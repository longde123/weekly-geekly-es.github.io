<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö± üë©üèº‚Äçüè≠ üëâüèº Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer üëø üë®‚Äçüë¶‚Äçüë¶ üîí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im sechsten Teil der √úbersetzung des Node.js-Handbuchs, werden wir √ºber die Ereignisschleife, den Aufrufstapel, die Funktion process.nextTick()...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Heute, im sechsten Teil der √úbersetzung des Node.js-Handbuchs, werden wir √ºber die Ereignisschleife, den Aufrufstapel, die Funktion <code>process.nextTick()</code> und Timer sprechen.  Das Verst√§ndnis dieser und anderer Node.js-Mechanismen ist einer der Eckpfeiler einer erfolgreichen Anwendungsentwicklung f√ºr diese Plattform. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ereignisschleife</font> </h2><br>  Wenn Sie verstehen m√∂chten, wie JavaScript-Code ausgef√ºhrt wird, ist die Ereignisschleife eines der wichtigsten Konzepte, die Sie verstehen m√ºssen.  Hier werden wir dar√ºber sprechen, wie JavaScript im Single-Threaded-Modus funktioniert und wie asynchrone Funktionen behandelt werden. <br><br>  Ich habe JavaScript seit vielen Jahren entwickelt, aber ich kann nicht sagen, dass ich vollst√§ndig verstanden habe, wie alles sozusagen "unter der Haube" funktioniert.  Dem Programmierer sind m√∂glicherweise die Feinheiten des Ger√§ts der internen Subsysteme der Umgebung, in der er arbeitet, nicht bekannt.  Aber es ist normalerweise n√ºtzlich, zumindest eine allgemeine Vorstellung von solchen Dingen zu haben. <br><br>  Der von Ihnen geschriebene JavaScript-Code wird im Single-Thread-Modus ausgef√ºhrt.  Zu einem bestimmten Zeitpunkt wird nur eine Aktion ausgef√ºhrt.  Diese Einschr√§nkung ist in der Tat sehr n√ºtzlich.  Dies vereinfacht die Arbeitsweise von Programmen erheblich und macht es f√ºr Programmierer unn√∂tig, Probleme zu l√∂sen, die f√ºr Multithread-Umgebungen spezifisch sind. <br><br>  Tats√§chlich muss ein JS-Programmierer nur genau darauf achten, welche Aktionen sein Code ausf√ºhrt, und versuchen, Situationen zu vermeiden, die zum Blockieren des Hauptthreads f√ºhren.  Zum Beispiel - Netzwerkanrufe im synchronen Modus und in endlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zyklen</a> . <br><br>  In der Regel haben Browser in jedem ge√∂ffneten Tab eine eigene Ereignisschleife.  Auf diese Weise k√∂nnen Sie den Code jeder Seite in einer isolierten Umgebung ausf√ºhren und Situationen vermeiden, in denen eine bestimmte Seite, in deren Code eine Endlosschleife vorhanden ist oder umfangreiche Berechnungen durchgef√ºhrt werden, den gesamten Browser "anhalten" kann.  Der Browser unterst√ºtzt die Arbeit vieler gleichzeitig vorhandener Ereignisschleifen, die beispielsweise zum Verarbeiten von Aufrufen an verschiedene APIs verwendet werden.  Dar√ºber hinaus wird eine propriet√§re Ereignisschleife zur Unterst√ºtzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Workern verwendet</a> . <br><br>  Das Wichtigste, an das sich ein JavaScript-Programmierer st√§ndig erinnern muss, ist, dass sein Code eine eigene Ereignisschleife verwendet. Daher muss der Code so geschrieben werden, dass diese Ereignisschleife nicht blockiert wird. <br><br><h2>  <font color="#3AC1EF">Ereignisschleifensperre</font> </h2><br>  Jeder JavaScript-Code, dessen Ausf√ºhrung zu lange dauert, dh Code, der die Ereignisschleife nicht zu lange kontrolliert, blockiert die Ausf√ºhrung eines anderen Seitencodes.  Dies f√ºhrt sogar dazu, dass die Verarbeitung von Benutzeroberfl√§chenereignissen blockiert wird. Dies spiegelt sich darin wider, dass der Benutzer nicht mit den Seitenelementen interagieren und normal damit arbeiten kann, z. B. beim Scrollen. <br><br>  Fast alle grundlegenden JavaScript-E / A-Mechanismen sind nicht blockierend.  Dies gilt sowohl f√ºr den Browser als auch f√ºr Node.js.  Unter solchen Mechanismen k√∂nnen wir beispielsweise die Tools zum Ausf√ºhren von Netzwerkanforderungen erw√§hnen, die sowohl in Client- als auch in Serverumgebungen verwendet werden, sowie Tools zum Arbeiten mit Node.js-Dateien.  Es gibt synchrone Methoden zum Ausf√ºhren solcher Operationen, die jedoch nur in besonderen F√§llen verwendet werden.  Aus diesem Grund sind traditionelle R√ºckrufe und neuere Mechanismen - Versprechen und das Konstrukt async / await - in JavaScript von gro√üer Bedeutung. <br><br><h2>  <font color="#3AC1EF">Stapel aufrufen</font> </h2><br>  Der JavaScript Call Stack basiert auf dem LIFO-Prinzip (Last In, First Out - Last In, First Out).  Die Ereignisschleife √ºberpr√ºft st√§ndig den Aufrufstapel, um festzustellen, ob eine Funktion ausgef√ºhrt werden muss.  Wenn beim Ausf√ºhren des Codes eine Funktion darin aufgerufen wird, werden Informationen dazu zum Aufrufstapel hinzugef√ºgt und diese Funktion ausgef√ºhrt. <br><br>  Wenn Sie sich schon vorher nicht f√ºr das Konzept eines ‚ÄûAufrufstapels‚Äú interessiert haben und dann auf Fehlermeldungen gesto√üen sind, die eine Stapelverfolgung enthalten, stellen Sie sich bereits vor, wie es aussieht.  Hier sieht es zum Beispiel in einem Browser so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Browser-Fehlermeldung</font></i> <br><br>  Wenn ein Fehler auftritt, meldet der Browser die Reihenfolge der Aufrufe von Funktionen, deren Informationen im Aufrufstapel gespeichert sind. Auf diese Weise k√∂nnen Sie die Fehlerquelle ermitteln und nachvollziehen, welche Aufrufe zu welchen Funktionen zur Situation gef√ºhrt haben. <br><br>  Nachdem wir nun allgemein √ºber die Ereignisschleife und den Aufrufstapel gesprochen haben, betrachten wir ein Beispiel, das die Ausf√ºhrung eines Codefragments veranschaulicht und wie dieser Prozess aus der Sicht der Ereignisschleife und des Aufrufstapels aussieht. <br><br><h2>  <font color="#3AC1EF">Ereignisschleife und Call Stack</font> </h2><br>  Hier ist der Code, mit dem wir experimentieren werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Wenn dieser Code ausgef√ºhrt wird, gelangt Folgendes zur Konsole: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Ein solches Ergebnis wird durchaus erwartet.  Wenn dieser Code ausgef√ºhrt wird, wird n√§mlich zuerst die Funktion <code>foo()</code> aufgerufen.  Innerhalb dieser Funktion rufen wir zuerst die Funktion <code>bar()</code> und dann die Funktion <code>baz()</code> .  Gleichzeitig erf√§hrt der Aufrufstapel w√§hrend der Ausf√ºhrung dieses Codes die in der folgenden Abbildung gezeigten √Ñnderungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">√Ñndern des Status des Aufrufstapels beim Ausf√ºhren des Codes</font></i> <br><br>  Die Ereignisschleife pr√ºft bei jeder Iteration, ob sich etwas im Aufrufstapel befindet, und wenn ja, bis der Aufrufstapel leer ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Ereignisschleifeniterationen</font></i> <br><br><h2>  <font color="#3AC1EF">Eine Funktion in die Warteschlange stellen</font> </h2><br>  Das obige Beispiel sieht ganz normal aus, es gibt nichts Besonderes: JavaScript findet den Code, der ausgef√ºhrt werden muss, und f√ºhrt ihn der Reihe nach aus.  Wir werden dar√ºber sprechen, wie die Funktionsausf√ºhrung verschoben werden kann, bis der Aufrufstapel gel√∂scht ist.  Zu diesem Zweck wird die folgende Konstruktion verwendet: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Sie k√∂nnen die an die Funktion <code>setTimeout()</code> Funktion ausf√ºhren, nachdem alle anderen im Programmcode aufgerufenen Funktionen ausgef√ºhrt wurden. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Was dieser Code druckt, kann unerwartet erscheinen: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Wenn wir dieses Beispiel ausf√ºhren, wird zuerst die Funktion <code>foo()</code> aufgerufen.  Darin rufen wir <code>setTimeout()</code> und √ºbergeben diese Funktion als erstes Argument <code>bar</code> .  Indem wir <code>0</code> als zweites Argument √ºbergeben, informieren wir das System, dass diese Funktion so schnell wie m√∂glich ausgef√ºhrt werden soll.  Dann rufen wir die Funktion <code>baz()</code> . <br><br>  So sieht der Aufrufstapel jetzt aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">√Ñndern des Status des Aufrufstapels bei der Ausf√ºhrung des untersuchten Codes</font></i> <br><br>  Hier ist die Reihenfolge, in der die Funktionen in unserem Programm jetzt ausgef√ºhrt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Ereignisschleifeniterationen</font></i> <br><br>  Warum passiert das so? <br><br><h2>  <font color="#3AC1EF">Ereigniswarteschlange</font> </h2><br>  Wenn die Funktion <code>setTimeout()</code> aufgerufen wird, startet der Browser oder die Node.js-Plattform einen Timer.  Nachdem der Timer funktioniert (in unserem Fall geschieht dies sofort, da wir ihn auf 0 gesetzt haben), wird die an <code>setTimeout()</code> R√ºckruffunktion in die Ereigniswarteschlange gestellt. <br><br>  Die Ereigniswarteschlange enth√§lt im Browser vom Benutzer initiierte Ereignisse - Ereignisse, die durch Mausklicks auf Seitenelemente verursacht werden, Ereignisse, die ausgel√∂st werden, wenn Daten √ºber die Tastatur eingegeben werden.  DOM- <code>onload</code> wie <code>onload</code> , Funktionen, die beim Empfang von Antworten auf asynchrone Anforderungen zum Laden von Daten aufgerufen werden, sind sofort <code>onload</code> .  Hier warten sie darauf, dass sie an die Reihe kommen. <br><br>  Die Ereignisschleife gibt dem, was sich auf dem Aufrufstapel befindet, Priorit√§t.  Zuerst macht es alles, was es auf dem Stapel findet, und nachdem der Stapel leer ist, verarbeitet es, was sich in der Ereigniswarteschlange befindet. <br><br>  Wir m√ºssen nicht warten, bis eine Funktion wie <code>setTimeout()</code> , da √§hnliche Funktionen vom Browser bereitgestellt werden und sie ihre eigenen Streams verwenden.  <code>setTimeout()</code> Sie beispielsweise den Timer mit der Funktion <code>setTimeout()</code> auf 2 Sekunden <code>setTimeout()</code> , sollten Sie nach dem Stoppen der Ausf√ºhrung eines anderen Codes nicht auf diese 2 Sekunden warten, da der Timer au√üerhalb Ihres Codes arbeitet. <br><br><h2>  <font color="#3AC1EF">ES6-Jobwarteschlange</font> </h2><br>  ECMAScript 2015 (ES6) f√ºhrte das Konzept der Job Queue ein, das von Versprechungen verwendet wird (sie erschienen auch in ES6).  Dank der Jobwarteschlange kann das Ergebnis der Ausf√ºhrung der asynchronen Funktion so schnell wie m√∂glich verwendet werden, ohne dass auf das L√∂schen des Aufrufstapels gewartet werden muss. <br><br>  Wenn ein Versprechen vor dem Ende der aktuellen Funktion aufgel√∂st wird, wird der entsprechende Code unmittelbar nach Abschluss der aktuellen Funktion ausgef√ºhrt. <br><br>  Ich habe eine interessante Analogie f√ºr das gefunden, wor√ºber wir sprechen.  Dies kann mit einer Achterbahn in einem Vergn√ºgungspark verglichen werden.  Nachdem Sie den H√ºgel gefahren sind und es erneut tun m√∂chten, nehmen Sie ein Ticket und steigen in die Warteschlange ein.  So funktioniert die Ereigniswarteschlange.  Die Jobwarteschlange sieht jedoch anders aus.  Dieses Konzept √§hnelt einem erm√§√üigten Ticket, mit dem Sie das Recht haben, die n√§chste Reise unmittelbar nach Beendigung der vorherigen zu unternehmen. <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Folgendes wird nach der Ausf√ºhrung ausgegeben: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Was Sie hier sehen k√∂nnen, zeigt einen gravierenden Unterschied zwischen Versprechungen (und dem darauf basierenden asynchronen / wartenden Konstrukt) und traditionellen asynchronen Funktionen, deren Ausf√ºhrung mithilfe von <code>setTimeout()</code> oder anderen APIs der verwendeten Plattform organisiert wird. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  Die Methode <code>process.nextTick()</code> interagiert auf besondere Weise mit der Ereignisschleife.  Ein Tick ist ein einzelner vollst√§ndiger Zyklus von Ereignissen.  Wenn wir die Funktion an die <code>process.nextTick()</code> -Methode √ºbergeben, informieren wir das System, dass diese Funktion aufgerufen werden muss, nachdem die aktuelle Iteration der Ereignisschleife abgeschlossen ist, bevor die n√§chste beginnt.  Die Verwendung dieser Methode sieht folgenderma√üen aus: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Angenommen, eine Ereignisschleife f√ºhrt gerade Code f√ºr die aktuelle Funktion aus.  Wenn dieser Vorgang abgeschlossen ist, f√ºhrt die JavaScript-Engine alle Funktionen aus, die w√§hrend des vorherigen Vorgangs an <code>process.nextTick()</code> wurden.  Mit diesem Mechanismus m√∂chten wir sicherstellen, dass eine bestimmte Funktion asynchron (nach der aktuellen Funktion) ausgef√ºhrt wird, jedoch so schnell wie m√∂glich, ohne sie in die Warteschlange zu stellen. <br><br>  Wenn Sie beispielsweise das <code>setTimeout(() =&gt; {}, 0)</code> verwenden, wird die Funktion bei der n√§chsten Iteration der Ereignisschleife ausgef√ºhrt, <code>setTimeout(() =&gt; {}, 0)</code> viel sp√§ter als wenn <code>process.nextTick()</code> in derselben Situation verwendet wird.  Diese Methode sollte verwendet werden, wenn die Ausf√ºhrung von Code zu Beginn der n√§chsten Iteration der Ereignisschleife sichergestellt werden muss. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Eine weitere von Node.js bereitgestellte Funktion f√ºr die asynchrone Codeausf√ºhrung ist <code>setImmediate()</code> .  So verwenden Sie es: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Die an <code>setImmediate()</code> R√ºckruffunktion wird bei der n√§chsten Iteration der Ereignisschleife ausgef√ºhrt. <br><br>  Wie unterscheidet sich <code>setImmediate()</code> von <code>setTimeout(() =&gt; {}, 0)</code> ( <code>setTimeout(() =&gt; {}, 0)</code> von einem Timer, der so schnell wie m√∂glich funktionieren sollte) und von <code>process.nextTick()</code> ? <br><br>  Die an <code>process.nextTick()</code> wird ausgef√ºhrt, nachdem die aktuelle Iteration der Ereignisschleife abgeschlossen wurde.  Das hei√üt, eine solche Funktion wird immer vor der Funktion ausgef√ºhrt, deren Ausf√ºhrung mit <code>setTimeout()</code> oder <code>setImmediate()</code> . <br><br>  Das Aufrufen der Funktion <code>setTimeout()</code> mit einer festgelegten Verz√∂gerung von 0 ms ist dem Aufrufen von <code>setImmediate()</code> sehr √§hnlich.  Die Reihenfolge der Ausf√ºhrung der an sie √ºbertragenen Funktionen h√§ngt von verschiedenen Faktoren ab. In beiden F√§llen werden jedoch bei der n√§chsten Iteration der Ereignisschleife R√ºckrufe aufgerufen. <br><br><h2>  <font color="#3AC1EF">Timer</font> </h2><br>  Wir haben bereits √ºber die Funktion <code>setTimeout()</code> , mit der Sie Aufrufe an die an sie √ºbergebenen R√ºckrufe planen k√∂nnen.  Nehmen wir uns etwas Zeit, um die Funktionen <code>setInterval()</code> zu beschreiben und eine andere √§hnliche Funktion, <code>setInterval()</code> , zu betrachten.  In Node.js sind Funktionen zum Arbeiten mit Timern im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timer-</a> Modul enthalten. Sie k√∂nnen sie jedoch verwenden, ohne dieses Modul im Code zu verbinden, da sie global sind. <br><br><h3>  <font color="#3AC1EF">‚ñç Funktion setTimeout ()</font> </h3><br>  Denken Sie daran, dass beim Aufrufen der Funktion <code>setTimeout()</code> ein R√ºckruf und die Uhrzeit in Millisekunden empfangen werden, nach der der R√ºckruf aufgerufen wird.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Hier √ºbergeben wir <code>setTimeout()</code> neue Funktion, die sofort beschrieben wird. Hier k√∂nnen wir die vorhandene Funktion verwenden, indem wir <code>setTimeout()</code> ihren Namen und eine Reihe von Parametern √ºbergeben, um sie auszuf√ºhren.  Es sieht so aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  Die Funktion <code>setTimeout()</code> gibt eine Timer- <code>setTimeout()</code> zur√ºck.  Normalerweise wird es nicht verwendet, aber Sie k√∂nnen es speichern und gegebenenfalls den Timer l√∂schen, wenn der geplante R√ºckruf nicht mehr ben√∂tigt wird: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Keine Verz√∂gerung</font> </h3><br>  In den vorherigen Abschnitten haben wir <code>setTimeout()</code> und es als die Zeit √ºbergeben, nach der der R√ºckruf <code>0</code> aufgerufen werden muss.  Dies bedeutete, dass der R√ºckruf so schnell wie m√∂glich aufgerufen wurde, jedoch nach Abschluss der aktuellen Funktion: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Ein solcher Code gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Diese Technik ist besonders n√ºtzlich in Situationen, in denen ich bei der Ausf√ºhrung schwerer Rechenaufgaben den Hauptthread nicht blockieren m√∂chte, um die Ausf√ºhrung anderer Funktionen zu erm√∂glichen und diese Aufgaben in mehrere Stufen zu unterteilen, die als <code>setTimeout()</code> -Aufrufe ausgef√ºhrt werden. <br><br>  Wenn wir uns an die obige Funktion <code>setImmediate()</code> erinnern, ist sie in Node.js Standard, was nicht √ºber Browser gesagt werden kann (sie ist in IE und Edge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert</a> , aber nicht in anderen). <br><br><h3>  <font color="#3AC1EF">‚ñç Funktion setInterval ()</font> </h3><br>  Die Funktion <code>setInterval()</code> √§hnelt <code>setTimeout()</code> , es gibt jedoch Unterschiede zwischen ihnen.  Anstatt den an ihn √ºbergebenen R√ºckruf einmal <code>setInterval()</code> , <code>setInterval()</code> diesen R√ºckruf regelm√§√üig mit dem angegebenen Intervall auf.  Dies wird im Idealfall so lange fortgesetzt, bis der Programmierer diesen Prozess explizit stoppt.  So verwenden Sie diese Funktion: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Ein an die oben gezeigte Funktion √ºbergebener R√ºckruf wird alle 2 Sekunden aufgerufen.  Um die M√∂glichkeit zu bieten, diesen Prozess zu stoppen, m√ºssen Sie die von <code>setInterval()</code> Timer- <code>setInterval()</code> und den Befehl <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Eine √ºbliche Technik besteht darin, <code>clearInterval()</code> innerhalb des an <code>setInterval()</code> R√ºckrufs <code>setInterval()</code> wenn eine bestimmte Bedingung erf√ºllt ist.  Der folgende Code wird beispielsweise regelm√§√üig ausgef√ºhrt, bis die <code>App.somethingIWait</code> Eigenschaft auf " <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Rekursive Einstellung setTimeout ()</font> </h3><br>  Die Funktion <code>setInterval()</code> ruft den an sie √ºbergebenen R√ºckruf alle <code>n</code> Millisekunden auf, ohne sich Gedanken dar√ºber zu machen, ob dieser R√ºckruf nach dem vorherigen Aufruf abgeschlossen wurde. <br><br>  Wenn jeder Aufruf dieses R√ºckrufs immer dieselbe Zeit von weniger als <code>n</code> , treten hier keine Probleme auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Periodisch aufgerufene R√ºckruf, deren Ausf√ºhrungssitzung dieselbe Zeit in Anspruch nimmt und in das Intervall zwischen den Aufrufen f√§llt</font></i> <br><br>  M√∂glicherweise dauert es eine andere Zeit, um einen R√ºckruf abzuschlie√üen, der immer noch kleiner als <code>n</code> .  Wenn wir zum Beispiel √ºber die Durchf√ºhrung bestimmter Netzwerkoperationen sprechen, ist diese Situation durchaus zu erwarten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Periodisch aufgerufene R√ºckruf, deren Ausf√ºhrungssitzung eine andere Zeit in Anspruch nimmt und zwischen den Aufrufen liegt</font></i> <br><br>  Bei Verwendung von <code>setInterval()</code> kann es vorkommen, dass der R√ºckruf l√§nger als <code>n</code> dauert, was dazu f√ºhrt, dass der n√§chste Aufruf abgeschlossen wird, bevor der vorherige abgeschlossen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">R√ºckruf in regelm√§√üigen Abst√§nden, wobei jede Sitzung eine andere Zeit ben√∂tigt, was manchmal nicht in das Intervall zwischen den Anrufen passt</font></i> <br><br>  Um diese Situation zu vermeiden, k√∂nnen Sie die rekursive Timer-Einstellungstechnik mit <code>setTimeout()</code> .  Der Punkt ist, dass der n√§chste R√ºckruf nach Abschluss des vorherigen Anrufs geplant ist: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Mit diesem Ansatz kann das folgende Szenario implementiert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Ein rekursiver Aufruf von setTimeout (), um die Ausf√ºhrung von R√ºckrufen zu planen</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir √ºber die internen Mechanismen von Node.js gesprochen, wie z. B. die Ereignisschleife, den Aufrufstapel, und die Arbeit mit Timern besprochen, mit denen Sie die Codeausf√ºhrung planen k√∂nnen.  Das n√§chste Mal werden wir uns mit dem Thema asynchrone Programmierung befassen. <br><br>  <b>Liebe Leser!</b>  Sind Sie auf Situationen gesto√üen, in denen Sie process.nextTick () verwenden mussten? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424553/">https://habr.com/ru/post/de424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424537/index.html">Die Sberbank hat ihren eigenen Betreiber SberMobile gegr√ºndet</a></li>
<li><a href="../de424539/index.html">Java 11: neu in String</a></li>
<li><a href="../de424541/index.html">UGJ 2018 Fiasko-Geschichte: Wie man ein Spiel macht, das niemand mag (tu es nicht!)</a></li>
<li><a href="../de424543/index.html">Java 11 / JDK 11: Allgemeine Verf√ºgbarkeit</a></li>
<li><a href="../de424551/index.html">Warm and Tube: F√ºnf Balalaikas √ºber magnetische Audiotechnologie</a></li>
<li><a href="../de424555/index.html">Node.js Handbuch, Teil 7: Asynchrone Programmierung</a></li>
<li><a href="../de424557/index.html">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a></li>
<li><a href="../de424559/index.html">Big Data Resistance 1 oder schwer fassbarer Joe. Internet-Anonymit√§t, Anti-Erkennung, Anti-Tracking f√ºr Anti-Sie und Anti-uns</a></li>
<li><a href="../de424563/index.html">Beeline sendet Einzelheiten zu Gespr√§chen an Fremde</a></li>
<li><a href="../de424565/index.html">√úbersicht: 3D-Scannen von Immobilien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>