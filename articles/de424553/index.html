<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👩🏼‍🏭 👉🏼 Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer 👿 👨‍👦‍👦 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im sechsten Teil der Übersetzung des Node.js-Handbuchs, werden wir über die Ereignisschleife, den Aufrufstapel, die Funktion process.nextTick()...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Heute, im sechsten Teil der Übersetzung des Node.js-Handbuchs, werden wir über die Ereignisschleife, den Aufrufstapel, die Funktion <code>process.nextTick()</code> und Timer sprechen.  Das Verständnis dieser und anderer Node.js-Mechanismen ist einer der Eckpfeiler einer erfolgreichen Anwendungsentwicklung für diese Plattform. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ereignisschleife</font> </h2><br>  Wenn Sie verstehen möchten, wie JavaScript-Code ausgeführt wird, ist die Ereignisschleife eines der wichtigsten Konzepte, die Sie verstehen müssen.  Hier werden wir darüber sprechen, wie JavaScript im Single-Threaded-Modus funktioniert und wie asynchrone Funktionen behandelt werden. <br><br>  Ich habe JavaScript seit vielen Jahren entwickelt, aber ich kann nicht sagen, dass ich vollständig verstanden habe, wie alles sozusagen "unter der Haube" funktioniert.  Dem Programmierer sind möglicherweise die Feinheiten des Geräts der internen Subsysteme der Umgebung, in der er arbeitet, nicht bekannt.  Aber es ist normalerweise nützlich, zumindest eine allgemeine Vorstellung von solchen Dingen zu haben. <br><br>  Der von Ihnen geschriebene JavaScript-Code wird im Single-Thread-Modus ausgeführt.  Zu einem bestimmten Zeitpunkt wird nur eine Aktion ausgeführt.  Diese Einschränkung ist in der Tat sehr nützlich.  Dies vereinfacht die Arbeitsweise von Programmen erheblich und macht es für Programmierer unnötig, Probleme zu lösen, die für Multithread-Umgebungen spezifisch sind. <br><br>  Tatsächlich muss ein JS-Programmierer nur genau darauf achten, welche Aktionen sein Code ausführt, und versuchen, Situationen zu vermeiden, die zum Blockieren des Hauptthreads führen.  Zum Beispiel - Netzwerkanrufe im synchronen Modus und in endlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zyklen</a> . <br><br>  In der Regel haben Browser in jedem geöffneten Tab eine eigene Ereignisschleife.  Auf diese Weise können Sie den Code jeder Seite in einer isolierten Umgebung ausführen und Situationen vermeiden, in denen eine bestimmte Seite, in deren Code eine Endlosschleife vorhanden ist oder umfangreiche Berechnungen durchgeführt werden, den gesamten Browser "anhalten" kann.  Der Browser unterstützt die Arbeit vieler gleichzeitig vorhandener Ereignisschleifen, die beispielsweise zum Verarbeiten von Aufrufen an verschiedene APIs verwendet werden.  Darüber hinaus wird eine proprietäre Ereignisschleife zur Unterstützung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Workern verwendet</a> . <br><br>  Das Wichtigste, an das sich ein JavaScript-Programmierer ständig erinnern muss, ist, dass sein Code eine eigene Ereignisschleife verwendet. Daher muss der Code so geschrieben werden, dass diese Ereignisschleife nicht blockiert wird. <br><br><h2>  <font color="#3AC1EF">Ereignisschleifensperre</font> </h2><br>  Jeder JavaScript-Code, dessen Ausführung zu lange dauert, dh Code, der die Ereignisschleife nicht zu lange kontrolliert, blockiert die Ausführung eines anderen Seitencodes.  Dies führt sogar dazu, dass die Verarbeitung von Benutzeroberflächenereignissen blockiert wird. Dies spiegelt sich darin wider, dass der Benutzer nicht mit den Seitenelementen interagieren und normal damit arbeiten kann, z. B. beim Scrollen. <br><br>  Fast alle grundlegenden JavaScript-E / A-Mechanismen sind nicht blockierend.  Dies gilt sowohl für den Browser als auch für Node.js.  Unter solchen Mechanismen können wir beispielsweise die Tools zum Ausführen von Netzwerkanforderungen erwähnen, die sowohl in Client- als auch in Serverumgebungen verwendet werden, sowie Tools zum Arbeiten mit Node.js-Dateien.  Es gibt synchrone Methoden zum Ausführen solcher Operationen, die jedoch nur in besonderen Fällen verwendet werden.  Aus diesem Grund sind traditionelle Rückrufe und neuere Mechanismen - Versprechen und das Konstrukt async / await - in JavaScript von großer Bedeutung. <br><br><h2>  <font color="#3AC1EF">Stapel aufrufen</font> </h2><br>  Der JavaScript Call Stack basiert auf dem LIFO-Prinzip (Last In, First Out - Last In, First Out).  Die Ereignisschleife überprüft ständig den Aufrufstapel, um festzustellen, ob eine Funktion ausgeführt werden muss.  Wenn beim Ausführen des Codes eine Funktion darin aufgerufen wird, werden Informationen dazu zum Aufrufstapel hinzugefügt und diese Funktion ausgeführt. <br><br>  Wenn Sie sich schon vorher nicht für das Konzept eines „Aufrufstapels“ interessiert haben und dann auf Fehlermeldungen gestoßen sind, die eine Stapelverfolgung enthalten, stellen Sie sich bereits vor, wie es aussieht.  Hier sieht es zum Beispiel in einem Browser so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Browser-Fehlermeldung</font></i> <br><br>  Wenn ein Fehler auftritt, meldet der Browser die Reihenfolge der Aufrufe von Funktionen, deren Informationen im Aufrufstapel gespeichert sind. Auf diese Weise können Sie die Fehlerquelle ermitteln und nachvollziehen, welche Aufrufe zu welchen Funktionen zur Situation geführt haben. <br><br>  Nachdem wir nun allgemein über die Ereignisschleife und den Aufrufstapel gesprochen haben, betrachten wir ein Beispiel, das die Ausführung eines Codefragments veranschaulicht und wie dieser Prozess aus der Sicht der Ereignisschleife und des Aufrufstapels aussieht. <br><br><h2>  <font color="#3AC1EF">Ereignisschleife und Call Stack</font> </h2><br>  Hier ist der Code, mit dem wir experimentieren werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Wenn dieser Code ausgeführt wird, gelangt Folgendes zur Konsole: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Ein solches Ergebnis wird durchaus erwartet.  Wenn dieser Code ausgeführt wird, wird nämlich zuerst die Funktion <code>foo()</code> aufgerufen.  Innerhalb dieser Funktion rufen wir zuerst die Funktion <code>bar()</code> und dann die Funktion <code>baz()</code> .  Gleichzeitig erfährt der Aufrufstapel während der Ausführung dieses Codes die in der folgenden Abbildung gezeigten Änderungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Ändern des Status des Aufrufstapels beim Ausführen des Codes</font></i> <br><br>  Die Ereignisschleife prüft bei jeder Iteration, ob sich etwas im Aufrufstapel befindet, und wenn ja, bis der Aufrufstapel leer ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Ereignisschleifeniterationen</font></i> <br><br><h2>  <font color="#3AC1EF">Eine Funktion in die Warteschlange stellen</font> </h2><br>  Das obige Beispiel sieht ganz normal aus, es gibt nichts Besonderes: JavaScript findet den Code, der ausgeführt werden muss, und führt ihn der Reihe nach aus.  Wir werden darüber sprechen, wie die Funktionsausführung verschoben werden kann, bis der Aufrufstapel gelöscht ist.  Zu diesem Zweck wird die folgende Konstruktion verwendet: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Sie können die an die Funktion <code>setTimeout()</code> Funktion ausführen, nachdem alle anderen im Programmcode aufgerufenen Funktionen ausgeführt wurden. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Was dieser Code druckt, kann unerwartet erscheinen: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Wenn wir dieses Beispiel ausführen, wird zuerst die Funktion <code>foo()</code> aufgerufen.  Darin rufen wir <code>setTimeout()</code> und übergeben diese Funktion als erstes Argument <code>bar</code> .  Indem wir <code>0</code> als zweites Argument übergeben, informieren wir das System, dass diese Funktion so schnell wie möglich ausgeführt werden soll.  Dann rufen wir die Funktion <code>baz()</code> . <br><br>  So sieht der Aufrufstapel jetzt aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Ändern des Status des Aufrufstapels bei der Ausführung des untersuchten Codes</font></i> <br><br>  Hier ist die Reihenfolge, in der die Funktionen in unserem Programm jetzt ausgeführt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Ereignisschleifeniterationen</font></i> <br><br>  Warum passiert das so? <br><br><h2>  <font color="#3AC1EF">Ereigniswarteschlange</font> </h2><br>  Wenn die Funktion <code>setTimeout()</code> aufgerufen wird, startet der Browser oder die Node.js-Plattform einen Timer.  Nachdem der Timer funktioniert (in unserem Fall geschieht dies sofort, da wir ihn auf 0 gesetzt haben), wird die an <code>setTimeout()</code> Rückruffunktion in die Ereigniswarteschlange gestellt. <br><br>  Die Ereigniswarteschlange enthält im Browser vom Benutzer initiierte Ereignisse - Ereignisse, die durch Mausklicks auf Seitenelemente verursacht werden, Ereignisse, die ausgelöst werden, wenn Daten über die Tastatur eingegeben werden.  DOM- <code>onload</code> wie <code>onload</code> , Funktionen, die beim Empfang von Antworten auf asynchrone Anforderungen zum Laden von Daten aufgerufen werden, sind sofort <code>onload</code> .  Hier warten sie darauf, dass sie an die Reihe kommen. <br><br>  Die Ereignisschleife gibt dem, was sich auf dem Aufrufstapel befindet, Priorität.  Zuerst macht es alles, was es auf dem Stapel findet, und nachdem der Stapel leer ist, verarbeitet es, was sich in der Ereigniswarteschlange befindet. <br><br>  Wir müssen nicht warten, bis eine Funktion wie <code>setTimeout()</code> , da ähnliche Funktionen vom Browser bereitgestellt werden und sie ihre eigenen Streams verwenden.  <code>setTimeout()</code> Sie beispielsweise den Timer mit der Funktion <code>setTimeout()</code> auf 2 Sekunden <code>setTimeout()</code> , sollten Sie nach dem Stoppen der Ausführung eines anderen Codes nicht auf diese 2 Sekunden warten, da der Timer außerhalb Ihres Codes arbeitet. <br><br><h2>  <font color="#3AC1EF">ES6-Jobwarteschlange</font> </h2><br>  ECMAScript 2015 (ES6) führte das Konzept der Job Queue ein, das von Versprechungen verwendet wird (sie erschienen auch in ES6).  Dank der Jobwarteschlange kann das Ergebnis der Ausführung der asynchronen Funktion so schnell wie möglich verwendet werden, ohne dass auf das Löschen des Aufrufstapels gewartet werden muss. <br><br>  Wenn ein Versprechen vor dem Ende der aktuellen Funktion aufgelöst wird, wird der entsprechende Code unmittelbar nach Abschluss der aktuellen Funktion ausgeführt. <br><br>  Ich habe eine interessante Analogie für das gefunden, worüber wir sprechen.  Dies kann mit einer Achterbahn in einem Vergnügungspark verglichen werden.  Nachdem Sie den Hügel gefahren sind und es erneut tun möchten, nehmen Sie ein Ticket und steigen in die Warteschlange ein.  So funktioniert die Ereigniswarteschlange.  Die Jobwarteschlange sieht jedoch anders aus.  Dieses Konzept ähnelt einem ermäßigten Ticket, mit dem Sie das Recht haben, die nächste Reise unmittelbar nach Beendigung der vorherigen zu unternehmen. <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Folgendes wird nach der Ausführung ausgegeben: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Was Sie hier sehen können, zeigt einen gravierenden Unterschied zwischen Versprechungen (und dem darauf basierenden asynchronen / wartenden Konstrukt) und traditionellen asynchronen Funktionen, deren Ausführung mithilfe von <code>setTimeout()</code> oder anderen APIs der verwendeten Plattform organisiert wird. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  Die Methode <code>process.nextTick()</code> interagiert auf besondere Weise mit der Ereignisschleife.  Ein Tick ist ein einzelner vollständiger Zyklus von Ereignissen.  Wenn wir die Funktion an die <code>process.nextTick()</code> -Methode übergeben, informieren wir das System, dass diese Funktion aufgerufen werden muss, nachdem die aktuelle Iteration der Ereignisschleife abgeschlossen ist, bevor die nächste beginnt.  Die Verwendung dieser Methode sieht folgendermaßen aus: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Angenommen, eine Ereignisschleife führt gerade Code für die aktuelle Funktion aus.  Wenn dieser Vorgang abgeschlossen ist, führt die JavaScript-Engine alle Funktionen aus, die während des vorherigen Vorgangs an <code>process.nextTick()</code> wurden.  Mit diesem Mechanismus möchten wir sicherstellen, dass eine bestimmte Funktion asynchron (nach der aktuellen Funktion) ausgeführt wird, jedoch so schnell wie möglich, ohne sie in die Warteschlange zu stellen. <br><br>  Wenn Sie beispielsweise das <code>setTimeout(() =&gt; {}, 0)</code> verwenden, wird die Funktion bei der nächsten Iteration der Ereignisschleife ausgeführt, <code>setTimeout(() =&gt; {}, 0)</code> viel später als wenn <code>process.nextTick()</code> in derselben Situation verwendet wird.  Diese Methode sollte verwendet werden, wenn die Ausführung von Code zu Beginn der nächsten Iteration der Ereignisschleife sichergestellt werden muss. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Eine weitere von Node.js bereitgestellte Funktion für die asynchrone Codeausführung ist <code>setImmediate()</code> .  So verwenden Sie es: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Die an <code>setImmediate()</code> Rückruffunktion wird bei der nächsten Iteration der Ereignisschleife ausgeführt. <br><br>  Wie unterscheidet sich <code>setImmediate()</code> von <code>setTimeout(() =&gt; {}, 0)</code> ( <code>setTimeout(() =&gt; {}, 0)</code> von einem Timer, der so schnell wie möglich funktionieren sollte) und von <code>process.nextTick()</code> ? <br><br>  Die an <code>process.nextTick()</code> wird ausgeführt, nachdem die aktuelle Iteration der Ereignisschleife abgeschlossen wurde.  Das heißt, eine solche Funktion wird immer vor der Funktion ausgeführt, deren Ausführung mit <code>setTimeout()</code> oder <code>setImmediate()</code> . <br><br>  Das Aufrufen der Funktion <code>setTimeout()</code> mit einer festgelegten Verzögerung von 0 ms ist dem Aufrufen von <code>setImmediate()</code> sehr ähnlich.  Die Reihenfolge der Ausführung der an sie übertragenen Funktionen hängt von verschiedenen Faktoren ab. In beiden Fällen werden jedoch bei der nächsten Iteration der Ereignisschleife Rückrufe aufgerufen. <br><br><h2>  <font color="#3AC1EF">Timer</font> </h2><br>  Wir haben bereits über die Funktion <code>setTimeout()</code> , mit der Sie Aufrufe an die an sie übergebenen Rückrufe planen können.  Nehmen wir uns etwas Zeit, um die Funktionen <code>setInterval()</code> zu beschreiben und eine andere ähnliche Funktion, <code>setInterval()</code> , zu betrachten.  In Node.js sind Funktionen zum Arbeiten mit Timern im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timer-</a> Modul enthalten. Sie können sie jedoch verwenden, ohne dieses Modul im Code zu verbinden, da sie global sind. <br><br><h3>  <font color="#3AC1EF">▍ Funktion setTimeout ()</font> </h3><br>  Denken Sie daran, dass beim Aufrufen der Funktion <code>setTimeout()</code> ein Rückruf und die Uhrzeit in Millisekunden empfangen werden, nach der der Rückruf aufgerufen wird.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Hier übergeben wir <code>setTimeout()</code> neue Funktion, die sofort beschrieben wird. Hier können wir die vorhandene Funktion verwenden, indem wir <code>setTimeout()</code> ihren Namen und eine Reihe von Parametern übergeben, um sie auszuführen.  Es sieht so aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  Die Funktion <code>setTimeout()</code> gibt eine Timer- <code>setTimeout()</code> zurück.  Normalerweise wird es nicht verwendet, aber Sie können es speichern und gegebenenfalls den Timer löschen, wenn der geplante Rückruf nicht mehr benötigt wird: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Keine Verzögerung</font> </h3><br>  In den vorherigen Abschnitten haben wir <code>setTimeout()</code> und es als die Zeit übergeben, nach der der Rückruf <code>0</code> aufgerufen werden muss.  Dies bedeutete, dass der Rückruf so schnell wie möglich aufgerufen wurde, jedoch nach Abschluss der aktuellen Funktion: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Ein solcher Code gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Diese Technik ist besonders nützlich in Situationen, in denen ich bei der Ausführung schwerer Rechenaufgaben den Hauptthread nicht blockieren möchte, um die Ausführung anderer Funktionen zu ermöglichen und diese Aufgaben in mehrere Stufen zu unterteilen, die als <code>setTimeout()</code> -Aufrufe ausgeführt werden. <br><br>  Wenn wir uns an die obige Funktion <code>setImmediate()</code> erinnern, ist sie in Node.js Standard, was nicht über Browser gesagt werden kann (sie ist in IE und Edge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert</a> , aber nicht in anderen). <br><br><h3>  <font color="#3AC1EF">▍ Funktion setInterval ()</font> </h3><br>  Die Funktion <code>setInterval()</code> ähnelt <code>setTimeout()</code> , es gibt jedoch Unterschiede zwischen ihnen.  Anstatt den an ihn übergebenen Rückruf einmal <code>setInterval()</code> , <code>setInterval()</code> diesen Rückruf regelmäßig mit dem angegebenen Intervall auf.  Dies wird im Idealfall so lange fortgesetzt, bis der Programmierer diesen Prozess explizit stoppt.  So verwenden Sie diese Funktion: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Ein an die oben gezeigte Funktion übergebener Rückruf wird alle 2 Sekunden aufgerufen.  Um die Möglichkeit zu bieten, diesen Prozess zu stoppen, müssen Sie die von <code>setInterval()</code> Timer- <code>setInterval()</code> und den Befehl <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Eine übliche Technik besteht darin, <code>clearInterval()</code> innerhalb des an <code>setInterval()</code> Rückrufs <code>setInterval()</code> wenn eine bestimmte Bedingung erfüllt ist.  Der folgende Code wird beispielsweise regelmäßig ausgeführt, bis die <code>App.somethingIWait</code> Eigenschaft auf " <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Rekursive Einstellung setTimeout ()</font> </h3><br>  Die Funktion <code>setInterval()</code> ruft den an sie übergebenen Rückruf alle <code>n</code> Millisekunden auf, ohne sich Gedanken darüber zu machen, ob dieser Rückruf nach dem vorherigen Aufruf abgeschlossen wurde. <br><br>  Wenn jeder Aufruf dieses Rückrufs immer dieselbe Zeit von weniger als <code>n</code> , treten hier keine Probleme auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Periodisch aufgerufene Rückruf, deren Ausführungssitzung dieselbe Zeit in Anspruch nimmt und in das Intervall zwischen den Aufrufen fällt</font></i> <br><br>  Möglicherweise dauert es eine andere Zeit, um einen Rückruf abzuschließen, der immer noch kleiner als <code>n</code> .  Wenn wir zum Beispiel über die Durchführung bestimmter Netzwerkoperationen sprechen, ist diese Situation durchaus zu erwarten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Periodisch aufgerufene Rückruf, deren Ausführungssitzung eine andere Zeit in Anspruch nimmt und zwischen den Aufrufen liegt</font></i> <br><br>  Bei Verwendung von <code>setInterval()</code> kann es vorkommen, dass der Rückruf länger als <code>n</code> dauert, was dazu führt, dass der nächste Aufruf abgeschlossen wird, bevor der vorherige abgeschlossen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Rückruf in regelmäßigen Abständen, wobei jede Sitzung eine andere Zeit benötigt, was manchmal nicht in das Intervall zwischen den Anrufen passt</font></i> <br><br>  Um diese Situation zu vermeiden, können Sie die rekursive Timer-Einstellungstechnik mit <code>setTimeout()</code> .  Der Punkt ist, dass der nächste Rückruf nach Abschluss des vorherigen Anrufs geplant ist: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Mit diesem Ansatz kann das folgende Szenario implementiert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Ein rekursiver Aufruf von setTimeout (), um die Ausführung von Rückrufen zu planen</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir über die internen Mechanismen von Node.js gesprochen, wie z. B. die Ereignisschleife, den Aufrufstapel, und die Arbeit mit Timern besprochen, mit denen Sie die Codeausführung planen können.  Das nächste Mal werden wir uns mit dem Thema asynchrone Programmierung befassen. <br><br>  <b>Liebe Leser!</b>  Sind Sie auf Situationen gestoßen, in denen Sie process.nextTick () verwenden mussten? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424553/">https://habr.com/ru/post/de424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424537/index.html">Die Sberbank hat ihren eigenen Betreiber SberMobile gegründet</a></li>
<li><a href="../de424539/index.html">Java 11: neu in String</a></li>
<li><a href="../de424541/index.html">UGJ 2018 Fiasko-Geschichte: Wie man ein Spiel macht, das niemand mag (tu es nicht!)</a></li>
<li><a href="../de424543/index.html">Java 11 / JDK 11: Allgemeine Verfügbarkeit</a></li>
<li><a href="../de424551/index.html">Warm and Tube: Fünf Balalaikas über magnetische Audiotechnologie</a></li>
<li><a href="../de424555/index.html">Node.js Handbuch, Teil 7: Asynchrone Programmierung</a></li>
<li><a href="../de424557/index.html">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a></li>
<li><a href="../de424559/index.html">Big Data Resistance 1 oder schwer fassbarer Joe. Internet-Anonymität, Anti-Erkennung, Anti-Tracking für Anti-Sie und Anti-uns</a></li>
<li><a href="../de424563/index.html">Beeline sendet Einzelheiten zu Gesprächen an Fremde</a></li>
<li><a href="../de424565/index.html">Übersicht: 3D-Scannen von Immobilien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>