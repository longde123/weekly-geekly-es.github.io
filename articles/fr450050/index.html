<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚥 🙎🏿 👳🏿 Les bases de la programmation réactive à l'aide de RxJS. Partie 3. Observables d'ordre supérieur 🤟🏾 👩🏼 👶🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous verrons comment il est possible d'en traiter un autre dans un même fil, pourquoi il est nécessaire et comment les opérateurs ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les bases de la programmation réactive à l'aide de RxJS. Partie 3. Observables d'ordre supérieur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450050/"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  Dans cet article, nous verrons comment il est possible d'en traiter un autre dans un même fil, pourquoi il est nécessaire et comment les opérateurs observables d'ordre supérieur (ci-après dénommés HOO) nous aideront à cet égard. <br><br>  Série d'articles "Fondamentaux de la programmation réactive utilisant RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1. Réactivité et flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Opérateurs et tuyaux</a> </li></ul><br><br>  Lorsque vous travaillez avec des threads, une situation survient souvent lorsqu'il est nécessaire de transférer les résultats d'un autre sur un thread en tant que valeur.  Par exemple, nous voulons exécuter une requête ajax et traiter sa réponse dans le thread actuel, ou exécuter plusieurs requêtes parallèles, implémenter le pooling.  Je pense que beaucoup de gens sont habitués à résoudre de tels problèmes en utilisant un mécanisme tel que la promesse.  Mais est-il possible de les résoudre en utilisant RxJS?  Bien sûr, et tout est beaucoup plus facile que vous ne le pensez! <br><a name="habracut"></a><br>  <b>Remarque</b> : pour comprendre la partie théorique de l'article, il n'est pas nécessaire de lire les articles précédents, il suffit de savoir ce que l'on peut observer, les opérateurs et les tuyaux.  Dans la partie pratique, nous affinerons l'exemple du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième article</a> , que vous pouvez trouver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> . <br><br><h4>  Le problème </h4><br>  Imaginons la tâche suivante: nous devons savoir à chaque seconde si le serveur est accessible.  Comment pouvons-nous le résoudre? <br><br>  Créez d'abord un flux à l'aide de la méthode du minuteur: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  La méthode de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">minuterie</a> est très similaire en principe à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">intervalle</a> .  Mais contrairement à cela, il vous permet de définir le délai de démarrage du thread, qui est transmis par le premier paramètre.  Le deuxième paramètre indique l'intervalle pendant lequel une nouvelle valeur sera générée.  Si le deuxième paramètre n'est pas spécifié, le temporisateur ne générera qu'une seule valeur et terminera le flux. <br><br>  Comme vous et moi n'avons pas de serveur, je vous suggère d'écrire simplement une fonction qui émule une demande au serveur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  Que fait cette méthode?  Il renvoie un flux créé à l'aide de la méthode timer, qui émet une valeur après une seconde et se termine.  Étant donné que la méthode timer ne génère qu'un nombre, nous utilisons l'opérateur mapTo pour le remplacer par la chaîne «success». <br><br>  Voici à quoi ressemble le flux créé par la méthode makeRequest: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Nous avons maintenant le choix: appeler la méthode makeRequest à l'intérieur du flux ou assigner cette responsabilité à l'observateur? <br><br>  La première approche est préférable, car dans ce cas, nous pourrons utiliser tout le potentiel de RxJS avec ses opérateurs et décharger notre observateur de tâches inutiles.  Nous utilisons la méthode timer pour exécuter les requêtes par intervalle: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Lorsque nous exécutons un tel code, nous verrons que dans console.log, nous n'obtenons pas un message avec le texte «success», mais un objet de type Observable: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  La réponse est tout à fait attendue, car dans la carte, nous renvoyons le flux.  Pour qu'un flux fonctionne, vous devez vous y abonner.  Eh bien, voyons comment <b>ne pas le faire</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  Le problème avec l'exemple ci-dessus est que nous obtenons un abonnement dans un abonnement.  Mais que se passe-t-il si nous voulons faire plus d'une demande dans une chaîne?  Ou si, à un moment donné, nous devons nous désinscrire du flux interne?  Dans ce cas, notre code ressemblera de plus en plus à des «nouilles».  Pour résoudre ce problème, RxJS a des opérateurs spéciaux appelés HOO. <br><br><h4>  Hoo </h4><br>  HOO est un type spécial d'instructions qui acceptent les flux comme valeurs.  Un tel opérateur est la méthode mergeAll. <br><br>  Lorsqu'un flux arrive à mergeAll, il y souscrit.  Le flux auquel l'opérateur s'est abonné est appelé interne.  Le flux à partir duquel l'opérateur reçoit d'autres flux sous forme de valeurs est appelé externe. <br><br>  Lorsqu'un thread interne génère une valeur, mergeAll pousse cette valeur dans le thread externe.  Ainsi, on se débarrasse de la nécessité de s'abonner manuellement.  Si nous nous désabonnons du flux externe, alors mergeAll se désabonnera automatiquement du flux interne. <br><br>  Voyons comment réécrire notre exemple avec mergeAll: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Dans l'exemple ci-dessus, le flux externe a été créé par l'instruction timer.  Et les flux créés dans l'opérateur de carte sont internes.  Chaque thread créé tombe dans l'instruction mergeAll. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  La combinaison map + mergeAll est utilisée très souvent, donc dans RxJS il y a une méthode mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Lorsqu'un thread externe génère une valeur, l'opérateur mergeMap appelle la fonction de rappel qui lui est transmise, ce qui génère un nouveau thread.  MergeMap s'abonne ensuite au flux généré. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  La particularité de l'opérateur mergeAll / mergeMap est que si un autre flux lui revient, il y souscrit également.  Ainsi, dans un flux externe, nous pouvons obtenir des valeurs de plusieurs internes à la fois.  Voyons l'exemple suivant: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  Voici à quoi ressemblera le flux externe sans l'opérateur mergeMap: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  Et donc avec mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Chaque seconde, nous créons un nouveau thread interne et mergeMap s'y abonne.  Ainsi, nous avons de nombreux threads internes travaillant simultanément, dont les valeurs tombent dans l'externe: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Remarque</b> : soyez prudent en utilisant mergeMap, chaque nouveau thread interne fonctionnera jusqu'à ce que vous vous désabonniez du externe.  Dans l'exemple ci-dessus, le nombre de threads internes augmente chaque seconde, au final, il peut y avoir tellement de threads que l'ordinateur ne peut pas faire face à la charge. <br><br><h4>  concatAll / concatMap </h4><br>  La méthode mergeMap est idéale lorsque vous ne vous souciez pas de l'ordre d'exécution des threads internes, mais qu'en est-il si vous en avez besoin?  Supposons que nous voulons que la prochaine requête de serveur soit exécutée uniquement après avoir reçu une réponse de la précédente? <br><br>  À ces fins, l'opérateur HOO concatAll / concatMap convient.  Cet opérateur, ayant souscrit au thread interne, attend jusqu'à ce qu'il se termine, puis seulement s'abonne au suivant. <br><br>  Si pendant l'exécution d'un thread, un nouveau descend, il est placé dans la file d'attente jusqu'à ce que le précédent soit terminé. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  Dans l'exemple ci-dessus, nous créons deux threads en utilisant la méthode timer.  Pour plus de clarté, j'ai utilisé l'opérateur mapTo pour afficher différentes valeurs.  Le premier thread générera 1, le second - 2. Un thread externe est créé en utilisant la méthode of, qui prend en entrée deux des observables ci-dessus. <br><br>  L'instruction concatAll reçoit d'abord firstInnerObservable, s'y abonne et attend qu'elle se termine, et seulement après l'achèvement du premier s'abonne à secondInnerObservable.  Voici à quoi ressemblera le flux externe: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  Si nous remplaçons concatAll par mergeAll, le flux ressemblera à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  Cet opérateur diffère des précédents en ce que lorsqu'il reçoit un nouveau flux, il se désabonne immédiatement du précédent et s'abonne au nouveau. <br><br>  Prenez l'exemple ci-dessus et remplacez concatAll par switchAll, et voyez comment le flux externe se comporte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Seule la valeur du deuxième flux interne est entrée dans le flux externe.  C'est parce que switchMap s'est désabonné du premier lorsqu'il a reçu le deuxième thread. <br><br>  Quand est-ce nécessaire?  Par exemple, lors de la mise en œuvre d'une recherche de données.  Si la réponse du serveur n'est pas encore arrivée et que nous avons déjà envoyé une nouvelle demande, il n'est pas logique d'attendre la précédente. <br><br><h4>  exhaust / exhaustMap </h4><br>  exhaust est exactement l'opposé de l'instruction switchAll, et son comportement est similaire à concatAll.  Cette méthode, en vous abonnant au flux, attend qu'elle se termine.  Si un nouveau flux lui revient, il est simplement rejeté. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  Dans l'exemple ci-dessus, nous n'avons pas obtenu de double, car à ce moment, l'opérateur attendait l'achèvement du premier thread, et a simplement laissé tomber le second. <br><br>  Je pense que beaucoup ont une question, quand un tel comportement peut-il être nécessaire?  Un bon exemple est le formulaire de connexion.  Cela n'a aucun sens d'envoyer plusieurs requêtes au serveur tant que la requête en cours n'est pas terminée. <br><br><h4>  Nous finalisons la candidature </h4><br>  Nous rappelons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">exemple</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième article</a> .  Dans ce document, nous avons implémenté une recherche sur GitHub et utilisé l'opérateur mergeMap pour envoyer des demandes au serveur.  Maintenant que nous connaissons les caractéristiques de cet opérateur, est-il vraiment adapté dans notre cas? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Supposons que le serveur GitHub soit fortement surchargé, alors le traitement de notre réponse prendra beaucoup de temps.  Qu'est-ce qui pourrait mal tourner dans ce cas? <br><br>  Supposons qu'un utilisateur saisisse certaines données, n'attende pas de réponse et en saisisse de nouvelles.  Dans ce cas, nous enverrons la deuxième demande au serveur.  Cependant, personne ne garantit que la réponse à la première demande viendra plus tôt. <br><br>  Étant donné que l'opérateur mergeMap ne se soucie pas de l'ordre dans lequel traiter les threads internes, dans le cas où la première demande est exécutée après la seconde, nous effacerons les données réelles.  Par conséquent, je propose de remplacer la méthode mergeMap par switchMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Maintenant, si l'utilisateur entre de nouvelles données, switchMap se désabonnera du flux précédent et s'abonnera au nouveau. <br><br>  Il convient de noter que notre requête http continuera de se bloquer jusqu'à ce que le serveur y réponde.  Mais, puisque nous nous sommes désabonnés du flux interne, la réponse ne tombera pas dans le flux externe. <br><br>  <b>Remarque</b> : si vous travaillez avec Angular et utilisez HttpClient pour travailler avec http, vous ne pouvez pas vous soucier d'annuler la demande elle-même.  HttpClient peut le faire pour vous lors de la désinscription. <br><br><h4>  Annuler http </h4><br>  L'API de récupération a la possibilité d'annuler la demande http à l'aide d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">AbortController</a> .  Lorsqu'elle est combinée avec l'opérateur switchMap, cette fonctionnalité permettra d'économiser du trafic utilisateur. <br><br>  Réécrivons un peu notre exemple.  Et créez une méthode qui encapsulera l'appel de récupération dans observable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  Modifiez également la méthode getUsersRepsFromApi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Maintenant, la méthode retourne pas promis, mais observable.  Par conséquent, nous supprimons le wrapper de switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Remarque</b> : dans RxJS version 6.5, ils ont ajouté l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">instruction fromFetch</a> , qui elle-même appelle la méthode d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">abandon</a> sous le capot, de sorte que vous n'avez plus besoin d'écrire votre propre «vélo». <br><br>  C'est tout!  Tous les exemples de code peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> . <br><br><h4>  Conclusion </h4><br>  Aujourd'hui, nous avons examiné ce qu'est HOO et certains opérateurs très utiles de cette catégorie.  Bien sûr, ceux-ci étaient loin d'être tous.  Pour des informations plus détaillées et détaillées, je vous recommande de consulter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation</a> RxJS. <br><br>  Dans le prochain article, je prévois d'examiner quelle est la différence entre les observables chauds et froids. <br><br>  Enfin: n'utilisez pas l'abonnement dans l'abonnement, car il y a HOO! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450050/">https://habr.com/ru/post/fr450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450036/index.html">Summ3r 0f h4ck: stage Digital Security 2019</a></li>
<li><a href="../fr450040/index.html">Une nouvelle société prendra en charge OpenJDK 8 et 11 - nous comprenons la situation</a></li>
<li><a href="../fr450042/index.html">Disposition du clavier étendu russe</a></li>
<li><a href="../fr450044/index.html">Recherche d'un problème au mauvais endroit</a></li>
<li><a href="../fr450048/index.html">Commentaires sur les modifications de la loi fédérale n ° 149-ФЗ «sur l'information, les technologies de l'information et la protection de l'information»</a></li>
<li><a href="../fr450054/index.html">Pirater le jeton JWT</a></li>
<li><a href="../fr450056/index.html">Faites attention # 2: Recueil d'articles sur la réflexion sur les produits, la psychologie du comportement et la productivité personnelle</a></li>
<li><a href="../fr450058/index.html">Le CV de ce mec</a></li>
<li><a href="../fr450060/index.html">Comment j'ai découvert que mon visa n'était pas prêt, un message dans Slack</a></li>
<li><a href="../fr450062/index.html">Rétablir la circulation cérébrale quelques heures après la mort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>