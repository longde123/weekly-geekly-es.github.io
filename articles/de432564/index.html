<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔧 👆🏼 💖 Rust 2018 kam heraus ... aber was ist das? 🌷 💈 🚅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel wurde von Lin Clarke in Zusammenarbeit mit dem Rust-Entwicklungsteam („wir“ im Text) verfasst. Sie können den Beitrag auch im offiziell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 kam heraus ... aber was ist das?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Dieser Artikel wurde von Lin Clarke in Zusammenarbeit mit dem Rust-Entwicklungsteam („wir“ im Text) verfasst.  Sie können den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag auch</a> im offiziellen Rust-Blog lesen. <br><br>  Die erste Version von Rust 2018 wurde am 6. Dezember 2018 veröffentlicht. In dieser Version haben wir uns auf die Produktivität konzentriert, damit die Rust-Entwickler so effizient wie möglich arbeiten können. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">Die Zeitleiste zeigt den Übergang von Beta zu Rust 2018 und Rust 2015. Sie ist von Symbolen für Tools und vier Bereichen umgeben: WebAssembly, Embedded, Networking und CLI.</font></i>  <i><font color="gray">Der rote Kreis - Entwicklerproduktivität - umgibt alles außer Rust 2015</font></i> <br><br>  Im Allgemeinen ist es jedoch nicht einfach zu erklären, was Rust 2018 ist. <br><br>  Einige präsentieren es als eine neue Version der Sprache ... so etwas, aber nicht wirklich.  Ich sage "nicht wirklich", weil hier die "neue Version" nicht die neuen Versionen anderer Sprachen bedeutet. <br><a name="habracut"></a><br>  In den meisten anderen Sprachen fügen alle neuen Funktionen eine neue Version hinzu.  Die vorherige Version wird nicht aktualisiert. <br><br>  Das Rust-System arbeitet anders.  Dies liegt daran, wie sich die Sprache entwickelt.  Fast alle neuen Funktionen sind zu 100% mit Rust kompatibel.  Sie erfordern keine Änderungen.  Dies bedeutet, dass es keinen Grund gibt, sie auf Rust 2018-Code zu beschränken. Neuere Versionen des Compilers unterstützen weiterhin standardmäßig den „Rust 2015-Modus“. <br><br>  Aber manchmal erfordert die Entwicklung einer Sprache Innovation, zum Beispiel eine neue Syntax.  Und diese neue Syntax kann vorhandene Codebasen beschädigen. <br><br>  Zum Beispiel die Funktion <code>async/await</code> .  Anfangs gab es in Rust keine derartigen Konzepte.  Es stellte sich jedoch heraus, dass diese Grundelemente wirklich nützlich sind und das Schreiben von asynchronem Code vereinfachen. <br><br>  Für diese Funktion müssen die Schlüsselwörter <code>async</code> und <code>await</code> hinzugefügt werden.  Sie sollten jedoch darauf achten, den alten Code nicht zu <code>async</code> bei dem <code>async</code> oder <code>await</code> als Variablennamen verwendet werden können. <br><br>  Daher fügen wir in Rust 2018 Schlüsselwörter hinzu. Obwohl die Funktion noch nicht freigegeben wurde, sind die Schlüsselwörter jetzt reserviert.  Alle inkompatiblen Änderungen für die nächsten drei Entwicklungsjahre (z. B. Hinzufügen neuer Schlüsselwörter) werden jeweils in Rust 1.31 vorgenommen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Obwohl es in Rust 2018 inkompatible Änderungen gibt, bedeutet dies nicht, dass Ihr Code beschädigt wird.  Selbst bei <code>async</code> und <code>await</code> Variablen wird der Code kompiliert.  Standardmäßig arbeitet der Compiler wie zuvor. <br><br>  Wenn Sie jedoch eine der neuen Funktionen verwenden möchten, können Sie den neuen Kompilierungsmodus von Rust 2018 auswählen. Der Befehl für die <code>cargo fix</code> zeigt an, ob Sie den Code aktualisieren müssen, um die neuen Funktionen zu verwenden und den Änderungsprozess zu automatisieren.  Dann können Sie Ihrem Cargo.toml die <code>edition=2018</code> hinzufügen, wenn Sie der Verwendung neuer Funktionen zustimmen. <br><br>  Dieser Versionsbezeichner in Cargo.toml gilt nicht für das gesamte Projekt und nicht für Ihre Abhängigkeiten.  Es ist auf ein bestimmtes Rack beschränkt.  Das heißt, Sie können die Kisten Rust 2015 und Rust 2018 gleichzeitig verwenden. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Daher sieht auch bei Verwendung von Rust 2018 alles ungefähr so ​​aus wie bei Rust 2015. Die meisten Änderungen werden gleichzeitig in Rust 2018 und Rust 2015 implementiert. Nur wenige Funktionen erfordern inkompatible Änderungen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 ist nicht nur Änderungen in der Hauptsprache.  Weit nicht nur sie. <br><br>  Rust 2018 ist in erster Linie ein Impuls zur Verbesserung der Produktivität von Rust-Entwicklern, vor allem dank Tools, die außerhalb der Sprache liegen, sowie durch die Entwicklung spezifischer Anwendungen und das Verständnis, wie Rust in diesen Fällen zur effektivsten Programmiersprache gemacht werden kann. <br><br>  Somit können Sie Rust 2018 als Bezeichner in Cargo.toml darstellen, das verwendet wird, um mehrere Funktionen einzuschließen, die inkompatible Änderungen erfordern ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Oder Sie können es sich zu einem Zeitpunkt vorstellen, zu dem Rust zu einer der effizientesten Sprachen für viele Anwendungen wird - wenn Sie Leistung, effizienten Ressourceneinsatz oder hohe Zuverlässigkeit benötigen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Wir bevorzugen die zweite Version der Definition.  Schauen wir uns also alle Verbesserungen an, die außerhalb der Sprache vorgenommen wurden, und tauchen wir dann in die Sprache selbst ein. <br><br><h1>  Rost für bestimmte Anwendungen </h1><br>  Eine Programmiersprache kann an sich abstrakt nicht effektiv sein.  Es ist in einer bestimmten Anwendung wirksam.  Daher haben wir verstanden, dass es nicht nur notwendig ist, Rust als Sprache oder Werkzeug zu verbessern.  Es ist auch notwendig, die Verwendung von Rost in bestimmten Bereichen zu vereinfachen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  In einigen Fällen bedeutete dies die Schaffung eines völlig neuen Werkzeugsatzes für ein völlig neues Ökosystem.  In anderen Fällen sollten vorhandene Funktionen und eine gute Dokumentation verbessert werden, um das Aufrufen und Ausführen eines funktionierenden Systems zu vereinfachen. <br><br>  Das Rust-Entwicklungsteam hat Arbeitsgruppen in vier Bereichen gebildet: <br><br><ul><li>  Webassembly </li><li>  Eingebettete Anwendungen </li><li>  Netzwerkaufgaben </li><li>  Befehlszeilen-Tools </li></ul><br><h2>  Webassembly </h2><br>  WebAssembly musste einen völlig neuen Satz von Tools erstellen. <br><br>  Erst im letzten Jahr war es mit WebAssembly möglich, Sprachen wie Rust für die Ausführung im Internet zu kompilieren.  Seitdem hat sich Rust schnell zur besten Sprache für die Integration in vorhandene Webanwendungen entwickelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust eignet sich aus zwei Gründen gut für die Webentwicklung: <br><br><ol><li>  Das Cargo Crash Ecosystem funktioniert so, wie es die meisten Entwickler von Webanwendungen gewohnt sind.  Kombinieren Sie eine Reihe kleiner Module, um eine größere Anwendung zu bilden.  Dies bedeutet, dass Rust genau dort einfach zu verwenden ist, wo Sie es benötigen. </li><li>  Rost ist ressourcenarm und erfordert keine Laufzeit.  Sie benötigen nicht viel Code.  Wenn Sie ein winziges Modul haben, das viel Hard-Computing-Arbeit leistet, implementieren Sie ein paar Rust-Linien, um es zu beschleunigen. </li></ol><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">web-sys und js-sys</a> aus Rust-Code können Web-APIs wie <code>fetch</code> oder <code>appendChild</code> einfach <code>appendChild</code> .  Und <code>wasm-bindgen</code> macht es einfach, übergeordnete Datentypen zu unterstützen, die WebAssembly nicht nativ unterstützt. <br><br>  Nach dem Schreiben des Rust WebAssembly-Moduls gibt es Tools, mit denen Sie es einfach mit dem Rest der Webanwendung verbinden können.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-pack verwenden</a> , um diese Tools automatisch zu starten und das Modul in npm auszuführen, wenn Sie möchten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch Rust and WebAssembly</a> . <br><br><h4>  Was weiter? </h4><br>  Nach der Veröffentlichung von Rust 2018 planen die Entwickler, mit der Community zu diskutieren, in welche Richtungen weiter gearbeitet werden soll. <br><br><h2>  Eingebettete Anwendungen </h2><br>  Für die eingebettete Entwicklung war es notwendig, die Stabilität der vorhandenen Funktionalität zu erhöhen. <br><br>  Theoretisch war Rust immer eine gute Sprache für eingebettete Anwendungen.  Dies ist ein modernes Toolkit, das Entwicklern sehr fehlte, und sehr praktische Sprachfunktionen auf hoher Ebene.  All dies ohne unnötige Belastung der CPU und des Speichers.  Somit eignet sich Rust hervorragend für Embedded. <br><br>  In der Praxis stellte sich dies jedoch anders heraus.  Dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabilen Kanal</a> fehlten die notwendigen Funktionen.  Darüber hinaus musste für die Verwendung auf eingebetteten Geräten die Standardbibliothek geändert werden.  Dies bedeutet, dass die Benutzer ihre eigene Version der Rust-Kernkiste kompilieren mussten (die Kiste, die in jeder Rust-Anwendung verwendet wird, um die grundlegenden Rust-Bausteine ​​bereitzustellen - integrierte Funktionen und Grundelemente). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  Infolgedessen waren die Entwickler auf die experimentelle Version von Rust angewiesen.  In Ermangelung automatischer Tests funktionierte die Versuchsanordnung häufig nicht mit Mikrocontrollern. <br><br>  Um dies zu beheben, versuchten die Entwickler, alle erforderlichen Funktionen auf einen stabilen Kanal zu übertragen und dem CI-System Tests für Mikrocontroller hinzuzufügen.  Dies bedeutet, dass durch das Ändern einer Desktop-Komponente die integrierte Version nicht beschädigt wird. <br><br>  Mit solchen Änderungen verlagert sich die Entwicklung eingebetteter Systeme auf Rust vom Bereich fortgeschrittener Experimente zum Bereich normaler Effizienz. <br><br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch Rust for Embedded Systems</a> . <br><br><h4>  Was weiter? </h4><br>  In diesem Jahr erhielt Rust wirklich gute Unterstützung für die beliebte ARM Cortex-M-Familie.  Viele Architekturen werden jedoch noch nicht gut unterstützt.  Rust muss erweitert werden, um andere Architekturen ähnlich zu unterstützen. <br><br><h2>  Netzwerkaufgaben </h2><br>  Um im Netzwerk arbeiten zu können, musste eine Schlüsselabstraktion in die Sprache eingebettet werden: <code>async/await</code> .  Daher können Entwickler Standard-Rust-Redewendungen auch in asynchronem Code verwenden. <br><br>  Bei Netzwerkaufgaben müssen Sie häufig warten.  Zum Beispiel eine Antwort auf eine Anfrage.  Wenn der Code synchron ist, wird die Arbeit gestoppt: Der Kern des Prozessors, auf dem der Code ausgeführt wird, kann nichts tun, bis eine Anforderung eintrifft.  Im asynchronen Code kann eine solche Funktion jedoch in den Standby-Modus versetzt werden, während der CPU-Kern den Rest erledigt. <br><br>  Asynchrone Programmierung ist auch in Rust 2015 möglich, und dies hat viele Vorteile.  In Hochleistungsanwendungen verarbeitet die Serveranwendung viel mehr Verbindungen zu jedem Server.  Eingebettete Anwendungen auf winzigen Single-Thread-CPUs optimieren die Verwendung eines einzelnen Threads. <br><br>  Diese Vorteile sind jedoch mit einem großen Nachteil verbunden: Für einen solchen Code funktioniert die Kreditüberprüfung nicht und Sie müssen nicht standardmäßige (und leicht verwirrte) Rust-Redewendungen verwenden.  Dies ist der Vorteil von <code>async/await</code> .  Dies gibt dem Compiler die notwendigen Informationen, um das Ausleihen von asynchronen Funktionsaufrufen zu testen. <br><br>  Schlüsselwörter für <code>async/await</code> in Version 1.31 implementiert, obwohl sie derzeit von der Implementierung nicht unterstützt werden.  Der größte Teil der Arbeit ist erledigt und die Funktion sollte in der nächsten Version verfügbar sein. <br><br><h4>  Was weiter? </h4><br>  Zusätzlich zu einer effektiven Entwicklung auf niedriger Ebene kann Rust eine effizientere Entwicklung von Netzwerkanwendungen auf einer höheren Ebene ermöglichen. <br><br>  Viele Server führen Routineaufgaben aus: URLs analysieren oder mit HTTP arbeiten.  Wenn Sie sie in Komponenten umwandeln - allgemeine Abstraktionen, die als Kisten geteilt werden -, ist es einfach, sie miteinander zu verbinden und alle Arten von Server- und Framework-Konfigurationen zu bilden. <br><br>  Ein experimentelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tide-Framework wurde</a> erstellt, um Komponenten zu entwickeln und zu testen. <br><br><h2>  Befehlszeilen-Tools </h2><br>  Für Befehlszeilentools war es erforderlich, kleine Bibliotheken auf niedriger Ebene zu Abstraktionen auf höherer Ebene zu kombinieren und einige vorhandene Tools zu verbessern. <br><br>  Für einige Skripte ist bash ideal.  Zum Beispiel, um einfach andere Shell-Tools aufzurufen und Daten zwischen ihnen zu übertragen. <br><br>  Aber Rust ist eine großartige Option für viele andere Werkzeuge.  Wenn Sie beispielsweise ein komplexes Tool wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ripgrep</a> oder ein CLI-Tool zusätzlich zur Funktionalität einer vorhandenen Bibliothek erstellen. <br><br>  Rust benötigt keine Laufzeit und wird in eine einzelne statische Binärdatei kompiliert, was die Verteilung des Programms vereinfacht.  Und Sie erhalten Abstraktionen auf hoher Ebene, die nicht in anderen Sprachen wie C und C ++ vorliegen. <br><br>  Was kann Rust noch verbessern?  Natürlich Abstraktionen auf noch höherem Niveau. <br><br>  Mit übergeordneten Abstraktionen kann eine vorgefertigte CLI schnell und einfach zusammengestellt werden. <br><br>  Ein Beispiel für eine solche Abstraktion ist die Bibliothek für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">menschliche Panik</a> .  Wenn keine solche Bibliothek vorhanden ist, gibt der CLI-Code im Falle eines Fehlers wahrscheinlich das gesamte Backtracking zurück.  Aber es ist nicht sehr interessant für Benutzer.  Sie können eine benutzerdefinierte Fehlerbehandlung hinzufügen, dies ist jedoch schwierig. <br><br>  Bei der Human Panic Library wird die Ausgabe automatisch in die Fehler-Dump-Datei verschoben.  Dem Benutzer wird eine informative Meldung angezeigt, in der er ein Problem melden und die Speicherauszugsdatei herunterladen kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Der Beginn der Entwicklung von CLI-Tools ist ebenfalls einfacher geworden.  Beispielsweise automatisiert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Confy-</a> Bibliothek ihre Konfiguration.  Er fragt nur zwei Dinge: <br><br><ul><li>  Wie heißt die Anwendung? </li><li>  Welche Konfigurationsparameter möchten Sie bereitstellen (die Sie als eine Struktur definieren, die serialisiert und deserialisiert werden kann)? </li></ul><br>  Confy bestimmt alles andere selbst. <br><br><h4>  Was weiter? </h4><br>  Wir haben viele Aufgaben für die CLI abstrahiert.  Aber es gibt noch etwas zu abstrahieren.  Wir werden weitere solche Bibliotheken auf hoher Ebene veröffentlichen. <br><br><h1>  Rostwerkzeuge </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Wenn Sie in einer beliebigen Sprache schreiben, arbeiten Sie mit den Tools: Beginnen Sie mit dem Editor und fahren Sie mit anderen Tools in allen Phasen der Entwicklung und des Supports fort. <br><br>  Dies bedeutet, dass eine effektive Sprache von effektiven Werkzeugen abhängt. <br><br>  Hier sind einige neue Tools (und Verbesserungen an bestehenden) in Rust 2018. <br><br><h2>  IDE-Unterstützung </h2><br>  Die Leistung hängt natürlich von der schnellen und reibungslosen Übertragung von Code vom Kopf des Entwicklers auf den Computerbildschirm ab.  Hier ist die IDE-Unterstützung von entscheidender Bedeutung.  Dazu benötigen wir Tools, die der IDE die Bedeutung von Rust-Code "erklären" können: Schlagen Sie beispielsweise sinnvolle Optionen für die automatische Vervollständigung von Zeichenfolgen vor. <br><br>  In Rust 2018 konzentrierte sich die Community auf die von der IDE geforderten Funktionen.  Mit dem Aufkommen von Rust Language Server und IntelliJ Rust unterstützen viele IDEs Rust jetzt vollständig. <br><br><h2>  Schnellere Zusammenstellung </h2><br>  Um die Compilerleistung zu verbessern, muss sie beschleunigt werden.  Das haben wir getan. <br><br>  Zuvor hat der Compiler beim Kompilieren der Rust-Kiste jede einzelne Datei in der Kiste neu kompiliert.  Die inkrementelle Kompilierung ist jetzt implementiert: Sie kompiliert nur die Teile, die sich geändert haben.  Zusammen mit anderen Optimierungen machte dies den Rust-Compiler viel schneller. <br><br><h2>  rustfmt </h2><br>  Effizienz erfordert auch, dass wir niemals über Code-Formatierungsregeln streiten oder die Stile anderer Leute manuell korrigieren. <br><br>  Das rustfmt-Tool hilft dabei: Es formatiert den Code automatisch gemäß dem Standardstil neu (durch den die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Community einen Konsens erreicht hat</a> ).  Rustfmt stellt sicher, dass der gesamte Rust-Code dem gleichen Stil entspricht, wie das Clang-Format für C ++ oder Prettier für JavaScript. <br><br><h2>  Clippy </h2><br>  Manchmal ist es schön, einen erfahrenen Berater in der Nähe zu haben, der Ratschläge zu Best Practices für das Schreiben von Code gibt.  Dies ist, was Clippy tut: Es überprüft den Code während der Anzeige und schlägt Standard-Idiome vor. <br><br><h2>  Rustfix </h2><br>  Wenn Sie jedoch eine alte Codebasis mit veralteten Redewendungen haben, kann es anstrengend sein, den Code unabhängig zu überprüfen und zu korrigieren.  Sie möchten nur, dass jemand Korrekturen an der gesamten Codebasis vornimmt. <br><br>  In diesen Fällen automatisiert rustfix den Prozess.  Gleichzeitig werden Regeln von Tools wie Clippy angewendet und der alte Code gemäß den Redewendungen von Rust 2018 aktualisiert. <br><br><h1>  Änderungen an Rust selbst </h1><br>  Änderungen im Ökosystem haben die Effizienz der Programmierung erheblich gesteigert.  Einige Probleme können jedoch nur durch Änderungen in der Sprache selbst gelöst werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Wie bereits in der Einleitung erwähnt, sind die meisten Sprachänderungen vollständig mit dem vorhandenen Rust-Code kompatibel.  Alle diese Änderungen sind Teil von Rust 2018. Da sie jedoch nichts beschädigen, funktionieren sie in jedem Rust-Code ... sogar im alten. <br><br>  Schauen wir uns die wichtigen Funktionen an, die allen Versionen hinzugefügt wurden.  Dann schauen Sie sich eine kurze Liste der Funktionen von Rust 2018 an. <br><br><h2>  Neue Funktionen für alle Versionen </h2><br>  Hier ist ein kleines Beispiel für die neuen Funktionen, die in allen Versionen der Sprache verfügbar sind (oder sein werden). <br><br><h4>  Genauere Überprüfung der Kreditaufnahme </h4><br>  Ein großer Vorteil von Rust ist die Überprüfung der Kreditaufnahme.  Es stellt sicher, dass der Code speichersicher ist.  Dies ist aber auch eine ziemlich komplizierte Funktion für Rust-Neulinge. <br><br>  Ein Teil der Schwierigkeit liegt darin, neue Konzepte zu lernen.  Aber es gibt noch einen anderen Teil ... Das Testen von Ausleihen lehnt manchmal Code ab, der aus der Sicht eines Programmierers zu funktionieren scheint, der das Konzept der Speichersicherheit vollständig versteht. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Sie können eine Variable nicht ausleihen, da sie bereits ausgeliehen ist</font></i> <br><br>  Dies liegt daran, dass sich die Lebensdauer der Ausleihe bis zum Ende des Felds erstrecken sollte - beispielsweise bis zum Ende der Funktion, in der sich die Variable befindet. <br><br>  Dies bedeutete, dass anderen Variablen bis zum Ende der Funktion der Zugriff auf diesen Wert verweigert wird, selbst wenn die Variable nicht mehr mit dem Wert arbeitet und nicht mehr versucht, darauf zuzugreifen. <br><br>  Um die Situation zu korrigieren, haben wir den Scheck intelligenter gemacht.  Jetzt sieht sie, wann die Variable den Wert <i>tatsächlich</i> verwendet hat.  Danach wird die Verwendung von Daten nicht blockiert. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Dies ist zwar nur in Rust 2018 verfügbar, aber in naher Zukunft wird die Funktion allen anderen Versionen hinzugefügt.  Bald werden wir mehr zu diesem Thema schreiben. <br><br><h4>  Verfahrensmakros in stabilem Rost </h4><br>  Rust hatte Makros vor Rust 1.0.  In Rust 2018 wurden jedoch ernsthafte Verbesserungen vorgenommen, beispielsweise wurden prozedurale Makros angezeigt.  Mit ihnen können Sie Rust Ihre eigene Syntax hinzufügen. <br><br>  Rust 2018 bietet zwei Arten von prozeduralen Makros: <br><br><h4>  Funktionsmakros </h4><br>  Mit funktionsähnlichen Makros können Sie Objekte erstellen, die wie normale Funktionsaufrufe aussehen, aber tatsächlich zur Kompilierungszeit ausgeführt werden.  Sie nehmen einen Code und geben einen anderen aus, den der Compiler dann in die Binärdatei einfügt. <br><br>  Sie existierten vorher, aber mit begrenztem.  Ein Makro konnte nur die match-Anweisung ausführen.  Er hatte keinen Zugriff, um alle Token im eingehenden Code anzuzeigen. <br><br>  Bei prozeduralen Makros erhalten Sie jedoch dieselbe Eingabe wie beim Parser: denselben Token-Stream.  Dies bedeutet, dass Sie viel leistungsfähigere Makros wie Funktionen erstellen können. <br><br><h4>  Attributähnliche Makros </h4><br>  Wenn Sie mit Dekorateuren in Sprachen wie JavaScript vertraut sind, sind Attributmakros sehr ähnlich.  Mit ihnen können Sie Fragmente von Rust-Code mit Anmerkungen versehen, die vorverarbeitet und in etwas anderes umgewandelt werden sollen. <br><br>  Das <code>derive</code> macht genau das.  Wenn Sie es über eine Struktur legen, nimmt der Compiler diese Struktur (nachdem sie als Liste von Token analysiert wurde) und verarbeitet sie.  Insbesondere wird eine grundlegende Implementierung von Funktionen aus dem Merkmal hinzugefügt. <br><br><h4>  Ergonomischere Anleihen im Vergleich </h4><br>  Es gibt eine einfache Änderung. <br><br>  Wenn Sie zuvor etwas ausleihen wollten und versuchten, eine Übereinstimmung zu finden, mussten Sie eine seltsame Syntax hinzufügen: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Anstelle von <code>&amp;Some(ref s)</code> schreiben wir jetzt einfach <code>Some(s)</code> . <br><br><h1>  Neue Rust 2018 Funktionen </h1><br>  Der kleinste Teil von Rust 2018 enthält spezifische Funktionen für diese Version.  Hier ist eine kleine Reihe von Änderungen in Rust 2018. <br><br><h3>  Stichworte </h3><br>  Rust 2018 hat einige Schlüsselwörter hinzugefügt: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Diese Funktionen sind noch nicht vollständig implementiert, aber Schlüsselwörter werden in Rust 1.31 hinzugefügt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher müssen wir in Zukunft keine neuen Schlüsselwörter einführen (was zu einer inkompatiblen Änderung führen würde), wenn wir diese Funktionen implementieren. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modulares System </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein großer Schmerz für Rust-Neulinge ist das modulare System. </font><font style="vertical-align: inherit;">Und es ist klar warum. </font><font style="vertical-align: inherit;">Es war schwer zu verstehen, warum Rust ein bestimmtes Modul auswählt. </font><font style="vertical-align: inherit;">Um dies zu beheben, haben wir einige Änderungen am Pfadmechanismus vorgenommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beispielsweise ein Rack importiert haben, können Sie es im Pfad auf der obersten Ebene verwenden. </font><font style="vertical-align: inherit;">Wenn Sie jedoch Code in ein Submodul verschieben, funktioniert dies nicht mehr.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel ist das Präfix </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das sowohl für die Wurzel der Kiste als auch für die externe Kiste verwendet wird. </font><font style="vertical-align: inherit;">Es ist schwer zu verstehen, was vor uns liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben es expliziter gemacht. </font><font style="vertical-align: inherit;">Wenn Sie sich nun auf die Wurzelkiste beziehen möchten, verwenden Sie das Präfix </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist nur eine der Verbesserungen zur Klarheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der aktuelle Code die Funktionen von Rust 2018 nutzen soll, müssen Sie den Code höchstwahrscheinlich aktualisieren, um die neuen Pfade widerzuspiegeln. </font><font style="vertical-align: inherit;">Dies muss jedoch nicht manuell erfolgen. </font><font style="vertical-align: inherit;">Bevor Sie den Versionsbezeichner zu Cargo.toml hinzufügen, führen Sie ihn einfach aus </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nehmen Sie </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die erforderlichen Änderungen vor.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Informationen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Informationen zur neuen Version der Sprache sind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Rust 2018-Handbuch enthalten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432564/">https://habr.com/ru/post/de432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432554/index.html">Douglas Engelbart: Stärkung der „Collective IQ“ -Gesellschaft</a></li>
<li><a href="../de432556/index.html">Tesla patentierte Technologie zur Positionierung von Fahrzeugen</a></li>
<li><a href="../de432558/index.html">Architekturmuster „Besucher“ in den Universen „iOS“ und „Swift“</a></li>
<li><a href="../de432560/index.html">Typografie im Web. Yandex-Vortrag bei FrontTalks 2018</a></li>
<li><a href="../de432562/index.html">Techday Make IT Real - 17. Dezember, Moskau</a></li>
<li><a href="../de432566/index.html">Zwei Welten oder "Ingenieure haben etwas zu sagen." Zu den verschiedenen Arten komplexer Aufgaben und den damit verbundenen Prozessen</a></li>
<li><a href="../de432568/index.html">„Wenn Sie der Chefredakteur von Rusbase sind“: Ein neuer Podcast über die Arbeit mit Inhalten und eine Karriere in Technologiemedien</a></li>
<li><a href="../de432572/index.html">Der Metall-Luft-Transistor wird das Moore'sche Gesetz erweitern - wie Technologie funktioniert</a></li>
<li><a href="../de432574/index.html">Anspruchsvolles Design einfacher Geräte</a></li>
<li><a href="../de432576/index.html">Unter der Haube eines JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>