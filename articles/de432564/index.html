<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß üëÜüèº üíñ Rust 2018 kam heraus ... aber was ist das? üå∑ üíà üöÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel wurde von Lin Clarke in Zusammenarbeit mit dem Rust-Entwicklungsteam (‚Äûwir‚Äú im Text) verfasst. Sie k√∂nnen den Beitrag auch im offiziell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 kam heraus ... aber was ist das?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Dieser Artikel wurde von Lin Clarke in Zusammenarbeit mit dem Rust-Entwicklungsteam (‚Äûwir‚Äú im Text) verfasst.  Sie k√∂nnen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag auch</a> im offiziellen Rust-Blog lesen. <br><br>  Die erste Version von Rust 2018 wurde am 6. Dezember 2018 ver√∂ffentlicht. In dieser Version haben wir uns auf die Produktivit√§t konzentriert, damit die Rust-Entwickler so effizient wie m√∂glich arbeiten k√∂nnen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">Die Zeitleiste zeigt den √úbergang von Beta zu Rust 2018 und Rust 2015. Sie ist von Symbolen f√ºr Tools und vier Bereichen umgeben: WebAssembly, Embedded, Networking und CLI.</font></i>  <i><font color="gray">Der rote Kreis - Entwicklerproduktivit√§t - umgibt alles au√üer Rust 2015</font></i> <br><br>  Im Allgemeinen ist es jedoch nicht einfach zu erkl√§ren, was Rust 2018 ist. <br><br>  Einige pr√§sentieren es als eine neue Version der Sprache ... so etwas, aber nicht wirklich.  Ich sage "nicht wirklich", weil hier die "neue Version" nicht die neuen Versionen anderer Sprachen bedeutet. <br><a name="habracut"></a><br>  In den meisten anderen Sprachen f√ºgen alle neuen Funktionen eine neue Version hinzu.  Die vorherige Version wird nicht aktualisiert. <br><br>  Das Rust-System arbeitet anders.  Dies liegt daran, wie sich die Sprache entwickelt.  Fast alle neuen Funktionen sind zu 100% mit Rust kompatibel.  Sie erfordern keine √Ñnderungen.  Dies bedeutet, dass es keinen Grund gibt, sie auf Rust 2018-Code zu beschr√§nken. Neuere Versionen des Compilers unterst√ºtzen weiterhin standardm√§√üig den ‚ÄûRust 2015-Modus‚Äú. <br><br>  Aber manchmal erfordert die Entwicklung einer Sprache Innovation, zum Beispiel eine neue Syntax.  Und diese neue Syntax kann vorhandene Codebasen besch√§digen. <br><br>  Zum Beispiel die Funktion <code>async/await</code> .  Anfangs gab es in Rust keine derartigen Konzepte.  Es stellte sich jedoch heraus, dass diese Grundelemente wirklich n√ºtzlich sind und das Schreiben von asynchronem Code vereinfachen. <br><br>  F√ºr diese Funktion m√ºssen die Schl√ºsselw√∂rter <code>async</code> und <code>await</code> hinzugef√ºgt werden.  Sie sollten jedoch darauf achten, den alten Code nicht zu <code>async</code> bei dem <code>async</code> oder <code>await</code> als Variablennamen verwendet werden k√∂nnen. <br><br>  Daher f√ºgen wir in Rust 2018 Schl√ºsselw√∂rter hinzu. Obwohl die Funktion noch nicht freigegeben wurde, sind die Schl√ºsselw√∂rter jetzt reserviert.  Alle inkompatiblen √Ñnderungen f√ºr die n√§chsten drei Entwicklungsjahre (z. B. Hinzuf√ºgen neuer Schl√ºsselw√∂rter) werden jeweils in Rust 1.31 vorgenommen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Obwohl es in Rust 2018 inkompatible √Ñnderungen gibt, bedeutet dies nicht, dass Ihr Code besch√§digt wird.  Selbst bei <code>async</code> und <code>await</code> Variablen wird der Code kompiliert.  Standardm√§√üig arbeitet der Compiler wie zuvor. <br><br>  Wenn Sie jedoch eine der neuen Funktionen verwenden m√∂chten, k√∂nnen Sie den neuen Kompilierungsmodus von Rust 2018 ausw√§hlen. Der Befehl f√ºr die <code>cargo fix</code> zeigt an, ob Sie den Code aktualisieren m√ºssen, um die neuen Funktionen zu verwenden und den √Ñnderungsprozess zu automatisieren.  Dann k√∂nnen Sie Ihrem Cargo.toml die <code>edition=2018</code> hinzuf√ºgen, wenn Sie der Verwendung neuer Funktionen zustimmen. <br><br>  Dieser Versionsbezeichner in Cargo.toml gilt nicht f√ºr das gesamte Projekt und nicht f√ºr Ihre Abh√§ngigkeiten.  Es ist auf ein bestimmtes Rack beschr√§nkt.  Das hei√üt, Sie k√∂nnen die Kisten Rust 2015 und Rust 2018 gleichzeitig verwenden. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Daher sieht auch bei Verwendung von Rust 2018 alles ungef√§hr so ‚Äã‚Äãaus wie bei Rust 2015. Die meisten √Ñnderungen werden gleichzeitig in Rust 2018 und Rust 2015 implementiert. Nur wenige Funktionen erfordern inkompatible √Ñnderungen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 ist nicht nur √Ñnderungen in der Hauptsprache.  Weit nicht nur sie. <br><br>  Rust 2018 ist in erster Linie ein Impuls zur Verbesserung der Produktivit√§t von Rust-Entwicklern, vor allem dank Tools, die au√üerhalb der Sprache liegen, sowie durch die Entwicklung spezifischer Anwendungen und das Verst√§ndnis, wie Rust in diesen F√§llen zur effektivsten Programmiersprache gemacht werden kann. <br><br>  Somit k√∂nnen Sie Rust 2018 als Bezeichner in Cargo.toml darstellen, das verwendet wird, um mehrere Funktionen einzuschlie√üen, die inkompatible √Ñnderungen erfordern ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Oder Sie k√∂nnen es sich zu einem Zeitpunkt vorstellen, zu dem Rust zu einer der effizientesten Sprachen f√ºr viele Anwendungen wird - wenn Sie Leistung, effizienten Ressourceneinsatz oder hohe Zuverl√§ssigkeit ben√∂tigen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Wir bevorzugen die zweite Version der Definition.  Schauen wir uns also alle Verbesserungen an, die au√üerhalb der Sprache vorgenommen wurden, und tauchen wir dann in die Sprache selbst ein. <br><br><h1>  Rost f√ºr bestimmte Anwendungen </h1><br>  Eine Programmiersprache kann an sich abstrakt nicht effektiv sein.  Es ist in einer bestimmten Anwendung wirksam.  Daher haben wir verstanden, dass es nicht nur notwendig ist, Rust als Sprache oder Werkzeug zu verbessern.  Es ist auch notwendig, die Verwendung von Rost in bestimmten Bereichen zu vereinfachen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  In einigen F√§llen bedeutete dies die Schaffung eines v√∂llig neuen Werkzeugsatzes f√ºr ein v√∂llig neues √ñkosystem.  In anderen F√§llen sollten vorhandene Funktionen und eine gute Dokumentation verbessert werden, um das Aufrufen und Ausf√ºhren eines funktionierenden Systems zu vereinfachen. <br><br>  Das Rust-Entwicklungsteam hat Arbeitsgruppen in vier Bereichen gebildet: <br><br><ul><li>  Webassembly </li><li>  Eingebettete Anwendungen </li><li>  Netzwerkaufgaben </li><li>  Befehlszeilen-Tools </li></ul><br><h2>  Webassembly </h2><br>  WebAssembly musste einen v√∂llig neuen Satz von Tools erstellen. <br><br>  Erst im letzten Jahr war es mit WebAssembly m√∂glich, Sprachen wie Rust f√ºr die Ausf√ºhrung im Internet zu kompilieren.  Seitdem hat sich Rust schnell zur besten Sprache f√ºr die Integration in vorhandene Webanwendungen entwickelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust eignet sich aus zwei Gr√ºnden gut f√ºr die Webentwicklung: <br><br><ol><li>  Das Cargo Crash Ecosystem funktioniert so, wie es die meisten Entwickler von Webanwendungen gewohnt sind.  Kombinieren Sie eine Reihe kleiner Module, um eine gr√∂√üere Anwendung zu bilden.  Dies bedeutet, dass Rust genau dort einfach zu verwenden ist, wo Sie es ben√∂tigen. </li><li>  Rost ist ressourcenarm und erfordert keine Laufzeit.  Sie ben√∂tigen nicht viel Code.  Wenn Sie ein winziges Modul haben, das viel Hard-Computing-Arbeit leistet, implementieren Sie ein paar Rust-Linien, um es zu beschleunigen. </li></ol><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">web-sys und js-sys</a> aus Rust-Code k√∂nnen Web-APIs wie <code>fetch</code> oder <code>appendChild</code> einfach <code>appendChild</code> .  Und <code>wasm-bindgen</code> macht es einfach, √ºbergeordnete Datentypen zu unterst√ºtzen, die WebAssembly nicht nativ unterst√ºtzt. <br><br>  Nach dem Schreiben des Rust WebAssembly-Moduls gibt es Tools, mit denen Sie es einfach mit dem Rest der Webanwendung verbinden k√∂nnen.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-pack verwenden</a> , um diese Tools automatisch zu starten und das Modul in npm auszuf√ºhren, wenn Sie m√∂chten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch Rust and WebAssembly</a> . <br><br><h4>  Was weiter? </h4><br>  Nach der Ver√∂ffentlichung von Rust 2018 planen die Entwickler, mit der Community zu diskutieren, in welche Richtungen weiter gearbeitet werden soll. <br><br><h2>  Eingebettete Anwendungen </h2><br>  F√ºr die eingebettete Entwicklung war es notwendig, die Stabilit√§t der vorhandenen Funktionalit√§t zu erh√∂hen. <br><br>  Theoretisch war Rust immer eine gute Sprache f√ºr eingebettete Anwendungen.  Dies ist ein modernes Toolkit, das Entwicklern sehr fehlte, und sehr praktische Sprachfunktionen auf hoher Ebene.  All dies ohne unn√∂tige Belastung der CPU und des Speichers.  Somit eignet sich Rust hervorragend f√ºr Embedded. <br><br>  In der Praxis stellte sich dies jedoch anders heraus.  Dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabilen Kanal</a> fehlten die notwendigen Funktionen.  Dar√ºber hinaus musste f√ºr die Verwendung auf eingebetteten Ger√§ten die Standardbibliothek ge√§ndert werden.  Dies bedeutet, dass die Benutzer ihre eigene Version der Rust-Kernkiste kompilieren mussten (die Kiste, die in jeder Rust-Anwendung verwendet wird, um die grundlegenden Rust-Bausteine ‚Äã‚Äãbereitzustellen - integrierte Funktionen und Grundelemente). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  Infolgedessen waren die Entwickler auf die experimentelle Version von Rust angewiesen.  In Ermangelung automatischer Tests funktionierte die Versuchsanordnung h√§ufig nicht mit Mikrocontrollern. <br><br>  Um dies zu beheben, versuchten die Entwickler, alle erforderlichen Funktionen auf einen stabilen Kanal zu √ºbertragen und dem CI-System Tests f√ºr Mikrocontroller hinzuzuf√ºgen.  Dies bedeutet, dass durch das √Ñndern einer Desktop-Komponente die integrierte Version nicht besch√§digt wird. <br><br>  Mit solchen √Ñnderungen verlagert sich die Entwicklung eingebetteter Systeme auf Rust vom Bereich fortgeschrittener Experimente zum Bereich normaler Effizienz. <br><br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch Rust for Embedded Systems</a> . <br><br><h4>  Was weiter? </h4><br>  In diesem Jahr erhielt Rust wirklich gute Unterst√ºtzung f√ºr die beliebte ARM Cortex-M-Familie.  Viele Architekturen werden jedoch noch nicht gut unterst√ºtzt.  Rust muss erweitert werden, um andere Architekturen √§hnlich zu unterst√ºtzen. <br><br><h2>  Netzwerkaufgaben </h2><br>  Um im Netzwerk arbeiten zu k√∂nnen, musste eine Schl√ºsselabstraktion in die Sprache eingebettet werden: <code>async/await</code> .  Daher k√∂nnen Entwickler Standard-Rust-Redewendungen auch in asynchronem Code verwenden. <br><br>  Bei Netzwerkaufgaben m√ºssen Sie h√§ufig warten.  Zum Beispiel eine Antwort auf eine Anfrage.  Wenn der Code synchron ist, wird die Arbeit gestoppt: Der Kern des Prozessors, auf dem der Code ausgef√ºhrt wird, kann nichts tun, bis eine Anforderung eintrifft.  Im asynchronen Code kann eine solche Funktion jedoch in den Standby-Modus versetzt werden, w√§hrend der CPU-Kern den Rest erledigt. <br><br>  Asynchrone Programmierung ist auch in Rust 2015 m√∂glich, und dies hat viele Vorteile.  In Hochleistungsanwendungen verarbeitet die Serveranwendung viel mehr Verbindungen zu jedem Server.  Eingebettete Anwendungen auf winzigen Single-Thread-CPUs optimieren die Verwendung eines einzelnen Threads. <br><br>  Diese Vorteile sind jedoch mit einem gro√üen Nachteil verbunden: F√ºr einen solchen Code funktioniert die Kredit√ºberpr√ºfung nicht und Sie m√ºssen nicht standardm√§√üige (und leicht verwirrte) Rust-Redewendungen verwenden.  Dies ist der Vorteil von <code>async/await</code> .  Dies gibt dem Compiler die notwendigen Informationen, um das Ausleihen von asynchronen Funktionsaufrufen zu testen. <br><br>  Schl√ºsselw√∂rter f√ºr <code>async/await</code> in Version 1.31 implementiert, obwohl sie derzeit von der Implementierung nicht unterst√ºtzt werden.  Der gr√∂√üte Teil der Arbeit ist erledigt und die Funktion sollte in der n√§chsten Version verf√ºgbar sein. <br><br><h4>  Was weiter? </h4><br>  Zus√§tzlich zu einer effektiven Entwicklung auf niedriger Ebene kann Rust eine effizientere Entwicklung von Netzwerkanwendungen auf einer h√∂heren Ebene erm√∂glichen. <br><br>  Viele Server f√ºhren Routineaufgaben aus: URLs analysieren oder mit HTTP arbeiten.  Wenn Sie sie in Komponenten umwandeln - allgemeine Abstraktionen, die als Kisten geteilt werden -, ist es einfach, sie miteinander zu verbinden und alle Arten von Server- und Framework-Konfigurationen zu bilden. <br><br>  Ein experimentelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tide-Framework wurde</a> erstellt, um Komponenten zu entwickeln und zu testen. <br><br><h2>  Befehlszeilen-Tools </h2><br>  F√ºr Befehlszeilentools war es erforderlich, kleine Bibliotheken auf niedriger Ebene zu Abstraktionen auf h√∂herer Ebene zu kombinieren und einige vorhandene Tools zu verbessern. <br><br>  F√ºr einige Skripte ist bash ideal.  Zum Beispiel, um einfach andere Shell-Tools aufzurufen und Daten zwischen ihnen zu √ºbertragen. <br><br>  Aber Rust ist eine gro√üartige Option f√ºr viele andere Werkzeuge.  Wenn Sie beispielsweise ein komplexes Tool wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ripgrep</a> oder ein CLI-Tool zus√§tzlich zur Funktionalit√§t einer vorhandenen Bibliothek erstellen. <br><br>  Rust ben√∂tigt keine Laufzeit und wird in eine einzelne statische Bin√§rdatei kompiliert, was die Verteilung des Programms vereinfacht.  Und Sie erhalten Abstraktionen auf hoher Ebene, die nicht in anderen Sprachen wie C und C ++ vorliegen. <br><br>  Was kann Rust noch verbessern?  Nat√ºrlich Abstraktionen auf noch h√∂herem Niveau. <br><br>  Mit √ºbergeordneten Abstraktionen kann eine vorgefertigte CLI schnell und einfach zusammengestellt werden. <br><br>  Ein Beispiel f√ºr eine solche Abstraktion ist die Bibliothek f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">menschliche Panik</a> .  Wenn keine solche Bibliothek vorhanden ist, gibt der CLI-Code im Falle eines Fehlers wahrscheinlich das gesamte Backtracking zur√ºck.  Aber es ist nicht sehr interessant f√ºr Benutzer.  Sie k√∂nnen eine benutzerdefinierte Fehlerbehandlung hinzuf√ºgen, dies ist jedoch schwierig. <br><br>  Bei der Human Panic Library wird die Ausgabe automatisch in die Fehler-Dump-Datei verschoben.  Dem Benutzer wird eine informative Meldung angezeigt, in der er ein Problem melden und die Speicherauszugsdatei herunterladen kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Der Beginn der Entwicklung von CLI-Tools ist ebenfalls einfacher geworden.  Beispielsweise automatisiert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Confy-</a> Bibliothek ihre Konfiguration.  Er fragt nur zwei Dinge: <br><br><ul><li>  Wie hei√üt die Anwendung? </li><li>  Welche Konfigurationsparameter m√∂chten Sie bereitstellen (die Sie als eine Struktur definieren, die serialisiert und deserialisiert werden kann)? </li></ul><br>  Confy bestimmt alles andere selbst. <br><br><h4>  Was weiter? </h4><br>  Wir haben viele Aufgaben f√ºr die CLI abstrahiert.  Aber es gibt noch etwas zu abstrahieren.  Wir werden weitere solche Bibliotheken auf hoher Ebene ver√∂ffentlichen. <br><br><h1>  Rostwerkzeuge </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Wenn Sie in einer beliebigen Sprache schreiben, arbeiten Sie mit den Tools: Beginnen Sie mit dem Editor und fahren Sie mit anderen Tools in allen Phasen der Entwicklung und des Supports fort. <br><br>  Dies bedeutet, dass eine effektive Sprache von effektiven Werkzeugen abh√§ngt. <br><br>  Hier sind einige neue Tools (und Verbesserungen an bestehenden) in Rust 2018. <br><br><h2>  IDE-Unterst√ºtzung </h2><br>  Die Leistung h√§ngt nat√ºrlich von der schnellen und reibungslosen √úbertragung von Code vom Kopf des Entwicklers auf den Computerbildschirm ab.  Hier ist die IDE-Unterst√ºtzung von entscheidender Bedeutung.  Dazu ben√∂tigen wir Tools, die der IDE die Bedeutung von Rust-Code "erkl√§ren" k√∂nnen: Schlagen Sie beispielsweise sinnvolle Optionen f√ºr die automatische Vervollst√§ndigung von Zeichenfolgen vor. <br><br>  In Rust 2018 konzentrierte sich die Community auf die von der IDE geforderten Funktionen.  Mit dem Aufkommen von Rust Language Server und IntelliJ Rust unterst√ºtzen viele IDEs Rust jetzt vollst√§ndig. <br><br><h2>  Schnellere Zusammenstellung </h2><br>  Um die Compilerleistung zu verbessern, muss sie beschleunigt werden.  Das haben wir getan. <br><br>  Zuvor hat der Compiler beim Kompilieren der Rust-Kiste jede einzelne Datei in der Kiste neu kompiliert.  Die inkrementelle Kompilierung ist jetzt implementiert: Sie kompiliert nur die Teile, die sich ge√§ndert haben.  Zusammen mit anderen Optimierungen machte dies den Rust-Compiler viel schneller. <br><br><h2>  rustfmt </h2><br>  Effizienz erfordert auch, dass wir niemals √ºber Code-Formatierungsregeln streiten oder die Stile anderer Leute manuell korrigieren. <br><br>  Das rustfmt-Tool hilft dabei: Es formatiert den Code automatisch gem√§√ü dem Standardstil neu (durch den die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Community einen Konsens erreicht hat</a> ).  Rustfmt stellt sicher, dass der gesamte Rust-Code dem gleichen Stil entspricht, wie das Clang-Format f√ºr C ++ oder Prettier f√ºr JavaScript. <br><br><h2>  Clippy </h2><br>  Manchmal ist es sch√∂n, einen erfahrenen Berater in der N√§he zu haben, der Ratschl√§ge zu Best Practices f√ºr das Schreiben von Code gibt.  Dies ist, was Clippy tut: Es √ºberpr√ºft den Code w√§hrend der Anzeige und schl√§gt Standard-Idiome vor. <br><br><h2>  Rustfix </h2><br>  Wenn Sie jedoch eine alte Codebasis mit veralteten Redewendungen haben, kann es anstrengend sein, den Code unabh√§ngig zu √ºberpr√ºfen und zu korrigieren.  Sie m√∂chten nur, dass jemand Korrekturen an der gesamten Codebasis vornimmt. <br><br>  In diesen F√§llen automatisiert rustfix den Prozess.  Gleichzeitig werden Regeln von Tools wie Clippy angewendet und der alte Code gem√§√ü den Redewendungen von Rust 2018 aktualisiert. <br><br><h1>  √Ñnderungen an Rust selbst </h1><br>  √Ñnderungen im √ñkosystem haben die Effizienz der Programmierung erheblich gesteigert.  Einige Probleme k√∂nnen jedoch nur durch √Ñnderungen in der Sprache selbst gel√∂st werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Wie bereits in der Einleitung erw√§hnt, sind die meisten Sprach√§nderungen vollst√§ndig mit dem vorhandenen Rust-Code kompatibel.  Alle diese √Ñnderungen sind Teil von Rust 2018. Da sie jedoch nichts besch√§digen, funktionieren sie in jedem Rust-Code ... sogar im alten. <br><br>  Schauen wir uns die wichtigen Funktionen an, die allen Versionen hinzugef√ºgt wurden.  Dann schauen Sie sich eine kurze Liste der Funktionen von Rust 2018 an. <br><br><h2>  Neue Funktionen f√ºr alle Versionen </h2><br>  Hier ist ein kleines Beispiel f√ºr die neuen Funktionen, die in allen Versionen der Sprache verf√ºgbar sind (oder sein werden). <br><br><h4>  Genauere √úberpr√ºfung der Kreditaufnahme </h4><br>  Ein gro√üer Vorteil von Rust ist die √úberpr√ºfung der Kreditaufnahme.  Es stellt sicher, dass der Code speichersicher ist.  Dies ist aber auch eine ziemlich komplizierte Funktion f√ºr Rust-Neulinge. <br><br>  Ein Teil der Schwierigkeit liegt darin, neue Konzepte zu lernen.  Aber es gibt noch einen anderen Teil ... Das Testen von Ausleihen lehnt manchmal Code ab, der aus der Sicht eines Programmierers zu funktionieren scheint, der das Konzept der Speichersicherheit vollst√§ndig versteht. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Sie k√∂nnen eine Variable nicht ausleihen, da sie bereits ausgeliehen ist</font></i> <br><br>  Dies liegt daran, dass sich die Lebensdauer der Ausleihe bis zum Ende des Felds erstrecken sollte - beispielsweise bis zum Ende der Funktion, in der sich die Variable befindet. <br><br>  Dies bedeutete, dass anderen Variablen bis zum Ende der Funktion der Zugriff auf diesen Wert verweigert wird, selbst wenn die Variable nicht mehr mit dem Wert arbeitet und nicht mehr versucht, darauf zuzugreifen. <br><br>  Um die Situation zu korrigieren, haben wir den Scheck intelligenter gemacht.  Jetzt sieht sie, wann die Variable den Wert <i>tats√§chlich</i> verwendet hat.  Danach wird die Verwendung von Daten nicht blockiert. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Dies ist zwar nur in Rust 2018 verf√ºgbar, aber in naher Zukunft wird die Funktion allen anderen Versionen hinzugef√ºgt.  Bald werden wir mehr zu diesem Thema schreiben. <br><br><h4>  Verfahrensmakros in stabilem Rost </h4><br>  Rust hatte Makros vor Rust 1.0.  In Rust 2018 wurden jedoch ernsthafte Verbesserungen vorgenommen, beispielsweise wurden prozedurale Makros angezeigt.  Mit ihnen k√∂nnen Sie Rust Ihre eigene Syntax hinzuf√ºgen. <br><br>  Rust 2018 bietet zwei Arten von prozeduralen Makros: <br><br><h4>  Funktionsmakros </h4><br>  Mit funktions√§hnlichen Makros k√∂nnen Sie Objekte erstellen, die wie normale Funktionsaufrufe aussehen, aber tats√§chlich zur Kompilierungszeit ausgef√ºhrt werden.  Sie nehmen einen Code und geben einen anderen aus, den der Compiler dann in die Bin√§rdatei einf√ºgt. <br><br>  Sie existierten vorher, aber mit begrenztem.  Ein Makro konnte nur die match-Anweisung ausf√ºhren.  Er hatte keinen Zugriff, um alle Token im eingehenden Code anzuzeigen. <br><br>  Bei prozeduralen Makros erhalten Sie jedoch dieselbe Eingabe wie beim Parser: denselben Token-Stream.  Dies bedeutet, dass Sie viel leistungsf√§higere Makros wie Funktionen erstellen k√∂nnen. <br><br><h4>  Attribut√§hnliche Makros </h4><br>  Wenn Sie mit Dekorateuren in Sprachen wie JavaScript vertraut sind, sind Attributmakros sehr √§hnlich.  Mit ihnen k√∂nnen Sie Fragmente von Rust-Code mit Anmerkungen versehen, die vorverarbeitet und in etwas anderes umgewandelt werden sollen. <br><br>  Das <code>derive</code> macht genau das.  Wenn Sie es √ºber eine Struktur legen, nimmt der Compiler diese Struktur (nachdem sie als Liste von Token analysiert wurde) und verarbeitet sie.  Insbesondere wird eine grundlegende Implementierung von Funktionen aus dem Merkmal hinzugef√ºgt. <br><br><h4>  Ergonomischere Anleihen im Vergleich </h4><br>  Es gibt eine einfache √Ñnderung. <br><br>  Wenn Sie zuvor etwas ausleihen wollten und versuchten, eine √úbereinstimmung zu finden, mussten Sie eine seltsame Syntax hinzuf√ºgen: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Anstelle von <code>&amp;Some(ref s)</code> schreiben wir jetzt einfach <code>Some(s)</code> . <br><br><h1>  Neue Rust 2018 Funktionen </h1><br>  Der kleinste Teil von Rust 2018 enth√§lt spezifische Funktionen f√ºr diese Version.  Hier ist eine kleine Reihe von √Ñnderungen in Rust 2018. <br><br><h3>  Stichworte </h3><br>  Rust 2018 hat einige Schl√ºsselw√∂rter hinzugef√ºgt: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Diese Funktionen sind noch nicht vollst√§ndig implementiert, aber Schl√ºsselw√∂rter werden in Rust 1.31 hinzugef√ºgt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher m√ºssen wir in Zukunft keine neuen Schl√ºsselw√∂rter einf√ºhren (was zu einer inkompatiblen √Ñnderung f√ºhren w√ºrde), wenn wir diese Funktionen implementieren. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modulares System </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gro√üer Schmerz f√ºr Rust-Neulinge ist das modulare System. </font><font style="vertical-align: inherit;">Und es ist klar warum. </font><font style="vertical-align: inherit;">Es war schwer zu verstehen, warum Rust ein bestimmtes Modul ausw√§hlt. </font><font style="vertical-align: inherit;">Um dies zu beheben, haben wir einige √Ñnderungen am Pfadmechanismus vorgenommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beispielsweise ein Rack importiert haben, k√∂nnen Sie es im Pfad auf der obersten Ebene verwenden. </font><font style="vertical-align: inherit;">Wenn Sie jedoch Code in ein Submodul verschieben, funktioniert dies nicht mehr.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel ist das Pr√§fix </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das sowohl f√ºr die Wurzel der Kiste als auch f√ºr die externe Kiste verwendet wird. </font><font style="vertical-align: inherit;">Es ist schwer zu verstehen, was vor uns liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben es expliziter gemacht. </font><font style="vertical-align: inherit;">Wenn Sie sich nun auf die Wurzelkiste beziehen m√∂chten, verwenden Sie das Pr√§fix </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist nur eine der Verbesserungen zur Klarheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der aktuelle Code die Funktionen von Rust 2018 nutzen soll, m√ºssen Sie den Code h√∂chstwahrscheinlich aktualisieren, um die neuen Pfade widerzuspiegeln. </font><font style="vertical-align: inherit;">Dies muss jedoch nicht manuell erfolgen. </font><font style="vertical-align: inherit;">Bevor Sie den Versionsbezeichner zu Cargo.toml hinzuf√ºgen, f√ºhren Sie ihn einfach aus </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nehmen Sie </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die erforderlichen √Ñnderungen vor.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Informationen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Informationen zur neuen Version der Sprache sind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Rust 2018-Handbuch enthalten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432564/">https://habr.com/ru/post/de432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432554/index.html">Douglas Engelbart: St√§rkung der ‚ÄûCollective IQ‚Äú -Gesellschaft</a></li>
<li><a href="../de432556/index.html">Tesla patentierte Technologie zur Positionierung von Fahrzeugen</a></li>
<li><a href="../de432558/index.html">Architekturmuster ‚ÄûBesucher‚Äú in den Universen ‚ÄûiOS‚Äú und ‚ÄûSwift‚Äú</a></li>
<li><a href="../de432560/index.html">Typografie im Web. Yandex-Vortrag bei FrontTalks 2018</a></li>
<li><a href="../de432562/index.html">Techday Make IT Real - 17. Dezember, Moskau</a></li>
<li><a href="../de432566/index.html">Zwei Welten oder "Ingenieure haben etwas zu sagen." Zu den verschiedenen Arten komplexer Aufgaben und den damit verbundenen Prozessen</a></li>
<li><a href="../de432568/index.html">‚ÄûWenn Sie der Chefredakteur von Rusbase sind‚Äú: Ein neuer Podcast √ºber die Arbeit mit Inhalten und eine Karriere in Technologiemedien</a></li>
<li><a href="../de432572/index.html">Der Metall-Luft-Transistor wird das Moore'sche Gesetz erweitern - wie Technologie funktioniert</a></li>
<li><a href="../de432574/index.html">Anspruchsvolles Design einfacher Ger√§te</a></li>
<li><a href="../de432576/index.html">Unter der Haube eines JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>