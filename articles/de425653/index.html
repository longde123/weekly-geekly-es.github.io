<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóùÔ∏è ü§öüèº üóÑÔ∏è Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 1 ‚ùå üë©üèø‚Äçüöí üë®üèø‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung in die Microservice-Architektur 
 Teil 1 von 10 


 Anpassung von Ewan Valentine Artikeln. 


 Dies ist eine Serie von zehn Teilen. Ich wer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425653/"><h2 id="vvedenie-v-mikroservisnuyu-arhitekturu">  Einf√ºhrung in die Microservice-Architektur </h2><br><h4 id="chast-1-iz-10">  Teil 1 von 10 </h4><br><p>  Anpassung von Ewan Valentine Artikeln. </p><br><p>  Dies ist eine Serie von zehn Teilen. Ich werde versuchen, einmal im Monat √ºber den Aufbau von Mikrodiensten auf Golang zu schreiben.  Ich werde Protobuf und gRPC als Haupttransportprotokoll verwenden. </p><br><p>  Der Stapel, den ich verwendet habe: Golang, Mongodb, Grpc, Docker, Google Cloud, Kubernetes, NATS, CircleCI, Terraform und Go-Micro. </p><br><p>  Wozu brauche ich das?  Da ich lange gebraucht habe, um es herauszufinden und die angesammelten Probleme zu l√∂sen.  Ich wollte Ihnen auch mitteilen, was ich √ºber das Erstellen, Testen und Bereitstellen von Microservices on Go und anderen neuen Technologien gelernt habe. </p><br><p>  In diesem Teil m√∂chte ich die grundlegenden Konzepte und Technologien f√ºr den Aufbau von Microservices zeigen.  Schreiben wir eine einfache Implementierung.  Das Projekt wird die folgenden Entit√§ten haben: </p><br><ul><li>  Ladung </li><li>  Inventar </li><li>  Versuch </li><li>  die Benutzer </li><li>  die Rollen </li><li>  Authentifizierung </li></ul><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rw/x9/gb/rwx9gbtjbpn9m44olxapvk2ecgq.jpeg"><br><p>  Um weiter zu gehen, m√ºssen Sie Golang und die erforderlichen Bibliotheken installieren und ein Git-Repository erstellen. </p><br><h2 id="teoriya">  Theorie </h2><br><h4 id="chto-takoe-mikroservisnaya-arhitektura">  Was ist Microservice-Architektur? </h4><br><p>  Microservices isolieren eine separate Funktionalit√§t in einen Dienst, die hinsichtlich der von diesem Dienst ausgef√ºhrten Funktion autark ist.  Zur Kompatibilit√§t mit anderen Diensten verf√ºgt es √ºber eine bekannte und vordefinierte Schnittstelle. <br>  Microservices kommunizieren miteinander √ºber Nachrichten, die √ºber einen zwischengeschalteten Nachrichtenbroker √ºbertragen werden. </p><br><img src="https://habrastorage.org/webt/tr/aq/dm/traqdmhafa_yvh0haprr05w7rgo.png"><br><p>  Dank der Microservice-Architektur kann die Anwendung nicht ganz, sondern teilweise skaliert werden.  Wenn der Autorisierungsdienst beispielsweise h√§ufiger als andere zuckt, k√∂nnen wir die Anzahl der Instanzen erh√∂hen.  Dieses Konzept steht im Einklang mit den Konzepten des Cloud Computing und der Containerisierung im Allgemeinen. </p><br><h4 id="pochemu-golang">  Warum Golang? </h4><br><p>  Microservices werden in fast allen Sprachen unterst√ºtzt, schlie√ülich sind Microservices ein Konzept, keine bestimmte Struktur oder ein bestimmtes Werkzeug.  Einige Sprachen sind jedoch besser geeignet und unterst√ºtzen dar√ºber hinaus Microservices besser als andere.  Eine Sprache mit gro√üer Unterst√ºtzung ist Golang. </p><br><h4 id="poznakomimsya-s-protobufgrpc">  Treffen Sie protobuf / gRPC </h4><br><p>  Wie bereits erw√§hnt, sind Microservices in separate Codebasen unterteilt. Eines der wichtigsten Probleme bei Microservices ist die Kommunikation.  Wenn Sie einen Monolithen haben, k√∂nnen Sie den Code einfach direkt von einer anderen Stelle in Ihrem Programm aus aufrufen. </p><br><p>  Um das Kommunikationsproblem zu l√∂sen, k√∂nnen wir den traditionellen REST-Ansatz verwenden und Daten im JSON- oder XML-Format √ºber HTTP √ºbertragen.  Dieser Ansatz hat jedoch die Nachteile, dass Sie vor dem Senden einer Nachricht Ihre Daten verschl√ºsseln und auf der Empfangsseite wieder entschl√ºsseln m√ºssen.  Dies ist ein Overhead und erh√∂ht die Komplexit√§t des Codes. </p><br><p>  Es gibt eine L√∂sung!  Dies ist das <strong>gRPC-</strong> Protokoll - ein leichtes, bin√§rbasiertes Protokoll, das die √úbertragung von HTTP-Headern eliminiert und uns einige Bytes spart.  Zuk√ºnftiges HTTP2 impliziert auch die Verwendung von Bin√§rdaten, was wiederum f√ºr gRPC spricht.  HTTP2 erm√∂glicht bidirektionale Kommunikation und es ist fantastisch! </p><br><p>  Mit GRPC k√∂nnen Sie auch die Schnittstelle zu Ihrem Dienst in einem <strong>benutzerfreundlichen</strong> Format definieren - dies ist&gt; <strong>protobuf</strong> . </p><br><h2 id="praktika">  √úbe </h2><br><p>  Erstellen Sie die Datei /project/consigment.proto. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Protobuf-Dokumentation</a> </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre><code class="plaintext hljs">//consigment.proto syntax = "proto3"; package go.micro.srv.consignment; service ShippingService { rpc CreateConsignment(Consignment) returns (Response) {} } message Consignment { string id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { string id = 1; string customer_id = 2; string origin = 3; string user_id = 4; } message Response { bool created = 1; Consignment consignment = 2; }</code> </pre> </div></div><br><p>  Dies ist ein einfaches Beispiel, das den Dienst enth√§lt, den Sie f√ºr andere Dienste bereitstellen m√∂chten: Dienst ShippingService. Anschlie√üend definieren wir unsere Nachrichten.  Protobuf ist ein statisch typisiertes Protokoll, und wir k√∂nnen benutzerdefinierte Typen erstellen (√§hnlich wie Strukturen in Golang).  Hier ist der Container im Stapel verschachtelt. </p><br><p>  Installieren Sie die Bibliotheken, den Compiler und kompilieren Sie unser Protokoll: </p><br><pre> <code class="bash hljs">$ go get -u google.golang.org/grpc $ go get -u github.com/golang/protobuf/protoc-gen-go $ sudo apt install protobuf-compiler $ mkdir consignment &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> consignment $ protoc -I=. --go_out=plugins=grpc:. consignment.proto</code> </pre> <br><p>  Die Ausgabe sollte eine Datei sein: </p><br><div class="spoiler">  <b class="spoiler_title">consignment.pb.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by protoc-gen-go. DO NOT EDIT. // source: consignment.proto package consignment import ( fmt "fmt" proto "github.com/golang/protobuf/proto" context "golang.org/x/net/context" grpc "google.golang.org/grpc" math "math" ) // Reference imports to suppress errors if they are not otherwise used. var _ = proto.Marshal var _ = fmt.Errorf var _ = math.Inf // This is a compile-time assertion to ensure that this generated file // is compatible with the proto package it is being compiled against. // A compilation error at this line likely means your copy of the // proto package needs to be updated. const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package type Consignment struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"` Weight int32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"` Containers []*Container `protobuf:"bytes,4,rep,name=containers,proto3" json:"containers,omitempty"` VesselId string `protobuf:"bytes,5,opt,name=vessel_id,json=vesselId,proto3" json:"vessel_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Consignment) Reset() { *m = Consignment{} } func (m *Consignment) String() string { return proto.CompactTextString(m) } func (*Consignment) ProtoMessage() {} func (*Consignment) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{0} } func (m *Consignment) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Consignment.Unmarshal(m, b) } func (m *Consignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Consignment.Marshal(b, m, deterministic) } func (m *Consignment) XXX_Merge(src proto.Message) { xxx_messageInfo_Consignment.Merge(m, src) } func (m *Consignment) XXX_Size() int { return xxx_messageInfo_Consignment.Size(m) } func (m *Consignment) XXX_DiscardUnknown() { xxx_messageInfo_Consignment.DiscardUnknown(m) } var xxx_messageInfo_Consignment proto.InternalMessageInfo func (m *Consignment) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Consignment) GetDescription() string { if m != nil { return m.Description } return "" } func (m *Consignment) GetWeight() int32 { if m != nil { return m.Weight } return 0 } func (m *Consignment) GetContainers() []*Container { if m != nil { return m.Containers } return nil } func (m *Consignment) GetVesselId() string { if m != nil { return m.VesselId } return "" } type Container struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"` Origin string `protobuf:"bytes,3,opt,name=origin,proto3" json:"origin,omitempty"` UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Container) Reset() { *m = Container{} } func (m *Container) String() string { return proto.CompactTextString(m) } func (*Container) ProtoMessage() {} func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{1} } func (m *Container) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Container.Unmarshal(m, b) } func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Container.Marshal(b, m, deterministic) } func (m *Container) XXX_Merge(src proto.Message) { xxx_messageInfo_Container.Merge(m, src) } func (m *Container) XXX_Size() int { return xxx_messageInfo_Container.Size(m) } func (m *Container) XXX_DiscardUnknown() { xxx_messageInfo_Container.DiscardUnknown(m) } var xxx_messageInfo_Container proto.InternalMessageInfo func (m *Container) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Container) GetCustomerId() string { if m != nil { return m.CustomerId } return "" } func (m *Container) GetOrigin() string { if m != nil { return m.Origin } return "" } func (m *Container) GetUserId() string { if m != nil { return m.UserId } return "" } type Response struct { Created bool `protobuf:"varint,1,opt,name=created,proto3" json:"created,omitempty"` Consignment *Consignment `protobuf:"bytes,2,opt,name=consignment,proto3" json:"consignment,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Response) Reset() { *m = Response{} } func (m *Response) String() string { return proto.CompactTextString(m) } func (*Response) ProtoMessage() {} func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{2} } func (m *Response) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Response.Unmarshal(m, b) } func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Response.Marshal(b, m, deterministic) } func (m *Response) XXX_Merge(src proto.Message) { xxx_messageInfo_Response.Merge(m, src) } func (m *Response) XXX_Size() int { return xxx_messageInfo_Response.Size(m) } func (m *Response) XXX_DiscardUnknown() { xxx_messageInfo_Response.DiscardUnknown(m) } var xxx_messageInfo_Response proto.InternalMessageInfo func (m *Response) GetCreated() bool { if m != nil { return m.Created } return false } func (m *Response) GetConsignment() *Consignment { if m != nil { return m.Consignment } return nil } func init() { proto.RegisterType((*Consignment)(nil), "Consignment") proto.RegisterType((*Container)(nil), "Container") proto.RegisterType((*Response)(nil), "Response") } func init() { proto.RegisterFile("consignment.proto", fileDescriptor_3804bf87090b51a9) } var fileDescriptor_3804bf87090b51a9 = []byte{ // 281 bytes of a gzipped FileDescriptorProto 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xbf, 0x4e, 0x33, 0x31, 0x10, 0xc4, 0xbf, 0xcb, 0xff, 0x5b, 0x7f, 0x02, 0xc5, 0x05, 0x58, 0x50, 0x70, 0xba, 0x2a, 0xa2, 0x70, 0x11, 0x9e, 0x00, 0xa5, 0x4a, 0xeb, 0xd0, 0xa3, 0x60, 0xaf, 0x2e, 0x2b, 0x11, 0xfb, 0x64, 0x3b, 0xe1, 0x75, 0x78, 0x54, 0x74, 0xbe, 0x1c, 0x18, 0x51, 0xce, 0xac, 0x67, 0xf7, 0xa7, 0x31, 0x2c, 0xb5, 0xb3, 0x81, 0x1a, 0x7b, 0x44, 0x1b, 0x65, 0xeb, 0x5d, 0x74, 0xf5, 0x67, 0x01, 0x6c, 0xf3, 0xe3, 0xf2, 0x2b, 0x18, 0x91, 0x11, 0x45, 0x55, 0xac, 0xa6, 0x6a, 0x44, 0x86, 0x57, 0xc0, 0x0c, 0x06, 0xed, 0xa9, 0x8d, 0xe4, 0xac, 0x18, 0x55, 0xc5, 0xaa, 0x54, 0xb9, 0xc5, 0x6f, 0x60, 0xf6, 0x81, 0xd4, 0x1c, 0xa2, 0x18, 0xa7, 0xd4, 0x45, 0xf1, 0x47, 0x00, 0xed, 0x6c, 0xdc, 0x93, 0x45, 0x1f, 0xc4, 0xa4, 0x1a, 0xaf, 0xd8, 0x1a, 0xe4, 0x66, 0xb0, 0x54, 0x36, 0xe5, 0xf7, 0x50, 0x9e, 0x31, 0x04, 0x7c, 0x7f, 0x25, 0x23, 0xa6, 0xe9, 0xc6, 0xa2, 0x37, 0xb6, 0xa6, 0x3e, 0x42, 0xf9, 0x9d, 0xfa, 0xc3, 0xf7, 0x00, 0x4c, 0x9f, 0x42, 0x74, 0x47, 0xf4, 0x5d, 0xb6, 0xe7, 0x83, 0xc1, 0xda, 0x9a, 0x0e, 0xcf, 0x79, 0x6a, 0xc8, 0x26, 0xbc, 0x52, 0x5d, 0x14, 0xbf, 0x85, 0xf9, 0x29, 0xf4, 0xa1, 0x49, 0x3f, 0xe8, 0xe4, 0xd6, 0xd4, 0x2f, 0xb0, 0x50, 0x18, 0x5a, 0x67, 0x03, 0x72, 0x01, 0x73, 0xed, 0x71, 0x1f, 0xb1, 0x3f, 0xb9, 0x50, 0x83, 0xe4, 0x12, 0x58, 0x56, 0x66, 0xba, 0xcb, 0xd6, 0xff, 0x65, 0x56, 0xa5, 0xca, 0x1f, 0xac, 0x9f, 0xe1, 0x7a, 0x77, 0xa0, 0xb6, 0x25, 0xdb, 0xec, 0xd0, 0x9f, 0x49, 0x23, 0x97, 0xb0, 0xdc, 0xa4, 0x6d, 0x79, 0xff, 0xbf, 0x56, 0xdc, 0x95, 0x72, 0x40, 0xa9, 0xff, 0xbd, 0xcd, 0xd2, 0x8f, 0x3d, 0x7d, 0x05, 0x00, 0x00, 0xff, 0xff, 0x84, 0x5c, 0xa4, 0x06, 0xc6, 0x01, 0x00, 0x00, } // Reference imports to suppress errors if they are not otherwise used. var _ context.Context var _ grpc.ClientConn // This is a compile-time assertion to ensure that this generated file // is compatible with the grpc package it is being compiled against. const _ = grpc.SupportPackageIsVersion4 // ShippingServiceClient is the client API for ShippingService service. // // For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream. type ShippingServiceClient interface { CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) } type shippingServiceClient struct { cc *grpc.ClientConn } func NewShippingServiceClient(cc *grpc.ClientConn) ShippingServiceClient { return &amp;shippingServiceClient{cc} } func (c *shippingServiceClient) CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) { out := new(Response) err := c.cc.Invoke(ctx, "/ShippingService/CreateConsignment", in, out, opts...) if err != nil { return nil, err } return out, nil } // ShippingServiceServer is the server API for ShippingService service. type ShippingServiceServer interface { CreateConsignment(context.Context, *Consignment) (*Response, error) } func RegisterShippingServiceServer(s *grpc.Server, srv ShippingServiceServer) { s.RegisterService(&amp;_ShippingService_serviceDesc, srv) } func _ShippingService_CreateConsignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(Consignment) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(ShippingServiceServer).CreateConsignment(ctx, in) } info := &amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: "/ShippingService/CreateConsignment", } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(ShippingServiceServer).CreateConsignment(ctx, req.(*Consignment)) } return interceptor(ctx, in, info, handler) } var _ShippingService_serviceDesc = grpc.ServiceDesc{ ServiceName: "ShippingService", HandlerType: (*ShippingServiceServer)(nil), Methods: []grpc.MethodDesc{ { MethodName: "CreateConsignment", Handler: _ShippingService_CreateConsignment_Handler, }, }, Streams: []grpc.StreamDesc{}, Metadata: "consignment.proto", }</span></span></code> </pre> <br><p>  Wenn ja, dann ist etwas schief gelaufen.  Achten Sie auf die Argumente -I ist der Pfad, in dem der Compiler nach Dateien sucht, --go_out, in dem eine neue Datei erstellt wird.  Es gibt immer Hilfe </p><br><pre> <code class="bash hljs">$ protoc -h</code> </pre> </div></div><br><p>  Dies ist der Code, der automatisch von den gRPC / protobuf-Bibliotheken generiert wird, damit Sie Ihre protobuf-Definition mit Ihrem eigenen Code verkn√ºpfen k√∂nnen. </p><br><h4 id="napishem-maingo">  Wir werden main.go schreiben </h4><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> seaport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    pbf "seaport/consignment" "golang.org/x/net/context" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ) const ( port = ":50051" ) //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) } // Repository -    , //        type Repository struct { consignments []*pbf.Consignment } //Create -    func (repo *Repository) Create(consignment *pbf.Consignment) (*pbf.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } //         //       .     //         . . type service struct { repo IRepository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pbf.Consignment) (*pbf.Response, error) { //      consignment, err := s.repo.Create(req) if err != nil { return nil, err } //   `Response`, //        return &amp;pbf.Response{Created: true, Consignment: consignment}, nil } func main() { repo := &amp;Repository{} //   gRPC    tcp lis, err := net.Listen("tcp", port) if err != nil { log.Fatalf("failed to listen: %v", err) } s := grpc.NewServer() //      gRPC,    //        //  `Response`,       pbf.RegisterShippingServiceServer(s, &amp;service{repo}) //      gRPC. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } }</span></span></code> </pre> </div></div><br><p>  Bitte lesen Sie die Kommentare im Code sorgf√§ltig durch.  Anscheinend erstellen wir hier eine Implementierungslogik, in der unsere gRPC-Methoden unter Verwendung der generierten Formate interagieren und einen neuen gRPC-Server auf Port 50051 erstellen. Jetzt wird unser gRPC-Dienst dort leben. <br>  Sie k√∂nnen dies mit <strong>$ go run main.go ausf√ºhren</strong> , aber Sie sehen nichts und k√∂nnen es nicht verwenden ... Erstellen wir also einen Client, um es in Aktion zu sehen. </p><br><p>  Erstellen wir eine Befehlszeilenschnittstelle, die eine JSON-Datei verwendet und mit unserem gRPC-Dienst interagiert. </p><br><p>  Erstellen Sie im Stammverzeichnis ein neues Unterverzeichnis von <strong>$ mkdir consignment-cli</strong> .  Erstellen Sie in diesem Verzeichnis eine cli.go-Datei mit folgendem Inhalt: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) }</span></span></code> </pre> </div></div><br><p>  Erstellen Sie nun einen Stapel (consignment-cli / consignment.json): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"vessel_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span> }</code> </pre> <br><p>  Wenn Sie nun <strong>$ go ausf√ºhren, f√ºhren Sie main.go</strong> aus dem <strong>Seehafenpaket aus</strong> und f√ºhren Sie dann <strong>$ go run cli.go</strong> in einem separaten Terminalfenster aus.  Sie sollten die Meldung "Erstellt: wahr" sehen. <br>  Aber wie k√∂nnen wir √ºberpr√ºfen, was genau erstellt wurde?  Lassen Sie uns unseren Service mithilfe der GetConsignments-Methode aktualisieren, damit wir alle von uns erstellten Stapel anzeigen k√∂nnen. </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//consigment.proto syntax = "proto3"; service ShippingService{ rpc CreateConsignment(Consignment) returns (Response) {} //    rpc GetConsignments(GetRequest) returns (Response) {} } message Consignment { int32 id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { int32 id =1; string customer_id =2; string origin = 3; string user_id = 4; } //    message GetRequest {} message Response { bool created = 1; Consignment consignment = 2; //     //     repeated Consignment consignments = 3; }</span></span></code> </pre> </div></div><br><p>  Also haben wir hier eine neue Methode f√ºr unseren Service namens <strong>GetConsignments</strong> erstellt. <strong>Au√üerdem</strong> haben wir eine neue <strong>GetRequest erstellt</strong> , die noch nichts enth√§lt.  Wir haben unserer Antwortnachricht auch ein Feld mit gesendeten Stapeln hinzugef√ºgt.  Sie werden feststellen, dass der Typ hier das wiederholte Schl√ºsselwort bis zum Typ hat.  Wie Sie wahrscheinlich vermutet haben, bedeutet dies einfach, dieses Feld als Array dieser Typen zu behandeln. </p><br><p>  Beeilen Sie sich nicht, um das Programm auszuf√ºhren. Die Implementierung unserer gRPC-Methoden basiert auf der √úbereinstimmung der von der protobuf-Bibliothek erstellten Schnittstelle. Wir m√ºssen sicherstellen, dass unsere Implementierung unserer Protodefinition entspricht. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//seaport/main.go //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) GetAll() []*pbf.Consignment } //GetAll -       func (repo *Repository) GetAll() []*pbf.Consignment { return repo.consignments } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pbf.GetRequest) (*pbf.Response, error) { consignments := s.repo.GetAll() return &amp;pbf.Response{Consignments: consignments}, nil }</span></span></code> </pre> <br><p>  Hier haben wir unsere neue GetConsignments-Methode aufgenommen, unser Repository und unsere Schnittstelle aktualisiert und jeweils in der Definition von consignments.proto erstellt.  Wenn Sie <strong>$ go run main.go erneut ausf√ºhren</strong> , sollte das Programm erneut funktionieren. </p><br><p>  Lassen Sie uns unser CLI-Tool aktualisieren, um die M√∂glichkeit zu bieten, diese Methode aufzurufen, und es ist m√∂glich, unsere Parteien aufzulisten: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pbf.GetRequest{}) if err != nil { log.Fatalf("    : %v", err) } for _, cns := range getAll.Consignments { fmt.Printf("Id: %v\n", cns.GetId()) fmt.Printf("Description: %v\n", cns.GetDescription()) fmt.Printf("Weight: %d\n", cns.GetWeight()) fmt.Printf("VesselId: %v\n", cns.GetVesselId()) for _, cnt := range cns.GetContainers() { fmt.Printf("\tId: %v\n", cnt.GetId()) fmt.Printf("\tUserId: %v\n", cnt.GetUserId()) fmt.Printf("\tCustomerId: %v\n", cnt.GetCustomerId()) fmt.Printf("\tOrigin: %v\n", cnt.GetOrigin()) } } }</span></span></code> </pre> </div></div><br><p>  F√ºgen Sie den obigen Code zu cli.go hinzu und f√ºhren Sie <strong>$ go run cli.go erneut aus</strong> .  Der Client f√ºhrt CreateConsignment aus und ruft dann GetConsignments auf.  Und Sie sollten sehen, dass in der Antwortliste die Zusammensetzung der Partei enth√§lt. </p><br><p>  Somit haben wir den ersten Microservice und Client, der mit Protobuf und gRPC mit ihm interagiert. </p><br><p>  Der n√§chste Teil dieser Reihe wird die Go-Micro-Integration beinhalten, die eine leistungsstarke Grundlage f√ºr die Erstellung von gRPC-basierten Microservices darstellt.  Wir werden auch unseren zweiten Service erstellen.  Betrachten Sie die Arbeit unserer Dienste in Docker-Containern im n√§chsten Teil dieser Artikelserie. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425653/">https://habr.com/ru/post/de425653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425641/index.html">Die Bewohner der kanadischen Stadt haben einen "Uber-Service" mit Bussen entwickelt, nicht mit Autos</a></li>
<li><a href="../de425643/index.html">Digitale Ereignisse in Moskau vom 8. bis 14. Oktober</a></li>
<li><a href="../de425645/index.html">SpaceX und SAOCOM - 1A Neue Mission. Fertig</a></li>
<li><a href="../de425647/index.html">UI-Test: √úberpr√ºfen des Systems mit unterschiedlichen Aufl√∂sungen</a></li>
<li><a href="../de425649/index.html">BDSM, Gore und das Drupal Developer Pursuit</a></li>
<li><a href="../de425657/index.html">Die Unvermeidlichkeit der Bestrafung, die Wirksamkeit pl√∂tzlicher Kontrollen</a></li>
<li><a href="../de425659/index.html">Interaktives Design muss nicht kompliziert sein.</a></li>
<li><a href="../de425661/index.html">22 Tipps f√ºr einen Angular-Entwickler. Teil 1</a></li>
<li><a href="../de425663/index.html">22 Tipps f√ºr einen Angular-Entwickler. Teil 2</a></li>
<li><a href="../de425665/index.html">Git: Fehler beheben und Commits beheben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>