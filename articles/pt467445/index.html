<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¨ üßîüèª üî≤ Lista indescrit√≠vel de atualiza√ß√µes instaladas do Windows ‚òéÔ∏è üîì üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ j√° se perguntou por que uma lista de atualiza√ß√µes instaladas do Windows √© gerada? E atrav√©s de qual API obt√™-lo? Tentarei dar respostas a essas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lista indescrit√≠vel de atualiza√ß√µes instaladas do Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  Voc√™ j√° se perguntou por que uma lista de atualiza√ß√µes instaladas do Windows √© gerada?  E atrav√©s de qual API obt√™-lo?  Tentarei dar respostas a essas e outras quest√µes emergentes em meu pequeno estudo. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Antecedentes ou como tudo come√ßou. </h2><br>  Todos os anos √© realizada uma confer√™ncia de jovens especialistas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nossa empresa</a> , onde cada participante pode resolver o problema de um departamento (uma lista de t√≥picos √© proposta com anteced√™ncia).  E o departamento de SPAS (suporte de software e hardware) teve a seguinte tarefa, que me interessou, al√©m disso, tornou poss√≠vel retornar √† programa√ß√£o novamente (infelizmente, no momento em que trabalho nesta empresa como um simples operador de NPPS). <br><br>  Anteriormente, para cada "TO" com a ajuda do WSUS, todas as atualiza√ß√µes lan√ßadas eram puxadas e distribu√≠das para todas as m√°quinas.  O TSB (boletins de servi√ßo t√©cnico) tamb√©m aparecia periodicamente, indicando que era necess√°rio instalar as atualiza√ß√µes necess√°rias na forma de pacotes isolados.  Como resultado, acumulamos atualiza√ß√µes que n√£o podem ser rastreadas no WSUS, mas s√≥ podem ser vistas atrav√©s do painel de controle na se√ß√£o "Atualiza√ß√µes instaladas". <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Esquema de atualiza√ß√£o visual"><br><br>  H√° situa√ß√µes em que a esta√ß√£o de trabalho ou o servidor "trava" e voc√™ precisa restaur√°-lo a partir de uma imagem criada h√° algum tempo.  Ao recuperar a partir de uma imagem, h√° uma chance de que possamos perder as atualiza√ß√µes necess√°rias (que vieram na forma de pacotes isolados) que foram instaladas antes da falha da m√°quina.  Explicado da forma mais detalhada poss√≠vel, porque os esclarecimentos j√° ser√£o um segredo comercial. <br><br>  √â por isso que surgiu a id√©ia de criar um programa que pudesse extrair essa lista de atualiza√ß√µes (de prefer√™ncia <b>remotamente</b> pela rede local), gravar em um arquivo / banco de dados, comparar a lista atual com um determinado modelo e enviar uma mensagem ao sistema SCADA por meio de um dos protocolos - SNMP, OPC. <br><br>  Como voc√™ deve ter adivinhado no t√≠tulo do artigo, eu j√° tinha uma tarefa dif√≠cil de escolher o m√©todo de recupera√ß√£o de lista.  Como sempre, decidi procurar o caminho certo no mecanismo de pesquisa, fiz perguntas sobre recursos especializados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> , por algum motivo, o fluxo de pilha em ingl√™s n√£o gostou da minha pergunta e precisou ser exclu√≠do), mas todas as respostas n√£o deram o resultado desejado.  Portanto, eu mesmo tive que descobrir isso, o que ser√° discutido mais adiante. <br><br><h2>  Comandos do console </h2><br>  Vamos come√ßar com um simples e aproveitar o que o Windows nos oferece sem usar ferramentas de terceiros.  Isso pode ser feito usando os seguintes comandos: <br><br><ul><li>  lista wmic qfe </li><li>  systeminfo </li><li>  dism / online / get-packages </li><li>  atrav√©s do PowerShell: <br><br><ul><li>  <b>Obter hotfix</b> </li><li>  <b>Get-SilWindowsUpdate</b> (dispon√≠vel apenas nas edi√ß√µes do servidor) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - atrav√©s do acesso √† classe WMI win32_quickfixengineering (sobre o WMI um pouco mais tarde) </li></ul><br></li></ul><br><br>  Voc√™ pode obter a lista atrav√©s da interface gr√°fica atrav√©s do item padr√£o do Painel de Controle ‚ÄúAdicionar / Remover Programas‚Äù, mas n√£o podemos copiar nada a partir da√≠.  Cada ferramenta do painel de controle √© representada por um arquivo .cpl na pasta Windows \ System.  Os arquivos .Cpl na pasta do sistema do Windows s√£o baixados automaticamente quando o painel de controle √© iniciado.  O arquivo Appwiz.cpl √© respons√°vel pelo item do programa.  Sua an√°lise n√£o levou a nada. <br><br>  A sa√≠da do comando do console pode ser redirecionada para um arquivo e, em seguida, pode ser analisada, mas isso est√° errado, al√©m de uma chamada de programa (de acordo com as regras do SB, n√£o funcionar√°) e n√£o h√° d√∫vida de receber a lista remotamente.  Portanto, sugiro que voc√™ simplesmente chame os comandos, compare o n√∫mero de atualiza√ß√µes em cada lista com a lista no Painel de Controle e continue nossa investiga√ß√£o. <br><br>  Formalmente, todos os m√©todos para obter a lista de atualiza√ß√µes podem ser divididos em dois grupos: local e de rede. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="Metodos locais e de rede para obter informa√ß√µes"><br><br>  Todos os m√©todos foram testados em imagens limpas do sistema (Windows 7, 8, Server 2012 R2) com atualiza√ß√µes integradas. Ap√≥s cada atualiza√ß√£o pelo Update Center dos servidores oficiais da Microsoft, uma verifica√ß√£o adicional era realizada.  Vamos nos debru√ßar sobre cada um deles com mais detalhes. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WUApi</a> (API do Windows Update Agent) - Usando a API do Windows Update Agent.  A op√ß√£o mais √≥bvia, cujo nome fala por si.  Usaremos a biblioteca Wuapi.dll para isso. <br><blockquote>  Nota: a seguir, para minha conveni√™ncia, incorporarei todos os resultados na Lista.  Isso pode n√£o ser racional, mas me pareceu uma boa ideia. </blockquote><div class="spoiler">  <b class="spoiler_title">Exemplo de implementa√ß√£o</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  H√° uma segunda varia√ß√£o desse m√©todo: <b>Update Session</b> - recebendo informa√ß√µes conectando-se √† sess√£o de atualiza√ß√£o do Windows Update Agent (nesse caso, n√£o trabalhamos diretamente com a biblioteca). <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de implementa√ß√£o</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  A Microsoft sugere o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso</a> remoto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da API</a> . <br><br>  As principais desvantagens desses dois m√©todos s√£o que eles n√£o permitem encontrar corre√ß√µes de KB que n√£o s√£o distribu√≠das pelo Windows Update.  Voc√™ s√≥ pode ver o que passou pelo pr√≥prio agente de atualiza√ß√£o, ou seja, essa op√ß√£o n√£o √© adequada para n√≥s. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Gerenciamento e Manuten√ß√£o de Imagens de Implanta√ß√£o</a> √© uma ferramenta de linha de comando que pode ser usada para atender uma imagem do Windows ou para preparar uma imagem de um Ambiente de Pr√©-instala√ß√£o do Windows (Windows PE).  √â um substituto para o Gerenciador de Pacotes (Pkgmgr.exe), PEimg e Intlcfg. <br><br>  Este utilit√°rio √© usado para integrar atualiza√ß√µes, service packs √† imagem do sistema.  As atualiza√ß√µes do Windows s√£o m√≥dulos separados que podem ser apresentados de v√°rias maneiras: <br><br><ul><li>  Arquivos .cab (Cabinet) - arquivos.  Projetado para distribui√ß√£o e instala√ß√£o usando os m√≥dulos do Windows Update em um modo automatizado; </li><li>  Arquivos .msu (Pacote Independente do Microsoft Update) - arquivos execut√°veis.  Projetado para distribui√ß√£o e instala√ß√£o pelos pr√≥prios usu√°rios no modo manual por meio do cat√°logo de atualiza√ß√µes da Microsoft.  Na verdade, eles s√£o um conjunto empacotado que consiste em arquivos .cab-, .xml, .txt. </li></ul><br>  O comando <b>dism / online / get-packages</b> mencionado anteriormente exibe informa√ß√µes b√°sicas sobre todos os pacotes no sistema wim image / current.  A Microsoft cuidou de n√≥s e fornece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacotes NuGet</a> para uso conveniente da API. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de implementa√ß√£o</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  O n√∫mero de atualiza√ß√µes coincidiu com o n√∫mero da lista do Painel de Controle at√© a primeira atualiza√ß√£o pelo centro de controle - depois disso, o n√∫mero de atualiza√ß√µes se tornou menor (eram 214, passou a 209), embora logicamente elas devam aumentar.  Exemplos de sa√≠da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Antes de atualizar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depois de atualizar</a> . <br><br>  Qual √© a raz√£o disso, posso apenas especular - talvez algumas atualiza√ß√µes substituam as anteriores, portanto, o n√∫mero se tornou menor. <br><br>  Um pouco mais tarde, deparei-me com um utilit√°rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DISM ++</a> chin√™s, que n√£o √© baseado na API do DISM ou na API do DISM Core, mas as bibliotecas que ele possui n√£o possuem os m√©todos que eu preciso abrir, ent√£o abandonei essa id√©ia e continuei pesquisando mais. <br><br><h2>  WSUS </h2><br>  O Windows Server Update Services ( <a href="">WSUS</a> ) √© um servidor para atualiza√ß√£o de sistemas operacionais e produtos da Microsoft.  O servidor de atualiza√ß√µes √© sincronizado com o site da Microsoft, baixando atualiza√ß√µes que podem ser distribu√≠das na LAN corporativa.  Novamente, uma ferramenta especial projetada para trabalhar com atualiza√ß√µes. <br><br>  Distribu√≠do apenas nas edi√ß√µes do servidor do Windows, portanto, o seguinte suporte foi implantado: <br><br><ul><li>  o sistema principal √© o Windows Server 2016; </li><li>  e por meio do sistema de virtualiza√ß√£o Hyper-V, dois sistemas operacionais clientes foram implantados: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Todos os sistemas est√£o conectados a uma √∫nica rede local virtual, mas <u>sem acesso √† Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Algumas dicas</b> <div class="spoiler_text">  Para n√£o alocar uma parti√ß√£o do disco r√≠gido para o novo sistema, eu uso o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WinNTSetup</a> e instalo o sistema em discos VHD - o gerenciador de inicializa√ß√£o, come√ßando no Windows 7 (edi√ß√µes Professional / Ultimate), faz um √≥timo trabalho ao inicializar a partir de uma imagem de disco.  Os discos assim obtidos podem ser usados ‚Äã‚Äãcom seguran√ßa no Hyper-V - voc√™ mata dois coelhos com uma cajadada ao mesmo tempo.  Lembre-se de fazer uma c√≥pia do reposit√≥rio BCD antecipadamente atrav√©s do <b>comando bcdedit / export e: \ bcd_backup.bcd</b> . <br><br>  Como n√£o queria configurar o AD para distribui√ß√£o de atualiza√ß√µes, simplesmente registrei o caminho para o servidor WSUS nas pol√≠ticas de grupo: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Configura√ß√µes"><br><br>  Preste aten√ß√£o √† porta, devido a um erro de digita√ß√£o (8350 em vez de 8530), n√£o foi poss√≠vel receber atualiza√ß√µes nas m√°quinas clientes, embora tudo tenha sido feito corretamente.  Al√©m disso, os nomes dos itens nas pol√≠ticas de grupo no Windows 7 e Windows 8 s√£o diferentes. <br><br>  Para receber o relat√≥rio usando o WSUS, voc√™ deve instalar o pacote adicionalmente - o sistema notificar√° voc√™ disso. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">E agora um pouco de c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Como n√£o h√° Internet, a situa√ß√£o com as atualiza√ß√µes aparece como na captura de tela abaixo: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  O comportamento √© semelhante ao WUApi - se as atualiza√ß√µes n√£o passaram por eles, eles n√£o sabem disso.  Portanto, esse m√©todo n√£o funciona novamente. <br><br><h2>  Wmi </h2><br>  A Instrumenta√ß√£o de Gerenciamento do Windows ( <b>WMI</b> ) na tradu√ß√£o literal √© um kit de ferramentas de gerenciamento do Windows. <br><br>  O WMI √© um padr√£o implementado pela Microsoft para gerenciar uma empresa <u>pela Internet</u> para administra√ß√£o centralizada e monitoramento de v√°rias partes de uma infraestrutura de computador executando uma plataforma Windows.  O WMI √© um sistema unificado aberto de interfaces de acesso a todos os par√¢metros do sistema operacional, dispositivos e aplicativos que nele operam. <br><br>  Este m√©todo permite receber dados da m√°quina local e remotamente na rede local.  Para acessar objetos WMI, √© usada uma WQL (WMI Query Language) espec√≠fica, que √© uma das variedades de SQL.  Receberemos a lista atrav√©s da classe WMI <b>win32_quickfixengineering</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de implementa√ß√£o</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      ¬´NTLMDOMAIN:¬ª  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Quantitativamente, tudo coincide (mesmo ap√≥s as atualiza√ß√µes), por isso foi decidido usar esse m√©todo.  Para cria√ß√£o program√°tica de solicita√ß√µes WMI, recomendo que voc√™ use o seguinte utilit√°rio - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WMI Delphi Code Creator</a> .  Gra√ßas a ela, olhei para o meu c√≥digo um pouco diferente e decidi usar um espa√ßo em branco neste programa. <br><br><h2>  XML </h2><br>  Os dados obtidos pelo m√©todo WMI n√£o me pararam, e eu decidi pela "engenharia reversa de superf√≠cie".  Usaremos o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Process Monitor</a> da cole√ß√£o de software <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sysinternals Suite</a> para identificar arquivos e ramifica√ß√µes do registro que s√£o usadas ao chamar os comandos do console listados acima e acessar o item "Atualiza√ß√µes Instaladas" atrav√©s do Painel de Controle. <br><br>  Chamei minha aten√ß√£o o arquivo wuindex.xml, localizado na pasta C: \ Windows \ servicing \ Packages \.  Para analis√°-lo, foi escrito o seguinte programa: <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de aplicativo de console</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Infelizmente, esse arquivo n√£o foi encontrado em todos os sistemas e o princ√≠pio de sua gera√ß√£o e atualiza√ß√£o permaneceu um mist√©rio para mim.  Portanto, novamente este m√©todo n√£o nos conv√©m. <br><br><h2>  Cbs </h2><br>  Aqui chegamos ao que todos esses m√©todos est√£o associados.  Continuando a an√°lise dos logs do Process Monitor, identifiquei as seguintes pastas e arquivos. <br><br>  O arquivo DataStore.edb localizado na <b>pasta C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Este √© um banco de dados que cont√©m o hist√≥rico de todas as atualiza√ß√µes da vers√£o instalada do Windows, incluindo aquelas que est√£o apenas na fila. <br><br>  O programa ESEDatabaseView foi usado para analisar o arquivo DataStore.edb.  H√° uma tabela tbUpdates no banco de dados, cujo conte√∫do √© dif√≠cil de interpretar. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="Tabela TbUpdates no ESEDatabaseView"><br><br>  Ap√≥s chamar minha aten√ß√£o para o processo <b>TiWorker.exe</b> , que era chamado toda vez que eu abria um item no Painel de Controle.  Ele "caminhou" por v√°rias pastas, uma das quais me levou no caminho certo. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> √© uma pasta usada pelo Windows Update para baixar atualiza√ß√µes para um computador e instal√°-las, al√©m de armazenar informa√ß√µes sobre todas as atualiza√ß√µes instaladas anteriormente. <br><br>  Pasta WinSxS localizada em <b>C: \ Windows \ winsxs</b> .  Essa √© a pasta de servi√ßo do sistema operacional Windows usada para armazenar vers√µes instaladas anteriormente dos componentes do sistema.  Devido √† sua presen√ßa, √© poss√≠vel reverter para uma vers√£o mais antiga da atualiza√ß√£o, se necess√°rio. <br><br>  <b>C: \ Windows \ servicing</b> - o componente principal de todo o sistema, cujo nome √© <b>CBS (Component-Based Service)</b> . <br><br>  O CBS √© um servi√ßo baseado em componente que faz parte do Windows e est√° integrado ao servi√ßo Windows Update.  Em contraste com o <b>servi√ßo Servi√ßo Baseado</b> em <b>Arquivo (FBS)</b> (para sistemas operacionais anteriores ao Windows Vista), no qual os arquivos foram atualizados diretamente nos diret√≥rios do sistema, o CBS introduziu uma hierarquia completa de diret√≥rios e uma fam√≠lia inteira (pilha) de m√≥dulos / bibliotecas de servi√ßos. <br><br>  <b>CbsApi.dll</b> √© a principal biblioteca de suporte da tecnologia CBS.  N√£o possui m√©todos abertos, ent√£o n√£o pude us√°-lo diretamente.  A Microsoft usa o TrustedInstaller.exe e o TiWorker.exe para acessar os m√©todos desta biblioteca e, j√° atrav√©s desses processos, exibe os dados de que precisamos.  Os registros s√£o mantidos em <b>C: \ Windows \ Logs \ CBS \ CBS.log</b> . <br><br>  No momento da cria√ß√£o do prot√≥tipo do programa (voc√™ pode ver maio de 2019 nas capturas de tela), n√£o havia informa√ß√µes em russo sobre a CBS, mas no final de agosto havia um artigo muito bom no blog - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://datadump.ru/component-based-servicing</a> .  Um artigo muito interessante que confirmou minha experi√™ncia e reuniu as informa√ß√µes necess√°rias.  E mais sobre o tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Conclus√£o </h2><br>  A Microsoft complicou demais a tarefa trivial de obter uma lista de atualiza√ß√µes e tornou esse processo n√£o totalmente √≥bvio.  Tudo isso √© feito por seguran√ßa, mas n√£o por facilidade de uso.  Concordo com o autor do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> - a previsibilidade e a transpar√™ncia come√ßaram a estar ausentes no recebimento de atualiza√ß√µes. <br><br>  Como resultado do estudo, foi escrito o seguinte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programa</a> , cuja demonstra√ß√£o pode ser vista neste v√≠deo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Os planos para adicionar: <br><br><ol><li>  comparar a lista de atualiza√ß√µes necess√°rias com a recebida; </li><li>  envie o resultado via SNMP / OPC (se algu√©m tiver experi√™ncia, compartilhe nos coment√°rios); </li><li>  organize a instala√ß√£o das atualiza√ß√µes "offline" ausentes da pasta especificada. </li></ol><br>  Se voc√™ conhece mais m√©todos para obter uma lista n√£o apenas de atualiza√ß√µes, mas tamb√©m de componentes adicionais (Adobe Flash, Acrobat Reader, etc.) ou se tem outras sugest√µes interessantes, escreva sobre isso nos coment√°rios ou nas mensagens privadas - terei prazer em receber qualquer coment√°rio .  E participe da pesquisa deste artigo - para saber se minha experi√™ncia com o p√∫blico do Habrahabr ser√° interessante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467445/">https://habr.com/ru/post/pt467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467429/index.html">Habrastatistics: explorando as se√ß√µes mais e menos visitadas do site</a></li>
<li><a href="../pt467435/index.html">Enviamos relat√≥rios do agente Veeam Linux para o correio ou no Telegram</a></li>
<li><a href="../pt467437/index.html">MVCC no PostgreSQL-1. Isolamento</a></li>
<li><a href="../pt467439/index.html">Por que o vinil voltou e como os servi√ßos de streaming est√£o relacionados a isso?</a></li>
<li><a href="../pt467443/index.html">Centro Multim√≠dia "Kodi" e Projeto Yocto</a></li>
<li><a href="../pt467449/index.html">Detec√ß√£o de vulnerabilidades e avalia√ß√£o da resist√™ncia a ataques de hackers de cart√µes inteligentes e processadores de criptografia com prote√ß√£o integrada</a></li>
<li><a href="../pt467453/index.html">Resolvendo o problema do n√∫mero 42 usando um supercomputador planet√°rio</a></li>
<li><a href="../pt467455/index.html">Modelo QBS para programa√ß√£o de microcontroladores no QtCreator usando o exemplo de controladores Milander</a></li>
<li><a href="../pt467457/index.html">O caminho da cirurgia para o desenvolvimento de jogos ou a primeira experi√™ncia de desenvolvimento m√≥vel no Unity</a></li>
<li><a href="../pt467459/index.html">Como um microcontrolador pode ler dados em 1,6 Gbps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>