<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ üë©üèΩ‚Äçü§ù‚Äçüë®üèæ üëèüèΩ Playrix CI / CD: Wie wir unsere Spiele bauen und testen üí© üëàüèø ‚õπüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Team sollte sich darauf konzentrieren, sch√∂ne und erfolgreiche Spiele zu entwickeln, f√ºr alles andere gibt es CI. 

 Wo wenden wir CI an? Welche A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Playrix CI / CD: Wie wir unsere Spiele bauen und testen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/479966/">  Das Team sollte sich darauf konzentrieren, sch√∂ne und erfolgreiche Spiele zu entwickeln, f√ºr alles andere gibt es CI. <br><br>  Wo wenden wir CI an?  Welche Ans√§tze und Konzepte verwenden wir?  Warum Builds erstellen und testen?  Die detaillierte Geschichte √ºber CI und wie es in Playrix organisiert ist, wird einen Kurs mit Vortr√§gen zeichnen.  Unter dem Schnitt - ein kurzes Dr√ºcken und ein paar Akzente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/54d/ab2/b4e54dab26c1357b27e3e31b88c9378d.png"></div><a name="habracut"></a><br>  Hallo. <br><br>  Zun√§chst ein wenig aufw√§rmen: Was ist Continuous Integration?  Wenn das Team das Repository verwendet und Nacht-Builds sammelt - ist das CI bereits?  Was ist der Unterschied zwischen Continuous Deployment und Delivery?  Es ist fast unwichtig.  Details - f√ºr einen engen Kreis von Spezialisten.  Wenn Sie das gesamte Unternehmen in einen Prozess einbeziehen m√∂chten, √ºberlegen Sie sich einen einfachen und guten Namen.  In Playrix bezeichnen wir alle diese Ans√§tze als CI.  Dies ist so eine lokale Marke und ein cooles Logo: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebe/d97/d8e/ebed97d8e7a2fff88508b8e73c6b0e97.png" width="500"></div><br><h2>  Idee </h2><br>  CI ist kein Ziel, es ist ein Werkzeug.  Es muss ein Ziel geben, das Sie mit Continuous Integration erreichen m√∂chten, ein Problem, das gel√∂st werden muss.  Es kommt vor, dass die Entwicklungs- und Freigabeprozesse in einem Team auf dem Prinzip "Gebet und Produktion" basieren.  Manchmal ist es gerechtfertigt, aber selten. <br><br>  Wir haben unser Ziel wie folgt formuliert: Minimierung der Wahrscheinlichkeit von Integrationsproblemen, Minimierung der Ressourcen, die zur Behebung der gefundenen Fehler erforderlich sind, Verk√ºrzung der Zeit der Projektentwicklungsteams zur Unterst√ºtzung und Unterst√ºtzung von CI-Prozessen. <br>  CI ist die Automatisierung von Erstellungsprozessen, das Testen von Code und dessen Bereitstellung in verschiedenen Umgebungen, die Automatisierung von Routineentwicklungsprozessen und die gegenseitige Integration von Diensten, die wir alle nutzen. <br><br>  Die Idee ist ein System, das automatisch alles sammelt, es oft tut, einen Build testet und ausliefert und au√üerdem einen praktischen Bericht Punkt f√ºr Punkt erstellt, wenn etwas schief gelaufen ist. <br><br><h2>  Wo wenden wir CI an? </h2><br><ul><li>  Motor und Versorgung, </li><li>  unsere Spiele f√ºr alle Plattformen, </li><li>  Servercode </li><li>  Analytik, Marketing-Dienstleistungen, verschiedene Automatisierungs-, CI-Dienstleistungen, </li><li>  die Infrastruktur. </li></ul><br>  Das ist √ºberall oder fast √ºberall. <br><br>  Das Zusammenstellen und Testen von Containern, die automatische Bereitstellung in Test-, Staging- und Prod-, Rolling- und Canary-Updates - all dies haben wir und dies gilt insbesondere f√ºr Services und Webanwendungen.  Heute werden wir uns auf CI f√ºr Spiele konzentrieren: Builds bauen, testen und liefern. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/bab/b31/e87babb31e40c7d90e3994f45be77792.png" width="500"></div><br><h2>  Paradigmen </h2><br>  Um die oben genannten Ziele zu erreichen, m√ºssen Sie mehrere Probleme l√∂sen.  Im Folgenden finden Sie einen Plan, den wir befolgen, wenn wir einen Prozess in der Entwicklung automatisieren, z. B. das Zusammenstellen eines Clients f√ºr mobile Spiele.  Es ist sehr praktisch, eine Liste mit Fragen zu haben, die Sie beantworten k√∂nnen, um jedes Problem zu l√∂sen, das in das CI-Team f√§llt. <br><br><ul><li><h3>  Dokumentation </h3></li></ul><br>  Bauanleitungen sind Dokumentationen, eine Beschreibung unseres automatisierten Prozesses.  Oft liegt eine solche Dokumentation im Kopf der Programmierer.  Wenn ein Team einen Superspezialisten f√ºr das Erstellen von Builds hat und niemand mehr einen schnellen und fehlerfreien Build erstellen kann - es ist Zeit, etwas zu √§ndern, es wird keine √úbergabe geben. <br><br>  Nun, wenn eine solche Dokumentation in Form eines Skripts vorliegt: Ich habe eine Befehlszeile und eine Reihe von Parametern auf einem Computer mit einer vorbereiteten Umgebung eingegeben - ich habe einen Build erhalten. <br><br>  Die beste Prozessdokumentation ist der <s>Cat-</s> Code.  Auch wenn Sie den Vorgang aus irgendeinem Grund manuell wiederholen m√ºssen, k√∂nnen Sie ihn jederzeit √ºberpr√ºfen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/b35/41c/bc1b3541c1eaf585466131dfc966a466.png" width="500"></div><ul><li><h3>  Protokollierung </h3></li></ul><br>  Mit dem Build-Protokoll k√∂nnen Sie immer sicher sagen, wer, wann, von welchem ‚Äã‚ÄãCommit und mit welchem ‚Äã‚ÄãErgebnis dieser oder jener Build gesammelt wurde.  Gestern war der Bau kurz davor, heute jedoch nicht.  Wir sehen im Protokoll nach, wir finden den ersten Floppy-Build, wir sehen die Liste der Commits, die dort ankamen - Profit. <br><br>  Das Magazin ist noch n√ºtzlicher, wenn es zum Beispiel um Server-Code geht.  Wenn keine Informationen dar√ºber vorliegen, wer und wann das Produkt aktualisiert hat, ist im Allgemeinen nicht bekannt, welcher Code derzeit dort ausgef√ºhrt wird.  Und manchmal ist es sehr wichtig, sehr. <br><br>  Sie k√∂nnen ein solches Tagebuch im Hauptbuch f√ºhren, vorzugsweise in einer Tabelle oder einem Wiki.  Die Liste der Builds im CI-System ist von unsch√§tzbarem Wert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/a88/26c/4dca8826cad8ae341be5df436c3fcab4.png"></div><br><ul><li><h3>  Sicherheit </h3></li></ul><br>  Wenn es darum geht, einen Build zu erstellen und in einer bestimmten Umgebung bereitzustellen, stellt sich immer die Frage, wo Anmelde- / Zugriffskennw√∂rter gespeichert werden sollen.  Sie ben√∂tigen normalerweise viel: in das Repository, um die Quelldaten herunterzuladen, in den Dateispeicher, um die Spielressourcen auszuf√ºllen, in die HockeyApp, um Zeichen zu senden, auf den Server, um den Code zu aktualisieren usw. <br><br>  Es kommt vor, dass alle erforderlichen Zugriffe im Repository gespeichert werden.  Es gibt eine Hypothese, dass dies nicht sehr gut ist.  In Jenkins wird h√§ufig das Feld "Passwort eingeben" angezeigt, in dem der Autor des Builds die verborgenen Zeichen eingibt. <br><br>  Sich alle Passw√∂rter auswendig zu merken, ist eine gute F√§higkeit.  Unser CI-Server selbst erh√§lt je nach Baugruppe die notwendigen Zugriffe.  In der Regel sind dies kurzlebige Token, die zu Beginn des Builds generiert werden und minimale Rechte genau dort gew√§hren, wo wir etwas bereitstellen oder wo wir etwas lesen. <br><br>  Durch die zentrale Verwaltung der Assembly und Bereitstellung k√∂nnen Sie das Problem der Unterscheidung der Zugriffsrechte auf die Infrastruktur l√∂sen.  Warum jemandem Zugriff auf den Server gew√§hren, wenn Sie nur Zugriff auf die Assembly des entsprechenden Builds gew√§hren k√∂nnen, der die erforderliche Operation auf diesem Server ausf√ºhrt?  Und da es einen Build gibt, haben wir Dokumentation und Journal, verstehen Sie? <br><br><ul><li><h3>  R√ºckverfolgbarkeit </h3></li></ul><br>  W√§hrend der Erstellungszeit sind normalerweise viele Spuren hinterlassen.  Nein, nicht so: Beim Build-Build m√ºssen so viele Spuren wie m√∂glich hinterlassen werden.  Im Repository, im Task-Tracker, im Build-Verteilungssystem.  √úberall dort, wo Sie auf einen Build sto√üen, sollten sich Spuren befinden, die Sie zu vollst√§ndigen Informationen dar√ºber f√ºhren. <br><br>  Diese Spuren m√ºssen nicht weggefegt werden, im Gegenteil, sie m√ºssen sorgf√§ltig hinterlassen und sorgf√§ltig aufbewahrt werden.  Des Weiteren werde ich Ihnen mehr dar√ºber erz√§hlen, aber zuerst m√ºssen wir unseren Build sammeln.  Lass uns gehen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/436/e91/75c436e91724a70d5442af7c6432516d.png" width="500"></div><h2>  Hooks vorab festschreiben </h2><br>  Die Idee ist wieder ein System, das alles sammelt, testet und meldet.  Aber warum einen Build erstellen, wenn Sie ihn nicht erstellen k√∂nnen? <br><br>  Bei allen Entwicklern unserer Spiele sind Pre-Commit-Hooks installiert, d. H.  Eine Reihe von √úberpr√ºfungen, die durchgef√ºhrt werden, wenn versucht wird, etwas festzuschreiben.  √úberpr√ºfungen werden nur f√ºr ge√§nderte Dateien ausgef√ºhrt, aber wir haben ein sehr ausgekl√ºgeltes Suchsystem implementiert, um alle zugeh√∂rigen Inhalte zu √ºberpr√ºfen.  Das hei√üt  Wenn der K√ºnstler eine Textur hinzugef√ºgt hat, √ºberpr√ºfen Hooks, ob sie nicht vergessen haben, diese zu registrieren, wo immer dies erforderlich ist, und haben sie nie versiegelt. <br><br>  Es stellt sich heraus, dass Haken einen erheblichen Teil kleiner Fehler auffangen.  Sie sparen die Ressourcen des Build-Systems und helfen dem Entwickler, das Problem schnell zu beheben: Er sieht eine Meldung, die detailliert angibt, was schief gelaufen ist.  Und er muss nicht zwischen den Aufgaben wechseln: Er hat buchst√§blich nur √Ñnderungen vorgenommen und ist im Kontext.  Die Fehlerkorrekturzeit ist minimal. <br><br>  Uns hat es so gut gefallen, dass wir sogar ein System erstellt haben, das √ºberpr√ºft, ob Hooks f√ºr ein Commit erstellt wurden, das in das Repository gelangt ist.  Ist dies nicht der Fall, erh√§lt der Autor eines solchen Commits automatisch eine Aufforderung, diese zu konfigurieren, und detaillierte Anweisungen dazu. <br><br>  Haken sind f√ºr alle Projekte standardisiert.  Die Anzahl der benutzerdefinierten Tests ist minimal.  Es gibt bequeme Anpassungsm√∂glichkeiten, auch je nach Benutzer, der gerade ausgef√ºhrt wird: Dies ist sehr praktisch zum Testen von Tests. <br><br><h2>  Bauen </h2><br>  Um das Problem im Build so fr√ºh wie m√∂glich zu erkennen, m√ºssen Sie diese Builds so oft wie m√∂glich erfassen und testen.  Kunden unserer Spiele versammeln sich f√ºr alle Plattformen, f√ºr jedes Commit, f√ºr alle Projekte.  Es gibt wahrscheinlich einige Ausnahmen, aber nicht viele. <br><br>  Typischerweise hat ein Client, insbesondere ein mobiler, mehrere verschiedene Versionen: mit und ohne Cheats, unterschiedlich signiert usw.  F√ºr jedes Commit sammeln wir "regul√§re" Builds, die Entwickler und Tester st√§ndig verwenden. <br><br>  Es gibt Builds, die sehr selten verwendet werden, z. B. den Build des Stores - nur einmal in einer √úbermittlung, d. H.  etwa einmal im Monat.  Wir sind jedoch der Meinung, dass alle Builds regelm√§√üig eingesammelt werden sollten.  Wenn bei dieser Art von Baugruppe ein Problem auf der Entwicklungs- oder Infrastrukturseite auftritt, wei√ü das Projektteam dies nicht am Tag der Lieferung des Builds, sondern viel fr√ºher und kann im Voraus reagieren und das Problem beheben. <br><br>  Als Ergebnis haben wir eine einfache Regel: Jeder Build wird mindestens einmal am Tag gestartet.  Das Projektentwicklungsteam findet heraus, ob auf einer Plattform Probleme vorliegen, und zwar im schlimmsten Fall am n√§chsten Morgen, nachdem dieses Problem im Repository aufgetreten ist. <br><br>  Eine solche H√§ufigkeit von Baugruppen und Tests erfordert einen besonderen Ansatz zur Optimierung ihrer Ausf√ºhrungszeit. <br><br><ul><li>  Alle regul√§ren Kundenbuilds sind inkrementell. </li><li>  Das Packen von Atlanten und das Vorbereiten von Ressourcen erfolgt ebenfalls inkrementell. </li><li>  Assemblies sind granular: Einige der Schritte befinden sich in separaten Build-Konfigurationen. Auf diese Weise k√∂nnen Sie sie parallel ausf√ºhren und Zwischenergebnisse wiederverwenden. </li></ul><br>  Dies ist ein fast vollst√§ndiger Screenshot der Build- und Testkette f√ºr WildScapes.  Voll konnte nicht gemacht werden: es ist etwa doppelt so gro√ü. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/415/771/67241577111cb4d6b5d1df70a54337e5.png"></div><br><h2>  Statische Tests </h2><br>  Nach dem Zusammenbau werden statische Tests durchgef√ºhrt: Wir nehmen den Ordner mit dem Build und f√ºhren eine Reihe von √úberpr√ºfungen des gesamten Inhalts durch, der dort vorhanden ist.  Code ist auch Inhalt, daher ist auch die statische Analyse (cppcheck + PVS-Studio) hier. <br><br>  Auf einem habr gab <a href="https://habr.com/ru/company/playrix/blog/452926/">es ein detailliertes Material</a> dar√ºber, wie wir statische Tests implementiert haben, ich empfehle es.  Ich betone nur, dass die statischen Tests nach dem Build und in den Pre-Commit-Hooks vom selben Code ausgef√ºhrt werden.  Dies vereinfacht die Systemunterst√ºtzung erheblich. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/195/0dd/69f1950dd3434591d233507574609672.png" width="500"></div><br><h2>  Laufzeit-Tests </h2><br>  Wenn die Erstellung der statischen Tests erfolgreich war, k√∂nnen Sie versuchen, die zusammengestellte Erstellung auszuf√ºhren.  Wir testen Builds auf allen Plattformen au√üer UWP, d. H.  Windows, MacOS, iOS, Android.  UWP - wird auch sein, aber etwas sp√§ter. <br><br>  Warum Desktop-Builds testen, wenn sie nur in der Entwicklung ben√∂tigt werden?  Die Antwort auf die Frage lautet: Es ist schlimm, wenn ein K√ºnstler oder Leveldesigner einen Build bekommt, der beim Start aus irgendeinem l√§cherlichen Grund abst√ºrzt.  Aus diesem Grund wird der Smoke-Test, der Mindestsatz an √úberpr√ºfungen auf Runability und grundlegendes Gameplay, f√ºr alle Plattformen durchgef√ºhrt. <br><br>  Alles, was oben √ºber Builds geschrieben wurde, gilt auch f√ºr Tests an Ger√§ten - mindestens einmal am Tag.  Mit wenigen Ausnahmen: Es gibt sehr lange Tests, f√ºr die an einem Tag keine Zeit zur Verf√ºgung steht. <br><br>  Bei jedem Commit werden Smoke-Tests durchgef√ºhrt.  Der erfolgreiche Abschluss grundlegender √úberpr√ºfungen ist eine Voraussetzung daf√ºr, dass der Build in das Verteilungssystem aufgenommen werden kann.  Normalerweise macht es keinen Sinn, jemandem Zugriff auf einen Build zu gew√§hren, der offensichtlich nicht funktioniert.  Hier k√∂nnen Sie Einspruch einlegen und sich Ausnahmen einfallen lassen.  Projekte haben eine Problemumgehung, um auf einen nicht funktionierenden Build zuzugreifen, aber sie verwenden ihn kaum. <br><br>  Welche anderen Tests gibt es: <br><br><ul><li>  Benchmark: Wir √ºberpr√ºfen die Leistung auf FPS und Speicher in verschiedenen Situationen und auf allen Ger√§ten. </li><li>  3-Gewinntests: Jedes Element und jede Mechanik werden einzeln und in allen Interaktionskombinationen getestet. </li><li>  Der Durchgang des gesamten Spiels von Anfang bis Ende. </li><li>  Verschiedene Regressionstests, z. B. Lokalisierungstests oder das korrekte √ñffnen aller Benutzeroberfl√§chenfenster oder das fehlerfreie Abspielen von Fishdom-Szenen in Fishdom. </li><li>  <a href="https://en.wikipedia.org/wiki/AddressSanitizer">Trotzdem</a> , aber mit <a href="https://en.wikipedia.org/wiki/AddressSanitizer">AddressSanitizer</a> . </li><li>  Kompatibilit√§tstests f√ºr Spielversionen: Nehmen Sie die vom Benutzer gespeicherte Datei aus fr√ºheren Versionen, √∂ffnen Sie sie in der neuen Version und stellen Sie sicher, dass alles in Ordnung ist. </li><li>  Verschiedene kundenspezifische Tests, die f√ºr den Mechaniker eines bestimmten Projekts relevant sind. </li></ul><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7a/24e/992/c7a24e992e95338aa4e884f367168b9e.png" width="500"></div><br>  Zur Durchf√ºhrung der Tests verwenden wir unseren eigenen Teststand f√ºr iOS- und Android-Ger√§te.  Auf diese Weise k√∂nnen wir die Builds, die wir auf Ger√§ten ben√∂tigen, flexibel starten und √ºber den Code mit dem Ger√§t interagieren.  Wir haben die volle Kontrolle, ein verst√§ndliches Ma√ü an Zuverl√§ssigkeit, wir wissen, mit welchen Problemen wir konfrontiert sind und wie lange es dauern wird, sie zu l√∂sen.  Keiner der Cloud-Dienste, die Testger√§te bereitstellen, bietet einen solchen Komfort. <br><br><h2>  KATZEN </h2><br>  Die oben aufgef√ºhrten Tests sind im Projektcode implementiert.  Dies erm√∂glicht theoretisch einen Test jeder Komplexit√§t, erfordert jedoch Aufwand und Ressourcen f√ºr die Entwicklung des Projekts, um diese Tests zu implementieren und zu unterst√ºtzen.  Diese Ressourcen sind h√§ufig nicht verf√ºgbar, und das Testen mehrerer Regressionen per Hand ist schwierig und nicht erforderlich.  Ich wollte wirklich, dass die Tester selbst Testautomatisierung durchf√ºhren.  Und wir haben ein Framework daf√ºr entwickelt - das Continuous Automation Testing System (CATS). <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f1/40d/aab/9f140daab4981b2700a9e40358ceb51e.png" width="500"></div><br>  Was ist die Idee: Autoren von Testskripten die M√∂glichkeit zu geben, mit der Spieleanwendung zu interagieren, ohne sich darum zu k√ºmmern, wie alles funktioniert.  Wir schreiben Skripte in primitivem Python und greifen √ºber eine Reihe von Abstraktionen auf die Anwendung zu.  Zum Beispiel: "Homescapes, √∂ffne mir ein Schaufenster und kaufe so und so ein Produkt."  √úberpr√ºfen Sie das Ergebnis, Bingo. <br><br>  Die gesamte Implementierung von Skriptbefehlen ist hinter einer Reihe von Abstraktionen verborgen.  Mit der API, die die Interaktion mit der Anwendung implementiert, k√∂nnen Sie Aktionen auf verschiedene Arten ausf√ºhren: <br><br><ul><li>  Senden Sie mit einem Befehl eine http-Anfrage an den Server, der in die Spiel-Engine integriert ist.  Dieser Befehl wird vom Spielcode verarbeitet.  In der Regel handelt es sich hierbei um einen Cheat, der beliebig einfach oder komplex sein kann.  Beispiel: "Geben Sie mir die Koordinaten der Schaltfl√§chenmitte mit der angegebenen Kennung."  Oder "gib mir das Spiel von hier bis zum Level mit der angegebenen Nummer." </li><li>  Wir k√∂nnen ein Fenster durch den Cheat √∂ffnen oder die Koordinaten der Schaltfl√§che herausfinden, mit der dieses Fenster ge√∂ffnet wird. Wir k√∂nnen das Klicken auf diese Schaltfl√§che emulieren und einen virtuellen Klick darauf ausf√ºhren. </li><li>  Zum Schluss k√∂nnen wir die angegebenen Koordinaten mit einem ‚Äûechten‚Äú Klick anklicken, als ob dies mit einem Finger auf dem Bildschirm geschehen w√§re. </li></ul><br>  Die letztere Methode er√∂ffnet den Spielraum f√ºr die Vorstellungskraft von Testern, die h√§ufig "Kampf" -Bauten testen m√∂chten, bei denen es keine Cheats gibt.  Solche Szenarien beizubehalten ist schwieriger, aber ein "Kampfbau" ist ein "Kampfbau". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e25/0de/9ce/e250de9ce8a6e45d5ecfc8495eec7cb2.png"></div><br>  Es hat sich als sehr praktisch erwiesen, mit den Koordinaten der Knopfmitte zu arbeiten: Die Koordinaten √§ndern sich manchmal, aber die Knopfkennungen sind selten.  Dies f√ºhrte zu einer weiteren wichtigen Eigenschaft des Systems: Die M√∂glichkeit, ein Testskript f√ºr alle Plattformen und alle Bildschirmaufl√∂sungen zu schreiben. <br><br><h2>  Lieferung, Berichte &amp; Traces </h2><br>  Bei der Auslieferung stellte sich heraus, dass alles ganz einfach war: Wir verwenden einen einzigen gemeinsamen Speicher f√ºr Build-Artefakte und f√ºr die Speicherung im Distributionssystem.  Das "Laden" des Builds l√§uft darauf hinaus, ein Paar von Anforderungen an die API des Build-Verteilungsdienstes aufzurufen und sich im Wesentlichen zu registrieren.  Auf diese Weise haben wir ein wenig Zeit beim Pumpen von Bauteilen und Geld f√ºr deren Lagerung gespart. <br><br>  Denken Sie daran, Sie haben dar√ºber gesprochen, die Ressourcen zu minimieren, die zur Behebung von Fehlern in Builds erforderlich sind.  Berichte und Tracks - so ungef√§hr: <br><br><ul><li>  Das Melden eines gefundenen Problems ist eine Aufgabe in Asana.  Es ist einfach zu steuern, es dem richtigen Entwickler zuzuweisen und es an das CI-Team weiterzuleiten, wenn in der Infrastruktur etwas schief gelaufen ist. </li><li>  Wir sammeln Builds f√ºr jedes Commit.  Wir kennen den Autor dieses Commits, daher wird nur er diese Aufgabe sehen.  So sparen wir Zeit f√ºr andere Entwickler: Sie m√ºssen sich nicht von Problemen ablenken lassen, mit denen sie nichts zu tun haben, und helfen bei der L√∂sung, die sie h√∂chstwahrscheinlich nicht l√∂sen k√∂nnen. </li><li>  Wenn Sie einen Build aus dem n√§chsten Commit erstellen, ist er h√∂chstwahrscheinlich immer noch fehlerhaft.  Es wird einen Kommentar in der Aufgabe geben: "Der Build ist noch nicht fertig", der Autor des neuen Commits wird die Aufgabe nicht sehen und keine Zeit mit dem Problem einer anderen Person verschwenden. </li><li>  Wir senden Berichte an Slack.  Notwendigerweise - pers√∂nlich an denjenigen, der den Build "gebrochen" hat, und wenn das Projekt dies w√ºnscht - an einen speziellen Channel oder an einen Playrix-Mitarbeiter.  Alles ist so flexibel wie m√∂glich. </li></ul><br>  Traces werden ben√∂tigt, damit √ºberall vollst√§ndige Informationen √ºber den Build und die √Ñnderungen, von denen er gesammelt wurde, zur Verf√ºgung stehen.  Um nicht nach irgendetwas zu suchen, damit alles zur Hand war und man keine Zeit damit verbringen musste, nach Details zu suchen, die bei der Suche nach einem Problem h√§ufig erforderlich sind. <br><br><ul><li>  Der Bericht enth√§lt einen Link zum Build, zum Build-Protokoll, den Text des gefundenen Kompilierungsfehlers und die Namen der umgedrehten Tests.  H√§ufig kann ein Programmierer, der eine Berichtsaufgabe erhalten hat, den Fehler sofort beheben: Der Dateiname, die Zeile und der Fehlertext befinden sich im Bericht. </li><li>  Die Nachricht in Slack enth√§lt trotzdem + einen Link zur Aufgabe in Asana. </li><li>  In Teamcity ein Link zu einer Aufgabe.  Build Engineer kann sofort in die Aufgabe einsteigen, mit einem Klick m√ºssen Sie nichts suchen. </li><li>  Im Github - Status mit einem Link zum Build, im Kommentar zum Commit - einem Link zu der Task, f√ºr die dieser Build erstellt wurde.  In der Aufgabe - ein Kommentar mit einem Link zum Commit. </li><li>  Im Build-Verteilungsdienst: Link zum Build, Link zum Commit. </li></ul><br>  Es gibt nichts zu merken, aber Sie haben die Idee verstanden: Links zu allem, √ºberall.  Dies beschleunigt das Studium jeder unverst√§ndlichen Situation erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94d/4dc/1a0/94d4dc1a015d9f068e9c5dce0461b17a.png"></div><h2>  Bauernhof </h2><br>  Wir sammeln und testen Builds f√ºr alle Plattformen.  Daf√ºr brauchen wir viele verschiedene Agenten.  Sie manuell zu verfolgen und zu warten ist lang und schwierig.  Alle Agenten werden automatisch vorbereitet.  Wir verwenden Packer und Ansible. <br><br>  Alle Protokolle aller Agenten, Teamcity, aller Dienste, die es gibt, speichern wir (in unserem Fall - in ELK).  Alle Dienste, die einen Build verarbeiten, f√ºgen jeder Protokollzeile die Nummer dieses Builds hinzu.  Wir k√∂nnen in einer einzelnen Anfrage den gesamten Lebenszyklus des Builds von seinem Erscheinen in der Warteschlange bis zum Ende des Sendens aller Berichte sehen. <br><br>  Wir haben unseren eigenen Warteschlangenoptimierungsmechanismus implementiert.  Das in Teamcity funktioniert bei unseren Zahlen nicht sehr gut.  Apropos Zahlen: <br><br><ul><li>  Wir sammeln jeden Tag ungef√§hr 5.000 Builds.  Das sind ca. 500 Maschinenstunden. </li><li>  Der dreimillionste Bau war vor einem Monat. </li><li>  Wir haben √ºber 50 Build-Server an 10 verschiedenen Standorten. </li><li>  √úber 40 mobile Ger√§te auf einem Pr√ºfstand. </li><li>  Genau 1 Teamcity Server. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/4eb/797/5e84eb79776709b09b73921f78cbb41a.png" width="500"></div><br><h2>  CI als Dienstleistung </h2><br>  Playrix CI ist ein Dienst.  Es gibt viele Projekte, viele Ideen. <br><br>  Wir optimieren die Zeit vom Einreihen des Builds in die Warteschlange bis zum Ende seiner Ausf√ºhrung, da der Benutzer des Service, der Entwickler, genau diese "Erstellungszeit" ber√ºcksichtigt.  Auf diese Weise k√∂nnen wir ein Gleichgewicht zwischen der Erstellungszeit und der in der Warteschlange verbrachten Zeit suchen und finden.  Es erscheint logisch, dass mit dem Wachstum des Unternehmens und der Anzahl der Projekte auch die Build-Farm, in der diese Projekte gesammelt werden, w√§chst.  Dank Optimierungen liegt die Wachstumsrate der Farm jedoch weit hinter der Wachstumsrate des Unternehmens. <br><br>  Jede Optimierung beginnt mit der √úberwachung und einer methodischen Erfassung von Statistiken.  Wir sammeln viele Statistiken und wissen absolut alles √ºber unsere Builds.  Neben dem Volumen der Buildfarm gibt es auch ein Team, das das CI-System unterst√ºtzt und daf√ºr sorgt, dass niemand dar√ºber nachdenken muss, woher die Builds stammen. <br><br>  Die Prozessoptimierung in diesem Team ist ebenfalls ein interessanter und unterhaltsamer Prozess.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel schreiben wir Tests zum Festlegen von Build-Konfigurationen, da es viele dieser Konfigurationen gibt. Ohne √§hnliche Tests ist es nicht einfach, alle Stellen zu finden, die bearbeitet werden m√ºssen. </font><font style="vertical-align: inherit;">F√ºr fast alle √Ñnderungen schreiben wir zuerst einen Test und nehmen sie dann vor, d. H. Tats√§chlich haben wir TDD. </font><font style="vertical-align: inherit;">Es gibt viele Prozesse im Zusammenhang mit der Aufgabe, dem Vorfallmanagement und der Planung des Ablaufs eingehender Aufgaben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwickler sollten sich darauf konzentrieren, gro√üartige und erfolgreiche Spiele zu entwickeln, ohne sich Gedanken dar√ºber zu machen, woher Builds stammen. </font><font style="vertical-align: inherit;">Daf√ºr hat Playrix ein CI. </font><font style="vertical-align: inherit;">Es muss ein Ziel geben, das Sie mit Continuous Integration erreichen m√∂chten, ein Problem, das gel√∂st werden muss. </font><font style="vertical-align: inherit;">Es ist wichtig, kein Problem zu haben, n√§mlich es zu finden. </font><font style="vertical-align: inherit;">Und wenn Sie sie finden, erinnern Sie sich an unsere Erfahrung und verbessern Sie sie. </font><font style="vertical-align: inherit;">Und denk </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dran </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">CIch schlafe nie Wir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehen uns!</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/1f2/f01/7961f2f01ed13cee81c7ea0e604e7ace.png" width="500"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479966/">https://habr.com/ru/post/de479966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479950/index.html">Die Geschichte der Videoprozessoren, Teil 4: Das Aufkommen der Allzweck-GPU</a></li>
<li><a href="../de479952/index.html">Was steckt in shawarma: Microservices, verteilte Systeme und Kafka. Teilen von Materialien aus Backend United # 5</a></li>
<li><a href="../de479954/index.html">Spring Boot Admin Tutorial</a></li>
<li><a href="../de479958/index.html">Firmware- und Prozessor-Schwachstellen</a></li>
<li><a href="../de479960/index.html">Leistungsmodell der Medienwerbung f√ºr Online-Shops</a></li>
<li><a href="../de479968/index.html">Das B√ºro von Nginx wird aufgrund einer Klage der Rambler Group durchsucht. Der Pressedienst des Beschwerdef√ºhrers best√§tigte die Klage</a></li>
<li><a href="../de479970/index.html">Tausend und ein UI-Fehler oder wie man einem Entwickler hilft, h√§ufige UI-Fehler zu vermeiden</a></li>
<li><a href="../de479972/index.html">Apple Patch-Verlauf</a></li>
<li><a href="../de479974/index.html">Zero-Click-Angriffe: Wenn Ihre Sicherheit nicht Ihnen √ºberlassen bleibt</a></li>
<li><a href="../de479978/index.html">Wie ohne Schmerzen, ohne Sicherheitsabfrage und kostenlos, um Ausz√ºge aus dem Federal State Property Fund des Unified State Register of Human Rights in eine f√ºr Menschen lesbare (*) Form zu bringen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>