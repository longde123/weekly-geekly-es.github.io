<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 🧕🏾 👩🏻‍🌾 Perl 5：宏如何隐藏错误 🤳🏾 🕴🏿 👨🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为了补充使用PVS-Studio静态代码分析器测试过的开源编程语言的列表，选择了Perl 5，本文涉及发现的错误和查看分析结果的困难。 代码中的宏数量如此之多，以至于似乎该代码不是用C编写的，而是用某种奇怪的方言编写的。 尽管查看代码时遇到了困难，但我还是设法收集了一些有趣的问题，本文将对此进行讨论...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perl 5：宏如何隐藏错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/425415/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/949/fad/134949fad7cf6d492a3eb7324942b640.png"></div><br> 为了补充使用PVS-Studio静态代码分析器测试过的开源编程语言的列表，选择了Perl 5，本文涉及发现的错误和查看分析结果的困难。 代码中的宏数量如此之多，以至于似乎该代码不是用C编写的，而是用某种奇怪的方言编写的。 尽管查看代码时遇到了困难，但我还是设法收集了一些有趣的问题，本文将对此进行讨论。 <br><br><h2> 引言 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Perl</a>是一种高级解释型动态通用编程语言（Perl是两种高级，通用型，解释性动态编程语言的家族）。  Perl 5于1994年推出。 几十年后，带有大量宏的C代码使现代程序员感到不安。 <br><br>  Perl 5的源代码来自官方<a href="">存储库</a> （ <i>blead</i>分支）。 为了检查项目，我们使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>静态代码分析器。 分析是在Linux操作系统上进行的，但分析仪也可用于Windows和macOS。 <br><br> 查看分析结果并非易事。 事实是分析器会检查已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预处理的.i</a>文件（已打开预处理器的所有指令），并在带有源代码的文件上生成警告。 这是分析仪的正确行为，您无需更改任何内容，但是会向宏发出许多警告！ 宏后面是不可读的代码。 <br><a name="habracut"></a><br><h2> 三元运算符不符合您的思维方式 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V502</a>也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'-'运算符。  toke.c 9494 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">STATIC </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S_scan_ident</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, STRLEN destlen, I32 ck_uni)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((s &lt;= PL_bufend - (is_utf8) ? UTF8SKIP(s) : <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; VALID_LEN_ONE_IDENT(s, PL_bufend, is_utf8)) { .... } .... }</code> </pre> <br> 让我们开始回顾一个美丽的错误。 每进行几次代码审查，都必须重复说三元运算符在计算中几乎具有最低的优先级。 <br><br> 考虑带有错误的片段： <br><br><pre> <code class="cpp hljs">s &lt;= PL_bufend - (is_utf8) ? UTF8SKIP(s) : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 程序员期望的操作顺序： <ol><li>  ？： </li><li>  -- </li><li>  &lt;= </li></ol><br> 实际发生的情况： <ol><li>  -- </li><li>  &lt;= </li><li>  ？： </li></ol><br> 保留操作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优先级的</a>标签：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C / C ++中的操作优先级</a> ”。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V502</a>也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'=='运算符。  re_exec.c 9193 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">STATIC I32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S_regrepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ regexp *prog, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **startposp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> regnode *p, regmatch_info *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reginfo, I32 max _pDEPTH)</span></span></span><span class="hljs-function"> </span></span>{ .... assert(STR_LEN(p) == reginfo-&gt;is_utf8_pat ? UTF8SKIP(STRING(p)) : <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br> 具有类似错误的简单代码。 但是，如果您不知道操作的优先级，则可以在任何大小的表达式中犯错误。 <br><br> 断言的另一个地方： <br><br><ul><li>  V502也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'=='运算符。  re_exec.c 9286 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V502</a>也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'&amp;&amp;'运算符。  pp_hot.c 3036 <br><br><pre> <code class="cpp hljs">PP(pp_match) { .... MgBYTEPOS_set(mg, TARG, truebase, RXp_OFFS(prog)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end); .... }</code> </pre> <br> 这是对宏的警告...要了解其中发生的情况，即使宏的实现也无济于事，因为它使用了更多的宏！ <br><br> 因此，我为这行代码附​​加了预处理文件的一部分： <br><br><pre> <code class="cpp hljs">(((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00000400</span></span>) &amp;&amp; (!((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00200000</span></span>) || S_sv_only_taint_gmagic(targ)) ? (mg)-&gt;mg_len = ((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags |= <span class="hljs-number"><span class="hljs-number">0x40</span></span> : ((mg)-&gt;mg_len = (((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x20000000</span></span>) &amp;&amp; !__builtin_expect(((((PL_curcop)-&gt;cop_hints + <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00000008</span></span>) ? (<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> :(<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>),(<span class="hljs-number"><span class="hljs-number">0</span></span>))) ? (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)Perl_utf8_length( (U8 *)(truebase), (U8 *)(truebase)+((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end)) : (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags &amp;= ~<span class="hljs-number"><span class="hljs-number">0x40</span></span>));</code> </pre> <br> 分析器在这里的某个地方怀疑三元运算符的正确使用（其中有3个），但是我没有发现理解此代码正在执行的功能。 我们已经看到开发人员犯了这样的错误，因此在这里也很有可能。 <br><br> 此宏的其他三种用法： <br><br><ul><li>  V502也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'&amp;&amp;'运算符。  pp_ctl.c 324 </li><li>  V502也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'&amp;&amp;'运算符。  regexec.c 7335 </li><li>  V502也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'&amp;&amp;'运算符。  re_exec.c 7335 </li></ul><br>  <b>注意同事安德烈·卡波夫（Andrei Karpov）。</b> 我在此代码上思考了10分钟，并倾向于认为没有错误。 但是无论如何，阅读这样的代码是非常痛苦的，最好不要这样写。 <br><br><h2> 条件错误 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V523'then</a> '语句等效于'else'语句。  toke.c 12056 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> U8 * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S_add_utf16_textfilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ U8 *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed)</span></span></span><span class="hljs-function"> </span></span>{ .... SvCUR_set(PL_linestr, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FILTER_READ(<span class="hljs-number"><span class="hljs-number">0</span></span>, PL_linestr, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { SvUTF8_on(PL_linestr); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { SvUTF8_on(PL_linestr); } PL_bufend = SvEND(PL_linestr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (U8*)SvPVX(PL_linestr); }</code> </pre> <br> 我认为您可以在不检查宏内容的情况下进行操作，以确保存在可疑的重复代码片段。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V564</a> '|' 运算符应用于布尔类型值。 您可能忘记了括号或打算使用'||' 操作员。  op.c 11494 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OP * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perl_ck_rvconst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ OP *o)</span></span></span><span class="hljs-function"> </span></span>{ .... gv = gv_fetchsv(kidsv, o-&gt;op_type == OP_RV2CV &amp;&amp; o-&gt;op_private &amp; OPpMAY_RETURN_CONSTANT ? GV_NOEXPAND : iscv | !(kid-&gt;op_private &amp; OPpCONST_ENTERED), iscv <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? SVt_PVCV : o-&gt;op_type == OP_RV2SV ? SVt_PV : o-&gt;op_type == OP_RV2AV ? SVt_PVAV : o-&gt;op_type == OP_RV2HV ? SVt_PVHV : SVt_PVGV); .... }</span></span></code> </pre> <br> 非常奇怪的代码。 表达式“ iscv |  ！（kid-&gt; op_private＆OPpCONST_ENTERED）“未以任何方式使用。 显然这里有一个错字。 例如，也许您应该在这里写： <br><br><pre> <code class="cpp hljs">: iscv = !(kid-&gt;op_private &amp; OPpCONST_ENTERED), iscv <span class="hljs-comment"><span class="hljs-comment">// &lt;=</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a>表达式“ RETVAL == 0”始终为true。  Typemap.c 710 <br><br><pre> <code class="cpp hljs">XS_EUPXS(XS_XS__Typemap_T_SYSRET_pass); XS_EUPXS(XS_XS__Typemap_T_SYSRET_pass) { dVAR; dXSARGS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (items != <span class="hljs-number"><span class="hljs-number">0</span></span>) croak_xs_usage(cv, <span class="hljs-string"><span class="hljs-string">""</span></span>); { SysRet RETVAL; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 370 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Typemap.xs"</span></span></span><span class="hljs-meta"> RETVAL = 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 706 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Typemap.c"</span></span></span><span class="hljs-meta"> { SV * RETVALSV; RETVALSV = sv_newmortal(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (RETVAL != -1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= if (RETVAL == 0) // &lt;= sv_setpvn(RETVALSV, "0 but true", 10); else sv_setiv(RETVALSV, (IV)RETVAL); } ST(0) = RETVALSV; } } XSRETURN(1); }</span></span></span></span></code> </pre> <br>  <i>RETVAL</i>变量连续检查两次。 此外，从代码中可以看出该变量始终为零。 也许在一种或两种情况下，他们想检查<i>RETVALSV</i>指针，但他们<i>打错</i>了字。 <br><br><h2> 抛出有关sizeof运算符的警告 </h2><br> 分析器中有几种类型的诊断规则，这些规则使用<i>sizeof</i>运算符查找错误。 在Perl 5项目中，其中两个诊断程序总共产生了大约一千条警告。 在这种情况下，应该责怪的不是分析器，而是宏。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V568</a>奇怪的是sizeof（）运算符的参数是'len + 1'表达式。 实用程序1084 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perl_savepvn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv, I32 len)</span></span></span><span class="hljs-function"> </span></span>{ .... Newx(newaddr,len+<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>); .... }</code> </pre> <br> 该代码有很多类似的宏。 我选择一个作为示例，我们对参数“ len +1”感兴趣。 <br><br> 宏预处理器扩展为以下代码： <br><br><pre> <code class="cpp hljs">(newaddr = ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)(__builtin_expect(((((( <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len+<span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) &gt; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>*(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len+<span class="hljs-number"><span class="hljs-number">1</span></span>)))) ? (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(len+<span class="hljs-number"><span class="hljs-number">1</span></span>) : ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)) &gt; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>))) ? (<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>),(<span class="hljs-number"><span class="hljs-number">0</span></span>)) &amp;&amp; (S_croak_memory_wrap(),<span class="hljs-number"><span class="hljs-number">0</span></span>)), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)(Perl_safesysmalloc((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)((len+<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>))))));</code> </pre> <br> 对<i>sizeof（len +1）</i>构造发出分析器警告。 事实是，没有在<i>sizeof</i>运算符的参数中进行任何计算。 许多宏被扩展为类似的代码。 这可能是一种旧的旧代码，其中没有人想触摸任何东西，但是当前的开发人员继续使用旧的宏，暗示了它们的不同行为。 <br><br><h2>  <i>解引用空指针</i> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V522</a>可能会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">取消</a>引用空指针“ sv”。  pp_ctl.c 577 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OP * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perl_pp_formline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... SV *sv = ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*fpc++) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: arg = *fpc++; f += arg; fieldsize = arg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mark &lt; sp) sv = *++mark; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sv = &amp;(PL_sv_immortals[<span class="hljs-number"><span class="hljs-number">2</span></span>]); Perl_ck_warner( (<span class="hljs-number"><span class="hljs-number">28</span></span> ), <span class="hljs-string"><span class="hljs-string">"...."</span></span>); } .... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s = item = ((((sv)-&gt;sv_flags &amp; (....)) == <span class="hljs-number"><span class="hljs-number">0x00000400</span></span>) ? .... .... } .... }</code> </pre> <br> 此代码段完全取自预处理文件，因为同样由于宏的原因，无法从源文件验证问题的存在。 <br><br> 声明后， <i>sv</i>指针将初始化为零。 分析器发现，在<i>switch语句中</i>传递<i>5</i>时，该指针已取消引用，之前从未进行过初始化。  <i>sv</i>指针的更改出现在分支中，值为<i>4</i> ，但该代码块的末尾是<i>break</i>语句。 很可能在此位置需要其他代码。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a>在针对nullptr进行验证之前，已使用了'k'指针。 检查行：15919，15920。op.c 15919 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perl_rpeep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pTHX_ OP *o)</span></span></span><span class="hljs-function"> </span></span>{ .... OP *k = o-&gt;op_next; U8 want = (k-&gt;op_flags &amp; OPf_WANT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if ( k // &lt;= &amp;&amp; k-&gt;op_type == OP_KEYS &amp;&amp; ( want == OPf_WANT_VOID || want == OPf_WANT_SCALAR) &amp;&amp; !(k-&gt;op_private &amp; OPpMAYBE_LVSUB) &amp;&amp; !(k-&gt;op_flags &amp; OPf_MOD) ) { .... }</span></span></code> </pre> <br> 在此代码段中，分析器找到了指针<i>k</i> ，该指针早于其有效性检查被取消引用了一行。 这可能是错误，也可能是多余的代码。 <br><br>  Diagnostics <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a>在任何项目中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">都会</a>发现很多警告，Perl 5也不例外。 不可能将所有这些内容都纳入本文，因此我们将仅举一个例子，开发人员将根据需要自行检查项目。 <br><br><h2> 杂项 </h2><br>  V779检测到无法访问的代码。 可能存在错误。 通用c 457 <br><br><pre> <code class="cpp hljs">XS(XS_utf8_valid); XS(XS_utf8_valid) { dXSARGS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (items != <span class="hljs-number"><span class="hljs-number">1</span></span>) croak_xs_usage(cv, <span class="hljs-string"><span class="hljs-string">"sv"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { SV * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sv = ST(<span class="hljs-number"><span class="hljs-number">0</span></span>); STRLEN len; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s = SvPV_const(sv,len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SvUTF8(sv) || is_utf8_string((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> U8*)s,len)) XSRETURN_YES; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> XSRETURN_NO; } XSRETURN_EMPTY; }</code> </pre> <br> 在带有<i>XSRETURN_EMPTY</i>的行上<i>，</i>分析器检测到无法访问的代码。 此函数和<i>croak_xs_usage中</i>有两个<i>return语句</i> -宏被扩展为noreturn函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perl_croak_xs_usage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CV *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> params)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((noreturn))</span></span></span></span>;</code> </pre> <br> 在Perl 5代码中的类似位置， <i>NOT_REACHED</i>宏用于指示不可达分支。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V784</a>位掩码的大小小于第一个操作数的大小。 这将导致丢失更高的位。  inffast.c 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ZLIB_INTERNAL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inflate_fast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(z_streamp strm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> hold; <span class="hljs-comment"><span class="hljs-comment">/* local strm-&gt;hold */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> bits; <span class="hljs-comment"><span class="hljs-comment">/* local strm-&gt;bits */</span></span> .... hold &amp;= (<span class="hljs-number"><span class="hljs-number">1U</span></span> &lt;&lt; bits) - <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br> 分析器在使用位掩码时检测到可疑的操作。 作为位掩码，使用比分辨率<i>hold</i>更低分辨率的变量。 这导致高位的损失。 开发人员应注意此代码。 <br><br><h2> 结论 </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9e/e0d/a01/a9ee0da01644c5db03e6d93f79cab705.png" alt="图片6"></p><br><br> 通过宏查找错误非常困难。 查看报告需要大量时间和精力。 尽管如此，本文还是包含一些非常有趣的案例，这些案例与真实错误相似。 分析器报告相当大，肯定还有很多有趣的地方。 但是，我无法进一步研究它了：)。 我建议开发人员自己检查项目，并消除他们将能够检测到的缺陷。 <br><br>  PS我们绝对希望支持这个有趣的项目，并且准备为开发人员提供几个月的许可。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Svyatoslav Razmyslov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Perl 5：如何隐藏宏中的错误</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425415/">https://habr.com/ru/post/zh-CN425415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425405/index.html">大功率新型</a></li>
<li><a href="../zh-CN425407/index.html">Firecore-AVR上的有趣游戏</a></li>
<li><a href="../zh-CN425409/index.html">DevBoy：制作信号发生器</a></li>
<li><a href="../zh-CN425411/index.html">Scrum死了</a></li>
<li><a href="../zh-CN425413/index.html">傻瓜好吗？</a></li>
<li><a href="../zh-CN425417/index.html">快闪给大家。 QSAN的全闪存阵列</a></li>
<li><a href="../zh-CN425419/index.html">《巫师》的作者要求CD Projekt Red至少提供1600万美元</a></li>
<li><a href="../zh-CN425421/index.html">星期五 程序员狂欢</a></li>
<li><a href="../zh-CN425423/index.html">关于熊猫的问题或雅罗斯拉夫纳的下一声呐喊</a></li>
<li><a href="../zh-CN425425/index.html">审查用于Internet营销的R包，第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>