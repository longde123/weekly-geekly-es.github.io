<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª ‚õ∫Ô∏è üéÖüèø Verwenden von asynchronem Messaging zur Verbesserung der Verf√ºgbarkeit üéôÔ∏è ü§Æ üßëüèº‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Wir haben k√ºrzlich ein Buch von Chris Richardson an die Druckerei √ºbergeben, um zu lehren, wie Anwendungen mithilfe der Microservi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von asynchronem Messaging zur Verbesserung der Verf√ºgbarkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458344/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/hz/bw/dj/hzbwdju5aq8nv9xbromr1vbgdsi.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Wir haben k√ºrzlich ein Buch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chris Richardson</a> an die Druckerei √ºbergeben, um zu lehren, wie Anwendungen mithilfe der Microservice-Architektur erfolgreich entwickelt werden k√∂nnen.  Das Buch behandelt nicht nur die Vorteile, sondern auch die Nachteile von Microservices.  Sie erfahren, in welchen Situationen es sinnvoll ist, sie anzuwenden, und wann es besser ist, √ºber einen monolithischen Ansatz nachzudenken. <br><br>  Das Buch konzentriert sich auf Architektur und Design.  Es richtet sich an alle Personen, deren Aufgaben das Schreiben und Bereitstellen von Software umfassen, einschlie√ülich Entwickler, Architekten, technische Direktoren und Leiter der Entwicklungsabteilungen. <br><br>  Das Folgende ist ein Auszug aus dem Buch Verwenden von asynchronem Messaging <br><a name="habracut"></a><br><h3>  Verwenden von asynchronem Messaging zur Verbesserung der Verf√ºgbarkeit </h3><br>  Wie Sie gesehen haben, f√ºhren Sie die verschiedenen IPC-Mechanismen zu verschiedenen Kompromissen.  Eine davon h√§ngt damit zusammen, wie sich IPC auf die Barrierefreiheit auswirkt.  In diesem Abschnitt erfahren Sie, dass die synchrone Interaktion mit anderen Diensten im Rahmen der Anforderungsverarbeitung die Verf√ºgbarkeit der Anwendung verringert.  In diesem Zusammenhang sollten Sie beim Entwerfen Ihrer Dienste nach M√∂glichkeit asynchrones Messaging verwenden. <br><br>  Lassen Sie uns zun√§chst sehen, welche Probleme die synchrone Interaktion verursacht und wie sie sich auf die Barrierefreiheit auswirkt. <br><br><h3>  3.4.1.  Synchronisierte Interaktion reduziert die Verf√ºgbarkeit </h3><br>  REST ist eine √§u√üerst beliebte IPC-Engine.  Sie k√∂nnten versucht sein, es f√ºr die dienst√ºbergreifende Kommunikation zu verwenden.  Das Problem mit REST ist jedoch, dass es sich um ein synchrones Protokoll handelt: Der HTTP-Client muss warten, bis der Dienst eine Antwort zur√ºckgibt.  Jedes Mal, wenn die Dienste √ºber ein synchrones Protokoll miteinander kommunizieren, wird die Verf√ºgbarkeit der Anwendung verringert. <br><br>  Um zu verstehen, warum dies geschieht, betrachten Sie das in Abb. 1 gezeigte Szenario.  3.15.  Der Bestellservice verf√ºgt √ºber eine REST-API zum Erstellen von Bestellungen.  Um die Bestellung zu √ºberpr√ºfen, wendet er sich an die Verbraucher- und Restaurantdienste, die ebenfalls √ºber eine REST-API verf√ºgen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/uq/22/pnuq22tmdzqdhbr_wxa9nuntoeq.png" alt="Bild"></div><br>  Das Erstellen einer Bestellung besteht aus dieser Abfolge von Schritten. <br><br><ol><li>  Der Client sendet eine HTTP-POST- / Bestellanforderung an den Bestellservice. </li><li>  Der Bestellservice ruft Kundeninformationen ab, indem er eine HTTP-GET / consumer / id-Anfrage an den Consumer-Service sendet. </li><li>  Der Bestellservice ruft Restaurantinformationen ab, indem er eine HTTP-GET / Restaurant / ID-Anforderung an den Restaurantdienst ausf√ºhrt. </li><li>  Order Taking pr√ºft die Anfrage anhand von Informationen √ºber den Kunden und das Restaurant. </li><li>  Auftragsannahme erstellt eine Bestellung. </li><li>  Order Taking sendet eine HTTP-Antwort an den Client. </li></ol><br>  Da diese Dienste HTTP verwenden, m√ºssen alle f√ºr FTGO zug√§nglich sein, um die CreateOrder-Anforderung verarbeiten zu k√∂nnen.  Es kann keine Bestellung erstellt werden, wenn mindestens einer der Dienste nicht verf√ºgbar ist.  Aus mathematischer Sicht ist die Verf√ºgbarkeit eines Systembetriebs ein Produkt der Verf√ºgbarkeit von Diensten, die daran beteiligt sind.  Wenn der Bestellservice und die beiden von ihm aufgerufenen Services eine Verf√ºgbarkeit von 99,5% haben, betr√§gt ihre Gesamtverf√ºgbarkeit 99,5% 3 = 98,5%, was viel niedriger ist.  Jeder nachfolgende Dienst, der an der Anforderung teilnimmt, macht den Vorgang weniger zug√§nglich. <br><br>  Dieses Problem betrifft nicht nur REST-basierte Interaktionen.  Die Verf√ºgbarkeit nimmt ab, wenn ein Dienst Antworten von anderen Diensten erhalten muss, um auf einen Client zu antworten.  Selbst der √úbergang zu einem Anforderungs- / Antwort-Interaktionsstil √ºber asynchrone Nachrichten hilft hier nicht weiter.  Wenn der Bestelldienst beispielsweise √ºber einen Broker eine Nachricht an den Verbraucherservice sendet und auf eine Antwort wartet, verschlechtert sich seine Verf√ºgbarkeit. <br><br>  Wenn Sie die Zug√§nglichkeit maximieren m√∂chten, minimieren Sie den Umfang der synchronen Interaktion.  Mal sehen, wie es geht. <br><br><h3>  3.4.2.  Befreien Sie sich von synchroner Interaktion </h3><br>  Es gibt verschiedene M√∂glichkeiten, die synchrone Interaktion mit anderen Diensten bei der Verarbeitung synchroner Anforderungen zu reduzieren.  Um dieses Problem vollst√§ndig zu vermeiden, k√∂nnen zun√§chst alle Dienste mit ausschlie√ülich asynchronen APIs bereitgestellt werden.  Dies ist jedoch nicht immer m√∂glich.  Beispielsweise entsprechen √∂ffentliche APIs im Allgemeinen dem REST-Standard.  Daher m√ºssen einige Dienste √ºber synchrone APIs verf√ºgen. <br><br>  Gl√ºcklicherweise ist es f√ºr die Verarbeitung synchroner Anforderungen nicht erforderlich, diese selbst auszuf√ºhren.  Lassen Sie uns √ºber solche Optionen sprechen. <br><br>  <b>Verwenden asynchroner Interaktionsstile</b> <br><br>  Im Idealfall sollte jede Interaktion in dem zuvor in diesem Kapitel beschriebenen asynchronen Stil erfolgen.  Stellen Sie sich beispielsweise vor, der FTGO-Anwendungsclient verwendet einen Interaktionsstil f√ºr asynchrone Anforderungen und asynchrone Antworten, um Auftr√§ge zu erstellen.  Um eine Bestellung anzulegen, sendet er eine Anforderungsnachricht an den Bestellservice.  Dieser Dienst tauscht dann asynchron Nachrichten mit anderen Diensten aus und gibt schlie√ülich eine Antwort an den Client zur√ºck (Abb. 3.16). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/j3/px/7ej3pxinlckogxf4ga0fmjaxtmu.png" alt="Bild"></div><br>  Der Client und der Dienst kommunizieren asynchron und senden Nachrichten √ºber Kan√§le.  Keiner der Teilnehmer an dieser Interaktion ist blockiert und wartet auf eine Antwort. <br><br>  Eine solche Architektur w√§re √§u√üerst robust, da der Broker Nachrichten puffert, bis ihr Verbrauch m√∂glich ist.  Das Problem ist jedoch, dass Dienste h√§ufig √ºber eine externe API verf√ºgen, die ein synchrones Protokoll wie REST verwendet und daher sofort auf Anforderungen reagieren muss. <br><br>  Wenn der Dienst √ºber eine synchrone API verf√ºgt, kann die Zug√§nglichkeit durch Datenreplikation verbessert werden.  Mal sehen, wie es funktioniert. <br><br>  <b>Datenreplikation</b> <br><br>  Eine M√∂glichkeit, die synchrone Interaktion w√§hrend der Abfrageverarbeitung zu minimieren, besteht darin, Daten zu replizieren.  Der Dienst speichert eine Kopie (Replikat) der Daten, die zur Verarbeitung von Anforderungen ben√∂tigt werden.  Um das Replikat auf dem neuesten Stand zu halten, werden Ereignisse abonniert, die von den Diensten ver√∂ffentlicht wurden, zu denen diese Daten geh√∂ren.  Beispielsweise kann ein Bestelldienst eine Kopie von Daten speichern, die zu den Verbraucher- und Restaurantdiensten geh√∂ren.  Auf diese Weise kann er Anfragen zum Erstellen von Bestellungen bearbeiten, ohne auf diese Dienste zur√ºckgreifen zu m√ºssen.  Eine solche Architektur ist in Abb. 1 dargestellt.  3.17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p9/vz/zs/p9vzzssvlgjr7xx3efpsyjtesly.png" alt="Bild"></div><br>  Die Verbraucher- und Restaurantdienste ver√∂ffentlichen Ereignisse, wenn sich ihre Daten √§ndern.  Der Bestellservice abonniert diese Ereignisse und aktualisiert sein Replikat. <br><br>  In einigen F√§llen ist die Datenreplikation eine gute L√∂sung.  In Kapitel 5 wird beispielsweise beschrieben, wie der Bestellservice Restaurant-Servicedaten repliziert, um Men√ºelemente √ºberpr√ºfen zu k√∂nnen.  Einer der Nachteile dieses Ansatzes besteht darin, dass manchmal gro√üe Datenmengen kopiert werden m√ºssen, was ineffizient ist.  Wenn wir beispielsweise viele Kunden haben, kann es unpraktisch sein, eine Replik der Daten des Verbraucherdienstes zu speichern.  Ein weiterer Nachteil der Replikation besteht darin, dass das Problem der Aktualisierung von Daten anderer Dienste nicht gel√∂st wird. <br><br>  Um dieses Problem zu l√∂sen, kann ein Dienst die Interaktion mit anderen Diensten verz√∂gern, bis er auf seinen Client reagiert.  Dies wird weiter diskutiert. <br><br>  <b>Beenden Sie die Verarbeitung, nachdem Sie eine Antwort zur√ºckgegeben haben</b> <br><br>  Eine andere M√∂glichkeit, die synchrone Interaktion w√§hrend der Abfrageverarbeitung zu eliminieren, besteht darin, diese Verarbeitung in Form der folgenden Schritte durchzuf√ºhren. <br><br><ol><li>  Der Dienst pr√ºft die Anfrage nur mit Hilfe lokal verf√ºgbarer Daten. </li><li>  Es aktualisiert seine Datenbank, einschlie√ülich des Hinzuf√ºgens von Nachrichten zur OUTBOX-Tabelle. </li><li>  Gibt die Antwort an den Client zur√ºck. </li></ol><br>  W√§hrend der Verarbeitung der Anforderung greift der Dienst nicht synchron auf andere Dienste zu.  Stattdessen sendet er ihnen asynchrone Nachrichten.  Dieser Ansatz bietet eine schlechte Konnektivit√§t von Diensten.  Wie Sie im n√§chsten Kapitel sehen werden, wird dieser Prozess h√§ufig als Erz√§hlung implementiert. <br><br>  Stellen Sie sich vor, der Bestellservice verh√§lt sich so.  Er erstellt eine Bestellung mit dem Status PENDING und √ºberpr√ºft diese, indem er asynchrone Nachrichten mit anderen Diensten austauscht.  In Abb.  Abbildung 3.18 zeigt, was passiert, wenn die Operation createOrder () aufgerufen wird.  Die Kette der Ereignisse sieht so aus. <br><br><ol><li>  Der Bestellservice erstellt eine Bestellung mit dem Status PENDING. </li><li>  Der Bestellservice gibt eine Antwort mit der Bestell-ID an seinen Kunden zur√ºck. </li><li>  Der Bestelldienst sendet eine ValidateConsumerInfo-Nachricht an den Verbraucherdienst. </li><li>  Der Bestellservice sendet eine ValidateOrderDetails-Nachricht an den Restaurantdienst. </li><li>  Der Consumer-Service empf√§ngt eine ValidateConsumerInfo-Nachricht, pr√ºft, ob der Kunde eine Bestellung aufgeben kann, und sendet eine ConsumerValidated-Nachricht an den Order-Service. </li><li>  Der Restaurantdienst empf√§ngt eine ValidateOrderDetails-Nachricht, √ºberpr√ºft die Richtigkeit der Men√ºelemente und die F√§higkeit des Restaurants, eine Bestellung an eine bestimmte Adresse zu liefern, und sendet eine OrderDetailsValidated-Nachricht an den Bestelldienst. </li><li>  Der Bestellservice empf√§ngt ConsumerValidated- und OrderDetailsValidated-Nachrichten und √§ndert den Bestellstatus in VALIDATED. </li></ol><br>  Usw‚Ä¶ <br><br>  Der Bestellservice kann ConsumerValidated- und OrderDetailsValidated-Nachrichten in beliebiger Reihenfolge empfangen.  Um zu wissen, welche er zuerst erhalten hat, √§ndert er den Status der Bestellung.  Wenn die erste Nachricht ConsumerValidated war, √§ndert sich der Bestellstatus in CONSUMER_VALIDATED, und wenn OrderDetailsValidated in ORDER_DETAILS_VALIDATED ge√§ndert wird.  Nach Erhalt der zweiten Nachricht setzt der Bestellservice den Bestellstatus auf VALIDATED. <br><br>  Nach √úberpr√ºfung der Bestellung f√ºhrt der Bestellservice die verbleibenden Schritte zum Erstellen der Bestellung aus, die im n√§chsten Kapitel erl√§utert werden.  Ein gro√üer Teil dieses Ansatzes besteht darin, dass der Bestellservice eine Bestellung erstellen und auf den Kunden reagieren kann, selbst wenn der Verbraucherservice nicht verf√ºgbar ist.  Fr√ºher oder sp√§ter wird der Verbraucherservice alle ausstehenden Nachrichten wiederherstellen und verarbeiten, wodurch die √úberpr√ºfung der Bestellungen abgeschlossen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/d2/e_/hvd2e_kioxghqoo4jwcyqroerk8.png" alt="Bild"></div><br>  Der Nachteil der R√ºckgabe einer Antwort vor der vollst√§ndigen Verarbeitung der Anforderung besteht darin, dass der Client dadurch komplexer wird.  Wenn der Bestellservice beispielsweise eine Antwort zur√ºckgibt, gibt er nur minimale Garantien f√ºr den Status der soeben erstellten Bestellung.  Er antwortet sofort, noch bevor er die Bestellung √ºberpr√ºft und die Bankkarte des Kunden autorisiert.  Um herauszufinden, ob die Bestellung erfolgreich erstellt wurde, muss der Kunde regelm√§√üig Informationen anfordern oder der Bestelldienst muss ihm eine Benachrichtigung senden.  Trotz der Komplexit√§t dieses Ansatzes lohnt es sich in vielen F√§llen, ihn zu bevorzugen, insbesondere weil er die Probleme mit dem verteilten Transaktionsmanagement ber√ºcksichtigt, die wir in Kapitel 4 diskutieren werden. In den Kapiteln 4 und 5 werde ich diese Technik am Beispiel des Bestellservices demonstrieren. <br><br><h3>  Zusammenfassung </h3><br><ul><li>  Die Microservice-Architektur ist verteilt, daher spielt die Interprozesskommunikation eine Schl√ºsselrolle. </li><li>  Die Entwicklung des API-Dienstes muss sorgf√§ltig und sorgf√§ltig angegangen werden.  Es ist am einfachsten, abw√§rtskompatible √Ñnderungen vorzunehmen, da diese die Arbeitsweise der Kunden nicht beeinflussen.  Wenn Sie wichtige √Ñnderungen an der Service-API vornehmen, m√ºssen Sie normalerweise sowohl die alte als auch die neue Version beibehalten, bis die Clients aktualisiert werden. </li><li>  Es gibt viele IPC-Technologien mit jeweils eigenen St√§rken und Schw√§chen.  Die Schl√ºsselentscheidung in der Entwurfsphase ist die Wahl zwischen synchronem Remoteprozeduraufruf und asynchronen Nachrichten.  Am einfachsten zu verwenden sind synchrone Protokolle wie REST, die auf dem Aufruf von Remoteprozeduren basieren.  Um die Zug√§nglichkeit zu verbessern, sollten Dienste im Idealfall √ºber asynchrones Messaging kommunizieren. </li><li>  Um eine Lawinen-√§hnliche Anh√§ufung von Fehlern im System zu verhindern, muss ein Client, der ein synchrones Protokoll verwendet, in der Lage sein, Teilausf√§lle zu bew√§ltigen - die Tatsache, dass der aufgerufene Dienst entweder nicht verf√ºgbar ist oder eine hohe Latenz aufweist.  Insbesondere bei der Ausf√ºhrung von Anforderungen ist es erforderlich, die Wartezeit zu z√§hlen, die Anzahl √ºberf√§lliger Anforderungen zu begrenzen und die Vorlage "Sicherung" anzuwenden, um Anrufe an den fehlerhaften Dienst zu vermeiden. </li><li>  Eine Architektur, die synchrone Protokolle verwendet, muss einen Erkennungsmechanismus enthalten, damit Clients den Netzwerkstandort von Dienstinstanzen bestimmen k√∂nnen.  Am einfachsten ist es, sich auf den von der Bereitstellungsplattform bereitgestellten Erkennungsmechanismus zu konzentrieren: auf die Vorlagen "Serverseitige Erkennung" und "Registrierung von Drittanbietern".  Ein alternativer Ansatz ist die Implementierung der Serviceerkennung auf Anwendungsebene: die Vorlagen f√ºr die Clienterkennung und die Selbstregistrierung.  Diese Methode erfordert mehr Aufwand, eignet sich jedoch f√ºr Situationen, in denen Dienste auf mehreren Bereitstellungsplattformen ausgef√ºhrt werden. </li><li>  Das Nachrichten- und Kanalmodell kapselt die Details der Implementierung des Nachrichtensystems und wird eine gute Wahl beim Entwerfen dieser Art von Architektur.  Sp√§ter k√∂nnen Sie Ihre Architektur an eine bestimmte Messaging-Infrastruktur binden, f√ºr die normalerweise ein Broker verwendet wird. </li><li>  Eine Hauptschwierigkeit beim Messaging ist die Ver√∂ffentlichung und Aktualisierung der Datenbank.  Eine gute L√∂sung ist die Verwendung der Event Publishing-Vorlage: Die Nachricht wird ganz am Anfang als Teil der Transaktion in die Datenbank geschrieben.  Ein separater Prozess ruft dann die Nachricht mithilfe der Vorlage "Interrogating Publisher" oder "Transactional Log Tracking" aus der Datenbank ab und leitet sie an den Broker weiter. </li></ul><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  F√ºr Khabrozhiteley 30% Rabatt auf vorbestellte B√ºcher auf einen Gutschein - <b>Microservices</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458344/">https://habr.com/ru/post/de458344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458332/index.html">Asynchrone Programmierung - asynchrone Leistung: Verstehen Sie die Kosten der asynchronen Programmierung und warten Sie</a></li>
<li><a href="../de458334/index.html">Kontinuierliche Replikation von altem zu neuem PostgreSQL mit Slony</a></li>
<li><a href="../de458336/index.html">Der gesamte Zyklus der IT-Produktentwicklung anhand des Projektbeispiels: Teamrollen, Kundenaufgaben, Phasen</a></li>
<li><a href="../de458338/index.html">Anwendungssicherheits-Manager. Entwickler oder Sicherheit?</a></li>
<li><a href="../de458342/index.html">Texturierung oder was Sie wissen m√ºssen, um ein Oberfl√§chenk√ºnstler zu werden. Teil 1. Pixel</a></li>
<li><a href="../de458346/index.html">Probleml√∂sung mit pwnable.kr 01 - fd. Dateideskriptoren und -prozesse</a></li>
<li><a href="../de458348/index.html">Samsung Ecosystem - Wettbewerbsergebnisse</a></li>
<li><a href="../de458350/index.html">Schmutziger Twitter-Test des VS7.0-ER</a></li>
<li><a href="../de458352/index.html">[Peter] JUG.ru mit Cliff Click treffen - eine JVM macht das?</a></li>
<li><a href="../de458354/index.html">Einf√ºhrung in das Umkehren von Grund auf mit IDA PRO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>