<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛁 👨‍👩‍👧 👿 SQL HowTo: Erstellen von Ketten mit Fensterfunktionen 🛕 👩🏼‍🤝‍👨🏻 🕋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Analyse von Daten tritt manchmal das Problem auf , „Ketten“ in einer Stichprobe zu unterscheiden, dh geordnete Sequenzen von Datensätzen, für ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL HowTo: Erstellen von Ketten mit Fensterfunktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483460/">  Bei der Analyse von Daten tritt manchmal das <b>Problem auf</b> , <b>„Ketten“ in einer Stichprobe zu unterscheiden, dh</b> <u>geordnete Sequenzen von</u> Datensätzen, für die jeweils <u>eine bestimmte Bedingung erfüllt ist</u> . <br><br>  Dies kann entweder eine Bedingung für die Daten des Datensatzes selbst oder ein komplexer Ausdruck in Bezug auf einen oder mehrere vorherige Datensätze sein, z. B. die Länge des Intervalls zwischen Abtastungen zum Abschlusszeitpunkt. <br><br><img src="https://habrastorage.org/webt/fx/nc/ld/fxncldmr0bpfaufpa2tosjozqy8.png"><br><br>  Herkömmliche Lösungen bieten verschiedene Optionen für die "Selbstverknüpfung", wenn die Stichprobe eine Verbindung zu sich selbst herstellt, oder für die Verwendung bestimmter Fakten "außerhalb der Daten". Beispielsweise müssen Datensätze einen genau definierten Schritt haben (N + 1, "für jeden Tag", ...). ) <br><br>  Die erste Option führt häufig zu einer <b>quadratischen Komplexität des</b> Algorithmus in Bezug auf die Anzahl der Datensätze, die <a href="https://habr.com/ru/post/479298/">bei großen Stichproben nicht akzeptabel</a> ist, und die zweite Option <b>kann leicht „auseinanderfallen“,</b> wenn die Quelldaten plötzlich keine Stichproben enthalten. <br><br>  Diese Aufgabe hilft uns jedoch, <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">Fensterfunktionen</a> in PostgreSQL effektiv zu lösen. <br><a name="habracut"></a><br><h2>  Aufgabe: Das Geld anderer Leute zählen </h2><br>  Stellen Sie sich den einfachsten Fall einer Kette vor, bei dem die Kontinuitätsbedingung durch die Daten des Datensatzes selbst bestimmt wird. <br><br>  Alle weiteren Vorgänge müssen nicht separat durchgeführt werden.  Der Klarheit halber werde ich den Algorithmus jedoch in aufeinanderfolgende Schritte aufteilen und <u>am Ende zeigen, was und wie optimiert werden muss</u> . <br><br>  Stellen wir uns vor, wir haben eine kleine Bank, die Guthaben auf Kundenkonten in der Tabelle verwaltet.  Sobald die Eingangs- und Ausgabentransaktion stattfindet, wird mit diesem Datum auch der Gesamtrechnungsbetrag am Ende des Tages festgelegt. <br><blockquote>  Nach einem langen Neujahrsurlaub entschied sich die Bank, ihre Kunden zu belohnen - und jede Person, die in diesem Jahr ein Konto eröffnet hat, erhält zusätzlich + 1% des <u>durchschnittlichen täglichen Kontostands</u> für <b>den längsten zusammenhängenden Zeitraum,</b> in dem das <u>Konto nicht „zurückgesetzt“ wurde</u> . </blockquote>  Hier ist es unser Kriterium für die Kontinuität der "Kette".  Nun, die Reihenfolge der Daten wird durch die Daten der Salden bestimmt. <br><br>  Sie brachten uns eine solche CSV und fragten uns, wer und wie viel Großzügigkeit von der Bank bekommen sollte: <br><br><pre><code class="plaintext hljs">date;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5</code> </pre> <br>  Beachten Sie nur einige Fakten, die sich in diesen Daten bemerkbar machen: <br><br><ul><li>  01.01 war ein Feiertag, und die Bank hat nicht funktioniert.  Daher hat keiner der Kunden Aufzeichnungen über Änderungen des Kontostands an diesem Tag, aber sie haben Geld auf ihren Konten.  Das heißt, "Brute Force" -Algorithmen, die am Tag wiederholt werden, funktionieren nicht normal. </li><li>  04.01 Alice hat keine Operationen durchgeführt, daher gibt es keinen Eintrag.  Aber vor dem 05.01 war der Betrag auf ihrem Konto nicht Null - dies muss bei der Analyse berücksichtigt werden. </li><li>  Wir führen die Analyse am 01.01.12.01 durch, aber der Kontostand von Alice am Ende dieses Zeitraums ist ungleich Null.  Wir berücksichtigen auch die Notwendigkeit, den Zeitraum zu begrenzen. </li></ul><br><h2>  CSV-to-Table </h2><br>  Der beste Weg, aus CSV zu importieren, ist die <a href="https://www.postgresqltutorial.com/import-csv-file-into-posgresql-table/" rel="nofollow">Verwendung des COPY-Operators</a> .  Aber wir werden versuchen, dies durch reguläre Ausdrücke zum Aufwärmen zu tun: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span>(prt[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) dt , prt[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , prt[<span class="hljs-number"><span class="hljs-number">3</span></span>]::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_array(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>) prt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_table( $$ <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5 $$ , E'\\n') str ) T WHERE str &lt;&gt; '' OFFSET 1 ) T;</code> </pre> <br>  Dies ist eine „unehrliche“ Methode in dem Sinne, dass sie nicht richtig verdaut wird, z. B. indem ein Separator im Körper eines Feldes abgeschirmt wird.  Aber für die meisten einfachen Anwendungen - geeignet. <br><br><h2>  Schritt 1: Korrigieren Sie den Anwendungszustand </h2><br>  In unserem Fall ist die Kettenkontinuitätsbedingung ein Gleichgewicht ungleich Null.  Wir zeigen es der Übersichtlichkeit halber als separates Feld an, in chronologischer Reihenfolge nach Kunden: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, dt;</code> </pre><br><pre> <code class="plaintext hljs">dt | client | balance | cond ------------------------------------ 2020-01-01 |  | 150.00 | t 2020-01-02 |  | 100.00 | t 2020-01-03 |  | 200.00 | t 2020-01-05 |  | 0.00 | f 2020-01-06 |  | 50.00 | t 2020-01-08 |  | 0.00 | f 2020-01-09 |  | 0.00 | f 2020-01-10 |  | 5.00 | t 2020-01-01 |  | 100.00 | t 2020-01-02 |  | 150.00 | t 2020-01-08 |  | 200.00 | t 2020-01-09 |  | 0.00 | f</code> </pre><br><h2>  Schritt 2: Berechnen Sie das Fehlen </h2><br>  Beachten Sie, dass sich der Betrag von Bob nicht von 02.01 auf 08.01 geändert hat.  Und je nach den Bedingungen des Problems müssen wir den <u>durchschnittlichen Tagesrest</u> berechnen - das heißt, wir benötigen Informationen über diese „fehlenden“ Tage.  Oder zumindest die Anzahl der Tage, an denen der Wert gleich blieb: <br><br><pre> <code class="sql hljs">coalesce(lead(dt) OVER(PARTITION BY client ORDER BY dt), '2020-01-12') - dt days</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days ------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 2020-01-02 |  | 100.00 | t | 1 2020-01-03 |  | 200.00 | t | 2 2020-01-05 |  | 0.00 | f | 1 2020-01-06 |  | 50.00 | t | 2 2020-01-08 |  | 0.00 | f | 1 2020-01-09 |  | 0.00 | f | 1 2020-01-10 |  | 5.00 | t | 2 2020-01-01 |  | 100.00 | t | 1 2020-01-02 |  | 150.00 | t | 6 2020-01-08 |  | 200.00 | t | 1 2020-01-09 |  | 0.00 | f | 3</code> </pre><br>  Mit <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">der Funktion lead () Fenster haben</a> wir das Datum aus dem <u>nächsten</u> Datensatz in der angegebenen Reihenfolge gelernt und durch <b>Zusammenführen</b> das Intervall für den letzten Datensatz begrenzt.  Gleichzeitig verwendeten sie die nützliche Eigenschaft, dass die <b>Differenz zweier Daten in PostgreSQL eine ganze Zahl von Tagen</b> zwischen ihnen <b>zurückgibt</b> . <br><br>  Als beinahe kostenlosen Bonus erhielten wir alle gleichen Informationen für Datensätze mit einem Saldo von Null.  Wenn es jedoch viele Zeilen mit einer nicht erfüllten Bedingung gibt, die uns nicht interessieren, ist es sinnvoll <a href="https://habr.com/ru/post/479508/">,</a> solche <a href="https://habr.com/ru/post/479508/">Berechnungen unter CASE</a> durchzuführen, um Serverressourcen zu sparen. <br><br><h2>  Schritt 3: Finden Sie die Haltepunkte </h2><br>  Der Anfang jeder Kette, an der wir interessiert sind, ist der Punkt, an dem sich der Wert der zuvor berechneten Bedingung relativ zum <u>vorherigen</u> Datensatz ändert.  Wir werden die Funktion <b>lag ()</b> verwenden, um solche Punkte zu finden: <br><br><pre> <code class="sql hljs">lag(cond) OVER(PARTITION BY client ORDER BY dt) IS DISTINCT FROM cond chain_start</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start --------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t 2020-01-02 |  | 100.00 | t | 1 | f 2020-01-03 |  | 200.00 | t | 2 | f 2020-01-05 |  | 0.00 | f | 1 | t 2020-01-06 |  | 50.00 | t | 2 | t 2020-01-08 |  | 0.00 | f | 1 | t 2020-01-09 |  | 0.00 | f | 1 | f 2020-01-10 |  | 5.00 | t | 2 | t 2020-01-01 |  | 100.00 | t | 1 | t 2020-01-02 |  | 150.00 | t | 6 | f 2020-01-08 |  | 200.00 | t | 1 | f 2020-01-09 |  | 0.00 | f | 3 | t</code> </pre><br>  Durch die Verwendung des Operators <b>IS DISTINCT FROM</b> anstelle von &lt;&gt; konnten die Probleme beim Vergleich mit NULL für die ersten Datensätze für jeden Client vermieden werden.  Dementsprechend sind alle Zeilen, in denen der Wert TRUE der Anfang einer neuen Kette und FALSE deren Fortsetzung ist. <br><br><h2>  Schritt 4: Verknüpfen Sie die Links </h2><br>  Um Daten innerhalb jeder einzelnen Kette zu gruppieren, ist es am einfachsten, allen Datensätzen <b>denselben Bezeichner</b> zuzuweisen.  Die Seriennummer der Kette selbst ist dafür perfekt.  Und es ist genau gleich der <b>Anzahl der "Anfänge" von Ketten</b> , die höher in der Stichprobe gefunden wurden. <br><br>  Sie können entweder durch die "Fenster" -Summe der Bool-Werte ({boolean} :: integer) oder durch Zählen der Anzahl der Datensätze berechnet werden, die mit der Bedingung count (*) FILTER (WHERE {boolean} übereinstimmen.  Wir werden die zweite Option verwenden: <br><br><pre> <code class="sql hljs">count(*) FILTER(WHERE chain_start) OVER(PARTITION BY client ORDER BY dt) grpid</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start | grpid ----------------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t | 1 2020-01-02 |  | 100.00 | t | 1 | f | 1 2020-01-03 |  | 200.00 | t | 2 | f | 1 2020-01-06 |  | 50.00 | t | 2 | t | 2 2020-01-10 |  | 5.00 | t | 2 | t | 3 2020-01-01 |  | 100.00 | t | 1 | t | 1 2020-01-02 |  | 150.00 | t | 6 | f | 1 2020-01-08 |  | 200.00 | t | 1 | f | 1</code> </pre><br>  In diesem Schritt kennen wir bereits die Länge aller Glieder in jeder Kette. Wir brauchen keine "uninteressanten" Datensätze mehr. Filtern Sie sie einfach heraus. <br><br><h2>  Schritt 5: Ketten setzen </h2><br>  Um den Durchschnitt aller Tage in einer Kette zu berechnen, benötigen wir die Gesamtzahl der Tage und den "integralen" Saldo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) balance , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-06 | 100.00 | 2  | 2020-01-10 | 10.00 | 2  | 2020-01-01 | 1200.00 | 8</code> </pre><br><h2>  Schritt 6: Suchen Sie nach Applied Highs </h2><br>  Mit <b>DISTINCT ON</b> hinterlassen wir für jeden Kunden einen einzigen Datensatz (mit einem Höchstwert von Tagen): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-01 | 1200.00 | 8</code> </pre><br>  Eigentlich ist das alles, alles was noch übrig ist ... <br><br><h2>  Wir kombinieren und optimieren </h2><br><div class="spoiler">  <b class="spoiler_title">Zusammenfassende Anfrage</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> lag(cond) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> chain_start , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">lead</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w), <span class="hljs-string"><span class="hljs-string">'2020-01-12'</span></span>) - dt <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl , LATERAL(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond) T WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) ) , step4 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) FILTER(<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chain_start) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) grpid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> cond ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step4 WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, grpid) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre></div></div><br>  Hier haben wir die ersten drei Schritte zusammengefasst und optimiert: <br><br><ul><li>  <b>Die LATERAL-Unterabfrage</b> ermöglichte es uns, ein zusätzliches Feld zu berechnen, ohne die Auswahl unnötig zu durchlaufen, und es sofort in der Funktion zu verwenden </li><li>  Das Entfernen einer allgemeinen Definition unter <b>WINDOW</b> hilft PostgreSQL dabei, nicht doppelt zu sortieren, um ein „Fenster“ zu bilden und beide Funktionen in einem WindowAgg-Knoten zu berechnen </li><li>  Die <b>Berechnung der</b> Lazy- <b>Funktion unter CASE</b> reduziert die Anzahl der ausgeführten Operationen </li></ul><br>  In ähnlicher Weise haben wir die folgenden beiden Schritte kombiniert.  Die Reihenfolge des „Fensters“ für die Berechnung der Aggregate (Client, Grpid) und der Eindeutigkeit (Client, Summe (Tage)) stimmte jedoch nicht überein. Daher befinden sich im letzten Block noch zwei Sortierknoten - vor WindowAgg und vor Unique. <br><br><img src="https://habrastorage.org/webt/8h/nq/2_/8hnq2_rny7scq8l_lo0qml_oayc.png"><br>  <a href="https://explain.tensor.ru/archive/explain/33705f55485a31a59d37945d63f26696:0:2020-01-12" rel="nofollow">[siehe EXPLAIN.TENSOR.RU]</a> <br><br>  Ich stelle fest, dass beim Nummerieren von Ketten zuerst <b>die WHERE-Bedingung erfüllt wird</b> , sodass sich die von der <u>Fensterfunktion</u> generierten Zahlen als sequenziell herausstellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483460/">https://habr.com/ru/post/de483460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483444/index.html">DORA-Bericht 2019: So verbessern Sie die DevOps-Leistung</a></li>
<li><a href="../de483446/index.html">Wissenschaftler haben einen neuen Weg gefunden, um den Eisengehalt im Trinkwasser zu senken</a></li>
<li><a href="../de483448/index.html">Disney - die größte Zwei-Wege in der Geschichte der Menschheit</a></li>
<li><a href="../de483454/index.html">Wechseln von Mercurial zu GIT in Atlassian Bitbucket mit Speichern von Dateien in kyrillischer Sprache</a></li>
<li><a href="../de483458/index.html">GreenPig-Datenbankassistent</a></li>
<li><a href="../de483462/index.html">Halt die Klappe und nimm mein Geld</a></li>
<li><a href="../de483466/index.html">Einführung in die Backpropagation-Methode</a></li>
<li><a href="../de483468/index.html">Flatterintegrationstests - ganz einfach</a></li>
<li><a href="../de483470/index.html">Fliesen effizient verlegen (Pro CSS, SVG, Muster und mehr)</a></li>
<li><a href="../de483472/index.html">Alles löschen: So löschen Sie Daten und setzen die NVMe-SSD auf die Werkseinstellungen zurück</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>