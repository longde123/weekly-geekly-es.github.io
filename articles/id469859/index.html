<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ãŠ—ï¸ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ‘¨ğŸ½â€ğŸ“ Pointer dan Value semantik dalam menentukan penerima suatu metode ğŸ ğŸ’ ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Membuat tipe data baru adalah bagian penting dari pekerjaan setiap programmer. Dalam kebanyakan bahasa, definisi tipe terdiri dari deskripsi bidang da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointer dan Value semantik dalam menentukan penerima suatu metode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469859/">  Membuat tipe data baru adalah bagian penting dari pekerjaan setiap programmer.  Dalam kebanyakan bahasa, definisi tipe terdiri dari deskripsi bidang dan metodenya.  Di Golang, selain ini, Anda perlu memutuskan semantik penerima mana untuk metode tipe baru yang akan digunakan: nilai (nilai) atau penunjuk (pointer).  Pada pandangan pertama, keputusan ini mungkin tampak sekunder, karena dalam kebanyakan kasus program akan bekerja dengan semantik penerima.  Oleh karena itu, banyak orang melewati titik ini dan menulis kode, tanpa sepenuhnya memahami apa yang semantik dari penerima metode.  Dan untuk mengetahuinya, Anda perlu sedikit lebih dalam tentang bagaimana Golang bekerja. <br><a name="habracut"></a><br>  Pertimbangkan sebuah contoh kecil.  Tentukan struktur <i>kucing</i> dengan satu bidang <i>Nama</i> dan metode <i>sayHello (string orang)</i> .  Selanjutnya, <i>dengan metode</i> saya akan merujuk ke fungsi yang terkait dengan tipe tertentu, <i>objek</i> ke variabel yang memiliki metode, dan <i>penerima metode</i> akan menjadi variabel yang ditunjukkan dalam tanda kurung setelah kata <i>func</i> dalam deskripsi metode. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> cat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(person </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Meow, meow, %s!"</span></span>, person) }</code> </pre> <br>  Jika kita mendefinisikan pointer ke <i>cat</i> dan meminta bidang <i>Nama</i> darinya, maka, jelas, kita akan mendapatkan kesalahan, karena bidang tersebut dipanggil dari <i>nil</i> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil fmt.Println(c.Name) //panic: runtime error: invalid memory address or nil pointer dereference</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.golang.org/p/L3FnRJXKqs0</a> <br><br>  Namun, ketika metode <i>sayHello ()</i> dipanggil pada variabel yang sama, tidak akan ada kesalahan: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil c.sayHello(â€œHumanâ€) //Meow, meow, Human!</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.golang.org/p/EMoFgKL1HEi</a> <br><br>  Mengapa <i>nil</i> dapat memanggil metode dalam contoh ini, dan bagaimana ini dijelaskan dalam hal arsitektur bahasa itu sendiri?  Ini menjadi mungkin karena metode dalam Go adalah sintaksis gula, atau, dengan kata lain, pembungkus di sekitar fungsi yang memiliki salah satu argumen penerima.  Ketika metode <i>c.sayHello ("Manusia")</i> dipanggil, <i>(* cat) .sayHello (c, s)</i> construct ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.golang.org/p/X9leJeIvxcA</a> ) sebenarnya akan dipanggil.  Dengan memanggil metode <i>nil</i> dari contoh di atas, kita secara praktis memanggil fungsi dengan <i>nil</i> dalam argumen, dan ini sudah merupakan situasi yang cukup normal.  Oleh karena itu, di Go <i>nil, itu</i> adalah penerima yang tepat untuk metode. <br><br>  Karena penerima metode sebenarnya adalah argumen, rekomendasi untuk menggunakan semantik "nilai" atau "pointer" untuk penerima metode mirip dengan rekomendasi untuk argumen fungsi.  Mereka, pada gilirannya, disimpulkan dari aturan dasar Go: <b>argumen selalu diteruskan ke fungsi dengan nilai</b> .  Ini berarti bahwa transfer argumen apa pun ke fungsi terjadi melalui penyalinannya: jika fungsi menerima suatu struktur sebagai input, maka salinan lengkap dari struktur ini akan masuk ke dalamnya;  jika dibutuhkan pointer ke objek, maka variabel baru akan datang dengan pointer ke objek yang sama.  Ini dapat dilihat dengan membandingkan alamat variabel sebelum meneruskannya ke fungsi dengan alamat argumen di dalam fungsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.golang.org/p/oc2ssC_Irs8</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.golang.org/p/FeQa2HUdX0a</a> ). <br><br>  Saat lewat tautan digunakan: <br><br><ul><li>  Untuk struktur besar.  Pointer hanya menempati satu kata mesin (32, 64 bit tergantung pada sistem).  Oleh karena itu, ketika memanggil metode dengan pointer di penerima, menyalin pointer lebih murah daripada menyalin seluruh objek, seperti halnya dengan melewatkan nilai. </li><li>  Jika metode yang dipanggil memodifikasi data objek itu sendiri.  Ketika penerima ditransfer dengan referensi, metode ini dapat mempengaruhi keadaan objek panggilan dengan secara tidak langsung membuat perubahan.  Yang tidak mungkin ketika melewati nilai. </li></ul><br>  Saat menggunakan transfer nilai: <br><br><ul><li>  Untuk tipe bawaan yang sederhana seperti angka, string, bool.  Saat menggunakan pointer, jumlah memori yang hampir sama digunakan dengan objek jenis ini, dan biaya pemeliharaannya oleh pengumpul sampah meningkat, seperti yang akan dijelaskan di bawah ini. </li><li>  Untuk irisan, serta jenis referensi lainnya: peta dan saluran - tidak masuk akal untuk mengambil pointer.  Mereka sendiri sudah menjadi pointer. </li><li>  Dengan multi-threading, melewati nilai aman, tidak seperti lewat referensi. </li><li>  Untuk struktur kecil.  Dalam kasus seperti itu, transmisi berdasarkan nilai lebih efisien.  Ini karena data internal metode ditempatkan dalam bingkai stack yang terpisah.  Setelah keluar dari suatu fungsi, bingkainya dihapus.  Ketika kami menggeledah sesuatu di sepanjang pointer, kami mentransfer data ini dari tumpukan ke tumpukan, dari mana data ini mungkin tersedia untuk fungsi lainnya.  Meningkatkan tumpukan menciptakan beban tambahan pada pengumpul sampah, yang operasinya mengurangi kecepatan program rata-rata 25%.  Saat menggunakan transfer nilai demi nilai, data tetap berada di tumpukan dan tidak ada pekerjaan pengumpul sampah tambahan yang diperlukan. </li></ul><br>  Saat Anda perlu memikirkan semantik penerima: <br><br><ul><li>  Jenis penerima dapat bervariasi berdasarkan bidang subjek.  Dalam salah satu pidatonya, Bill Kennedy memberikan contoh yang baik dengan tipe pengguna yang menggambarkan pengguna.  Ketika diteruskan oleh nilai, salinan akan dibuat untuk pengguna.  Ini akan mengarah pada fakta bahwa beberapa salinan dari pengguna yang sama dapat hidup berdampingan dalam program pada saat yang sama, yang kemudian dapat diubah secara independen, yang tidak sesuai dengan bidang subjek, karena pengguna sebenarnya selalu satu, dan ia tidak dapat dijelaskan pada waktu yang berbeda dengan set yang berbeda. data. </li><li>  Cara pasti lainnya untuk menentukan jenis penerima untuk suatu metode adalah dengan menggunakan metode konstruktor untuk jenisnya.  Jika konstruktor mengembalikan nilai / penunjuk, maka saat membuat entitas, diasumsikan bahwa mereka akan terus bekerja dengannya sebagai nilai / penunjuk.  Oleh karena itu, lebih baik menggunakan semantik yang sama dalam metode penerima. </li><li>  Ada aturan tidak tertulis, yang melanggar kompiler tidak akan bersumpah, tetapi kode Anda pasti tidak akan lebih baik dari ini.  Jika salah satu metode tipe menggunakan pointer / nilai sebagai penerima, maka untuk mempertahankan konsistensi, metode yang tersisa harus menggunakan pointer / nilai.  Metode tipe seharusnya tidak memiliki hash nilai-dan pointer-penerima. </li></ul><br><h4>  Apa hasilnya </h4><br>  Dalam Nilai Go, semantik berarti menyalin nilai; semantik pointer berarti memberikan akses ke nilai.  Ini berlaku untuk argumen metode dan penerima.  Untuk tipe bawaan, seperti angka, garis, irisan, peta, saluran, dan struktur kecil, Anda hampir selalu perlu menggunakan transfer berbasis nilai.  Untuk struktur yang menempati banyak memori, dan struktur yang kondisinya dapat secara tidak langsung diubah dengan metode mereka, Anda harus menggunakan transfer dengan referensi.  Juga, semantik penerima mungkin bergantung pada domain yang jenisnya jelaskan, semantik yang dikembalikan di pabriknya, dan semantik penerima telah digunakan dalam metode lain dari jenis ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469859/">https://habr.com/ru/post/id469859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469837/index.html">Pertemuan Flutter pertama di St. Petersburg: laporan video</a></li>
<li><a href="../id469839/index.html">Kerentanan Spam Pikabu</a></li>
<li><a href="../id469843/index.html">"Di mana bajingan muda yang akan menghapus kita dari muka bumi?"</a></li>
<li><a href="../id469849/index.html">Gim â€œSerang 51%â€: menulis gim mandiri sederhana di platform Obyte</a></li>
<li><a href="../id469855/index.html">Gradle + LLVM</a></li>
<li><a href="../id469861/index.html">Struktur data untuk pemrogram game: data massal</a></li>
<li><a href="../id469869/index.html">Mengapa Anda harus overclock RAM (mudah!)</a></li>
<li><a href="../id469871/index.html">Ketika keyboard adalah tabel</a></li>
<li><a href="../id469875/index.html">Cara melindungi kata sandi Anda pada tahun 2019</a></li>
<li><a href="../id469877/index.html">Oh metode Newton ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>