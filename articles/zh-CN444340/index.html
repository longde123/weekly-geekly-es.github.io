<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 👩‍❤️‍👨 🕵🏿 在JavaScript中使用Symbol数据类型的功能 🍴 🍾 🏴󠁧󠁢󠁥󠁮󠁧󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="字符基元是ES6标准的创新之一，它为JavaScript带来了一些有价值的功能。 当用作对象属性的标识符时，由Symbol数据类型表示的符号特别有用。 结合其应用的这种情况，出现了一个问题，即它们可以做什么，哪些行不能做。 

  

 在我们今天发布的翻译材料中，我们将讨论JavaScript中的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在JavaScript中使用Symbol数据类型的功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444340/"> 字符基元是ES6标准的创新之一，它为JavaScript带来了一些有价值的功能。 当用作对象属性的标识符时，由Symbol数据类型表示的符号特别有用。 结合其应用的这种情况，出现了一个问题，即它们可以做什么，哪些行不能做。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br> 在我们今天发布的翻译材料中，我们将讨论JavaScript中的Symbol数据类型。 我们将首先回顾一些您需要导航以处理符号的JavaScript功能。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">初步资料</font> </h2><br> 实际上，在JavaScript中，有两种值。 第一种是原始值，第二种是对象（它们还包含函数）。 基本值包括简单的数据类型，例如数字（包括从整数到浮点数， <code>Infinity</code>和<code>NaN</code>值的所有内容），逻辑值，字符串， <code>undefined</code>和<code>null</code>值。 请注意，在检查<code>typeof null === 'object'</code>产生<code>true</code> ， <code>null</code>是原始值。 <br><br> 原始值是不可变的。 它们无法更改。 当然，您可以在存储原始值的变量中编写新内容。 例如，这将新值写入变量<code>x</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br> 但是同时，原始数值<code>1</code>没有变化（变异）。 <br><br> 在某些语言中，例如在C语言中，存在通过引用和值传递函数自变量的概念。  JavaScript也有类似的东西。 数据工作的确切组织方式取决于其类型。 如果将某个变量表示的原始值传递给该函数，然后在该函数中对其进行更改，则存储在原始变量中的值不会更改。 但是，如果将变量代表的对象值传递给函数并对其进行修改，则此变量中存储的内容也会更改。 <br><br> 考虑以下示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br> 原始值（神秘的<code>NaN</code>除外，它不等于自身）总是与其他看起来像它们自己的原始值相等。 例如： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br> 但是，从外部看相同的对象值的构造不会导致获得实体的事实，当比较时，将揭示它们之间的相等性。 您可以通过以下方式对此进行验证： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br> 对象在JavaScript中起着基本作用。 它们几乎在任何地方都可以使用。 例如，它们通常以键/值集合的形式使用。 但是在<code>Symbol</code>数据类型出现之前，只能将字符串用作对象键。 这是对使用集合形式的对象的严重限制。 尝试将非字符串值分配为对象键时，此值已强制转换为字符串。 您可以通过以下方式对此进行验证： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br> 顺便说一句，尽管这使我们与字符的主题有些距离，但我想指出，创建<code>Map</code>数据结构是为了在键不是字符串的情况下允许使用键/值数据存储。 <br><br><h2>  <font color="#3AC1EF">什么是符号？</font> </h2><br> 现在我们已经弄清了JavaScript中原始值的功能，我们终于可以开始讨论字符了。 符号是唯一的原始含义。 如果从该位置接近符号，则将注意到这方面的符号与对象相似，因为创建符号的多个实例将导致创建不同的值。 但是，符号是不可变的原始值。 这是使用字符的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br> 创建字符实例时，可以使用可选的第一个字符串参数。 此自变量是旨在用于调试的符号的描述。 该值不影响符号本身。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">符号作为对象属性的键</font> </h2><br> 符号可以用作对象的属性键。 这很重要。 这是这样使用它们的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br> 请注意， <code>Object.keys()</code>方法时，不会返回由字符指定的键。 在JS中出现字符之前编写的代码对它们一无所知，因此，古代的<code>Object.keys()</code>方法不应返回有关字符所表示对象的键的信息。 <br><br> 乍一看，似乎字符的上述功能使您可以使用它们来创建JS对象的私有属性。 在许多其他编程语言中，可以使用类创建隐藏的对象属性。 长期以来，缺少此功能一直被认为是JavaScript的缺点之一。 <br><br> 不幸的是，与对象一起使用的代码可以自由访问其字符串键。 此外，该代码还可以访问由字符指定的键，即使它们与对象一起使用的代码无法访问相应的字符。 例如，使用<code>Reflect.ownKeys()</code>方法，您可以获得对象的所有键的列表，这些键既是字符串，又是字符： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br> 请注意，目前正在努力使类具有使用私有属性的能力。 此功能称为“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">专用字段”</a> 。 的确，它并不会绝对影响所有对象，而只是引用基于先前准备的类创建的对象。  Chrome浏览器72版及更早版本已提供对私有字段的支持。 <br><br><h2>  <font color="#3AC1EF">防止对象属性名称冲突</font> </h2><br> 当然，符号不会为JavaScript添加创建对象私有属性的功能，但是由于其他原因，它们是该语言中的宝贵创新。 即，它们在某些库需要向在其外部描述的对象添加属性，同时又不怕对象的属性名称冲突的情况下很有用。 <br><br> 考虑一个示例，其中两个不同的库希望将元数据添加到对象。 两个库都可能需要为对象配备一些标识符。 如果仅使用诸如两个字母的<code>id</code>字符串之类的名称作为此类属性的名称，则可能会遇到一种情况，即一个库会覆盖另一个库所指定的属性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br> 如果在示例中使用符号，则每个库都可以在初始化时生成其所需的符号。 然后，可以使用这些符号将属性分配给对象并访问这些属性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br> 通过查看这种情况，您可以从JavaScript中的字符外观中受益。 <br><br> 但是，关于将库用于对象，随机字符串或具有复杂结构的字符串的属性的名称可能存在问题，例如包括库的名称。 类似的字符串可以形成类似于库使用的标识符的名称空间的名称。 例如，它可能看起来像这样： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br> 通常，您可以这样做。 实际上，类似的方法与使用符号时的情况非常相似。 而且，如果使用随机标识符或名称空间，几个库不会偶然生成相同的属性名称，那么这些名称就不会有问题。 <br><br> 精明的读者现在会说，正在考虑的两种命名对象属性的方法并不完全等效。 随机生成或使用命名空间生成的属性名称有一个缺点：对应的键很容易找到，尤其是当代码搜索对象的键或将其序列化时。 考虑以下示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br> 如果在这种情况下将符号用作键名，则对象的JSON表示将不包含符号值。 为什么会这样呢？ 事实是，JavaScript中出现了新的数据类型，并不意味着已经对JSON规范进行了更改。  JSON仅支持字符串作为属性键。 序列化对象时，不会尝试以任何特殊方式表示字符。 <br><br> 通过使用<code>Object.defineProperty()</code>可以解决在对象的JSON表示形式中获取属性名称的问题： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br> 通过将其<code>enumerable</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述符</a>设置为<code>false</code>来“隐藏”的字符串键的行为与字符表示的键几乎相同。 当调用<code>Object.keys()</code>时，它们都不显示，并且都可以使用<code>Reflect.ownKeys()</code>来检测。 看起来是这样的： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br> 我必须说，在这里，我们几乎使用JS的其他方式重新创建了符号的可能性。 特别是，用符号表示的密钥和专用密钥都不属于对象的JSON表示形式。 两者都可以通过引用<code>Reflect.ownKeys()</code>方法来识别。 结果，它们两个都不能真正称为私有。 如果我们假设使用一些随机值或库名称空间来生成键名，那么这意味着我们摆脱了名称冲突的风险。 <br><br> 但是，使用符号名称和使用其他机制创建的名称之间只有一个小差异。 由于字符串是不可变的，并且保证了字符的唯一性，因此始终存在这样的可能性，即某个人在经历了字符串中所有可能的字符组合之后，将导致名称冲突。 从数学的角度来看，这意味着字符确实为我们提供了字符串所没有的宝贵机会。 <br><br> 在Node.js中，当检查对象时（例如，使用<code>console.log()</code> ），如果检测到称为<code>inspect</code>的对象方法，则该方法用于获取对象的字符串表示形式，然后将其显示在屏幕上。 很容易理解，绝对每个人都不能考虑到这一点，因此系统的这种行为可以导致调用<code>inspect</code>对象方法，该方法旨在解决与对象的字符串表示形式无关的问题。  Node.js 10中不推荐使用此功能，在版本11中，具有相似名称的方法将被忽略。 现在，要实现此功能，提供了<code>require('util').inspect.custom</code> 。 这意味着，没有人能够通过创建一种称为<code>inspect</code>的对象方法来无意中破坏系统。 <br><br><h2>  <font color="#3AC1EF">仿制私人财产</font> </h2><br> 这是一种有趣的方法，可用于模拟对象的私有属性。 这种方法涉及使用另一个现代JavaScript功能-代理对象。 这样的对象充当其他对象的包装，使程序员可以干预使用这些对象执行的动作。 <br><br> 代理对象提供了许多方法来拦截对对象执行的操作。 我们对控制读取对象键操作的能力感兴趣。 在此我们将不详细介绍代理对象。 如果您有兴趣，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>出版物。 <br><br> 我们可以使用代理来控制对象的哪些属性从外部可见。 在这种情况下，我们要创建一个代理，以隐藏我们知道的两个属性。 一个具有字符串名称<code>_favColor</code> ，第二个由写入<code>favBook</code>变量的字符表示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br> 处理名称由字符串<code>_favColor</code>表示的属性并不困难：只需阅读源代码即可。 动态键（如我们在上面看到的uuid键）可以与蛮力匹配。 但是，如果不引用该符号，则无法从<code>proxy</code>对象访问<code>Metro 2033</code>的值。 <br><br> 应该注意的是，在Node.js中，有一项功能侵犯了代理对象的隐私。 语言本身不存在此功能，因此它与其他JS运行时（例如浏览器）无关。 事实是，如果您有权访问代理对象，则此功能允许您访问隐藏在代理对象后面的对象。 这是一个示例，该示例演示了绕过前面代码片段中所示机制的能力： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br> 现在，为了防止在Node.js的特定实例中使用此功能，您必须修改全局<code>Reflect</code>对象或<code>util</code>进程的绑定。 但是，这是另一项任务。 如果您有兴趣，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇</a>有关保护基于JavaScript的API的文章。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们讨论了<code>Symbol</code>数据类型，它为JavaScript开发人员提供了哪些功能，以及可以使用哪些现有语言机制来模拟这些功能。 <br><br>  <b>亲爱的读者们！</b> 您在JavaScript项目中使用符号吗？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444340/">https://habr.com/ru/post/zh-CN444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444328/index.html">重新设计UI通常是浪费时间</a></li>
<li><a href="../zh-CN444330/index.html">无服务器CMS最终成为Wordpress的重要竞争对手</a></li>
<li><a href="../zh-CN444332/index.html">信息安全和餐饮：经理如何看待IT产品</a></li>
<li><a href="../zh-CN444336/index.html">Swift捕获列表：弱链接，强链接和无主链接有什么区别？</a></li>
<li><a href="../zh-CN444338/index.html">Python 3中的封装</a></li>
<li><a href="../zh-CN444342/index.html">使用Webpack和高级Web技术开发简单，现代的JavaScript应用程序</a></li>
<li><a href="../zh-CN444344/index.html">成功的Python项目的10个步骤</a></li>
<li><a href="../zh-CN444346/index.html">GraphQL和Golang</a></li>
<li><a href="../zh-CN444348/index.html">功能性React组件与基于类的组件有何不同？</a></li>
<li><a href="../zh-CN444350/index.html">由于某些原因，MVP（最低可行产品）无法启动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>