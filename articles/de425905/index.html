<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíø üö• üïµüèº So schreiben Sie Assembler-Code mit √ºberlappenden Anweisungen (eine andere Technik zum Verschleiern von Bytecode) üë∏üèΩ ‚¨áÔ∏è üßëüèΩ‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir pr√§sentieren Ihnen die Technik zum Erstellen von Assembler-Programmen mit √ºberlappenden Anweisungen, um den kompilierten Bytecode vor dem Zerlegen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So schreiben Sie Assembler-Code mit √ºberlappenden Anweisungen (eine andere Technik zum Verschleiern von Bytecode)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425905/"><p>  Wir pr√§sentieren Ihnen die Technik zum Erstellen von Assembler-Programmen mit √ºberlappenden Anweisungen, um den kompilierten Bytecode vor dem Zerlegen zu sch√ºtzen.  Diese Technik kann sowohl statischen als auch dynamischen Bytecode-Analysen standhalten.  Die Idee besteht darin, einen Bytestrom auszuw√§hlen, der, wenn er aus zwei verschiedenen Offsets zerlegt wird, zu zwei verschiedenen Befehlsketten f√ºhrt, dh zu zwei verschiedenen Arten der Ausf√ºhrung des Programms.  Dazu nehmen wir Multibyte-Assembler-Anweisungen und verstecken den gesch√ºtzten Code in den variablen Teilen des Bytecodes dieser Anweisungen.  Um den Disassembler zu t√§uschen, indem man ihn auf eine falsche Spur bringt (gem√§√ü einer maskierenden Anweisungskette), und um eine verborgene Anweisungskette vor seinen Augen zu sch√ºtzen. </p><br><p><img src="https://habrastorage.org/webt/iu/f0/nj/iuf0njjfado7wk-bt05rlxz5l2w.png"></p><a name="habracut"></a><br><h2 id="tri-neobhodimyh-usloviya-dlya-sozdaniya-effektivnogo-perekrytiya">  Drei Voraussetzungen f√ºr eine effektive ‚Äû√úberlappung‚Äú </h2><br><p>  Um den Disassembler zu t√§uschen, muss der √ºberlappende Code die folgenden drei Bedingungen erf√ºllen: 1) Anweisungen von der Maskierungskette und der verborgenen Kette m√ºssen sich immer √ºberschneiden, d. H.  sollten nicht relativ zueinander ausgerichtet sein (ihr erstes und letztes Byte sollten nicht zusammenfallen).  Andernfalls ist ein Teil des versteckten Codes in der Maskierungskette sichtbar.  2) Beide Ketten sollten aus plausiblen Montageanleitungen bestehen.  Andernfalls wird die Maskierung bereits in der Phase der statischen Analyse erkannt (nachdem der Disassembler auf ungeeigneten Code f√ºr die Ausf√ºhrung gesto√üen ist, korrigiert er den Befehlszeiger und legt die Maskierung frei).  3) Alle Anweisungen beider Ketten sollten nicht nur plausibel sein, sondern auch korrekt ausgef√ºhrt werden (um dies zu verhindern, st√ºrzte das Programm ab, wenn Sie versuchen, sie auszuf√ºhren).  Andernfalls ziehen die Fehler w√§hrend der dynamischen Analyse die Aufmerksamkeit des Gegenteils auf sich und die Maske wird aufgedeckt. </p><br><h2 id="opisanie-tehniki-perekrytiya-assemblernyh-instrukciy">  Beschreibung der Technik der "√ºberlappenden" Assembler-Anweisungen </h2><br><p>  Um den Prozess der Erstellung √ºberlappenden Codes so flexibel wie m√∂glich zu gestalten, m√ºssen nur solche Multibyte-Anweisungen ausgew√§hlt werden, f√ºr die so viele Bytes wie m√∂glich einen beliebigen Wert annehmen k√∂nnen.  Diese Multibyte-Befehle bilden eine Maskierungsbefehlskette. </p><br><p>  Um das Ziel zu erreichen, √ºberlappenden Code zu erstellen, der die obigen drei Bedingungen erf√ºllt, betrachten wir jede Maskierungsanweisung als eine Folge von Bytes der Form: XX YY ZZ. </p><br><p>  Hier ist XX das Befehlspr√§fix (Befehlscode und andere statische Bytes - die nicht ge√§ndert werden k√∂nnen). </p><br><p>  YY sind Bytes, die beliebig ge√§ndert werden k√∂nnen (in der Regel speichern diese Bytes den direkten numerischen Wert, der an den Befehl √ºbergeben wird, oder die Adresse des im Speicher gespeicherten Operanden).  Es sollten so viele YY-Bytes wie m√∂glich vorhanden sein, damit mehr versteckte Anweisungen in sie passen. </p><br><p>  ZZ - Dies sind auch Bytes, die beliebig ge√§ndert werden k√∂nnen. Der einzige Unterschied besteht darin, dass die Kombination von ZZ-Bytes mit den nachfolgenden Bytes XX (ZZ XX) eine g√ºltige Anweisung bilden sollte, die die drei am Anfang des Artikels formulierten Bedingungen erf√ºllt.  Im Idealfall sollte ZZ nur ein Byte belegen, damit auf YY (dies ist im Wesentlichen der wichtigste Teil - unser versteckter Code wird hier platziert) so viele Bytes wie m√∂glich vorhanden sein sollten.  Die letzte versteckte Anweisung sollte in ZZ enden - und einen Konvergenzpunkt f√ºr die beiden Ausf√ºhrungsketten erstellen. </p><br><h2 id="skleivayuschie-instrukcii">  Anleitung zum Kleben </h2><br><p>  Die Kombination ZZ XX - wir nennen die Klebeanweisung.  Eine Klebeanweisung wird zum einen ben√∂tigt, um versteckte Anweisungen zu verbinden, die sich in benachbarten Maskierungsanweisungen befinden, und zum anderen, um die erste notwendige Bedingung zu erf√ºllen, die am Anfang des Artikels angegeben ist: Die Anweisungen beider Ketten sollten sich immer √ºberschneiden (daher die Klebeanweisung immer befindet sich am Schnittpunkt zweier Maskierungsanweisungen). </p><br><p>  Der Klebebefehl wird in einer verborgenen Befehlskette ausgef√ºhrt und muss daher so ausgew√§hlt werden, dass dem verborgenen Code so wenig Einschr√§nkungen wie m√∂glich auferlegt werden.  Angenommen, wenn es ausgef√ºhrt wird, werden die Allzweckregister und das EFLAGS-Register ge√§ndert, dann kann der verborgene Code die entsprechenden Register und bedingten Befehle nicht effektiv verwenden (wenn dem Klebebefehl beispielsweise der Vergleichsoperator vorausgeht und der Klebebefehl selbst den Wert des EFLAGS-Registers √§ndert, dann der bedingte √úbergang). was nach der Klebeanweisung steht, funktioniert nicht richtig). </p><br><p>  Die obige Beschreibung der √úberlappungstechnik ist in der folgenden Abbildung dargestellt.  Beginnt die Ausf√ºhrung mit den Startbytes (XX), wird eine Maskierungsbefehlskette aktiviert.  Und wenn von Bytes YY, wird eine versteckte Befehlskette aktiviert. </p><br><p><img src="https://habrastorage.org/webt/a8/yq/f-/a8yqf-uukfw3fgzvlkqmmjjxiao.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-maskiruyuschih-instrukciy">  Assembler-Anweisungen, die f√ºr die Rolle der "Maskierungsanweisungen" geeignet sind </h2><br><p>  Die l√§ngste der Anweisungen, die auf den ersten Blick am besten zu uns passt, ist eine 10-Byte-Version von MOV, bei der der durch das Register und die 32-Bit-Adresse angegebene Offset als erster Operand und die 32-Bit-Nummer als zweiter Operand √ºbertragen werden.  Diese Anweisung enth√§lt die meisten Bytes, die beliebig ge√§ndert werden k√∂nnen (bis zu 8 Teile). </p><br><p><img src="https://habrastorage.org/webt/0k/8b/ph/0k8bphb01jec2f1t7dy1bupi_c0.png"></p><br><p>  Obwohl dieser Befehl plausibel erscheint (theoretisch kann er korrekt ausgef√ºhrt werden), passt er immer noch nicht zu uns, da sein erster Operand in der Regel eine unzug√§ngliche Adresse angibt und daher beim Versuch, einen solchen MOV auszuf√ºhren, das Programm wird zusammenbrechen.  T.O.  Diese 10-Byte-MOV erf√ºllt nicht die dritte notwendige Bedingung: Alle Anweisungen beider Ketten m√ºssen korrekt ausgef√ºhrt werden. </p><br><p>  Daher werden wir f√ºr die Rolle der Maskierungsanweisungen nur diejenigen Bewerber ausw√§hlen, bei denen kein Risiko eines Zusammenbruchs des Programms besteht.  Diese Bedingung schr√§nkt den Bereich von Anweisungen, die zum Erstellen von √ºberlappendem Code geeignet sind, erheblich ein, es gibt jedoch noch geeignete Anweisungen.  Unten sind vier davon.  Jeder dieser vier Befehle enth√§lt f√ºnf Bytes, die beliebig ge√§ndert werden k√∂nnen, ohne dass das Risiko eines Programmabsturzes besteht. </p><br><ul><li>  <strong>LEA.</strong>  Dieser Befehl berechnet die durch den Ausdruck im zweiten Operanden angegebene Speicheradresse und speichert das Ergebnis im ersten Operanden.  Da wir auf den Speicher verweisen k√∂nnen, ohne tats√§chlich darauf zuzugreifen (und dementsprechend ohne das Risiko eines Programmabsturzes), k√∂nnen die letzten f√ºnf Bytes dieser Anweisung beliebige Werte annehmen. </li></ul><br><p><img src="https://habrastorage.org/webt/nt/j4/qt/ntj4qtax25h_ztuizjq-aokjpbu.png"></p><br><ul><li>  <strong>CMOVcc.</strong>  Dieser Befehl f√ºhrt die MOV-Operation aus, wenn die Bedingung "cc" erf√ºllt ist.  Damit diese Anweisung die dritte Anforderung erf√ºllt, muss die Bedingung so ausgew√§hlt werden, dass sie unter allen Umst√§nden den Wert FALSE hat.  Andernfalls versucht diese Anweisung m√∂glicherweise, auf eine unzug√§ngliche Speicheradresse usw. zuzugreifen.  Programm herunterfahren. </li></ul><br><p><img src="https://habrastorage.org/webt/np/me/fn/npmefnc43igcj9aqvw9omgyofae.png"></p><br><ul><li>  <strong>SETcc</strong>  Es funktioniert nach dem gleichen Prinzip wie CMOVcc: setzt das Byte auf eins, wenn die Bedingung "cc" erf√ºllt ist.  Diese Anweisung hat das gleiche Problem wie CMOVcc: Der Zugriff auf eine ung√ºltige Adresse f√ºhrt zum Absturz des Programms.  Daher muss die Wahl des "cc" -Zustands sehr sorgf√§ltig angegangen werden. </li></ul><br><p><img src="https://habrastorage.org/webt/sn/yc/xt/snycxte6lqjzorjwdqcvsppfdri.png"></p><br><ul><li>  <strong>NOP.</strong>  NOPs k√∂nnen unterschiedlich lang sein (von 2 bis 15 Byte), je nachdem, welche Operanden in ihnen angegeben sind.  In diesem Fall besteht kein Risiko eines Absturzes des Programms (aufgrund des Zugriffs auf eine ung√ºltige Speicheradresse).  Weil NOPs nur den Befehlsz√§hler erh√∂hen (sie f√ºhren keine Operationen an Operanden aus).  Daher k√∂nnen die NOP-Bytes, in denen die Operanden angegeben sind, einen beliebigen Wert annehmen.  F√ºr unsere Zwecke ist ein 9-Byte-NOP am besten geeignet. </li></ul><br><p><img src="https://habrastorage.org/webt/_i/sh/8k/_ish8ks2qosezlkfzpgzx43jk2k.png"></p><br><p>  Als Referenz finden Sie hier einige andere NOP-Optionen. </p><br><p><img src="https://habrastorage.org/webt/0k/iq/n7/0kiqn7dtu1yzrrmawbtw8yfwep0.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-skleivayuschih-instrukciy">  Assembler-Anweisungen, die f√ºr die Rolle der ‚ÄûKlebe-Anweisungen‚Äú geeignet sind </h2><br><p>  Die Liste der Anweisungen, die f√ºr die Rolle einer Klebeanweisung geeignet sind, ist f√ºr jede spezifische Maskierungsanweisung eindeutig.  Unten finden Sie eine Liste (generiert mit dem in der folgenden Abbildung gezeigten Algorithmus) am Beispiel des 9-Byte-NOP. </p><br><p><img src="https://habrastorage.org/webt/zh/9o/ja/zh9ojaw9sezcyr9milmugd3pihm.png"></p><br><p>  Bei der Erstellung dieser Liste haben wir nur die Optionen ber√ºcksichtigt, bei denen ZZ 1 Byte ben√∂tigt (andernfalls bleibt nur wenig Platz f√ºr versteckten Code).  Hier ist eine Liste geeigneter Haftanweisungen f√ºr ein 9-Byte-NOP. </p><br><p><img src="https://habrastorage.org/webt/wm/kv/uj/wmkvujcabiyqgy-ysdg1750mp7k.png"></p><br><p>  Unter dieser Liste von Anweisungen gibt es keine, die frei von Nebenwirkungen w√§re.  Jeder von ihnen √§ndert entweder EFLAGS oder Allzweckregister oder beides gleichzeitig.  Diese Liste ist in 4 Kategorien unterteilt, je nachdem, welche Nebenwirkung die Anweisung hat. </p><br><p>  <strong>Die erste Kategorie</strong> enth√§lt Anweisungen, die das EFLAGS-Register √§ndern, jedoch keine Allzweckregister.  Anweisungen aus dieser Kategorie k√∂nnen verwendet werden, wenn keine bedingten Spr√ºnge oder Anweisungen in der Kette versteckter Anweisungen vorhanden sind, die auf der Auswertung von Informationen aus dem EFLAGS-Register basieren.  In diesem Fall gibt es in diesem Fall (f√ºr einen 9-Byte-NOP) nur zwei Anweisungen: TEST und CMP. </p><br><p><img src="https://habrastorage.org/webt/vx/6k/nz/vx6knzdkeafykou6rrga4kjtjrc.png"></p><br><p>  Das Folgende ist ein einfaches Beispiel f√ºr versteckten Code, der TEST als Klebeanweisung verwendet.  In diesem Beispiel wird ein Systemaufruf beendet, der f√ºr jede Linux-Version den Wert 1 zur√ºckgibt. Um die TEST-Anweisung f√ºr unsere Anforderungen korrekt zu bilden, m√ºssen wir das letzte Byte des ersten NOP auf 0xA9 setzen.  Dieses Byte wird in Verbindung mit den ersten vier Bytes des n√§chsten NOP (66 0F 1F 84) zu einem TEST EAX-Befehl 0x841F0F66.  Die folgenden beiden Abbildungen zeigen den entsprechenden Assembler-Code (zum Maskieren der Kette und der versteckten Kette).  Die versteckte Kette wird aktiviert, wenn die Steuerung auf das 4. Byte des ersten NOP √ºbertragen wird. </p><br><p><img src="https://habrastorage.org/webt/sv/ok/v9/svokv9pvujkp3sz1mzgcpfumlx4.png"></p><br><p><img src="https://habrastorage.org/webt/ky/bd/-b/kybd-bm02hdj6lka_rnkemfrnj8.png"></p><br><p>  <strong>Die zweite Kategorie</strong> enth√§lt Anweisungen, die die Werte allgemeiner Register oder des verf√ºgbaren Speichers (z. B. Stapel) √§ndern, das EFLAGS-Register jedoch nicht √§ndern.  Bei der Ausf√ºhrung eines PUSH-Befehls oder einer MOV-Variante, bei der als zweiter Operand ein Sofortwert angegeben wird, bleibt das EFLAGS-Register unver√§ndert.  T.O.  Klebebefehle der zweiten Kategorie k√∂nnen sogar zwischen dem Vergleichsbefehl (z. B. TEST) und dem Befehl, der das EFLAGS-Register auswertet, platziert werden.  Anweisungen in dieser Kategorie beschr√§nken jedoch die Verwendung des Registers, das in den entsprechenden Klebeanweisungen enthalten ist.  Wenn beispielsweise MOV EBP, 0x841F0F66 als Klebebefehl verwendet wird, sind die M√∂glichkeiten zur Verwendung des EBP-Registers (aus dem Rest des verborgenen Codes) erheblich eingeschr√§nkt. </p><br><p>  <strong>Die dritte Kategorie</strong> enth√§lt Anweisungen, die das EFLAGS-Register √§ndern, und die Allzweckregister (oder den Speicher) √§ndern sich.  Diese Anweisungen haben keine offensichtlichen Vorteile gegen√ºber Anweisungen aus den ersten beiden Kategorien.  Sie k√∂nnen jedoch auch verwendet werden, da sie den drei am Anfang des Artikels formulierten Bedingungen nicht widersprechen.  Die vierte Kategorie enth√§lt Anweisungen, f√ºr deren Implementierung nicht garantiert werden kann, dass das Programm nicht abst√ºrzt. Es besteht die Gefahr eines illegalen Zugriffs auf den Speicher.  Es ist √§u√üerst unerw√ºnscht, sie zu verwenden, weil  Sie erf√ºllen nicht die dritte Bedingung. </p><br><h2 id="assemblernye-instrukcii-kotorye-mozhno-ispolzovat-v-skrytoy-cepochke">  Assembler-Anweisungen, die in einer versteckten Kette verwendet werden k√∂nnen </h2><br><p>  In unserem Fall (wenn 9-Byte-NOPs als Maskierungsanweisungen verwendet werden) sollte die L√§nge jeder Anweisung aus der verborgenen Kette vier Bytes nicht √ºberschreiten (diese Einschr√§nkung gilt nicht f√ºr Sticky-Anweisungen, die 5 Bytes belegen).  Dies ist jedoch keine sehr kritische Einschr√§nkung, da die meisten Befehle, die l√§nger als vier Bytes sind, in mehrere k√ºrzere Befehle zerlegt werden k√∂nnen.  Das folgende Beispiel zeigt einen 5-Byte-MOV, der zu gro√ü ist, um in eine versteckte Kette zu passen. </p><br><p><img src="https://habrastorage.org/webt/oo/97/yx/oo97yx0fsovio-agsdn-spiejre.png"></p><br><p>  Diese F√ºnf-Byte-MOV kann jedoch in drei Befehle zerlegt werden, deren L√§nge vier Bytes nicht √ºberschreitet. </p><br><p><img src="https://habrastorage.org/webt/yx/zd/oc/yxzdocctpxhzvy13td7fpkqnwi0.png"></p><br><h2 id="usilenie-maskirovki-putyom-rasseivaniya-maskiruyuschih-nopov-po-vsey-programme">  Verbessern der Maskierung durch Verteilen von Maskierungs-NOPs im gesamten Programm </h2><br><p>  Eine gro√üe Anzahl aufeinanderfolgender NOPs erscheint aus umgekehrter Sicht sehr verd√§chtig.  Ein erfahrener Umkehrer, der sein Interesse auf diese verd√§chtigen NOPs konzentriert, kann dem darin verborgenen Code auf den Grund gehen.  Um diese Exposition zu vermeiden, k√∂nnen maskierte NOPs im gesamten Programm verteilt werden. </p><br><p>  Die korrekte Ausf√ºhrungskette des versteckten Codes kann in diesem Fall durch Doppelbyte-Anweisungen f√ºr einen bedingungslosen Sprung unterst√ºtzt werden.  In diesem Fall belegen die letzten zwei Bytes jedes NOP einen 2-Byte-JMP. </p><br><p>  Mit diesem Trick k√∂nnen Sie eine lange Folge von NOPs in mehrere kurze aufteilen (oder sogar jeweils einen NOP verwenden).  Im letzten NOP einer solch kurzen Sequenz k√∂nnen nur 3 Bytes der Nutzlast zugewiesen werden (das 4. Byte wird von der bedingungslosen Sprunganweisung √ºbernommen).  T.O.  Hier gibt es eine zus√§tzliche Einschr√§nkung f√ºr die Gr√∂√üe g√ºltiger Anweisungen.  Wie oben erw√§hnt, k√∂nnen lange Anweisungen jedoch in einer Kette k√ºrzerer Anweisungen angeordnet werden.  Unten finden Sie ein Beispiel f√ºr denselben 5-Byte-MOV, den wir bereits so ausgelegt haben, dass er in die 4-Byte-Grenze passt.  Jetzt zerlegen wir diesen MOV jedoch so, dass er in die 3-Byte-Grenze passt. </p><br><p><img src="https://habrastorage.org/webt/lr/6g/bz/lr6gbzoo5qnjgocu3zzkoblxqsc.png"></p><br><p>  Nachdem wir alle langen Anweisungen nach demselben Prinzip in k√ºrzere zerlegt haben, k√∂nnen wir, um mehr zu maskieren, im Allgemeinen nur einzelne NOPs verwenden, die √ºber das Programm verteilt sind.  Zwei-Byte-JMP-Befehle k√∂nnen um 127 Bytes vorw√§rts und r√ºckw√§rts springen, was bedeutet, dass zwei aufeinanderfolgende NOPs (aufeinanderfolgend in Bezug auf eine Kette versteckter Befehle) innerhalb von 127 Bytes liegen m√ºssen. </p><br><p>  Dieser Trick hat einen weiteren signifikanten Vorteil (zus√§tzlich zur verbesserten Maskierung): Mit ihm k√∂nnen Sie versteckten Code in die vorhandenen NOPs der kompilierten Bin√§rdatei einf√ºgen (d. H. Nach dem Kompilieren eine Nutzlast in die Bin√§rdatei einf√ºgen).  In diesem Fall ist es nicht erforderlich, dass diese verwaisten NOPs 9 Byte gro√ü sind.  Wenn beispielsweise mehrere Einzelbyte-NOPs in einer Reihe in der Bin√§rdatei vorhanden sind, k√∂nnen sie in Mehrbyte-NOPs konvertiert werden, ohne die Funktionalit√§t des Programms zu beeintr√§chtigen.  Nachfolgend finden Sie ein Beispiel f√ºr eine Technik zum Verteilen von NOPs (dieser Code entspricht funktional dem oben diskutierten Beispiel). </p><br><p><img src="https://habrastorage.org/webt/t6/cj/fn/t6cjfn6ctjsqubp6setuf324nui.png"></p><br><p>  Ein solcher versteckter Code, der in NOP versteckt ist und √ºber das Programm verteilt ist, ist bereits viel schwieriger zu erkennen. </p><br><p>  Ein aufmerksamer Leser muss bemerkt haben, dass der erste NOP kein letztes Byte hat.  Es gibt jedoch keinen Grund zur Sorge.  Weil diesem nicht beanspruchten Byte ein bedingungsloser Sprung vorausgeht.  T.O.  Die Kontrolle wird niemals auf ihn √ºbertragen.  Also ist alles in Ordnung. </p><br><p>  Hier ist eine Technik zum Erstellen von √ºberlappendem Code.  Verwendung f√ºr die Gesundheit.  Verstecken Sie Ihren wertvollen Code vor neugierigen Blicken.  Aber nehmen Sie einfach eine andere Anweisung an, keine 9-Byte-NOP.  Weil die Umkehrer wahrscheinlich auch diesen Artikel lesen werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425905/">https://habr.com/ru/post/de425905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425893/index.html">‚ÄûFlutter spricht die Community an, aber noch nicht die Kunden‚Äú: Interview mit Paulina Szklarska</a></li>
<li><a href="../de425897/index.html">Funktionen zur Verwendung der RxJs-Bibliothek in einem Online-Banking-System</a></li>
<li><a href="../de425899/index.html">Ameisenh√ºgel oder Festung? Ich baue ein Haus zum Preis einer Wohnung. 1 Teil</a></li>
<li><a href="../de425901/index.html">Wetterstation auf Arduino von A bis Z. Teil 1</a></li>
<li><a href="../de425903/index.html">Urlaub kommt zu uns: SCRF hat das ISM-Band von 868 MHz verdoppelt</a></li>
<li><a href="../de425907/index.html">Wir machen ein maschinelles Lernprojekt in Python. Teil 2</a></li>
<li><a href="../de425911/index.html">√úbertragen Sie Cloud CRM in die Box-Version</a></li>
<li><a href="../de425915/index.html">Wie grenz√ºberschreitende Kommunikation Ampeln ersetzen und den Weg zur Arbeit verk√ºrzen kann</a></li>
<li><a href="../de425917/index.html">Der Justizk√§mpfer verhindert, dass Waymo die Schl√ºssel-Lidar-Technologie patentiert</a></li>
<li><a href="../de425919/index.html">Hexagon-Karten in Unity: Speichern und Laden, Texturen, Entfernungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>