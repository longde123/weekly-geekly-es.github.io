<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòä üíÜüèΩ üë®üèø‚Äç‚öñÔ∏è D√©veloppement de syst√®me d'exploitation de type Unix - Pilotes de p√©riph√©riques de caract√®res (8) üèá üòæ ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l'article pr√©c√©dent, nous avons introduit le multit√¢che. Aujourd'hui, il est temps d'examiner le sujet des pilotes de p√©riph√©riques de caract√®res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement de syst√®me d'exploitation de type Unix - Pilotes de p√©riph√©riques de caract√®res (8)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468509/">  Dans l'article pr√©c√©dent, nous avons introduit le multit√¢che.  Aujourd'hui, il est temps d'examiner le sujet des pilotes de p√©riph√©riques de caract√®res. <br><br>  Plus pr√©cis√©ment, nous allons aujourd'hui √©crire un pilote de terminal, un m√©canisme de traitement diff√©r√© des interruptions, et examiner le sujet des gestionnaires pour les moiti√©s sup√©rieure et inf√©rieure des interruptions. <br><br>  Nous commen√ßons par cr√©er une structure de p√©riph√©rique, puis introduisons le support d'E / S de fichier de base, consid√©rons la structure et les fonctions io_buf pour travailler avec des fichiers de stdio.h. <br><a name="habracut"></a><br><h4>  Table des mati√®res </h4><br>  Construisez le syst√®me (make, gcc, gas).  D√©marrage initial (multiboot).  Lancez (qemu).  Biblioth√®que C (strcpy, memcpy, strext).  Biblioth√®que C (sprintf, strcpy, strcmp, strtok, va_list ...).  Construction de la biblioth√®que en mode noyau et en mode application utilisateur.  Le journal syst√®me du noyau.  M√©moire vid√©o  Sortie vers le terminal (kprintf, kpanic, kassert).  M√©moire dynamique, tas (kmalloc, kfree).  Organisation de la m√©moire et gestion des interruptions (GDT, IDT, PIC, syscall).  Exceptions  M√©moire virtuelle (r√©pertoire de pages et table de pages).  Processus.  Planificateur  Multit√¢che.  Appels syst√®me (kill, exit, ps). <br><br>  <b>Pilotes de p√©riph√©riques de caract√®res.</b>  <b>Appels syst√®me (ioctl, fopen, fread, fwrite).</b>  <b>Biblioth√®que C (fopen, fclose, fprintf, fscanf).</b> <br><br>  Le syst√®me de fichiers du noyau (initrd), elf et ses composants internes.  Appels syst√®me (exec).  Shell comme programme complet pour le noyau.  Mode de protection utilisateur (ring3).  Segment d'√©tat de la t√¢che (tss). <br><br><h4>  Pilotes de personnage </h4><br>  Tout commence par l'apparition d'un dispositif symbolique.  Comme vous vous en souvenez, dans les pilotes de p√©riph√©riques Linux, la d√©finition du p√©riph√©rique ressemblait √† ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_cdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev_alloc</span></span></span><span class="hljs-class">( );</span></span> my_cdev-&gt;ops = &amp;my_fops;</code> </pre> <br>  L'essentiel est d'attribuer √† l'appareil la mise en ≈ìuvre des fonctions d'E / S de fichiers. <br><br>  Nous nous en sortirons avec une seule structure, mais la signification sera similaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* device name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* base_r; <span class="hljs-comment"><span class="hljs-comment">/* base read address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* base_w; <span class="hljs-comment"><span class="hljs-comment">/* base write address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_read_cb_t</span></span> read_cb; <span class="hljs-comment"><span class="hljs-comment">/* read handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_write_cb_t</span></span> write_cb; <span class="hljs-comment"><span class="hljs-comment">/* write handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_ioctl_cb_t</span></span> ioctl_cb; <span class="hljs-comment"><span class="hljs-comment">/* device specific command handler */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* low half interrupt handlers */</span></span> };</code> </pre><br>  Chaque p√©riph√©rique correspond √† la moiti√© de la liste des interruptions appel√©es lors de la g√©n√©ration des interruptions. <br><br>  Sous Linux, ces moiti√©s sont appel√©es sup√©rieures, au contraire inf√©rieures (niveau inf√©rieur). <br><br>  Personnellement, cela me semblait plus logique et je me suis souvenu accidentellement des termes dans l'autre sens.  Nous d√©crivons chaque √©l√©ment de la liste des moiti√©s inf√©rieures d'interruptions comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number; <span class="hljs-comment"><span class="hljs-comment">/* interrupt number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ih_low_cb_t</span></span> handler; <span class="hljs-comment"><span class="hljs-comment">/* interrupt handler */</span></span> };</code> </pre><br>  Lors de l'initialisation, le pilote enregistrera son p√©riph√©rique via la fonction dev_register, en d'autres termes, ajoutera un nouveau p√©riph√©rique √† la liste de sonnerie: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dev_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* create list entry */</span></span> entry = clist_insert_entry_after(&amp;dev_list, dev_list.head); device = (struct <span class="hljs-keyword"><span class="hljs-keyword">dev_t</span></span>*)entry-&gt;data; <span class="hljs-comment"><span class="hljs-comment">/* fill data */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(device-&gt;name, dev-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dev-&gt;name)); device-&gt;base_r = dev-&gt;base_r; device-&gt;base_w = dev-&gt;base_w; device-&gt;read_cb = dev-&gt;read_cb; device-&gt;write_cb = dev-&gt;write_cb; device-&gt;ioctl_cb = dev-&gt;ioctl_cb; device-&gt;ih_list.head = dev-&gt;ih_list.head; device-&gt;ih_list.slot_size = dev-&gt;ih_list.slot_size; }</code> </pre><br>  Pour que tout cela fonctionne, nous avons besoin du rudiment du syst√®me de fichiers.  Au d√©but, nous n'aurons que des fichiers pour les appareils de caract√®res. <br><br>  C'est-√†-dire  l'ouverture du fichier √©quivaudra √† la cr√©ation d'une structure FILE √† partir de stdio pour le fichier de pilote correspondant. <br><br>  Dans ce cas, les noms de fichiers correspondront au nom du p√©riph√©rique.  Nous d√©finissons le concept d'un descripteur de fichier dans notre biblioth√®que C (stdio.h). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-comment"><span class="hljs-comment">/* file descriptor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* base; <span class="hljs-comment"><span class="hljs-comment">/* buffer beginning */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr; <span class="hljs-comment"><span class="hljs-comment">/* position in buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_eof; <span class="hljs-comment"><span class="hljs-comment">/* whether end of file */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* file; <span class="hljs-comment"><span class="hljs-comment">/* file definition */</span></span> }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FILE struct io_buf_t</span></span></code> </pre><br>  Pour plus de simplicit√©, laissez tous les fichiers ouverts √™tre stock√©s dans une liste en anneau pour l'instant.  L'√©l√©ment de liste est d√©crit comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* file handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* file name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mod_rw; <span class="hljs-comment"><span class="hljs-comment">/* whether read or write */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* whether device driver */</span></span> };</code> </pre><br>  Pour chaque fichier ouvert, nous enregistrerons un lien vers l'appareil.  Nous impl√©mentons une liste en anneau de fichiers ouverts et impl√©mentons les appels syst√®me en lecture / √©criture / ioctl. <br><br>  Lors de l'ouverture d'un fichier, il nous suffit d'affecter les positions initiales des tampons de lecture et d'√©criture du pilote √† la structure io_buf_t et, en cons√©quence, d'associer les op√©rations sur les fichiers au pilote de p√©riph√©rique. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> struct io_buf_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mod_rw)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* try to find already opened file */</span></span> entry = clist_find(&amp;file_list, file_list_by_name_detector, path, mod_rw); file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)entry-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;file-&gt;io_buf; } <span class="hljs-comment"><span class="hljs-comment">/* create list entry */</span></span> entry = clist_insert_entry_after(&amp;file_list, file_list.head); file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)entry-&gt;data; <span class="hljs-comment"><span class="hljs-comment">/* whether file is device */</span></span> dev = dev_find_by_name(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev != null) { <span class="hljs-comment"><span class="hljs-comment">/* device */</span></span> file-&gt;dev = dev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod_rw == MOD_R) { file-&gt;io_buf.base = dev-&gt;base_r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod_rw == MOD_W) { file-&gt;io_buf.base = dev-&gt;base_w; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* fs node */</span></span> file-&gt;dev = null; unreachable(); <span class="hljs-comment"><span class="hljs-comment">/* fs in not implemented yet */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* fill data */</span></span> file-&gt;mod_rw = mod_rw; file-&gt;io_buf.fd = next_fd++; file-&gt;io_buf.ptr = file-&gt;io_buf.base; file-&gt;io_buf.is_eof = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; file-&gt;io_buf.file = file; <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(file-&gt;name, path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(file-&gt;name)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;file-&gt;io_buf; }</code> </pre><br>  Les op√©rations sur les fichiers en lecture / √©criture / ioctl sont d√©finies par un mod√®le utilisant l'exemple d'appel de syst√®me de lecture. <br><br>  Les appels syst√®me que nous avons appris √† √©crire dans la derni√®re le√ßon appellent simplement ces fonctions. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">;</span></span> file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)io_buf-&gt;file; <span class="hljs-comment"><span class="hljs-comment">/* whether file is device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file-&gt;dev != null) { <span class="hljs-comment"><span class="hljs-comment">/* device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file-&gt;dev-&gt;read_cb(&amp;file-&gt;io_buf, buff, size); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* fs node */</span></span> unreachable(); <span class="hljs-comment"><span class="hljs-comment">/* fs in not implemented yet */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  En bref, ils tireront simplement les rappels de la d√©finition de l'appareil.  Nous allons maintenant √©crire le pilote de terminal. <br><br><h4>  Pilote de terminal </h4><br>  Nous avons besoin d'un tampon de sortie d'√©cran et d'un tampon d'entr√©e de clavier, ainsi que de deux drapeaux pour les modes d'entr√©e et de sortie. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_dev_name = TTY_DEV_NAME; <span class="hljs-comment"><span class="hljs-comment">/* teletype device name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tty_output_buff[VIDEO_SCREEN_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* teletype output buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tty_input_buff[VIDEO_SCREEN_WIDTH]; <span class="hljs-comment"><span class="hljs-comment">/* teletype input buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_output_buff_ptr = tty_output_buff; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_input_buff_ptr = tty_input_buff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> read_line_mode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether read only whole line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_echo = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether to put readed symbol to stdout */</span></span></code> </pre><br>  Nous √©crivons la fonction de cr√©ation d'un appareil.  Il supprime simplement les rappels des op√©rations sur les fichiers et les gestionnaires des moiti√©s inf√©rieures d'interruptions, apr√®s quoi il enregistre le p√©riph√©rique dans une liste de sonnerie. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tty_output_buff, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(VIDEO_SCREEN_SIZE)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tty_input_buff, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(VIDEO_SCREEN_WIDTH)); <span class="hljs-comment"><span class="hljs-comment">/* register teletype device */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(dev.name, tty_dev_name); dev.base_r = tty_input_buff; dev.base_w = tty_output_buff; dev.read_cb = tty_read; dev.write_cb = tty_write; dev.ioctl_cb = tty_ioctl; dev.ih_list.head = null; <span class="hljs-comment"><span class="hljs-comment">/* add interrupt handlers */</span></span> dev.ih_list.slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">ih_low_t</span></span>); entry = clist_insert_entry_after(&amp;dev.ih_list, dev.ih_list.head); ih_low = (struct <span class="hljs-keyword"><span class="hljs-keyword">ih_low_t</span></span>*)entry-&gt;data; ih_low-&gt;number = INT_KEYBOARD; ih_low-&gt;handler = tty_keyboard_ih_low; dev_register(&amp;dev); }</code> </pre><br>  Le gestionnaire d'interruption inf√©rieur pour le clavier est d√©fini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Key press low half handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_keyboard_ih_low</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ih_low_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* write character to input buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* keycode = data-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = *keycode; assert(index &lt; <span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = keyboard_map[index]; *tty_input_buff_ptr++ = ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_echo &amp;&amp; ch != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* echo character to screen */</span></span> *tty_output_buff_ptr++ = ch; } <span class="hljs-comment"><span class="hljs-comment">/* register deffered execution */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">;</span></span> msg.type = IPC_MSG_TYPE_DQ_SCHED; msg.len = <span class="hljs-number"><span class="hljs-number">4</span></span>; *((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)msg.data) = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_keyboard_ih_high; ksend(TID_DQ, &amp;msg); }</code> </pre><br>  Ici, nous mettons simplement le caract√®re entr√© dans le tampon du clavier.  √Ä la fin, nous enregistrons l'appel diff√©r√© du processeur des moiti√©s sup√©rieures des interruptions du clavier.  Cela se fait en envoyant un message (IPC) au thread du noyau. <br><br>  Le thread du noyau lui-m√™me est assez simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Deferred queue execution scheduler * This task running in kernel mode */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dq_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { kreceive(TID_DQ, &amp;msg); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (msg.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IPC_MSG_TYPE_DQ_SCHED: <span class="hljs-comment"><span class="hljs-comment">/* do deffered callback execution */</span></span> assert(msg.len == <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dq_handler_t</span></span> handler = (<span class="hljs-keyword"><span class="hljs-keyword">dq_handler_t</span></span>)*((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*)msg.data); assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)handler &lt; KERNEL_CODE_END_ADDR); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_DQ_SCHED, handler); handler(msg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  En l'utilisant, le gestionnaire des moiti√©s sup√©rieures de l'interruption du clavier sera appel√©.  Son but est de dupliquer un caract√®re √† l'√©cran en copiant le tampon de sortie dans la m√©moire vid√©o. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Key press high half handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_keyboard_ih_high</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ video_flush(tty_output_buff); }</code> </pre><br>  Il reste maintenant √† √©crire les fonctions d'E / S elles-m√™mes, appel√©es √† partir d'op√©rations sur les fichiers. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Read line from tty to string */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u_int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buffer, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = buffer; assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr); assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff); assert(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); io_buf-&gt;is_eof = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr == (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_line_mode) { io_buf-&gt;is_eof = !<span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(io_buf-&gt;ptr, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !io_buf-&gt;is_eof; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = tty_read_ch(io_buf); *ptr++ = ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_line_mode &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)buffer; } <span class="hljs-comment"><span class="hljs-comment">/* * Write to tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size &amp;&amp; !io_buf-&gt;is_eof; ++i) { tty_write_ch(io_buf, *ptr++); } }</code> </pre><br>  Les op√©rations caract√®re par caract√®re ne sont pas beaucoup plus compliqu√©es et je ne pense pas qu'elles aient besoin de commentaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Write single character to tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_write_ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff_ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; VIDEO_SCREEN_SIZE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* regular character */</span></span> *tty_output_buff_ptr++ = ch; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* new line character */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line_pos = ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff_ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff) % VIDEO_SCREEN_WIDTH; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; VIDEO_SCREEN_WIDTH - line_pos; ++j) { *tty_output_buff_ptr++ = <span class="hljs-string"><span class="hljs-string">' '</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tty_output_buff_ptr = video_scroll(tty_output_buff, tty_output_buff_ptr); tty_write_ch(io_buf, ch); } io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-comment"><span class="hljs-comment">/* * Read single character from tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_read_ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr &lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *io_buf-&gt;ptr++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { io_buf-&gt;is_eof = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } }</code> </pre><br>  Il ne reste plus qu'√† contr√¥ler les modes d'entr√©e et de sortie pour impl√©menter ioctl. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Teletype specific command */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* hello_msg = MSG_KERNEL_NAME; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_INIT: <span class="hljs-comment"><span class="hljs-comment">/* prepare video device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { kmode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* detach syslog from screen */</span></span> tty_output_buff_ptr = video_clear(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; tty_write(io_buf, hello_msg, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(hello_msg)); video_flush(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_CLEAR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { <span class="hljs-comment"><span class="hljs-comment">/* fill output buffer with spaces */</span></span> tty_output_buff_ptr = video_clear(io_buf-&gt;base); video_flush(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { <span class="hljs-comment"><span class="hljs-comment">/* clear input buffer */</span></span> tty_input_buff_ptr = tty_input_buff; io_buf-&gt;ptr = io_buf-&gt;base; io_buf-&gt;is_eof = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_FLUSH: <span class="hljs-comment"><span class="hljs-comment">/* flush buffer to screen */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { video_flush(io_buf-&gt;base); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_READ_MODE_LINE: <span class="hljs-comment"><span class="hljs-comment">/* read only whole line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { read_line_mode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_READ_MODE_ECHO: <span class="hljs-comment"><span class="hljs-comment">/* put readed symbol to stdout */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { is_echo = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: unreachable(); } }</code> </pre><br>  Maintenant, nous impl√©mentons la sortie d'entr√©e de fichier au niveau de notre biblioth√®que C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Open file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> FILE* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mod_rw)</span></span></span><span class="hljs-function"> </span></span>{ FILE* result = null; asm_syscall(SYSCALL_OPEN, file, mod_rw, &amp;result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Close file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fclose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ asm_syscall(SYSCALL_CLOSE, file); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Read from file to buffer */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> u_int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asm_syscall(SYSCALL_READ, file, buff, size); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Write data to file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fwrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ asm_syscall(SYSCALL_WRITE, file, data, size); }</code> </pre><br>  Eh bien, voici quelques fonctions de haut niveau: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Print user message */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uvnprintf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* format, u_int n, va_list </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[VIDEO_SCREEN_WIDTH]; vsnprintf(buff, n, format, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>); uputs(buff); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Read from file to string */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uscanf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, ...)</span></span></span><span class="hljs-function"> </span></span>{ u_int readed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { readed = fread(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, buff, <span class="hljs-number"><span class="hljs-number">255</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (readed == <span class="hljs-number"><span class="hljs-number">0</span></span>); buff[readed - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* erase new line character */</span></span> uprintf(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); uflush(); }</code> </pre><br>  Afin de ne pas tromper avec la lecture de format jusqu'√† pr√©sent, nous allons toujours simplement lire dans la ligne comme si l'indicateur% s √©tait donn√©.  J'√©tais trop paresseux pour introduire un nouveau statut de t√¢che pour attendre les descripteurs de fichiers, nous essayons donc de lire quelque chose dans une boucle infinie jusqu'√† ce que nous r√©ussissions. <br><br>  C‚Äôest tout.  Vous pouvez maintenant attacher des pilotes en toute s√©curit√© √† votre noyau! <br><br><h4>  Les r√©f√©rences </h4><br>  Regardez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel vid√©o</a> pour plus d'informations. <br><br>  ‚Üí Code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le r√©f√©rentiel git</a> (vous avez besoin de la branche de le√ßon 8) <br><br><h4>  Les r√©f√©rences </h4><br><ol><li>  James Molloy.  Faites rouler votre propre syst√®me d'exploitation jouet UNIX-clone. </li><li>  Zubkov.  Assembleur pour DOS, Windows, Unix </li><li>  Kalachnikov.  L'assembleur est facile! </li><li>  Tanenbaum.  Syst√®mes d'exploitation.  Mise en ≈ìuvre et d√©veloppement. </li><li>  Robert Love.  Noyau Linux  Description du processus de d√©veloppement. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468509/">https://habr.com/ru/post/fr468509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468491/index.html">Mal√©diction karmique d'Habra</a></li>
<li><a href="../fr468493/index.html">La structure de la vue a√©rienne du projet Data Science</a></li>
<li><a href="../fr468497/index.html">Minuterie de brossage minut√©e de 3 minutes</a></li>
<li><a href="../fr468501/index.html">Comment j'ai cr√©√© un filtre qui ne corrompe pas l'image m√™me apr√®s un million d'ex√©cutions</a></li>
<li><a href="../fr468503/index.html">Le courrier ne fait pas plus de 500 miles - FAQ</a></li>
<li><a href="../fr468511/index.html">Publication d'un serveur via une passerelle DFL D-Link</a></li>
<li><a href="../fr468515/index.html">Conseils utiles pour l'int√©gration dans de nouveaux projets</a></li>
<li><a href="../fr468517/index.html">2. Pr√©sentation du support technique et de la garantie du commutateur Extreme Networks</a></li>
<li><a href="../fr468521/index.html">Comment nous avons g√©n√©ralis√© la s√©curit√© de l'information</a></li>
<li><a href="../fr468525/index.html">Jouets en bois, premi√®re partie - 1982-1985</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>