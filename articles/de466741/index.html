<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úèÔ∏è ü§ê üë®üèª‚Äçüöí Das Beste ist der Feind des Guten üà∂ ‚ùì üïµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel geht es darum, wie wir uns einmal entschlossen haben, das interne Tool SelfTester, mit dem die Qualit√§t des PVS-Studio-Analysators √º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Beste ist der Feind des Guten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466741/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Bild 12" align="left"></p>  In diesem Artikel geht es darum, wie wir uns einmal entschlossen haben, das interne Tool SelfTester, mit dem die Qualit√§t des PVS-Studio-Analysators √ºberpr√ºft wurde, leicht zu verbessern.  Die Verbesserung war einfach und sah n√ºtzlich aus, aber sie verursachte uns viele Probleme, und sp√§ter stellte sich heraus, dass es besser w√§re, wenn wir dies nicht tun w√ºrden. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Wir entwickeln und f√∂rdern den statischen Code-Analysator PVS-Studio f√ºr C, C ++, C # und Java.  Um die Qualit√§t des Analysators zu √ºberpr√ºfen, verwenden wir interne Tools, die zusammen als SelfTester bezeichnet werden.  Jede der unterst√ºtzten Sprachen verf√ºgt √ºber eine eigene Version von SelfTester.  Dies liegt an den Testfunktionen und ist nur bequemer.  Daher verwendet unser Unternehmen derzeit drei interne SelfTester-Tools f√ºr C \ C ++, C # und Java.  Als n√§chstes werde ich √ºber die Windows-Version von SelfTester f√ºr C \ C ++ Visual Studio-Projekte sprechen und sie einfach SelfTester nennen.  Dieser Tester war der erste in der Reihe solcher internen Tools, er ist der fortschrittlichste und komplexeste von allen. <br><br>  Wie funktioniert SelfTester?  Die Idee ist einfach: Nehmen Sie einen Pool von Testprojekten (wir verwenden echte Projekte mit Open Source Code) und analysieren Sie sie mit PVS-Studio.  Als Ergebnis wird f√ºr jedes Projekt ein Warnprotokoll f√ºr den Analysator erstellt.  Dieses Protokoll wird mit dem <i>Referenzprotokoll</i> f√ºr dasselbe Projekt verglichen.  Beim Vergleichen von Protokollen erstellt SelfTester ein <i>Protokollvergleichsprotokoll</i> in einer Form, die Entwickler gerne wahrnehmen k√∂nnen. <br><br>  Nach dem Studium des Logbuchs zieht der Entwickler eine Schlussfolgerung √ºber √Ñnderungen im Verhalten des Analysators: Anzahl und Art der Warnungen, Betriebsgeschwindigkeit, interne Analysatorfehler usw.  All diese Informationen sind sehr wichtig, damit Sie verstehen, wie gut der Analysator seine Arbeit erledigt. <br><br>  Basierend auf dem Protokollvergleichsprotokoll nimmt der Entwickler √Ñnderungen am Analysatorkern vor (z. B. beim Erstellen einer neuen Diagnoseregel) und steuert sofort die Auswirkung seiner √Ñnderungen.  Wenn der Entwickler keine Fragen mehr zum n√§chsten Vergleich der Protokolle hat, erstellt er das <i>aktuelle</i> Warnprotokoll f√ºr das Projekt als <i>Referenz</i> .  Ansonsten geht die Arbeit weiter. <br><br>  Die Aufgabe von SelfTester besteht also darin, mit einem Pool von Testprojekten zu arbeiten (√ºbrigens gibt es bereits mehr als 120 davon f√ºr C / C ++).  Projekte f√ºr den Pool werden als Visual Studio-L√∂sungen ausgew√§hlt.  Dies geschieht, um den Analysator zus√§tzlich auf verschiedenen Versionen von Visual Studio zu testen, die der Analysator unterst√ºtzt (derzeit von Visual Studio 2010 bis Visual Studio 2019). <br><br>  <i>Hinweis</i> : Ich werde die Konzepte von <i>L√∂sung</i> und <i>Projekt</i> weiter trennen und das Projekt als Teil der L√∂sung verstehen, wie es in Visual Studio √ºblich ist. <br><br>  Die SelfTester-Oberfl√§che sieht folgenderma√üen aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Bild 3"></div><br>  Links finden Sie eine Liste der L√∂sungen, rechts die Testergebnisse f√ºr jede Version von Visual Studio. <br><br>  Die grauen Markierungen "Nicht unterst√ºtzt" zeigen an, dass die L√∂sung die ausgew√§hlte Version von Visual Studio nicht unterst√ºtzt oder f√ºr diese Version nicht konvertiert wurde.  Einige L√∂sungen im Pool verf√ºgen √ºber eine Einstellung, die die zu √ºberpr√ºfende Version von Visual Studio angibt.  Wenn die Version nicht angegeben wird, wird die L√∂sung auf alle nachfolgenden Versionen von Visual Studio aktualisiert.  Ein Beispiel f√ºr eine solche L√∂sung im Screenshot ist "smart_ptr_check.sln" (die √úberpr√ºfung wurde f√ºr alle Versionen von Visual Studio durchgef√ºhrt). <br><br>  Ein gr√ºnes ‚ÄûOK‚Äú zeigt an, dass bei der n√§chsten Pr√ºfung keine Unterschiede zum Referenzprotokoll festgestellt wurden.  Eine rote ‚ÄûDiff‚Äú -Markierung zeigt Unterschiede an.  Auf solchen Etiketten sollte der Entwickler aufpassen.  Dazu muss er auf das gew√ºnschte Etikett doppelklicken.  Die ausgew√§hlte L√∂sung wird in der gew√ºnschten Version von Visual Studio ge√∂ffnet, und dort wird auch ein Fenster mit einem Warnprotokoll ge√∂ffnet.  Mit den folgenden Steuertasten k√∂nnen Sie die Analyse der ausgew√§hlten oder aller Entscheidungen neu starten, das ausgew√§hlte Protokoll (oder alle gleichzeitig) den Standardprotokollen zuweisen usw. <br><br>  Die pr√§sentierten Ergebnisse der SelfTester-Arbeit werden immer im HTML-Bericht (Differenzprotokoll) dupliziert. <br><br>  Zus√§tzlich zur grafischen Benutzeroberfl√§che verf√ºgt SelfTester √ºber automatisierte Modi f√ºr die Ausf√ºhrung w√§hrend n√§chtlicher Builds.  Das √ºbliche Verwendungsmuster wird jedoch vom Entwickler w√§hrend des Arbeitstages wiederholt gestartet.  Daher ist eine der wichtigen Eigenschaften von SelfTester die <i>Geschwindigkeit</i> . <br><br>  Warum Geschwindigkeit wichtig ist: <br><br><ol><li>  Um w√§hrend der Nachttests ausgef√ºhrt zu werden, ist die Zeit, die f√ºr jeden Schritt ben√∂tigt wird, entscheidend.  Je schneller die Tests bestehen, desto besser.  Die durchschnittliche Betriebszeit von SelfTester betr√§gt derzeit mehr als 2 Stunden. </li><li>  Wenn SelfTester tags√ºber gestartet wird, muss der Entwickler weniger auf das Ergebnis warten, was die Arbeitsproduktivit√§t erh√∂ht. </li></ol><br>  Es war der Wunsch, die Arbeit von SelfTester zu beschleunigen, der diesmal die Verbesserungen verursachte. <br><br><h2>  Multithreading in SelfTester </h2><br>  SelfTester wurde urspr√ºnglich als Multithread-Anwendung mit der M√∂glichkeit erstellt, mehrere L√∂sungen gleichzeitig zu √ºberpr√ºfen.  Die einzige Einschr√§nkung bestand darin, dass Sie nicht gleichzeitig dieselbe L√∂sung f√ºr verschiedene Versionen von Visual Studio √ºberpr√ºfen k√∂nnen, da viele L√∂sungen vor der √úberpr√ºfung auf bestimmte Versionen von Visual Studio aktualisiert werden m√ºssen.  W√§hrenddessen werden √Ñnderungen direkt an den <i>.vcxproj-</i> Projektdateien vorgenommen, was bei paralleler Ausf√ºhrung zu Fehlern f√ºhrt. <br><br>  Um die Arbeit effizienter zu gestalten, verwendet SelfTester einen intelligenten Taskplaner, mit dem Sie einen streng begrenzten Wert f√ºr parallele Threads festlegen und verwalten k√∂nnen. <br><br>  Der Scheduler wird auf zwei Ebenen verwendet.  Die erste ist die <i>L√∂sungsebene</i> , mit der die √úberpr√ºfung der <i>SLN-</i> L√∂sung mit dem <i>Dienstprogramm PVS-Studio_Cmd.exe gestartet wird</i> .  In <i>PVS-Studio_Cmd.exe</i> (auf der Ebene der √úberpr√ºfung von Quellcodedateien) wird derselbe Scheduler verwendet, jedoch mit einem anderen <i>Grad an Parallelit√§tseinstellung</i> . <br><br>  Der Parallelit√§tsgrad ist ein Parameter, der angibt, wie viele parallele Threads gleichzeitig ausgef√ºhrt werden sollen.  F√ºr Werte des Parallelit√§tsgrades auf Entscheidungsebene und f√ºr Dateien wurden die Standardwerte von <i>vier</i> bzw. <i>acht</i> ausgew√§hlt.  Daher sollte die Anzahl der parallelen Threads f√ºr diese Implementierung 32 betragen (vier gleichzeitig getestete L√∂sungen und acht Dateien).  Diese Einstellung scheint uns optimal f√ºr den Analysator zu sein, um auf einem Acht-Kern-Prozessor zu arbeiten. <br><br>  Der Entwickler kann unabh√§ngig andere Werte f√ºr den Grad der Parallelit√§t festlegen, wobei er sich auf die Leistung seines Computers oder auf aktuelle Aufgaben konzentriert.  Wenn er diesen Parameter nicht einstellt, wird standardm√§√üig die Anzahl der logischen Prozessoren des Systems ausgew√§hlt. <br><br>  <i>Hinweis</i> : Au√üerdem werden wir ber√ºcksichtigen, dass die Arbeit mit den Standardwerten f√ºr den Parallelit√§tsgrad ausgef√ºhrt wird. <br><br>  Der <i>LimitedConcurrencyLevelTaskScheduler-Scheduler wird</i> von <i>System.Threading.Tasks.TaskScheduler</i> geerbt und verfeinert, um ein H√∂chstma√ü an Parallelit√§t bei der Arbeit mit <i>ThreadPool zu gew√§hrleisten</i> .  Vererbungshierarchie: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>Mit PausableTaskScheduler</i> k√∂nnen <i>Sie</i> Aufgaben <i>anhalten</i> , und <i>LimitedConcurrencyLevelTaskScheduler</i> bietet dar√ºber hinaus eine intelligente Steuerung der Aufgabenwarteschlange und der Planung ihrer Ausf√ºhrung unter Ber√ºcksichtigung des Parallelit√§tsgrads, der Anzahl der geplanten Aufgaben und anderer Faktoren.  Der Scheduler wird beim Starten von <i>System.Threading.Tasks.Task-</i> Tasks verwendet. <br><br><h2>  Voraussetzungen f√ºr Verbesserungen </h2><br>  Die Umsetzung der oben beschriebenen Arbeit hat einen Nachteil: Sie ist nicht optimal, wenn mit L√∂sungen unterschiedlicher Gr√∂√üe gearbeitet wird.  Die Gr√∂√üe der L√∂sungen im Testpool ist <i>sehr</i> unterschiedlich: 8 KB bis 4 GB f√ºr die Gr√∂√üe des Ordners mit der L√∂sung und jeweils eine bis mehrere tausend Quellcodedateien. <br><br>  Der Scheduler stellt die Entscheidungen einfach in der richtigen Reihenfolge ohne intellektuelle Komponente in die Warteschlange.  Ich m√∂chte Sie daran erinnern, dass standardm√§√üig nicht mehr als vier L√∂sungen gleichzeitig √ºberpr√ºft werden k√∂nnen.  Wenn derzeit vier gro√üe L√∂sungen √ºberpr√ºft werden (die Anzahl der Dateien in jeder ist mehr als acht), wird davon ausgegangen, dass wir effizient arbeiten, da wir die maximal m√∂gliche Anzahl von Threads verwenden (32). <br><br>  Stellen Sie sich jedoch eine ziemlich h√§ufige Situation vor, in der mehrere kleine L√∂sungen getestet werden.  Beispielsweise ist eine L√∂sung gro√ü und enth√§lt 50 Dateien (maximal acht Threads sind beteiligt), und die anderen drei enthalten jeweils drei, vier und f√ºnf Dateien.  In diesem Fall verwenden wir nur 20 Threads (8 + 3 + 4 + 5).  Die Prozessorzeit wird nicht ausreichend genutzt, und die Gesamtleistung nimmt ab. <br><br>  <i>Hinweis</i> : Tats√§chlich ist der Engpass in der Regel immer noch das Festplattensubsystem und nicht der Prozessor. <br><br><h2>  Verbesserungen </h2><br>  Eine Verbesserung, die sich in diesem Fall selbst anbietet, ist die Rangfolge der Liste der zur √úberpr√ºfung eingereichten L√∂sungen.  Es ist notwendig, eine bestimmte Anzahl gleichzeitig ausgef√ºhrter Threads (32) optimal zu nutzen, indem Projekte mit der ‚Äûrichtigen‚Äú Anzahl von Dateien zur √úberpr√ºfung eingereicht werden. <br><br>  Schauen wir uns noch einmal unser Beispiel an, wenn vier L√∂sungen mit jeweils der folgenden Anzahl von Dateien getestet werden: 50, 3, 4 und 5. Eine Aufgabe, die eine L√∂sung aus <i>drei</i> Dateien √ºberpr√ºft, wird wahrscheinlich bald funktionieren.  Und stattdessen w√§re es optimal, eine L√∂sung hinzuzuf√ºgen, in der acht oder mehr Dateien vorhanden sind (um maximal acht verf√ºgbare Streams f√ºr diese L√∂sung zu verwenden).  Dann werden wir insgesamt bereits 25 Threads verwenden (8 + <b>8</b> + 4 + 5).  Nicht schlecht.  Sieben Threads wurden jedoch noch nicht verwendet.  Und hier entsteht die Idee einer weiteren Verfeinerung, die sich auf die Aufhebung der Beschr√§nkung auf vier Threads zur √úberpr√ºfung von L√∂sungen bezieht.  In der Tat k√∂nnen Sie im obigen Beispiel nicht eine, sondern mehrere L√∂sungen hinzuf√ºgen, wobei Sie so viel wie m√∂glich alle 32 Threads verwenden.  Stellen wir uns vor, wir haben zwei weitere L√∂sungen, jeweils drei und vier Dateien.  Durch Hinzuf√ºgen dieser Aufgaben wird die ‚ÄûL√ºcke‚Äú in nicht verwendeten Threads vollst√§ndig geschlossen, und es werden 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ) vorhanden sein. <br><br>  Ich denke, die Idee ist klar.  Tats√§chlich erforderte die Umsetzung dieser Verbesserungen auch keinen gro√üen Aufwand.  Alles war an einem Tag erledigt. <br><br>  Es war notwendig, die <i>Taskklasse</i> : Vererbung von <i>System.Threading.Tasks.Task</i> zu verfeinern und das Feld "weight" hinzuzuf√ºgen.  Um das Gewicht der L√∂sung festzulegen, wird ein einfacher Algorithmus verwendet: Wenn die Anzahl der Dateien in der L√∂sung weniger als acht betr√§gt, wird das Gewicht gleich diesem Wert gesetzt (z. B. 5). Wenn die Anzahl der Dateien gr√∂√üer oder gleich acht ist, wird das Gewicht gleich acht gew√§hlt. <br><br>  Es war auch notwendig, den Scheduler zu verfeinern: ihm beizubringen, L√∂sungen mit dem richtigen Gewicht auszuw√§hlen, um einen Maximalwert von 32 Threads zu erreichen.  Es war auch notwendig, die Zuweisung von mehr als vier Threads f√ºr die gleichzeitige √úberpr√ºfung von L√∂sungen zuzulassen. <br><br>  Schlie√ülich war ein erster Schritt erforderlich, um alle Pooll√∂sungen zu analysieren (Auswertung mit der MSBuild-API), um die L√∂sungsgewichte zu berechnen und festzulegen (Anzahl der Dateien mit Quellcode ermitteln). <br><br><h2>  Ergebnis </h2><br>  Ich denke, nach einer so langen Einf√ºhrung haben Sie bereits vermutet, dass das Ergebnis Null war. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Bild 15"></div><br>  Es ist gut, dass die Verbesserungen einfach und schnell waren. <br><br>  Nun beginnt tats√§chlich der Teil des Artikels √ºber "viele Probleme f√ºr uns geschaffen", und das ist alles. <br><br><h2>  Nebenwirkungen </h2><br>  Ein negatives Ergebnis ist also auch ein Ergebnis.  Es stellte sich heraus, dass die Anzahl der gro√üen L√∂sungen im Pool die Anzahl der kleinen (weniger als acht Dateien) <i>erheblich</i> √ºbersteigt.  Unter diesen Bedingungen machen sich die vorgenommenen Verbesserungen nicht bemerkbar, da sie praktisch unsichtbar sind: Ihre √úberpr√ºfung nimmt im Vergleich zu gro√üen Projekten eine mikroskopische Zeit in Anspruch. <br><br>  Trotzdem wurde beschlossen, die √úberarbeitung als "nicht st√∂rend" und potenziell n√ºtzlich zu belassen.  Dar√ºber hinaus wird der Pool an Testl√∂sungen st√§ndig aufgef√ºllt, sodass sich die Situation in Zukunft m√∂glicherweise √§ndern wird. <br><br>  Und dann ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Bild 5"></div><br>  Einer der Entwickler beschwerte sich √ºber den "Fall" von SelfTester.  Nun, es passiert.  Um zu verhindern, dass dieser Fehler verloren geht, wurde ein interner Vorfall (Ticket) mit dem Namen ‚ÄûAusnahme bei der Arbeit mit SelfTester‚Äú gestartet.  Der Fehler trat w√§hrend der Evaluierung des Projekts auf.  Eine solche F√ºlle von Fenstern hat das Problem auch im Fehlerbehandler best√§tigt.  Dies wurde jedoch schnell beseitigt, und in der n√§chsten Woche brach nichts zusammen.  Pl√∂tzlich beschwerte sich ein anderer Benutzer √ºber SelfTester.  Und noch einmal zum Fehler der Projektevaluierung: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Bild 8"></div><br>  Der Stapel enthielt diesmal n√ºtzlichere Informationen - ein Fehler im XML-Format.  Wahrscheinlich ist bei der Verarbeitung der Projektdatei <i>Proto_IRC.vcxproj</i> (ihrer XML-Darstellung) etwas mit der Datei selbst passiert, sodass <i>XmlTextReader</i> sie nicht verarbeiten konnte. <br><br>  Das Vorhandensein von zwei Fehlern in relativ kurzer Zeit hat uns veranlasst, das Problem genauer zu betrachten.  Dar√ºber hinaus wird SelfTester, wie oben erw√§hnt, von Entwicklern sehr aktiv genutzt. <br><br>  Zun√§chst wurde der letzte Ort des Sturzes analysiert.  Leider konnte nichts Verd√§chtiges festgestellt werden.  F√ºr alle F√§lle haben sie Entwickler (SelfTester-Benutzer) gebeten, auf der Hut zu sein und m√∂gliche Fehler zu melden. <br><br>  Ein wichtiger Punkt: Der Code, bei dem der Fehler aufgetreten ist, wurde in SelfTester wiederverwendet.  Zun√§chst werden damit Projekte im Analysator selbst ( <i>PVS-Studio_Cmd.exe</i> ) <i>ausgewertet</i> .  Deshalb ist die Aufmerksamkeit auf das Problem gewachsen.  Im Analysator traten jedoch keine √§hnlichen Tropfen auf. <br><br>  In der Zwischenzeit wurde ein Ticket √ºber Probleme mit SelfTester mit neuen Fehlern aufgef√ºllt: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Bild 9"></div><br>  Und wieder <i>XmlException</i> .  Offensichtlich gibt es irgendwo konkurrierende Threads, die mit Lese- und Schreibprojektdateien arbeiten.  SelfTester arbeitet in folgenden F√§llen mit Projekten: <br><br><ol><li>  Bewertung von Projekten w√§hrend der vorl√§ufigen Berechnung von Entscheidungsgewichten: ein neuer Schritt, der zun√§chst Verdacht erregte; </li><li>  Aktualisieren von Projekten auf die erforderlichen Versionen von Visual Studio: Wird unmittelbar vor der √úberpr√ºfung durchgef√ºhrt (Projekte √ºberschneiden sich in keiner Weise) und sollten die Arbeit nicht beeintr√§chtigen. </li><li>  Bewertung von Projekten w√§hrend der √úberpr√ºfung: Debugging eines thread-sicheren Mechanismus, der von <i>PVS-Studio_Cmd.exe</i> wiederverwendet wurde; </li><li>  Wiederherstellen von Projektdateien (Ersetzen ge√§nderter <i>.vcxproj-</i> Dateien <i>durch die</i> urspr√ºnglichen Referenzdateien) beim Beenden von SelfTester, da Projektdateien dabei auf die erforderlichen Versionen von Visual Studio aktualisiert werden k√∂nnen: der letzte Schritt, der auch andere Mechanismen nicht beeinflusst. </li></ol><br>  Der Verdacht fiel auf den neuen Code, der zur Optimierung hinzugef√ºgt wurde (Berechnung der Gewichte).  Die Untersuchung dieses Codes ergab jedoch, dass der Tester immer korrekt auf das Ende der vorl√§ufigen Bewertung wartete, wenn der Benutzer die Analyse unmittelbar nach dem Start von SelfTester startete.  Dieser Ort sah sicher aus. <br><br>  Auch hier konnten wir die Ursache des Problems nicht identifizieren. <br><br><h2>  Schmerz </h2><br>  Im Laufe des n√§chsten Monats fiel SelfTester von Zeit zu Zeit weiter.  Das Ticket wurde mit Daten aufgef√ºllt, aber es war nicht klar, was mit diesen Daten zu tun ist.  Die meisten Abst√ºrze waren alle mit derselben <i>XmlException</i> .  Gelegentlich gab es noch etwas anderes, aber denselben wiederverwendeten Code aus <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Bild 1"></div><br>  Traditionell werden keine so hohen Anforderungen an interne Tools gestellt, so dass die Arbeit mit SelfTester-Fehlern dennoch auf Restbasis durchgef√ºhrt wurde.  Von Zeit zu Zeit waren verschiedene Personen miteinander verbunden (w√§hrend der gesamten Zeit des Vorfalls arbeiteten sechs Personen an dem Problem, darunter zwei Praktikanten).  Trotzdem musste die Aufgabe abgelenkt werden. <br><br>  <i>Unser erster Fehler.</i>  Tats√§chlich war es hier bereits m√∂glich, das Problem ein f√ºr alle Mal zu l√∂sen.  Wie?  Es war klar, dass der Fehler durch eine neue Optimierung verursacht wurde.  Immerhin hat vorher alles gut funktioniert, und wiederverwendeter Code konnte offensichtlich nicht so schlecht sein.  Dar√ºber hinaus brachte diese Optimierung keine Vorteile.  Was musste also getan werden?  <i>Entfernen Sie diese Optimierung</i> <b>.</b>  Wie Sie wissen, wurde dies nicht getan.  Wir arbeiteten weiter an einem Problem, das wir selbst geschaffen hatten.  Die Suche nach der Antwort auf die Frage "WIE ???" wurde fortgesetzt.  Wie f√§llt es?  Dennoch scheint es richtig geschrieben zu sein. <br><br>  <i>Unser zweiter Fehler.</i>  <i>Andere Menschen</i> waren <i>mit</i> der L√∂sung des Problems verbunden.  Ein sehr, sehr gro√üer Fehler.  Leider hat dies nicht nur das Problem nicht gel√∂st, sondern es wurden zus√§tzliche Ressourcen aufgewendet.  Ja, neue Leute brachten neue Ideen mit, aber f√ºr ihre Umsetzung wurde viel Arbeitszeit ben√∂tigt (absolut verschwendet).  Zu einem bestimmten Zeitpunkt wurden Testprogramme (von denselben Auszubildenden) geschrieben, die die Bewertung desselben Projekts in verschiedenen Threads mit paralleler √Ñnderung des Projekts in einem anderen Thread emulieren.  Es hat nicht geholfen.  Zus√§tzlich zu dem, was wir bereits zuvor wussten, ist die MSBuild-API im Inneren threadsicher. Sie haben nichts Neues herausgefunden.  In SelfTester wurde ein Mini-Dump hinzugef√ºgt, als eine <i>XmlException</i> ausgel√∂st wurde.  Dann hat das alles jemand entsetzt, Entsetzen.  Es wurden Diskussionen gef√ºhrt, viele andere unn√∂tige Dinge wurden getan. <br><br>  <i>Endlich unser dritter Fehler</i> .  Wissen Sie, wie viel Zeit vergangen ist, seit das Problem mit SelfTester aufgetreten ist und wie es gel√∂st wurde?  Obwohl nein, z√§hlen Sie sich.  Der Vorfall wurde am 17.09.2008 erstellt und am 20.02.2019 geschlossen. Dort gibt es mehr als 40 (vierzig!) Nachrichten.  Leute, das ist viel Zeit!  Wir haben <i>uns erlaubt</i> , f√ºnf Monate lang IT <i>zu</i> betreiben.  Zur gleichen Zeit (parallel) haben wir Visual Studio 2019 unterst√ºtzt, die Java-Sprache hinzugef√ºgt, mit der Implementierung des MISRA C / C ++ - Standards begonnen, den C # -Analysator verbessert, aktiv an Konferenzen teilgenommen, eine Reihe von Artikeln geschrieben usw.  Und all diese Arbeiten haben den Entwicklern aufgrund des dummen Fehlers SelfTester keine Zeit gegeben. <br><br>  B√ºrger, lernen aus unseren Fehlern und tun das niemals.  Und wir werden nicht. <br><br>  Ich habe alles <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Bild 17"></div><br>  Nat√ºrlich ist dies ein Witz und ich werde Ihnen sagen, was das Problem mit SelfTester war :) <br><br><h2>  Bingo! </h2><br>  Gl√ºcklicherweise war unter uns eine Person mit dem am wenigsten getr√ºbten Bewusstsein (mein Kollege Sergey Vasiliev), die das Problem nur aus einem ganz anderen Blickwinkel betrachtete (und auch ein wenig Gl√ºck hatte).  Was ist, wenn in SelfTester wirklich alles in Ordnung ist und Projekte etwas von au√üen brechen?  Parallel zu SelfTester wurde normalerweise nichts gestartet. In einigen F√§llen haben wir die Laufzeit streng kontrolliert.  In diesem Fall k√∂nnte dieses ‚ÄûEtwas‚Äú nur SelfTester selbst sein, aber eine weitere Instanz davon. <br><br>  Nach dem Beenden von SelfTester funktioniert der Stream, der Projektdateien aus den Standards wiederherstellt, noch einige Zeit.  Zu diesem Zeitpunkt k√∂nnen Sie den Tester neu starten.  Der Schutz gegen das gleichzeitige Ausf√ºhren mehrerer Instanzen von SelfTester wurde <i>sp√§ter</i> hinzugef√ºgt und sieht nun folgenderma√üen aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Bild 16"></div><br>  Aber dann war sie weg. <br><br>  Unglaublicherweise hat fast ein halbes Jahr lang niemand darauf geachtet.  Das Wiederherstellen von Projekten aus Standards ist ein Hintergrundverfahren, das schnell genug ist, aber leider nicht schnell genug, um den Neustart von SelfTester nicht zu beeintr√§chtigen.  Und was passiert beim Start?  Das ist richtig, Entscheidungsgewichte zu berechnen.  Ein Prozess √ºberschreibt <i>.vcxproj-</i> Dateien, w√§hrend ein anderer versucht, sie zu lesen.  Hallo, <i>XmlException</i> . <br><br>  Sergey fand dies alles heraus, als er dem Tester die M√∂glichkeit hinzuf√ºgte, in den Arbeitsmodus mit einem anderen Satz von Standardprotokollen zu wechseln.  Die Notwendigkeit hierf√ºr ergab sich nach dem Hinzuf√ºgen des MISRA-Regelsatzes zum Analyseger√§t.  Sie k√∂nnen direkt in der Benutzeroberfl√§che wechseln, w√§hrend der Benutzer das Fenster sieht: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Bild 14"></div><br>  Danach wird SelfTester <i>neu</i> gestartet.  Nun, anscheinend haben Benutzer das Problem fr√ºher selbst emuliert und den Tester erneut gestartet. <br><br><h2>  Nachbesprechung und Schlussfolgerungen </h2><br>  Nat√ºrlich haben wir die zuvor erstellte Optimierung gel√∂scht oder vielmehr deaktiviert.  Au√üerdem war es viel einfacher als eine Art Synchronisation zwischen dem Rest des Testers selbst durchzuf√ºhren.  Und alles begann nach wie vor einwandfrei zu funktionieren.  Als zus√§tzliche Ma√ünahme wurde der oben beschriebene Schutz gegen das gleichzeitige Starten des Testers hinzugef√ºgt. <br><br>  Ich habe oben bereits √ºber unsere Hauptfehler bei der Suche nach dem Problem geschrieben, daher reicht es aus, sich selbst zu kennzeichnen.  Wir sind auch Menschen, und deshalb irren wir uns.  Es ist wichtig, aus Ihren Fehlern zu lernen und Schlussfolgerungen zu ziehen.  Die Schlussfolgerungen hier sind recht einfach: <br><br><ul><li>  Es ist notwendig, das Wachstum der Aufgabenkomplexit√§t zu verfolgen und zu bewerten. </li><li>  Stoppen Sie rechtzeitig; </li><li>  Versuchen Sie, das Problem breiter zu betrachten, da die Ansicht mit der Zeit ‚Äûverschwommen‚Äú und der Blickwinkel verengt wird. </li><li>  Haben Sie keine Angst, alten oder unn√∂tigen Code zu l√∂schen. </li></ul><br>  Nun sicher - das war's.  Danke f√ºrs Lesen.  An alle hoffnungslosen Codes! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Beste ist der Feind des Guten</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466741/">https://habr.com/ru/post/de466741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466731/index.html">Extravaganz. Der September steigt</a></li>
<li><a href="../de466733/index.html">Willkommen zu DINS Java ABEND am 18. September</a></li>
<li><a href="../de466735/index.html">Eine einfache M√∂glichkeit, einen Sprachalarm im Home Automation-System (‚ÄûSmart Home‚Äú) zu erstellen.</a></li>
<li><a href="../de466737/index.html">Warum das soziale Netzwerk von Google+ fehlgeschlagen ist</a></li>
<li><a href="../de466739/index.html">Das Beste ist der Feind des Guten</a></li>
<li><a href="../de466745/index.html">Der erste Arbeitsplatz oder wie man mit der Entwicklung der API auf Node.js beginnt</a></li>
<li><a href="../de466747/index.html">Mitap iOS-Entwickler bei Redmadrobot</a></li>
<li><a href="../de466753/index.html">Netzwerkadministration schnell und effizient - Netzwerk-MACMonitor</a></li>
<li><a href="../de466755/index.html">Der Computer wird Sie lecker machen</a></li>
<li><a href="../de466757/index.html">Der erste Flutter Mitap in St. Petersburg - 26. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>