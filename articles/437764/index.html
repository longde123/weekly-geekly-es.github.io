<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèø üßõüèæ üåßÔ∏è OpenSceneGraph: Gesti√≥n de Windows y modos de visualizaci√≥n ü§±üèΩ üçå üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Ya hemos dicho que la clase osg :: Camera gestiona el contexto gr√°fico OpenGL asociado. El contexto gr√°fico encapsula informaci√≥n sobre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Gesti√≥n de Windows y modos de visualizaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437764/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Ya hemos dicho que la clase osg :: Camera gestiona el contexto gr√°fico OpenGL asociado.  El contexto gr√°fico encapsula informaci√≥n sobre c√≥mo y d√≥nde se dibujan los objetos y qu√© atributos de estado se les aplican.  El contexto se entiende como una ventana gr√°fica, o m√°s bien su √°rea de cliente, o el b√∫fer de p√≠xeles de OpenGL, que almacena datos de p√≠xeles sin transferirlos al b√∫fer de cuadros. <br><br>  OSG utiliza la clase osg :: GraphicsContext para representar un contexto gr√°fico abstracto y la clase osg :: GraphicsWindow para representar una ventana gr√°fica abstracta.  Este √∫ltimo tiene un m√©todo getEventQueue () para administrar eventos desde elementos de la GUI.  En t√©rminos generales, un contexto gr√°fico es un concepto espec√≠fico de la plataforma, por lo que OSG se encarga de la mayor parte del trabajo de crear una ventana y asociar su contexto con el contexto OpenGL.  Cuando se llama al m√©todo createGraphicsContext () de la clase osg :: GraphicsContext (), el preprocesador generar√° autom√°ticamente el c√≥digo requerido (y hay muchos, ¬°cr√©anme!), Dependiendo de la plataforma.  Todo lo que se requiere de nosotros es pasar a este m√©todo un argumento del tipo osg :: GraphicsContex :: Traits que contenga una descripci√≥n de la ventana que queremos recibir. <br><a name="habracut"></a><br><h1>  1. La clase osg :: DisplaySettings </h1><br>  OSG permite al desarrollador administrar la configuraci√≥n de visualizaci√≥n global, en funci√≥n de qu√© c√°maras, visores y elementos de escena se representan.  Para esto, se utiliza el patr√≥n singleton, es decir, un objeto √∫nico que contiene esta configuraci√≥n, implementado en forma de la clase osg :: DisplaySettings, a la que se puede acceder desde cualquier parte del programa.  Por lo tanto, desde nuestra aplicaci√≥n, podemos cambiar esta configuraci√≥n en cualquier momento. <br><br><pre><code class="cpp hljs">osg::DisplaySettings *ds = osg::DisplaySettings::instance();</code> </pre> <br>  Singleton osg :: DisplaySettings contiene la configuraci√≥n que se aplica a los dispositivos de renderizado reci√©n creados, el contexto OpenGL de la ventana gr√°fica.  Puede variar los siguientes par√°metros: <br><br><ol><li>  setDoubleBuffer () - habilita / deshabilita el doble buffering.  Habilitado por defecto. <br></li><li>  setDepthBuffer () - activa / desactiva el b√∫fer de profundidad.  Habilitado por defecto. <br></li><li>  Establezca el ancho del b√∫fer alfa, el b√∫fer de la plantilla y el b√∫fer de acumulaci√≥n utilizando m√©todos como setMinimumNumAlphaBits ().  Por defecto, todos los par√°metros son 0. <br></li><li>  Permiso para usar anti-aliasing y su profundidad usando el m√©todo setNumMultiSamples ().  El valor predeterminado es 0. <br></li><li>  Activa el modo est√©reo.  Desactivado por defecto. <br></li></ol><br>  Considere el uso de este singleton en el ejemplo de suavizado <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo singleton de Osg :: DisplaySettings</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::DisplaySettings::instance()-&gt;setNumMultiSamples(6); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Lo esencial aqu√≠ es solo un desaf√≠o. <br><br><pre> <code class="cpp hljs">osg::DisplaySettings::instance()-&gt;setNumMultiSamples(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  - establecer el par√°metro de suavizado, que puede tomar los valores 2, 4 y 6, dependiendo del dispositivo gr√°fico utilizado.  Preste atenci√≥n a c√≥mo se ve la cuchilla de tornillo Cessna sin aplicar suavizado <br><br><img src="https://habrastorage.org/webt/4y/nr/1p/4ynr1p8ia9knpagauohb6_fe2-g.png"><br><br>  y luego de su aplicaci√≥n <br><br><img src="https://habrastorage.org/webt/yq/4b/og/yq4bog1qdmngwxpsij7ujponxzk.png"><br><br><h1>  2. Cambiar al modo ventana </h1><br>  La clase osgViewer :: Viewer se puede reconfigurar muy r√°pidamente para mostrar en modo de ventana.  Como not√≥, todos nuestros ejemplos anteriores se mostraron en pantalla completa.  Para cambiar el visor al modo de ventana, existe el m√©todo setUpViewInWindow (), que toma como par√°metros las coordenadas de la esquina superior izquierda de la ventana, su ancho y alto en p√≠xeles <br><br><pre> <code class="cpp hljs">viewer.setUpViewInWindow(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>);</code> </pre><br>  Opcionalmente, este m√©todo acepta el quinto par√°metro: el n√∫mero de la pantalla en la que se debe mostrar la ventana, en caso de que tenga m√°s de un monitor.  Seguramente trabajando con m√∫ltiples monitores en Windows, observ√≥ que la escena se extiende a todos los monitores en modo de pantalla completa (esto no se observa en Linux). <br><br>  Adem√°s, en la configuraci√≥n del proyecto, puede establecer la variable de entorno OSG_WINDOW de esta manera <br><br><img src="https://habrastorage.org/webt/-5/yg/ge/-5yggeqzivtjkymngxq3xk318qm.png"><br><br>  que ser√° equivalente a llamar a setUpViewInWindow (), que en este caso no se puede ejecutar. <br><br><img src="https://habrastorage.org/webt/2z/z_/px/2zz_pxckvywsn1c3hpebbwwj77e.png"><br><br>  Para especificar expl√≠citamente la pantalla en la que se debe mostrar el visor en modo de pantalla completa, puede usar el m√©todo setUpViewOnSingleScreen () especificando el n√∫mero de pantalla como un par√°metro (0 por defecto). <br><br>  OSG tambi√©n admite pantallas esf√©ricas de demostraci√≥n.  Puede usar el m√©todo setUpViewFor3DSphericalDisplay () para personalizar la pantalla en dicha pantalla. <br><br><h1>  3. Visor compuesto </h1><br>  La clase osgViewer :: Viewer controla una vista √∫nica que muestra un solo gr√°fico de escena.  Adem√°s de esto, hay una clase osgViewer :: CompositeViewer que admite varias vistas y varias escenas.  Tiene los mismos m√©todos run (), frame () y done () para controlar el proceso de renderizado, pero le permite agregar y eliminar vistas independientes usando los m√©todos addView () y removeView (), as√≠ como obtener vistas por su √≠ndice usando el m√©todo getView ()  El objeto de vista es descrito por la clase osgViewer :: View. <br><br>  La clase osgViewer :: View es la clase base para la clase osgViewer :: Viewer.  Le permite agregar un nodo ra√≠z con datos de escena, un manipulador de c√°mara y controladores de eventos.  La principal diferencia entre esta clase (vista) y la clase de visor es que no permite renderizar la escena con llamadas run () o frame ().  Un escenario t√≠pico para agregar vistas se ve as√≠ <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer multiviewer; multiviewer.addView( view );</code> </pre><br>  El visor compuesto le permite mostrar una escena en diferentes √°ngulos, mostrando estos √°ngulos en diferentes ventanas.  Tambi√©n le permite mostrar escenas independientes en diferentes ventanas.  Escribamos un ejemplo simple de uso de un visor compuesto <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo compuesto</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/CompositeViewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::View *createView(int x, int y, int w, int h, osg::Node *scene) { osg::ref_ptr&lt;osgViewer::View&gt; view = new osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); return view.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Node&gt; model3 = osgDB::readNodeFile("../data/glider.osg"); osgViewer::View *view1 = createView(50, 50, 320, 240, model1); osgViewer::View *view2 = createView(380, 50, 320, 240, model2); osgViewer::View *view3 = createView(185, 330, 320, 240, model3); osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Colocaremos la creaci√≥n de una vista separada en una funci√≥n que tome como par√°metros la posici√≥n y el tama√±o de la ventana, as√≠ como la escena como un puntero a su nodo ra√≠z <br><br><pre> <code class="cpp hljs">osgViewer::<span class="hljs-function"><span class="hljs-function">View *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, osg::Node *scene)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release(); }</code> </pre><br>  Aqu√≠ creamos una vista controlada por un puntero inteligente a un objeto osgViewer :: View <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View;</code> </pre><br>  establecer los datos de la escena mostrada y el modo de visualizaci√≥n de la ventana en la ventana con la posici√≥n y el tama√±o especificados <br><br><pre> <code class="cpp hljs">view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h);</code> </pre><br>  Devolvemos la vista desde la funci√≥n de acuerdo con las reglas para devolver punteros inteligentes <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release();</code> </pre><br>  Ahora en el programa principal cargamos tres modelos diferentes <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  crear tres tipos diferentes <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  crear un visor compuesto y agregarle vistas creadas previamente <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3);</code> </pre><br>  y ejecuta el renderizado exactamente de la misma manera que lo hicimos en el caso de una escena <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Eso es todo!  Cuando se inicia el programa, obtenemos tres ventanas diferentes.  El contenido de cada ventana se puede controlar de forma independiente.  Cualquiera de las ventanas se puede cerrar de la manera est√°ndar y salir completamente de la aplicaci√≥n presionando Esc. <br><br><img src="https://habrastorage.org/webt/dh/na/kl/dhnaklox5z-apbaynehnea_okss.png"><br><br><h1>  3. La clase osg :: GraphicsContext :: Traits </h1><br>  La palabra "rasgos" en la traducci√≥n del ingl√©s significa "caracter√≠sticas".  Entonces, la clase mencionada anteriormente describe las caracter√≠sticas de la ventana futura y contiene todas las propiedades para describir el contexto gr√°fico.  Se diferencia de la clase osg :: DisplaySettings, que controla las caracter√≠sticas de todos los contextos gr√°ficos para c√°maras reci√©n creadas.  Las principales propiedades p√∫blicas de esta clase se enumeran en la tabla a continuaci√≥n. <br><br><table><thead><tr><th>  Atributo de clase </th><th>  Tipo </th><th>  Valor por defecto </th><th>  Descripci√≥n </th></tr></thead><tbody><tr><td>  x </td><td>  int </td><td>  0 0 </td><td>  La posici√≥n horizontal inicial de la ventana. </td></tr><tr><td>  y </td><td>  int </td><td>  0 0 </td><td>  La posici√≥n vertical inicial de la ventana. </td></tr><tr><td>  ancho </td><td>  int </td><td>  0 0 </td><td>  Ancho de la ventana </td></tr><tr><td>  altura </td><td>  int </td><td>  0 0 </td><td>  Altura de la ventana </td></tr><tr><td>  windowName </td><td>  std :: string </td><td>  "" </td><td>  T√≠tulo de la ventana </td></tr><tr><td>  ventanaDecoraci√≥n </td><td>  bool </td><td>  falso </td><td>  Indicador de visualizaci√≥n del t√≠tulo de la ventana </td></tr><tr><td>  rojo </td><td>  unsigned int </td><td>  8 </td><td>  El n√∫mero de bits de rojo en el b√∫fer de color OpenGL </td></tr><tr><td>  verde </td><td>  unsigned int </td><td>  8 </td><td>  El n√∫mero de bits de verde en el b√∫fer de color OpenGL </td></tr><tr><td>  azul </td><td>  unsigned int </td><td>  8 </td><td>  El n√∫mero de bits de azul en el b√∫fer de color OpenGL </td></tr><tr><td>  alfa </td><td>  unsigned int </td><td>  8 </td><td>  El n√∫mero de bits en el b√∫fer alfa OpenGL </td></tr><tr><td>  profundidad </td><td>  unsigned int </td><td>  24 </td><td>  El n√∫mero de bits en el b√∫fer de profundidad OpenGL </td></tr><tr><td>  plantilla </td><td>  unsigned int </td><td>  0 0 </td><td>  El n√∫mero de bits en el b√∫fer de galer√≠a de s√≠mbolos OpenGL </td></tr><tr><td>  doubleBuffer </td><td>  bool </td><td>  falso </td><td>  Usar doble tamp√≥n </td></tr><tr><td>  muestras </td><td>  unsigned int </td><td>  0 0 </td><td>  N√∫mero de suavizado primitivo </td></tr><tr><td>  quadBufferStereo </td><td>  bool </td><td>  falso </td><td>  Utilice un b√∫fer est√©reo cu√°druple (para equipos NVidia) </td></tr><tr><td>  inheritedWindowData </td><td>  osg :: ref_ptr </td><td>  Nulo </td><td>  Descriptor de datos asociado a la ventana </td></tr></tbody></table><br>  Para inicializar el objeto Traits, ejecute el siguiente c√≥digo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">100</span></span>; ...</code> </pre><br><h1>  4. Configure la ventana de la aplicaci√≥n OSG </h1><br>  Para crear una ventana con las caracter√≠sticas especificadas, debe realizar los siguientes pasos: <br><br><ol><li>  Configure un objeto de tipo osg :: GraphicsContext :: Traits <br></li><li>  Crear un contexto de ventana gr√°fica <br></li><li>  Enlace este contexto gr√°fico a la c√°mara <br></li><li>  Haz de la c√°mara el espectador principal <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de rasgos</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/GraphicsContext&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;x = 50; traits-&gt;y = 50; traits-&gt;width = 800; traits-&gt;height = 600; traits-&gt;windowName = "OSG application"; traits-&gt;windowDecoration = true; traits-&gt;doubleBuffer = true; traits-&gt;samples = 4; osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setGraphicsContext(gc); camera-&gt;setViewport( new osg::Viewport(0, 0, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(0.2f, 0.2f, 0.4f, 1.0f) ); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Para establecer las preferencias de la ventana, cree una instancia de la clase osg :: GraphicsContext :: Traits e inicial√≠cela con los par√°metros que necesitamos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;width = <span class="hljs-number"><span class="hljs-number">800</span></span>; traits-&gt;height = <span class="hljs-number"><span class="hljs-number">600</span></span>; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">"OSG application"</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;samples = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Despu√©s de eso, creamos un contexto gr√°fico pasando un puntero a los rasgos como la configuraci√≥n <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get());</code> </pre><br>  Crear una c√°mara <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera;</code> </pre><br>  Asociamos la c√°mara con el contexto gr√°fico creado. <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gc);</code> </pre><br>  Configure la ventana gr√°fica, configure la m√°scara de limpieza del b√∫fer, configure el color de limpieza <br><br><pre> <code class="cpp hljs">camera-&gt;setViewport( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Viewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) );</code> </pre><br>  Configurar una matriz de proyecci√≥n en perspectiva <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  No olvide habilitar la prueba de profundidad, para la correcta visualizaci√≥n de caras. <br><br><pre> <code class="cpp hljs">camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);</code> </pre><br>  Cargando modelo de avi√≥n <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Configuramos y lanzamos el visor, indicando la c√°mara que configuramos en la calidad de la c√°mara principal. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  A la salida tenemos una ventana con los par√°metros requeridos. <br><br><img src="https://habrastorage.org/webt/rs/av/d-/rsavd-z8aawrwpykioblv1kxsni.png"><br><br>  El t√≠tulo de la ventana no se muestra porque esta funci√≥n est√° deshabilitada en la configuraci√≥n de mi administrador de ventanas.  Si ejecuta el ejemplo en Windows o Linux con configuraciones diferentes, el encabezado estar√° en su lugar. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437764/">https://habr.com/ru/post/437764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437752/index.html">PHP Digest No. 148 (14-28 de enero de 2019)</a></li>
<li><a href="../437754/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 349 (21-27 de enero de 2019)</a></li>
<li><a href="../437756/index.html">Frontend Weekly Digest (21‚Äì27 de enero de 2019)</a></li>
<li><a href="../437758/index.html">Estad√≠sticas interesantes de 100,000 perfiles con Stack Overflow para 2018 (y habraopros)</a></li>
<li><a href="../437760/index.html">Configuraci√≥n de VSCODE para desarrollo para ARM usando la placa de depuraci√≥n stm32f429i-disco como ejemplo</a></li>
<li><a href="../437766/index.html">28 de enero: D√≠a Internacional para la Protecci√≥n de Datos Personales</a></li>
<li><a href="../437768/index.html">KnowledgeConf: es hora de compartir conocimiento</a></li>
<li><a href="../437772/index.html">Los dragones viven aqu√≠: la matriz de competencias como herramienta del Timlid</a></li>
<li><a href="../437774/index.html">Gitpab Gusto en conocerte</a></li>
<li><a href="../437778/index.html">El cuento de la aleaci√≥n rosa y el Krenka ca√≠do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>