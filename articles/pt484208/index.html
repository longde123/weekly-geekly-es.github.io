<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÅ üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üëç Usando o aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa üí¥ üëßüèø ü§∞üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O aprendizado de m√°quina est√° profundamente enraizado em v√°rias √°reas da atividade humana: do reconhecimento de fala ao diagn√≥stico m√©dico. A populari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando o aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Usando o aprendizado da m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa"></div><br>  O aprendizado de m√°quina est√° profundamente enraizado em v√°rias √°reas da atividade humana: do reconhecimento de fala ao diagn√≥stico m√©dico.  A popularidade dessa abordagem √© t√£o grande que eles tentam us√°-la sempre que poss√≠vel.  Algumas tentativas de substituir as abordagens cl√°ssicas por redes neurais n√£o s√£o t√£o bem-sucedidas.  Vamos dar uma olhada no aprendizado de m√°quina do ponto de vista da cria√ß√£o de analisadores de c√≥digo est√°tico eficazes para encontrar bugs e poss√≠veis vulnerabilidades. <br><a name="habracut"></a><br>  A equipe do PVS-Studio √© frequentemente questionada se queremos come√ßar a usar o aprendizado de m√°quina para encontrar erros no c√≥digo fonte dos programas.  Resposta curta: sim, mas muito limitada.  Acreditamos que, com o uso do aprendizado de m√°quina em problemas de an√°lise de c√≥digo, existem muitas armadilhas.  Na segunda parte do artigo, falaremos sobre eles.  Vamos come√ßar com uma revis√£o de novas solu√ß√µes e id√©ias. <br><br><h2>  Novas abordagens </h2><br>  Atualmente, j√° existem muitas implementa√ß√µes de analisadores est√°ticos baseados em ou usando aprendizado de m√°quina, incluindo aprendizado profundo e PNL para detec√ß√£o de erros.  N√£o apenas os entusiastas, mas tamb√©m as grandes empresas, como Facebook, Amazon ou Mozilla, chamaram a aten√ß√£o para o potencial do aprendizado de m√°quina ao procurar erros.  Alguns projetos n√£o s√£o analisadores est√°ticos completos, mas apenas encontram erros espec√≠ficos durante as confirma√ß√µes. <br><br>  Curiosamente, quase todos est√£o posicionados como produtos que mudam o jogo que, com a ajuda da intelig√™ncia artificial, mudar√£o o processo de desenvolvimento. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Considere alguns exemplos conhecidos: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Origem {d} </li><li>  Assistente inteligente de confirma√ß√£o, confirma√ß√£o </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  O Deep Code √© uma ferramenta de busca de vulnerabilidades no c√≥digo de programas escritos em Java, JavaScript, TypeScript e Python, nos quais o aprendizado de m√°quina est√° presente como um componente.  Segundo Boris Paskalev, mais de 250 mil regras j√° funcionam.  Essa ferramenta √© treinada com base nas altera√ß√µes feitas pelos desenvolvedores no c√≥digo fonte de projetos abertos (um milh√£o de reposit√≥rios).  A pr√≥pria empresa diz que o projeto deles √© Grammarly para desenvolvedores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  Em ess√™ncia, este analisador compara sua solu√ß√£o com seu banco de dados de projetos e oferece a melhor solu√ß√£o estimada com a experi√™ncia de outros desenvolvedores. <br><br>  Em maio de 2018, os desenvolvedores escreveram que o suporte √† linguagem C ++ estava sendo preparado, no entanto, essa linguagem ainda n√£o √© suportada.  Embora seja indicado no pr√≥prio site que um novo idioma pode ser adicionado em quest√£o de semanas, devido ao fato de que apenas uma etapa depende da an√°lise do idioma. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Um grupo de publica√ß√µes sobre os m√©todos nos quais o analisador se baseia tamb√©m √© publicado no site. <br><br><h3>  Inferir </h3><br>  O Facebook est√° tentando amplamente introduzir novas abordagens em seus produtos.  Eles n√£o ignoraram sua aten√ß√£o e aprendizado de m√°quina.  Em 2013, eles compraram uma startup que estava desenvolvendo um analisador est√°tico baseado em m√°quina.  E em 2015, o c√≥digo fonte do projeto <a href="https://github.com/facebook/infer">tornou-se aberto</a> . <br><br>  Infer √© um analisador est√°tico para projetos escritos em Java, C, C ++ e Objective-C, desenvolvidos pelo Facebook.  Segundo o site, ele tamb√©m √© usado no Amazon Web Services, Oculus, Uber e outros projetos populares. <br><br>  O Infer atualmente √© capaz de detectar erros relacionados √† desreferencia√ß√£o de um ponteiro nulo, vazamentos de mem√≥ria.  Infer baseia-se na l√≥gica de Hoar, l√≥gica de separa√ß√£o e bi-abdu√ß√£o, bem como na teoria da interpreta√ß√£o abstrata.  O uso dessas abordagens permite ao analisador dividir o programa em pequenos blocos (peda√ßos) e analis√°-los independentemente um do outro. <br><br>  Voc√™ pode tentar usar o Infer em seus projetos, no entanto, os desenvolvedores alertam que, embora em projetos do Facebook, os hits √∫teis representem 80% dos resultados, em outros projetos, um n√∫mero baixo de falsos positivos n√£o √© garantido.  Alguns dos erros que a Infer ainda n√£o conseguiu encontrar, mas os desenvolvedores est√£o trabalhando na introdu√ß√£o desses gatilhos: <br><br><ul><li>  saindo da matriz; </li><li>  exce√ß√µes tipogr√°ficas; </li><li>  vazamento de dados n√£o verificados; </li><li>  condi√ß√£o de corrida. </li></ul><br><h3>  Sapfix </h3><br>  SapFix √© uma ferramenta de edi√ß√£o automatizada.  Ele recebe informa√ß√µes da Sapienz, uma ferramenta de automa√ß√£o de teste e do analisador est√°tico Infer, e com base nas altera√ß√µes e mensagens mais recentes, o Infer escolhe uma das v√°rias estrat√©gias para corrigir erros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Em alguns casos, o SapFix reverte todas ou parte das altera√ß√µes.  Em outros casos, ele tenta resolver o problema gerando um patch a partir de seu conjunto de padr√µes de corre√ß√£o.  Esse conjunto √© formado a partir dos modelos de edi√ß√£o compilados pelos pr√≥prios programadores a partir do conjunto de edi√ß√µes j√° feitas uma vez.  Se esse modelo n√£o corrigir o erro, o SapFix tentar√° ajust√°-lo √† situa√ß√£o, fazendo pequenas modifica√ß√µes na √°rvore de sintaxe abstrata at√© encontrar uma solu√ß√£o em potencial. <br><br>  Mas como uma solu√ß√£o em potencial n√£o √© suficiente, o SapFix coleta v√°rias solu√ß√µes selecionadas com base em tr√™s perguntas: existem erros de compila√ß√£o, h√° um travamento, a edi√ß√£o introduz novos travamentos.  Ap√≥s as edi√ß√µes serem totalmente testadas, as corre√ß√µes s√£o enviadas para revis√£o ao programador que decide qual das edi√ß√µes melhor resolve o problema. <br><br><h3>  Embold </h3><br>  O Embold √© uma plataforma de inicializa√ß√£o para an√°lise est√°tica do c√≥digo fonte dos programas, que antes da renomea√ß√£o era chamada Gamma.  A an√°lise est√°tica √© realizada com base em nossos pr√≥prios diagn√≥sticos, bem como com base em analisadores internos, como Cppheck, SpotBugs, SQL Check e outros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Al√©m dos pr√≥prios diagn√≥sticos, a √™nfase est√° na capacidade de exibir visualmente os infogr√°ficos pela carga da base de c√≥digo e visualizar convenientemente os erros encontrados, bem como procurar refatora√ß√£o.  Al√©m disso, esse analisador possui um conjunto de antipadr√µes que permite detectar problemas na estrutura do c√≥digo no n√≠vel de classes e m√©todos, al√©m de v√°rias m√©tricas para calcular a qualidade do sistema. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Uma das principais vantagens √© o sistema inteligente de sugest√µes de solu√ß√µes e revis√µes, que, al√©m dos diagn√≥sticos usuais, verifica as revis√µes com base em informa√ß√µes sobre altera√ß√µes anteriores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Usando a PNL, o Embold divide o c√≥digo em partes e procura interconex√µes e depend√™ncias entre fun√ß√µes e m√©todos entre elas, o que economiza tempo de refatora√ß√£o. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Assim, o Embold oferece principalmente uma visualiza√ß√£o conveniente dos resultados da an√°lise do seu c√≥digo-fonte por v√°rios analisadores, bem como seus pr√≥prios diagn√≥sticos, alguns dos quais baseados no aprendizado de m√°quina. <br><br><h3>  Origem {d} </h3><br>  A fonte {d} √© a mais aberta em termos de como implement√°-la nos analisadores que examinamos.  √â tamb√©m uma <a href="https://github.com/src-d/sourced-ce">solu√ß√£o de c√≥digo aberto</a> .  No site deles, voc√™ pode (em troca do seu endere√ßo de e-mail) obter um livreto com uma descri√ß√£o das tecnologias que eles usam.  Al√©m disso, ele cont√©m um <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">link</a> para a base de publica√ß√£o que eles coletaram relacionados ao uso de aprendizado de m√°quina para an√°lise de c√≥digo, al√©m de um <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">reposit√≥rio</a> com um conjunto de dados para treinamento em c√≥digo.  O produto em si √© uma plataforma inteira para analisar o c√≥digo-fonte e o software, e se concentra, n√£o nos desenvolvedores, mas no link dos gerentes.  Entre suas capacidades, h√° uma funcional para identificar o volume de d√≠vida t√©cnica, gargalos no processo de desenvolvimento e outras estat√≠sticas globais do projeto. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Eles baseiam sua abordagem da an√°lise de c√≥digo assistida por m√°quina na Hip√≥tese Natural, formulada no artigo " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sobre a naturalidade do software</a> ". <br><br>  <i>‚ÄúAs linguagens de programa√ß√£o, em teoria, s√£o complexas, flex√≠veis e poderosas, mas os programas que as pessoas reais realmente escrevem s√£o, na maioria das vezes, simples e razoavelmente repetitivos e, portanto, possuem propriedades estat√≠sticas √∫teis e previs√≠veis que podem ser expressas em estat√≠sticas. modelos de linguagem e uso para tarefas de desenvolvimento de software. ‚Äù</i> <br><br>  Com base nessa hip√≥tese, quanto maior a base de c√≥digo para o treinamento do analisador, mais propriedades estat√≠sticas se destacam e maior a precis√£o das m√©tricas alcan√ßadas pelo treinamento. <br><br>  Para analisar o c√≥digo, a origem {d} usa o servi√ßo Babelfish, que pode analisar o arquivo de c√≥digo em qualquer um dos idiomas dispon√≠veis, obter uma √°rvore de sintaxe abstrata e convert√™-lo em uma √°rvore de sintaxe universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  No entanto, a fonte {d} n√£o procura erros no c√≥digo.  Com base na √°rvore, usando o aprendizado de m√°quina com base em todo o projeto, a fonte {d} revela como o c√≥digo √© formatado, qual estilo de codifica√ß√£o √© usado no projeto e ao confirmar, e se o novo c√≥digo n√£o corresponder ao estilo de c√≥digo do projeto, ele far√° as altera√ß√µes apropriadas. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  O treinamento √© guiado por v√°rios elementos b√°sicos: espa√ßos, guias, quebras de linha etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Voc√™ pode ler mais sobre isso em sua publica√ß√£o: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: corrigindo inconsist√™ncias de estilo de c√≥digo com algoritmos n√£o supervisionados interpret√°veis</a> ". <br><br>  Em geral, a fonte {d} √© uma ampla plataforma para coletar uma ampla variedade de estat√≠sticas sobre o c√≥digo-fonte e o processo de desenvolvimento do projeto, desde o c√°lculo da efic√°cia dos desenvolvedores at√© a identifica√ß√£o dos custos de tempo para as revis√µes de c√≥digo. <br><br><h3>  Confirma√ß√£o inteligente </h3><br>  O Clever-Commit √© um analisador criado pela Mozilla em colabora√ß√£o com a Ubisoft.  Ele √© baseado no estudo <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> da Ubisoft (Combinando n√≠veis de t√©cnicas de preven√ß√£o e resolu√ß√£o de bugs) e em seu Commit Assistant baseado em produto, que identifica confirma√ß√µes suspeitas que provavelmente cont√™m um erro.  Devido ao fato de o CLEVER se basear na compara√ß√£o de c√≥digos, ele n√£o apenas indica um c√≥digo perigoso, mas tamb√©m faz sugest√µes sobre poss√≠veis corre√ß√µes.  De acordo com a descri√ß√£o, em 60-70% dos casos, o Clever-Commit encontra √°reas problem√°ticas e com a mesma frequ√™ncia oferece corre√ß√µes corretas para elas.  Em geral, h√° pouca informa√ß√£o sobre esse projeto e sobre os erros que ele consegue encontrar. <br><br><h3>  CodeGuru </h3><br>  E, mais recentemente, a lista de analisadores que usam aprendizado de m√°quina foi reabastecida com um produto da Amazon chamado CodeGuru.  Este servi√ßo √© baseado no aprendizado de m√°quina, que permite encontrar erros no c√≥digo e identificar se√ß√µes dispendiosas.  At√© agora, a an√°lise √© apenas para c√≥digo Java, mas eles escrevem sobre o suporte a outras linguagens no futuro.  Embora tenha sido anunciado recentemente, o CEO da AWS (Amazon Web Services), Andy Jassi, diz que o usa h√° muito tempo na pr√≥pria Amazon. <br><br>  O site diz que o treinamento foi realizado na base de c√≥digo da pr√≥pria Amazon, bem como em mais de 10.000 projetos de c√≥digo aberto. <br><br>  De fato, o servi√ßo √© dividido em duas partes: CodeGuru Reviewer, treinado pela pesquisa de regras associativas e pela procura de erros no c√≥digo, e CodeGuru Profiler, que monitora o desempenho do aplicativo. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Em geral, poucas informa√ß√µes foram publicadas sobre este projeto.  O site afirma que, para aprender a detectar desvios das "melhores pr√°ticas", o Reviewer analisa as bases de c√≥digo da Amazon e procura solicita√ß√µes de recebimento contendo chamadas da API da AWS.  Em seguida, ele analisa as altera√ß√µes feitas e as compara com os dados da documenta√ß√£o, que √© analisada em paralelo.  O resultado √© um modelo de "melhores pr√°ticas". <br><br>  Tamb√©m √© dito que as recomenda√ß√µes para c√≥digo personalizado melhoram depois de receber feedback sobre as recomenda√ß√µes. <br><br>  A lista de erros aos quais o Revisor responde √© bastante borrada, pois nenhuma documenta√ß√£o espec√≠fica para erros foi publicada: <ul><li>  Pr√°ticas recomendadas da AWS </li><li>  Concorr√™ncia </li><li>  Vazamentos de recursos </li><li>  Vazamento de informa√ß√µes confidenciais </li><li>  "Pr√°ticas recomendadas" comuns para codifica√ß√£o </li></ul><br><h2>  Nosso ceticismo </h2><br>  Agora, vamos analisar o problema de encontrar erros atrav√©s dos olhos de nossa equipe, que desenvolve analisadores est√°ticos h√° muitos anos.  Vemos v√°rios problemas de alto n√≠vel na aplica√ß√£o do treinamento, sobre os quais queremos falar.  Por√©m, no come√ßo, dividimos aproximadamente todas as abordagens de ML em dois tipos: <br><br><ol><li>  Treine manualmente um analisador est√°tico para procurar v√°rios problemas usando exemplos de c√≥digo sint√©tico e real; </li><li>  Treine os algoritmos em um grande n√∫mero de c√≥digo-fonte aberto (GitHub) e altere o hist√≥rico, ap√≥s o qual o pr√≥prio analisador come√ßar√° a detectar erros e at√© sugerir corre√ß√µes. </li></ol><br>  Falaremos sobre cada dire√ß√£o separadamente, pois elas ter√£o v√°rias defici√™ncias inerentes.  Depois disso, acho que ficar√° claro para os leitores por que n√£o negamos a possibilidade de aprendizado de m√°quina, mas tamb√©m n√£o compartilhamos entusiasmo. <br><br>  <b>Nota</b>  Analisamos a perspectiva de desenvolver um analisador est√°tico universal de uso geral.  Nosso foco √© o desenvolvimento de um analisador que n√£o se concentre em uma base de c√≥digo espec√≠fica, mas que qualquer equipe possa usar em qualquer projeto. <br><br><h3>  Treinamento manual do analisador de est√°tica </h3><br>  Suponha que desejemos usar o ML para que o analisador comece a procurar anomalias no seguinte formato no c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  √â estranho comparar uma vari√°vel consigo mesma.  Podemos escrever muitos exemplos de c√≥digo correto e incorreto e treinar o analisador para procurar esses erros.  Al√©m disso, √© poss√≠vel adicionar exemplos reais de erros j√° encontrados nos testes.  A quest√£o, √© claro, √© onde conseguir esses exemplos.  Mas consideraremos que √© poss√≠vel.  Por exemplo, acumulamos v√°rios exemplos desses erros: <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Portanto, √© poss√≠vel procurar esses defeitos no c√≥digo usando algoritmos de aprendizado de m√°quina?  Voc√™ pode.  Mas n√£o est√° claro por que fazer isso! <br><br>  Veja, para treinar o analisador, precisamos dedicar muito esfor√ßo na prepara√ß√£o de exemplos para treinamento.  Ou marque o c√≥digo de aplicativos reais, indicando onde jurar e onde n√£o.  De qualquer forma, muito trabalho ter√° que ser feito, pois deve haver milhares de exemplos de treinamento.  Ou dezenas de milhares. <br><br>  Afinal, queremos procurar n√£o apenas casos (A == A), mas tamb√©m: <br><br><ul><li>  if (X e&amp;A == A) </li><li>  if (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  se ((A) == (A)) </li><li>  e assim por diante. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Agora vamos ver como um diagn√≥stico t√£o simples seria implementado no PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  E √© isso.  Nenhuma base de treinamento de amostra √© necess√°ria! <br><br>  No futuro, os diagn√≥sticos devem ser ensinados para levar em considera√ß√£o v√°rias exce√ß√µes e entender que voc√™ precisa jurar em (A [0] == A [1-1]).  No entanto, tudo isso √© muito f√°cil de programar.  Mas apenas com a base de exemplos de treinamento, tudo ser√° ruim. <br><br>  Observe que em ambos os casos ainda ser√° necess√°rio um sistema de teste, documenta√ß√£o de reda√ß√£o etc.  No entanto, o esfor√ßo para criar um novo diagn√≥stico est√° claramente do lado da abordagem cl√°ssica, onde a regra √© simplesmente codificada no c√≥digo. <br><br>  Vamos olhar agora para alguma outra regra.  Por exemplo, que o resultado de algumas fun√ß√µes deve ser usado.  N√£o faz sentido cham√°-los sem usar o resultado.  Aqui est√£o alguns desses recursos: <ul><li>  malloc </li><li>  memcmp </li><li>  string :: vazio </li></ul><br>  Em geral, √© isso que os diagn√≥sticos do <a href="https://www.viva64.com/ru/w/v530/">V530</a> implementados no PVS-Studio <a href="https://www.viva64.com/ru/w/v530/">fazem</a> . <br><br>  Portanto, queremos procurar chamadas para essas fun√ß√µes em que o resultado de seu trabalho n√£o seja usado.  Para fazer isso, voc√™ pode gerar muitos testes.  E achamos que tudo vai funcionar bem.  Mas, novamente, n√£o est√° claro por que isso √© necess√°rio. <br><br>  A implementa√ß√£o do diagn√≥stico V530 com todas as exce√ß√µes no analisador PVS-Studio √© de 258 linhas de c√≥digo, das quais 64 s√£o coment√°rios.  Al√©m disso, h√° uma tabela com anota√ß√µes de fun√ß√µes, onde se observa que o resultado delas deve ser usado.  Reabastecer esta tabela √© muito mais f√°cil do que criar exemplos sint√©ticos. <br><br>  A situa√ß√£o ser√° ainda pior com diagn√≥sticos que usam an√°lise de fluxo de dados.  Por exemplo, o analisador PVS-Studio pode rastrear o valor dos ponteiros, o que permite encontrar esse vazamento de mem√≥ria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Um exemplo √© retirado do artigo " <a href="https://www.viva64.com/ru/b/0555/">Chromium: memory leaks</a> ".  Se a condi√ß√£o <i>(pkey.n0inv == 0) for atendida</i> , a fun√ß√£o sair√° sem liberar o buffer, cujo ponteiro est√° armazenado na vari√°vel <i>n</i> . <br><br>  Do ponto de vista do PVS-Studio, n√£o h√° nada complicado.  O analisador estudou a fun√ß√£o <i>BnNew</i> e lembrou que ele retorna um ponteiro para um bloco de mem√≥ria alocada.  Em outra fun√ß√£o, ele notou que √© poss√≠vel uma situa√ß√£o em que o buffer n√£o √© liberado e o ponteiro para ele √© perdido quando a fun√ß√£o sai. <br><br>  Um algoritmo de rastreamento de valor geral funciona.  N√£o importa como o c√≥digo est√° escrito.  N√£o importa o que mais h√° na fun√ß√£o que n√£o esteja relacionada ao trabalho com ponteiros.  O algoritmo √© universal e o diagn√≥stico do V773 encontra muitos erros em v√°rios projetos.  Veja como os <a href="https://www.viva64.com/ru/examples/v773/">fragmentos de c√≥digo</a> s√£o diferentes onde os erros s√£o detectados! <br><br>  N√£o somos especialistas em aprendizado de m√°quina, mas parece que haver√° grandes problemas.  Existem in√∫meras maneiras de escrever c√≥digo com vazamentos de mem√≥ria.  Mesmo que a m√°quina seja treinada para rastrear o valor das vari√°veis, ser√° necess√°rio trein√°-la para entender que existem chamadas de fun√ß√£o. <br><br>  H√° uma suspeita de que tantos exemplos ser√£o necess√°rios para o treinamento que a tarefa se torna assustadora.  N√£o dizemos que √© irrealiz√°vel.  Duvidamos que os custos de cria√ß√£o de um analisador sejam compensadores. <br><br>  <b>Analogia.</b>  Uma analogia vem √† mente com uma calculadora, onde, em vez de diagn√≥sticos, √© necess√°rio programar opera√ß√µes aritm√©ticas.  Temos certeza de que voc√™ pode ensinar uma calculadora baseada em ML a adicionar n√∫meros, introduzindo uma base de conhecimento sobre o resultado das opera√ß√µes 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 e assim por diante.  Como voc√™ sabe, a conveni√™ncia de desenvolver essa calculadora √© uma grande quest√£o (se uma subven√ß√£o n√£o for alocada para ela :).  Uma calculadora muito mais simples, r√°pida, precisa e confi√°vel pode ser escrita usando a opera√ß√£o "+" comum no c√≥digo. <br><br>  <b>Conclus√£o</b>  O m√©todo ir√° funcionar.  Mas us√°-lo, em nossa opini√£o, n√£o faz sentido pr√°tico.  O desenvolvimento consumir√° mais tempo e o resultado ser√° menos confi√°vel e preciso, principalmente se se tratar da implementa√ß√£o de diagn√≥sticos complexos com base na an√°lise do fluxo de dados. <br><br><h3>  Aprendendo com muita fonte aberta </h3><br>  Bem, descobrimos exemplos sint√©ticos manuais, mas existe o GitHub.  Voc√™ pode acompanhar o hist√≥rico de confirma√ß√µes e derivar padr√µes de altera√ß√µes / corre√ß√µes de c√≥digo.  Depois, voc√™ pode apontar n√£o apenas se√ß√µes do c√≥digo suspeito, mas at√© sugerir uma maneira de corrigi-lo. <br><br>  Se voc√™ parar nesse n√≠vel de detalhe, tudo ficar√° bem.  O diabo, como sempre, est√° nos detalhes.  Vamos falar sobre esses detalhes. <br><br>  <b>A primeira nuance.</b>  <b>Fonte de dados.</b> <br><br>  As edi√ß√µes no GitHub s√£o bastante ca√≥ticas e variadas.  As pessoas costumam ter pregui√ßa de fazer confirma√ß√µes at√¥micas e fazer v√°rias altera√ß√µes no c√≥digo de uma s√≥ vez.  Voc√™ mesmo sabe como isso acontece: eles corrigiram o erro e, ao mesmo tempo, refatoraram um pouco ("E aqui vou adicionar o processamento de um caso desse tipo ao mesmo tempo ...").  Mesmo assim, pode n√£o estar claro para uma pessoa se essas altera√ß√µes est√£o relacionadas ou n√£o. <br><br>  O problema √© como distinguir os erros reais da adi√ß√£o de novas funcionalidades ou outra coisa.  Obviamente, voc√™ pode plantar 1.000 pessoas manualmente para marcar confirma√ß√µes.  As pessoas ter√£o que indicar que corrigiram o erro aqui, refatorando aqui, nova funcionalidade aqui, requisitos alterados aqui e assim por diante. <br><br>  Essa marca√ß√£o √© poss√≠vel?  Poss√≠vel.  Mas preste aten√ß√£o na rapidez com que a mudan√ßa ocorre.  Em vez de "aprender o pr√≥prio algoritmo com base no GitHub", j√° estamos discutindo como confundir centenas de pessoas por um longo tempo.  Os custos de m√£o-de-obra e o custo de criar uma ferramenta aumentam bastante. <br><br>  Voc√™ pode tentar identificar automaticamente onde exatamente os erros foram corrigidos.  Para fazer isso, voc√™ deve analisar os coment√°rios sobre confirma√ß√µes, prestar aten√ß√£o √†s pequenas edi√ß√µes locais, que, provavelmente, s√£o exatamente a revis√£o de erros.  √â dif√≠cil dizer o qu√£o bem voc√™ pode procurar automaticamente por corre√ß√µes de bugs.  De qualquer forma, essa √© uma grande tarefa que requer pesquisa e programa√ß√£o separadas. <br><br>  Portanto, ainda n√£o atingimos o treinamento, mas j√° existem nuances :). <br><br>  <b>A segunda nuance.</b>  <b>Atraso no desenvolvimento.</b> <br><br>  Os analisadores que ser√£o treinados com base em bancos de dados como o GitHub sempre estar√£o sujeitos a uma s√≠ndrome como "retardo mental".  Isso ocorre porque as linguagens de programa√ß√£o mudam com o tempo. <br><br>  O C # 8.0 <a href="https://www.viva64.com/ru/b/0631/">introduziu os</a> tipos de Refer√™ncia Nula para ajudar a lidar com as Exce√ß√µes de Refer√™ncia Nula (NREs).  O JDK 12 apresenta uma nova instru√ß√£o switch ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  No C ++ 17, tornou-se poss√≠vel executar constru√ß√µes condicionais no est√°gio de compila√ß√£o ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  E assim por diante <br><br>  Linguagens de programa√ß√£o est√£o evoluindo.  Al√©m disso, como o C ++, s√£o muito r√°pidos e ativos.  Novos designs aparecem neles, novas fun√ß√µes padr√£o s√£o adicionadas e assim por diante.  Juntamente com os novos recursos, tamb√©m aparecem novos padr√µes de erro que gostar√≠amos de identificar usando a an√°lise de c√≥digo est√°tica. <br><br>  E aqui o m√©todo de ensino em quest√£o tem um problema: o padr√£o de erro j√° pode ser conhecido, existe um desejo de identific√°-lo, mas n√£o h√° nada com o que aprender. <br><br>  Vejamos esse problema com um exemplo espec√≠fico.  O loop for baseado em intervalo apareceu no C ++ 11.  E voc√™ pode escrever o seguinte c√≥digo, repetindo todos os elementos no cont√™iner: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  O novo ciclo trouxe um novo padr√£o de erro.  Se o cont√™iner for alterado dentro do loop, isso levar√° √† invalida√ß√£o dos iteradores "shadow". <br><br>  Considere o seguinte c√≥digo incorreto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  O compilador ir√° transform√°-lo em algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Durante a opera√ß√£o <i>push_back</i> , a <i>invalida√ß√£o dos</i> iteradores <i>__begin</i> e <i>__end</i> pode ocorrer se ocorrer aloca√ß√£o de mem√≥ria dentro do vetor.  O resultado ser√° um comportamento indefinido do programa. <br><br>  Portanto, o padr√£o de erro j√° √© conhecido e descrito na literatura.  O analisador PVS-Studio o diagnostica usando o diagn√≥stico <a href="https://www.viva64.com/ru/w/v789/">V789</a> e j√° encontrou <a href="https://www.viva64.com/ru/examples/v789/">erros reais</a> em projetos abertos. <br><br>  Em quanto tempo haver√° c√≥digo novo suficiente no GitHub para perceber esse padr√£o?  Boa pergunta ... Voc√™ precisa entender que, se o loop for baseado em intervalo aparecer, isso n√£o significa que todos os programadores come√ßaram imediatamente a us√°-lo em massa.  Pode levar anos at√© que muito c√≥digo apare√ßa usando um novo loop.  Al√©m disso, muitos erros devem ser cometidos e, em seguida, devem ser corrigidos para que o algoritmo possa observar o padr√£o nas altera√ß√µes. <br><br>  Quantos anos devem passar?  Cinco?  Dez? <br><br>  Dez √© demais e somos pessimistas?  Nem um pouco.  Oito anos se passaram no momento em que este artigo foi escrito, pois o loop for baseado em intervalo apareceu no C ++ 11.  Mas at√© agora, apenas <a href="https://www.viva64.com/ru/examples/v789/">tr√™s casos</a> desse erro foram gravados em nosso banco de dados.  Tr√™s erros n√£o s√£o muitos e nem um pouco.  Nenhuma conclus√£o deve ser tirada do seu n√∫mero.  O principal √© que voc√™ pode confirmar que esse padr√£o de erro √© real e faz sentido detect√°-lo. <br><br>  Agora compare essa quantidade, por exemplo, com este padr√£o de erro: o <a href="https://www.viva64.com/ru/examples/v595/">ponteiro √© desreferenciado antes da verifica√ß√£o</a> .  No total, ao verificar projetos de c√≥digo aberto, j√° identificamos 1716 casos. <br><br>  Talvez voc√™ n√£o deva procurar erros de loop com base no intervalo?  N√£o.  Apenas os programadores s√£o inerciais, e esse operador est√° lentamente ganhando popularidade.  Gradualmente, haver√° muito c√≥digo com sua participa√ß√£o e, consequentemente, tamb√©m haver√° mais erros. <br><br>  Provavelmente, isso acontecer√° somente ap√≥s 10 a 15 anos a partir do momento em que o C ++ 11 apareceu.  E agora uma pergunta filos√≥fica.  J√° conhecendo o padr√£o de erro, esperaremos muitos anos at√© que muitos erros se acumulem em projetos abertos? <br><br>  Se a resposta for "sim", √© poss√≠vel diagnosticar razoavelmente para todos os analisadores com base no ML o diagn√≥stico "retardo mental". <br><br>  Se a resposta for n√£o, ent√£o o que devo fazer?  N√£o h√° exemplos.  Para escrev√™-los manualmente?  Mas ent√£o voltamos ao cap√≠tulo anterior, onde consideramos escrever uma pessoa para muitos exemplos de aprendizado. <br><br>  Isso pode ser feito, mas novamente surge a quest√£o da conveni√™ncia.  A implementa√ß√£o do diagn√≥stico V789 com todas as exce√ß√µes no analisador PVS-Studio √© de apenas 118 linhas de c√≥digo, das quais 13 s√£o coment√°rios.  I.e.  Este √© um diagn√≥stico muito simples que pode ser facilmente obtido e programado de maneira cl√°ssica. <br><br>  Uma situa√ß√£o semelhante ocorrer√° com outras inova√ß√µes que aparecerem em outros idiomas.  Como se costuma dizer, h√° algo em que pensar. <br><br>  <b>A terceira nuance.</b>  <b>Documenta√ß√£o</b> <br><br>  Um componente importante de qualquer analisador est√°tico √© a documenta√ß√£o que descreve cada diagn√≥stico.  Sem ele, o uso do analisador ser√° extremamente dif√≠cil ou at√© imposs√≠vel.  Na <a href="https://www.viva64.com/ru/w/">documenta√ß√£o</a> do PVS-Studio, temos uma descri√ß√£o de cada diagn√≥stico, que fornece um exemplo de c√≥digo incorreto e como corrigi-lo.  H√° tamb√©m um link para o <a href="https://cwe.mitre.org/">CWE,</a> onde voc√™ pode ler uma descri√ß√£o alternativa do problema.  E, mesmo assim, √†s vezes algo √© incompreens√≠vel para os usu√°rios, e eles nos fazem perguntas esclarecedoras. <br><br>  No caso de analisadores est√°ticos, que s√£o baseados em algoritmos de aprendizado de m√°quina, o problema da documenta√ß√£o √©, de alguma forma, silencioso.  Sup√µe-se que o analisador simplesmente indique um local que lhe parece suspeito e, talvez, at√© sugira como consert√°-lo.  A decis√£o de fazer uma altera√ß√£o ou n√£o permanece com a pessoa.  E aqui ... ahem ... N√£o √© f√°cil tomar uma decis√£o, n√£o sendo capaz de ler, com base na qual o analisador parece desconfiar de um ou outro local no c√≥digo. <br><br>  Obviamente, em alguns casos, tudo ser√° √≥bvio.  Suponha que o analisador aponte para este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  E oferecer√° substitu√≠-lo por: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Fica imediatamente claro que o programador fechou e adicionou 1 ao lugar errado.  Como resultado, menos mem√≥ria ser√° alocada. <br><br>  Aqui, sem documenta√ß√£o, tudo est√° claro.  No entanto, esse nem sempre ser√° o caso. <br><br>  Imagine que o analisador silenciosamente aponte para este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  E sugere alterar o tipo do valor de retorno de char para int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  N√£o h√° documenta√ß√£o para o aviso.  E, aparentemente, o texto do aviso em si, como o entendemos, tamb√©m n√£o ser√°, se estivermos falando de um analisador completamente independente. <br><br>  O que fazer  Qual a diferen√ßa?  Devo fazer uma substitui√ß√£o? <br><br>  Em princ√≠pio, aqui voc√™ pode ter uma chance e concordar em corrigir o c√≥digo.  Embora aceite edi√ß√µes sem entend√™-las, essa √© uma pr√°tica mais ou menos ... :) Voc√™ pode examinar a descri√ß√£o da fun√ß√£o <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> e ler que a fun√ß√£o retorna <i>int</i> : 0 valores maiores que zero e menores que zero.  Mesmo assim, pode n√£o estar claro por que fazer altera√ß√µes se o c√≥digo j√° estiver funcionando com √™xito. <br><br>  Agora, se voc√™ n√£o sabe qual √© o objetivo dessa edi√ß√£o, leia a descri√ß√£o dos diagn√≥sticos do <a href="https://www.viva64.com/ru/w/v642/">V642</a> .  Torna-se imediatamente claro que este √© um erro real.  Al√©m disso, pode causar vulnerabilidade. <br><br>  Talvez o exemplo n√£o parecesse convincente.  Afinal, o analisador prop√¥s um c√≥digo que provavelmente seria melhor.  Ok  Vejamos outro exemplo de pseudoc√≥digo, desta vez, para uma mudan√ßa, em Java. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Existe algum tipo de objeto.  √â serializado.  O estado do objeto muda e √© serializado novamente.  Tudo parece estar bem.  Agora imagine que o analisador, de repente, n√£o gosta desse c√≥digo, e ele sugere substitu√≠-lo por: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Em vez de alterar o objeto e regrav√°-lo, um novo objeto √© criado e j√° est√° serializado. <br><br>  N√£o h√° descri√ß√£o do problema.  Nenhuma documenta√ß√£o.  O c√≥digo ficou mais longo.  Por alguma raz√£o, a cria√ß√£o de um novo objeto foi adicionada.  Voc√™ est√° pronto para fazer essa edi√ß√£o no seu c√≥digo? <br><br>  Voc√™ dir√° que n√£o est√° claro.  Na verdade, n√£o est√° claro.  E assim ser√° incompreens√≠vel o tempo todo.  Trabalhar com um analisador "silencioso" ser√° um estudo intermin√°vel, na tentativa de entender por que o analisador n√£o gosta de algo. <br><br>  Se houver documenta√ß√£o, tudo ficar√° transparente.  A classe <i>java.io.ObjectOuputStream</i> , usada para serializa√ß√£o, armazena em cache objetos grav√°veis.  Isso significa que o mesmo objeto n√£o ser√° serializado duas vezes.  Depois que a classe serializa o objeto, e na segunda vez, simplesmente grava um link no mesmo primeiro objeto no fluxo.  Leia mais: <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> - A serializa√ß√£o recorrente usar√° o estado do objeto em cache desde a primeira serializa√ß√£o. <br><br>  Esperamos poder explicar a import√¢ncia de ter documenta√ß√£o.  E agora a pergunta.  Como ser√° exibida a documenta√ß√£o para um analisador baseado em ML? <br><br>  Quando um analisador de c√≥digo cl√°ssico √© desenvolvido, tudo √© simples e claro.  H√° um certo padr√£o de erros.  N√≥s o descrevemos na documenta√ß√£o e implementamos o diagn√≥stico. <br><br>  No caso de ML, o oposto √© verdadeiro.  Sim, o analisador pode observar uma anomalia no c√≥digo e apontar para ele.  Mas ele n√£o sabe nada sobre a ess√™ncia do defeito.  Ele n√£o entende e n√£o diz por que o c√≥digo n√£o pode ser escrito assim.  Essas s√£o abstra√ß√µes de n√≠vel muito alto.  Em seguida, o analisador tamb√©m deve aprender a ler e <b>entender a</b> documenta√ß√£o para as fun√ß√µes. <br><br>  Como eu disse, como o t√≥pico da documenta√ß√£o √© abordado em artigos sobre aprendizado de m√°quina, n√£o estamos prontos para conversar mais.  Apenas outra grande nuance que trouxemos para revis√£o. <br><br>  <b>Nota</b>  Pode-se argumentar que a documenta√ß√£o √© opcional.  O analisador pode levar a muitos exemplos de corre√ß√µes no GitHub e uma pessoa, analisando confirma√ß√µes e coment√°rios sobre elas, descobrir√° o que √© o qu√™.  √â sim.  Mas a ideia n√£o parece atraente.  Em vez de um assistente, o analisador atua como uma ferramenta que ir√° confundir ainda mais o programador. <br><br>  <b>A quarta nuance.</b>  <b>Idiomas altamente especializados.</b> <br><br>  A abordagem descrita n√£o √© aplic√°vel a linguagens altamente especializadas para as quais a an√°lise est√°tica tamb√©m pode ser extremamente √∫til.  O motivo √© que o GitHub e outras fontes simplesmente n√£o t√™m uma base de c√≥digo fonte grande o suficiente para fornecer treinamento eficaz. <br><br>  Considere isso com um exemplo espec√≠fico.  Para come√ßar, acesse o GitHub e pesquise reposit√≥rios para a popular linguagem Java. <br><br>  Resultado: idioma: ‚ÄúJava‚Äù: <b>3.128.884</b> resultados dispon√≠veis do reposit√≥rio <br><br>  Agora vamos usar o idioma especializado "1C Enterprise" usado em aplicativos de contabilidade emitidos pela empresa russa <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Resultado: idioma: ‚Äú1C Enterprise‚Äù: <b>551</b> resultados dispon√≠veis no reposit√≥rio <br><br>  Talvez n√£o sejam necess√°rios analisadores para esse idioma?  S√£o necess√°rios.  Existe uma necessidade pr√°tica para a an√°lise de tais programas e j√° existem analisadores correspondentes.  Por exemplo, existe um plug-in SonarQube 1C (BSL) fabricado pela <a href="https://silverbulleters.org/">Silver Bullet</a> . <br><br> , -    ,          . <br><br> <b> . C, C++, #include</b> . <br><br> ,          ML,    ,  Java, JavaScript, Python.     .    C  C++ -  ,      . <br><br>    ,     /,   ,    C  C++  .    ¬´¬ª     . <br><br>  c/cpp-    .   ,      GitHub,  - cpp-    .   ,       ML. <br><br> ,    .    GitHub .     ,    .  ,         .  ,    .cpp-     . <br><br>     .    .    .     ,     ,        .       <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"></a> . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>        ,      <i>(x == ¬´y¬ª)</i>  strcmp(x, ¬´y¬ª)? <br><br>      ,  ,    <i>m_name</i>  .  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>      ,      .     ,          (  <i>std::string</i> ). <br><br>  ,  ,    .h .        ,     .  ,    C  C++. <br><br>  - ,     ,    ,       C  C++. <br><br>     ,    .    ,      ,      .    ,    cpp-. <br><br>     .       (,   ,     ).  ,    .      ,      ,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br>  ,     GitHub  .     ,    ,   .    -        .   -   ,    .     .           ¬´ ¬ª.    ,    ,     .cpp    (.i) .      . <br><br>  , ,     ,   .      ,   .       .      ,    -  , ,   . <br><br>  ,     .          .   C  C++  ,   GitHub,      .    ,     . <br><br> <b></b> .      ,      .   GitHub   C++       ,     .cpp    .         :). <br><br>       ,   C  C++   . <br><br> <b> .    .</b> <br><br>            ,    . <br><br>       <a href="https://www.viva64.com/ru/w/v789/">V789</a> ,     Range-based for loop. ,       ,      .  ,     ,      ,     .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br> ,  .         .  PVS-Studio      26  . <br><br>       ,      . ,   ,      ,    . <br><br>      ,   .  ,      ,   ,      ML.  I.e.           . <br><br> <b> .      .</b> <br><br>     ,         .       (, WinAPI,     ..). <br><br>        C,  <i>strcmp</i> ,      . GitHub, available code results: <br><br><ul><li> strcmp ‚Äî 40,462,158 </li><li> stricmp ‚Äî 1,256,053 </li></ul><br> ,   . ,   , ,  : <ul><li> ,     .  . </li><li> ,     NULL.  . </li><li> ,       .  . </li><li>  E assim por diante </li></ul><br>  ?  N√£o.     ¬´ ¬ª.    ¬´ ¬ª  .       Top50      . ,     , ,  100  ,      .       , ,  ,   . , - Amazon.com      ,     130  ¬´  ¬ª. <br><br>      .  ,   . ,        : <br><br><ul><li> g_ascii_strncasecmp ‚Äî 35,695 </li><li> lstrcmpiA ‚Äî 27,512 </li><li> _wcsicmp_l ‚Äî 5,737 </li><li> _strnicmp_l ‚Äî 5,848 </li><li> _mbscmp_l ‚Äî 2,458 </li><li>  .. </li></ul><br>  ,    ,          .      .      .     ,         ,   .       ¬´ ¬ª. <br><br>  PVS-Studio    . ,  C  ++      7200 .  : <br><br><ul><li> WinAPI </li><li>   C, </li><li>    (STL), </li><li> glibc (GNU C Library) </li><li> Qt </li><li> MFC </li><li> zlib </li><li> libpng </li><li> OpenSSL </li><li>  .. </li></ul><br>   ,    .   .   ,  . <br><br>  .     ML?    ,   . <br><br>  ,  ,   ML,            . ,  .         ,  <i>strcmp</i>  <i>malloc</i> . <br><br> C     .  ,   .       ,  ,        ,     . <br><br>     ,  <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> . ,   ,  <i>fread</i> .          . ,     .      ,       .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>        PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>        , ,   ,    ,   .   ,   write-only .   .   . <br><br>         ML. GitHub   .   15000   .     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>   ? <br><br><ol><li>   .    . </li><li>  ,        ,          . ,   ,    .    . </li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br>  , ML         . <br><br>  ,    ML,    ,     ,       ,   . , ,     ,     . <br><br>     . ,    ,   WinAPI.     ,    ,   ?   ,        Google,   ,   <b> </b> .  ,      .   <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a>        ,    .       ,        ,    C++. ,            20. <br><br>     ,       .   ,  <i>memmove</i> .    - : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>    <i>__builtin___memmove_chk</i> ?  intrinsic ,     .      . <br><br>  <i>memmove</i>   - : <a href="">    </a> .         ,  -   . <br><br> Ok,     .  ,        .  ,    ML   ,     ,     . <br><br>        .    .      . ,        ,   .    ,        AI? ,  AI    ,    .       ,               . ,      20   . <br><br> <b> </b> <br><br>    ,      ,       .     .      ,     . <ul><li> <b> </b> .   ,  ,      .           ,    -     . .  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  I.e.     ,   ‚Äî ,    ,   .     ,       .    ,     ,   ‚Äî ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  </h2><br>       ,   ,     .    ML    ,    ,    (   )     .       ,   ,  ML    . <br><br>      ,    ,     ML.           ,  ,            . <br><br>  ,     ML      . ,   .  ML    ¬´¬ª               . <br><br>    ,       ,    ,     ,     . <br><br>         ML,       . <br><br><h2>  PS </h2><br>       ,  -  ,       <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"></a>   ML,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Unic√≥rnios Ludditas"></div><br><br> ,   .               PVS-Studio.          ML.  ,         .          ,     ,   ,     if- :).      ,     :). <br><br>      ,            -,     . <br><br>   .      " <a href="https://www.viva64.com/ru/b/0687/">        PVS-Studio</a> ". <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov, Victoria Khanieva. <a href="https://habr.com/en/company/pvs-studio/blog/484202/">Machine Learning in Static Analysis of Program Source Code</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484208/">https://habr.com/ru/post/pt484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484198/index.html">Verso da moeda: quem ganhou e perdeu com o crescimento das a√ß√µes da Tesla</a></li>
<li><a href="../pt484200/index.html">Como definir metas para alcan√ß√°-las</a></li>
<li><a href="../pt484202/index.html">Aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa</a></li>
<li><a href="../pt484204/index.html">FTCODE ransomware sem arquivo agora rouba contas</a></li>
<li><a href="../pt484206/index.html">Uso de mixins no Dart</a></li>
<li><a href="../pt484212/index.html">Material gratuito para karma - a hist√≥ria de uma startup bielorrussa que muda o princ√≠pio do consumo</a></li>
<li><a href="../pt484214/index.html">Tensores em TensorFlow</a></li>
<li><a href="../pt484216/index.html">Segunda confer√™ncia Zabbix na R√∫ssia: inscri√ß√µes e datas importantes</a></li>
<li><a href="../pt484218/index.html">Otimizamos a automa√ß√£o: como aceleramos os autotestes em 3 a 4 vezes, preservando os desenvolvimentos antigos</a></li>
<li><a href="../pt484220/index.html">Voc√™ j√° encomendou a entrega? Como a Crossroads entrega 6.000 pedidos por dia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>