<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàØÔ∏è üèúÔ∏è üéÄ Arr√™tez de nourrir les b√ªcherons! Donnez plus de modificateurs! Champs finaux statiques paresseux. Projet d'esquisse d'objet ü§≤üèº üé¶ üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il suffit qu'en Java, les loggers soient initialis√©s au moment de l'initialisation de la classe, pourquoi jonchent-ils tout le lancement? John Rose √† ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arr√™tez de nourrir les b√ªcherons! Donnez plus de modificateurs! Champs finaux statiques paresseux. Projet d'esquisse d'objet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p>  Il suffit qu'en Java, les loggers soient initialis√©s au moment de l'initialisation de la classe, pourquoi jonchent-ils tout le lancement?  John Rose √† la rescousse! </p><br><p>  Voici √† quoi cela pourrait ressembler: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Ce document √©tend le comportement des variables finales, vous permettant √©ventuellement de prendre en charge l'ex√©cution paresseuse - √† la fois dans le langage lui-m√™me et dans la JVM.  Il est propos√© d'am√©liorer le comportement des m√©canismes existants de l'informatique paresseuse en modifiant la granularit√©: d√©sormais, elle ne sera pas pr√©cise pour la classe, mais pr√©cise pour une variable sp√©cifique. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  La motivation </h1><br><p>  Java a profond√©ment int√©gr√© l'informatique paresseuse.  Presque chaque op√©ration de liaison peut extraire du code paresseux.  Par exemple, ex√©cuter la m√©thode <code>&lt;clinit&gt;</code> (bytecode de l'initialiseur de classe) ou utiliser la m√©thode bootstrap (pour un site d'appel dynamique invoqu√© ou des constantes <code>CONSTANT_Dynamic</code> ). </p><br><p>  Les initialiseurs de classe sont quelque chose de tr√®s grossier en termes de granularit√© par rapport aux m√©canismes utilisant des m√©thodes de bootstrap, car leur contrat est d'ex√©cuter <em>tout le</em> code d'initialisation de la classe dans son <em>ensemble</em> , plut√¥t que de se limiter √† l'initialisation li√©e √† un champ sp√©cifique de la classe.  Les effets d'une telle initialisation brute sont difficiles √† pr√©voir.  Il est difficile d'isoler les effets secondaires de l'utilisation d' <em>un</em> champ statique d'une classe, car le calcul d'un champ conduit √† calculer <em>tous les</em> champs statiques de cette classe. </p><br><p>  Si vous touchez un champ, vous les affecterez tous.  Dans les compilateurs AOT, cela rend particuli√®rement difficile l'optimisation des r√©f√©rences de champ statiques, m√™me pour les champs avec une valeur constante facilement analysable.  Une fois qu'au moins <em>un</em> champ statique repens√© est encombr√© parmi les champs, il devient impossible d'analyser compl√®tement <em>tous les</em> champs de cette classe.  Un probl√®me similaire se manifeste avec les m√©canismes pr√©c√©demment propos√©s pour impl√©menter la convolution de constantes (pendant le fonctionnement en <em>javac</em> ) pour des champs constants avec des initialiseurs complexes. </p><br><p>  Un exemple d'initialisation de champ repens√©e, qui se produit dans diff√©rents projets √† chaque √©tape, dans chaque fichier, est l'initialisation de l'enregistreur. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Cette initialisation inoffensive lance sous le capot une √©norme quantit√© de travail qui sera effectu√©e pendant l'initialisation de la classe - et pourtant, il est extr√™mement peu probable que l'enregistreur soit vraiment n√©cessaire au moment o√π la classe est initialis√©e, ou peut-√™tre pas du tout n√©cessaire.  La possibilit√© de diff√©rer sa cr√©ation jusqu'√† la premi√®re utilisation r√©elle simplifiera l'initialisation et, dans certains cas, cela aidera √† √©viter compl√®tement cette initialisation. </p><br><p>  Les variables finales sont tr√®s utiles, elles sont le principal m√©canisme de l'API Java pour indiquer la constance des valeurs.  Les variables paresseuses ont √©galement bien fonctionn√©.  √Ä partir de Java 7, ils ont commenc√© √† jouer un r√¥le de plus en plus important dans les <code>@Stable</code> internes du JDK, marqu√©s de l'annotation <code>@Stable</code> .  JIT peut optimiser les variables finales et stables - bien mieux que seulement certaines variables.  L'ajout de variables finales paresseuses permettra √† ce mod√®le d'utilisation utile de devenir plus courant, ce qui permettra de l'utiliser dans plus d'endroits.  Enfin, l'utilisation de variables finales paresseuses permettra aux biblioth√®ques telles que le JDK de r√©duire la d√©pendance au code <code>&lt;clinit&gt;</code> , ce qui devrait √† son tour r√©duire le temps de d√©marrage et am√©liorer la qualit√© des optimisations AOT. </p><br><h1 id="opisanie">  La description </h1><br><p>  Le champ peut √™tre d√©clar√© avec le nouveau modificateur <code>lazy</code> , qui est un mot-cl√© contextuel per√ßu exclusivement comme un modificateur.  Un tel champ est appel√© <em>champ</em> paresseux et doit √©galement avoir <code>static</code> modificateurs <code>static</code> et <code>final</code> . </p><br><p>  Un champ paresseux doit avoir un initialiseur.  Le compilateur et le runtime conviennent de d√©marrer l'initialiseur exactement lorsque la variable est utilis√©e pour la premi√®re fois, et non lors de l'initialisation de la classe √† laquelle ce champ appartient. </p><br><p>  Chaque <code>lazy static final</code> est associ√© au moment de la compilation √† un √©l√©ment de pool constant qui repr√©sente sa valeur.  Puisque les √©l√©ments du pool constant eux-m√™mes sont calcul√©s paresseusement, il suffit d'attribuer simplement la bonne valeur pour chaque variable finale statique paresseuse associ√©e √† cet √©l√©ment.  (Vous pouvez lier plus d'une variable paresseuse √† un √©l√©ment, mais ce n'est gu√®re une fonctionnalit√© utile ou significative.) Le nom d'attribut est <code>LazyValue</code> , et il doit faire r√©f√©rence √† un √©l√©ment de genre constant qui peut √™tre cod√© en ldc en une valeur qui peut √™tre convertie en un type de champ paresseux. .  Seuls les <code>MethodHandle.invoke</code> d√©j√† utilis√©s dans <code>MethodHandle.invoke</code> . </p><br><p>  Ainsi, un champ statique paresseux peut √™tre consid√©r√© comme un alias nomm√© pour un √©l√©ment de pool constant dans la classe qui a d√©clar√© ce champ.  Des outils comme les compilateurs peuvent en quelque sorte essayer d'utiliser ce champ. </p><br><p>  Un champ paresseux n'est jamais une variable constante (au sens de JLS 4.12.4) et est explicitement exclu de la participation aux expressions constantes (au sens de JLS 15.28).  Par cons√©quent, il ne capture jamais l'attribut <code>ConstantValue</code> , m√™me si son initialiseur est une expression constante.  Au lieu de cela, le champ paresseux capture un nouveau type d'attribut de fichier de classes appel√© <code>LazyValue</code> , que la JVM consulte lors de la liaison √† ce champ particulier.  Le format de ce nouvel attribut est similaire au pr√©c√©dent, car il pointe √©galement vers un √©l√©ment du pool constant, dans ce cas, celui qui est r√©solu en valeur de champ. </p><br><p>  Lorsqu'un champ statique paresseux est li√©, le processus normal d'ex√©cution des initialiseurs de classe <em>ne</em> doit <em>pas</em> dispara√Ætre.  Au lieu de cela, toute m√©thode d√©clarante de classe <code>&lt;clinit&gt;</code> est initialis√©e conform√©ment aux r√®gles d√©finies dans JVMS 5.5.  En d'autres termes, le bytecode <code>getstatic</code> pour un champ statique paresseux effectue la m√™me liaison que pour <em>tout</em> champ statique.  Apr√®s l'initialisation (ou lors de l'initialisation d√©j√† commenc√©e du thread actuel), la JVM r√©sout les √©l√©ments du pool constant associ√©s au champ et stocke les valeurs obtenues √† partir du pool constant dans ce champ. </p><br><p>  √âtant donn√© que la finale statique paresseuse ne peut pas √™tre vide, aucune valeur ne peut leur √™tre attribu√©e, m√™me dans les quelques contextes o√π cela fonctionne pour les variables finales vides. </p><br><p>  Lors de la compilation, tous les champs statiques paresseux sont initialis√©s ind√©pendamment des champs statiques non paresseux, quel que soit leur emplacement dans le code source.  Par cons√©quent, les restrictions sur l'emplacement des champs statiques ne s'appliquent pas aux champs statiques paresseux.  L'initialiseur de champ statique paresseux peut utiliser n'importe quel champ statique de la m√™me classe, quel que soit l'ordre dans lequel ils apparaissent dans la source.  L'initialiseur de n'importe quel champ non statique ou l'initialiseur de classe peut acc√©der au champ paresseux, quel que soit l'ordre dans la source o√π ils sont les uns par rapport aux autres.  Habituellement, faire cela n'est pas l'id√©e la plus raisonnable, car toute la signification des valeurs paresseuses est perdue, mais elle peut √©ventuellement √™tre utilis√©e d'une mani√®re ou d'une autre dans des expressions conditionnelles ou sur le flux de contr√¥le.  Par cons√©quent, les champs statiques paresseux peuvent √™tre trait√©s plus comme des champs d'une autre classe - en ce sens qu'ils peuvent √™tre r√©f√©renc√©s dans n'importe quel ordre √† partir de n'importe quelle partie de la classe dans laquelle ils sont d√©clar√©s. </p><br><p>  Les champs paresseux peuvent √™tre d√©tect√©s √† l'aide de l'API de r√©flexion √† l'aide de deux nouvelles m√©thodes d'API dans <code>java.lang.reflect.Field</code> .  La nouvelle m√©thode <code>isLazy</code> renvoie <code>true</code> si et seulement si le champ a un modificateur <code>lazy</code> .  La nouvelle m√©thode <code>isAssigned</code> renvoie <code>false</code> si et seulement si le champ est paresseux et n'est toujours pas initialis√© au moment o√π <code>isAssigned</code> .  (Il peut retourner vrai presque au prochain appel dans le m√™me thread, selon la pr√©sence de races).  Il n'y a aucun moyen de savoir si un champ est initialis√©, autre que d'utiliser <code>isAssigned</code> . </p><br><p>  (L'appel <code>isAssigned</code> n'est n√©cessaire que pour r√©soudre les probl√®mes rares li√©s √† la r√©solution des d√©pendances circulaires. Peut-√™tre pouvons-nous nous passer de cette m√©thode. Cependant, les personnes qui √©crivent du code avec des variables paresseuses veulent parfois savoir si la valeur est d√©finie sur une telle variable ou pas encore, de la m√™me mani√®re que les utilisateurs de mutex veulent parfois savoir si le mutex est verrouill√© ou non, mais ils ne veulent pas vraiment le verrouiller) </p><br><p>  Il existe une limitation inhabituelle sur les champs finaux paresseux: ils ne doivent jamais √™tre initialis√©s √† leurs valeurs par d√©faut.  Autrement dit, le champ de r√©f√©rence paresseux ne doit pas √™tre initialis√© √† <code>null</code> et les types num√©riques ne doivent pas avoir de valeur null.  Une valeur bool√©enne paresseuse peut √™tre initialis√©e avec une seule valeur - <code>true</code> , puisque <code>false</code> est sa valeur par d√©faut.  Si l'initialiseur d'un champ statique paresseux renvoie sa valeur par d√©faut, la liaison de ce champ √©chouera avec l'erreur correspondante. </p><br><p>  Cette restriction est introduite pour cela.  pour permettre aux impl√©mentations JVM de r√©server des valeurs par d√©faut en tant que valeur de surveillance interne qui marque l'√©tat d'un champ non initialis√©.  La valeur par d√©faut est d√©j√† d√©finie dans la valeur initiale de n'importe quel champ, d√©finie au moment de la pr√©paration (cela est d√©crit dans JLS 5.4.2).  Cette valeur existe donc naturellement d√©j√† au d√©but du cycle de vie de n'importe quel champ, et est donc un choix logique √† utiliser comme valeur de surveillance qui surveille l'√©tat de ce champ.  En utilisant ces r√®gles, vous ne pouvez jamais obtenir la valeur par d√©faut d'origine √† partir d'un champ statique paresseux.  Pour cela, la JVM peut, par exemple, impl√©menter un champ paresseux en tant que lien immuable vers l'√©l√©ment de pool constant correspondant. </p><br><p>  Les restrictions sur les valeurs par d√©faut peuvent √™tre contourn√©es en encapsulant les valeurs (qui sont √©ventuellement √©gales aux valeurs par d√©faut) dans des bo√Ætes ou des conteneurs d'un type pratique.  Un nombre z√©ro peut √™tre encapsul√© dans une r√©f√©rence enti√®re non nulle.  Les types non primitifs peuvent √™tre encapsul√©s dans Facultatif, qui devient vide s'il atteint null. </p><br><p>  Pour conserver la libert√© d'impl√©menter les fonctionnalit√©s, les exigences de la m√©thode <code>isAssigned</code> sp√©cialement sous-estim√©es.  Si la JVM peut prouver qu'une variable statique paresseuse peut √™tre initialis√©e sans effets externes observables, elle peut effectuer cette initialisation √† tout moment.  Dans ce cas, <code>isAssigned</code> retournera <code>true</code> m√™me si <code>getfield</code> n'a jamais √©t√© appel√©.  La seule exigence impos√©e √† <code>isAssigned</code> est que si elle retourne <code>false</code> , aucun des effets secondaires de l'initialisation des variables ne doit √™tre observ√© dans le thread actuel.  Et s'il est retourn√© <code>true</code> , le thread actuel peut √† l'avenir observer les effets secondaires de l'initialisation.  Un tel contrat permet au compilateur de remplacer <code>ldc</code> par <code>getstatic</code> pour ses propres champs, ce qui permet √† la JVM de ne pas surveiller les √©tats d√©taill√©s des variables finales qui ont des √©l√©ments communs ou d√©g√©n√©r√©s dans le pool constant. </p><br><p>  Plusieurs threads peuvent entrer dans un √©tat de course pour initialiser un champ final paresseux.  Comme cela se produit d√©j√† avec <code>CONSTANT_Dynamic</code> , la JVM s√©lectionne un gagnant arbitraire de cette course et fournit la valeur de ce gagnant √† tous les threads participant √† la course, et l'√©crit pour toutes les tentatives ult√©rieures pour obtenir une valeur.  Pour contourner la course, des impl√©mentations JVM sp√©cifiques peuvent essayer d'utiliser les op√©rations CAS, si la plate-forme les prend en charge, le vainqueur de la course verra la valeur par d√©faut pr√©c√©dente et les perdants verront la valeur non par d√©faut qui a remport√© la course. </p><br><p>  Ainsi, les r√®gles existantes pour l'attribution unique des variables finales continuent de fonctionner et capturent d√©sormais toutes les difficult√©s de l'informatique paresseuse. </p><br><p>  La m√™me logique s'applique √† la publication s√©curis√©e √† l'aide des champs finaux - il en est de m√™me pour les champs paresseux et non paresseux. </p><br><p>  Notez qu'une classe peut convertir un champ statique en champ statique paresseux sans rompre la compatibilit√© binaire.  L' <code>getstatic</code> client <code>getstatic</code> identique dans les deux cas.  Lorsqu'une d√©claration de variable devient paresseuse, <code>getstatic</code> li√© de mani√®re diff√©rente. </p><br><h1 id="alternativnye-resheniya">  Solutions alternatives </h1><br><p>  Vous pouvez utiliser des classes imbriqu√©es comme conteneurs pour les variables paresseuses. </p><br><p>  Vous pouvez d√©finir quelque chose comme une API de biblioth√®que pour g√©rer les valeurs paresseuses ou (plus g√©n√©ralement) toutes les donn√©es monotones. </p><br><p>  Refactorisez ce qu'ils allaient faire des variables statiques paresseuses afin qu'elles se transforment en m√©thodes statiques nulles et que leurs corps soient publi√©s en utilisant les constantes ldc CONSTANT_Dynamic, d'une mani√®re ou d'une autre. </p><br><p>  (Remarque: les solutions de contournement ci-dessus ne fournissent pas un moyen compatible binaire de d√©coupler de mani√®re √©volutive les constantes statiques existantes de leur <code>&lt;clinit&gt;</code> ) </p><br><p>  Si nous parlons de fournir <em>plus de</em> fonctionnalit√©s, vous pouvez autoriser les champs paresseux √† √™tre non statiques ou non finaux, tout en conservant les correspondances et analogies actuelles entre le comportement des champs statiques et non statiques.  Un pool constant ne peut pas √™tre un r√©f√©rentiel pour des champs non statiques, mais il peut toujours contenir des m√©thodes d'amor√ßage (selon l'instance actuelle).  Les tableaux gel√©s (s'ils sont mis en ≈ìuvre) peuvent obtenir une option paresseuse.  Ces √©tudes constituent une bonne base pour de futurs projets construits sur la base de ce document.  Et en passant, ces opportunit√©s rendent notre d√©cision d'interdire les valeurs par d√©faut encore plus significative. </p><br><p>  Les variables paresseuses doivent √™tre initialis√©es √† l'aide de leurs propres expressions d'initialisation.  Parfois, cela semble √™tre une limitation tr√®s d√©sagr√©able qui nous ram√®ne √† l'√©poque de l'invention des variables finales vides.  Rappelons que ces variables finales vides peuvent √™tre initialis√©es avec des blocs de code arbitraires, y compris la logique try-finally, et elles peuvent √™tre initialis√©es en groupes plut√¥t qu'en m√™me temps.  √Ä l'avenir, il sera possible d'essayer d'appliquer les m√™mes possibilit√©s aux variables finales paresseuses.  Peut-√™tre qu'une ou plusieurs variables paresseuses peuvent √™tre associ√©es √† un bloc priv√© de code d'initialisation dont la t√¢che consiste √† affecter chaque variable exactement une fois, comme cela se produit avec un initialiseur de classe ou un constructeur d'objet.  L'architecture d'une telle fonctionnalit√© peut devenir plus claire apr√®s l'apparition des d√©constructeurs, car les t√¢ches qu'ils r√©solvent se recoupent dans un certain sens. </p><br><blockquote>  Minute de publicit√©.  La conf√©rence Joker 2018 se tiendra tr√®s prochainement, o√π il y aura de nombreux sp√©cialistes √©minents de Java et de JVM.  Consultez la liste compl√®te des orateurs et les rapports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site officiel</a> . </blockquote><br><h1 id="avtor">  L'auteur </h1><br><p>  <strong>John Rose</strong> est ing√©nieur JVM et architecte chez Oracle.  Ing√©nieur en chef Da Vinci Machine Project (partie d'OpenJDK).  L'ing√©nieur principal JSR 292 (Prise en charge des langages √† typage dynamique sur la plate-forme Java) est sp√©cialis√© dans les appels dynamiques et les sujets connexes tels que le profilage de type et les optimisations avanc√©es du compilateur.  Auparavant, il a travaill√© sur les classes internes, cr√©√© le port HotSpot d'origine sur SPARC, l'API Unsafe, et a √©galement d√©velopp√© de nombreux langages dynamiques, parall√®les et hybrides, y compris Common Lisp, Scheme (¬´esh¬ª), des classeurs dynamiques pour C ++. </p><br><h1 id="perevodchik">  Traductrice </h1><br><p>  <strong>Oleg Chirukhin</strong> - au moment de la r√©daction de ce texte, il travaille en tant que community manager dans la soci√©t√© JUG.ru Group, il est engag√© dans la vulgarisation de la plateforme Java.  Avant de rejoindre JRG, il a particip√© au d√©veloppement de syst√®mes d'information bancaires et gouvernementaux, d'un √©cosyst√®me de langages de programmation auto-√©crits et de jeux en ligne.  Les int√©r√™ts de recherche actuels incluent les machines virtuelles, les compilateurs et les langages de programmation. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422629/">https://habr.com/ru/post/fr422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422615/index.html">Toute la v√©rit√© sur RTOS. Article # 9. Scheduler: impl√©mentation</a></li>
<li><a href="../fr422617/index.html">Toute la v√©rit√© sur RTOS. Article # 8. Nucleus SE: conception interne et d√©ploiement</a></li>
<li><a href="../fr422623/index.html">Comment s√©curiser C</a></li>
<li><a href="../fr422625/index.html">Nous avons parl√© avec Troy Miles - le programmeur de "Neuromancer"</a></li>
<li><a href="../fr422627/index.html">Recherche sur le march√© du travail MongoDB et IT</a></li>
<li><a href="../fr422631/index.html">Terminaux QIWI. Comment tirer le meilleur parti des technologies simples</a></li>
<li><a href="../fr422633/index.html">Comment nous avons automatis√© la surveillance du travail des employ√©s du r√©seau f√©d√©ral de stations-service</a></li>
<li><a href="../fr422635/index.html">Vous n‚Äôavez pas encore dit le mot ¬´bonjour¬ª, et nous savons d√©j√† qui vous √™tes</a></li>
<li><a href="../fr422637/index.html">Cadeau de geek: Protection Auto-Alkash</a></li>
<li><a href="../fr422641/index.html">Nuit polaire, pompage d'eau et coffre-fort intelligent: 5 projets √©tudiants dans le domaine de l'IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>