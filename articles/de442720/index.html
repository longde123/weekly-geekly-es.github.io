<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆔 👈🏼 🌶️ Schnelle Verallgemeinerung von Markern auf einer WebGL-Karte 🤟🏾 🐀 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Marker sind eine gute Sache. Nützlich in angemessenen Mengen. Wenn es zu viele von ihnen gibt, verschwinden die Vorteile. Was tun, wenn Sie Suchergebn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Verallgemeinerung von Markern auf einer WebGL-Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/442720/"><p><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="Bild"></p><br><p>  Marker sind eine gute Sache.  Nützlich in angemessenen Mengen.  Wenn es zu viele von ihnen gibt, verschwinden die Vorteile.  Was tun, wenn Sie Suchergebnisse auf der Karte markieren möchten, in denen Zehntausende von Objekten vorhanden sind?  In dem Artikel werde ich Ihnen erklären, wie wir dieses Problem auf einer WebGL-Karte lösen, ohne deren Aussehen und Leistung zu beeinträchtigen. </p><a name="habracut"></a><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  2016 startete 2GIS sein erstes WebGL-Projekt, Floors: 3D-Grundrisse von Gebäuden. </p><br><p><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="Bild"><br>  <em>Fußböden des Nowosibirsker Einkaufszentrums Aura</em> </p><br><p>  Unmittelbar nach der Veröffentlichung von Floors begann unser Team mit der Entwicklung einer vollwertigen dreidimensionalen kartografischen Engine für WebGL.  Die Engine wurde in Verbindung mit der neuen Version 2gis.ru entwickelt und befindet sich nun im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">öffentlichen Beta-</a> Status. </p><br><p><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="Bild"><br>  <em>Rotes Quadrat auf WebGL gezeichnet.</em>  <em>Baupläne werden jetzt direkt in die Karte integriert.</em> </p><br><h1 id="zadacha-generalizacii-podpisey">  Aufgabe zur Verallgemeinerung von Signaturen </h1><br><p>  Jeder, der seine eigene Karten-Engine schreiben möchte, wird früher oder später mit dem Problem konfrontiert sein, Signaturen auf der Karte zu platzieren.  Es gibt viele Objekte auf der Karte, und es ist unmöglich, jedes zu signieren, damit sich die Signaturen nicht überschneiden. </p><br><p><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="Bild"><br>  <em>Was passiert, wenn in Nowosibirsk alle Objekte gleichzeitig signiert sind?</em> </p><br><p>  Um dieses Problem zu lösen, ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verallgemeinerung der</a> Signaturen erforderlich.  Verallgemeinerung im allgemeinen Sinne ist die Transformation von Kartendaten, so dass sie für die Anzeige in kleinen Maßstäben geeignet sind.  Dies kann mit verschiedenen Methoden erfolgen.  Für Signaturen wird normalerweise die Auswahlmethode verwendet: Aus der Gesamtzahl wird eine Teilmenge der Signaturen mit der höchsten Priorität ausgewählt, die sich nicht überlappen. </p><br><p>  Die Signaturpriorität wird durch ihren Typ sowie den aktuellen Kartenmaßstab bestimmt.  Beispielsweise werden im kleinen Maßstab Unterschriften von Städten und Ländern benötigt, und im großen Maßstab werden Straßensignaturen und Hausnummern viel wichtiger.  Oft wird die Priorität des Namens einer Siedlung durch die Größe ihrer Bevölkerung bestimmt.  Je größer es ist, desto wichtiger ist die Signatur. </p><br><p>  Eine Verallgemeinerung ist nicht nur für Signaturen erforderlich, sondern auch für Markierungen, die die Suchergebnisse auf der Karte markieren.  Wenn Sie beispielsweise in Moskau nach einem „Geschäft“ suchen, erhalten Sie mehr als 15.000 Ergebnisse.  Es ist offensichtlich eine schlechte Idee, sie alle gleichzeitig auf der Karte zu markieren. </p><br><p><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="Bild"><br>  <em>Alle Moskauer Geschäfte auf der Karte.</em>  <em>Ohne Verallgemeinerung geht es nicht</em> </p><br><p> Jede Benutzerinteraktion mit der Karte (Bewegen, Zoomen, Drehen und Neigen) führt zu einer Änderung der Position der Markierungen auf dem Bildschirm. Sie müssen daher in der Lage sein, die Generalisierung im laufenden Betrieb neu zu berechnen.  Deshalb muss es schnell gehen. </p><br><p>  In diesem Artikel werde ich am Beispiel der Marker-Generalisierung verschiedene Möglichkeiten zur Lösung dieses Problems zeigen, die zu unterschiedlichen Zeiten in unseren Projekten verwendet wurden. </p><br><h1 id="obschiy-podhod-k-generalizacii">  Allgemeiner Ansatz zur Verallgemeinerung </h1><br><ol><li>  Projizieren Sie jeden Marker auf die Ebene des Bildschirms und berechnen Sie dafür eine Grenze - den rechteckigen Bereich, den er auf dem Bildschirm einnimmt. </li><li>  Sortieren Sie die Marker nach Priorität. </li><li>  Untersuchen Sie nacheinander jeden Marker und platzieren Sie ihn auf dem Bildschirm, wenn er sich nicht mit anderen davor platzierten Markern schneidet. </li></ol><br><p>  Mit Punkt 1 ist alles klar - es ist nur eine Berechnung.  Mit Punkt 2 hatten wir auch Glück: Die Liste der Marker, die vom Backend zu uns kommen, ist bereits nach Priorität nach Suchalgorithmen sortiert.  Die relevantesten Ergebnisse, die für den Benutzer am wahrscheinlichsten von Interesse sind, stehen ganz oben in den Ergebnissen. </p><br><p>  Das Hauptproblem ist in Absatz 3: Der Zeitpunkt der Berechnung der Verallgemeinerung kann stark davon abhängen, wie sie implementiert wird. </p><br><p>  Um nach Schnittpunkten zwischen Markierungen zu suchen, benötigen wir eine Datenstruktur, die: </p><br><ol><li>  Speichert die Grenzen der Markierungen, die dem Bildschirm hinzugefügt wurden. </li><li> Verfügt über eine <code>insert(marker)</code> , um dem Bildschirm einen Marker hinzuzufügen. </li><li>  Es gibt eine <code>collides(marker)</code> , um die Markierung auf Schnittpunkte mit den bereits zum Bildschirm hinzugefügten zu überprüfen. </li></ol><br><p>  Betrachten Sie mehrere Implementierungen dieser Struktur.  Alle weiteren Beispiele werden in TypeScript geschrieben, das wir in den meisten unserer Projekte verwenden.  In allen Beispielen werden Markierungen durch Objekte der folgenden Form dargestellt: </p><br><pre> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p>  Alle berücksichtigten Ansätze sind Implementierungen der folgenden Schnittstelle: </p><br><pre> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p>  Um die Leistung zu vergleichen, wird die Ausführungszeit des folgenden Codes gemessen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p>  Das <code>markers</code> enthält 100.000 30 x 50 Elemente, die zufällig auf einer Ebene mit einer Größe von 1920 x 1080 platziert werden. </p><br><p>  Die Leistung wird auf dem 2012 Macbook Air gemessen. </p><br><p>  Die im Artikel bereitgestellten Tests und Codebeispiele werden auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub veröffentlicht</a> . </p><br><h1 id="naivnaya-realizaciya">  Naive Umsetzung </h1><br><p>  Betrachten Sie zunächst die einfachste Option, wenn die Markierung in einem einfachen Zyklus auf Schnittpunkte mit den anderen überprüft wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit für 100.000 Marker: <strong>420 ms</strong> .  Zu viel.  Selbst wenn die Berechnung der Verallgemeinerung in einem Web-Worker durchgeführt wird und den Haupt-Thread nicht blockiert, ist eine solche Verzögerung für das Auge erkennbar, zumal dieser Vorgang nach jeder Kartenbewegung ausgeführt werden muss.  Darüber hinaus kann auf Mobilgeräten mit einem schwachen Prozessor die Verzögerung noch größer sein. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva">  R-Tree-Implementierung </h1><br><p>  Da in einer naiven Implementierung jeder Marker auf Schnittpunkte mit allen vorherigen überprüft wird, ist die Komplexität dieses Algorithmus im schlimmsten Fall quadratisch.  Sie können es verbessern, indem Sie die R-Tree-Datenstruktur anwenden.  Nehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> als Implementierung des R-Baums die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBush-</a> Bibliothek: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit für 100.000 Marker: <strong>173 ms</strong> .  Deutlich besser.  Wir haben diesen Ansatz in den Etagen verwendet (dies wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem vorherigen Artikel erwähnt</a> ). </p><br><p><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="Bild"><br>  <em>Visualisierung der Speicherung von Punkten im R-Baum.</em>  <em>Durch die hierarchische Unterteilung der Ebene in Rechtecke können Sie den Suchbereich schnell eingrenzen und nicht alle Objekte sortieren</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy">  Implementierung des Kollisionspuffers </h1><br><p>  Das Zeichnen einer Karte ist eine viel kompliziertere Aufgabe als das Zeichnen eines Plans eines Gebäudes.  Dies äußert sich auch in der Verallgemeinerung.  Selbst in den größten Einkaufszentren der Welt befinden sich 1.000 Organisationen selten auf derselben Etage.  Gleichzeitig kann eine einfache Suchabfrage in einer Großstadt Zehntausende von Ergebnissen liefern. </p><br><p>  Als wir mit der Entwicklung einer WebGL-Karte begannen, begannen wir zu überlegen: Ist es immer noch möglich, die Generalisierung zu beschleunigen?  Eine interessante Idee bot uns der für uns funktionierende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Stellarator an</a> : Verwenden Sie anstelle des R-Baums einen Puffer, in dem der Status jedes Pixels des Bildschirms (beschäftigt oder nicht beschäftigt) gespeichert wird.  Wenn Sie eine Markierung auf dem Bildschirm einfügen, füllen Sie die entsprechende Stelle im Puffer aus und überprüfen Sie beim Überprüfen der Einfügemöglichkeit die Pixelwerte im gewünschten Bereich. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit für 100.000 Marker: <strong>46 ms</strong> . </p><br><p>  Warum so schnell?  Dieser Ansatz erscheint auf den ersten Blick naiv, und verschachtelte Schleifen in beiden Methoden sind nicht wie schneller Code.  Wenn Sie sich den Code jedoch genauer ansehen, werden Sie feststellen, dass die Ausführungszeit beider Methoden nicht von der Gesamtzahl der Marker abhängt.  Somit erhalten wir für eine feste Größe von WxH-Markern die Komplexität O (W * H * n), dh linear! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy">  Optimierter Kollisionspuffer-Ansatz </h1><br><p>  Sie können den vorherigen Ansatz sowohl hinsichtlich der Geschwindigkeit als auch des belegten Speichers verbessern, wenn Sie sicherstellen, dass ein Pixel im Speicher nicht durch ein Byte, sondern durch ein Bit dargestellt wird.  Der Code nach dieser Optimierung ist jedoch merklich kompliziert und wächst mit ein bisschen Magie: </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p>  Verallgemeinerungsberechnungszeit für 100.000 Marker: <strong>16 ms</strong> .  Wie Sie sehen, rechtfertigt sich die Komplexität der Logik und ermöglicht es uns, die Berechnung der Generalisierung um fast das Dreifache zu beschleunigen. </p><br><h1 id="ogranicheniya-bufera-kolliziy">  Einschränkungen des Kollisionspuffers </h1><br><p>  Es ist wichtig zu verstehen, dass der Kollisionspuffer keinen vollständigen Ersatz für den R-Baum darstellt.  Es hat viel weniger Funktionen und mehr Einschränkungen: </p><br><ol><li>  Sie können nicht verstehen, womit sich der Marker genau schneidet.  Der Puffer speichert nur Daten darüber, welche Pixel belegt sind und welche nicht.  Daher ist es unmöglich, eine Operation zu implementieren, die eine Liste von Markierungen zurückgibt, die sich mit den angegebenen überschneiden. </li><li>  Zuvor hinzugefügte Markierung kann nicht gelöscht werden.  Der Puffer speichert keine Daten darüber, wie viele Markierungen sich in einem bestimmten Pixel befinden.  Daher ist es unmöglich, den Vorgang des Entfernens eines Markers aus dem Puffer korrekt zu implementieren. </li><li>  Hohe Empfindlichkeit gegenüber der Größe der Elemente.  Wenn Sie versuchen, dem Kollisionspuffer Markierungen hinzuzufügen, die den gesamten Bildschirm einnehmen, sinkt die Leistung erheblich. </li><li>  Arbeitet in einem begrenzten Bereich.  Die Größe des Puffers wird beim Erstellen festgelegt, und es ist unmöglich, einen Marker darin zu platzieren, der über diese Größe hinausgeht.  Bei diesem Ansatz müssen daher Markierungen, die nicht auf dem Bildschirm angezeigt werden, manuell gefiltert werden. </li></ol><br><p>  Alle diese Einschränkungen haben die Lösung des Problems der Marker-Generalisierung nicht beeinträchtigt.  Jetzt wird diese Methode erfolgreich für Marker in der Beta-Version von 2gis.ru verwendet. </p><br><p>  Um die Hauptsignaturen auf der Karte zu verallgemeinern, sind die Anforderungen jedoch komplexer.  Für sie muss beispielsweise sichergestellt werden, dass das POI-Symbol seine eigene Signatur nicht „töten“ kann.  Da der Kollisionspuffer nicht unterscheidet, mit was genau der Schnittpunkt passiert ist, kann eine solche Logik nicht implementiert werden.  Daher mussten sie eine Lösung bei RBush hinterlassen. </p><br><h1 id="vyvod">  Fazit </h1><br><p><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="Bild"><br>  Der Artikel zeigt den Weg, den wir von der einfachsten Lösung zu der jetzt verwendeten gegangen sind. </p><br><p>  Die Verwendung des R-Baums war der erste wichtige Schritt, mit dem wir die naive Implementierung um ein Vielfaches beschleunigen konnten.  In Floors funktioniert es hervorragend, aber tatsächlich nutzen wir nur einen kleinen Bruchteil der Funktionen dieser Datenstruktur. </p><br><p>  Nachdem wir den R-Baum aufgegeben und durch ein einfaches zweidimensionales Array ersetzt haben, das genau das tut, was wir brauchen, und sonst nichts, konnten wir die Produktivität noch weiter steigern. </p><br><p>  Dieses Beispiel hat uns gezeigt, wie wichtig es ist, aus mehreren Optionen eine Lösung für ein Problem auszuwählen, um die Einschränkungen der einzelnen Optionen zu verstehen und zu erkennen.  Einschränkungen sind wichtig und nützlich, und Sie sollten keine Angst davor haben: Wenn Sie sich geschickt auf etwas Unbedeutendes beschränken, können Sie im Gegenzug dort, wo es wirklich benötigt wird, enorme Vorteile erzielen.  Zum Beispiel, um die Lösung eines Problems zu vereinfachen oder um sich vor einer ganzen Klasse von Problemen zu schützen oder um, wie in unserem Fall, die Produktivität mehrmals zu verbessern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442720/">https://habr.com/ru/post/de442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442708/index.html">Was bestimmt die Einnahmen der Bergleute?</a></li>
<li><a href="../de442710/index.html">Überprüfung der Google IoT-Plattform</a></li>
<li><a href="../de442714/index.html">Wie Mängel</a></li>
<li><a href="../de442716/index.html">Fußtücher</a></li>
<li><a href="../de442718/index.html">Google-Mitarbeiter stellten fest, dass die Arbeit an der Version der Suchmaschine für China fortgesetzt wird</a></li>
<li><a href="../de442722/index.html">Stoppen Sie das Herunterladen und Speichern von Nullen</a></li>
<li><a href="../de442724/index.html">Der Film „Office Space“ ist 20 Jahre alt: Wie er unsere Jobs verändert hat</a></li>
<li><a href="../de442726/index.html">Der MIT-Gepardenroboter kann Backflips ausführen und schnell laufen</a></li>
<li><a href="../de442730/index.html">Microsoft: Russland ist den USA und Europa bei der Implementierung künstlicher Intelligenz voraus</a></li>
<li><a href="../de442732/index.html">Meine kleinen Staffeln: Triple Brainfuck oder What Is Madness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>