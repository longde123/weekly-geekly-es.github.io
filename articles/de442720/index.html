<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜî üëàüèº üå∂Ô∏è Schnelle Verallgemeinerung von Markern auf einer WebGL-Karte ü§üüèæ üêÄ üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Marker sind eine gute Sache. N√ºtzlich in angemessenen Mengen. Wenn es zu viele von ihnen gibt, verschwinden die Vorteile. Was tun, wenn Sie Suchergebn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Verallgemeinerung von Markern auf einer WebGL-Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/442720/"><p><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="Bild"></p><br><p>  Marker sind eine gute Sache.  N√ºtzlich in angemessenen Mengen.  Wenn es zu viele von ihnen gibt, verschwinden die Vorteile.  Was tun, wenn Sie Suchergebnisse auf der Karte markieren m√∂chten, in denen Zehntausende von Objekten vorhanden sind?  In dem Artikel werde ich Ihnen erkl√§ren, wie wir dieses Problem auf einer WebGL-Karte l√∂sen, ohne deren Aussehen und Leistung zu beeintr√§chtigen. </p><a name="habracut"></a><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  2016 startete 2GIS sein erstes WebGL-Projekt, Floors: 3D-Grundrisse von Geb√§uden. </p><br><p><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="Bild"><br>  <em>Fu√üb√∂den des Nowosibirsker Einkaufszentrums Aura</em> </p><br><p>  Unmittelbar nach der Ver√∂ffentlichung von Floors begann unser Team mit der Entwicklung einer vollwertigen dreidimensionalen kartografischen Engine f√ºr WebGL.  Die Engine wurde in Verbindung mit der neuen Version 2gis.ru entwickelt und befindet sich nun im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√∂ffentlichen Beta-</a> Status. </p><br><p><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="Bild"><br>  <em>Rotes Quadrat auf WebGL gezeichnet.</em>  <em>Baupl√§ne werden jetzt direkt in die Karte integriert.</em> </p><br><h1 id="zadacha-generalizacii-podpisey">  Aufgabe zur Verallgemeinerung von Signaturen </h1><br><p>  Jeder, der seine eigene Karten-Engine schreiben m√∂chte, wird fr√ºher oder sp√§ter mit dem Problem konfrontiert sein, Signaturen auf der Karte zu platzieren.  Es gibt viele Objekte auf der Karte, und es ist unm√∂glich, jedes zu signieren, damit sich die Signaturen nicht √ºberschneiden. </p><br><p><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="Bild"><br>  <em>Was passiert, wenn in Nowosibirsk alle Objekte gleichzeitig signiert sind?</em> </p><br><p>  Um dieses Problem zu l√∂sen, ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verallgemeinerung der</a> Signaturen erforderlich.  Verallgemeinerung im allgemeinen Sinne ist die Transformation von Kartendaten, so dass sie f√ºr die Anzeige in kleinen Ma√üst√§ben geeignet sind.  Dies kann mit verschiedenen Methoden erfolgen.  F√ºr Signaturen wird normalerweise die Auswahlmethode verwendet: Aus der Gesamtzahl wird eine Teilmenge der Signaturen mit der h√∂chsten Priorit√§t ausgew√§hlt, die sich nicht √ºberlappen. </p><br><p>  Die Signaturpriorit√§t wird durch ihren Typ sowie den aktuellen Kartenma√üstab bestimmt.  Beispielsweise werden im kleinen Ma√üstab Unterschriften von St√§dten und L√§ndern ben√∂tigt, und im gro√üen Ma√üstab werden Stra√üensignaturen und Hausnummern viel wichtiger.  Oft wird die Priorit√§t des Namens einer Siedlung durch die Gr√∂√üe ihrer Bev√∂lkerung bestimmt.  Je gr√∂√üer es ist, desto wichtiger ist die Signatur. </p><br><p>  Eine Verallgemeinerung ist nicht nur f√ºr Signaturen erforderlich, sondern auch f√ºr Markierungen, die die Suchergebnisse auf der Karte markieren.  Wenn Sie beispielsweise in Moskau nach einem ‚ÄûGesch√§ft‚Äú suchen, erhalten Sie mehr als 15.000 Ergebnisse.  Es ist offensichtlich eine schlechte Idee, sie alle gleichzeitig auf der Karte zu markieren. </p><br><p><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="Bild"><br>  <em>Alle Moskauer Gesch√§fte auf der Karte.</em>  <em>Ohne Verallgemeinerung geht es nicht</em> </p><br><p> Jede Benutzerinteraktion mit der Karte (Bewegen, Zoomen, Drehen und Neigen) f√ºhrt zu einer √Ñnderung der Position der Markierungen auf dem Bildschirm. Sie m√ºssen daher in der Lage sein, die Generalisierung im laufenden Betrieb neu zu berechnen.  Deshalb muss es schnell gehen. </p><br><p>  In diesem Artikel werde ich am Beispiel der Marker-Generalisierung verschiedene M√∂glichkeiten zur L√∂sung dieses Problems zeigen, die zu unterschiedlichen Zeiten in unseren Projekten verwendet wurden. </p><br><h1 id="obschiy-podhod-k-generalizacii">  Allgemeiner Ansatz zur Verallgemeinerung </h1><br><ol><li>  Projizieren Sie jeden Marker auf die Ebene des Bildschirms und berechnen Sie daf√ºr eine Grenze - den rechteckigen Bereich, den er auf dem Bildschirm einnimmt. </li><li>  Sortieren Sie die Marker nach Priorit√§t. </li><li>  Untersuchen Sie nacheinander jeden Marker und platzieren Sie ihn auf dem Bildschirm, wenn er sich nicht mit anderen davor platzierten Markern schneidet. </li></ol><br><p>  Mit Punkt 1 ist alles klar - es ist nur eine Berechnung.  Mit Punkt 2 hatten wir auch Gl√ºck: Die Liste der Marker, die vom Backend zu uns kommen, ist bereits nach Priorit√§t nach Suchalgorithmen sortiert.  Die relevantesten Ergebnisse, die f√ºr den Benutzer am wahrscheinlichsten von Interesse sind, stehen ganz oben in den Ergebnissen. </p><br><p>  Das Hauptproblem ist in Absatz 3: Der Zeitpunkt der Berechnung der Verallgemeinerung kann stark davon abh√§ngen, wie sie implementiert wird. </p><br><p>  Um nach Schnittpunkten zwischen Markierungen zu suchen, ben√∂tigen wir eine Datenstruktur, die: </p><br><ol><li>  Speichert die Grenzen der Markierungen, die dem Bildschirm hinzugef√ºgt wurden. </li><li> Verf√ºgt √ºber eine <code>insert(marker)</code> , um dem Bildschirm einen Marker hinzuzuf√ºgen. </li><li>  Es gibt eine <code>collides(marker)</code> , um die Markierung auf Schnittpunkte mit den bereits zum Bildschirm hinzugef√ºgten zu √ºberpr√ºfen. </li></ol><br><p>  Betrachten Sie mehrere Implementierungen dieser Struktur.  Alle weiteren Beispiele werden in TypeScript geschrieben, das wir in den meisten unserer Projekte verwenden.  In allen Beispielen werden Markierungen durch Objekte der folgenden Form dargestellt: </p><br><pre> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p>  Alle ber√ºcksichtigten Ans√§tze sind Implementierungen der folgenden Schnittstelle: </p><br><pre> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p>  Um die Leistung zu vergleichen, wird die Ausf√ºhrungszeit des folgenden Codes gemessen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p>  Das <code>markers</code> enth√§lt 100.000 30 x 50 Elemente, die zuf√§llig auf einer Ebene mit einer Gr√∂√üe von 1920 x 1080 platziert werden. </p><br><p>  Die Leistung wird auf dem 2012 Macbook Air gemessen. </p><br><p>  Die im Artikel bereitgestellten Tests und Codebeispiele werden auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub ver√∂ffentlicht</a> . </p><br><h1 id="naivnaya-realizaciya">  Naive Umsetzung </h1><br><p>  Betrachten Sie zun√§chst die einfachste Option, wenn die Markierung in einem einfachen Zyklus auf Schnittpunkte mit den anderen √ºberpr√ºft wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit f√ºr 100.000 Marker: <strong>420 ms</strong> .  Zu viel.  Selbst wenn die Berechnung der Verallgemeinerung in einem Web-Worker durchgef√ºhrt wird und den Haupt-Thread nicht blockiert, ist eine solche Verz√∂gerung f√ºr das Auge erkennbar, zumal dieser Vorgang nach jeder Kartenbewegung ausgef√ºhrt werden muss.  Dar√ºber hinaus kann auf Mobilger√§ten mit einem schwachen Prozessor die Verz√∂gerung noch gr√∂√üer sein. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva">  R-Tree-Implementierung </h1><br><p>  Da in einer naiven Implementierung jeder Marker auf Schnittpunkte mit allen vorherigen √ºberpr√ºft wird, ist die Komplexit√§t dieses Algorithmus im schlimmsten Fall quadratisch.  Sie k√∂nnen es verbessern, indem Sie die R-Tree-Datenstruktur anwenden.  Nehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> als Implementierung des R-Baums die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBush-</a> Bibliothek: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit f√ºr 100.000 Marker: <strong>173 ms</strong> .  Deutlich besser.  Wir haben diesen Ansatz in den Etagen verwendet (dies wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem vorherigen Artikel erw√§hnt</a> ). </p><br><p><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="Bild"><br>  <em>Visualisierung der Speicherung von Punkten im R-Baum.</em>  <em>Durch die hierarchische Unterteilung der Ebene in Rechtecke k√∂nnen Sie den Suchbereich schnell eingrenzen und nicht alle Objekte sortieren</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy">  Implementierung des Kollisionspuffers </h1><br><p>  Das Zeichnen einer Karte ist eine viel kompliziertere Aufgabe als das Zeichnen eines Plans eines Geb√§udes.  Dies √§u√üert sich auch in der Verallgemeinerung.  Selbst in den gr√∂√üten Einkaufszentren der Welt befinden sich 1.000 Organisationen selten auf derselben Etage.  Gleichzeitig kann eine einfache Suchabfrage in einer Gro√üstadt Zehntausende von Ergebnissen liefern. </p><br><p>  Als wir mit der Entwicklung einer WebGL-Karte begannen, begannen wir zu √ºberlegen: Ist es immer noch m√∂glich, die Generalisierung zu beschleunigen?  Eine interessante Idee bot uns der f√ºr uns funktionierende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Stellarator an</a> : Verwenden Sie anstelle des R-Baums einen Puffer, in dem der Status jedes Pixels des Bildschirms (besch√§ftigt oder nicht besch√§ftigt) gespeichert wird.  Wenn Sie eine Markierung auf dem Bildschirm einf√ºgen, f√ºllen Sie die entsprechende Stelle im Puffer aus und √ºberpr√ºfen Sie beim √úberpr√ºfen der Einf√ºgem√∂glichkeit die Pixelwerte im gew√ºnschten Bereich. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Verallgemeinerungsberechnungszeit f√ºr 100.000 Marker: <strong>46 ms</strong> . </p><br><p>  Warum so schnell?  Dieser Ansatz erscheint auf den ersten Blick naiv, und verschachtelte Schleifen in beiden Methoden sind nicht wie schneller Code.  Wenn Sie sich den Code jedoch genauer ansehen, werden Sie feststellen, dass die Ausf√ºhrungszeit beider Methoden nicht von der Gesamtzahl der Marker abh√§ngt.  Somit erhalten wir f√ºr eine feste Gr√∂√üe von WxH-Markern die Komplexit√§t O (W * H * n), dh linear! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy">  Optimierter Kollisionspuffer-Ansatz </h1><br><p>  Sie k√∂nnen den vorherigen Ansatz sowohl hinsichtlich der Geschwindigkeit als auch des belegten Speichers verbessern, wenn Sie sicherstellen, dass ein Pixel im Speicher nicht durch ein Byte, sondern durch ein Bit dargestellt wird.  Der Code nach dieser Optimierung ist jedoch merklich kompliziert und w√§chst mit ein bisschen Magie: </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p>  Verallgemeinerungsberechnungszeit f√ºr 100.000 Marker: <strong>16 ms</strong> .  Wie Sie sehen, rechtfertigt sich die Komplexit√§t der Logik und erm√∂glicht es uns, die Berechnung der Generalisierung um fast das Dreifache zu beschleunigen. </p><br><h1 id="ogranicheniya-bufera-kolliziy">  Einschr√§nkungen des Kollisionspuffers </h1><br><p>  Es ist wichtig zu verstehen, dass der Kollisionspuffer keinen vollst√§ndigen Ersatz f√ºr den R-Baum darstellt.  Es hat viel weniger Funktionen und mehr Einschr√§nkungen: </p><br><ol><li>  Sie k√∂nnen nicht verstehen, womit sich der Marker genau schneidet.  Der Puffer speichert nur Daten dar√ºber, welche Pixel belegt sind und welche nicht.  Daher ist es unm√∂glich, eine Operation zu implementieren, die eine Liste von Markierungen zur√ºckgibt, die sich mit den angegebenen √ºberschneiden. </li><li>  Zuvor hinzugef√ºgte Markierung kann nicht gel√∂scht werden.  Der Puffer speichert keine Daten dar√ºber, wie viele Markierungen sich in einem bestimmten Pixel befinden.  Daher ist es unm√∂glich, den Vorgang des Entfernens eines Markers aus dem Puffer korrekt zu implementieren. </li><li>  Hohe Empfindlichkeit gegen√ºber der Gr√∂√üe der Elemente.  Wenn Sie versuchen, dem Kollisionspuffer Markierungen hinzuzuf√ºgen, die den gesamten Bildschirm einnehmen, sinkt die Leistung erheblich. </li><li>  Arbeitet in einem begrenzten Bereich.  Die Gr√∂√üe des Puffers wird beim Erstellen festgelegt, und es ist unm√∂glich, einen Marker darin zu platzieren, der √ºber diese Gr√∂√üe hinausgeht.  Bei diesem Ansatz m√ºssen daher Markierungen, die nicht auf dem Bildschirm angezeigt werden, manuell gefiltert werden. </li></ol><br><p>  Alle diese Einschr√§nkungen haben die L√∂sung des Problems der Marker-Generalisierung nicht beeintr√§chtigt.  Jetzt wird diese Methode erfolgreich f√ºr Marker in der Beta-Version von 2gis.ru verwendet. </p><br><p>  Um die Hauptsignaturen auf der Karte zu verallgemeinern, sind die Anforderungen jedoch komplexer.  F√ºr sie muss beispielsweise sichergestellt werden, dass das POI-Symbol seine eigene Signatur nicht ‚Äût√∂ten‚Äú kann.  Da der Kollisionspuffer nicht unterscheidet, mit was genau der Schnittpunkt passiert ist, kann eine solche Logik nicht implementiert werden.  Daher mussten sie eine L√∂sung bei RBush hinterlassen. </p><br><h1 id="vyvod">  Fazit </h1><br><p><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="Bild"><br>  Der Artikel zeigt den Weg, den wir von der einfachsten L√∂sung zu der jetzt verwendeten gegangen sind. </p><br><p>  Die Verwendung des R-Baums war der erste wichtige Schritt, mit dem wir die naive Implementierung um ein Vielfaches beschleunigen konnten.  In Floors funktioniert es hervorragend, aber tats√§chlich nutzen wir nur einen kleinen Bruchteil der Funktionen dieser Datenstruktur. </p><br><p>  Nachdem wir den R-Baum aufgegeben und durch ein einfaches zweidimensionales Array ersetzt haben, das genau das tut, was wir brauchen, und sonst nichts, konnten wir die Produktivit√§t noch weiter steigern. </p><br><p>  Dieses Beispiel hat uns gezeigt, wie wichtig es ist, aus mehreren Optionen eine L√∂sung f√ºr ein Problem auszuw√§hlen, um die Einschr√§nkungen der einzelnen Optionen zu verstehen und zu erkennen.  Einschr√§nkungen sind wichtig und n√ºtzlich, und Sie sollten keine Angst davor haben: Wenn Sie sich geschickt auf etwas Unbedeutendes beschr√§nken, k√∂nnen Sie im Gegenzug dort, wo es wirklich ben√∂tigt wird, enorme Vorteile erzielen.  Zum Beispiel, um die L√∂sung eines Problems zu vereinfachen oder um sich vor einer ganzen Klasse von Problemen zu sch√ºtzen oder um, wie in unserem Fall, die Produktivit√§t mehrmals zu verbessern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442720/">https://habr.com/ru/post/de442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442708/index.html">Was bestimmt die Einnahmen der Bergleute?</a></li>
<li><a href="../de442710/index.html">√úberpr√ºfung der Google IoT-Plattform</a></li>
<li><a href="../de442714/index.html">Wie M√§ngel</a></li>
<li><a href="../de442716/index.html">Fu√üt√ºcher</a></li>
<li><a href="../de442718/index.html">Google-Mitarbeiter stellten fest, dass die Arbeit an der Version der Suchmaschine f√ºr China fortgesetzt wird</a></li>
<li><a href="../de442722/index.html">Stoppen Sie das Herunterladen und Speichern von Nullen</a></li>
<li><a href="../de442724/index.html">Der Film ‚ÄûOffice Space‚Äú ist 20 Jahre alt: Wie er unsere Jobs ver√§ndert hat</a></li>
<li><a href="../de442726/index.html">Der MIT-Gepardenroboter kann Backflips ausf√ºhren und schnell laufen</a></li>
<li><a href="../de442730/index.html">Microsoft: Russland ist den USA und Europa bei der Implementierung k√ºnstlicher Intelligenz voraus</a></li>
<li><a href="../de442732/index.html">Meine kleinen Staffeln: Triple Brainfuck oder What Is Madness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>