<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔 😘 👼🏻 Tarantool kubernetes Betreiber 🤜🏾 🌦️ 🙇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes wird zum De-facto-Standard für die Ausführung zustandsloser Anwendungen. Hauptsächlich, weil dadurch die Markteinführungszeit für die Berei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool kubernetes Betreiber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465823/"><img src="https://habrastorage.org/webt/pm/mm/lk/pmmmlkexzrcniami66ljv1ynirg.jpeg"><br><br>  Kubernetes wird zum De-facto-Standard für die Ausführung zustandsloser Anwendungen.  Hauptsächlich, weil dadurch die Markteinführungszeit für die Bereitstellung neuer Funktionen erheblich verkürzt werden kann.  Das Starten von Stateful-Anwendungen - Datenbanken, Stateful-Microservices - ist immer noch eine schwierige Aufgabe, aber die Notwendigkeit, dem Wettbewerb standzuhalten und eine hohe Bereitstellungsrate aufrechtzuerhalten, zwingt Unternehmen dazu, in diesem Bereich zu experimentieren, und schafft eine Nachfrage nach solchen Lösungen. <br><br>  Wir präsentieren Ihnen unsere Lösung zum Starten von Stateful Clustern. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Kubernetes Operator</a> , für Details frage ich unter cat. <br><a name="habracut"></a><br>  Inhaltsverzeichnis: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anstelle von tausend Wörtern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was macht der Bediener überhaupt?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein wenig über die Nuancen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie der Bediener arbeitet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was der Operator erweitert</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li></ol><br><br>  Tarantool ist eine OpenSource-Datenbank und ein Anwendungsserver in einem Paket.  Als Datenbank weist sie eine Reihe einzigartiger Merkmale auf: hohe Eisenausnutzungseffizienz, flexibles Datenschema, Unterstützung für In-Memory- und Festplattenspeicher sowie die Möglichkeit der Erweiterung durch die Verwendung der Lua-Sprache.  Als Anwendungsserver können Sie den Anwendungscode so nah wie möglich an die Daten verschieben und gleichzeitig eine minimale Antwortzeit und einen maximalen Durchsatz erzielen.  Darüber hinaus verfügt Tarantool über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein umfangreiches Ökosystem</a> , das vorgefertigte Module zur Lösung von Anwendungsproblemen bereitstellt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sharding</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlange</a> , Module für die einfache Entwicklung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cartridge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luatest</a> ), Lösungen für den Betrieb ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metrics</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible</a> ) - dies sind nur einige Beispiele. <br><br>  Trotz aller Vorteile sind die Funktionen einer einzelnen Tarantool-Instanz nicht unbegrenzt: Um Terabytes an Daten zu speichern und Millionen von Anforderungen zu verarbeiten, müssen Sie Dutzende und Hunderte von Instanzen auslösen, und dies ist ein verteiltes System mit all seinen inhärenten Problemen.  Um sie zu lösen, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> , ein Framework, dessen Hauptaufgabe es ist, alle möglichen Schwierigkeiten beim Schreiben verteilter Anwendungen zu verbergen und Entwicklern die Möglichkeit zu geben, sich auf den geschäftlichen Wert der Anwendung zu konzentrieren.  Cartridge bietet eine Reihe leistungsstarker Komponenten für die automatische Cluster-Orchestrierung, die automatische Datenverteilung, das Webui für den Betrieb und Entwicklertools. <br><br>  Tarantool ist nicht nur Technologie, sondern auch ein Team von Ingenieuren, die sich mit der Entwicklung schlüsselfertiger Unternehmenssysteme, Box-Lösungen und dem Support für Open Source-Komponenten befassen. <br><br>  Weltweit lassen sich unsere Aufgaben in zwei Bereiche unterteilen: die Entwicklung neuer Systeme und die Erweiterung bestehender Lösungen.  Zum Beispiel gibt es eine große Basis von einem berühmten Anbieter.  Um es für das Lesen zu skalieren, haben sie einen endlich konsistenten Cache auf Tarantool dahinter gelegt.  Oder umgekehrt: Um die Aufzeichnung zu skalieren, wird Tarantool in die Hot / Cold-Konfiguration versetzt, in der die Daten beim „Abkühlen“ in den Kühlspeicher und parallel zur Analysewarteschlange gestellt werden.  Oder um ein vorhandenes System zu sichern, wird eine Light-Version dieses Systems (Funktionsreserve) geschrieben, die das Haupt-Hot mit Datenreplikation vom Hauptsystem reserviert.  Weitere Informationen finden Sie in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichten von T + 2019</a> . <br><br>  Alle diese Systeme haben eines gemeinsam: Sie sind recht schwierig zu bedienen.  Stellen Sie schnell einen Cluster mit mehr als 100 Instanzen mit Redundanz in 3 Rechenzentren bereit, aktualisieren Sie die Anwendung, in der Daten ohne Ausfallzeiten und Wartungsprobleme gespeichert sind, führen Sie eine Sicherungswiederherstellung im Falle einer Katastrophe oder von Menschen verursachter Fehler durch, stellen Sie ein unauffälliges Komponenten-Failover sicher, organisieren Sie das Konfigurationsmanagement ... Im Allgemeinen eine Tonne interessant. <br><br>  Und es wäre großartig, wenn all dies noch so einfach betrieben würde, wie es entwickelt wird.  Kubernetes macht es möglich, das gewünschte Ergebnis zu erzielen, aber die Verwendung eines spezialisierten Bedieners macht das Leben noch einfacher. <br><br><a name="1"></a><h2>  Anstelle von tausend Wörtern </h2><br>  Wir haben ein kleines Beispiel basierend auf Tarantool Cartridge vorbereitet und werden damit arbeiten.  Eine einfache Anwendung wie "Distributed Key Value Storage mit HTTP-Schnittstelle".  Nach dem Start erhalten wir dieses Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/235/2c7/c242352c708a0e0dfa8fc0896bbb986d.png"><br><br>  Wo: <br><br><ul><li>  Router - der Teil des Clusters, der für das Akzeptieren und Verarbeiten eingehender HTTP-Anforderungen verantwortlich ist; <br></li><li>  Speichern ist der Teil des Clusters, der für das Speichern und Verarbeiten von Daten verantwortlich ist. 3 Shards steigen aus der Box auf, jeder Master und jedes Replikat. <br></li></ul><br>  Um den eingehenden HTTP-Verkehr auf Routern auszugleichen, wird der Kubernetian Ingress verwendet.  Daten werden mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der vshard-Komponente</a> im Speicher auf Tarantool-Ebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verteilt</a> . <br><br>  Wir brauchen Kubernetes 1.14+, Minikube wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionieren</a> .  Auch die Verfügbarkeit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubectl</a> wird nicht schaden.  Um den Operator zu starten, müssen Sie ein ServiceAccount, eine Rolle und eine Rollenbindung dafür erstellen: <br><br><pre><code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/service_account.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role_binding.yaml</code> </pre> <br>  Tarantool Operator erweitert die Kubernetes-API mit ihren Ressourcendefinitionen. Wir werden sie erstellen: <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_cluster_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_role_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_replicasettemplate_crd.yaml</code> </pre> <br>  Alles ist bereit, um den Operator zu starten. Los geht's: <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/operator.yaml</code> </pre> <br>  Wir warten auf den Start des Bedieners und können mit dem Starten der Anwendung fortfahren: <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/examples/kv/deployment.yaml</code> </pre> <br>  In der yaml-Datei mit dem Beispiel wird Ingress auf der Web-Benutzeroberfläche deklariert.  Es ist unter <code>cluster_ip/admin/cluster</code> verfügbar.  Wenn mindestens ein Pod von Ingress aktiv ist, können Sie dort beobachten, wie neue Instanzen zum Cluster hinzugefügt werden und wie sich seine Topologie ändert. <br><br>  Wir warten auf die Verwendung des Clusters: <br><br><pre> <code class="bash hljs">$ kubectl describe clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Wir erwarten, dass im Status des Clusters Folgendes angezeigt wird: <br><br><pre> <code class="plaintext hljs">… Status: State: Ready …</code> </pre> <br>  Alles, die Anwendung ist gebrauchsfertig! <br><br>  Benötigen Sie mehr Speicherplatz?  Shards hinzufügen: <br><br><pre> <code class="bash hljs">$ kubectl scale roles.tarantool.io storage --replicas=3</code> </pre> <br>  Scherben können die Last nicht bewältigen?  Erhöhen Sie die Anzahl der Instanzen im Shard, indem Sie die Replikatsatzvorlage bearbeiten: <br><br><pre> <code class="bash hljs">$ kubectl edit replicasettemplates.tarantool.io storage-template</code> </pre> <br>  <code>.spec.replicas</code> Sie <code>.spec.replicas</code> , z. B. 2, um die Anzahl der Instanzen in jedem Replikat auf zwei zu erhöhen. <br><br>  Ein Cluster wird nicht mehr benötigt?  Wir löschen es zusammen mit allen Ressourcen: <br><br><pre> <code class="bash hljs">$ kubectl delete clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Ist etwas schief gelaufen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erzielen Sie das Ticket</a> , wir werden es schnell zerlegen.  :) :) <br><br><a name="2"></a><h2>  Was macht der Bediener überhaupt? </h2><br>  Beim Start und Betrieb des Tarantool Cartridge-Clusters werden bestimmte Aktionen in einer bestimmten Reihenfolge zu einem bestimmten Zeitpunkt ausgeführt. <br><br>  Der Cluster selbst wird hauptsächlich über die Admin-API verwaltet: GraphQL über HTTP.  Sie können natürlich eine Stufe tiefer gehen und Befehle direkt in die Konsole eingeben, aber dies kommt selten vor.  So startet der Cluster beispielsweise: <br><br><ol><li>  Wir erhöhen die erforderliche Anzahl von Tarantool-Instanzen, beispielsweise unter systemd. <br></li><li>  Instanzen zur Mitgliedschaft zusammenführen: <br><br><pre> <code class="plaintext hljs">mutation { probe_instance: probe_server(uri: "storage:3301") }</code> </pre> <br></li><li>  Weisen Sie Instanzen Rollen zu, schreiben Sie Instanz- und Replikatsatzkennungen vor.  Hierfür wird auch die GraphQL-API verwendet: <br><br><pre> <code class="plaintext hljs">mutation { join_server( uri:"storage:3301", instance_uuid: "cccccccc-cccc-4000-b000-000000000001", replicaset_uuid: "cccccccc-0000-4000-b000-000000000000", roles: ["storage"], timeout: 5 ) }</code> </pre> <br></li><li>  Wir führen einen Bootstrap der Komponente durch, die für das Sharding verantwortlich ist.  Auch über die API: <br><br><pre> <code class="plaintext hljs">mutation { bootstrap_vshard cluster { failover(enabled:true) } }</code> </pre> <br></li></ol><br>  Einfach, oder? <br><br>  Alles wird interessanter, wenn es um die Erweiterung eines Clusters geht.  Die Rolle der Router aus dem Beispiel lässt sich einfach skalieren: Erhöhen Sie mehr Instanzen, schließen Sie sie an einen vorhandenen Cluster an - fertig!  Die Rolle der Speicher ist etwas schwieriger.  Der Speicher ist gespalten. Wenn Sie also Instanzen hinzufügen oder entfernen, müssen Sie die Daten neu ausgleichen, um zu neuen Instanzen zu wechseln / um von gelöschten Instanzen zu wechseln.  Wenn dies nicht getan wird, erhalten wir in einem Fall unterlastete Instanzen, im zweiten Fall verlieren wir Daten.  Und wenn nicht nur ein, sondern ein Dutzend solcher Cluster mit unterschiedlichen Topologien in Betrieb sind? <br><br>  Im Allgemeinen ist Tarantool Operator mit all dem beschäftigt.  Der Benutzer beschreibt den gewünschten Status des Tarantool Cartridge-Clusters, und der Bediener übersetzt dies in eine Reihe von Aktionen für k8s-Ressourcen und in bestimmte Aufrufe der Tarantool-Cluster-Administrator-API in einer bestimmten Reihenfolge zu einem bestimmten Zeitpunkt und versucht im Allgemeinen, alle Nuancen vor dem Benutzer zu verbergen. <br><br><a name="3"></a><h2>  Ein wenig über die Nuancen </h2><br>  Bei der Arbeit mit der Admin-Cluster-API von Tarantool Cartridge ist sowohl die Reihenfolge der Aufrufe als auch deren Herkunft wichtig.  Warum so? <br><br>  Tarantool Cartridge enthält sein Topologie-Repository, seine Service Discovery-Komponente und seine Konfigurationskomponente.  Jede Instanz des Clusters speichert eine Kopie der Topologie und Konfiguration in einer Yaml-Datei. <br><br><pre> <code class="plaintext hljs">servers: d8a9ce19-a880-5757-9ae0-6a0959525842: uri: storage-2-0.examples-kv-cluster:3301 replicaset_uuid: 8cf044f2-cae0-519b-8d08-00a2f1173fcb 497762e2-02a1-583e-8f51-5610375ebae9: uri: storage-0-0.examples-kv-cluster:3301 replicaset_uuid: 05e42b64-fa81-59e6-beb2-95d84c22a435 … vshard: bucket_count: 30000 ...</code> </pre> <br>  Die Aktualisierung erfolgt gemeinsam mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwei-Phasen-Festschreibungsmechanismus</a> .  Für ein erfolgreiches Upgrade ist ein Quorum von 100% erforderlich: Jede Instanz muss antworten, andernfalls wird ein Rollback durchgeführt.  Was bedeutet das für den Betrieb?  Alle Anforderungen an die Admin-API, die den Status des Clusters ändern, können am zuverlässigsten an eine Instanz, an den Leader, gesendet werden. Andernfalls besteht die Gefahr, dass auf verschiedenen Instanzen unterschiedliche Konfigurationen auftreten.  Tarantool Cartridge weiß nicht, wie man eine Führungswahl durchführt (weiß aber nicht wie), und Tarantool Operator kann - und Sie können dies nur als unterhaltsame Tatsache wissen, weil der Operator alles ruinieren wird. <br><br>  Außerdem muss jede Instanz eine feste Identität haben, d. H. Eine Menge von <code>instance_uuid</code> und <code>replicaset_uuid</code> sowie <code>advertise_uri</code> .  Wenn der Speicher plötzlich neu gestartet wird und sich einer dieser Parameter ändert, besteht die Gefahr, dass das Quorum verletzt wird - der Bediener tut dies auch. <br><br><a name="4"></a><h2>  Wie der Bediener arbeitet </h2><br>  Die Aufgabe des Bedieners besteht darin, das System in den vom Benutzer festgelegten Zustand zu bringen und das System in diesem Zustand zu halten, bis neue Anweisungen empfangen werden.  Damit der Bediener seine Arbeit ausführen kann, benötigt er: <br><br><ol><li>  Beschreibung des Systemstatus. <br></li><li>  Der Code, der das System in diesen Zustand versetzt. <br></li><li>  Ein Mechanismus zum Integrieren dieses Codes in k8s (zum Beispiel zum Empfangen von Benachrichtigungen über Statusänderungen). <br></li></ol><br>  Der Tarantool Cartridge-Cluster wird in k8s durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte Ressourcendefinition (CRD) beschrieben</a> .  Der Bediener benötigt drei solcher benutzerdefinierten Ressourcen, die unter der Gruppe tarantool.io/v1alpha zusammengefasst sind: <br><br><ul><li>  Cluster ist eine Ressource der obersten Ebene, die einem Tarantool Cartridge-Cluster entspricht. <br></li><li>  Rolle - In Bezug auf Tarantool Cartridge ist dies eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzerrolle</a> . <br></li><li>  ReplicasetTemplate - eine Vorlage, mit der StatefulSets erstellt werden (warum stateful - ich werde es Ihnen etwas später sagen; nicht zu verwechseln mit k8s ReplicaSet). <br></li></ul><br>  Alle diese Ressourcen spiegeln direkt das Tarantool Cartridge-Cluster-Beschreibungsmodell wider.  Mit einem gemeinsamen Wörterbuch ist es für einen Bediener einfacher, mit Entwicklern zu kommunizieren und zu verstehen, was sie im Produkt sehen möchten. <br><br>  Der Code, der das System in den angegebenen Zustand bringt - in Bezug auf k8s ist dies Controller.  Im Fall des Tarantool-Operators gibt es mehrere Controller: <br><br><ul><li>  ClusterController - ist für die Interaktion mit dem Tarantool Cartridge-Cluster verantwortlich, verbindet Instanzen mit dem Cluster und trennt Instanzen vom Cluster. <br></li><li>  RoleController ist ein Benutzerrollen-Controller, der für die Bereitstellung von StatefulSets aus einer Vorlage und die Verwaltung der Nummer in einer bestimmten Nummer verantwortlich ist. <br></li></ul><br>  Wie ist ein Controller?  Ein Satz von Code, der die Welt um Sie herum allmählich in Ordnung bringt.  ClusterController kann wie folgt schematisch dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/132/1d2/317/1321d23173a37f65743fcc0ee4d48ad2.png"><br><br>  Ein Einstiegspunkt ist eine Überprüfung, ob eine Clusterressource vorhanden ist, für die das Ereignis aufgetreten ist.  Existiert nicht?  Wir gehen.  Gibt es  Wir fahren mit dem nächsten Block fort: Übernehmen Sie die Eigentümerschaft über Benutzerrollen.  Erfasst eins - links, auf dem zweiten Kreis erfassen wir den zweiten.  Und so weiter, bis wir alles erfassen.  Werden alle Rollen erfasst?  Fahren Sie also mit dem nächsten Operationsblock fort.  Und so, bis wir zum letzten kommen;  dann können wir annehmen, dass sich das gesteuerte System in einem bestimmten Zustand befindet. <br><br>  Im Allgemeinen ist alles einfach.  Es ist wichtig, die Erfolgskriterien für das Bestehen jeder Stufe zu bestimmen.  Zum Beispiel betrachten wir den Vorgang des Beitritts zu einem Cluster als erfolgreich, nicht wenn er bedingten Erfolg = true zurückgibt, sondern wenn er einen Fehler wie "bereits verbunden" zurückgibt. <br><br>  Und der letzte Teil dieses Mechanismus ist die Integration des Controllers in k8s.  In der Luftaufnahme besteht der gesamte k8 aus einer Reihe von Controllern, die Ereignisse generieren und darauf reagieren.  Ereignisse durchlaufen Warteschlangen, die wir abonnieren können.  Schematisch kann dies wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/094/d57/3fb/094d573fbcf511ba2eea8e707a575423.jpg"><br><br>  Der Benutzer ruft <code>kubectl create -f tarantool_cluster.yaml</code> , die entsprechende <code>kubectl create -f tarantool_cluster.yaml</code> wird erstellt.  ClusterController wird über die Erstellung einer Clusterressource benachrichtigt.  Und das erste, was er versucht, ist, alle Rollenressourcen zu finden, die Teil dieses Clusters sein sollten.  Wenn dies der Fall ist, wird Cluster als Eigentümer für die Rolle zugewiesen und die Rollenressource aktualisiert.  Der RoleController erhält eine Benachrichtigung über die Rollenaktualisierung, erkennt, dass die Ressource einen Eigentümer hat, und beginnt mit der Erstellung von StatefulSets.  Und so weiter im Kreis: der erste Strigger des zweiten, der zweite Strigger des dritten - und so weiter, bis jemand anhält.  Sie können beispielsweise auch alle 5 Sekunden pünktlich auslösen, was manchmal nützlich ist. <br><br>  Das ist der ganze Operator: Erstellen Sie eine benutzerdefinierte Ressource und schreiben Sie Code, der auf Ereignisse auf Ressourcen reagiert. <br><br><a name="5"></a><h2>  Was der Operator erweitert </h2><br>  Bedieneraktionen führen letztendlich dazu, dass k8s Pods und Container erstellen.  In dem auf k8s bereitgestellten Tarantool Cartridge-Cluster werden alle Pods zu StatefulSets zusammengeführt. <br><br>  Warum StatefulSet?  Wie ich bereits geschrieben habe, behält jede Tarantool-Cluster-Instanz eine Kopie der Topologie und Konfiguration des Clusters bei, und häufig auf dem App-Server no, no, und sie verwenden eine Art Speicherplatz, z. B. wiederum oder Referenzdaten, und dies ist bereits ein vollständiger Status .  Und StatefulSet garantiert auch die Beibehaltung von Identitäts-Pods, was beim Clustering von Instanzen in einem Cluster wichtig ist: Die Identität von Instanzen muss behoben werden, da sonst das Quorum beim Neustart verloren gehen kann. <br><br>  Wenn alle Clusterressourcen erstellt und in den gewünschten Status versetzt werden, bilden sie die folgende Hierarchie: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e27/89f/f7e/e2789ff7e8bf174c20baf8cc077bdad2.png"><br><br>  Die Pfeile geben die inhaberabhängige Beziehung zwischen Ressourcen an.  Es ist notwendig, dass der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Garbage Collector</a> nach uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufräumt,</a> wenn beispielsweise der Cluster entfernt wird. <br><br>  Zusätzlich zu StatefulSets erstellt der Tarantool-Operator den Headless-Dienst, der für die Wahl des Leiters benötigt wird, und über diesen kommunizieren die Instanzen miteinander. <br><br>  Unter der Haube des Tarantool-Operators verbirgt sich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Framework</a> , der Operatorcode selbst ist in Golang, hier nichts Außergewöhnliches. <br><br><a name="6"></a><h2>  Zusammenfassung </h2><br>  Das ist alles im Allgemeinen!  Wir warten auf Feedback und Tickets von Ihnen - ohne sie ist die Alpha-Version alle gleich.  Was weiter?  Und dann gibt es eine Menge Arbeit, um dies alles in Erinnerung zu rufen: <br><br><ul><li>  Einheit, E2E-Test; <br></li><li>  Chaos Affentest <br></li><li>  Stresstests; <br></li><li>  sichern / wiederherstellen; <br></li><li>  externer Topologieanbieter. <br></li></ul><br>  Jedes dieser Themen ist für sich genommen umfangreich und verdient ein eigenes Material. Warten Sie auf Aktualisierungen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465823/">https://habr.com/ru/post/de465823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465811/index.html">14 Tipps zum Schreiben von sauberem React-Code. Teil 1</a></li>
<li><a href="../de465813/index.html">14 Tipps zum Schreiben von sauberem React-Code. Teil 2</a></li>
<li><a href="../de465815/index.html">Wissenschaftler haben Cluster von Nervenzellen gezüchtet und sie an die ISS geschickt</a></li>
<li><a href="../de465817/index.html">Wie Unbehagen uns hilft, den Entwicklungsprozess zu verbessern.</a></li>
<li><a href="../de465819/index.html">Ideales LAN</a></li>
<li><a href="../de465825/index.html">Asterisk FreePBX-Telefonverzeichnis aus SQL-Tabellen (webbasiertes Verzeichnis, Hochladen in XML-Datei für Grandstream-Telefone)</a></li>
<li><a href="../de465829/index.html">[Tutorial] So erstellen Sie Ihr erstes inkrementelles IDLE-JavaScript-Spiel</a></li>
<li><a href="../de465833/index.html">TOKEN2 Molto-1, das weltweit erste TOTP-Hardware-Token mit mehreren Profilen</a></li>
<li><a href="../de465835/index.html">Abstrakte Fabrik an den Fingern</a></li>
<li><a href="../de465839/index.html">Alles, was Sie über CSS Margin wissen müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>