<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïäÔ∏è ‚õàÔ∏è üå≠ Ex√©cutez des tests unitaires localement dans STM32CubeIDE sous Windows üêº ‚è∞ ü•ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 


 Tout le monde conna√Æt les avantages des tests unitaires. Tout d'abord, l'√©criture de tests en m√™me temps que le code vous permet de d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ex√©cutez des tests unitaires localement dans STM32CubeIDE sous Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469367/"><h3 id="vvedenie">  Pr√©sentation </h3><br><p><img src="https://habrastorage.org/webt/8f/3q/2r/8f3q2rt_-eycgp3_ejr_hfwqnva.png" align="left" width="200">  Tout le monde conna√Æt les avantages des tests unitaires.  Tout d'abord, l'√©criture de tests en m√™me temps que le code vous permet de d√©tecter les erreurs plus t√¥t et de ne pas perdre de temps par la suite sur un d√©bogage complexe et long.  Dans le cas du d√©veloppement embarqu√©, les tests unitaires ont des fonctionnalit√©s li√©es, d'une part, au fait que le code se trouve quelque part profond√©ment dans les entrailles de l'appareil et qu'il est assez difficile d'interagir avec lui, et d'autre part, le code est fortement li√© au mat√©riel cible . </p><br><p>  S'il y a des fragments dans le projet qui ne d√©pendent pas du mat√©riel et impl√©mentent en m√™me temps une logique assez complexe, pour eux, l'utilisation de tests unitaires sera la plus avantageuse.  Par exemple, il peut s'agir de la mise en ≈ìuvre d'un protocole de transfert de donn√©es, de divers calculs ou d'une machine √† √©tats de contr√¥le. </p><br><p>  Il existe trois fa√ßons d'ex√©cuter des tests unitaires pour les plates-formes int√©gr√©es: </p><a name="habracut"></a><br><ol><li>  Lancer directement sur la plateforme cible.  Dans ce cas, vous pouvez travailler avec l'√©quipement de l'appareil et le code fonctionnera exactement de la m√™me mani√®re que dans les conditions de combat.  Cependant, pour les tests, vous aurez besoin d'un acc√®s physique √† l'appareil.  De plus, le cycle de test sera assez long en raison de la n√©cessit√© de t√©l√©charger constamment du code sur l'appareil. </li><li>  Fonctionnant sur un √©mulateur.  Cette m√©thode est bonne principalement parce qu'elle vous permet de travailler m√™me lorsque la plate-forme cible n'est pas disponible (par exemple, car elle n'a pas encore √©t√© effectu√©e).  Les inconv√©nients sont la pr√©cision limit√©e dans la reproduction du comportement du fer (et du monde environnant), ainsi que la difficult√© de cr√©er un tel √©mulateur. </li><li>  En cours d'ex√©cution sur la machine h√¥te (localement).  Cela ne fonctionnera pas avec l'√©quipement (vous pouvez utiliser des talons de test √† la place), mais les tests d√©marreront rapidement et fonctionneront, et vous n'avez pas besoin d'acc√©der au p√©riph√©rique cible.  Un bon exemple d'utilisation de cette m√©thode consiste √† tester la mise en ≈ìuvre sur un microcontr√¥leur d'un algorithme de calcul, qui en soi ne d√©pend pas du mat√©riel, mais utilise les donn√©es du capteur de l'appareil.  Tester un algorithme avec une vraie source de donn√©es sera tr√®s g√™nant, il est pr√©f√©rable d'enregistrer une fois ces mesures et d'ex√©cuter des tests d√©j√† sur les donn√©es stock√©es.  Ce script ex√©cutera des tests localement et sera discut√© plus tard. </li></ol><br><p>  Cette publication fournit un moyen de configurer les tests unitaires dans l'environnement STM32CubeIDE, bas√©s sur Eclipse et destin√©s au d√©veloppement des contr√¥leurs de la famille STM32.  Le langage de d√©veloppement est C, mais les tests eux-m√™mes sont √©crits en C ++.  Les tests s'ex√©cuteront sur une machine h√¥te Windows utilisant Cygwin.  En tant que cadre de test, Google Test est utilis√©.  Les r√©sultats seront affich√©s dans une fen√™tre de plug-in sp√©ciale pour les tests unitaires, et ils peuvent √™tre lanc√©s avec un bouton du projet pour STM32: </p><br><p><img src="https://habrastorage.org/webt/mo/_j/gw/mo_jgwdlc6e3qqzjkcbsxrslvaq.png"></p><br><p>  La m√©thode d√©crite convient √† d'autres environnements de d√©veloppement bas√©s sur Eclipse, √† moins bien s√ªr que les bons fabricants les aient trop coup√©s pour le confort des d√©veloppeurs.  Cette m√©thode fonctionnera √©galement avec CubeIDE sous Linux, sans avoir √† se soucier de Cygwin. </p><br><h3 id="vam-ponadobyatsya">  Vous aurez besoin </h3><br><ol><li>  Cygwin 3.0.7 x86 (puisque les tests concernent un microcontr√¥leur 32 bits, nous utiliserons √©galement un environnement 32 bits sur une plate-forme 64 bits) </li><li>  STM32CubeIDE 1.0.2 pour Windows. </li><li>  Google Test Framework 1.8.1 </li></ol><br><h3 id="ustanovka-cygwin-i-stm32cubeide">  Installer Cygwin et STM32CubeIDE </h3><br><h4 id="cygwin">  Cygwin </h4><br><p>  Installez Cygwin, version x86.  Dans le programme d'installation, s√©lectionnez des packages suppl√©mentaires: gcc-core, g ++, binutils, automake, autoconf, cmake, libtool, gdb, make.  Vous pouvez installer les derni√®res versions stables des packages. </p><br><p><img src="https://habrastorage.org/webt/xc/fj/6v/xcfj6v0wun10fgdbskuccodkqqk.png"></p><br><p>  Vous devez √©galement enregistrer les variables d'environnement: </p><br><p>  <strong>CHEMIN:</strong> ...; C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ bin;  C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib <br>  chemin de classe <strong>:</strong> C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib </p><br><h4 id="stm32cubeide">  STM32CubeIDE </h4><br><p>  L'environnement est install√© comme d'habitude.  Il est conseill√© d'installer CubeIDE apr√®s Cygwin, car dans ce cas, Cube r√©cup√©rera la cha√Æne d'outils Cygwin existante. </p><br><p>  Tout d'abord, cr√©ez un projet C ++ pour la plate-forme Cygwin x86.  Nous en aurons besoin pour, d'une part, v√©rifier la fonctionnalit√© de la cha√Æne d'outils, et d'autre part, nous l'utiliserons comme ¬´donneur¬ª de la configuration d'assemblage du projet principal. </p><br><p>  Choisissez Fichier&gt; Nouveau&gt; Projet C / C ++.  S√©lectionnez C ++ Managed Build.  Nous cr√©ons un projet de type hello world pour la cha√Æne d'outils Cygwin GCC: </p><br><p><img src="https://habrastorage.org/webt/jc/ny/1n/jcny1ntttq4rzapxeth3-s2emim.png"></p><br><p>  Ensuite, vous devrez choisir les configurations d'assemblage √† cr√©er.  Un simple d√©bogage suffit. <br>  Vous pouvez maintenant v√©rifier que le projet se d√©roule en choisissant Projet&gt; Tout construire.  Il est √©galement conseill√© de v√©rifier le d√©bogage sous Cygwin en ex√©cutant Ex√©cuter&gt; D√©boguer en tant que&gt; Application C / C ++ locale.  L'application affichera ¬´Hello world¬ª sur la console √† l'int√©rieur de CubeIDE. </p><br><p>  Pour que le d√©bogueur affiche les lignes ex√©cutables dans les fichiers de code source, vous devez configurer l'affichage des chemins.  Dans la fen√™tre Window&gt; Preferences, dans l'onglet C / C ++&gt; Debug, s√©lectionnez Source Lookup Path et ajoutez un nouvel affichage: Add&gt; Path Mapping.  Dans la fen√™tre, vous devez nommer quelque chose comme un nouvel affichage et ajouter des lignes pour les disques qui sont dans le syst√®me: </p><br><ul><li>  \ cygdrive \ c - C: \ </li><li>  \ cygdrive \ g - G: \ </li></ul><br><p><img src="https://habrastorage.org/webt/fe/ro/2h/fero2hpb7i_n1cjf4sie1nfdndm.png"></p><br><p><img src="https://habrastorage.org/webt/cc/y3/4e/ccy34eo_dtfubifpmfnmkgzkjgu.png"></p><br><p>  Pour une belle ex√©cution de test, nous avons √©galement besoin d'un plug-in pour Eclipse avec prise en charge des tests unitaires pour C ++.  Il est install√© directement √† partir de STM32CubeIDE: menu Aide&gt; Installer un nouveau logiciel, puis s√©lectionnez le r√©f√©rentiel Eclipse et installez le plug-in C / C ++ Unit Testing Support. </p><br><p><img src="https://habrastorage.org/webt/67/eh/ns/67ehnsuupvabu-i1vvkp6dfz4yc.png"></p><br><h3 id="sborka-biblioteki-google-test">  Cr√©er la biblioth√®que de tests Google </h3><br><p>  Le code source de la biblioth√®que peut √™tre r√©cup√©r√© √†: <a href="">https://github.com/google/googletest/tree/release-1.8.1</a> <br>  D√©compressez les sources, acc√©dez au r√©pertoire googletest-release-1.8.1 √† l'aide du terminal Cygwin et ex√©cutez: </p><br><pre><code class="bash hljs">cmake . make</code> </pre> <br><p>  Une fois l'assemblage r√©ussi, le fichier de biblioth√®que statique sera dans ./googlemock/lib/libgtest.a et les fichiers d'en-t√™te seront dans le r√©pertoire ./googletest/include/gtest/.  Ils devront √™tre copi√©s dans notre projet (ou pour enregistrer le chemin d'acc√®s √† ces fichiers dans les param√®tres du projet). </p><br><h3 id="sozdanie-proekta-dlya-stm32">  Cr√©ation d'un projet pour STM32 </h3><br><p>  Conception pour la carte de d√©bogage STM32L476G-DISCO.  L'exemple ne sera pas trop sophistiqu√© - il y a deux LED sur la carte, laissez-les afficher un compteur binaire de 00 √† 11. Nous allons impl√©menter un module s√©par√© pour le compteur, d√©crit dans une paire de fichiers .h et .c, et √©crire un test pour cela. <br>  Le projet peut √™tre cr√©√© comme d'habitude, en utilisant le configurateur Cube, l'essentiel est de s'assurer que les broches PB2 et PE8 sont configur√©es comme sorties num√©riques.  Lors de la cr√©ation d'un projet, il serait pr√©f√©rable de sp√©cifier le type - C ++, cela sera n√©cessaire pour compiler les tests (le code principal sera toujours compil√© par le compilateur C).  La conversion d'un projet √† partir de C sera possible plus tard, en cliquant sur le nom du projet RMB et en s√©lectionnant ¬´Convertir en C ++¬ª. </p><br><p>  Pour la compilation sous MK et pour les tests, nous avons besoin de deux configurations d'assemblage diff√©rentes.  Dans ces configurations, diff√©rents ensembles de fichiers seront collect√©s - les principaux obtiendront les modules pour travailler avec le mat√©riel et les modules test√©s, et le test obtiendra les m√™mes modules test√©s et les m√™mes fichiers de test.  Par cons√©quent, nous cr√©erons diff√©rents r√©pertoires √† la racine du projet - Application avec le code d'application pour MK (vous pouvez simplement renommer le r√©pertoire Src cr√©√© par Cube), Commun pour les modules qui ne d√©pendent pas du fer (que nous testerons) et Tests pour les tests.  Les r√©pertoires peuvent √™tre exclus de l'assembly en cliquant sur RMB sur leur nom, menu Configuration des ressources&gt; Exclure de la g√©n√©ration. </p><br><p>  Ajoutez notre module compteur au r√©pertoire commun: </p><br><div class="spoiler">  <b class="spoiler_title">Led_counter code</b> <div class="spoiler_text"><p>  (led_counter.h): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; void Led_Counter_Init(); uint8_t Led_Counter_Get_Next(); #endif /* LED_COUNTER_H_ */</span></span></span></span></code> </pre> <br><p>  led_counter.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> static uint8_t led_cnt_state = 0; void Led_Counter_Init() { led_cnt_state = 0; } uint8_t Led_Counter_Get_Next() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(++led_cnt_state &gt; 3) led_cnt_state = 0; return led_cnt_state; }</span></span></code> </pre> </div></div><br><p>  Les r√©pertoires Common et Tests doivent √™tre ajout√©s au chemin de recherche pour les fichiers include: propri√©t√©s du projet (Propri√©t√©s)&gt; C / C ++ G√©n√©ral&gt; Chemins et symboles&gt; Inclut. </p><br><p>  Ajouter au travail avec les LED principales </p><br><div class="spoiler">  <b class="spoiler_title">Fragment main.c</b> <div class="spoiler_text"><p>  main.c: </p><br><pre> <code class="cpp hljs">‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> ‚Ä¶ int main(void) { ‚Ä¶ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span></span></span><span class="hljs-meta"> Led_Counter_Init(); uint8_t led_state = 0; while (1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END WHILE */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 3 */</span></span></span><span class="hljs-meta"> led_state = Led_Counter_Get_Next(); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, led_state &amp; (1&lt;&lt;0)); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, led_state &amp; (1&lt;&lt;1)); HAL_Delay(500); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 3 */</span></span></span><span class="hljs-meta"> ‚Ä¶ }</span></span></code> </pre> </div></div><br><p>  Le projet doit √™tre compil√© et ex√©cut√©, et les voyants doivent clignoter. </p><br><h3 id="napisanie-testov">  Tests d'√©criture </h3><br><p>  Maintenant ce pour quoi tout a commenc√©. </p><br><p>  Cr√©ez une nouvelle configuration de construction via les propri√©t√©s du projet - Propri√©t√©s&gt; Construction C / C ++&gt; Param√®tres&gt; G√©rer les configurations.  CubeIDE ne vous permet tout simplement pas de cr√©er une configuration pour la construction sous Cygwin, alors copiez-la √† partir du projet que nous avons cr√©√© pr√©c√©demment: </p><br><p><img src="https://habrastorage.org/webt/4d/ro/kd/4drokdgkom2o6z18duo1v_tbmwi.png"></p><br><p>  Vous devez maintenant basculer vers cette configuration et configurer les chemins d'acc√®s aux fichiers source et aux fichiers d'en-t√™te.  Dans les propri√©t√©s du projet dans l'onglet Chemins et symboles que nous prescrivons (lors de l'ajout d'une entr√©e, il est pr√©f√©rable de mettre un daw dans le champ "ajouter √† toutes les langues"): </p><br><ul><li>  Comprend - Tests / Inc, Commun / Inc </li><li>  Biblioth√®ques - gtest </li><li>  Chemins de biblioth√®que - Tests / Lib </li><li>  Emplacement source - / &lt;prj_name&gt; / Common et / &lt;prj_name&gt; / Tests (remplacez &lt;prj_name&gt; par le nom du projet) </li></ul><br><p>  Ensuite, copiez la biblioth√®que gtest - le fichier .a dans le r√©pertoire Tests / Lib du projet et les fichiers d'en-t√™te dans le dossier gtest - dans le dossier Tests / Inc.  Dans le dossier Tests, cr√©ez un nouveau fichier main.cpp dans lequel les tests seront ex√©cut√©s.  Son contenu est standard: </p><br><p>  main.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Unit tests main file */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); }</span></span></code> </pre> <br><p>  De plus, pour v√©rifier la configuration, nous allons cr√©er un test qui v√©rifiera que la taille du pointeur est de 32 bits dans notre environnement (nous voulons nous assurer qu'il est le m√™me que sur le microcontr√¥leur, pour cela nous avons d√©fini Cygwin 32 bits). </p><br><p>  Cr√©ez le fichier de test test_platform.cpp suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> TEST(PlatformTest, TestPointerSize) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Check pointer size is 32 bit ASSERT_EQ(sizeof(void*)*8, 32U); }</span></span></span></span></code> </pre> <br><p>  Maintenant, si le projet est ex√©cut√© en tant qu'application C ++ normale, la sortie de d√©bogage affichera un message de Google Test indiquant que tous les tests ont r√©ussi. </p><br><p>  La structure du projet devrait ressembler √† ceci: <br><img src="https://habrastorage.org/webt/ev/ld/g2/evldg2fj_pqta199knozgvzicu8.png"></p><br><p>  Nous allons maintenant √©crire des tests pour notre module compteur LED.  Les fichiers de test se trouvent dans le dossier Tests: </p><br><div class="spoiler">  <b class="spoiler_title">test_led_counter.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Test fixture class LedCounterTest: public ::testing::Test { protected: void SetUp() { Led_Counter_Init(); } }; // Check initial value TEST_F(LedCounterTest, TestInitialValue) { Led_Counter_Init(); ASSERT_EQ(Led_Counter_Get_Next(), 1); } // Check how value is incremented TEST_F(LedCounterTest, TestIncrementValue) { Led_Counter_Init(); unsigned int val = Led_Counter_Get_Next(); for(int i=0;i&lt;1;i++) { ASSERT_EQ(Led_Counter_Get_Next(), ++val); } } // Check how value return to 0 after 3 TEST_F(LedCounterTest, TestZeroCrossing) { Led_Counter_Init(); for(int i=0;i&lt;3;i++) { Led_Counter_Get_Next(); } ASSERT_EQ(Led_Counter_Get_Next(), 0); }</span></span></span></span></code> </pre> </div></div><br><p>  Pour que les r√©sultats du test soient affich√©s dans une belle fen√™tre, vous devez cr√©er une nouvelle configuration de lancement dans le menu Ex√©cuter&gt; Configurations de d√©bogage.  Le plugin install√© vous permet de cr√©er des configurations de type C / C ++ Unit.  Cr√©ez-le, appelez Ex√©cuter les tests, s√©lectionnez la configuration utilis√©e de l'assemblage ¬´Test¬ª et d√©cochez la case ¬´Arr√™ter au d√©marrage √†¬ª de l'onglet D√©bogueur.  Apr√®s cela, la configuration peut √™tre lanc√©e. </p><br><p>  Pour qu'une fen√™tre avec les r√©sultats apparaisse, s√©lectionnez-la dans Fen√™tre&gt; Afficher la vue&gt; Autre&gt; C / C ++&gt; Unit√© C / C ++. </p><br><p><img src="https://habrastorage.org/webt/ip/qd/cr/ipqdcrsjl0iohvf1yq4_99xwieq.png"></p><br><p>  C'est fait!  Maintenant, le projet peut √™tre compil√© et ex√©cut√© sous le MK cible comme d'habitude.  Lorsque vous devez ex√©cuter des tests locaux, lorsque vous ex√©cutez la configuration Ex√©cuter les tests, le projet est automatiquement reconstruit pour x86, l'environnement ex√©cute les tests et affiche le r√©sultat. </p><br><h3 id="literatura">  Litt√©rature </h3><br><ol><li>  J. Grenning.  D√©veloppement pilot√© par les tests pour Embedded C. - travaux fondamentaux sur les tests unitaires des syst√®mes embarqu√©s et sur l'application de la m√©thodologie TDD. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://uncannier.com/unit-testing-of-embedded-firmware-part-1-software-confucius/</a> - Test unitaire du code du microcontr√¥leur x86 au Texas Compments Studio Code Composer Studio, framework CppUTest </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://blog.atollic.com/why-running-your-embedded-arm-cortex-code-on-a-host-pc-is-a-good-thing</a> - un article expliquant pourquoi il pourrait √™tre utile d'ex√©cuter du code pour un microcontr√¥leur sur une plateforme de bureau </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469367/">https://habr.com/ru/post/fr469367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469351/index.html">Intel Comet Lake-U et Comet Lake-Y: jusqu'√† 6 c≈ìurs pour ordinateurs portables fins et l√©gers</a></li>
<li><a href="../fr469353/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 317 (23-29 septembre)</a></li>
<li><a href="../fr469355/index.html">Un tutoriel NumPy ennuyeux</a></li>
<li><a href="../fr469357/index.html">Courez, Gopher, courez! - de quoi parlerons-nous √† GolangConf</a></li>
<li><a href="../fr469361/index.html">Douleur et larmes dans Svelte 3</a></li>
<li><a href="../fr469369/index.html">√âv√©nements num√©riques √† Moscou du 30 septembre au 06 octobre</a></li>
<li><a href="../fr469371/index.html">Description de l'approche pour organiser et tester le code √† l'aide de Redux Thunk</a></li>
<li><a href="../fr469373/index.html">Les r√©sultats du projet de cr√©ation d'une interface neuronale pour des patients compl√®tement paralys√©s remettent en cause</a></li>
<li><a href="../fr469375/index.html">Pourquoi Mozilla, Coil et Creative Commons allouent 100 millions de dollars pour des projets open source?</a></li>
<li><a href="../fr469379/index.html">Application des m√©thodes formelles de validation des mod√®les pour l'interface utilisateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>