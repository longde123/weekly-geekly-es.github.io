<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍯 🖐🏿 🎅🏽 Segala sesuatu yang Anda ingin tahu tentang pemrosesan permintaan, tetapi malu untuk bertanya 🧙🏻 🏴‍☠️ 🤴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu layanan jaringan? Ini adalah program yang menerima permintaan masuk melalui jaringan dan memprosesnya, mungkin mengembalikan respons. 


 Ada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Segala sesuatu yang Anda ingin tahu tentang pemrosesan permintaan, tetapi malu untuk bertanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432630/"><p>  Apa itu layanan jaringan?  Ini adalah program yang menerima permintaan masuk melalui jaringan dan memprosesnya, mungkin mengembalikan respons. </p><br><p>  Ada banyak aspek di mana layanan jaringan berbeda satu sama lain.  Pada artikel ini, saya fokus pada bagaimana menangani permintaan yang masuk. </p><br><p>  Memilih metode pemrosesan permintaan memiliki konsekuensi yang luas.  Bagaimana cara membuat layanan obrolan dengan 100.000 koneksi simultan?  Pendekatan mana yang harus diambil untuk mengekstrak data dari aliran file yang tidak terstruktur dengan baik?  Pilihan yang salah akan menyebabkan pemborosan waktu dan energi. </p><br><p>  Artikel ini membahas pendekatan seperti kumpulan proses / utas, pemrosesan berorientasi peristiwa, setengah sinkronisasi / setengah pola async dan banyak lainnya.  Banyak contoh diberikan, pro dan kontra dari pendekatan, fitur dan aplikasi mereka dipertimbangkan. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Topik metode pemrosesan kueri bukanlah hal baru, lihat, misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> .  Namun, sebagian besar artikel menganggapnya hanya sebagian.  Artikel ini dimaksudkan untuk mengisi kekosongan dan memberikan presentasi yang konsisten tentang masalah ini. </p><br><p>  Pendekatan berikut akan dipertimbangkan: </p><br><ul><li>  pemrosesan berurutan </li><li>  proses permintaan </li><li>  minta aliran </li><li>  pool proses / utas </li><li>  pemrosesan berorientasi peristiwa (pola reaktor) </li><li>  half sync / half async pattern </li><li>  pengolahan conveyor </li></ul><br><p>  Perlu dicatat bahwa layanan yang memproses permintaan belum tentu merupakan layanan jaringan.  Ini mungkin layanan yang menerima tugas baru dari database atau antrian tugas.  Dalam artikel ini, layanan jaringan dimaksudkan, tetapi Anda perlu memahami bahwa pendekatan yang dipertimbangkan memiliki cakupan yang lebih luas. </p><br><h3 id="tldr">  TL; DR </h3><br><p>  Di akhir artikel adalah daftar dengan deskripsi singkat dari setiap pendekatan. </p><br><h2 id="posledovatelnaya-obrabotka">  Pemrosesan berurutan </h2><br><p>  Aplikasi terdiri dari utas tunggal dalam satu proses tunggal.  Semua permintaan diproses hanya secara berurutan.  Tidak ada paralelisme.  Jika beberapa permintaan datang ke layanan pada saat yang sama, salah satunya diproses, sisanya diantrekan. </p><br><p>  Plus, pendekatan ini mudah diterapkan.  Tidak ada kunci dan persaingan untuk sumber daya.  Minus yang jelas adalah ketidakmampuan untuk skala dengan sejumlah besar pelanggan. </p><br><h2 id="process-na-zapros">  Proses permintaan </h2><br><p>  Aplikasi terdiri dari proses inti yang menerima permintaan dan alur kerja yang masuk.  Untuk setiap permintaan baru, proses utama membuat alur kerja yang memproses permintaan.  Penskalaan dengan jumlah permintaan itu sederhana: setiap permintaan mendapatkan prosesnya sendiri. </p><br><p>  Tidak ada yang rumit dalam arsitektur ini, tetapi ada <del>  masalah </del>  <strong>keterbatasan</strong> : </p><br><ul><li>  Prosesnya menghabiskan banyak sumber daya. <br>  Coba buat 10.000 koneksi bersamaan ke RDBMS PostgreSQL dan lihat hasilnya. </li><li>  Proses tidak memiliki memori bersama (default).  Jika Anda memerlukan akses ke data bersama atau cache bersama, Anda harus memetakan memori bersama (memanggil linux mmap, munmap) atau menggunakan penyimpanan eksternal (memcahed, redis) </li></ul><br><p>  Masalah-masalah ini sama sekali tidak berhenti.  Berikut ini akan menunjukkan bagaimana mereka dikelola di PostgeSQL RDBMS. </p><br><p>  <strong>Kelebihan</strong> arsitektur ini: </p><br><ul><li>  Jatuhnya salah satu proses tidak akan mempengaruhi yang lain.  Misalnya, kesalahan pemrosesan kasus yang jarang terjadi tidak akan menjatuhkan seluruh aplikasi, hanya permintaan yang diproses yang akan menderita </li><li>  Diferensiasi hak akses pada level sistem operasi.  Karena proses adalah inti dari OS, Anda dapat menggunakan mekanisme standarnya untuk membatasi hak akses ke sumber daya OS </li><li>  Anda dapat mengubah proses yang sedang berjalan dengan cepat.  Misalnya, jika skrip terpisah digunakan untuk memproses permintaan, maka untuk mengganti algoritma pemrosesan, cukup untuk mengubah skrip.  Contoh akan dipertimbangkan di bawah ini. </li><li>  Mesin multicore digunakan secara efisien </li></ul><br><p>  <strong>Contoh:</strong> </p><br><ul><li>  RDBMS PostgreSQL menciptakan proses baru untuk setiap koneksi baru.  Memori bersama digunakan untuk bekerja dengan data umum.  PostgreSQL dapat menangani konsumsi sumber daya yang tinggi dari proses dengan berbagai cara.  Jika ada beberapa klien (sebuah dudukan khusus untuk analis), maka tidak ada masalah seperti itu.  Jika ada satu aplikasi yang mengakses database, Anda bisa membuat kumpulan koneksi database di level aplikasi.  Jika ada banyak aplikasi, Anda bisa menggunakan pgbouncer </li><li>  sshd mendengarkan permintaan yang masuk pada port 22 dan fork di setiap koneksi.  Setiap koneksi ssh adalah fork dari daemon sshd yang menerima dan mengeksekusi perintah pengguna secara berurutan.  Berkat arsitektur ini, sumber daya OS itu sendiri digunakan untuk membedakan hak akses </li><li>  Contoh dari praktik kita sendiri.  Ada aliran file tidak terstruktur dari mana Anda perlu mendapatkan metadata.  Proses layanan utama mendistribusikan file di antara proses-proses handler.  Setiap proses handler adalah skrip yang mengambil path file sebagai parameter.  Pemrosesan file terjadi dalam proses terpisah, oleh karena itu, karena kesalahan pemrosesan, seluruh layanan tidak macet.  Untuk memperbarui algoritma pemrosesan, cukup mengubah skrip pemrosesan tanpa menghentikan layanan. </li></ul><br><p>  Secara umum, saya harus mengatakan bahwa pendekatan ini memiliki kelebihan, yang menentukan cakupannya, tetapi skalabilitasnya sangat terbatas. </p><br><h2 id="potok-na-zapros">  Minta aliran </h2><br><p>  Pendekatan ini sangat mirip dengan yang sebelumnya.  Perbedaannya adalah bahwa utas digunakan sebagai ganti proses.  Ini memungkinkan Anda untuk menggunakan memori bersama di luar kotak.  Namun, keuntungan lain dari pendekatan sebelumnya tidak dapat digunakan lagi, sementara konsumsi sumber daya juga akan tinggi. </p><br><p>  <strong>Pro:</strong> </p><br><ul><li>  Keluar dari kotak memori bersama </li><li>  Kemudahan implementasi </li><li>  Penggunaan multi-core CPU secara efisien </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Aliran menghabiskan banyak sumber daya.  Pada sistem operasi mirip unix, sebuah thread mengkonsumsi sumber daya yang hampir sama banyaknya dengan suatu proses </li></ul><br><p>  Contoh penggunaannya adalah MySQL.  Tetapi perlu dicatat bahwa MySQL menggunakan pendekatan campuran, jadi contoh ini akan dibahas pada bagian selanjutnya. </p><br><h2 id="pul-processovpotokov">  Proses / kumpulan benang </h2><br><p>  Streaming (proses) membuat mahal dan panjang.  Agar tidak membuang sumber daya, Anda dapat menggunakan utas yang sama berulang kali.  Selain membatasi jumlah maksimum utas, kami memperoleh kumpulan utas (proses).  Sekarang utas utama menerima permintaan masuk dan menempatkannya dalam antrian.  Alur kerja menerima permintaan dari antrian dan memprosesnya.  Pendekatan ini dapat diambil sebagai penskalaan alami pemrosesan sekuensial permintaan: setiap utas pekerja hanya dapat memproses aliran secara berurutan, dengan menggabungkannya memungkinkan Anda memproses permintaan secara paralel.  Jika setiap aliran dapat menangani 1000 rps, maka 5 aliran akan menangani beban mendekati 5000 rps (tunduk pada kompetisi minimal untuk sumber daya bersama). </p><br><p>  Kolam dapat dibuat terlebih dahulu pada awal layanan atau dibentuk secara bertahap.  Menggunakan kumpulan utas lebih umum  memungkinkan Anda menerapkan memori bersama. </p><br><p>  Ukuran kumpulan thread tidak harus terbatas.  Layanan dapat menggunakan utas gratis dari kumpulan, dan jika tidak ada, buat utas baru.  Setelah memproses permintaan, utas bergabung dengan kumpulan dan menunggu permintaan berikutnya.  Opsi ini merupakan kombinasi dari pendekatan utas berdasarkan permintaan dan kumpulan utas.  Contoh akan diberikan di bawah ini. </p><br><p>  <strong>Pro:</strong> </p><br><ul><li>  penggunaan banyak core CPU </li><li>  pengurangan biaya untuk membuat utas / proses </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Skalabilitas terbatas dalam jumlah klien bersamaan.  Menggunakan kumpulan memungkinkan kita untuk menggunakan kembali utas yang sama beberapa kali tanpa biaya sumber daya tambahan, namun, itu tidak memecahkan masalah mendasar dari sejumlah besar sumber daya yang dihabiskan oleh utas / proses.  Membuat layanan obrolan yang dapat menahan 100.000 koneksi simultan menggunakan pendekatan ini akan gagal. </li><li>  Skalabilitas dibatasi oleh sumber daya bersama, misalnya, jika utas menggunakan memori bersama dengan menyesuaikan akses ke sana menggunakan semaphores / mutex.  Ini adalah batasan dari semua pendekatan yang menggunakan sumber daya bersama. </li></ul><br><p>  <strong>Contoh:</strong> </p><br><ol><li>  Aplikasi python berjalan dengan uWSGI dan nginx.  Proses uWSGI utama menerima permintaan masuk dari nginx dan mendistribusikannya di antara proses Python dari interpreter yang memproses permintaan.  Aplikasi ini dapat ditulis pada kerangka kerja yang kompatibel dengan uWSGI - Django, Flask, dll. </li><li>  MySQL menggunakan kumpulan utas: setiap koneksi baru diproses oleh salah satu utas gratis dari kumpulan.  Jika tidak ada utas gratis, maka MySQL membuat utas baru.  Ukuran kumpulan thread gratis dan jumlah maksimum thread (koneksi) dibatasi oleh pengaturan. </li></ol><br><p>  Mungkin ini adalah salah satu pendekatan paling umum untuk membangun layanan jaringan, jika bukan yang paling umum.  Ini memungkinkan Anda untuk skala dengan baik, mencapai rps besar.  Keterbatasan utama dari pendekatan ini adalah jumlah koneksi jaringan yang diproses secara bersamaan.  Bahkan, pendekatan ini hanya berfungsi baik jika permintaannya pendek atau sedikit pelanggan. </p><br><h2 id="sobytiyno-orientirovannaya-obrabotka-reactor-pattern">  Pemrosesan berorientasi peristiwa (pola reaktor) </h2><br><p>  Dua paradigma - sinkron dan asinkron - adalah pesaing abadi satu sama lain.  Sejauh ini, hanya pendekatan sinkron yang telah dibahas, tetapi akan salah jika mengabaikan pendekatan asinkron.  Pemrosesan permintaan yang berorientasi peristiwa atau reaktif adalah pendekatan di mana setiap operasi IO dilakukan secara serempak, dan pada akhir operasi, penangan dipanggil.  Sebagai aturan, pemrosesan setiap permintaan terdiri dari banyak panggilan tidak sinkron diikuti oleh eksekusi penangan.  Pada saat tertentu, aplikasi berulir tunggal mengeksekusi kode hanya satu penangan, tetapi eksekusi penangan berbagai permintaan bergantian satu sama lain, yang memungkinkan Anda untuk secara bersamaan (pseudo-parallel) memproses banyak permintaan paralel. </p><br><p>  Diskusi lengkap tentang pendekatan ini berada di luar cakupan artikel ini.  Untuk melihat lebih dalam, Anda dapat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reactor (Reactor)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa rahasia kecepatan NodeJS?</a>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di dalam NGINX</a> .  Di sini kami membatasi diri untuk mempertimbangkan pro dan kontra dari pendekatan ini. </p><br><p>  <strong>Pro:</strong> </p><br><ul><li>  Penskalaan efektif oleh rps dan jumlah koneksi simultan.  Layanan reaktif secara bersamaan dapat memproses sejumlah besar koneksi (puluhan ribu) jika sebagian besar koneksi menunggu I / O untuk menyelesaikan </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Kompleksitas pengembangan.  Pemrograman dalam gaya asinkron lebih sulit daripada sinkron.  Logika pemrosesan permintaan lebih kompleks, debugging juga lebih sulit daripada dalam kode sinkron. </li><li>  Kesalahan yang menyebabkan pemblokiran seluruh layanan.  Jika bahasa atau runtime awalnya tidak dirancang untuk pemrosesan asinkron, maka operasi sinkron tunggal dapat memblokir seluruh layanan, meniadakan kemungkinan penskalaan. </li><li>  Sulit untuk skala di seluruh core CPU.  Pendekatan ini mengasumsikan utas tunggal dalam satu proses tunggal, sehingga Anda tidak dapat menggunakan beberapa inti CPU secara bersamaan.  Perlu dicatat bahwa ada cara untuk mengatasi batasan ini. </li><li>  Akibat dari paragraf sebelumnya: pendekatan ini tidak menskala dengan baik untuk permintaan yang membutuhkan CPU.  Jumlah rps untuk pendekatan ini berbanding terbalik dengan jumlah operasi CPU yang diperlukan untuk memproses setiap permintaan.  Menuntut permintaan CPU meniadakan manfaat dari pendekatan ini. </li></ul><br><p>  <strong>Contoh:</strong> </p><br><ol><li>  Node.js menggunakan pola reaktor out-of-box.  Untuk detail lebih lanjut, lihat Apa rahasia kecepatan NodeJS? </li><li>  nginx: proses pekerja nginx menggunakan pola reaktor untuk memproses permintaan secara paralel.  Lihat Di Dalam NGINX untuk lebih jelasnya. </li><li>  Program C / C ++ yang langsung menggunakan alat OS (epoll di linux, IOCP di windows, kqueue di FreeBSD), atau menggunakan kerangka kerja (libev, libevent, libuv, dll.). </li></ol><br><h2 id="half-synchalf-async">  Setengah sinkronisasi / setengah asinkron </h2><br><p>  Nama ini diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSA: Pola untuk Objek Bersamaan dan Jaringan</a> .  Dalam aslinya, pola ini ditafsirkan secara luas, tetapi untuk tujuan artikel ini saya akan memahami pola ini agak lebih sempit.  Half sync / half async adalah pendekatan pemrosesan permintaan yang menggunakan aliran kontrol ringan (benang hijau) untuk setiap permintaan.  Suatu program terdiri dari satu atau lebih utas pada tingkat sistem operasi, namun, sistem pelaksanaan program mendukung utas hijau yang tidak dilihat dan tidak dapat dikendalikan oleh OS. </p><br><p>  Beberapa <strong>contoh</strong> untuk membuat pertimbangan lebih spesifik: </p><br><ol><li>  Layanan dalam bahasa Go.  Bahasa Go mendukung banyak utas eksekusi ringan - goroutine.  Program ini menggunakan satu atau lebih thread OS, tetapi programmer beroperasi dengan goroutine, yang didistribusikan secara transparan antara thread OS untuk menggunakan CPU multi-core </li><li>  Layanan python dengan perpustakaan gevent.  Pustaka gevent memungkinkan pemrogram untuk menggunakan utas hijau di tingkat pustaka.  Seluruh program dieksekusi dalam utas OS tunggal. </li></ol><br><p>  Intinya, pendekatan ini dirancang untuk menggabungkan kinerja tinggi dari pendekatan asinkron dengan kesederhanaan pemrograman kode sinkron. </p><br><p>  Dengan menggunakan pendekatan ini, terlepas dari ilusi sinkronisasi, program akan bekerja secara tidak sinkron: sistem eksekusi program akan mengontrol loop peristiwa, dan setiap operasi "sinkron" sebenarnya akan tidak sinkron.  Ketika operasi seperti itu dipanggil, sistem eksekusi akan memanggil operasi asinkron menggunakan alat OS dan mendaftarkan pawang penyelesaian operasi.  Ketika operasi asinkron selesai, sistem eksekusi akan memanggil penangan yang terdaftar sebelumnya, yang akan terus menjalankan program pada titik doa operasi "sinkron". </p><br><p>  Akibatnya, pendekatan half sync / half async mengandung beberapa kelebihan dan beberapa kelemahan dari pendekatan asinkron.  Volume artikel tidak memungkinkan kita untuk mempertimbangkan pendekatan ini secara rinci.  Bagi mereka yang tertarik, saya menyarankan Anda untuk membaca bab dengan nama yang sama di buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSA: Pola untuk Objek Bersamaan dan Jaringan</a> . </p><br><p>  Pendekatan setengah sinkronisasi / setengah asinkron itu sendiri memperkenalkan entitas "aliran hijau" baru - aliran kontrol ringan di tingkat program atau sistem eksekusi perpustakaan.  Apa yang harus dilakukan dengan utas hijau adalah pilihan programmer.  Itu bisa menggunakan kumpulan benang hijau, itu bisa membuat utas hijau baru untuk setiap permintaan baru.  Perbedaannya dibandingkan dengan thread / proses OS adalah bahwa thread hijau jauh lebih murah: mereka mengkonsumsi RAM jauh lebih sedikit dan dibuat lebih cepat.  Ini memungkinkan Anda membuat sejumlah besar utas hijau, misalnya, ratusan ribu dalam bahasa Go.  Jumlah yang sangat besar membenarkan penggunaan pendekatan green flow-on-request. </p><br><p>  <strong>Pro:</strong> </p><br><ul><li>  Ini berskala baik dalam rps dan jumlah koneksi simultan </li><li>  Kode lebih mudah untuk ditulis dan di-debug dibandingkan dengan pendekatan asinkron </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Karena pelaksanaan operasi sebenarnya tidak sinkron, kesalahan pemrograman dimungkinkan ketika satu operasi sinkron memblokir seluruh proses.  Ini terutama dirasakan dalam bahasa-bahasa di mana pendekatan ini diimplementasikan melalui perpustakaan, misalnya Python. </li><li>  Keburaman program.  Saat menggunakan utas atau proses OS, algoritma eksekusi program jelas: setiap utas / proses melakukan operasi dalam urutan yang ditulis dalam kode.  Menggunakan pendekatan half sync / half async, operasi yang ditulis secara berurutan dalam kode dapat bergantian secara tak terduga dengan operasi yang memproses permintaan secara bersamaan. </li><li>  Tidak cocok untuk sistem waktu nyata.  Pemrosesan permintaan yang tidak sinkron sangat menyulitkan penyediaan jaminan untuk waktu pemrosesan dari setiap permintaan individu.  Ini adalah konsekuensi dari paragraf sebelumnya. </li></ul><br><p>  Tergantung pada implementasinya, pendekatan ini berskala baik di seluruh inti CPU (Golang) atau tidak skala sama sekali (Python). <br>  Pendekatan ini, serta asinkron, memungkinkan Anda untuk menangani sejumlah besar koneksi simultan.  Tetapi pemrograman layanan menggunakan pendekatan ini lebih mudah, karena  kode ditulis dalam gaya sinkron. </p><br><h2 id="konveyernaya-obrabotka">  Pemrosesan conveyor </h2><br><p>  Sesuai namanya, dalam pendekatan ini, permintaan diproses melalui pipa.  Proses pemrosesan terdiri dari beberapa utas OS yang diatur dalam sebuah rantai.  Setiap utas adalah tautan dalam rantai, ia melakukan bagian tertentu dari operasi yang diperlukan untuk memproses permintaan.  Setiap permintaan secara berurutan melewati semua tautan dalam rantai, dan tautan yang berbeda pada setiap saat memproses permintaan yang berbeda. </p><br><p>  <strong>Pro:</strong> </p><br><ul><li>  Pendekatan ini berskala baik dalam rps.  Semakin banyak tautan dalam rantai, semakin banyak permintaan diproses per detik. </li><li>  Menggunakan banyak utas memungkinkan Anda untuk menskalakan inti CPU dengan baik. </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Tidak semua kategori permintaan cocok untuk pendekatan ini.  Misalnya, mengatur pemungutan suara lama menggunakan pendekatan ini akan sulit dan tidak nyaman. </li><li>  Kompleksitas implementasi dan debugging.  Mengalahkan pemrosesan sekuensial sehingga produktivitas tinggi bisa sulit.  Debugging suatu program di mana setiap permintaan diproses secara berurutan dalam beberapa utas paralel lebih sulit daripada pemrosesan sekuensial. </li></ul><br><p>  <strong>Contoh:</strong> </p><br><ol><li>  Contoh yang menarik dari pemrosesan conveyor dijelaskan dalam laporan highload 2018 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow</a> </li></ol><br><p>  Pipelining digunakan secara luas, tetapi paling sering tautannya adalah komponen individual dalam proses independen yang bertukar pesan, misalnya melalui antrian pesan atau basis data. </p><br><h2 id="rezyume">  Ringkasan </h2><br><p>  Ringkasan singkat dari pendekatan yang dipertimbangkan: </p><br><ul><li>  Pemrosesan sinkron. <br>  Pendekatan sederhana, tetapi sangat terbatas dalam skalabilitas, baik dalam rps dan dalam jumlah koneksi simultan.  Itu tidak memungkinkan penggunaan beberapa core CPU secara bersamaan. </li><li>  Proses baru untuk setiap permintaan. <br>     .         ,      .             .       ( ,     ). </li><li>     . <br>   ,     ,      .       ,      . </li><li>  /. <br>            /.        .    rps    .        .      . </li><li> -  (reactor ). <br>    rps    .   -   ,     .      CPU    </li><li> Half sync/half async. <br>    rps    .         CPU (Golang)     (Python).      ,   ()  .        reactor ,      ,    reactor . </li><li>  . <br>    ,     .       (, long polling   ). </li></ul><br><p>     ,        . </p><br><p>   :    ?    ,        ? </p><br><h3 id="ssylki">  Referensi </h3><br><ol><li>   : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     : </a> </li></ul></li><li> - : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reactor ()</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    NodeJS?</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inside NGINX</a> </li></ul></li><li>       : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache vs Nginx:  </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       Node.js  PHP</a> </li></ul></li><li> Half sync/half async: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Half-Sync/Half-Async (Java Design Patterns)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSA: Patterns for Concurrent and Networked Objects</a> </li></ul></li><li>  : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Green threads ()</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Green Vs Native Threads</a> </li></ul></li><li>  : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  -   </a> </li></ul></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432630/">https://habr.com/ru/post/id432630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432620/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 20: Keamanan Ponsel, Bagian 3</a></li>
<li><a href="../id432622/index.html">Butuh Kabur Lebih Berbeda</a></li>
<li><a href="../id432624/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 5</a></li>
<li><a href="../id432626/index.html">Cara untuk berinteraksi dengan sistem: dari kaset berlubang ke permukaan neurointer</a></li>
<li><a href="../id432628/index.html">@Pythonetc November 2018</a></li>
<li><a href="../id432634/index.html">Tinjauan Umum Lima Perpustakaan Pengembangan Web HTTP</a></li>
<li><a href="../id432636/index.html">React Tutorial Bagian 1: Ikhtisar Kursus, React, ReactDOM, dan JSX Alasan untuk Popularitas</a></li>
<li><a href="../id432638/index.html">Apa yang Baru di Upsource 2018.2</a></li>
<li><a href="../id432640/index.html">Rilis Rust 1.31 dan Rust 2018</a></li>
<li><a href="../id432642/index.html">Menggunakan DeviceLock DLP dan Citrix Xen untuk mengontrol email di perangkat seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>