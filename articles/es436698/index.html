<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 👨🏼‍🏫 🔭 ¿De cuántas maneras puedo escribir factorial en Scheme? ⏰ 👩🏿‍🤝‍👩🏼 🛠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los lenguajes malvados afirman que los lenguajes de programación funcionales son "lenguajes de escritura factoriales". Esto se define con mayor frecue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿De cuántas maneras puedo escribir factorial en Scheme?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436698/"><p> Los lenguajes malvados afirman que los lenguajes de programación funcionales son "lenguajes de escritura factoriales".  Esto se define con mayor frecuencia como el lenguaje Haskell, pero comenzaremos con el lenguaje funcional que influyó mucho tanto en Haskell como en un subconjunto de las herramientas de programación funcional para muchos otros idiomas: Scheme.  Como mínimo, <code>map</code> y <code>for-each</code> , <code>filter</code> and <code>reduce</code> , así como <code>apply</code> y <code>eval</code> llegaron a nuestros lenguajes de programación favoritos, si no desde Scheme, desde allí. </p><br><p>  Considere <em>algunas</em> formas posibles de escribir cálculos factoriales.  Al mismo tiempo, obtienes una especie de oda al lenguaje de programación Scheme.  Creo que este maravilloso lenguaje lo merece. </p><br><p>  Tengo 10 opciones para escribir definiciones de funciones, que se pueden reducir a 3 métodos principales de cálculo: el proceso computacional recursivo lineal tradicional, la iteración, la generación de una secuencia de números, seguida de la multiplicación por convolución.  Propongo considerar estas opciones con más detalle.  En el camino, consideraremos: optimización de recursión de cola, funciones de orden superior y metaprogramación, cálculos diferidos, listas interminables, memorización, una forma de crear una variable estática en Scheme y macros de higiene. </p><a name="habracut"></a><br><p>  Para los experimentos, utilizamos el antiguo y antiguo dialecto Scheme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">R5RS</a> y el popular principio de las bellas artes "medios mínimos - impresiones máximas". </p><br><p>  Todos los ejemplos de Esquema se prepararon en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DrRacket</a> 6.2 en modo R5RS.  Las mediciones de tiempo de ejecución se realizaron en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guile</a> 2.0 en el entorno del sistema operativo OpenSUSE Leap 15. </p><br><p>  Para comenzar, puede tomar una definición recursiva de factorial y simplemente reescribir la fórmula en Scheme: </p><br><pre> <code class="plaintext hljs">(define (factorial-classic n) (if (zero? n) 1 (* n (factorial-classic (- n 1)))))</code> </pre> <br><p>  El resultado fue una definición de una función (en términos de Esquema, un procedimiento, aunque de hecho es una función) para calcular el factorial, que se puede ver en innumerables guías de programación, comenzando con el libro inmortal de H. Abelson y D. Sassman "Estructura e interpretación de programas de computadora" . </p><br><p>  Puede leer y comprender este código así: factorial <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> n </script>  esta ahi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">n</span><span class="MJXp-mo" id="MJXp-Span-7" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-8">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.656ex" height="1.937ex" viewBox="0 -728.2 2435.1 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-30" x="1934" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n = 0 </script>  de lo contrario <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">n</span><span class="MJXp-mtext" id="MJXp-Span-11">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">t</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">n</span><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-19">1</span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0.111em; margin-right: 0em;">!</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.019ex" height="2.66ex" viewBox="0 -832 6035.9 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-63" x="850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-64" x="1284" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6F" x="1807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-74" x="2293" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-28" x="2654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="3044" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-2212" x="3866" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-31" x="4867" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-29" x="5367" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMAIN-21" x="5757" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n \ cdot (n-1)! </script>  .  Por lo tanto, este código corresponde a la definición recursiva de factorial, adoptada en matemáticas.  Lo único que no verificamos es la afiliación. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> n </script>  Números no negativos. </p><br><p>  Al ser recursivo, el código anterior contiene una restricción obvia en el valor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n </script>  : los datos de llamadas recursivas se acumularán en la pila hasta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> n </script>  no llegará a 0. Esto puede causar un desbordamiento de pila en general <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhjHiiIphrE0SmiXVhdwkgElh87l0g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> n </script>  . </p><br><p>  ¿Cómo puedo eliminar esta restricción?  Es necesario optimizar la recursividad de cola: reescribe el código para que la llamada recursiva se convierta en <em>cola</em> (es decir, la última en el procedimiento).  Esto permitirá que el intérprete de Scheme realice la optimización: reemplace el cálculo recursivo con el iterativo. </p><br><p>  Si utiliza las recomendaciones de los autores del libro anterior, puede obtener lo siguiente: </p><br><pre> <code class="plaintext hljs">(define (factorial-classic-tco n) (define (iteration product counter) (if (&gt; counter n) product (iteration (* product counter) (+ counter 1)))) (iteration 1 1))</code> </pre> <br><p>  Este código es un ejemplo común, y comenzando con el libro "La estructura e interpretación de los programas de computadora", es allí donde generalmente se explica la optimización de la recursividad de la cola. </p><br><p>  Fue un clásico.  Pero Scheme es flexibilidad en sí misma, ¿es posible escribir lo mismo de una manera fundamentalmente diferente?  ¿Y preferiblemente incluso más corto?  Por ejemplo, de acuerdo con la entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">n</span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.111em; margin-right: 0em;">!</span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-34">1</span><span class="MJXp-mtext" id="MJXp-Span-35">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">t</span><span class="MJXp-mn" id="MJXp-Span-40">2</span><span class="MJXp-mtext" id="MJXp-Span-41">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">t</span><span class="MJXp-mn" id="MJXp-Span-46">3</span><span class="MJXp-mtext" id="MJXp-Span-47">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">t</span><span class="MJXp-mtext" id="MJXp-Span-52">&nbsp;</span><span class="MJXp-mtext" id="MJXp-Span-53">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58">s</span><span class="MJXp-mtext" id="MJXp-Span-59">&nbsp;</span><span class="MJXp-mtext" id="MJXp-Span-60">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> n! = 1 \ cdot 2 \ cdot 3 \ cdot ~ \ cdots ~ \ cdot n </script>  formar una secuencia de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mn" id="MJXp-Span-67">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> n </script>  (o de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-70"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> n </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-mn" id="MJXp-Span-73">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> 1 </script>  ) y luego colapsarlo por multiplicación?  Afortunadamente, en Scheme esto es bastante simple gracias al procedimiento de <code>apply</code> incorporado, que aplica un procedimiento con un número arbitrario de argumentos a la lista: </p><br><pre> <code class="plaintext hljs">(define (iota n) (define (iteration sequence i) (if (&gt; in) sequence (iteration (cons i sequence) (+ i 1)))) (iteration '() 1)) (define (factorial-fold n) (apply * (iota n)))</code> </pre> <br><p>  Scheme es famoso por su conveniencia para los cálculos simbólicos debido a la "unidad de código y datos" (como a veces dicen sobre los idiomas de la familia Lisp).  Usamos esta característica: formamos una expresión para calcular el factorial de un número <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> n </script>  y luego calcularlo: </p><br><pre> <code class="plaintext hljs">(define (factorial-eval n) (define expression `(* ,@(iota n))) (eval expression (interaction-environment)))</code> </pre> <br><p>  El símbolo "entre comillas simples" significa cuasiquotación.  Sin cuasi-cita, se puede obtener una expresión para el cálculo adicional utilizando el código <code>(cons '* (iota n))</code> .  Una comilla simple (cita, cita) significa que <code>*</code> debe sustituirse en la expresión exactamente como un nombre (símbolo), y no el valor correspondiente (aquí, el procedimiento).  Entonces, con <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-76"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">n</span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-79">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n = 3 </script>  obtenemos <code>(* 3 2 1)</code> .  Esta lista es una expresión en Scheme.  Su valor se puede realizar en un entorno adecuado, lo mejor de todo: en un entorno <code>(interaction-environment)</code> entorno de <code>(interaction-environment)</code> contiene los procedimientos integrados y los procedimientos definidos por nosotros en el programa.  En realidad, esto es lo que hacemos en el cuerpo de <code>factorial-eval</code> . </p><br><p>  El esquema admite computación diferida.  Haskell, quien fue fuertemente influenciado por Scheme, usa un modelo de cálculo perezoso, es decir  no calcula el valor de la expresión hasta que se reclame el resultado de estos cálculos.  Esto permite que los programas tengan estructuras de datos tan peculiares como listas interminables.  Si solo se les toma la parte necesaria para realizar más cálculos, el programa no irá en ciclos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; take <span class="hljs-number"><span class="hljs-number">4</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span> ..] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre> <br><p>  La expresión <code>[1 ..]</code> genera una lista infinita de enteros.  La expresión <code>take 4</code> obtiene los primeros 4 elementos de esta lista.  Como los elementos de la lista subsiguientes no se reclaman, no se calculan. </p><br><p>  En Haskell obteniendo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">n</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0.111em; margin-right: 0em;">!</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> n! </script>  de una lista interminable puedes escribir así: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">factorials</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] factorials = next <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> next n fact = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n' = n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fact : next n' (fact * n') factorial :: <span class="hljs-type"><span class="hljs-type">Integer</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Integer</span></span> factorial n = factorials !! fromIntegral n</code> </pre> <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; take <span class="hljs-number"><span class="hljs-number">7</span></span> $ factorials [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">24</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">720</span></span>] ghci&gt; factorial <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">720</span></span></code> </pre> <br><p>  Usando un par de formas de Scheme <code>delay</code> / <code>force</code> intentemos hacer algo similar.  La palabra clave <code>delay</code> crea una promesa para evaluar el valor de una expresión.  La palabra clave <code>force</code> indica que realice estos cálculos, el valor resultante se calcula y almacena.  Tras el acceso repetido, no se realizan nuevos cálculos, pero se devuelve el valor calculado anteriormente. </p><br><p>  En los idiomas de la familia Lisp, las listas se construyen a partir de pares.  Para construir listas infinitas, presentamos el tipo de "par perezoso": un par en el que el primer elemento es el valor calculado y el segundo es la promesa de calcular el valor.  Para hacer esto, necesitamos complementar la "santa trinidad" de los idiomas de la familia Lisp ( <code>cons</code> , <code>car</code> , <code>cdr</code> ) con sus versiones perezosas: </p><br><pre> <code class="plaintext hljs">(define-syntax lazy-cons (syntax-rules () ((_ first second) (cons first (delay second))))) (define lazy-car car) (define (lazy-cdr lazy-pair) (force (cdr lazy-pair)))</code> </pre> <br><p>  El constructor del par <code>lazy-cons</code> se implementa como una macro.  Esto se hace para evitar calcular el valor del segundo elemento del par cuando se crea. </p><br><p>  La idea es crear una lista interminable de valores y luego tomar de ella lo que necesita.  Para hacer esto, defina la versión perezosa del procedimiento para obtener el elemento por índice: </p><br><pre> <code class="plaintext hljs">(define (lazy-list-ref lazy-list index) (if (zero? index) (lazy-car lazy-list) (lazy-list-ref (lazy-cdr lazy-list) (- index 1)))) (define (generate-factorials) (define (next nn!) (define n+1 (+ n 1)) (lazy-cons n! (next n+1 (* n! n+1)))) (next 0 1))</code> </pre> <br><p>  Aquí <code>n!</code>  y <code>n+1</code> son los nombres de las variables.  En Scheme, en comparación con otros idiomas, hay muy pocos caracteres que no se pueden usar en identificadores. </p><br><p>  Tenga en cuenta que el generador de listas infinitas <code>generate-factorials</code> no contiene una salida a la recursividad.  Sin embargo, no se realizará un bucle, ya que cuando se llama, solo se calculará el encabezado de la lista, mientras que la cola estará representada por una promesa de calcular el valor. </p><br><p>  Ahora puedes definir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">n</span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.111em; margin-right: 0em;">!</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n! </script>  como llegar <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> n </script>  Elemento de la lista de factoriales: </p><br><pre> <code class="plaintext hljs">(define lazy-factorials (generate-factorials)) (define (factorial-lazy n) (lazy-list-ref lazy-factorials n))</code> </pre> <br><p>  Funciona  Al mismo tiempo, si se calculan factores de diferentes números en una sesión del intérprete, los cálculos se realizarán más rápido que en las versiones estrictas, porque algunos de los valores de la lista diferida ya se calcularán. </p><br><p>  Por cierto, el código en Scheme es muy similar al de Haskell.  ¡Entonces, la declaración de recepción <code>!!</code>  corresponde aproximadamente al procedimiento <code>lazy-list-ref</code> constructor de <code>lazy-list-ref</code> <code>:</code> corresponde a <code>lazy-cons</code> .  Correspondientemente, porque Haskell, aunque profesa un modelo de cálculo vago, sin embargo, a diferencia del <code>delay</code> / <code>force</code> en Scheme, no recuerda los valores calculados. </p><br><p>  Por cierto, para aumentar la productividad, puede aplicar la memorización de valores ya calculados: la memorización.  Almacenaremos los valores calculados en una lista asociativa, en la que las claves son números y los valores son sus factores.  Cuando se le llame, veremos en la lista los valores ya calculados.  Si el valor está en la lista, devolveremos este valor almacenado.  Si el valor no está en la lista, lo calcularemos, lo pondremos en la lista y solo luego lo devolveremos.  Para garantizar que esta lista siempre esté con la función llamada, y no en el entorno global, la colocamos en una variable estática: </p><br><pre> <code class="plaintext hljs">(define factorial-memoized (let ((memo '())) (lambda (n) (let ((memoized (assq n memo))) (if memoized (cadr memoized) (if (zero? n) 1 (let ((computed (* n (factorial-memoized (- n 1))))) (set! memo (cons (list n computed) memo)) computed)))))))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Variables Estáticas en Esquema</b> <div class="spoiler_text"><p>  Ver código </p><br><pre> <code class="plaintext hljs">(define proc (let ((static-var initial-value)) (lambda args ...)))</code> </pre> <br><p>  es una forma aceptada por Scheme para crear un procedimiento con una variable estática.  El principio de tal anuncio puede explicarse convenientemente con un ejemplo más corto: un procedimiento que devuelve el número de llamadas: </p><br><pre> <code class="plaintext hljs">(define count (let ((n 0)) (lambda () (set! n (+ n 1)) n)))</code> </pre> <br><p>  En una sesión de intérprete, la primera llamada <code>(count)</code> devolverá 1, la segunda - 2, la tercera - 3, etc.  Como funciona </p><br><p>  Sin azúcar sintáctico, la definición de <code>count</code> ve así: </p><br><pre> <code class="plaintext hljs">(define count ((lambda (n) (lambda () (set! n (+ n 1)) n)) 0))</code> </pre> <br><p>  Por lo tanto, el procedimiento sin argumentos <code>(lambda () (set! n (+ n 1)) n)</code> , que incluye libremente <code>n</code> está asociado con el <code>count</code> nombres.  Resulta que <code>n</code> define en el entorno externo con respecto a <code>(lambda () (set! n (+ n 1)) n)</code> , lo que significa que el valor de <code>n</code> se almacenará entre llamadas para <code>count</code> .  El valor <code>n</code> inicializa a cero cuando se inicia el programa, ya que <code>(lambda (n) ...)</code> se aplica al argumento 0. Por lo tanto, <code>n</code> ausente en el entorno global, pero siempre es accesible desde el <code>count</code> . </p></div></div><br><p>  Esta implementación también promete ganancias de rendimiento al calcular repetidamente factoriales de varios números en una sesión de intérprete. </p><br><p>  Por supuesto, la optimización de recursión de cola también es posible aquí: </p><br><pre> <code class="plaintext hljs">(define factorial-memoized-tco (let ((memo '())) (lambda (n) (define (iteration product counter) (cond ((&gt; counter n) product) (else (set! memo (cons (list counter product) memo)) (iteration (* product counter) (+ counter 1))))) (iteration 1 1))))</code> </pre> <br><p>  “¿Por qué hacen estos bailes con una pandereta?”, Puede decir el lector.  En los lenguajes de programación imperativos, lo mismo se escribe simplemente: a través de un bucle, funciona rápidamente y sin costos de memoria innecesarios.  Scheme tiene un subconjunto para la programación imperativa, también tiene un medio para organizar bucles, una <em>forma especial de</em> <code>do</code> .  El procedimiento para calcular el factorial, escrito con su ayuda, puede verse así: </p><br><pre> <code class="plaintext hljs">(define (factorial-do n) (define product 1) (do ((i 1 (+ i 1))) ((&gt; in) product) (set! product (* product i))))</code> </pre> <br><p>  La construcción <code>do</code> es bastante versátil, y es por eso que no es muy legible.  ¿No es mejor organizar tu propio ciclo en un estilo imperativo?  Las macros ayudarán con esto: </p><br><pre> <code class="plaintext hljs">(define-syntax for (syntax-rules () ((_ (variable init test step) . body) (let loop ((variable init)) (if test (begin (begin . body) (loop step)))))))</code> </pre><br><p>  Gracias a la optimización de la recursividad de cola por parte del intérprete, obtenemos un bucle al que estamos acostumbrados en los lenguajes de programación imperativos.  Al optimizar la recursividad de la cola, la pila no crecerá. </p><br><p>  Definición de factorial utilizando <code>for</code> : </p><br><pre> <code class="plaintext hljs">(define (factorial-for n) (define product 1) (for (i 1 (&lt;= in) (+ i 1)) (set! product (* product i))) product)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Como funciona</b> <div class="spoiler_text"><p>  En este ejemplo, la expresión <code>(for (i 1 (&lt;= in) (+ i 1)) (set! product (* product i)))</code> coincidirá con el patrón <code>(_ (variable init test step) . body)</code> regla de sintaxis.  Se realizarán las siguientes sustituciones: </p><br><pre> <code class="plaintext hljs">for → _ i → variable 1 → init (&lt;= in) → test (+ i 1) → step (set! product (* product i)) → body</code> </pre> <br><p>  A partir de aquí, la plantilla de regla de sintaxis generará el siguiente código: </p><br><pre> <code class="plaintext hljs">(define (factorial-for n) (define product 1) (let loop ((i 1)) ;   (if (&lt;= in) ;  (begin (begin (set! product (* product i))) ;  (loop (+ i 1))))) ;  for product)</code> </pre> </div></div><br><p>  Hay otra opción que se parece al imperativo <code>for</code> bucle: con el procedimiento incorporado <code>for-each</code> : </p><br><pre> <code class="plaintext hljs">(define (factorial-for-each n) (define product 1) (for-each (lambda (i) (set! product (* product i))) (iota n)) product)</code> </pre> <br><p>  ¡Excelente y poderoso lenguaje Scheme!  ¿Qué pasa con el rendimiento? </p><br><p>  Utilizaremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GNU Guile</a> para medir el rendimiento: en este entorno puede medir el tiempo que lleva evaluar una expresión de la manera más simple. </p><br><p>  Guile funciona de la siguiente manera: compila el código fuente del programa en código de bytes, que luego es ejecutado por la máquina virtual.  Esta es solo una de las implementaciones y una de varias formas posibles de ejecutar un programa Scheme, hay otras: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Racket</a> (usa la compilación JIT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chicken Scheme</a> (usa una interpretación o compilación "honesta" en un subconjunto de C), etc.  Obviamente, tanto las limitaciones como el rendimiento de los programas en estos entornos pueden variar ligeramente. </p><br><p>  Tomaremos medidas a un cierto valor. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  .  Que debe ser <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> n </script>  ?  Entonces con el cual el más grande <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> n </script>  podrá "hacer frente" a las opciones propuestas.  Con la configuración predeterminada de Guile 2.0, en una PC con Intel Core i5 y 4 GB de RAM, obtuve lo siguiente: </p><br><table><thead><tr><th>  Procedimiento </th><th>  El problema </th></tr></thead><tbody><tr><td> <code>factorial-classic</code> </td> <td>  desbordamiento de pila en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">n</span><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-97">10</span><span class="MJXp-mspace" id="MJXp-Span-98" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-99">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> n> 10 \, 000 </script></td></tr><tr><td> <code>factorial-classic-tco</code> </td> <td>  no ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">n</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">100</span><span class="MJXp-mspace" id="MJXp-Span-104" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-105">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> n = 100 \, 000 </script>  ) </td></tr><tr><td> <code>factorial-fold</code> </td> <td>  desbordamiento de pila en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">n</span><span class="MJXp-mo" id="MJXp-Span-108" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-109">10</span><span class="MJXp-mspace" id="MJXp-Span-110" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-111">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> n> 10 \, 000 </script></td></tr><tr><td> <code>factorial-eval</code> </td> <td>  desbordamiento de pila en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">n</span><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-115">8</span><span class="MJXp-mspace" id="MJXp-Span-116" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-117">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> n> 8 \, 000 </script></td></tr><tr><td> <code>factorial-lazy</code> </td> <td>  a las <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">n</span><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-121">100</span><span class="MJXp-mspace" id="MJXp-Span-122" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-123">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> n = 100 \, 000 </script>  utiliza la partición de intercambio y se congela </td></tr><tr><td> <code>factorial-memoized</code> </td> <td>  desbordamiento de pila en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">n</span><span class="MJXp-mo" id="MJXp-Span-126" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-127">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> n> 10000 </script>  solo en el primer inicio </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td>  a las <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-128"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">n</span><span class="MJXp-mo" id="MJXp-Span-130" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-131">1</span><span class="MJXp-mspace" id="MJXp-Span-132" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-133">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n> 1 \, 000 </script>  utiliza la partición de intercambio y se congela </td></tr><tr><td> <code>factorial-do</code> </td> <td>  no ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-134"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-135">n</span><span class="MJXp-mo" id="MJXp-Span-136" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-137">100</span><span class="MJXp-mspace" id="MJXp-Span-138" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-139">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n = 100 \, 000 </script>  ) </td></tr><tr><td> <code>factorial-for</code> </td> <td>  no ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">n</span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-143">100</span><span class="MJXp-mspace" id="MJXp-Span-144" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-145">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> n = 100 \, 000 </script>  ) </td></tr><tr><td> <code>factorial-for-each</code> </td> <td>  no ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-146"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">n</span><span class="MJXp-mo" id="MJXp-Span-148" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-149">100</span><span class="MJXp-mspace" id="MJXp-Span-150" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-151">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> n = 100 \, 000 </script>  ) </td></tr></tbody></table><br><p>  A partir de aquí, las pruebas de rendimiento se realizaron a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-155">8</span><span class="MJXp-mspace" id="MJXp-Span-156" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-157">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> n = 8 \, 000 </script>  .  Los resultados se presentan en la tabla a continuación, donde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-158"><span class="MJXp-msubsup" id="MJXp-Span-159"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-161" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-163">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> t_ {run} </script>  - plazo de entrega <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-165"><span class="MJXp-msubsup" id="MJXp-Span-166"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-168" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> t_ {GC} </script>  - Tiempo de ejecución del recolector de basura en segundos. <br>  Para todos los procedimientos, excepto perezoso y memorizado, se obtienen los valores más pequeños del tiempo de ejecución y el tiempo correspondiente del recolector de basura, obtenido de los resultados de tres inicios en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-171"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">n</span><span class="MJXp-mo" id="MJXp-Span-173" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-174">8</span><span class="MJXp-mspace" id="MJXp-Span-175" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-176">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> n = 8 \, 000 </script>  . <br>  Para procedimientos memorables y perezosos, se indica el tiempo de ejecución de la primera llamada, luego la menor de las tres llamadas. </p><br><table><thead><tr><th>  Procedimiento </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-177"><span class="MJXp-msubsup" id="MJXp-Span-178"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-180" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-183">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> t_ {run} </script>  con </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-184"><span class="MJXp-msubsup" id="MJXp-Span-185"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-187" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> t_ {GC} </script>  con </th><th>  Notas </th></tr></thead><tbody><tr><td> <code>factorial-classic</code> </td> <td>  0,051 </td><td>  0,034 </td><td></td></tr><tr><td> <code>factorial-classic-tco</code> </td> <td>  0,055 </td><td>  0,041 </td><td></td></tr><tr><td> <code>factorial-fold</code> </td> <td>  0,065 </td><td>  0,059 </td><td></td></tr><tr><td> <code>factorial-eval</code> </td> <td>  0,070 </td><td>  0,040 </td><td></td></tr><tr><td> <code>factorial-lazy</code> </td> <td>  0,076 </td><td>  0,036 </td><td>  primera llamada </td></tr><tr><td> <code>factorial-lazy</code> </td> <td>  0.009 </td><td>  - </td><td>  llamadas posteriores </td></tr><tr><td> <code>factorial-memoized</code> </td> <td>  0,077 </td><td>  0,041 </td><td>  primera llamada </td></tr><tr><td> <code>factorial-memoized</code> </td> <td>  0.002 </td><td>  - </td><td>  llamadas posteriores </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td>  0,077 </td><td>  0,041 </td><td>  primera llamada </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td>  0.002 </td><td>  - </td><td>  llamadas posteriores </td></tr><tr><td> <code>factorial-do</code> </td> <td>  0,052 </td><td>  0,025 </td><td></td></tr><tr><td> <code>factorial-for</code> </td> <td>  0,059 </td><td>  0,044 </td><td></td></tr><tr><td> <code>factorial-for-each</code> </td> <td>  0,066 </td><td>  0,042 </td><td></td></tr></tbody></table><br><p>  Tenemos 4 opciones que pueden funcionar con grandes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-190"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> n </script>  .  En <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193">n</span><span class="MJXp-mo" id="MJXp-Span-194" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-195">100</span><span class="MJXp-mspace" id="MJXp-Span-196" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-197">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> n = 100 \, 000 </script>  tienen los siguientes tiempos de cálculo y recolección de basura: </p><br><table><thead><tr><th>  Procedimiento </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-198"><span class="MJXp-msubsup" id="MJXp-Span-199"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-201" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-204">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> t_ {run} </script>  con </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-205"><span class="MJXp-msubsup" id="MJXp-Span-206"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-207" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-208" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-209">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> t_ {GC} </script>  con </th></tr></thead><tbody><tr><td> <code>factorial-classic-tco</code> </td> <td>  8.468 </td><td>  6.628 </td></tr><tr><td> <code>factorial-do</code> </td> <td>  8.470 </td><td>  6.632 </td></tr><tr><td> <code>factorial-for</code> </td> <td>  8.440 </td><td>  6,601 </td></tr><tr><td> <code>factorial-for-each</code> </td> <td>  9,998 </td><td>  7,985 </td></tr></tbody></table><br><p>  Puedes ver eso con no demasiado grande <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-211"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> n </script>  el más rápido y, al mismo tiempo, el más corto es el primero.  La misma opción es más consistente con la definición matemática de factorial.  La opción de optimización de recursión de cola no es muy inferior en rendimiento.  Ambas opciones son idiomáticas recomendadas por los autores del lenguaje.  La conclusión es obvia en muchos sentidos: a menos que se especifique lo contrario, se prefiere el enfoque, que es "típico" para el lenguaje, al menos para la primera implementación de un algoritmo o método. </p><br><p>  Al mismo tiempo, el lenguaje Scheme nos permitió escribir muchas opciones para implementar el cálculo factorial, utilizando un conjunto muy limitado de primitivas (los mismos "medios mínimos - impresiones máximas").  Por lo tanto, a pesar de su edad venerable y no demasiado extendida, este lenguaje aún se puede recomendar para la programación de investigación: parece que puede implementar cualquier cosa en él de cualquier <em>manera</em> (y de <em>cualquier</em> manera) <em>conveniente</em> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436698/">https://habr.com/ru/post/es436698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436688/index.html">El gigante de TI abandona el mercado de chips para centros de datos: cuéntenos qué significa para la industria</a></li>
<li><a href="../es436690/index.html">[Preguntar - responder] sobre propiedad intelectual y protección de datos</a></li>
<li><a href="../es436692/index.html">(in) Guerra finita</a></li>
<li><a href="../es436694/index.html">Mi compilador Pascal y arte contemporáneo polaco</a></li>
<li><a href="../es436696/index.html">Cómo generar sonido binaural en una pista de audio monocanal: el video ayudará</a></li>
<li><a href="../es436700/index.html">Anti-spoofing: ¿cómo resisten los sistemas de reconocimiento facial a los estafadores?</a></li>
<li><a href="../es436704/index.html">La historia de cómo elegimos escalas para la automatización de cajas registradoras</a></li>
<li><a href="../es436708/index.html">En qué consiste IoT</a></li>
<li><a href="../es436710/index.html">Las tendencias del mercado de gamedev del año 2019 en mi humilde opinión. Descentralización?</a></li>
<li><a href="../es436712/index.html">¿Cómo promover un juego incremental? Gratis, rápido y efectivo *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>