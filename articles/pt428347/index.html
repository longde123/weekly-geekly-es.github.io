<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üè≥Ô∏è ‚õîÔ∏è O futuro do WebAssembly como uma "√°rvore de habilidades" üë∞üèø üòÉ üßëüèΩ‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algumas pessoas de alguma maneira entenderam mal o WebAssembly. H√° quem acredite que, como os navegadores j√° suportam o WebAssembly (desde 2017), tudo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O futuro do WebAssembly como uma "√°rvore de habilidades"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Algumas pessoas de alguma maneira entenderam mal o WebAssembly.  H√° quem acredite que, como os navegadores j√° suportam o WebAssembly (desde 2017), tudo est√° pronto.  Ainda nem perto, apenas o MVP (produto minimamente vi√°vel) est√° pronto.  Posso adivinhar de onde vem a raiz desse erro: ap√≥s o lan√ßamento do MVP, seus desenvolvedores prometeram manter a compatibilidade com vers√µes anteriores no n√≠vel de ‚Äúqualquer c√≥digo gravado agora funcionar√° no futuro‚Äù.  Mas isso n√£o significa que o desenvolvimento do WebAssembly esteja conclu√≠do, nem um pouco!  Muitos recursos est√£o sendo desenvolvidos agora e est√£o planejados para desenvolvimento em um futuro pr√≥ximo.  E quando eles s√£o implementados, tudo vai mudar muito. <br><br>  Voc√™ pode tentar imaginar todos esses recursos na forma de uma √°rvore de habilidades em algum jogo.  Temos algumas "b√°sicas" (recursos j√° implementados) e uma √°rvore inteira com muitos galhos e folhas que se abrir√£o com o tempo, nos dando mais e mais poder. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="imagem"></a> <br>  Vejamos o que j√° temos agora e o que ainda precisamos descobrir. <br>  ( <b>Sob o corte muitas fotos, tr√°fego</b> ) <br><a name="habracut"></a><br><h2>  Produto m√≠nimo vi√°vel (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="imagem"><br>  No in√≠cio do hist√≥rico do WebAssembly est√° o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Emscripten</a> , que tornou poss√≠vel compilar o c√≥digo C ++ no c√≥digo JavaScript.  Isso nos permitiu transferir um grande n√∫mero de bibliotecas C ++ para o mundo da Web, sem o qual seria imposs√≠vel executar c√≥digo de n√≠vel superior.  O c√≥digo JS gerado estava longe do ideal e funcionou lentamente (comparado √† sua vers√£o nativa).  Ainda assim, os engenheiros da Mozilla encontraram algumas maneiras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de torn√°-</a> lo mais r√°pido.  O principal foi a aloca√ß√£o de um subconjunto do idioma que poderia ser executado em velocidades compar√°veis ‚Äã‚Äã√†s velocidades de execu√ß√£o do c√≥digo nativo.  Esse subconjunto foi chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">asm.js.</a> <br><br>  Os desenvolvedores de outros navegadores perceberam e apreciaram a velocidade do asm.js, todos os principais navegadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">receberam</a> seu suporte.  Mas isso n√£o terminou a hist√≥ria.  Isso foi apenas o come√ßo.  Ainda havia espa√ßo para trabalhar mais r√°pido.  Mas eles j√° foram al√©m do Javascript.  Aconteceu que o c√≥digo nativo (por exemplo, em C ++) tinha que ser compilado n√£o em Javascript, mas em outra coisa.  Em algo novo, criado especificamente como uma alternativa r√°pida ao JS.  E assim surgiu o WebAssembly. <br><br>  O que est√° inclu√≠do na primeira vers√£o do WebAssembly?  O que foi suficiente para obter o orgulhoso t√≠tulo de "produto m√≠nimo vi√°vel"? <br><br><h3>  Habilidade: plataforma do compilador de destino </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="imagem"><br><br>  Os programadores que trabalharam no WebAssembly entenderam que sua tarefa n√£o era oferecer suporte apenas a C ou C ++.  A tarefa era dar a oportunidade de compilar c√≥digo em qualquer idioma no WebAssembly.  Tinha que ser um "assembler", que deveria ser executado no navegador, assim como o c√≥digo da m√°quina do aplicativo de desktop √© executado, por exemplo, na plataforma x86.  Mas essa nova linguagem n√£o deve se basear em nenhuma plataforma espec√≠fica, seu objetivo deve ser uma plataforma abstrata de n√≠vel superior, cuja implementa√ß√£o espec√≠fica j√° dependa do conjunto de instru√ß√µes usadas neste hardware. <br><br><h3>  Habilidade: execu√ß√£o r√°pida de c√≥digo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="imagem"><br><br>  Tudo tinha que funcionar r√°pido.  Caso contr√°rio, por que se preocupar com toda essa hist√≥ria?  No final, o usu√°rio deve poder executar aplicativos realmente ‚Äúpesados‚Äù, jogar os melhores jogos no navegador etc. <br><br><h3>  Habilidade: Compacidade </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="imagem"><br><br>  √â importante n√£o apenas a velocidade de execu√ß√£o do c√≥digo, mas tamb√©m a velocidade de seu carregamento.  Os usu√°rios est√£o acostumados a aplicativos de desktop que s√£o iniciados muito rapidamente (porque s√£o instalados localmente e t√™m todos os recursos necess√°rios em m√£os).  Os aplicativos da Web tamb√©m s√£o executados com relativa rapidez, porque n√£o carregam muitos recursos de uma s√≥ vez.  E isso representa um novo desafio para n√≥s: se queremos criar um novo tipo de aplicativo Web com uma base de c√≥digo t√£o grande quanto a cl√°ssica de desktop, mas que pode ser baixada da Internet, o c√≥digo deve ser o mais compacto poss√≠vel. <br><br><h3>  Habilidade: acesso √† mem√≥ria </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="imagem"><br><br>  Nossos novos aplicativos tamb√©m precisar√£o trabalhar com a mem√≥ria de uma maneira ligeiramente diferente do c√≥digo JavaScript.  Precisa de acesso direto aos blocos de mem√≥ria.  Isso se deve √† peculiaridade das linguagens C e C ++, nas quais existem ponteiros.  Um ponteiro √©, grosso modo, uma vari√°vel que cont√©m um endere√ßo na mem√≥ria.  Um aplicativo pode ler dados nesse endere√ßo, alter√°-lo e at√© usar aritm√©tica em um ponteiro para "caminhar" na mem√≥ria para frente a partir do endere√ßo especificado.  Uma grande quantidade de c√≥digo C / C ++ usa ponteiros para aumentar a efici√™ncia de seu trabalho, √© imposs√≠vel criar uma plataforma de destino para esse c√≥digo sem o suporte de ponteiros. <br><br>  Mas n√£o podemos permitir que qualquer parte do c√≥digo baixado da Internet tenha acesso direto √† mem√≥ria do nosso processo - isso √© muito perigoso.  Teremos que criar um ambiente que, por um lado, permita que o c√≥digo nativo compilado no WebAssembly acredite que ele tenha acesso direto √† mem√≥ria, mas, por outro lado, limitar√° estritamente a √°rea na qual √© permitido manipular dados. <br><br>  Para isso, o WebAssembly usa o "modelo de mem√≥ria linear".  Isso √© implementado usando TypedArrays - algo como uma matriz em JavaScript, mas contendo apenas um conjunto seq√ºencial de bytes na mem√≥ria.  Quando voc√™ deseja colocar algo nele, usa o acesso ao elemento pelo √≠ndice (que pode ser um endere√ßo na mem√≥ria).  Portanto, essa matriz "finge" ser um bloco de mem√≥ria para o c√≥digo C ++. <br><br><h3>  Nova conquista! </h3><br>  Portanto, com todas as op√ß√µes acima, as pessoas finalmente poder√£o executar o aplicativo de desktop em um navegador com aproximadamente o mesmo desempenho como se fosse nativo.  √â sobre esse conjunto de recursos e foi chamado de "produto m√≠nimo vi√°vel" (MVP). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="imagem"><br><br>  Nesse ponto, alguns aplicativos j√° poderiam ser criados no WebAssembly e ganhar dinheiro com o navegador.  Mas ainda havia um longo caminho pela frente. <br><br><h2>  Aplicativos de desktop pesados </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="imagem"><br><br>  O pr√≥ximo passo importante deve ser a capacidade de iniciar aplicativos de desktop realmente grandes.  Voc√™ pode imaginar a vers√£o completa do Photoshop rodando em um navegador?  E voc√™ n√£o o instalou, apenas abriu o link - e agora voc√™ tem todo o poder de 100% deste produto, na velocidade nativa, a vers√£o mais recente com todas as atualiza√ß√µes e corre√ß√µes, em qualquer dispositivo. <br><br>  E n√£o estamos t√£o longe disso - exemplos j√° est√£o come√ßando a aparecer.  Por exemplo, AutoCAD.  E tamb√©m o Adobe Lightroom.  Mas sejamos honestos - nem tudo est√° pronto na implementa√ß√£o atual do WebAssembly para lan√ßar aplicativos realmente grandes.  Os gargalos s√£o investigados e corrigidos aqui neste momento, quando voc√™ l√™ este artigo. <br><br><h3>  Habilidade: multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="imagem"><br><br>  Obviamente, precisamos de multithreading.  Computadores modernos t√™m muitos n√∫cleos.  Precisamos ser capazes de us√°-los. <br><br><h3>  Habilidade: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="imagem"><br><br>  Al√©m do multithreading, h√° outra tecnologia que permite uma implementa√ß√£o mais eficiente do processamento de dados paralelo.  Isso √© SIMD: processamento por uma √∫nica instru√ß√£o de v√°rios blocos de dados ao mesmo tempo.  Um aspecto importante necess√°rio para um WebAssembly realmente r√°pido. <br><br><h3>  Habilidade: endere√ßamento de 64 bits </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="imagem"><br><br>  Outro recurso importante da arquitetura moderna de hardware, que ainda n√£o est√° dispon√≠vel no WebAssembly, √© o suporte ao endere√ßamento de mem√≥ria de 64 bits.  √â simples: com endere√ßos de 32 bits, voc√™ pode usar apenas 4 GB de mem√≥ria (o que √© muito pequeno para programas grandes), mas com endere√ßos de 64 bits j√° √© de at√© 16 exabytes (isso √© muito para o software moderno).  Obviamente, n√£o apenas o m√°ximo te√≥rico √© importante, mas tamb√©m o pr√°tico (quanta mem√≥ria o sistema operacional fornecer√° a voc√™).  Mas na maioria dos dispositivos modernos j√° existem 4 ou mais GB de RAM e esse n√∫mero aumentar√°. <br><br><h3>  Habilidade: Stream Compilation </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="imagem"><br><br>  Precisamos n√£o apenas executar aplicativos rapidamente.  Tamb√©m precisamos reduzir o intervalo de tempo entre o in√≠cio do download pela rede e o in√≠cio.  A compila√ß√£o de fluxo permite iniciar o processamento de um arquivo WebAssembly antes de finalmente ser baixado.  Analisamos as instru√ß√µes √† medida que elas s√£o baixadas pela rede.  Assim, o carregamento e a compila√ß√£o ocorrem paralelamente.  No c√≥digo do Firefox, conseguimos atingir uma velocidade de compila√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maior que a velocidade de download</a> - ou seja, o tempo de processamento de algum c√≥digo de N bytes acabou sendo menor que o tempo de download desse c√≥digo na rede.  Os desenvolvedores de outros navegadores tamb√©m est√£o trabalhando na compila√ß√£o de fluxo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="imagem"><br><br>  Uma coisa relacionada √† compila√ß√£o de streaming √© o uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois compiladores</a> .  Um deles (descrito acima) funciona rapidamente e permite iniciar imediatamente o c√≥digo baixado.  No entanto, ele n√£o realiza todas as otimiza√ß√µes teoricamente poss√≠veis, pois isso requer mais tempo.  Essas otimiza√ß√µes s√£o executadas por outro compilador trabalhando em segundo plano.  Assim que ele termina seu trabalho, uma vers√£o na mem√≥ria substitui outra e, em seguida, funciona. <br><br>  Portanto, temos o in√≠cio r√°pido do aplicativo e sua opera√ß√£o efetiva. <br><br><h3>  Habilidade: Armazenamento em cache </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="imagem"><br><br>  Se uma vez baixamos e compilamos algum c√≥digo do WebAssembly pelo compilador de otimiza√ß√£o, n√£o faz sentido fazer o mesmo ao carregar esse c√≥digo em outra guia (ou na pr√≥xima vez que o navegador for aberto, desde que o aplicativo permane√ßa inalterado).  O c√≥digo compilado pode (e deve) ser armazenado em cache e depois usado no cache. <br><br><h3>  Habilidade: outras melhorias </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="imagem"><br><br>  Agora, h√° muita discuss√£o sobre quais outras melhorias s√£o poss√≠veis e sobre o que os esfor√ßos dos desenvolvedores devem ser focados.  Definitivamente, algo ser√° realizado, algo n√£o imediatamente, algo n√£o acontecer√°.  Eu, com sua permiss√£o, definirei todos esses pontos na classe geral ‚Äúoutras melhorias‚Äù, e o que entraremos nisso entenderemos com o tempo. <br><br><h3>  Onde estamos agora? </h3><br>  Em algum lugar por aqui: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="imagem"><br><br><h4>  Multithreading </h4><br>  Para multithreading, temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plano</a> quase pronto, mas uma de suas partes principais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SharedArrayBuffers</a> ) foi for√ßada a ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desativada</a> no in√≠cio deste ano.  Ele ser√° reativado em breve e podemos continuar. <br><br><h4>  SIMD </h4><br>  <a href="">Desenvolvido</a> ativamente agora. <br><br><h4>  Endere√ßamento de 64 bits </h4><br>  Para o <a href="">wasm-64</a> , temos uma ideia bastante clara de como as coisas devem funcionar.  Baseamos-nos nas abordagens da arquitetura x86 e ARM. <br><br><h4>  Compila√ß√£o de stream </h4><br>  No Firefox, foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionado</a> em 2017, outros navegadores est√£o trabalhando nele. <br><br><h4>  Usando dois compiladores </h4><br>  No Firefox, isso foi adicionado em 2017 e em outros navegadores em 2018. <br><br><h4>  Cache HTTP impl√≠cito </h4><br>  No Firefox, o desenvolvimento est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quase completo</a> , haver√° um lan√ßamento em breve. <br><br><h4>  Outras melhorias </h4><br>  H√° uma discuss√£o <br><br>  Como voc√™ pode ver, a maioria dos itens ainda est√° em desenvolvimento ativo.  E, no entanto, j√° podemos ver aplicativos em execu√ß√£o no WebAssembly hoje, pois os recursos de hoje j√° s√£o suficientes para algu√©m.  Assim que todos os recursos acima estiverem prontos, abriremos outra "nova conquista" e ainda mais novos aplicativos receber√£o suporte do WebAssembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="imagem"><br><br><h2>  Intera√ß√£o Javascript </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="imagem"></a> <br><br>  O WebAssembly foi criado n√£o apenas como uma plataforma para jogos e aplicativos pesados.  Pode ser usado para o desenvolvimento regular da web.  Estamos cientes de que hoje existem aplicativos Web muito grandes escritos em Javascript e poucos decidem lev√°-los e reescrev√™-los completamente no WebAssembly.  O ponto importante aqui √© que isso n√£o √© necess√°rio.  Provavelmente, a maioria desses aplicativos funciona muito bem e apenas em alguns gargalos, talvez, haja uma falta de desempenho nos c√°lculos, na largura de banda do processamento de dados ou na funcionalidade devido √† falta de uma vers√£o JS de alguma biblioteca.  Queremos dar aos desenvolvedores a oportunidade de reescrever apenas esses gargalos no WebAssembly, deixando o restante do c√≥digo em JS familiar.  E j√° √© poss√≠vel.  Por exemplo, reescrevendo o analisador de Gutenberg para Rust e montando-o no WebAssebly, conseguimos obter um aumento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">86 vezes</a> na produtividade. <br><br>  Mas, para tornar essa pr√°tica em massa e conveniente, precisamos implementar outra coisa. <br><br><h3>  Habilidade: chamadas r√°pidas entre JS e WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="imagem"><br><br>  Chamar o WebAssembly a partir de JS deve funcionar muito r√°pido.  Ao adicionar um pequeno m√≥dulo WebAssembly, o programador n√£o deve sentir nenhuma perda de desempenho, mesmo que esse m√≥dulo seja chamado com muita frequ√™ncia.  Este n√£o √© o caso no MVP (j√° que o objetivo do MVP n√£o era maximizar o desempenho de tais chamadas).  Este problema ainda n√£o foi corrigido.  No Firefox, j√° garantimos que algumas chamadas JS-&gt; WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√°</a> sejam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais r√°pidas do que as chamadas JS-&gt; JS n√£o embutidas</a> .  Os desenvolvedores de outros navegadores tamb√©m est√£o trabalhando nessa tarefa. <br><br><h3>  Habilidade: troca r√°pida de dados </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="imagem"><br><br>  Esta tarefa est√° conectada √† anterior: √© importante n√£o apenas chamar rapidamente o c√≥digo WebAssembly de JS, mas tamb√©m transferir rapidamente dados entre eles.  Existem certos problemas com isso.  Por exemplo, o fato de o WebAssembly entender apenas n√∫meros.  N√£o h√° objetos nele, mas em JS eles s√£o.  Acontece que precisamos de algum tipo de camada de tradu√ß√£o.  Ele j√° existe, mas ainda n√£o √© produtivo o suficiente. <br><br><h3>  Habilidade: integra√ß√£o com m√≥dulos ES </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="imagem"><br><br>  Agora, usar o m√≥dulo WebAssembly parece chamar uma API especial que retornar√° o m√≥dulo para voc√™ para uso.  Mas isso significa que o m√≥dulo WebAssembly n√£o √© realmente parte do gr√°fico do m√≥dulo JS do aplicativo Web.  Para ter todas as fun√ß√µes dispon√≠veis para os m√≥dulos ES (como exporta√ß√£o e importa√ß√£o), o m√≥dulo WebAssembly deve poder integrar-se aos m√≥dulos ES. <br><br><h3>  Habilidade: Integra√ß√£o no Desenvolvimento </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="imagem"><br><br>  Ser capaz de importar e exportar n√£o significa tornar-se um m√≥dulo totalmente funcional.  Precisamos de um local onde os m√≥dulos do WebAssembly possam ser distribu√≠dos.  Qual ser√° o an√°logo do npm para o WebAssembly?  Hmm ... que tal npm em si?  E qual ser√° o an√°logo do webpack ou do Parcel for WebAssembly?  Hmm ... e o webpack e o Parcel? <br><br>  Os m√≥dulos WebAssembly n√£o devem diferir dos m√≥dulos comuns, o que significa que eles podem ser distribu√≠dos pela mesma infraestrutura.  Mas precisamos de ferramentas para integr√°-los a essa infraestrutura. <br><br><h3>  Habilidade: Compatibilidade com vers√µes anteriores </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="imagem"><br><br>  H√° outra coisa importante que devemos fornecer.  Tudo deve funcionar bem, mesmo em vers√µes mais antigas de navegadores.  Mesmo aqueles que n√£o t√™m id√©ia do WebAssembly.  Devemos garantir que, depois de escrever o c√≥digo para o WebAssembly, o desenvolvedor n√£o precisar√° escrever a segunda vers√£o do mesmo c√≥digo em Javascript, simplesmente porque o site tamb√©m deve abrir no IE11. <br><br><h3>  Onde estamos agora? </h3><br>  Em algum lugar aqui: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="imagem"><br><br><h4>  Atalhos entre JS e WebAssembly </h4><br>  J√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementado</a> no Firefox, o trabalho est√° em andamento em outros navegadores. <br><br><h4>  Troca r√°pida de dados </h4><br>  Existem v√°rias sugest√µes.  Por exemplo, expanda o sistema de tipos no WebAssembly com refer√™ncias a objetos JS.  Isso √© poss√≠vel, mas ser√° necess√°rio escrever c√≥digo adicional (por exemplo, para chamar m√©todos JS), que n√£o funciona muito r√°pido.  Para resolver esse problema, por sua vez, existem v√°rias sugest√µes. <br><br>  H√° outro aspecto relacionado √† troca de dados.  Trata-se de rastrear quanto tempo os dados podem ser armazenados na mem√≥ria.  Se voc√™ tiver algum dado na mem√≥ria ao qual o c√≥digo JS deve ter acesso, dever√° deix√°-lo l√° at√© que o c√≥digo JS o leia.  Mas se voc√™ deix√°-los l√° para sempre, teremos um vazamento de mem√≥ria.  Como descobrir que os dados j√° podem ser exclu√≠dos (o c√≥digo JS j√° os leu)?  Hoje, essa responsabilidade recai sobre o programador - tudo √© liberado manualmente.  Depois que o c√≥digo JS terminar de ler os dados, ele dever√° chamar algo como a fun√ß√£o "free".  Mas essa abordagem est√° desatualizada e geralmente leva a erros.  Para resolver esse problema, introduzimos o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WeakRef</a> em Javascript.  Isso possibilita a leitura de dados no lado do c√≥digo JS e, quando o coletor de lixo funciona, √© necess√°rio limpar corretamente a mem√≥ria no m√≥dulo WebAssembly. <br><br>  Tudo isso ainda est√° em desenvolvimento.  Enquanto isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, ferramentas</a> foram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criadas</a> no ecossistema Rust que automatizam a grava√ß√£o desse c√≥digo para voc√™, substituindo partes que ainda n√£o foram implementadas por sua pr√≥pria implementa√ß√£o.  Uma dessas ferramentas merece men√ß√£o especial.  √â chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wasm-bindgen</a> .  Quando ele percebe que seu c√≥digo Rust est√° tentando obter ou retornar objetos JS ou objetos DOM, ele cria automaticamente uma camada JS que poder√° interagir com seu c√≥digo Rust.  E essa camada tamb√©m √© capaz de interagir com o m√≥dulo WebAssembly escrito em qualquer outro idioma, para que n√£o apenas os programadores do Rust possam usar essa ferramenta. <br><br><h4>  Integra√ß√£o com m√≥dulos ES </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um plano de</a> trabalho nessa √°rea j√° existe h√° algum tempo.  Estamos trabalhando ativamente com desenvolvedores de outros navegadores. <br><br><h4>  Integra√ß√£o de Desenvolvimento </h4><br>  J√° existem ferramentas como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wasm-pack</a> no ecossistema Rust que permitem empacotar automaticamente tudo o que voc√™ precisa para libera√ß√£o em npm.  E h√° pessoas usando essa ferramenta para criar seus m√≥dulos. <br><br><h4>  Compatibilidade com vers√µes anteriores </h4><br>  Para compatibilidade com vers√µes anteriores, temos a ferramenta wasm2js.  Ele permite transformar um arquivo wasm em um arquivo JS equivalente.  Este c√≥digo Javascript n√£o ser√° r√°pido, mas funcionar√° em qualquer navegador (incluindo um que n√£o suporte o WebAssembly). <br><br>  Como voc√™ pode ver, estamos muito perto de receber essa "conquista".  E assim que fizermos isso, o caminho para mais dois se abrir√°. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="imagem"></a> <br><br><h2>  Estruturas JS e linguagens compiladas JS </h2><br>  O primeiro √© a capacidade de reescrever estruturas JS pesadas populares no WebAssebly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="imagem"><br><br>  O segundo √© habilitar as linguagens de programa√ß√£o compiladas em Javascript para substitu√≠-lo pelo WebAssembly.  Estamos falando de idiomas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="imagem"><br><br>  Para ambas as tarefas, o WebAssembly deve suportar v√°rios novos recursos de alto n√≠vel. <br><br><h3>  Habilidade: Garbage Collector </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="imagem"><br><br>  Precisamos de integra√ß√£o com um coletor de lixo baseado em navegador por v√°rios motivos.  Primeiro, vamos relembrar a tarefa de reescrever estruturas JS (ou partes delas).  Pode ser necess√°rio. ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm ‚Äî     Javascript,        .   WebAssembly      ‚Äî          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="imagem"><br><br>    . ,  ,  Rust,   .    ‚Äî .            ‚Äî    .       WebAssembly     . <br><br>  ,    Javascript.          ‚Äî -           - .   WebAssembly-  JS-,     ‚Äî      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="imagem"><br><br>   ,    JS-,    .         Javascript-.         WebAssembly. <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="imagem"><br><br>       ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ".       ,        ‚Äî              .         ,        WebAssembly. <br><br><h3>   ? </h3><br> -  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="imagem"><br><br><h4>   </h4><br>  Para implementar a coleta de lixo, o trabalho est√° em andamento em duas dire√ß√µes: esses s√£o os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objetos digitados</a> para JS e, de fato, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o coletor de lixo para o WebAssembly</a> .  Objetos digitados permite descrever a estrutura clara do objeto.  J√° existe uma vis√£o de como isso deve funcionar e ser√° discutido na pr√≥xima reuni√£o do TC39.  Consequentemente, o GC para WebAssembly poder√° acessar a estrutura acima para seus pr√≥prios fins.  O trabalho j√° est√° em andamento em sua implementa√ß√£o. <br><br>  Assim que as duas partes forem conclu√≠das, obteremos um sistema interagindo JS e WebAssembly, capaz de entender em todos os n√≠veis em que o objeto consiste e usar efetivamente seus dados internos.  J√° temos um prot√≥tipo em funcionamento.  O prot√≥tipo, no entanto, n√£o pode ser apenas capturado e liberado - temos que gastar algum tempo em padroniza√ß√£o e revis√µes.  Esperamos que ele chegue ao lan√ßamento em algum lugar no ano de 2019. <br><br><h4>  Manipula√ß√£o de exce√ß√£o </h4><br>  O trabalho sobre <a href="">exce√ß√µes est√°</a> atualmente em pesquisa e desenvolvimento.  Consideramos v√°rias propostas, tentamos implement√°-las e veremos com que efic√°cia elas funcionam. <br><br><h4>  Depura√ß√£o </h4><br>  Para depura√ß√£o, j√° existe algum suporte nas ferramentas de desenvolvedor do Firefox.  Mas o ideal ainda est√° longe.  Queremos mostrar ao desenvolvedor seu c√≥digo fonte e posi√ß√£o atual, e n√£o apenas instru√ß√µes do assembler.  Temos que desenvolver e implementar suporte para arquivos de s√≠mbolos, o que nos permitir√° correlacionar cada instru√ß√£o de c√≥digo com a linha de origem.  No momento, <a href="">est√°</a> em <a href="">andamento</a> o trabalho de especifica√ß√£o desse mecanismo. <br><br><h4>  Chamadas de cauda </h4><br>  <a href="">Trabalho em andamento</a> . <br><br>  Quando todas as op√ß√µes acima forem conclu√≠das, podemos assumir que alcan√ßamos a conquista "estruturas e linguagens JS compiladas em JS" <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="imagem"></a> <br><br>  Portanto, era um plano para obter "conquistas" no navegador.  E o que acontece fora do navegador? <br><br><h2>  Fora do navegador </h2><br>  Talvez voc√™ tenha ficado envergonhado pela combina√ß√£o das palavras "fora do navegador".  Realmente temos algo al√©m do navegador quando falamos sobre a web?  Mas a "web" temos o nome "WebAssembly".  Mas, de fato, HTML, CSS e JavaScript s√£o apenas a ponta do iceberg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="imagem"><br><br>  Sim, eles s√£o mais vis√≠veis, porque s√£o eles que formam a interface do usu√°rio.  Mas h√° outra parte muito importante da web - s√£o as conex√µes.  A conex√£o de tudo com tudo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="imagem"><br><br>  Eu posso criar um link para sua p√°gina agora.  N√£o preciso da sua permiss√£o ou de ningu√©m.  Acabei de criar este link e adicion√°-lo ao meu site.  Qualquer um pode segui-lo e seu conte√∫do ser√° mostrado, o c√≥digo que voc√™ escreveu ser√° lan√ßado.  Essa simplicidade de criar conex√µes e fazer a transi√ß√£o atrav√©s delas criou nossa Internet como ela √©.  Agora, temos redes sociais e outros sites que, em ess√™ncia, expandem o conceito de "link" com a capacidade de encaixar qualquer coisa: pessoas, dispositivos, empresas etc. <br><br>  Mas com todos esses links e links, existem dois problemas. <br><br>  Primeiro, a que o link deve levar?  Se voc√™ for a algum lugar e o site oferecer algum c√≥digo que deve ser executado no seu navegador - esse c√≥digo deve ser multiplataforma.  Ele deve ser compilado em algo e executado em uma papoula, no Windows, em um andr√≥ide.  Em todos os lugares.  A portabilidade do c√≥digo para download √© uma parte importante do conceito de conectividade da Web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="imagem"><br><br>  Mas apenas baixar e executar o c√≥digo n√£o √© suficiente.  Voc√™ precisa entender que n√£o sabemos nada sobre esse c√≥digo.  N√£o confiamos nele o suficiente para fornecer controle total sobre o computador do usu√°rio.  E se for um c√≥digo malicioso?  Ele pode fazer algo ruim.  E aqui precisamos de algum tipo de modelo de seguran√ßa.  Precisamos de uma caixa de areia onde possamos colocar um c√≥digo desconhecido, fornecer algumas ferramentas controladas para o trabalho, mas remover tudo que √© criticamente importante e inseguro. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="imagem"><br><br>  Portanto, existem dois aspectos do conceito de "comunica√ß√£o": portabilidade e seguran√ßa.  Sabemos que podemos definitivamente executar o c√≥digo e que certamente n√£o ir√° nos prejudicar.  Por que insisto nesses conceitos e como essa vis√£o das coisas difere da vis√£o da Web como uma combina√ß√£o de HTML, CSS e Javascript?  Porque essa abordagem altera fundamentalmente a vis√£o do que √© o WebAssembly. <br><br>  Por um lado, podemos pensar no WebAssembly como "outra ferramenta dispon√≠vel em um navegador moderno".  E assim √©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="imagem"><br><br>  Mas a portabilidade e a seguran√ßa da execu√ß√£o do c√≥digo nos abrem outras portas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="imagem"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="imagem"><br><br>  Como o WebAssembly pode ajudar o Node?  Trazendo portabilidade. <br><br>  O n√≥ fornece um n√≠vel razoavelmente alto de portabilidade usando Javascript.  Mas ainda existem muitos casos em que o desempenho do c√≥digo JS n√£o √© suficiente ou apenas o c√≥digo JS correto ainda n√£o foi gravado, mas existe uma vers√£o nativa.  E ent√£o o Node usa m√≥dulos nativos.  Eles s√£o escritos em idiomas como C e precisam ser compilados para a plataforma espec√≠fica em que o Node est√° executando. <br><br>  Os m√≥dulos nativos podem ser compilados durante a instala√ß√£o ou voc√™ pode lev√°-los imediatamente prontos para uma das plataformas populares.  Ambas as abordagens s√£o poss√≠veis, mas essa √© apenas uma escolha de dois males: uma dor de cabe√ßa extra para o usu√°rio ou o autor do m√≥dulo. <br><br>  Se voc√™ imagina que esses m√≥dulos estar√£o no WebAssembly, eles n√£o precisar√£o ser compilados.  A portabilidade permite execut√°-los em qualquer plataforma, imediatamente, como c√≥digo Javascript.  Mas eles funcionar√£o com o desempenho de vers√µes nativas. <br><br>  E aqui a felicidade chega ao mundo de Node na forma de total portabilidade de tudo e de todos os lugares.  Voc√™ pode portar o aplicativo Node do Linux para o Windows - e tudo continuar√° funcionando sem nenhuma recompila√ß√£o.  Mas, ao mesmo tempo, o m√≥dulo WebAssembly n√£o tem acesso aos recursos do sistema (ele funciona em sua sandbox).  Mas os m√≥dulos Node nativos (e at√© n√£o nativos) n√£o funcionam na sandbox, eles t√™m acesso a tudo - essa √© a ideologia do Node.  Portanto, para que o m√≥dulo WebAssembly obtenha os mesmos recursos, √© necess√°ria uma camada adicional de acesso aos recursos do SO.  Algo parecido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com as</a> fun√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">POSIX</a> (elas n√£o s√£o necess√°rias, s√£o fornecidas apenas como um exemplo de uma interface de acesso a recursos relativamente est√°vel e suficiente). <br><br><h3>  Habilidade: interface port√°til </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="imagem"><br><br>  Ent√£o, o que os desenvolvedores do Node precisam para usar os m√≥dulos WebAssembly?  Algum tipo de interface para acessar suas fun√ß√µes.  Seria bom padroniz√°-lo.  Bem, para que n√£o apenas o Node possa chamar essas fun√ß√µes, mas tamb√©m qualquer pessoa em geral.  Se voc√™ deseja usar o m√≥dulo WebAssembly no seu aplicativo, n√≥s estamos conectados e o estamos usando.  Algo como "POSIX for WebAssembly".  PWSIX (interface do sistema WebAssembly port√°til)? <br><br><h3>  Onde estamos agora? </h3><br>  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documento</a> que descreve o mecanismo para fornecer um caminho para um m√≥dulo por seu nome.  √â prov√°vel que seja usado pelos navegadores e pelo Node (eles poder√£o fornecer caminhos diferentes).  Embora n√£o haja desenvolvimento ativo, h√° muita discuss√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="imagem"><br><br>  Muito provavelmente ser√° implementado de alguma forma.  Isso √© bom porque abre uma s√©rie de possibilidades para n√≥s. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="imagem"></a> <br><br><h2>  CDN, sem servidor e computa√ß√£o de borda </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="imagem"><br><br>  Exemplos s√£o CDN, Serverless, Edge Computing.  Casos quando voc√™ coloca seu c√≥digo no servidor de outra pessoa, que cuida de sua disponibilidade para os clientes.  Por que voc√™ pode precisar do WebAssembly aqui?  Recentemente, houve um excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> sobre esse t√≥pico.  Em resumo, pode ser necess√°rio executar o c√≥digo de fontes diferentes (n√£o confiando uma na outra) dentro de um processo.  Esse c√≥digo precisa ser isolado um do outro e do sistema operacional.  Solu√ß√µes como uma m√°quina virtual JS (SpiderMonkey ou V8) de alguma forma funcionam, mas n√£o fornecem o desempenho e a escalabilidade desejados.  E WebAssembly - d√°. <br><br>  O que √© necess√°rio para fazer isso funcionar? <br><br><h3>  Habilidade: tempo de execu√ß√£o </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="imagem"><br><br>  Precisamos de um ambiente de tempo de execu√ß√£o e algumas empresas criam seus pr√≥prios.  J√° temos compiladores WebAssembly (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cranelift</a> ) - eles s√£o r√°pidos e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">economizam</a> mem√≥ria.  Mas o c√≥digo gerado por ele n√£o pode viver no v√°cuo - ele precisa confiar em algo, de alguma forma interagir com o ambiente.  Agora, algumas empresas, como a Fastly, escrevem esse ambiente de tempo de execu√ß√£o por conta pr√≥pria.  Mas essa n√£o √© uma abordagem muito boa - afinal, muitas empresas precisar√£o dela e far√£o o mesmo trabalho repetidamente.  Poder√≠amos fazer isso uma vez, adicionar ao padr√£o - e economizar a todos um monte de recursos. <br><br><h3>  Onde estamos agora? </h3><br>  Em algum lugar aqui: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="imagem"><br><br>  Ainda n√£o existe um padr√£o de tempo de execu√ß√£o.  O que n√£o impede que existam e funcionem v√°rios tempos de execu√ß√£o independentes j√° usados ‚Äã‚Äãem projetos reais.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WAVM</a> e wasmjit. <br><br>  Tamb√©m planejamos lan√ßar um tempo de execu√ß√£o constru√≠do sobre o Cranelift, que ser√° chamado wasmtime.  E assim que temos algo padronizado e funcionando, essa √© uma oportunidade aberta para desenvolver uma s√©rie de coisas, como, por exemplo ... <br><br><h2>  Utilit√°rios de linha de comando port√°teis </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="imagem"><br><br>  O WebAssembly pode ser usado n√£o apenas no navegador, mas tamb√©m nos sistemas operacionais tradicionais.  N√£o falaremos sobre o kernel (embora haja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dem√¥nios</a> que est√£o acenando para isso tamb√©m), mas o c√≥digo do WebAssembly pode funcionar no modo de usu√°rio.  E isso possibilita a cria√ß√£o de utilit√°rios de linha de comando que, uma vez criados, funcionar√£o garantidamente iguais para qualquer sistema operacional. <br><br><h2>  Internet das coisas </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="imagem"><br><br>  Por "Internet das coisas", eles geralmente significam dispositivos de baixa pot√™ncia (como sensores ou controladores vest√≠veis ou v√°rios em "casas inteligentes").  As limita√ß√µes nos recursos dispon√≠veis do processador e na RAM afetam negativamente a capacidade de executar o c√≥digo JS l√°, mas o WebAssembly √© uma quest√£o completamente diferente.  A otimiza√ß√£o de compiladores como o Cranelift e um tempo de execu√ß√£o como o wasmtime brilhar√£o nessas condi√ß√µes, porque eles foram escritos apenas para tarefas de economia de recursos.  Em casos absolutamente extremos, o WebAssembly torna poss√≠vel compilar seu m√≥dulo no bin√°rio nativo da plataforma de destino.  Bem, novamente, portabilidade - hoje existem muitos de todos esses dispositivos de IoT e eles s√£o criados em plataformas diferentes.  Com o WebAssembly, voc√™ n√£o precisa se preocupar com isso - o c√≥digo desenvolvido ser√° executado em qualquer lugar. <br><br><h2>  Conclus√µes </h2><br>  Vamos voltar um pouco e dar uma olhada na nossa "√°rvore de habilidades" novamente. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="imagem"></a> <br><br>  Comecei este artigo com o fato de que algumas pessoas ainda n√£o entendem por que o WebAssembly ainda n√£o terminou.  Como voc√™ pode entender agora - o caminho dele mal come√ßou.  Sim, o MVP j√° est√° abrindo algumas possibilidades.  J√° podemos compilar algo no WebAssembly e execut√°-lo em um navegador.  Mas ainda h√° muito trabalho pela frente - suportando tudo o que voc√™ precisa para aplicativos pesados ‚Äã‚Äãe linguagens de alto n√≠vel, substituindo as estruturas JS e todas essas coisas "fora do navegador" sobre as quais eu falei.  Quando tudo estiver pronto, veremos uma nova web.  Alto desempenho, maior, mais port√°til.  N√£o haver√° mais esse tipo de software que n√£o pode ser gravado para execu√ß√£o no navegador: jogos, blockchain, Internet das coisas, utilit√°rios de linha de comando - tudo come√ßar√°. <br><br>  O WebAssembly n√£o est√° conclu√≠do.  Ele acabou de come√ßar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428347/">https://habr.com/ru/post/pt428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428337/index.html">JavaScript divertido: sem chaves</a></li>
<li><a href="../pt428339/index.html">N√£o automatize: m√°s dicas de neg√≥cios</a></li>
<li><a href="../pt428341/index.html">Tecnologia Qsan RAID EE</a></li>
<li><a href="../pt428343/index.html">Um quebra-cabe√ßa interessante em C</a></li>
<li><a href="../pt428345/index.html">Cobrindo requisitos com casos. Realidades do SuperJob</a></li>
<li><a href="../pt428349/index.html">Pepino na nuvem: usando scripts BDD para teste de estresse do produto</a></li>
<li><a href="../pt428353/index.html">Como criamos um sistema para rastreamentos m√≥veis no SIBUR</a></li>
<li><a href="../pt428355/index.html">Gamification Mechanics: Classifica√ß√£o</a></li>
<li><a href="../pt428357/index.html">Absor√ß√£o na pr√°tica: uma hist√≥ria de vida</a></li>
<li><a href="../pt428363/index.html">Construindo um jetpack / hoverboard: sistemas de resgate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>