<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎇 📸 ⚗️ Peta Unity Hexagon: Air, Tengara, dan Dinding Benteng ☮️ 👨‍🏭 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1-3: jala, warna, dan tinggi sel 

 Bagian 4-7: gundukan, sungai, dan jalan 

 Bagian 8-11: air, bentang alam, dan benteng 

 Bagian 12-15: men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peta Unity Hexagon: Air, Tengara, dan Dinding Benteng</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425463/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1-3: jala, warna, dan tinggi sel</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4-7: gundukan, sungai, dan jalan</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8-11: air, bentang alam, dan benteng</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12-15: menyimpan dan memuat, tekstur, jarak</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16-19: menemukan jalan, regu pemain, animasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20-23: Kabut Perang, Penelitian Peta, Generasi Prosedural</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24-27: siklus air, erosi, bioma, peta silindris</a> <br><br><h1>  Bagian 8: air </h1><br><ul><li>  Tambahkan air ke sel. </li><li>  Triangulasi permukaan air. </li><li>  Buat selancar dengan busa. </li><li>  Campurkan air dan sungai. </li></ul><br>  Kami telah menambahkan dukungan sungai, dan di bagian ini kami akan sepenuhnya merendam sel-sel di dalam air. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/73c/b6e/2a973cb6eb97eba7d04a325f3ac89a3e.jpg"></div><br>  <i>Air datang.</i> <br><a name="habracut"></a><br><h2>  Tingkat air </h2><br>  Cara termudah adalah menerapkan dukungan air dengan menetapkannya pada level yang sama.  Semua sel yang tingginya di bawah level ini direndam dalam air.  Tetapi cara yang lebih fleksibel adalah menjaga air pada ketinggian yang berbeda, jadi mari kita buat ketinggian air berubah.  Untuk ini, <code>HexCell</code> perlu memantau ketinggian airnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel;</code> </pre> <br>  Jika diinginkan, Anda dapat memastikan bahwa fitur bantuan tertentu tidak ada di bawah air.  Tetapi untuk saat ini saya tidak akan melakukan ini.  Hal-hal seperti jalan bawah air cocok untuk saya.  Mereka dapat dianggap sebagai daerah yang baru saja terkena banjir. <br><br><h3>  Sel yang membanjiri </h3><br>  Sekarang kita memiliki level air, pertanyaan yang paling penting adalah apakah sel-sel itu di bawah air.  Sebuah sel berada di bawah air jika permukaan airnya di atas ketinggiannya.  Untuk mendapatkan informasi ini, kami akan menambahkan properti. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsUnderwater { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel &gt; elevation; } }</code> </pre> <br>  Ini berarti bahwa ketika ketinggian dan ketinggian air sama, sel naik di atas air.  Artinya, permukaan air yang sebenarnya ada di bawah ketinggian ini.  Seperti halnya permukaan sungai, mari tambahkan offset yang sama - <code>HexMetrics.riverSurfaceElevationOffset</code> .  Ubah namanya menjadi yang lebih umum. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public const float riverSurfaceElevationOffset = -0.5f; public const float waterElevationOffset = -0.5f;</span></span></code> </pre> <br>  Ubah <code>HexCell.RiverSurfaceY</code> sehingga menggunakan nama baru.  Kemudian kami menambahkan properti serupa ke permukaan air sel yang banjir. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WaterSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (waterLevel + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3>  Pengeditan air </h3><br>  Mengedit ketinggian air sama dengan mengubah ketinggian.  Oleh karena itu, <code>HexMapEditor</code> harus memantau level air aktif dan apakah itu harus diterapkan ke sel. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeWaterLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyWaterLevel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Tambahkan metode untuk menghubungkan parameter ini dengan UI. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyWaterLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeWaterLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; }</code> </pre> <br>  Dan tambahkan level air ke <code>EditCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } … } }</code> </pre> <br>  Untuk menambahkan ketinggian air ke UI, duplikat label dan penggeser ketinggian, lalu ubah.  Ingatlah untuk melampirkan acara mereka ke metode yang tepat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42b/a13/de4/42ba13de4120b43e460628021c77d99f.png"></div><br>  <i>Slider level air.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket unity</a> <br><br><h2>  Triangulasi air </h2><br>  Untuk melakukan triangulasi air, kita membutuhkan jaring baru dengan material baru.  Pertama, buat shader <em>Air</em> , duplikat <em>River</em> shader.  Ubah sehingga menggunakan properti warna. <br><br><pre> <code class="hljs pgsql">Shader "Custom/Water" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Transparent" "Queue"="Transparent" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard alpha #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br>  Buat material baru dengan shader ini, duplikat material <em>Water</em> dan gantikan dengan shader.  Biarkan tekstur suara, karena kita akan menggunakannya nanti. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd9/238/283/fd9238283d92bacd26a3ff5dce73b17b.png"></div><br>  <i>Bahan air.</i> <br><br>  Tambahkan anak baru ke prefab dengan menduplikasi anak <em>Rivers</em> .  Dia tidak membutuhkan koordinat UV, dan dia harus menggunakan <em>Air</em> .  Seperti biasa, kami akan melakukan ini dengan membuat turunan cetakan, mengubahnya, dan kemudian menerapkan perubahan ke cetakan.  Setelah itu, singkirkan instance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/6e6/82f/6ec6e682f16c604d75c0e5b835d5b03e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3f3/eeb/7c53f3eeb282e533f9f0b8a20e813091.png"></div><br>  <i>Air Benda Anak.</i> <br><br>  Selanjutnya, tambahkan dukungan water mesh ke <code>HexGridChunk</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); }</code> </pre> <br>  Dan hubungkan ke anak cetakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/19a/76a/b4d19a76a745d550314b277fd2c0e13c.png"></div><br>  <i>Objek Air terhubung.</i> <br><br><h3>  Segi enam air </h3><br>  Karena air membentuk lapisan kedua, mari berikan metode triangulasi kita sendiri untuk setiap arah.  Kita perlu menyebutnya hanya ketika sel direndam dalam air. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { TriangulateWater(direction, cell, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Seperti halnya sungai, ketinggian permukaan air tidak banyak berbeda dalam sel dengan tingkat air yang sama.  Karena itu, kita sepertinya tidak memerlukan tulang rusuk yang rumit.  Segitiga sederhana sudah cukup. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/72b/99b/a5172b99ba382c6e79abff653e4b7fb2.png"></div><br>  <i>Segi enam air.</i> <br><br><h3>  Senyawa air </h3><br>  Kita dapat menghubungkan sel tetangga dengan air dengan satu quadrangle. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 e1 = c1 + bridge; Vector3 e2 = c2 + bridge; water.AddQuad(c1, c2, e1, e2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3af/949/0a63af9496da925e966b008f41f808a8.png"></div><br>  <i>Koneksi ujung-ujung air.</i> <br><br>  Dan isi sudutnya dengan satu segitiga. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { … water.AddQuad(c1, c2, e1, e2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !nextNeighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } water.AddTriangle( c2, e2, c2 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/37e/5b4/c3237e5b4e492f9a1c334f90aaa88ee4.png"></div><br>  <i>Sambungan sudut air.</i> <br><br>  Sekarang kita memiliki sel air yang terhubung ketika mereka berada di dekatnya.  Mereka meninggalkan celah di antara mereka dan sel-sel kering dengan ketinggian yang lebih tinggi, tetapi kita akan meninggalkan ini untuk nanti. <br><br><h3>  Tingkat Air yang Diharmonisasikan </h3><br>  Kami berhipotesis bahwa sel bawah laut yang berdekatan memiliki level air yang sama.  Jika demikian, maka semuanya terlihat baik, tetapi jika asumsi ini dilanggar, kesalahan terjadi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a8b/b4f/fcfa8bb4fb960ddc788d358e60f9023f.png"></div><br>  <i>Level air yang tidak konsisten.</i> <br><br>  Kita bisa membuat air tetap di level yang sama.  Misalnya, ketika level air sel yang banjir berubah, kita dapat menyebarkan perubahan ke sel tetangga untuk menjaga agar levelnya tersinkronisasi.  Namun, proses ini harus berlanjut sampai bertemu sel-sel yang tidak direndam dalam air.  Sel-sel ini menentukan batas-batas massa air. <br><br>  Bahaya dari pendekatan ini adalah bahwa ia dapat dengan cepat lepas kendali.  Jika pengeditan tidak berhasil, air dapat menutupi seluruh peta.  Kemudian semua fragmen harus di-triangulasi secara bersamaan, yang akan menyebabkan lompatan besar dalam penundaan. <br><br>  Jadi jangan lakukan itu dulu.  Fitur ini dapat ditambahkan dalam editor yang lebih kompleks.  Sementara konsistensi level air, kami meninggalkan hati nurani pengguna. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Animasi air </h2><br>  Alih-alih warna seragam, kami akan menciptakan sesuatu yang menyerupai gelombang.  Seperti pada shader lainnya, untuk saat ini kami tidak akan mengusahakan grafik yang indah, kami hanya perlu menunjuk ombak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a2f/1f9/ca1a2f1f978cd2f2993a96b44440227b.png"></div><br>  <i>Airnya rata sempurna.</i> <br><br>  Mari kita lakukan apa yang kita lakukan dengan sungai.  Kami mencicipi kebisingan dengan posisi dunia dan menambahkannya ke warna yang seragam.  Untuk menghidupkan permukaan, tambahkan waktu ke koordinat V. <br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise.z; fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Air gulir, waktu × 10.</i> <br><br><h3>  Dua arah </h3><br>  Sejauh ini sama sekali tidak seperti gelombang.  Mari memperumit gambar dengan menambahkan sampel derau kedua <br>  dan kali ini menambahkan koordinat U. Kami menggunakan saluran noise yang berbeda untuk mendapatkan dua pola yang berbeda sebagai hasilnya.  Gelombang jadi akan menjadi dua sampel ini ditumpuk bersama. <br><br><pre> <code class="hljs pgsql"> float2 uv1 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(_MainTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x;</code> </pre> <br>  Saat menjumlahkan kedua sampel, kami mendapatkan hasil dalam interval 0–2, jadi kami perlu memperkecilnya menjadi 0–1.  Alih-alih hanya membagi gelombang menjadi dua, kita dapat menggunakan fungsi <code>smoothstep</code> untuk menciptakan hasil yang lebih menarik.  Kami menempatkan ¾ - 2 pada 0-1 sehingga tidak ada gelombang yang terlihat di permukaan air. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waves = noise1.z + noise2.x; waves = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Dua arah, waktu × 10.</i> <br><br><h3>  Gelombang pencampuran </h3><br>  Masih terlihat bahwa kita memiliki dua pola kebisingan bergerak yang tidak benar-benar berubah.  Akan lebih masuk akal jika polanya berubah.  Kita dapat menyadari hal ini dengan menginterpolasi berbagai saluran sampel kebisingan.  Tapi ini tidak bisa dilakukan dengan cara yang sama, jika tidak seluruh permukaan air akan berubah secara bersamaan, dan ini sangat terlihat.  Sebagai gantinya, kami akan membuat gelombang kebingungan. <br><br>  Kami akan membuat gelombang pencampuran dengan bantuan sinusoid, yang bergerak secara diagonal di sepanjang permukaan air.  Kami akan melakukan ini dengan menambahkan koordinat dunia X dan Z dan menggunakan jumlah sebagai input ke fungsi <code>sin</code> .  Perkecil untuk mendapatkan band yang cukup besar.  Dan tentu saja, mari kita tambahkan nilai yang sama untuk menghidupkannya. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y);</code> </pre> <br>  Gelombang sinus berkisar antara -1 dan 1, dan kita membutuhkan interval 0-1.  Anda bisa mendapatkannya dengan mengkuadratkan gelombang.  Untuk melihat hasil yang terisolasi, gunakan itu bukan warna yang berubah sebagai nilai output. <br><br><pre> <code class="hljs pgsql"> sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x; waves = smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); fixed4 c = blendWave; //saturate(_Color + waves);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d9/d70/aa33d9d70a022df57a0348423181b258.png"></div><br>  <i>Gelombang pencampuran.</i> <br><br>  Untuk membuat gelombang pencampuran kurang terlihat, tambahkan beberapa noise dari kedua sampel. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/c8f/697/618c8f697cd2e463d7349030277d1a82.png"></div><br>  <i>Gelombang pencampuran yang terdistorsi.</i> <br><br>  Akhirnya, kami menggunakan gelombang pencampuran untuk menginterpolasi antara dua saluran dari kedua sampel kebisingan.  Untuk variasi maksimum, ambil empat saluran berbeda. <br><br><pre> <code class="hljs lisp"> float waves = lerp(<span class="hljs-name"><span class="hljs-name">noise1</span></span>.z, noise1.w, blendWave) + lerp(<span class="hljs-name"><span class="hljs-name">noise2</span></span>.x, noise2.y, blendWave)<span class="hljs-comment"><span class="hljs-comment">; waves = smoothstep(0.75, 2, waves); fixed4 c = saturate(_Color + waves);</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Gelombang pencampuran, waktu × 2.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Pantai </h2><br>  Kita sudah selesai dengan air terbuka, tapi sekarang kita perlu mengisi celah di air di sepanjang pantai.  Karena kita harus menyesuaikan dengan kontur tanah, air pantai memerlukan pendekatan yang berbeda.  Mari kita bagikan <code>TriangulateWater</code> menjadi dua metode - satu untuk perairan terbuka dan satu untuk pantai.  Untuk memahami ketika kita bekerja dengan pantai, kita perlu melihat sel tetangga.  Artinya, di <code>TriangulateWater</code> kita akan mendapatkan tetangga.  Jika ada tetangga dan dia tidak di bawah air, maka kita berurusan dengan pantai. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !neighbor.IsUnderwater) { TriangulateWaterShore(direction, cell, neighbor, center); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateOpenWater(direction, cell, neighbor, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// HexCell neighbor = cell.GetNeighbor(direction); // if (neighbor == null || !neighbor.IsUnderwater) { // return; // } Vector3 bridge = HexMetrics.GetBridge(direction); … } } void TriangulateWaterShore ( HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center ) { }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f04/799/441/f0479944178dcb5646bbf935700a798e.png"></div><br>  <i>Tidak ada triangulasi di sepanjang pantai.</i> <br><br>  Karena pantai terdistorsi, kita harus mengubah segitiga air di sepanjang pantai.  Oleh karena itu, kita memerlukan bagian atas tepi dan kipas segitiga. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/761/283/bbd76128386859bb388e6e2d3f105ff0.png"></div><br>  <i>Penggemar segitiga di sepanjang pantai.</i> <br><br>  Berikutnya adalah potongan tulang rusuk, seperti pada relief normal.  Namun, kami tidak diwajibkan untuk membatasi diri hanya untuk area tertentu, karena kami hanya memanggil <code>TriangulateWaterShore</code> ketika kami bertemu pantai, yang membutuhkan strip. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, e1.v4, e1.v5); Vector3 bridge = HexMetrics.GetBridge(direction); EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7da/fbc/aa9/7dafbcaa95a4b48509ab68fbf111c703.png"></div><br>  <i>Garis-garis tulang rusuk di sepanjang pantai.</i> <br><br>  Demikian pula, kita juga harus menambahkan segitiga sudut setiap kali. <br><br><pre> <code class="cs hljs"> water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { water.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/18f/8b1/06418f8b10cc0fc0a4e2276b86375385.png"></div><br>  <i>Sudut iga di sepanjang pantai.</i> <br><br>  Sekarang kami memiliki air siap untuk pantai.  Sebagian darinya selalu berada di bawah lubang bantuan, sehingga tidak ada lubang. <br><br><h3>  Pantai UV </h3><br>  Kita bisa meninggalkan semuanya apa adanya, tetapi akan menarik jika air pantai punya jadwal sendiri.  Misalnya, efek busa, yang menjadi lebih besar saat mendekati pantai.  Untuk mengimplementasikannya, shader harus tahu seberapa dekat fragmen dengan pantai.  Kami dapat mengirimkan informasi ini melalui koordinat UV. <br><br>  Air terbuka tidak memiliki koordinat UV, dan tidak perlu busa.  Itu hanya dibutuhkan untuk air di dekat pantai.  Oleh karena itu, persyaratan untuk kedua jenis air ini sangat berbeda.  Adalah logis untuk membuat mesh Anda sendiri untuk setiap jenis.  Oleh karena itu, kami menambahkan dukungan untuk objek mesh lain ke HexGridChunk. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); }</code> </pre> <br>  Mesh baru ini akan menggunakan <code>TriangulateWaterShore</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br>  Gandakan objek air, hubungkan ke cetakan dan mengaturnya sehingga menggunakan koordinat UV.  Kami juga membuat shader dan material untuk air pantai, menduplikasi shader dan material air yang ada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/561/77e/e73/56177ee7331ce092a859a058645f0364.png"></div><br>  <i>Fasilitas tepi air dan bahan UV.</i> <br><br>  Ubah shader <em>Water Shore</em> sehingga alih-alih air akan menampilkan koordinat UV. <br><br><pre> <code class="hljs lisp"> fixed4 c = fixed4(<span class="hljs-name"><span class="hljs-name">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Karena belum ada koordinat yang ditetapkan, itu akan menampilkan warna solid.  Berkat ini, mudah untuk melihat bahwa pantai benar-benar menggunakan jala terpisah dengan material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/45c/ec0/63045cec0f1f367bfee191f69cfa11ad.png"></div><br>  <i>Pisahkan jaring untuk pantai.</i> <br><br>  Mari kita letakkan informasi pantai dalam koordinat V. Di sisi air, berikan nilai 0, di sisi darat - nilai 1. Karena kita tidak perlu mengirimkan apa pun, semua koordinat U hanya akan menjadi 0. <br><br><pre> <code class="cs hljs"> waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/3fa/f86/8f43faf864c259e21c2ce731d08f43f6.png"></div><br>  <i>Transisi ke pantai salah.</i> <br><br>  Kode di atas berfungsi untuk edge, tetapi salah di beberapa sudut.  Jika tetangga berikutnya ada di bawah air, maka pendekatan ini akan benar.  Tetapi ketika tetangga berikutnya tidak di bawah air, puncak ketiga segitiga itu akan berada di bawah tanah. <br><br><pre> <code class="cs hljs"> waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, nextNeighbor.IsUnderwater ? <span class="hljs-number"><span class="hljs-number">0f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/9e9/6e6/c2e9e96e63c161d0f71f81e31742af89.png"></div><br>  <i>Transisi ke pantai sudah benar.</i> <br><br><h3>  Busa di pantai </h3><br>  Sekarang transisi ke pantai diimplementasikan dengan benar, Anda dapat menggunakannya untuk membuat efek busa.  Cara termudah adalah menambahkan nilai pantai ke warna yang seragam. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = shore; fixed4 c = saturate(_Color + foam); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/502/a56/ef5502a56ab665732312be25a6961817.png"></div><br>  <i>Busa linier.</i> <br><br>  Untuk membuat busa lebih menarik, kalikan dengan persegi sinusoid. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin(shore * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/acf/6d8/c2eacf6d83e9f7c1298cdd7a05e551d0.png"></div><br>  <i>Busa Sinusoid Persegi Memudar.</i> <br><br>  Mari kita buat busa depan lebih besar saat mendekati pantai.  Ini dapat dilakukan dengan mengambil akar kuadratnya sebelum menggunakan nilai pantai. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/675/e98/762675e987d119034cd5b643c86ca672.png"></div><br>  <i>Busa menjadi lebih tebal di dekat pantai.</i> <br><br>  Tambahkan distorsi agar terlihat lebih alami.  Mari kita buat distorsi lebih lemah saat mendekati pantai.  Jadi akan lebih baik untuk melapisi pantai. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31a/7fd/59a/31a7fd59ad215b200571133543f1406b.png"></div><br>  <i>Busa dengan distorsi.</i> <br><br>  Dan, tentu saja, kita menjiwai semua ini: baik sinusoid dan distorsi. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam *= foam * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Busa Animasi.</i> <br><br>  Selain busa yang masuk, ada juga yang mundur.  Mari kita tambahkan sinusoid kedua, yang bergerak ke arah yang berlawanan, untuk mensimulasikannya.  Buat itu lebih lemah dan tambahkan shift waktu.  Busa jadi akan menjadi maksimum dari dua sinusoid ini. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion1 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam1 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion2 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam2 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(foam1, foam2) * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Busa masuk dan surut.</i> <br><br><h3>  Perpaduan ombak dan busa </h3><br>  Ada transisi yang tajam antara air terbuka dan air pantai karena gelombang air terbuka tidak termasuk dalam air pantai.  Untuk memperbaikinya, kita harus memasukkan gelombang ini ke dalam shader <em>Water Shore</em> . <br><br>  Alih-alih menyalin kode wave, mari kita tempelkan ke file yang menyertakan <em>Water.cginc</em> .  Bahkan, kami memasukkan kode ke dalamnya untuk kedua busa dan gelombang, masing-masing sebagai fungsi terpisah. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara shader menyertakan file berfungsi?</b> <div class="spoiler_text">  Membuat file shader include Anda sendiri tercakup dalam tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering 5, Multiple Lights</a> . </div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> Foam (<span class="hljs-type"><span class="hljs-type">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { // <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore); float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion1 = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam1 = sin((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-type"><span class="hljs-type">float</span></span> distortion2 = noise.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam2 = sin((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(foam1, foam2) * shore; } <span class="hljs-type"><span class="hljs-type">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(noiseTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = worldXZ; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (worldXZ.x + worldXZ.y) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = lerp(noise1.z, noise1.w, blendWave) + lerp(noise2.x, noise2.y, blendWave); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); }</code> </pre> <br>  Ubah <em>Water</em> shader sehingga ia menggunakan file include yang baru. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  Di <em>Water Shore</em> shader, nilai dihitung untuk busa dan gelombang.  Lalu kami meredam ombak saat mendekati pantai.  Hasil akhir akan maksimal dari busa dan gelombang. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Campuran busa dan gelombang.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Lagi tentang air pantai </h2><br>  Bagian dari jaring pantai disembunyikan di bawah jaring bantuan.  Ini normal, tetapi hanya sebagian kecil yang disembunyikan.  Sayangnya, tebing curam menyembunyikan sebagian besar air pantai, dan karenanya berbusa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/adf/7e3/deaadf7e3290f93b28ed6177c713bbaa.png"></div><br>  <i>Air pantai nyaris tersembunyi.</i> <br><br>  Kita dapat menangani ini dengan meningkatkan ukuran strip pantai.  Ini bisa dilakukan dengan mengurangi jari-jari heksagon air.  Untuk ini, selain koefisien integritas, kita memerlukan koefisien air <code>HexMetrics</code> , serta metode untuk mendapatkan sudut air. <br><br>  Koefisien integritas adalah 0,8.  Untuk menggandakan ukuran senyawa air, kita perlu mengatur koefisien air menjadi 0,6. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterFactor = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * waterFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * waterFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan metode baru ini </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menemukan sudut air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstWaterCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondWaterCorner(direction); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstWaterCorner(direction), center + HexMetrics.GetSecondWaterCorner(direction) ); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/b85/fcf/123b85fcffde7ae313f177f76f882ef5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan sudut air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak antara segi enam air sebenarnya berlipat ganda. </font><font style="vertical-align: inherit;">Sekarang </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu juga harus memiliki metode membuat jembatan di dalam air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterBlendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - waterFactor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWaterBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * waterBlendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga dia menggunakan metode baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 bridge = HexMetrics.GetWaterBridge(direction); … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetWaterBridge(direction); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetWaterBridge(direction.Next()) ); … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/756/1fa/99b7561fad8556733ea1f10b2dcdd233.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan panjang di air.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antara tulang rusuk air dan daratan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun ini memberi kita lebih banyak ruang untuk busa, sekarang lebih banyak lagi yang tersembunyi di bawah bantuan. </font><font style="vertical-align: inherit;">Idealnya, kita akan dapat menggunakan iga air di sisi air, dan iga darat di sisi darat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak dapat menggunakan jembatan sederhana untuk menemukan tepi tanah yang berlawanan, jika kita mulai dari sudut-sudut air. </font><font style="vertical-align: inherit;">Sebaliknya, kita bisa pergi ke arah yang berlawanan, dari pusat tetangga. </font><font style="vertical-align: inherit;">Ubah </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menggunakan pendekatan baru ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Vector3 bridge = HexMetrics.GetWaterBridge(direction); Vector3 center2 = neighbor.Position; center2.y = center.y; EdgeVertices e2 = new EdgeVertices( center2 + HexMetrics.GetSecondSolidCorner(direction.Opposite()), center2 + HexMetrics.GetFirstSolidCorner(direction.Opposite()) ); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); if (nextNeighbor != null) { Vector3 center3 = nextNeighbor.Position; center3.y = center.y; waterShore.AddTriangle( e1.v5, e2.v5, center3 + HexMetrics.GetFirstSolidCorner(direction.Previous()) ); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/3f2/01f/b293f201f065b7921f1098484e3b725d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudut tepi salah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berhasil, hanya sekarang kita kembali perlu mempertimbangkan dua kasus untuk segitiga sudut.</font></font><br><br><pre> <code class="cs hljs"> HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 center3 = nextNeighbor.Position; // center3.y = center.y; Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); v3.y = center.y; waterShore.AddTriangle(e1.v5, e2.v5, v3); waterShore.AddTriangleUV( new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f) ); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/f64/db1/4e1f64db1a34a8e6cff0f402f5fc6bd8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudut tepi yang benar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini bekerja dengan baik, tetapi sekarang karena sebagian besar busa terlihat, itu menjadi sangat jelas. </font><font style="vertical-align: inherit;">Untuk mengimbangi ini, kami akan membuat efek sedikit lebih lemah dengan mengurangi skala nilai pantai di shader.</font></font><br><br><pre> <code class="hljs lisp"> shore = sqrt(<span class="hljs-name"><span class="hljs-name">shore</span></span>) * <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Busa siap. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai bawah laut </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berakhir dengan air, setidaknya di tempat-tempat di mana tidak ada sungai yang mengalir ke sana. </font><font style="vertical-align: inherit;">Karena air dan sungai belum saling memperhatikan, sungai akan mengalir melalui dan di bawah air.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/1ee/bc5/0511eebc5420c9203475b65ce5c478b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai mengalir di dalam air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan di mana objek-objek tembus pandang diberikan tergantung pada jaraknya dari kamera. </font><font style="vertical-align: inherit;">Objek terdekat diberikan terakhir, sehingga mereka berada di atas. </font><font style="vertical-align: inherit;">Saat menggerakkan kamera, ini berarti kadang-kadang sungai dan air terkadang muncul saling berhadapan. </font><font style="vertical-align: inherit;">Mari kita mulai dengan membuat urutan rendering konstan. </font><font style="vertical-align: inherit;">Sungai harus ditarik di atas air sehingga air terjun ditampilkan dengan benar. </font><font style="vertical-align: inherit;">Kita bisa menerapkan ini dengan mengubah antrian shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+1"</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/74e/d91/4bc74ed9179598f5b9e82c3ff0cde851.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggambar sungai terakhir.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyembunyikan sungai bawah laut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun dasar sungai mungkin berada di bawah air, dan air sebenarnya dapat mengalir melaluinya, kita seharusnya tidak melihat air ini. </font><font style="vertical-align: inherit;">Dan terlebih lagi, itu tidak harus diberikan di atas permukaan air nyata. </font><font style="vertical-align: inherit;">Kita dapat membuang air sungai bawah laut dengan menambahkan segmen sungai hanya ketika sel saat ini tidak di bawah air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai dengan, kami akan menambahkan segmen sungai ketika baik arus maupun sel tetangga tidak terendam air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/0c7/cf6/8990c7cf6af7bf25596b4ffc05204817.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada lagi sungai bawah laut.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Air terjun </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada lagi sungai bawah laut, tetapi sekarang kami memiliki lubang di tempat-tempat sungai di mana mereka bertemu dengan permukaan air. Sungai pada tingkat yang sama dengan air menciptakan lubang kecil atau overlay. Tetapi yang paling mencolok adalah air terjun yang hilang untuk sungai yang mengalir dari ketinggian yang lebih tinggi. Mari kita urus mereka terlebih dahulu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmen sungai dengan air terjun yang digunakan untuk melewati permukaan air. Akibatnya, ia mendapati dirinya sebagian di atas, dan sebagian lagi di bawah air. Kita harus menjaga bagian di atas permukaan air, membuang yang lainnya. Anda harus bekerja keras untuk ini, jadi buat metode terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode baru ini membutuhkan empat puncak, dua ketinggian sungai, dan ketinggian air. Kami akan mengaturnya sehingga kami melihat ke arah arus, ke bawah air terjun. Oleh karena itu, dua puncak pertama dan sisi kiri dan kanan akan berada di atas, dan yang lebih rendah akan mengikuti.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memanggil metode ini </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika tetangga di bawah air dan kami membuat air terjun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita juga perlu memproses air terjun ke arah yang berlawanan, ketika sel saat ini di bawah air, dan yang berikutnya tidak. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekali lagi kita mendapatkan kuadrat dari sungai asli. </font><font style="vertical-align: inherit;">Selanjutnya kita perlu mengubah </font></font><code>TriangulateWaterfallInWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menaikkan puncak yang lebih rendah ke permukaan air. </font><font style="vertical-align: inherit;">Sayangnya, mengubah hanya koordinat Y tidak akan cukup. </font><font style="vertical-align: inherit;">Ini bisa mendorong air terjun dari tebing, yang bisa membentuk lubang. </font><font style="vertical-align: inherit;">Sebagai gantinya, Anda harus memindahkan simpul bawah ke atas menggunakan interpolasi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/11b/250/94211b250d95b614a5d6be6ff52c9e9e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolasi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memindahkan puncak yang lebih rendah ke atas, bagilah jarak mereka di bawah permukaan air dengan ketinggian air terjun. </font><font style="vertical-align: inherit;">Ini akan memberi kita nilai interpolator.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alhasil, kita mendapatkan air terjun pendek yang memiliki orientasi yang sama. </font><font style="vertical-align: inherit;">Namun, karena posisi simpul bawah telah berubah, mereka tidak akan terdistorsi seperti simpul asli. </font><font style="vertical-align: inherit;">Ini berarti bahwa hasil akhir masih tidak akan bertepatan dengan air terjun asli. </font><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, kita perlu secara manual mendistorsi simpul sebelum interpolasi, dan kemudian menambahkan quad tidak terdistorsi.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; v1 = HexMetrics.Perturb(v1); v2 = HexMetrics.Perturb(v2); v3 = HexMetrics.Perturb(v3); v4 = HexMetrics.Perturb(v4); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuadUnperturbed(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita sudah memiliki metode untuk menambahkan segitiga tidak terdistorsi, kita benar-benar tidak perlu membuat satu untuk paha depan. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan metode yang diperlukan </font></font><code>HexMesh.AddQuadUnperturbed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/605/bdd/dc4605bdd24ed9460b0ca3a310a11fb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air terjun berakhir di permukaan air. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muara </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sungai mengalir pada ketinggian yang sama dengan permukaan air, jaring sungai menyentuh jaring pantai. Jika itu adalah sungai yang mengalir ke laut atau ke laut, maka akan ada aliran sungai yang bertemu dengan ombak. Oleh karena itu, kami akan memanggil muara daerah tersebut.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/27b/efa/ddd27befa12ec543e2969505365b0d91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai memenuhi pantai tanpa merusak puncak.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kami memiliki dua masalah dengan mulut. Pertama, sungai quad menghubungkan puncak kedua dan keempat dari tulang rusuk, melewatkan yang ketiga. Karena pantai air tidak menggunakan puncak ketiga, itu dapat membuat lubang atau tumpang tindih. Kita bisa menyelesaikan masalah ini dengan mengubah geometri mulut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah kedua adalah bahwa ada transisi yang tajam antara busa dan material sungai. Untuk mengatasinya, kita membutuhkan bahan lain yang melakukan pencampuran efek sungai dan air. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berarti bahwa mulut memerlukan pendekatan khusus, jadi mari kita buat metode terpisah untuk mereka. Itu harus dipanggil </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika ada sungai bergerak ke arah saat ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daerah tidak perlu mencampur kedua efek untuk mengisi seluruh strip. </font><font style="vertical-align: inherit;">Bentuk trapesium akan cukup bagi kita. </font><font style="vertical-align: inherit;">Karena itu, kita bisa menggunakan dua segitiga pantai di sisinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ece/ca1/fc9/ececa1fc9852f7350a54e00fa71df0b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lubang trapesium untuk area pencampuran.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinat UV2 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat efek sungai, kita membutuhkan koordinat UV. </font><font style="vertical-align: inherit;">Tetapi untuk menciptakan efek busa, Anda juga membutuhkan koordinat UV. </font><font style="vertical-align: inherit;">Artinya, saat mencampurnya, kita membutuhkan dua set koordinat UV. </font><font style="vertical-align: inherit;">Untungnya, jerat engine Unity dapat mendukung hingga empat set UV. </font><font style="vertical-align: inherit;">Kami hanya perlu menambahkan untuk </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendukung set kedua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menambahkan set kedua UV, kami menduplikasi metode bekerja dengan UV dan mengubah cara yang kita butuhkan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); uv2s.Add(uv4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi River Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita akan menggunakan efek sungai dalam dua shader, kita akan memindahkan kode dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">ke fungsi file </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> include yang baru </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> River (float2 riverUV, sampler2D noiseTex) { float2 uv = riverUV; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, uv); float2 uv2 = riverUV; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noise.x * noise2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menggunakan fitur baru ini.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benda mulut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulut </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">mendukung objek jala.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore, estuaries; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat shader, material dan objek mulut, menduplikasi pantai dan mengubahnya. </font><font style="vertical-align: inherit;">Hubungkan ke fragmen, dan gunakan koordinat UV dan UV2.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/77a/7fc/54077a7fc8653228cd723ca855330fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obyek Estuarties.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulasi mulut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat memecahkan masalah lubang atau tumpang tindih dengan menempatkan segitiga antara ujung sungai dan tengah tepi air. </font><font style="vertical-align: inherit;">Karena shader mulut kami adalah duplikat dari shader pantai, kami mengatur koordinat UV agar sesuai dengan efek busa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { … estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/bb6/f76/f02bb6f768f915d39c05296055cc0b83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segitiga tengah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengisi seluruh trapesium dengan menambahkan quad di kedua sisi segitiga tengah.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/672/e7e/ef2672e7e62b9d66463e4fc44dc43b7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapesium siap. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita putar orientasi quad ke kiri sehingga memiliki koneksi diagonal pendek, dan sebagai hasilnya kita mendapatkan geometri simetris.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/dd0/7d1/cd5dd07d1b9f1fb8126e6a5a7c1bc29b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotated quad, geometri simetris</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aliran sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung efek sungai, kita perlu menambahkan koordinat UV2. </font><font style="vertical-align: inherit;">Bagian bawah segitiga tengah berada di tengah sungai, jadi koordinatnya U harus sama dengan 0,5. </font><font style="vertical-align: inherit;">Karena sungai mengalir ke arah air, titik kiri menerima koordinat U sama dengan 1, dan yang kanan menerima koordinat U dengan nilai 0. Kami mengatur koordinat Y ke 0 dan 1, sesuai dengan arah arus.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segi empat di kedua sisi segitiga harus bertepatan dengan orientasi ini. </font><font style="vertical-align: inherit;">Kami menjaga koordinat U yang sama untuk titik yang melebihi lebar sungai.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/475/d50/a98475d50fe84d16eeeff5397f6aa43f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2 trapesium. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa kami mengatur koordinat UV2 dengan benar, buat </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">merendernya. </font><font style="vertical-align: inherit;">Kami dapat mengakses koordinat ini dengan menambahkan ke struktur input </font></font><code>float2 uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 uv2_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/416/d95/efd416d95c7827f264f2f0e8360e6fde.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinat UV2. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya terlihat bagus, Anda dapat menggunakan shader untuk membuat efek sungai.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/2c9/fda/0e32c9fda58b356534c2070d0b74adae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan UV2 untuk membuat efek sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menciptakan sungai sedemikian rupa sehingga ketika melakukan triangulasi koneksi antar sel, koordinat sungai V berubah dari 0,8 menjadi 1. Oleh karena itu, di sini kita juga harus menggunakan interval ini, dan bukan dari 0 hingga 1. Namun, koneksi pantai 50% lebih dari koneksi sel biasa . </font><font style="vertical-align: inherit;">Oleh karena itu, untuk yang paling cocok dengan aliran sungai, kita harus mengubah nilai dari 0,8 menjadi 1,1.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/beb/7c6/27dbeb7c67553163422fd560e64ddb03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/4d9/2e3/b0c4d92e3797274e2534a6921334d184.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliran sungai dan muara yang tersinkronisasi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengaturan aliran </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara sungai bergerak dalam garis lurus. </font><font style="vertical-align: inherit;">Tetapi ketika air mengalir ke area yang lebih luas, itu mengembang. </font><font style="vertical-align: inherit;">Arus akan melengkung. </font><font style="vertical-align: inherit;">Kita dapat mensimulasikan ini dengan melipat koordinat UV2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menjaga koordinat U atas konstan di luar lebar sungai, pindahkan mereka dengan 0,5. </font><font style="vertical-align: inherit;">Titik paling kiri adalah 1.5, paling kanan adalah .50.5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada saat yang sama, kami memperluas aliran dengan menggerakkan koordinat U dari titik bawah kiri dan kanan. </font><font style="vertical-align: inherit;">Ubah yang kiri dari 1 menjadi 0,7, dan yang kanan dari 0 menjadi 0,3.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); … estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/99d/976/85099d97610434a630621e9e06f885ad.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/567/f72/0c1567f72c979734719b298c7850b59e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perluasan sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyelesaikan efek lengkungan, ubah koordinat V dari empat titik yang sama. </font><font style="vertical-align: inherit;">Karena air mengalir dari ujung sungai, kita akan meningkatkan koordinat V dari titik atas ke 1. Dan untuk membuat kurva yang lebih baik, kita akan meningkatkan koordinat V dari dua titik bawah menjadi 1.15.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/86d/320/1fa86d32037da7fab579ce9a195d1e71.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/edb/dfe/b07edbdfeb3615b1a597712a6bda5c8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur sungai yang melengkung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campur Sungai dan Pantai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang tersisa bagi kita adalah mencampur efek dari pantai dan sungai. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami menggunakan interpolasi linier, dengan mengambil nilai pantai sebagai interpolator.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shoreWater = max(foam, waves); <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> water = lerp(shoreWater, river, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x); fixed4 c = saturate(_Color + water);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun ini berhasil, Anda mungkin mendapatkan kesalahan kompilasi. </font><font style="vertical-align: inherit;">Kompiler mengeluh tentang definisi ulang </font></font><code>_MainTex_ST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alasannya adalah kesalahan di dalam kompiler shader permukaan Unity yang disebabkan oleh penggunaan simultan dari </font></font><code>uv_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kita perlu mencari solusinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menggunakannya </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita harus mentransfer koordinat UV sekunder secara manual. </font><font style="vertical-align: inherit;">Untuk melakukan ini, ganti nama </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi </font></font><code>riverUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian tambahkan fungsi titik ke shader, yang menetapkan koordinat untuk itu.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.riverUV, _MainTex); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/904/b40/c98/904b40c98323b2e9f32bd16513344181.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolasi berdasarkan nilai pantai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolasi bekerja, dengan pengecualian dari simpul kiri dan kanan di atas. </font><font style="vertical-align: inherit;">Pada titik-titik ini sungai harus menghilang. </font><font style="vertical-align: inherit;">Karena itu, kami tidak dapat menggunakan nilai pantai. </font><font style="vertical-align: inherit;">Kita harus menggunakan nilai yang berbeda, yang pada kedua simpul ini adalah 0. Untungnya, kita masih memiliki koordinat U dari set UV pertama, sehingga kita dapat menyimpan nilai ini di sana.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/e93/432/b34e93432248fb7be818b53aca4d8b20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campuran yang tepat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mulut memiliki campuran yang baik antara sungai yang berkembang, air pantai dan busa. </font><font style="vertical-align: inherit;">Meskipun ini tidak cocok dengan air terjun, efek ini juga terlihat bagus dengan air terjun.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Muara </font></a><i><font style="vertical-align: inherit;">aksi </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai mengalir dari badan air </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sudah memiliki sungai yang mengalir ke badan air, tetapi tidak ada dukungan untuk sungai yang mengalir ke arah yang berbeda. </font><font style="vertical-align: inherit;">Ada danau dari mana sungai mengalir, jadi kita perlu menambahkannya juga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sebuah sungai mengalir keluar dari badan air, sebenarnya mengalir menuju ketinggian yang lebih tinggi. </font><font style="vertical-align: inherit;">Ini saat ini tidak memungkinkan. </font><font style="vertical-align: inherit;">Kita perlu membuat pengecualian dan membiarkan situasi ini jika ketinggian air sesuai dengan ketinggian titik target. </font><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode pribadi yang memeriksa sesuai dengan kriteria baru kami apakah tetangga adalah titik target yang tepat untuk sungai keluar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRiverDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor &amp;&amp; ( elevation &gt;= neighbor.elevation || waterLevel == neighbor.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami akan menggunakan metode baru kami untuk menentukan apakah mungkin untuk membuat sungai keluar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || elevation &lt; neighbor.elevation) { if (!IsValidRiverDestination(neighbor)) { return; } RemoveOutgoingRiver(); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, di sana Anda perlu memeriksa sungai ketika mengubah ketinggian sel atau ketinggian air. </font><font style="vertical-align: inherit;">Mari kita buat metode pribadi yang akan melakukan tugas ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; !IsValidRiverDestination(GetNeighbor(outgoingRiver)) ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; !GetNeighbor(incomingRiver).IsValidRiverDestination(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) { RemoveIncomingRiver(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan metode baru ini di properti </font></font><code>Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// if ( // hasOutgoingRiver &amp;&amp; // elevation &lt; GetNeighbor(outgoingRiver).elevation // ) { // RemoveOutgoingRiver(); // } // if ( // hasIncomingRiver &amp;&amp; // elevation &gt; GetNeighbor(incomingRiver).elevation // ) { // RemoveIncomingRiver(); // } ValidateRivers(); … } } public int WaterLevel { … set { if (waterLevel == value) { return; } waterLevel = value; ValidateRivers(); Refresh(); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/ca4/b49/c04ca4b49ccff20e71dba70dc1a2bea7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keluar dan memasuki danau sungai.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putar ombak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menciptakan </font></font><code>HexGridChunk.TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menyarankan bahwa sungai hanya bisa mengalir ke badan air. </font><font style="vertical-align: inherit;">Karena itu, sebagai akibatnya, aliran sungai selalu bergerak dalam satu arah. </font><font style="vertical-align: inherit;">Kita perlu membalikkan aliran ketika berhadapan dengan sungai yang mengalir keluar dari badan air. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu tentang arah aliran. </font><font style="vertical-align: inherit;">Oleh karena itu, kami memberinya parameter Boolean yang menentukan apakah kami berhadapan dengan sungai yang masuk.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan meneruskan informasi ini saat memanggil metode ini dari </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2, cell.IncomingRiver == direction); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu memperluas aliran sungai dengan mengubah koordinat UV2. </font><font style="vertical-align: inherit;">Koordinat U untuk sungai keluar perlu dicerminkan: −0.5 menjadi 1.5, 0 menjadi 1, 1 menjadi 0, dan 1.5 menjadi −0.5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan koordinat V, segalanya menjadi sedikit lebih rumit. </font><font style="vertical-align: inherit;">Jika Anda melihat bagaimana kami bekerja dengan koneksi sungai terbalik, maka 0,8 harus menjadi 0, dan 1 harus −0,2. </font><font style="vertical-align: inherit;">Ini berarti bahwa 1,1 menjadi −0,3, dan 1,15 menjadi −0,35. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena dalam setiap kasus koordinat UV2 sangat berbeda, mari kita menulis kode terpisah untuk mereka.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incomingRiver) { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>) ); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rute sungai yang benar. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 9: fitur bantuan </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan objek ke relief. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuat dukungan untuk tingkat kepadatan objek. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menggunakan berbagai objek di tingkat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campurkan tiga jenis objek. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini kita akan berbicara tentang menambahkan objek ke medan. </font><font style="vertical-align: inherit;">Kami akan membuat objek seperti bangunan dan pohon.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/1ec/f84/b8b1ecf8496a03d50c881bbd47c262ad.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflik antara hutan, lahan pertanian dan urbanisasi.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan dukungan untuk objek </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun bentuk reliefnya bervariasi, sejauh ini tidak ada yang terjadi. </font><font style="vertical-align: inherit;">Ini adalah negeri yang tak bernyawa. </font><font style="vertical-align: inherit;">Untuk menghembuskan kehidupan ke dalamnya, Anda perlu menambahkan benda-benda tersebut. </font><font style="vertical-align: inherit;">seperti pohon dan rumah. </font><font style="vertical-align: inherit;">Objek-objek ini bukan bagian dari relief mesh, tetapi akan menjadi objek yang terpisah. </font><font style="vertical-align: inherit;">Tapi ini tidak menghentikan kita untuk menambahkannya saat melakukan triangulasi medan. </font></font><br><br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak peduli bagaimana mesh bekerja. </font><font style="vertical-align: inherit;">Dia hanya memerintahkan salah satu anaknya untuk </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambahkan segitiga atau quad. </font><font style="vertical-align: inherit;">Demikian pula, ia dapat memiliki elemen anak yang berhubungan dengan penempatan objek pada mereka.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer Obyek </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita membuat komponen </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menangani objek dalam satu fragmen. </font><font style="vertical-align: inherit;">Kami menggunakan skema yang sama dengan </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode yang diberikan padanya </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena objek perlu ditempatkan di suatu tempat, metode </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima parameter posisi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mulai dengan implementasi kosong yang tidak akan melakukan apa pun untuk saat ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexFeatureManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menambahkan tautan ke komponen semacam itu di </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian Anda bisa memasukkannya dalam proses triangulasi, seperti semua elemen anak </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureManager features; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); features.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); features.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita mulai dengan menempatkan satu objek di tengah setiap sel </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } features.AddFeature(cell.Position); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita membutuhkan manajer objek nyata. </font><font style="vertical-align: inherit;">Tambahkan </font><font style="vertical-align: inherit;">anak lain ke </font><font style="vertical-align: inherit;">prefab </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan berikan komponen </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian Anda dapat menghubungkan sebuah fragmen ke sana.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/1f4/626/eeb1f462652650c6dfe5e3cb34a2ec12.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51b/7ec/8f2/51b7ec8f20b4a79589fd2b464744230b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/c6f/8cd/620c6f8cd7c54c52597fcc289b160c57.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer objek ditambahkan ke prefab fragmen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objek cetakan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek medan apa yang akan kita buat? </font><font style="vertical-align: inherit;">Untuk tes pertama, sebuah kubus sangat cocok. </font><font style="vertical-align: inherit;">Mari kita buat kubus yang cukup besar, misalnya, dengan skala (3, 3, 3), dan mengubahnya menjadi cetakan. </font><font style="vertical-align: inherit;">Juga buat materi untuknya. </font><font style="vertical-align: inherit;">Saya menggunakan bahan standar dengan warna merah. </font><font style="vertical-align: inherit;">Mari kita hapus collider-nya, karena kita tidak membutuhkannya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1b1/315/a7a1b1315e7f2756ac2940dac661f95a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cetakan rumah pabrikan </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer objek akan memerlukan tautan ke cetakan ini, jadi tambahkan ke </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lalu sambungkan. </font><font style="vertical-align: inherit;">Karena akses ke komponen transformasi diperlukan untuk menempatkan objek, kami menggunakannya sebagai jenis tautan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform featurePrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/34d/e84/cfc34de84fbc12ac5fde17d7d1d09b58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer objek dengan cetakan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat instance objek </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturnya sudah siap, dan kita dapat mulai menambahkan fitur terain! </font><font style="vertical-align: inherit;">Cukup buat instance prefab di </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan atur posisinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/59c/ae5/dd859cae56fa9439e91d0ccb5d659f62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh fitur medan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai sekarang, medan akan diisi dengan kubus. </font><font style="vertical-align: inherit;">Setidaknya bagian atas kubus, karena asal lokal untuk kubus kubus di Unity adalah di tengah kubus, dan bagian bawah berada di bawah permukaan relief. </font><font style="vertical-align: inherit;">Untuk menempatkan kubus pada topografi, kita perlu memindahkannya setinggi setengahnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6be/89b/bb06be89b647d5ff29f1894bfdcf199b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubus di permukaan relief.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika kita menggunakan mesh lain?</font></font></b> <div class="spoiler_text">       .     ,      ,        .       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, sel kita terdistorsi, jadi kita perlu mengubah posisi objek. </font><font style="vertical-align: inherit;">Jadi kami menyingkirkan pengulangan mesh sempurna.</font></font><br><br><pre> <code class="cs hljs"> instance.localPosition = HexMetrics.Perturb(position);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/7ec/a43/9e57eca43cf9127691cb5eb11bc6a11a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posisi objek terdistorsi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penghancuran benda-benda bantuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap kali sebuah fragmen diperbarui, kami membuat objek bantuan baru. </font><font style="vertical-align: inherit;">Ini berarti bahwa saat kita membuat lebih banyak objek di posisi yang sama. </font><font style="vertical-align: inherit;">Untuk menghindari duplikat, kita perlu menyingkirkan benda-benda tua saat membersihkan sebuah fragmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara tercepat untuk melakukan ini adalah dengan membuat objek wadah permainan dan mengubah semua benda bantuan menjadi anak-anaknya. </font><font style="vertical-align: inherit;">Kemudian, ketika dipanggil, </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan menghancurkan wadah ini dan membuat yang baru. </font><font style="vertical-align: inherit;">Wadah itu sendiri akan menjadi anak dari manajernya.</font></font><br><br><pre> <code class="cs hljs"> Transform container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container) { Destroy(container.gameObject); } container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Features Container"</span></span>).transform; container.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin, tidak efisien untuk membuat dan menghancurkan objek bantuan setiap saat.</font></font></b> <div class="spoiler_text"> , ,   .       .      .   ,  ,      ,    .          <code>HexFeatureManager.Apply</code> .      .  ,    ,       . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penempatan benda bantuan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara kita menempatkan benda di tengah setiap sel. </font><font style="vertical-align: inherit;">Untuk sel kosong, ini terlihat normal, tetapi pada sel yang berisi sungai dan jalan, serta dibanjiri air, tampaknya aneh.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/e88/ab8/01de88ab8777d38afeb4ca374571a2f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek ada di mana-mana. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu, mari kita periksa sebelum menempatkan objek </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apakah selnya kosong.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell.Position); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/b98/75f/5dbb9875f8510c7f9224f8ba10465ae4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akomodasi terbatas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu objek per arah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya satu objek per sel yang tidak terlalu banyak. </font><font style="vertical-align: inherit;">Masih ada banyak ruang untuk banyak objek. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan objek tambahan ke pusat masing-masing dari enam segitiga sel, yaitu, satu per arah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan melakukan ini dengan metode lain </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ketika kami tahu bahwa tidak ada sungai di dalam sel. </font><font style="vertical-align: inherit;">Kita masih perlu memeriksa apakah kita berada di bawah air dan apakah ada jalan di dalam sel. </font><font style="vertical-align: inherit;">Namun dalam hal ini, kami hanya tertarik pada jalan yang menuju ke arah saat ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/b60/d4b/7e7b60d4b54d2f9a7b3119e78554507a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak fasilitas, tetapi tidak di sekitar sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menciptakan lebih banyak objek! </font><font style="vertical-align: inherit;">Mereka muncul di dekat jalan, tetapi masih menghindari sungai. </font><font style="vertical-align: inherit;">Untuk menempatkan objek di sepanjang sungai, kita juga bisa menambahkannya di dalam </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi sekali lagi hanya ketika segitiga tidak di bawah air dan tidak ada jalan di atasnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/90a/f9f/30c90af9ffb31cec360ea027fc4f1815.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek muncul di sebelah sungai.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin membuat begitu banyak objek?</font></font></b> <div class="spoiler_text">       ,    dynamic batching  Unity.    ,       .         batch.     « »,       .    instancing,          dynamic batching. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berbagai benda </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua benda bantuan kita memiliki orientasi yang sama, yang terlihat sangat tidak wajar. </font><font style="vertical-align: inherit;">Mari kita berikan masing-masing sentuhan acak.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b42/8bd/0bc/b428bd0bcb9b27676853f7bb1e491165.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belokan acak. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi hasilnya menjadi jauh lebih beragam. </font><font style="vertical-align: inherit;">Sayangnya, setiap kali sebuah fragmen diperbarui, objek menerima rotasi acak baru. </font><font style="vertical-align: inherit;">Mengedit sel seharusnya tidak mengubah objek di lingkungan, jadi kita perlu pendekatan yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki tekstur suara yang selalu sama. </font><font style="vertical-align: inherit;">Namun, tekstur ini mengandung noise gradien Perlin, dan konsisten secara lokal. </font><font style="vertical-align: inherit;">Inilah yang kita butuhkan saat mendistorsi posisi simpul dalam sel. </font><font style="vertical-align: inherit;">Namun belokan tidak harus konsisten. </font><font style="vertical-align: inherit;">Semua belokan harus sama kemungkinan dan campurannya. </font><font style="vertical-align: inherit;">Oleh karena itu, kita memerlukan tekstur dengan nilai acak non-gradien, yang dapat disampel tanpa penyaringan bilinear. </font><font style="vertical-align: inherit;">Pada dasarnya, ini adalah kotak hash yang membentuk dasar dari kebisingan gradien.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat tabel hash </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita bisa membuat tabel hash dari array nilai float dan mengisinya sekali dengan nilai acak. </font><font style="vertical-align: inherit;">Berkat ini, kami tidak perlu tekstur sama sekali. </font><font style="vertical-align: inherit;">Mari kita tambahkan </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ukuran 256 oleh 256 sudah cukup untuk variasi yang cukup.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashGridSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai acak dihasilkan oleh rumus matematika yang selalu memberikan hasil yang sama. </font><font style="vertical-align: inherit;">Urutan yang dihasilkan tergantung pada jumlah benih, yang secara default sama dengan nilai waktu saat ini. </font><font style="vertical-align: inherit;">Itulah sebabnya di setiap sesi permainan kami akan mendapatkan hasil yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa objek yang identik selalu diciptakan kembali, kita perlu menambahkan parameter seed ke metode inisialisasi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita telah menginisialisasi aliran angka acak, kita akan selalu mendapatkan urutan yang sama dari itu. </font><font style="vertical-align: inherit;">Oleh karena itu, kejadian yang tampaknya acak terjadi setelah generasi peta juga akan selalu sama. </font><font style="vertical-align: inherit;">Kita dapat menghindari ini dengan menyimpan keadaan generator angka acak sebelum menginisialisasi itu. </font><font style="vertical-align: inherit;">Setelah menyelesaikan pekerjaan, kita bisa menanyakan status lama.</font></font><br><br><pre> <code class="cs hljs"> Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } Random.state = currentState;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel hash diinisialisasi </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada saat yang sama yang memberikan tekstur noise. </font><font style="vertical-align: inherit;">Artinya, dalam metode </font></font><code>HexGrid.Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami membuatnya sehingga nilai-nilai tidak dihasilkan lebih sering dari yang diperlukan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel seed generik memungkinkan kita untuk memilih nilai seed untuk peta. </font><font style="vertical-align: inherit;">Nilai apa pun akan berlaku. </font><font style="vertical-align: inherit;">Saya memilih 1234.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/8b3/5a3/60c8b35a3b6a92b61165ed3a00473076.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan benih.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan tabel hash </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menggunakan tabel hash, tambahkan ke </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode pengambilan sampel. </font><font style="vertical-align: inherit;">Seperti </font></font><code>SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ia menggunakan koordinat posisi XZ untuk mendapatkan nilai. </font><font style="vertical-align: inherit;">Indeks hash ditemukan dengan membatasi koordinat ke nilai integer, dan kemudian mendapatkan sisa dari pembagian integer dengan ukuran tabel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang dilakukan%?</font></font></b> <div class="spoiler_text">   ,     ,    —  . ,  −4, −3, −2, −1, 0, 1, 2, 3, 4 modulo 3   −1, 0, −2, −1, 0, 1, 2, 0, 1. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berfungsi untuk koordinat positif, tetapi tidak untuk yang negatif, karena untuk angka seperti itu sisanya akan negatif. </font><font style="vertical-align: inherit;">Kita dapat memperbaikinya dengan menambahkan ukuran tabel ke hasil negatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang untuk setiap unit persegi kita menciptakan nilai kita sendiri. </font><font style="vertical-align: inherit;">Namun, pada kenyataannya, kita tidak perlu kepadatan meja seperti itu. </font><font style="vertical-align: inherit;">Objek ditempatkan terpisah satu sama lain. </font><font style="vertical-align: inherit;">Kami dapat meregangkan tabel dengan mengurangi skala posisi sebelum menghitung indeks. </font><font style="vertical-align: inherit;">Satu nilai unik untuk kotak 4 x 4 akan cukup bagi kami.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hashGridScale = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.x * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.z * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menggunakan tabel hash baru kami untuk mendapatkan nilai. </font><font style="vertical-align: inherit;">Setelah kami menerapkannya untuk menentukan rotasi, objek akan tetap diam saat mengedit medan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hash = HexMetrics.SampleHashGrid(position); Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambang penempatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun objek memiliki rotasi yang berbeda, suatu pola masih terlihat dalam penempatannya. </font><font style="vertical-align: inherit;">Setiap sel memiliki tujuh objek. </font><font style="vertical-align: inherit;">Kita dapat menambahkan kekacauan pada skema ini, secara acak melewatkan beberapa objek. </font><font style="vertical-align: inherit;">Bagaimana kita memutuskan apakah akan menambahkan objek atau tidak? </font><font style="vertical-align: inherit;">Tentu saja, memeriksa nilai acak lain! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, sekarang, alih-alih satu nilai hash, kita perlu dua. </font><font style="vertical-align: inherit;">Dukungan mereka dapat ditambahkan dengan menggunakan hash alih-alih </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel </font><font style="vertical-align: inherit;">sebagai tipe array tabel </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi operasi vektor tidak masuk akal untuk nilai hash, jadi mari kita buat struktur khusus untuk tujuan ini. </font><font style="vertical-align: inherit;">Dia hanya membutuhkan dua nilai float. </font><font style="vertical-align: inherit;">Dan mari kita tambahkan metode statis untuk membuat sepasang nilai acak.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexHash { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidakkah harus diserialkan?</font></font></b> <div class="spoiler_text">        ,  ,        Unity. ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubahlah </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menggunakan struktur baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexHash[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexHash[hashGridSize * hashGridSize]; Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = HexHash.Create(); } Random.state = currentState; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki akses ke dua nilai hash. </font><font style="vertical-align: inherit;">Mari kita gunakan yang pertama untuk memutuskan apakah akan menambahkan objek, atau melewatkannya. </font><font style="vertical-align: inherit;">Jika nilainya sama dengan atau lebih besar dari 0,5, maka lewati. </font><font style="vertical-align: inherit;">Dengan melakukan itu, kita akan menyingkirkan sekitar setengah dari objek. </font><font style="vertical-align: inherit;">Nilai kedua akan digunakan seperti biasa untuk menentukan rotasi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.b, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/e69/761/e89e697613f8eef3d149b07720e8a26a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kepadatan benda berkurang hingga 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggambar objek </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menempatkan objek di mana-mana, mari kita membuatnya dapat diedit. </font><font style="vertical-align: inherit;">Tapi kami tidak akan menggambar objek yang terpisah, tetapi menambahkan level objek ke setiap sel. </font><font style="vertical-align: inherit;">Level ini akan mengendalikan kemungkinan benda muncul di dalam sel. </font><font style="vertical-align: inherit;">Secara default, nilainya nol, yaitu objek tidak akan ada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena batu merah di medan kita tidak terlihat seperti benda alami, sebut saja itu bangunan. </font><font style="vertical-align: inherit;">Mereka akan mewakili urbanisasi. </font><font style="vertical-align: inherit;">Mari tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tingkat urbanisasi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UrbanLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urbanLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { urbanLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat membuat tingkat urbanisasi untuk sel bawah air sama dengan nol, tetapi ini tidak perlu, kita melewatkan pembuatan objek bawah air. </font><font style="vertical-align: inherit;">Dan mungkin di beberapa titik kita akan menambahkan badan air urbanisasi, seperti dermaga dan struktur bawah laut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Slider kepadatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengubah tingkat urbanisasi, kami menambahkan </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu lagi slider </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">mendukung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyUrbanLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeUrbanLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan slider lain ke UI dan gabungkan dengan metode yang sesuai. </font><font style="vertical-align: inherit;">Saya akan menempatkan panel baru di sisi kanan layar untuk menghindari meluapnya panel kiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berapa level yang kita butuhkan? </font><font style="vertical-align: inherit;">Mari kita bahas empat, yang menunjukkan kepadatan nol, rendah, sedang, dan tinggi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/e64/996/02fe649968954603df834d2a3b5f633b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/9e4/6f5/95e9e46f5ff83a9b7d713e85db86d67a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggeser urbanisasi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan ambang batas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki tingkat urbanisasi, kita perlu menggunakannya untuk menentukan apakah akan menempatkan objek. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu menambahkan tingkat urbanisasi sebagai parameter tambahan </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita selangkah lagi dan transfer saja sel itu sendiri. </font><font style="vertical-align: inherit;">Di masa depan, itu akan lebih nyaman bagi kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara tercepat untuk menggunakan tingkat urbanisasi adalah dengan mengalikannya dengan 0,25 dan menggunakan nilai sebagai ambang baru untuk melewatkan objek. </font><font style="vertical-align: inherit;">Karena ini, probabilitas penampilan objek akan meningkat dengan setiap level sebesar 25%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= cell.UrbanLevel * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar ini bekerja, mari kita sel untuk </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/7e9/de5/fd87e9de5b6b6ea4b4b490549ae5cbf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggambar tingkat kepadatan urbanisasi. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa cetakan benda bantuan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan dalam kemungkinan objek muncul tidak cukup untuk membuat pemisahan yang jelas antara urbanisasi tingkat rendah dan tinggi. Dalam beberapa sel, hanya akan ada lebih atau kurang dari jumlah bangunan yang diharapkan. Kita dapat membuat perbedaan lebih jelas dengan menggunakan prefab kita sendiri untuk setiap level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyingkirkan bidang </font></font><code>featurePrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menggantinya dengan array Rak itan urbanisasi. Untuk mendapatkan prefab yang sesuai, kami akan mengurangi satu dari tingkat urbanisasi dan menggunakan nilai sebagai indeks.</font></font><br><br><pre> <code class="cs hljs">&lt;del&gt;<span class="hljs-comment"><span class="hljs-comment">// public Transform featurePrefab;&lt;/del&gt; public Transform[] urbanPrefabs; public void AddFeature (HexCell cell, Vector3 position) { … Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat dua duplikat cetakan dari objek, ganti nama dan ubahlah sehingga menunjukkan tiga tingkat urbanisasi yang berbeda. </font><font style="vertical-align: inherit;">Level 1 adalah kepadatan rendah, jadi kami menggunakan kubus dengan panjang satuan tepi, yang menunjukkan gubuk. </font><font style="vertical-align: inherit;">Saya akan skala prefab level 2 ke (1,5, 2, 1,5) sehingga terlihat seperti bangunan dua lantai. </font><font style="vertical-align: inherit;">Untuk bangunan level 3 tinggi, saya menggunakan skala (2, 5, 2).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/4ad/cb6/b834adcb61a34d1e30cdec28925f066f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/41d/552/d4f41d5529d4716924345520ffc36280.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan cetakan yang berbeda untuk setiap tingkat urbanisasi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prefab Mix </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak diharuskan membatasi diri pada pemisahan jenis-jenis bangunan secara ketat. Anda dapat mencampurnya sedikit, seperti yang terjadi di dunia nyata. Alih-alih satu ambang per level, mari kita gunakan tiga, satu untuk setiap jenis bangunan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada level 1 kami menggunakan penempatan gubuk di 40% kasus. Tidak akan ada bangunan lain di sini sama sekali. Untuk level kami menggunakan tiga nilai (0,4, 0, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di level 2, ganti gubuk dengan bangunan yang lebih besar, dan tambahkan peluang 20% ​​untuk gubuk tambahan. Kami tidak akan melakukan gedung tinggi. Artinya, kami menggunakan ambang tiga nilai (0,2, 0,4, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada level 3, kami mengganti bangunan sedang dengan gedung tinggi, mengganti gubuk lagi, dan menambahkan 20% kemungkinan gubuk lainnya. Nilai ambang akan sama dengan (0,2, 0,2, 0,4).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, idenya adalah bahwa dengan meningkatnya tingkat urbanisasi, kami akan meningkatkan bangunan yang ada dan menambahkan yang baru ke tempat-tempat kosong. Untuk menghapus bangunan yang ada, kita perlu menggunakan interval nilai hash yang sama. Jika hash antara 0 dan 0,4 di level 1 adalah gubuk, maka pada level 3 interval yang sama akan membuat bangunan tinggi. Pada level 3, bangunan tinggi harus dibuat dengan hash di kisaran 0-0,4, bangunan dua lantai di kisaran 0,4-0,6, dan gubuk di kisaran 0,6-0,8. Jika Anda memeriksanya dari yang terbesar ke yang terkecil, maka ini dapat dilakukan dengan menggunakan triple of threshold (0,4, 0,6, 0,8). Ambang level 2 akan menjadi (0, 0.4, 0.6), dan ambang level 1 akan menjadi (0, 0, 0.4). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita simpan ambang ini di</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai kumpulan array dengan metode yang memungkinkan Anda untuk mendapatkan ambang batas untuk tingkat tertentu. </font><font style="vertical-align: inherit;">Karena kita hanya tertarik pada level dengan objek, kita mengabaikan level 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] featureThresholds = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeatureThresholds</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> featureThresholds[level]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, tambahkan ke </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode yang menggunakan tingkat dan nilai hash untuk memilih cetakan. </font><font style="vertical-align: inherit;">Jika level lebih besar dari nol, maka kita mendapatkan ambang menggunakan level yang dikurangi satu. </font><font style="vertical-align: inherit;">Lalu kami menggilir melalui ambang batas hingga salah satu dari mereka melebihi nilai hash. </font><font style="vertical-align: inherit;">Ini berarti bahwa kami telah menemukan cetakan. </font><font style="vertical-align: inherit;">Jika kami tidak menemukan, maka kembalikan nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan ini membutuhkan penataan ulang tautan ke prefab sehingga mereka beralih dari kepadatan tinggi ke rendah. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/eb5/80e/4dceb580e2410400a003b2ecad72d5c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesanan cetakan awal terbalik. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan metode baru kami </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memilih cetakan. </font><font style="vertical-align: inherit;">Jika kita tidak menerimanya, maka kita melewatkan objek. </font><font style="vertical-align: inherit;">Kalau tidak, buat instance dan lanjutkan seperti sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-comment"><span class="hljs-comment">// if (hash.a &gt;= cell.UrbanLevel * 0.25f) { // return; // } // Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a); if (!prefab) { return; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * 0.5f; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(0f, 360f * hash.b, 0f); instance.SetParent(container, false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/6f0/fcb/d336f0fcbf85285b38bb9c3de27ad77f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campur cetakan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variasi level </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami memiliki bangunan campuran, tetapi sejauh ini hanya ada tiga. </font><font style="vertical-align: inherit;">Kami selanjutnya dapat meningkatkan variabilitas dengan menghubungkan koleksi prefab ke setiap tingkat kepadatan urbanisasi. </font><font style="vertical-align: inherit;">Setelah itu, dimungkinkan untuk memilih salah satunya secara acak. </font><font style="vertical-align: inherit;">Ini akan membutuhkan nilai acak baru, jadi tambahkan ketiga c </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari mengubahnya </font></font><code>HexFeatureManager.urbanPrefabs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi array array, dan menambahkan </font></font><code>PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter </font><font style="vertical-align: inherit;">ke metode </font></font><code>choice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami menggunakannya untuk memilih indeks array bawaan, mengalikannya dengan panjang array ini dan mengubahnya menjadi integer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[][] urbanPrefabs; … <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i][(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * urbanPrefabs[i].Length)]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita benarkan pilihan kita pada nilai hash kedua (B). </font><font style="vertical-align: inherit;">Maka Anda perlu beralih dari B ke C.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a, hash.b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.c, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum melanjutkan, kita perlu mempertimbangkan apa yang </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mungkin mengembalikan nilai 1. Karena ini, indeks array mungkin melampaui. </font><font style="vertical-align: inherit;">Untuk mencegah hal ini terjadi, mari kita skalakan nilai hash. </font><font style="vertical-align: inherit;">Kami cukup mengatur semuanya agar tidak khawatir tentang spesifik yang kami gunakan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, inspektur tidak menampilkan array array. </font><font style="vertical-align: inherit;">Karena itu, kami tidak dapat mengonfigurasinya. </font><font style="vertical-align: inherit;">Untuk menyiasati batasan ini, buat struktur berseri yang dapat digunakan untuk mengenkapsulasi array bawaan. </font><font style="vertical-align: inherit;">Mari kita beri dia metode yang mengubah dari pilihan ke indeks array dan mengembalikan cetakan.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexFeatureCollection { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] prefabs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefabs[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * prefabs.Length)]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan di </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempat array built-in array koleksi seperti itu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Transform[][] urbanPrefabs; public HexFeatureCollection[] urbanCollections; … Transform PickPrefab (int level, float hash, float choice) { if (level &gt; 0) { float[] thresholds = HexMetrics.GetFeatureThresholds(level - 1); for (int i = 0; i &lt; thresholds.Length; i++) { if (hash &lt; thresholds[i]) { return urbanCollections[i].Pick(choice); } } } return null; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menetapkan beberapa bangunan untuk setiap tingkat kepadatan. </font><font style="vertical-align: inherit;">Karena mereka independen, kita tidak harus menggunakan jumlah yang sama per level. </font><font style="vertical-align: inherit;">Saya hanya menggunakan dua opsi per level, menambahkan opsi yang lebih rendah lagi untuk masing-masing. </font><font style="vertical-align: inherit;">Saya memilih timbangan (3,5, 3, 2), (2,75, 1,5, 1,5) dan (1,75, 1, 1) untuk mereka.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/a6e/c9f/b71a6ec9f2c379c223e007dda071c94b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/618/81d/a7261881d23703b54aaf22ba59942d2a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dua jenis bangunan per tingkat kepadatan. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa jenis benda </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam skema yang ada, kita dapat membuat struktur perkotaan yang cukup layak. </font><font style="vertical-align: inherit;">Namun, relief itu mungkin tidak hanya berisi bangunan. </font><font style="vertical-align: inherit;">Bagaimana dengan pertanian atau tanaman? </font><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">level dan untuk mereka. </font><font style="vertical-align: inherit;">Mereka tidak saling eksklusif dan dapat bercampur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FarmLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> farmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (farmLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { farmLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlantLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plantLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { plantLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel, farmLevel, plantLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, ini membutuhkan dukungan dalam </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua slider tambahan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyFarmLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeFarmLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyPlantLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activePlantLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyFarmLevel) { cell.FarmLevel = activeFarmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyPlantLevel) { cell.PlantLevel = activePlantLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan mereka ke UI. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/70b/f35/95670bf35594faa69fe46201b78080f7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga slider.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juga, koleksi tambahan akan dibutuhkan </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureCollection[] urbanCollections, farmCollections, plantCollections;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/001/cec/f5d001cecb2bee3c60a0dad637de7dc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga koleksi benda bantuan.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya membuat untuk kedua pertanian dan tanaman dua cetakan per tingkat kepadatan, serta untuk membangun koleksi. Untuk mereka semua, saya menggunakan kubus. Peternakan memiliki bahan hijau muda, tanaman memiliki bahan hijau tua. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya membuat kubus pertanian dengan ketinggian 0,1 unit untuk menunjukkan peruntukan lahan pertanian persegi. Sebagai skala kepadatan tinggi, saya memilih (2,5, 0,1, 2,5) dan (3,5, 0,1, 2). Rata-rata, situs memiliki luas 1,75 dan ukuran 2,5 kali 1,25. Tingkat kepadatan yang rendah diperoleh dengan luas 1 dan ukuran 1,5 x 0,75. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanaman cetakan menunjukkan pohon tinggi dan semak besar. Pabrikan dengan kepadatan tinggi adalah yang terbesar, (1,25, 4,5, 1,25) dan (1,5, 3, 1,5). Skala rata-rata adalah (0,75, 3, 0,75) dan (1, 1,5, 1). Tanaman terkecil memiliki ukuran (0,5, 1,5, 0,5) dan (0,75, 1, 0,75).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pilihan fitur bantuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap jenis objek harus menerima nilai hash sendiri sehingga mereka memiliki pola kreasi yang berbeda dan Anda dapat mencampurnya. </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua nilai tambahan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d, e; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.d = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.e = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda harus </font></font><code>HexFeatureManager.PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja dengan koleksi yang berbeda. </font><font style="vertical-align: inherit;">Tambahkan parameter untuk menyederhanakan proses. </font><font style="vertical-align: inherit;">Juga, ubah hash yang digunakan oleh varian prefab yang dipilih menjadi D, dan hash untuk rotasi menjadi E.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexFeatureCollection[] collection, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[i].Pick(choice); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); … instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memilih urbanisasi prefab. </font><font style="vertical-align: inherit;">Ini normal, kami membutuhkan lebih banyak opsi. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan cetakan lain dari peternakan. </font><font style="vertical-align: inherit;">Sebagai nilai hash, gunakan B. Pilihan opsi lagi akan menjadi D.</font></font><br><br><pre> <code class="cs hljs"> Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh cetakan apa yang akan kita buat sebagai hasilnya? </font><font style="vertical-align: inherit;">Jika salah satu dari mereka ternyata nol, maka pilihannya jelas. </font><font style="vertical-align: inherit;">Namun, jika keduanya ada, maka kita perlu membuat keputusan. </font><font style="vertical-align: inherit;">Mari kita tambahkan prefab dengan nilai hash terendah.</font></font><br><br><pre> <code class="cs hljs"> Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baf/369/d71/baf369d71420a1ded309880b38d94c53.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campuran objek perkotaan dan pedesaan. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, lakukan hal yang sama dengan tanaman menggunakan nilai hash C.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, kami tidak bisa hanya menyalin kode. </font><font style="vertical-align: inherit;">Ketika kita memilih pedesaan daripada objek perkotaan, kita perlu membandingkan hash tanaman dengan hash pertanian, dan bukan dengan urban. </font><font style="vertical-align: inherit;">Oleh karena itu, kita perlu melacak hash yang kita putuskan untuk memilih dan membandingkannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> usedHash = hash.a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; usedHash = hash.b; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; usedHash = hash.b; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; usedHash) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/2e2/215/8eb2e2215e6219b08e8bc42612b31493.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campuran objek perkotaan, pedesaan dan tanaman. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 10: dinding </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami melampirkan sel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membangun dinding di sepanjang tepi sel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita melewati sungai dan jalan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari air dan hubungkan dengan tebing. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada bagian ini kita akan menambahkan antara sel-sel dinding. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/924/d07/0cd/924d070cd67c3baccf02a0284ef9cdc4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang lebih menarik daripada tembok tinggi.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editing Dinding </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung dinding, kita perlu tahu di mana menempatkannya. </font><font style="vertical-align: inherit;">Kami akan menempatkan mereka di antara sel di sepanjang tepi yang menghubungkannya. </font><font style="vertical-align: inherit;">Karena benda yang sudah ada terletak di bagian tengah sel, kita tidak perlu khawatir bahwa dinding akan melewatinya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/bbb/c11/7a1bbbc1158301bb0091638858fa79fd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding di sepanjang tepi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding adalah benda medan, meski besar. </font><font style="vertical-align: inherit;">Seperti objek lain, kami tidak akan mengeditnya secara langsung. </font><font style="vertical-align: inherit;">Sebagai gantinya, kami akan mengubah sel. </font><font style="vertical-align: inherit;">Kami tidak akan memiliki segmen yang terpisah dari dinding, tetapi akan terlibat dalam melampirkan sel secara keseluruhan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Properti Bertembok </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung sel berpagar, tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti </font></font><code>Walled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah saklar sederhana. </font><font style="vertical-align: inherit;">Karena dinding terletak di antara sel, kita perlu memperbarui sel yang diedit dan tetangganya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Walled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walled; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walled != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { walled = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> walled;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Switch editor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengganti status "berpagar" sel, kita perlu menambahkan </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dukungan untuk sakelar. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan bidang lain </font></font><code>OptionalToggle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan metode untuk menyetelnya.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode, walledMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWalledMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { walledMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak seperti sungai dan jalan, dinding tidak berpindah dari sel ke sel, tetapi berada di antara mereka. </font><font style="vertical-align: inherit;">Karena itu, kita tidak perlu memikirkan drag and drop. </font><font style="vertical-align: inherit;">Ketika sakelar dinding aktif, kita cukup mengatur keadaan berpagar sel saat ini berdasarkan keadaan sakelar ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walledMode != OptionalToggle.Ignore) { cell.Walled = walledMode == OptionalToggle.Yes; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { … } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menduplikasi salah satu elemen sebelumnya dari sakelar UI dan mengubahnya sehingga mereka mengontrol keadaan "pagar". </font><font style="vertical-align: inherit;">Saya akan menempatkan mereka di panel UI bersama dengan objek lain.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/f7f/0ca/0acf7f0caaaae171e31d42141fa75947.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saklar "pagar". </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menciptakan dinding </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena dinding mengikuti kontur sel, mereka seharusnya tidak memiliki bentuk yang konstan. </font><font style="vertical-align: inherit;">Karenanya, kami tidak dapat hanya menggunakan prefab untuknya, seperti yang kami lakukan dengan fitur terain lainnya. </font><font style="vertical-align: inherit;">Alih-alih, kita perlu membangun jaring, seperti yang kita lakukan dengan bantuan. </font><font style="vertical-align: inherit;">Ini berarti bahwa fragmen cetakan kami membutuhkan elemen anak lain </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gandakan salah satu jerat anak lainnya dan buat objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">memberi bayangan. </font><font style="vertical-align: inherit;">Mereka tidak membutuhkan apa pun kecuali simpul dan segitiga, sehingga semua opsi </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus dinonaktifkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/387/31d/61538731d2eed271c9348c4da2f5d844.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/c6e/af5/2bfc6eaf5ff31f5467ab252c00b7bcce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding Rak Pabrikan Anak Perusahaan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan logis bahwa tembok itu adalah objek perkotaan, jadi bagi mereka saya menggunakan bahan merah bangunan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajemen dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena dinding adalah benda yang melegakan, mereka harus menghadapinya </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan memberikan pengelola objek bantuan tautan ke objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan membuatnya memanggil metode </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh walls; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … walls.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { walls.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f9/0f3/31d8f90f315c7aa43910c67aab6b73cb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding terhubung ke manajer topografi.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah seharusnya Walls menjadi anak Fitur?</font></font></b> <div class="spoiler_text">       ,   .             ,    <em>Walls</em>    <em>Hex Grid Chunk</em> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu menambahkan metode ke manajer yang memungkinkan kita menambahkan dinding ke dalamnya. </font><font style="vertical-align: inherit;">Karena dinding berada di sepanjang tepi antara sel, ia perlu mengetahui simpul yang sesuai dari tepi dan sel. </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menyebabkannya melalui </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pada saat triangulasi sel dan salah satu tetangganya. </font><font style="vertical-align: inherit;">Dari sudut pandang ini, sel saat ini berada di sisi dekat dinding, dan yang lain di sisi yang jauh.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memanggil metode baru ini </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah menyelesaikan semua pekerjaan penghubung lainnya dan segera sebelum transisi ke segitiga sudut. </font><font style="vertical-align: inherit;">Kami akan membiarkan pengelola benda-benda bantuan memutuskan sendiri di mana tembok itu seharusnya berada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } features.AddWall(e1, cell, e2, neighbor); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bangun segmen dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seluruh dinding akan berkelok-kelok melewati beberapa tepi sel. </font><font style="vertical-align: inherit;">Setiap tepi hanya mengandung satu elemen dinding. </font><font style="vertical-align: inherit;">Dari sudut pandang sel dekat, segmen dimulai di sisi kiri tulang rusuk dan berakhir di sisi kanan. </font><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode terpisah yang menggunakan empat simpul di sudut-sudut tepi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/2a0/d7b/f322a0d7bc325b13f65c62cfb76b2d0c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisi dekat dan jauh. </font></font></i> <br><br> <code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat memanggil metode ini dengan tepi pertama dan terakhir dari tepi. </font><font style="vertical-align: inherit;">Tapi dinding hanya boleh ditambahkan ketika kita memiliki koneksi antara sel berpagar dan sel non-berpagar. </font><font style="vertical-align: inherit;">Tidak masalah sel mana yang ada di dalam dan mana yang di luar, hanya perbedaan statusnya yang diperhitungkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v5, far.v5); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmen dinding yang paling sederhana adalah satu quad, berdiri di tengah tulang rusuk. </font><font style="vertical-align: inherit;">Kami akan menemukan puncaknya yang lebih rendah, menyisipkan ke tengah dari yang terdekat ke puncak terjauh.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seberapa tinggi seharusnya tembok itu? </font><font style="vertical-align: inherit;">Mari atur ketinggiannya </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya membuat mereka seukuran level sel satu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br> <code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat menggunakan ketinggian ini untuk memposisikan simpul ketiga dan keempat dari quad, dan juga menambahkannya ke jala </font></font><code>walls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 v1, v2, v3, v4; v1 = v3 = left; v2 = v4 = right; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengedit dinding dan mereka akan ditampilkan sebagai garis quad. </font><font style="vertical-align: inherit;">Namun, kita tidak akan melihat dinding yang berkelanjutan. </font><font style="vertical-align: inherit;">Setiap quad hanya terlihat di satu sisi. </font><font style="vertical-align: inherit;">Wajahnya diarahkan ke sel tempat ia ditambahkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/2f0/442/e5a2f0442a2d1812b73dd2977d80d565.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding quad satu sisi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat dengan cepat menyelesaikan masalah ini dengan menambahkan quad kedua yang menghadap ke arah lain.</font></font><br><br><pre> <code class="cs hljs"> walls.AddQuad(v1, v2, v3, v4); walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/302/e53/129/302e53129e87c3432848772688e9d896.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding bilateral. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang semua dinding terlihat secara keseluruhan, tetapi masih ada lubang di sudut-sudut sel tempat ketiga sel bertemu. </font><font style="vertical-align: inherit;">Kami akan mengisinya nanti.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinding tebal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun dinding sudah terlihat di kedua sisi, mereka tidak memiliki ketebalan. </font><font style="vertical-align: inherit;">Bahkan, dindingnya tipis, seperti kertas, dan nyaris tak terlihat pada sudut tertentu. </font><font style="vertical-align: inherit;">Jadi mari kita membuatnya utuh dengan menambahkan ketebalan. </font><font style="vertical-align: inherit;">Atur ketebalannya </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya memilih nilai 0,75 unit, menurut saya cocok.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallThickness = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat dua dinding tebal, Anda harus membelah dua paha depan. </font><font style="vertical-align: inherit;">Mereka harus bergerak ke arah yang berlawanan. </font><font style="vertical-align: inherit;">Satu sisi harus bergerak ke arah tepi dekat, yang lain ke tepi jauh. </font><font style="vertical-align: inherit;">Vektor offset untuk ini sama </font></font><code>far - near</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi untuk meninggalkan bagian atas dinding datar, kita perlu mengatur komponen Y menjadi 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ini perlu dilakukan untuk sisi kiri dan kanan segmen dinding, mari kita tambahkan </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor offset </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">metode untuk menghitung ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallThicknessOffset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { Vector3 offset; offset.x = far.x - near.x; offset.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; offset.z = far.z - near.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar dinding tetap berada di tengah tulang rusuk, jarak gerakan sebenarnya sepanjang vektor ini harus sama dengan setengah ketebalan untuk setiap sisi. </font><font style="vertical-align: inherit;">Dan untuk memastikan bahwa kami benar-benar memindahkan jarak yang tepat, kami menormalkan vektor perpindahan sebelum menskalanya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset.normalized * (wallThickness * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan metode ini </font></font><code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengubah posisi paha depan. </font><font style="vertical-align: inherit;">Karena vektor perpindahan bergerak dari yang terdekat ke sel jauh, kurangi dari quad dekat dan tambahkan ke yang jauh.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 leftThicknessOffset = HexMetrics.WallThicknessOffset(nearLeft, farLeft); Vector3 rightThicknessOffset = HexMetrics.WallThicknessOffset(nearRight, farRight); Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/746/08b/df774608b2b06114b4afbc6ec2904e61.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding dengan offset. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paha depan sekarang bias, meskipun ini tidak sepenuhnya terlihat.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ketebalan dindingnya sama?</font></font></b> <div class="spoiler_text">    ,      «-»     .      ,    .       .       ,   .    ,    .  , -      ,     .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian atas dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat ketebalan dinding terlihat dari atas, kita perlu menambahkan quad ke bagian atas dinding. </font><font style="vertical-align: inherit;">Cara termudah untuk melakukan ini adalah dengan mengingat dua simpul atas dari quad pertama dan menghubungkannya dengan dua simpul atas dari quad kedua.</font></font><br><br><pre> <code class="cs hljs"> Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3); walls.AddQuad(t1, t2, v3, v4);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/15d/627/1d715d627770a9e7a17bf135a461833d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding dengan atasan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menikung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami masih memiliki lubang di sudut sel. </font><font style="vertical-align: inherit;">Untuk mengisinya, kita perlu menambahkan segmen ke area segitiga di antara sel. </font><font style="vertical-align: inherit;">Setiap sudut menghubungkan tiga sel. </font><font style="vertical-align: inherit;">Setiap sel mungkin memiliki atau tidak memiliki dinding. </font><font style="vertical-align: inherit;">Artinya, delapan konfigurasi dimungkinkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/277/8ee/ed92778ee39106d3a448892a124d366c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi sudut. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menempatkan dinding hanya di antara sel dengan negara berpagar yang berbeda. </font><font style="vertical-align: inherit;">Ini mengurangi jumlah konfigurasi menjadi enam. </font><font style="vertical-align: inherit;">Di masing-masing, salah satu sel berada di dalam kurva dinding. </font><font style="vertical-align: inherit;">Mari kita pertimbangkan sel ini sebagai titik referensi di mana dinding melengkung. </font><font style="vertical-align: inherit;">Dari sudut pandang sel ini, dinding dimulai dengan tepi yang sama dengan sel kiri dan berakhir dengan tepi yang sama dengan sel kanan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/f68/19a/48ef6819a839339a17d1513f7ca546b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peran sel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, kita perlu membuat metode </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang parameternya adalah tiga simpul sudut. </font><font style="vertical-align: inherit;">Meskipun kita dapat menulis kode untuk melakukan triangulasi pada segmen ini, sebenarnya ini adalah kasus khusus dari metode ini </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Titik jangkar memainkan peran kedua simpul dekat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, buat varian metode </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk tiga simpul sudut dan sel-selnya. </font><font style="vertical-align: inherit;">Tujuan dari metode ini adalah untuk menentukan sudut, yang merupakan titik referensi, jika ada. </font><font style="vertical-align: inherit;">Karena itu, ia harus mempertimbangkan kedelapan konfigurasi yang mungkin dan meminta </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enam dari mereka.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 c1, HexCell cell1, Vector3 c2, HexCell cell2, Vector3 c3, HexCell cell3 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell1.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menambahkan segmen sudut, panggil metode ini di akhir </font></font><code>HexGridChunk.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/e63/304/a8ee63304fce04d4db9dcdf46076b3a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding dengan sudut, tetapi masih ada lubang.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tutup lubangnya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih ada lubang di dinding karena ketinggian segmen dinding bervariasi. Sementara segmen di sepanjang tepi memiliki ketinggian konstan, segmen sudut berada di antara dua tepi yang berbeda. Karena setiap tepi dapat memiliki tinggi sendiri, lubang muncul di sudut-sudut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memperbaikinya, ubahlah </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga ia menyimpan secara terpisah koordinat Y dari simpul atas kiri dan kanan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftTop = left.y + HexMetrics.wallHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightTop = right.y + HexMetrics.wallHeight; Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/f1d/a88/9cdf1da889ce427e1d519a284532d6a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding tertutup.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinding sekarang ditutup, tetapi Anda mungkin masih melihat lubang di bayang-bayang dinding. Ini disebabkan oleh parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias Normal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">pengaturan bayangan arah. Ketika lebih besar dari nol, segitiga benda yang melemparkan bayangan bergerak sepanjang normal ke permukaan. Ini menghindari bayangan diri, tetapi pada saat yang sama menciptakan lubang dalam kasus di mana segitiga terlihat ke arah yang berbeda. Dalam hal ini, lubang dapat dibuat dalam bayangan geometri halus, misalnya, seperti dinding kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menyingkirkan artefak bayangan ini dengan menurunkan bias normal menjadi nol. Atau ubah mode </font><font style="vertical-align: inherit;">dinding renderer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast Shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mesh ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two Sided</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini akan membuat bayangan membuat objek membuat kedua sisi setiap segitiga dinding untuk rendering, yang akan menutup semua lubang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/9d5/d0b/b149d5d0bb36f049faa5ca9d49261618.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada lagi lubang di bayangan. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinding langkan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, dinding kami cukup lurus. </font><font style="vertical-align: inherit;">Untuk medan datar ini tidak buruk sama sekali, tetapi terlihat aneh ketika dinding bertepatan dengan tepian. </font><font style="vertical-align: inherit;">Ini terjadi ketika ada perbedaan satu tingkat ketinggian antara sel-sel di sisi yang berlawanan dari dinding.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/481/c1a/065481c1a0859ced22d0ae6568acbe86.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding lurus di tepian.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ikuti tepinya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih membuat satu segmen untuk seluruh tepi, kami akan membuat satu untuk setiap bagian dari strip tepi. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dengan memanggil empat kali </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di versi </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tepi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/8aa/0f9/a968aa0f984b31e81dc9edb12e8d31bb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding melengkung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding sekarang mengulangi bentuk tepi yang terdistorsi. </font><font style="vertical-align: inherit;">Dalam kombinasi dengan tepian, terlihat jauh lebih baik. </font><font style="vertical-align: inherit;">Selain itu, ini menciptakan dinding yang lebih menarik pada relief datar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menempatkan dinding di tanah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melihat dinding di tepian, Anda dapat menemukan masalah. Dindingnya tergantung di tanah! Ini berlaku untuk tepi rata yang cenderung, tetapi biasanya tidak begitu terlihat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/8f0/a59/0398f0a59aca756824e162c3fba5a891.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding tergantung di udara.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk mengatasi masalah tersebut, kita perlu menurunkan dinding. Cara termudah adalah menurunkan seluruh dinding sehingga bagian atasnya tetap rata. Pada saat yang sama, sebagian dinding di sisi atas akan sedikit turun ke relief, tetapi ini cocok untuk kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menurunkan dinding, kita perlu menentukan sisi mana yang lebih rendah - dekat atau jauh. Kami hanya bisa menggunakan ketinggian sisi terendah, tetapi kami tidak perlu terlalu rendah. Anda dapat menginterpolasi koordinat Y dari rendah ke tinggi dengan offset di bawah 0,5. Karena dinding hanya sesekali menjadi lebih tinggi dari langkah bawah langkan, kita dapat menggunakan langkah vertikal langkan sebagai penyeimbang. Ketebalan dinding yang berbeda dari konfigurasi langkan mungkin memerlukan offset yang berbeda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/61c/817/96061c817bfdc69db9682e0799ba3751.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding yang diturunkan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berhubungan dengan interpolasi ini, selain rata-rata koordinat X dan Z dari simpul dekat dan jauh. </font><font style="vertical-align: inherit;">Itu didasarkan pada suatu metode </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallElevationOffset = verticalTerraceStepSize; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paksa </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode ini untuk menentukan simpul kiri dan kanan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = HexMetrics.WallLerp(nearLeft, farLeft); Vector3 right = HexMetrics.WallLerp(nearRight, farRight); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/a4c/b49/957a4cb498eb8a712064a0b99a4041be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding berdiri di tanah.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan distorsi dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tembok kami dalam perjanjian yang baik dengan perbedaan ketinggian. Tetapi mereka masih tidak sepenuhnya sesuai dengan tepi yang terdistorsi, meskipun mereka dekat dengan mereka. Ini terjadi karena pertama-tama kita menentukan bagian atas dinding, dan kemudian mendistorsi mereka. Karena simpul-simpul ini berada di suatu tempat antara simpul-simpul tepi dekat dan jauh, distorsi mereka akan sedikit berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fakta bahwa dinding mengikuti tulang rusuk secara tidak akurat bukanlah masalah. Namun, distorsi bagian atas dinding berubah ketebalan yang relatif seragam. Jika kita mengatur dinding berdasarkan simpul terdistorsi, dan kemudian menambahkan paha depan tidak terdistorsi, ketebalannya tidak akan jauh berbeda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { nearLeft = HexMetrics.Perturb(nearLeft); farLeft = HexMetrics.Perturb(farLeft); nearRight = HexMetrics.Perturb(nearRight); farRight = HexMetrics.Perturb(farRight); … walls.AddQuadUnperturbed(v1, v2, v3, v4); … walls.AddQuadUnperturbed(v2, v1, v4, v3); walls.AddQuadUnperturbed(t1, t2, v3, v4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/fa3/03d/b10fa303dc91a50665bf92b47feed5e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian atas dinding yang tidak terdistorsi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat pendekatan ini, dinding tidak akan lagi mengikuti tepian setepat sebelumnya. </font><font style="vertical-align: inherit;">Tetapi sebagai imbalannya mereka akan menjadi kurang rusak dan akan memiliki ketebalan yang lebih konstan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/7f6/b6f/d387f6b6f1c4fed424d2582a8ef5c12c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketebalan dinding lebih konsisten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lubang-lubang di dinding </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami telah mengabaikan kemungkinan sungai atau jalan melintasi tembok. </font><font style="vertical-align: inherit;">Ketika ini terjadi, kita harus membuat lubang di dinding yang dilewati oleh sungai atau jalan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua parameter Boolean untuk menunjukkan apakah sungai atau jalan melewati tepi. </font><font style="vertical-align: inherit;">Meskipun kita dapat menanganinya secara berbeda, mari kita hapus dua segmen menengah dalam kedua kasus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { <span class="hljs-comment"><span class="hljs-comment">// Leave a gap. } else { AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); } AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menyediakan data yang diperlukan. </font><font style="vertical-align: inherit;">Karena dia sudah membutuhkan informasi yang sama, mari kita cache dalam variabel Boolean dan merekam panggilan ke metode yang sesuai hanya sekali.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRiver = cell.HasRiverThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoad = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.Color, e2, neighbor.Color, hasRoad); } features.AddWall(e1, cell, e2, neighbor, hasRiver, hasRoad); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/d05/425/64cd0542540b5d9347a071d727fe2fa4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lubang-lubang di dinding untuk melewati sungai dan jalan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menutupi dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukaan baru ini menciptakan tempat untuk melengkapi tembok. </font><font style="vertical-align: inherit;">Kita perlu menutup titik-titik akhir ini dengan paha depan agar kita tidak bisa melihat melalui sisi-sisi tembok. </font><font style="vertical-align: inherit;">Mari kita buat </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font><font style="vertical-align: inherit;">untuk tujuan ini </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini berfungsi seperti itu </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi hanya membutuhkan sepasang puncak jarak dekat. </font><font style="vertical-align: inherit;">Buat dia menambahkan quad, pergi dari dekat ke sisi jauh dinding.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallCap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = center.y + HexMetrics.wallHeight; walls.AddQuadUnperturbed(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menemukan bahwa kami membutuhkan lubang, kami menambahkan penutup antara pasangan tepi kedua dan keempat. </font><font style="vertical-align: inherit;">Untuk pasangan keempat simpul, Anda perlu mengubah orientasi, jika tidak, wajah quad akan melihat ke dalam.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { AddWallCap(near.v2, far.v2); AddWallCap(far.v4, near.v4); } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/98c/828/41398c82892a2c1f706ca85c9230813a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lubang tertutup di dinding.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan lubang di sekitar tepi peta?</font></font></b> <div class="spoiler_text">   ,     .        .    ,        . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghindari tebing dan air </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, mari kita lihat tepi yang berisi tebing atau air. </font><font style="vertical-align: inherit;">Karena tebing pada dasarnya adalah dinding besar, maka tidak masuk akal untuk menempatkan dinding tambahan di atasnya. </font><font style="vertical-align: inherit;">Selain itu, akan terlihat buruk. </font><font style="vertical-align: inherit;">Dinding bawah laut juga sama sekali tidak masuk akal, seperti halnya pembatasan oleh dinding pantai.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/94e/027/45a94e027094c6ebdae0763663d6eb8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding di tebing dan di dalam air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat menghapus dinding dari tepi yang tidak perlu ini dengan tambahan cek masuk </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dinding tidak bisa berada di bawah air, dan tulang rusuk yang umum dengannya tidak bisa menjadi tebing.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nearCell.Walled != farCell.Walled &amp;&amp; !nearCell.IsUnderwater &amp;&amp; !farCell.IsUnderwater &amp;&amp; nearCell.GetEdgeType(farCell) != HexEdgeType.Cliff ) { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/baf/75a/128baf75ace7d0cf4ed5f12ef380eec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding yang menghalangi sepanjang tulang rusuk telah dihapus, tetapi sudut tetap di tempatnya.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus sudut dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghapus segmen sudut yang tidak perlu akan membutuhkan sedikit usaha. </font><font style="vertical-align: inherit;">Kasus paling sederhana adalah ketika sel pendukung berada di bawah air. </font><font style="vertical-align: inherit;">Ini memastikan bahwa tidak ada segmen dinding di dekatnya yang dapat dihubungkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/475/9f3/ecc4759f38ced7802ad8743626f91d51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada lagi sel pendukung bawah air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu melihat dua sel lainnya. </font><font style="vertical-align: inherit;">Jika salah satunya ada di bawah air atau terhubung ke sel pendukung oleh istirahat, maka tidak ada dinding di sepanjang tulang rusuk ini. </font><font style="vertical-align: inherit;">Jika ini benar untuk setidaknya satu sisi, maka tidak boleh ada segmen dinding di sudut ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami secara individual menentukan apakah ada dinding kiri atau kanan. </font><font style="vertical-align: inherit;">Kami menempatkan hasilnya dalam variabel Boolean untuk membuatnya lebih mudah untuk dikerjakan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasLeftWall = !leftCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(leftCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRighWall = !rightCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(rightCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall &amp;&amp; hasRighWall) { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/f17/82d/8cdf1782d522d5b9e19e461ee5253436.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghapus semua sudut yang mengganggu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tutup sudutnya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika tidak ada dinding di tepi kiri atau kanan, pekerjaan selesai. </font><font style="vertical-align: inherit;">Tetapi jika dinding itu hanya dalam satu arah, itu berarti ada lubang lain di dinding itu. </font><font style="vertical-align: inherit;">Karena itu, Anda perlu menutupnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallCap(right, pivot); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20e/c4d/176/20ec4d17689500d123fc5fd41d447e88.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menutup dinding.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koneksi dinding dengan tebing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam satu situasi, dinding terlihat tidak sempurna. </font><font style="vertical-align: inherit;">Ketika dinding mencapai bagian bawah tebing, itu berakhir. </font><font style="vertical-align: inherit;">Tetapi karena tebing tidak sepenuhnya vertikal, lubang sempit dibuat antara dinding dan tepi tebing. </font><font style="vertical-align: inherit;">Di puncak tebing, masalah seperti itu tidak muncul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/5c6/9a7/6335c69a7f45dcd1c2a0609503b2504a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lubang di antara dinding dan wajah tebing. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan jauh lebih baik jika dinding terus ke ujung tebing. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dengan menambahkan segmen dinding lain antara ujung dinding saat ini dan ujung atas tebing. </font><font style="vertical-align: inherit;">Karena sebagian besar segmen ini akan disembunyikan di dalam tebing, kita dapat melakukannya tanpa mengurangi ketebalan dinding di dalam tebing menjadi nol. </font><font style="vertical-align: inherit;">Dengan demikian, cukup bagi kita untuk membuat irisan: dua paha depan ke titik dan segitiga di atas mereka. </font><font style="vertical-align: inherit;">Mari kita buat metode untuk tujuan ini </font></font><code>AddWallWedge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menyalin </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menambahkan titik irisan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallWedge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far, Vector3 point</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); point = HexMetrics.Perturb(point); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; Vector3 pointTop = point; point.y = center.y; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = pointTop.y = center.y + HexMetrics.wallHeight; <span class="hljs-comment"><span class="hljs-comment">// walls.AddQuadUnperturbed(v1, v2, v3, v4); walls.AddQuadUnperturbed(v1, point, v3, pointTop); walls.AddQuadUnperturbed(point, v2, pointTop, v4); walls.AddTriangleUnperturbed(pointTop, v3, v4); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudut kita akan memanggil metode ini ketika dinding hanya berjalan satu arah dan dinding ini berada pada ketinggian yang lebih rendah dari sisi lainnya. </font><font style="vertical-align: inherit;">Dalam kondisi seperti inilah kita berhadapan dengan tepi jurang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { AddWallWedge(pivot, left, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightCell.Elevation &lt; leftCell.Elevation) { AddWallWedge(right, pivot, left); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(right, pivot); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/30f/33a/b5c30f33ac93582e2ce319996d9ed1ac.png"></div><br> <i> ,   .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">unitypackage</a> <br><br><h1>  11:    </h1><br><ul><li>    . </li><li>     . </li><li>     . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a07/5ea/ef5a075ea4c14c810825388be274f817.jpg"></div><br> <i>  .</i> <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian sebelumnya, kami menambahkan dukungan dinding. Ini adalah segmen dinding lurus sederhana tanpa perbedaan nyata. Sekarang kita akan membuat dinding lebih menarik dengan menambahkan menara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmen dinding harus dibuat secara prosedural agar sesuai dengan relief. Ini tidak diperlukan untuk menara, kita bisa menggunakan prefab biasa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita bisa membuat menara sederhana dua kubus dengan bahan merah. Pangkalan menara memiliki ukuran 2 kali 2 unit dan tinggi 4 unit, yaitu lebih tebal dan lebih tinggi dari dinding. Di atas kubus ini kita akan menempatkan unit kubus yang menunjukkan bagian atas menara. Seperti semua cetakan lainnya, kubus ini tidak memerlukan colliders.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena model menara terdiri dari beberapa objek, kami menjadikannya anak-anak dari objek root. </font><font style="vertical-align: inherit;">Tempatkan mereka sehingga asal lokal akar berada di dasar menara. </font><font style="vertical-align: inherit;">Berkat ini, kita dapat menempatkan menara tanpa khawatir tentang tingginya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f1/a54/335/2f1a54335d81a6682707e740107362c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara cetakan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan tautan ke cetakan ini </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan sambungkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/df1/c7e/f76df1c7e5b1c808d2ae636f7e823487.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan ke menara cetakan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menara bangunan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan menempatkan menara di tengah setiap segmen dinding. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita akan membuat menara di akhir metode </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Posisinya akan menjadi rata-rata poin kiri dan kanan segmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { … Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/559/541/487/559541487b79dd6877b4456dbdf010b1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu menara per segmen dinding. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami punya banyak menara di sepanjang dinding, tetapi orientasinya tidak berubah. </font><font style="vertical-align: inherit;">Kita perlu mengubah rotasi mereka sehingga mereka sejajar dengan dinding. </font><font style="vertical-align: inherit;">Karena kita memiliki titik dinding kanan dan kiri, kita tahu arah mana yang benar. </font><font style="vertical-align: inherit;">Kita dapat menggunakan pengetahuan ini untuk menentukan orientasi segmen dinding, dan karenanya menara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menghitung sendiri rotasi, kami cukup menetapkan </font></font><code>Transform.right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor ke </font><font style="vertical-align: inherit;">properti </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kode Unity akan mengubah rotasi objek sehingga arah lokalnya sesuai dengan vektor yang ditransmisikan.</font></font><br><br><pre> <code class="cs hljs"> Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/2c3/777/5d32c3777d5b63db90ddf9f8fbbf1dee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara selaras dengan dinding.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara kerja tugas Transform.right?</font></font></b> <div class="spoiler_text">     <code>Quaternion.FromToRotation</code>   .   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotation * Vector3.right; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { rotation = Quaternion.FromToRotation(Vector3.right, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurangi jumlah menara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu menara per segmen terlalu banyak. </font><font style="vertical-align: inherit;">Mari kita membuat penambahan menara opsional dengan menambahkan </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">boolean. </font><font style="vertical-align: inherit;">Setel ke nilai default </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam hal ini, semua menara akan hilang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addTower = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addTower) { Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tempatkan menara hanya di sudut sel. </font><font style="vertical-align: inherit;">Hasilnya, kami mendapatkan lebih sedikit menara dengan jarak yang cukup konstan di antara mereka.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … AddWallSegment(pivot, left, pivot, right, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/823/d7b/d60823d7b381eccaf5916bf2bc636061.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara hanya di sudut-sudut. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelihatannya cukup bagus, tetapi kita mungkin membutuhkan penempatan menara yang lebih sedikit. </font><font style="vertical-align: inherit;">Seperti fitur medan lainnya, kita dapat menggunakan tabel hash untuk memutuskan apakah akan meletakkan menara di sudut. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami menggunakan pusat sudut untuk sampel tabel, dan kemudian kami akan membandingkan salah satu nilai hash dengan nilai ambang batas menara.</font></font><br><br><pre> <code class="cs hljs"> HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai ambang mengacu pada </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dengan nilai 0,5, menara akan dibuat dalam setengah kasus, tetapi kita dapat membuat dinding dengan banyak menara atau tanpa menara sama sekali.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallTowerThreshold = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/40c/f0f/b5440cf0ffa4f615f2dcbf37532bbb0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara acak.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menghapus menara dari lereng </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami menempatkan menara terlepas dari bentuk medan. </font><font style="vertical-align: inherit;">Namun, di lereng menara terlihat tidak masuk akal. </font><font style="vertical-align: inherit;">Di sini dindingnya miring dan dapat memotong bagian atas menara.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24c/c5e/2dd/24cc5e2ddb97b83d14e0826bc64e3f20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara di lereng. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari kemiringan, kami akan memeriksa apakah sel sudut kanan dan kiri sama tingginya. </font><font style="vertical-align: inherit;">Hanya dalam hal ini adalah mungkin untuk menempatkan menara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation == rightCell.Elevation) { HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; } AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/1b4/fd9/7701b4fd9d0a4952fce2a9e00bbb4571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada lagi menara di dinding lereng.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menempatkan dinding dan menara di tanah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kita menghindari dinding di lereng, relief di kedua sisi dinding masih bisa memiliki ketinggian yang berbeda. </font><font style="vertical-align: inherit;">Dinding dapat berjalan di sepanjang tepian, dan sel dengan ketinggian yang sama dapat memiliki posisi vertikal yang berbeda. </font><font style="vertical-align: inherit;">Karena itu, pangkalan menara mungkin ada di udara.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4d8/b10/cd24d8b1012804af5d073c3901c874ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara di udara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan, dinding di lereng juga bisa menggantung di udara, tetapi ini tidak begitu terlihat seperti untuk menara.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ae3/d24/8b6ae3d2489f253ae1a78593af0abd6c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding ada di udara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dapat diperbaiki dengan meregangkan pangkal dinding dan menara ke tanah. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan offset Y untuk dinding </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Satu unit ke bawah sudah cukup. </font><font style="vertical-align: inherit;">Tingkatkan ketinggian menara dengan jumlah yang sama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallYOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengubahnya </font></font><code>HexMetrics.WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga ketika menentukan koordinat Y, itu memperhitungkan offset baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v + wallYOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga perlu mengubah cetakan menara, karena pangkalan sekarang akan menjadi satu unit di bawah tanah. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambah ketinggian kubus dasar sebanyak satu unit dan karenanya mengubah posisi lokal kubus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e4e/503/f2de4e50398fbae4ee296737dbe3a922.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/5d7/0eb/ecd5d70ebb620e3bae84f17aedb4a2a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding dan menara di tanah. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2>  Jembatan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kita memiliki sungai dan jalan, tetapi jalan tidak dapat menyeberangi sungai dengan cara apa pun. </font><font style="vertical-align: inherit;">Ini waktu yang tepat untuk menambahkan jembatan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan kubus skala sederhana yang akan memainkan peran jembatan cetakan. </font><font style="vertical-align: inherit;">Lebar sungai bervariasi, tetapi ada sekitar tujuh unit jarak antara pusat jalan di kedua sisi. </font><font style="vertical-align: inherit;">Oleh karena itu, kami memberikan skala perkiraan (3, 1, 7). </font><font style="vertical-align: inherit;">Tambahkan material perkotaan merah prefab dan singkirkan collider-nya. </font><font style="vertical-align: inherit;">Seperti halnya menara, letakkan kubus di dalam objek root dengan skala yang sama. </font><font style="vertical-align: inherit;">Karena itu, geometri jembatan itu sendiri tidak akan menjadi penting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan tautan ke prefab jembatan </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tetapkan prefab.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower, bridge;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/808/ac6/dc5/808ac6dc523d16d2005da48dcf4d1f65.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pabrikan jembatan yang ditugaskan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penempatan jembatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menempatkan jembatan, kita perlu metode </font></font><code>HexFeatureManager.AddBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jembatan harus terletak di antara pusat sungai dan salah satu sisi sungai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami akan mengirimkan pusat jalan yang tidak terdistorsi, jadi kami harus mengubah mereka sebelum menempatkan jembatan. </font></font><br><br><pre> <code class="cs hljs"> roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meluruskan jembatan dengan benar, kita dapat menggunakan pendekatan yang sama seperti ketika memutar menara. </font><font style="vertical-align: inherit;">Dalam hal ini, pusat jalan menentukan vektor maju jembatan. </font><font style="vertical-align: inherit;">Karena kita tetap berada di dalam sel yang sama, vektor ini pasti akan horisontal, jadi kita tidak perlu nol komponennya Y.</font></font><br><br><pre> <code class="cs hljs"> Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membangun jembatan melintasi sungai lurus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya konfigurasi sungai yang membutuhkan jembatan lurus dan melengkung. Jalan bisa melewati titik akhir, dan di zigzag jalan hanya bisa dekat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, mari cari tahu sungai lurus. Di dalam, </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator pertama </font></font><code>else if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur jalan di sekitar sungai tersebut. Karena itu, di sini kita akan menambahkan jembatan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berada di satu sisi sungai. Pusat jalan bergerak dari sungai, dan kemudian pusat sel juga bergeser. Untuk menemukan pusat jalan di sisi yang berlawanan, kita perlu memindahkan arah yang berlawanan dengan jumlah yang sama. Ini harus dilakukan sebelum mengubah pusat itu sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { … roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97c/c7f/420/97cc7f42004ba86c6cd0333af352f24b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan di atas sungai lurus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan telah muncul! </font><font style="vertical-align: inherit;">Tetapi sekarang kita memiliki satu contoh jembatan untuk setiap arah di mana sungai tidak mengalir. </font><font style="vertical-align: inherit;">Kita perlu memastikan bahwa hanya satu instance dari jembatan dihasilkan dalam sel. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan memilih satu arah relatif ke sungai dan atas dasar untuk menghasilkan jembatan. </font><font style="vertical-align: inherit;">Anda dapat memilih arah mana pun.</font></font><br><br><pre> <code class="cs hljs"> roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next()) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kita perlu menambahkan jembatan hanya ketika ada jalan di kedua sisi sungai. </font><font style="vertical-align: inherit;">Saat ini, kami sudah yakin bahwa ada jalan di sisi saat ini. </font><font style="vertical-align: inherit;">Karena itu, Anda perlu memeriksa apakah ada jalan di seberang sungai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next() &amp;&amp; ( cell.HasRoadThroughEdge(direction.Next2()) || cell.HasRoadThroughEdge(direction.Opposite()) )) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/635/a47/978/635a4797816f9f35297f67224a0ec449.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan antara jalan di kedua sisi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jembatan di atas sungai yang melengkung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan di atas sungai yang melengkung bekerja serupa, tetapi topologinya sedikit berbeda. </font><font style="vertical-align: inherit;">Kami akan menambahkan jembatan ketika kami berada di luar kurva. </font><font style="vertical-align: inherit;">Ini terjadi di blok terakhir </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ia menggunakan arah tengah untuk mengimbangi tengah jalan. </font><font style="vertical-align: inherit;">Kita perlu menggunakan offset ini dua kali dengan skala yang berbeda, jadi simpanlah ke variabel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skala perpindahan di bagian luar kurva adalah 0,25, dan di dalam </font></font><code>HexMetrics.innerToOuter * 0.7f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami menggunakannya untuk menempatkan jembatan.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/f9e/da9/612f9eda9f9e4cd31ba20dfe2db7687b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan di atas sungai yang melengkung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita perlu menghindari duplikat jembatan. </font><font style="vertical-align: inherit;">Kita bisa melakukan ini dengan menambahkan jembatan hanya dari arah tengah.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == middle) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan lagi, Anda perlu memastikan bahwa jalan ada di sisi yang berlawanan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( direction == middle &amp;&amp; cell.HasRoadThroughEdge(direction.Opposite()) ) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/33c/275/74433c2750e413c44d17139982ecff3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan antara jalan di kedua sisi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penskalaan jembatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita mendistorsi medan, jarak antara pusat jalan dan sisi berlawanan dari sungai bervariasi. </font><font style="vertical-align: inherit;">Terkadang jembatan terlalu pendek, kadang terlalu panjang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/f2c/e53/770f2ce537ab16628c799eceb6ca4ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memvariasikan jarak tetapi panjang jembatan konstan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami telah membuat jembatan dengan panjang tujuh unit, Anda dapat menskalakannya agar sesuai dengan jarak sebenarnya antara pusat jalan. </font><font style="vertical-align: inherit;">Ini berarti bahwa model jembatan cacat. </font><font style="vertical-align: inherit;">Karena jaraknya tidak terlalu bervariasi, deformasi mungkin lebih dapat diterima daripada jembatan yang tidak cocok untuk panjangnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan penskalaan yang tepat kita perlu mengetahui panjang awal prefab jembatan. </font><font style="vertical-align: inherit;">Kami akan menyimpan panjang ini dalam </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bridgeDesignLength = <span class="hljs-number"><span class="hljs-number">7f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menetapkan skala di sepanjang instance Z jembatan ke jarak antara pusat jalan, dibagi dengan panjang aslinya. </font><font style="vertical-align: inherit;">Karena akar prefab jembatan memiliki skala yang sama, jembatan akan meregang dengan benar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length = Vector3.Distance(roadCenter1, roadCenter2); instance.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, length * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / HexMetrics.bridgeDesignLength) ); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/b73/49c/21eb7349c5e7ae6d5480b2e61d19e046.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panjang jembatan yang berubah. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruksi jembatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih kubus sederhana, kita bisa menggunakan model jembatan yang lebih menarik. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat membuat jembatan melengkung kasar dengan tiga kubus bersisik dan diputar. </font><font style="vertical-align: inherit;">Tentu saja, Anda dapat membuat model 3D yang jauh lebih kompleks, termasuk bagian jalan. </font><font style="vertical-align: inherit;">Tetapi perhatikan bahwa seluruh objek akan sedikit dikompresi dan diregangkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eee/83f/3b6/eee83f3b67cf879abe3114117614af08.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/741/f7f/8a9741f7f024aa8914e29b12c1ae9d94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan melengkung dengan panjang berbeda. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benda khusus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, sel-sel kita dapat mengandung benda-benda perkotaan, pedesaan dan tanaman. Meskipun masing-masing dari mereka memiliki tiga level, semua benda cukup kecil dibandingkan dengan ukuran sel. Bagaimana jika kita membutuhkan bangunan besar, seperti kastil? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tambahkan jenis objek khusus ke medan. Benda-benda seperti itu sangat besar sehingga menempati seluruh sel. Masing-masing benda ini unik dan membutuhkan cetakan sendiri. Misalnya, kastil sederhana dapat dibuat dari satu kubus pusat ditambah empat menara sudut. Skala (6, 4, 6) untuk kubus pusat akan membuat kunci yang cukup besar, yang cocok bahkan dalam sel yang sangat cacat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9bf/0dc/7e19bf0dc5f1568bf4b21ec467ba9063.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cetakan di puri. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek khusus lainnya dapat berupa ziggurat, misalnya, dibangun dari tiga kubus yang diletakkan di atas satu sama lain. </font><font style="vertical-align: inherit;">Untuk kubus bawah, skala (8, 2.5, 8) cocok.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/7d3/291/1ad7d3291224358562b3472f528973a1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefab ziggurat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek khusus bisa berupa apa saja, belum tentu arsitektur. </font><font style="vertical-align: inherit;">Sebagai contoh, sekelompok pohon besar hingga sepuluh unit dapat menunjukkan sel diisi dengan megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bb/e91/907/1bbe91907deba70f6ab9d02cd13de795.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cetakan awal megaflora. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array untuk melacak cetakan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] special;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertama, tambahkan kastil ke array, lalu ziggurat, dan kemudian megaflora. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbc/2e3/e94/bbc2e3e949b25efc800a8f2e799490c7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kustomisasi objek khusus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat sel khusus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan indeks objek khusus, yang menentukan jenis objek khusus, jika ada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specialIndex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti objek bantuan lainnya, mari kita berikan kemampuan untuk menerima dan menetapkan nilai ini. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, sel tidak mengandung objek khusus. </font><font style="vertical-align: inherit;">Kami menyatakan ini dengan indeks 0. Tambahkan properti yang menggunakan pendekatan ini untuk menentukan apakah sel khusus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSpecial { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengedit sel, tambahkan dukungan untuk indeks objek khusus di </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini bekerja sama dengan tingkat fasilitas perkotaan, pedesaan dan pabrik.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel, activeSpecialIndex; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel, applySpecialIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplySpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applySpecialIndex = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeSpecialIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)index; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applySpecialIndex) { cell.SpecialIndex = activeSpecialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan slider ke UI untuk mengontrol objek khusus. </font><font style="vertical-align: inherit;">Karena kami memiliki tiga objek, kami menggunakan interval 0–3 dalam slider. </font><font style="vertical-align: inherit;">Nol berarti tidak adanya objek, satu - kastil, dua - ziggurat, tiga - megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2ea/9bf/ab42ea9bf68565a294f4ded5d2d7ebf0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider untuk objek khusus.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan Objek Khusus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menetapkan objek khusus ke sel. </font><font style="vertical-align: inherit;">Agar mereka muncul, kita perlu menambahkan ke </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode lain. </font><font style="vertical-align: inherit;">Ini hanya membuat sebuah instance dari objek khusus yang diinginkan dan menempatkannya di posisi yang diinginkan. </font><font style="vertical-align: inherit;">Karena nol menunjukkan tidak adanya objek, kita harus mengurangi unit dari indeks objek khusus sel sebelum mendapatkan akses ke array prefab.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita beri objek rotasi acak menggunakan tabel hash. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); HexHash hash = HexMetrics.SampleHashGrid(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat melakukan triangulasi sel, kami </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memeriksa apakah sel tersebut berisi objek khusus. </font><font style="vertical-align: inherit;">Jika demikian, maka kita memanggil metode baru kita, sama seperti </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/242/657/b692426576e292bbdc9ed0752624db51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda khusus. </font><font style="vertical-align: inherit;">Mereka jauh lebih besar dari biasanya.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena objek khusus terletak di tengah sel, mereka tidak bergabung dengan sungai, karena mereka akan menggantung di atasnya. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/92f/cc2/a5192fcc2c5718f33bafc631f60a07a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda di sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencegah objek khusus dibuat di atas sungai, kami mengubah properti </font></font><code>HexCell.SpecialIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan mengubah indeks hanya ketika tidak ada sungai di dalam sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saat menambahkan sungai, kita harus menyingkirkan semua objek khusus. </font><font style="vertical-align: inherit;">Sungai harus membasuh mereka. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur indeks objek khusus ke 0 </font><font style="vertical-align: inherit;">dalam metode </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { … hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menghindari jalan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti sungai, jalan juga buruk dengan benda-benda khusus, tetapi tidak semuanya begitu mengerikan. </font><font style="vertical-align: inherit;">Anda bahkan dapat meninggalkan jalan apa adanya. </font><font style="vertical-align: inherit;">Beberapa fasilitas mungkin kompatibel dengan jalan, sementara yang lain mungkin tidak. </font><font style="vertical-align: inherit;">Oleh karena itu, Anda dapat membuatnya bergantung pada objek. </font><font style="vertical-align: inherit;">Tapi kami akan membuatnya lebih mudah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/ebf/939/b3bebf9399ed016e8d79a4c1ee53ace8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda di jalan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, biarkan benda-benda khusus mengalahkan jalan. </font><font style="vertical-align: inherit;">Karena itu, ketika mengubah indeks objek khusus, kami juga akan menghapus semua jalan dari sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RemoveRoads(); RefreshSelfOnly(); } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika kita menghapus objek tertentu?</font></font></b> <div class="spoiler_text">      0,   ,       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, ini berarti bahwa saat menambahkan jalan, kami harus melakukan pemeriksaan tambahan. </font><font style="vertical-align: inherit;">Kami akan menambahkan jalan hanya jika tidak ada sel yang merupakan sel dengan objek khusus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; !IsSpecial &amp;&amp; !GetNeighbor(direction).IsSpecial &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari benda lain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek khusus tidak dapat dicampur dengan jenis objek lain. </font><font style="vertical-align: inherit;">Jika mereka tumpang tindih, maka itu akan terlihat berantakan. </font><font style="vertical-align: inherit;">Mungkin juga tergantung pada objek tertentu, tetapi kami akan menggunakan pendekatan yang sama.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/7f1/8fc/03b7f18fc9f9d7543bdb0d9c24a074e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek yang bersinggungan dengan objek lain. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, kita akan menekan benda yang lebih kecil, seolah-olah benda itu berada di bawah air. </font><font style="vertical-align: inherit;">Kali ini kita akan check-in </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga memiliki masalah dengan air. </font><font style="vertical-align: inherit;">Akankah fitur khusus bertahan selama banjir? </font><font style="vertical-align: inherit;">Karena kita menghancurkan objek kecil di sel yang terendam, mari kita lakukan hal yang sama dengan objek khusus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/479/e79/8d9479e79cb0555c81f562dc32937552.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda di dalam air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan melakukan pemeriksaan banjir yang sama untuk objek khusus dan biasa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kedua operator </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang memeriksa apakah sel di bawah air, kami dapat mentransfer tes dan melakukan hanya sekali.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk percobaan, sejumlah objek seperti itu akan cukup bagi kita. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425463/">https://habr.com/ru/post/id425463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425449/index.html">Memperbarui pendekatan untuk iklan kontekstual: Yandex.Direct Turbo Pages</a></li>
<li><a href="../id425453/index.html">Dari Space Invaders ke Half Life 2: The Story of Game Dzdoks</a></li>
<li><a href="../id425457/index.html">Dua puluh teka-teki (dalam geometri yang gila dan menakjubkan)</a></li>
<li><a href="../id425459/index.html">Memutakhirkan ke Windows 1809 (kadang-kadang) menghancurkan semua file dalam profil</a></li>
<li><a href="../id425461/index.html">Devops and Security: Wawancara dengan Seth Wargo dan Liz Rice</a></li>
<li><a href="../id425465/index.html">Bagaimana seorang desainer dapat memperoleh lebih banyak, alat yang ideal untuk bekerja dan mencari ide</a></li>
<li><a href="../id425467/index.html">Mesin Renault D4F> B4D (alias SCe). Perubahan generasi. Tampilan pengendara</a></li>
<li><a href="../id425469/index.html">Penulis Python tidak lagi memimpin pengembangan. Apakah ini akan membuat bahasa menjadi lebih baik atau lebih buruk?</a></li>
<li><a href="../id425471/index.html">Bekerja dengan gambar dengan Python</a></li>
<li><a href="../id425473/index.html">Konferensi tentang Python dan tentang komunikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>