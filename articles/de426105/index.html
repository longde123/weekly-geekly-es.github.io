<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üí± üôå Mein Fang in einer Woche üéå üßîüèΩ üñáÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je mehr ein Entwickler in einem Team an einer Anwendung arbeitet und je besser er seinen Code kennt, desto h√§ufiger besch√§ftigt er sich mit dem Korrek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mein Fang in einer Woche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426105/"><p>  Je mehr ein Entwickler in einem Team an einer Anwendung arbeitet und je besser er seinen Code kennt, desto h√§ufiger besch√§ftigt er sich mit dem Korrekturlesen der Arbeit seiner Kameraden.  Heute werde ich zeigen, was in einer Woche in Code gefangen werden kann, der von sehr guten Entwicklern geschrieben wurde.  Unter dem Schnitt befindet sich eine Sammlung lebendiger Artefakte unserer Kreativit√§t (und ein wenig meiner Gedanken). </p><a name="habracut"></a><br><h3 id="komparatory">  Komparatoren </h3><br><p>  Es gibt einen Code: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; } <span class="hljs-comment"><span class="hljs-comment">// another class List&lt;Long&gt; readSortedIds(List&lt;Dto&gt; list) { List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(new Comparator&lt;Long&gt;() { public int compare(Long o1, Long o2) { if (o1 &lt; o2) return -1; if (o1 &gt; o2) return 1; return 0; } }); return ids; }</span></span></code> </pre> <br><p>  Jemand bemerkt, dass Sie den Stream direkt sortieren k√∂nnen, aber ich m√∂chte Ihre Aufmerksamkeit auf den Komparator lenken.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zur <code>Comparator::compare</code> Methode hei√üt es in Englisch in Wei√ü: </p><br><blockquote>  Vergleicht die beiden Argumente f√ºr die Reihenfolge.  Gibt eine negative Ganzzahl, Null oder eine positive Ganzzahl zur√ºck, da das erste Argument kleiner, gleich oder gr√∂√üer als das zweite ist. </blockquote><p>  Dieses Verhalten ist in unserem Code implementiert.  Was ist los  Tatsache ist, dass die Entwickler von Java sehr weitsichtig vorgeschlagen haben, dass viele einen solchen Komparator ben√∂tigen w√ºrden, und ihn f√ºr uns gemacht haben.  Wir k√∂nnen es verwenden, indem wir unseren Code vereinfachen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Long&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSortedIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(Comparator.naturalOrder()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids; }</code> </pre> <br><p>  Ebenso dieser Code </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;Dto&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto o1, Dto o2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &lt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &gt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  mit einem Handgriff verwandelt sich in </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(Comparator.comparing(Dto::getId)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  √úbrigens wird es in der neuen Version von ‚ÄûIdeas‚Äú m√∂glich sein, Folgendes zu tun: </p><br><div class="spoiler">  <b class="spoiler_title">Zauberei</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/b_/om/ki/b_omkixybpa-jvxblirsruyvglo.gif"></p></div></div><br><h3 id="zloupotreblenie-optional-ami">  Optionaler Missbrauch </h3><br><p>  Wahrscheinlich hat jeder von uns so etwas gesehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ Optional&lt;Long&gt; optional = Optional.ofNullable(groupId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional.isPresent()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(optional.get()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); }</code> </pre> <br><p>  Oft wird <code>Optional</code> verwendet, um das Vorhandensein / Fehlen eines Werts zu √ºberpr√ºfen, obwohl dieser nicht daf√ºr erstellt wurde.  Missbrauch binden und einfacher schreiben: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(groupId); }</code> </pre> <br><p>  Denken Sie daran, dass es bei <code>Optional</code> nicht um das Methodenargument oder -feld geht, sondern um den R√ºckgabewert.  Aus diesem Grund wurde es ohne Serialisierungsunterst√ºtzung entwickelt. </p><br><h3 id="void-metody-menyayuschie-sostoyanie-argumenta">  void Methoden, die den Status eines Arguments √§ndern </h3><br><p>  Stellen Sie sich eine Methode wie diese vor: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); repository.save(contract); } }</code> </pre> <br><p>  Sicher haben Sie schon oft etwas √Ñhnliches gesehen und geschrieben.  Hier gef√§llt mir nicht, dass die Methode den Status der Entit√§t √§ndert, ihn aber nicht zur√ºckgibt.  Wie verhalten sich √§hnliche Framework-Methoden?  Beispielsweise geben <code>org.springframework.data.jpa.repository.JpaRepository::save</code> und <code>javax.persistence.EntityManager::merge</code> einen Wert zur√ºck.  Angenommen, nach der Aktualisierung eines Vertrags m√ºssen wir ihn au√üerhalb der <code>update</code> abrufen.  Es stellt sich so etwas heraus: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ updateService.updateContractById(contractId, contractDto); Contract contract = repositoroty.findOne(contractId); doSmth(contract); }</code> </pre> <br><p>  Ja, wir k√∂nnten die Entit√§t direkt an die <code>UpdateService::updateContract</code> Methode √ºbergeben, indem wir ihre Signatur √§ndern. Es ist jedoch besser, dies folgenderma√üen zu tun: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Contract </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(contract); } } <span class="hljs-comment"><span class="hljs-comment">// @Transactional public void anotherMethod(Long contractId, Dto contractDto) { Contract contract = updateService.updateContractById(contractId, contractDto); doSmth(contract); }</span></span></code> </pre> <br><p>  Dies hilft einerseits, den Code zu vereinfachen, andererseits hilft es beim Testen.  Im Allgemeinen ist das Testen von <code>void</code> Methoden eine √§u√üerst trostlose Aufgabe, die ich anhand des gleichen Beispiels zeigen werde: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); updater.updateContractById(contractId, contractDto); <span class="hljs-comment"><span class="hljs-comment">//void // ,       dto? -  : ArgumentCaptor&lt;Contract&gt; captor = ArgumentCaptor.forClass(Contract.class); verify(repository).save(captor.capture()); Contract updated = captor.getValue(); assertEquals(dto.getValue(), updated.getValue()); } }</span></span></code> </pre> <br><p>  Aber alles kann einfacher gemacht werden, wenn die Methode einen Wert zur√ºckgibt: </p><br><div class="spoiler">  <b class="spoiler_title">Stellen Sie sicher</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); Contract updated = updater.updateContractById(contractId, contractDto); assertEquals(dto.getValue(), updated.getValue()); } }</code> </pre> </div></div><br><p>  Auf einen Schlag wird nicht nur der Aufruf von <code>ContractRepository::save</code> √ºberpr√ºft, sondern auch die Richtigkeit des gespeicherten Werts. </p><br><h3 id="velosipedostroenie">  Fahrradbau </h3><br><p>  √ñffnen Sie zum Spa√ü Ihr Projekt und suchen Sie danach: </p><br><pre> <code class="java hljs">lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)</code> </pre> <br><p>  Mit hoher Wahrscheinlichkeit sieht der gesamte Ausdruck ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="java hljs">String fileExtension = fileName.subString(fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>));</code> </pre> <br><p>  Davor kann kein statischer Analysator warnen, es geht um das neu erfundene Fahrrad.  Meine Herren, wenn Sie ein bestimmtes Problem im Zusammenhang mit dem Dateinamen / der Dateierweiterung oder dem Pfad dazu l√∂sen, genau wie beim Lesen / Schreiben / Kopieren, dann wurde in 9 von 10 F√§llen die Aufgabe bereits vor Ihnen gel√∂st.  Binden Sie sich daher an die Fahrradkonstruktion an und nehmen Sie fertige (und bew√§hrte) L√∂sungen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FilenameUtils; <span class="hljs-comment"><span class="hljs-comment">//... String fileExtension = FilenameUtils.getExtension(fileName);</span></span></code> </pre> <br><p>  In diesem Fall sparen Sie Zeit, die f√ºr die √úberpr√ºfung der Eignung des Fahrrads aufgewendet wird, und erhalten erweiterte Funktionen (siehe Dokumentation <code>FilenameUtils::getExtension</code> ). </p><br><p>  Oder hier ist ein Code, der den Inhalt einer Datei in eine andere kopiert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileChannel sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src).getChannel(); FileChannel dc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)).getChannel(); sc.transferTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, sc.size(), dc); dc.close(); sc.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  Welche Umst√§nde k√∂nnen uns verhindern?  Tausende von ihnen: </p><br><ul><li>  Das Ziel kann ein Ordner sein, √ºberhaupt keine Datei </li><li>  Die Quelle kann ein Ordner sein </li><li>  Quelle und Ziel k√∂nnen dieselbe Datei sein </li><li>  Ziel kann nicht erstellt werden </li><li>  usw. und so weiter. </li></ul><br><p>  Das Traurige ist, dass wir mit der Selbstaufnahme alles lernen, was wir bereits beim Kopieren gelernt haben. <br>  Wenn wir es mit Bedacht tun </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FileUtils; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileUtils.copyFile(src, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  Dann wird ein Teil der √úberpr√ºfungen vor dem Beginn des Kopierens durchgef√ºhrt, und eine m√∂gliche Ausnahme ist informativer (siehe die Quellen von <code>FileUtils::copyFile</code> ). </p><br><h3 id="prenebrezhenie-nullablenotnull">  Vernachl√§ssigung von @ Nullable / @ NotNull </h3><br><p>  Angenommen, wir haben eine Entit√§t: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String email; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String petName; }</code> </pre> <br><p>  In unserem Fall wird die <code>email</code> Spalte in der Tabelle im Gegensatz zu petName als <code>not null</code> beschrieben.  Das hei√üt, wir k√∂nnen die Felder mit den entsprechenden Anmerkungen markieren: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Nullable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.NotNull; <span class="hljs-comment"><span class="hljs-comment">//... @Column @NotNull private String email; @Column @Nullable private String petName;</span></span></code> </pre> <br><p>  Auf den ersten Blick sieht dies f√ºr den Entwickler wie ein Hinweis aus, und das ist es auch.  Gleichzeitig sind diese Anmerkungen ein viel leistungsf√§higeres Werkzeug als ein normales Etikett. </p><br><p>  Entwicklungsumgebungen verstehen sie beispielsweise, und wenn wir nach dem Hinzuf√ºgen von Anmerkungen versuchen, dies folgenderma√üen zu tun: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkIfPetBelongsToUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user, String lostPetName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.getPetName().equals(lostPetName); }</code> </pre> <br><p>  dann warnt uns die "Idee" mit dieser Nachricht vor der Gefahr: </p><br><blockquote>  Der Methodenaufruf 'equals' kann 'NullPointerException' erzeugen. </blockquote><p>  Im Code </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasEmail = user.getEmail() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasEmail; }</code> </pre> <br><p>  Es wird eine weitere Warnung geben: </p><br><blockquote>  Bedingung 'user.getEmail () == null' ist immer 'false' </blockquote><p>  Dies hilft dem eingebauten Zensor, m√∂gliche Fehler zu finden und die Codeausf√ºhrung besser zu verstehen.  Aus dem gleichen Grund sind Anmerkungen n√ºtzlich, um Methoden zu platzieren, die einen Wert und ihre Argumente zur√ºckgeben. </p><br><p>  Wenn meine Argumente nicht schl√ºssig erscheinen, schauen Sie sich den Quellcode eines ernsthaften Projekts an, denselben "Fr√ºhling" - sie sind mit Anmerkungen wie ein Weihnachtsbaum aufgeh√§ngt.  Und das ist keine Laune, sondern eine ernsthafte Notwendigkeit. </p><br><p>  Der einzige Nachteil scheint mir die Notwendigkeit zu sein, die Anmerkungen in einem modernen Zustand st√§ndig aufrechtzuerhalten.  Wenn Sie es sich ansehen, ist es eher ein Segen, denn wenn wir immer wieder zum Code zur√ºckkehren, verstehen wir es immer besser. </p><br><h3 id="nevnimatelnost">  Nachl√§ssigkeit </h3><br><p>  Es gibt keine Fehler in diesem Code, aber es gibt einen √úberschuss: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(id -&gt; { List&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toList()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids.contains(id); }) .collect(toList());</code> </pre> <br><p>  Es ist nicht klar, warum eine neue Liste von Schl√ºsseln erstellt werden soll, mit denen die Suche durchgef√ºhrt wird, wenn sich diese beim Durchlaufen des Streams nicht √§ndert.  Es ist gut, dass es nur 5 Elemente gibt, aber was ist, wenn es 100500 davon gibt?  Und wenn die <code>getDtos</code> Methode 100500 Objekte zur√ºckgibt (in der Liste!), Welche Leistung hat dieser Code dann?  Keine, also ist es besser so: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Set&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toSet()); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(ids::contains) .collect(toList());</code> </pre> <br><p>  Auch hier: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ notReplacedParams.stream() .filter(param -&gt; paramMap.keySet().contains(param)) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  Offensichtlich ist der vom Ausdruck <code>inParameterMap.keySet()</code> Wert unver√§ndert, sodass er in eine Variable verschoben werden kann: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;String&gt; params = paramMap.keySet(); notReplacedParams.stream() .filter(params::contains) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  Solche Abschnitte k√∂nnen √ºbrigens mit der Pr√ºfung 'Objektzuordnung in einer Schleife' berechnet werden. </p><br><h3 id="kogda-staticheskiy-analiz-bessilen">  Wenn die statische Analyse machtlos ist </h3><br><p>  Das achte Java ist l√§ngst ausgestorben, aber wir alle lieben Streams.  Einige von uns lieben sie so sehr, dass wir sie √ºberall verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;EmailAdresses&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserEmails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Stream&lt;UserEntity&gt; users = getUsers().stream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (users.count() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.empty(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users.findAny(); }</code> </pre> <br><p>  Wie Sie wissen, ist der Stream frisch, bevor die Beendigung aufgerufen wird. <code>IllegalStateException</code> Sie also erneut auf die <code>users</code> in unserem Code zugreifen, wird eine <code>IllegalStateException</code> . </p><br><p>  Statische Analyseger√§te wissen noch nicht, wie sie solche Fehler melden sollen. Daher liegt die Verantwortung f√ºr das rechtzeitige Erfassen beim Pr√ºfer. </p><br><p>  Es scheint mir, dass das Verwenden von Variablen vom Typ <code>Stream</code> sowie das √úbergeben von Variablen als Argumente und das Zur√ºckkehren von Methoden wie das Gehen in einem Minenfeld ist.  Vielleicht Gl√ºck, vielleicht auch nicht.  Daher eine einfache Regel: Jedes Auftreten von <code>Stream&lt;T&gt;</code> im Code sollte √ºberpr√ºft werden (aber auf gute Weise sofort ausgeschnitten werden). </p><br><h3 id="prostye-tipy">  Einfache Typen </h3><br><p>  Viele sind sich sicher, dass es bei <code>boolean</code> , <code>int</code> usw. nur um Leistung geht.  Dies ist teilweise richtig, aber au√üerdem ist der einfache Typ standardm√§√üig <code>not null</code> .  Wenn sich ein Ganzzahlfeld einer Entit√§t auf eine Spalte bezieht, die in der Tabelle als <code>not null</code> deklariert ist, ist es sinnvoll, <code>int</code> anstelle von <code>Integer</code> .  Dies ist eine Art Kombination - und der Speicherverbrauch ist geringer, und der Code wird aufgrund der unn√∂tigen √úberpr√ºfung auf <code>null</code> vereinfacht. </p><br><p>  Das ist alles  Denken Sie daran, dass all das nicht die ultimative Wahrheit ist. Denken Sie mit Ihrem eigenen Kopf und gehen Sie die Anwendung von Ratschl√§gen sinnvoll an. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426105/">https://habr.com/ru/post/de426105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426095/index.html">Offenes Webinar ‚ÄûWie man nicht in Python schreibt‚Äú</a></li>
<li><a href="../de426097/index.html">Arduino Projekt "RoboCar4W Robot Machine"</a></li>
<li><a href="../de426099/index.html">Typegramm Nachrichten</a></li>
<li><a href="../de426101/index.html">Datenintegrit√§t in der Microservice-Architektur - wie Sie dies ohne verteilte Transaktionen und enge Konnektivit√§t sicherstellen k√∂nnen</a></li>
<li><a href="../de426103/index.html">Webinar ‚ÄûBrauchen Sie Kubernetes?‚Äú 15. Oktober um 19:00 Uhr</a></li>
<li><a href="../de426111/index.html">Google wird weiterhin einen zensierten Suchdienst in China starten</a></li>
<li><a href="../de426113/index.html">Google News und Leo Tolstoy: Visualisierung von Vektordarstellungen von W√∂rtern mit t-SNE</a></li>
<li><a href="../de426115/index.html">Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform von Quake Champions</a></li>
<li><a href="../de426117/index.html">Der B√ºrgerbeauftragte schl√§gt vor, Anzeigen mit potenziell gef√§hrlichen Babyprodukten zu blockieren</a></li>
<li><a href="../de426119/index.html">Altert√ºmer: Cryptonomicon Iron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>