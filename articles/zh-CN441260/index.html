<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧‍👦 🔑 🖖🏽 神经网络图形如何提供帮助 💛 👌🏽 💮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1943年，美国神经心理学家McCallock和Pitts开发了神经网络的计算机模型，并在1958年第一个可工作的单层网络识别了一些字母。 现在，神经网络只是不被用于：预测汇率，诊断疾病，自动驾驶以及在计算机游戏中建立图形。 快讲最后一句话。 

 Evgeni Tumanov是NVIDIA的深度学...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神经网络图形如何提供帮助</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  1943年，美国神经心理学家McCallock和Pitts开发了神经网络的计算机模型，并在1958年第<strong>一个可工作</strong>的单层网络识别了一些字母。 现在，神经网络只是不被用于：预测汇率，诊断疾病，自动驾驶以及在计算机游戏中建立图形。 快讲最后一句话。 <br><br>  <strong>Evgeni Tumanov</strong>是<strong>NVIDIA</strong>的深度学习工程师。 根据他在HighLoad ++大会上的讲话结果，我们准备了一个有关在图形中使用机器学习和深度学习的故事。 机器学习并不以NLP，计算机视觉，推荐系统和搜索任务结尾。 即使您对这方面不是很熟悉，也可以应用您所在领域或行业中的最佳实践。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 故事将分为三个部分。 我们将回顾图中借助机器学习解决的任务，得出主要思想，并描述在特定任务（尤其<b>是云</b>的<b>渲染）中</b>应用此思想的情况。 <a name="habracut"></a><br><br><h2> 有监督的DL / ML图形学或图形教师培训 </h2><br> 让我们分析两组任务。 首先，我们简要地表示它们。 <br><br>  <strong>真实世界或渲染引擎</strong> ： <br><br><ul><li> 创作出逼真的动画：运动，面部动画。 </li><li> 对渲染的图像进行后处理：超级采样，抗锯齿。 </li><li> 慢动作：帧插值。 </li><li> 材料的产生。 </li></ul><br> 现在通常将第二组任务称为“ <strong>重型算法</strong> ”。 我们包括渲染复杂对象（例如云）和<strong>物理模拟</strong> （水，烟）的任务。 <br><br> 我们的目标是了解两组之间的根本区别。 让我们更详细地考虑任务。 <br><br><h3> 创建逼真的动画：运动，面部动画 <br></h3><br> 在过去的几年中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现了</a>许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ，研究人员在其中提供了产生精美动画的新方法。 使用艺术家的作品非常昂贵，用一种算法代替它们对每个人都是非常有益的。 一年前，我们在NVIDIA的一个项目中，我们从事游戏人物角色的面部动画处理：将英雄的脸与语音轨迹同步。 我们尝试“恢复”面部，以使面部上的每个点都移动，尤其是嘴唇上方，因为这是动画中最困难的时刻。 手动的艺术家要花很长时间才能做到这一点。 解决此问题并为其创建<strong>数据集</strong>的选项有哪些？ <br><br> 第一种选择是<strong>识别元音：嘴巴在元音上张开，嘴巴在辅音上张开</strong> 。 这是一个简单的算法，但是太简单了。 在游戏中，我们想要更高的质量。 第二种选择是<strong>让人们阅读不同的文本并写下他们的脸，然后将他们发音的字母与面部表情进行比较。</strong> 这是一个好主意，我们在与Remedy Entertainment的联合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目中</a>做到了。 唯一的区别是，在游戏中我们不显示视频，而是显示点的3D模型。 要组装数据集，您需要了解面部上的特定点如何移动。 我们带动了演员，要求他们阅读具有不同语调的文本，以不同的角度用非常好的相机拍摄它们，然后在每个帧上恢复人脸的3D模型，并通过声音预测这些点在人脸上的位置。 <br><br><h3> 渲染图像后处理：超级采样，抗锯齿 <br></h3><br> 考虑一个特定游戏的情况：我们有一个引擎，可以生成不同分辨率的图像。 我们要以1000×500像素的分辨率渲染图像，并向播放器显示2000×1000-这会更漂亮。 如何为该任务组装数据集？ <br><br> 首先以高分辨率渲染图像，然后降低质量，然后尝试训练系统将图像从低分辨率转换为高分辨率。 <br><br><h3> 慢动作：帧插值 <br></h3><br> 我们有一个视频，我们希望网络在中间添加帧-插值帧。 这个想法很明显-拍摄具有大量帧的真实视频，删除中间帧，并尝试预测网络删除了什么。 <br><br><h3> 材料产生 <br></h3><br> 我们不会过多地讨论材料的产生。 其本质是，例如，我们以一块木材在多个照明角度进行照明，然后从其他角度对视图进行插值。 <br><br> 我们研究了第一组问题。 第二个根本不同。 稍后，我们将讨论诸如云之类的复杂对象的渲染，但是现在我们将处理物理模拟。 <br><br><h3> 水和烟的物理模拟 <br></h3><br> 想象一下一个池，其中有移动的固体对象。 我们要预测流体颗粒的运动。 在时间<strong>t</strong>池中有粒子，并且在时间<strong>t +Δt处</strong>我们想要获得它们的位置。 对于每个粒子，我们称为神经网络，并获得下一帧的答案。 <br><br> 为了解决该问题， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们</a>使用<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Navier-Stokes方程</a></strong> ，该<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方程</a></strong>描述了流体的运动。 对于合理的，物理上正确的水模拟，我们将必须求解方程或近似方程。 这可以通过计算方式完成，在过去的50年中已经发明了许多方法：SPH，FLIP或基于位置的流体算法。 <br><br><h3> 第一组任务与第二组任务之间的区别 <br></h3><br> 在第一组中，算法的老师是以上内容：来自现实生活的记录（例如对于个人），或者来自引擎的内容（例如，渲染图片）。 在第二组问题中，我们使用计算数学方法。 从这个主题部门开始，一个想法就产生了。 <br><br><h2> 主要思想 <br></h2><br> 我们有一个复杂的计算任务，用经典的计算机大学方法很难解决。 为了解决它并加速甚至可能损失一点质量，我们需要： <br><br><blockquote><ul><li> 在代码持续时间最长的任务中找到最耗时的位置； </li><li> 看看这条线产生了什么； </li><li> 尝试使用神经网络或任何其他机器学习算法来预测直线的结果。 </li></ul></blockquote><br> 这是一种通用方法，主要思想是关于如何找到机器学习应用程序的秘诀。 您应该怎么做才能使这个想法有用？ 没有确切的答案-使用创造力，看看您的作品并找到它。 我会做图形，并且对其他领域不太熟悉，但是我可以想象在学术环境中（物理，化学，机器人技术）您肯定可以找到应用程序。 如果您在工作场所中解决了复杂的物理方程式，那么您可能还会发现该想法的应用。 为了清楚起见，请考虑一个具体情况。 <br><br><h2> 云渲染任务 <br></h2><br> 我们六个月前在NVIDIA参与了这个项目：任务是绘制物理上正确的云，该云表示为空间中液滴的密度。 <br><br><blockquote> 云是物理上复杂的对象，是无法建模为固体对象的液滴的悬浮液。 </blockquote><br> 不可能在云上加上纹理并进行渲染，因为水滴很难在3d空间中几何定位并且本身是复杂的：水滴实际上不吸收颜色，而是以不同的方式在各个方向上各向异性地反射颜色。 <br><br> 如果您看着一束阳光照耀的水滴，并且眼睛和水滴上的阳光矢量是平行的，那么将会观察到一个很大的光强度峰值。 这解释了每个人都已经看到的物理现象：在晴朗的天气中，云的边界之一非常明亮，几乎是白色的。 我们正在看云的边界，从该边界到太阳的视线和向量几乎平行。 <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br> 云是物理上复杂的对象，通过经典算法进行渲染需要大量时间。 稍后我们将讨论经典算法。 根据参数，该过程可能需要数小时甚至数天。 想象一下您是一名艺术家，并绘制了一部具有特殊效果的电影。 您有一个复杂的场景，要使用不同的照明。 我们绘制了一个云拓扑-我不喜欢它，您想重绘它并在那里得到答案。 尽快从一个参数更改中获取答案很重要。 这是一个问题。 因此，让我们尝试加快此过程。 <br><br><h3> 经典解决方案 <br></h3><br> 要解决该问题，您需要解决这个复杂的方程式。 <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br> 该方程式很苛刻，但让我们了解其物理意义。 考虑一束被云刺穿的云刺穿的光束。 光线如何朝这个方向进入相机？ 首先，光可以到达光线从云中射出的位置，然后沿着光线在云中传播。 <br><br> 对于“沿方向传播”的第二种方法，该方程式是积分项。 其物理意义如下。 <br><br> 考虑射线上云内部的部分-从入口点到出口点。 精确地在该段上进行积分，并且针对该段上的每个点，我们考虑所谓的<strong>间接光能L（x，ω）</strong> -积分I <sub>1</sub>的含义-该点上的间接照明。 出现这种现象的原因是，水滴以不同的方式反射阳光。 因此，来自周围液滴的大量介导的射线就此成为现实。  I <sub>1</sub>是围绕射线点的球面上的积分。 在经典算法中，使用<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">蒙特卡洛</a></strong>方法对其进行计数。 <br><br> 经典算法。 <br><br><ul><li> 从像素渲染图片，并产生从相机中心到像素再到其他像素的光线。 </li><li> 我们将光束与云相交，找到入口和出口点。 </li><li> 我们考虑方程式的最后一项：越过，与太阳连接。 </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重要样本</a></strong>入门 </li></ul><br> 我们将不分析如何考虑蒙特卡洛估计I <sub>1</sub> ，因为它很困难而且不是那么重要。 可以说这是整个算法中最长，最困难的部分。 <br><br><h3> 我们连接神经网络 <br></h3><br> 从经典算法的主要思想和描述出发，有一个关于如何将神经网络应用于此任务的方法。 最难的是计算蒙特卡洛分数。 它给出的数字意味着某个点上的间接照明，而这正是我们想要预测的。 <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br> 我们已经决定了出口，现在我们将了解入口-从该信息将清楚知道该点的间接光的大小。 这是从围绕该点的许多水滴反射的光。 点周围的密度拓扑，到光源的方向和到摄像机的方向会严重影响光拓扑。 <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br> 为了构造神经网络的入口，我们描述了局部密度。 有很多方法可以做到这一点，但我们的重点是《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度散射：利用辐射度预测神经网络渲染大气云》，Kallwcit等。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2017年</a> ，许多想法都来自那里。 <br><br> 简而言之，围绕点的局部密度表示方法如下所示。 <br><br><ul><li>  <strong>修正一个相当小的常数</strong> 。 让它成为云中的平均自由路径。 <br></li><li>  <strong>围绕我们的线段上的一个点绘制一个固定大小的体积矩形网格</strong> ，例如5 * 5 * 9。 这个立方体的中心将是我们的观点。 网格间距是一个小的固定常数。 在网格节点，我们将测量云的密度。 </li><li>  <strong>让我们将常数增加2倍</strong> ，绘制更大的网格，然后执行相同操作-测量网格节点处的密度。 </li><li>  <strong>重复上一步</strong> 。 我们这样做了10次，在此过程之后，我们得到了10个网格-10个张量，每个张量都存储了云密度，并且每个张量都覆盖了该点周围越来越大的邻域。 </li></ul><br> 这种方法为我们提供了一个小区域的最详细的说明-越接近该点，说明就越详细。 决定网络的输出和输入后，仍然需要了解如何训练它。 <br><br><h3> 培训课程 <br></h3><br> 我们将生成100个具有不同拓扑的不同云。 我们将使用经典算法简单地渲染它们，写下该算法在执行蒙特卡洛积分的那一行中收到的内容，并写下与该点相对应的属性。 这样我们就得到了一个可以学习的数据集。 <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3> 教什么，或网络架构 <br></h3><br> 这项任务的网络体系结构不是最关键的时刻，如果您什么都不懂-不用担心-这不是我想传达的最重要的内容。 我们使用以下架构：每个点都有10个张量，每个张量都是在越来越大的网格上计算的。 每个张量都落入相应的块中。 <br><br><ul><li> 首先进入第一个常规的<strong>完全连接层</strong> 。 </li><li> 退出第一个完全连接的层之后，在没有激活的第二个完全连接的层中。 </li></ul><br> 没有激活的完全连接的层只是一个矩阵的乘积。 对于乘以矩阵的结果，我们将前一个<strong>残差块</strong>的输出相加，然后才应用激活。 <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br> 我们取一个点，计算每个网格上的值，将获得的张量放在相应的残差块中-然后可以进行<strong>神经网络的推断</strong> - <strong>网络的</strong>生产模式。 我们这样做了，并确保我们得到了云的图片。 <br><br><h3> 结果 <br></h3><br> 第一个观察-我们得到了想要的：与Monte Carlo估计相比，神经网络调用的运行速度更快，这已经很好。 <br><br> 但是，对训练结果还有另一种观察-样本数量趋同。 你在说什么 <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br> 渲染图片时，我们将其切成小块-像素正方形，例如16 * 16。 考虑一个不失一般性的图像块。 渲染此图块时，对于相机中的每个像素，我们都会释放大量与一个像素相对应的光线，并向光线中添加一点噪点，以使它们略有不同。 这些射线称为<strong>抗锯齿</strong> ，是为了减少最终图像中的噪点而发明的。 <br><br><ul><li> 我们为每个像素释放一些抗锯齿射线。 </li><li> 在摄像机发出的光束的内部，在云中的某个片段上，我们计算<em>n</em>个要进行蒙特卡洛评估或为它们调用网络的点样本。 </li></ul><br> 仍然存在与光源连接相对应的样本。 当我们将点与光源（例如与太阳）连接时，它们会出现。 这很容易做到，因为太阳是彼此平行地落在地球上的光线。 例如，作为光源的天空要复杂得多，因为它显示为无限远的球体，在方向上具有颜色功能。 如果矢量垂直垂直看向天空，则颜色为蓝色。 亮度越低。 在球体的底部通常是模仿地球的中性色：绿色，棕色。 <br><br> 当我们将一个点与天空连接起来以了解有多少光入射时，我们总是会释放一些光线以得到收敛于真相的答案。 我们释放不止一条射线以获得更好的等级。 因此，整个<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管道渲染</a></strong>需要大量样本。 <br><br> 当我们训练神经网络时，我们注意到它学习了更多的平均解。 如果我们固定样本数，我们将看到经典算法收敛到图片列的左行，而网络则向右学习。 这并不意味着原始方法不好-我们收敛得更快。 当我们增加样本数量时，原始方法将越来越接近我们得到的结果。 <br><br> 我们想要得到的主要结果是渲染速度的提高。 对于具有特定分辨率和样本参数的特定云，我们看到通过网络和经典方法获得的图片几乎完全相同，但是获得正确图片的速度要快800倍。 <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2> 实作 <br></h2><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Blender</a></strong>有一个用于3D建模的开源程序，它实现了经典算法。 我们自己并未编写算法，而是使用了该程序：我们在Blender中进行了培训，写下了算法所需的一切。 该程序还完成了生产：我们在<strong>TensorFlow中</strong>训练了网络，使用TensorRT将其转移到C ++，并且由于TensorRT网络的代码是开放的，因此我们已经将TensorRT网络集成到Blender中。 <br><br> 由于我们为Blender完成了所有工作，因此我们的解决方案具有程序的所有功能：我们可以渲染任何类型的场景和大量的云。 解决方案中的云是通过创建一个多维数据集来设置的，在该多维数据集中，我们以特定的方式确定3D程序的密度函数。 我们优化了此过程-缓存密度。 如果用户想在场景的不同设置的堆上绘制相同的云：在不同的光照条件下，舞台上有不同的对象，那么他就不需要不断地重新计算云的密度。 发生了什么事，您可以观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> 。 <br><br> 总而言之，我再次重复我要传达的主要思想： <em>如果您在长时间的工作中辛苦地将某些东西视为某种特定的计算算法，而这并不适合您-在代码中找到最困难的地方，将其替换为神经网络，然后也许这会对您有所帮助。</em> <br><br><blockquote> 神经网络和人工智能是我们将在4月的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saint HighLoad ++ 2019上</a>讨论的新主题之一。 我们已经收到了有关此主题的多个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用程序</a> ，如果您有很好的经验（不一定是神经网络方面的经验），请在<strong>3月1日</strong>之前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交报告申请</a> 。 我们很高兴在我们的演讲嘉宾中见到您。 <br><br> 要了解程序的形成方式和接受哪些报告，请订阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新闻通讯</a> 。 在其中，我们仅发布报告，文章摘要和新视频的主题集合。 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441260/">https://habr.com/ru/post/zh-CN441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441248/index.html">俄罗斯在全球SSL排名中排名第9位，领先于中国，丹麦和瑞士</a></li>
<li><a href="../zh-CN441250/index.html">快速入门：Go + Apache Kafka + Redis</a></li>
<li><a href="../zh-CN441252/index.html">“口交文章”：科学家处理了109个小时的口交，以开发出吸引成员的AI</a></li>
<li><a href="../zh-CN441254/index.html">研讨会“为什么我们要与Kubernetes保持联系以及我们从中获得什么”，2月28日，莫斯科</a></li>
<li><a href="../zh-CN441258/index.html">在Linux上使用eBPF和bpftrace的全功能动态跟踪</a></li>
<li><a href="../zh-CN441262/index.html">简单和长期的任务比短期和复杂的任务更能淘汰候选人</a></li>
<li><a href="../zh-CN441264/index.html">Kibana用户指南。 可视化。 第二部分</a></li>
<li><a href="../zh-CN441266/index.html">tiOPF delphi / lazarus框架的工作方式。 访客模板</a></li>
<li><a href="../zh-CN441268/index.html">Ceedling + Eclipse或微控制器的单元测试</a></li>
<li><a href="../zh-CN441270/index.html">首先看一下苹果的FoundationDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>