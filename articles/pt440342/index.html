<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥇 👩🏾‍🎤 🛅 Código C # universal para NET e JavaScript 🤙🏿 🔸 👩🏼‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em 2013, enquanto trabalhava no serviço de fotos da GFRANQ, participei do desenvolvimento de um serviço da web de mesmo nome para publicação e process...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Código C # universal para NET e JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440342/"><p>  Em 2013, enquanto trabalhava no serviço de fotos da GFRANQ, participei do desenvolvimento de um serviço da web de mesmo nome para publicação e processamento de fotos.  Filtros e transformações foram definidos no arquivo com parâmetros e todo o processamento foi realizado no servidor.  Durante o desenvolvimento do serviço, havia a necessidade de suportar essas transformações no lado do cliente para a visualização.  Segundo Larry Wall, uma das virtudes de um programador é a preguiça.  Portanto, como programadores verdadeiramente preguiçosos, pensamos na possibilidade de usar o mesmo código no servidor e no cliente.  Todo o desenvolvimento foi realizado em C #.  Depois de pesquisar as bibliotecas e algumas tentativas, concluímos com orgulho que isso era possível e começamos a escrever o código universal. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/gs/y0/irgsy0wvrqkk5ybw0elxt5nagfk.png"></div><p></p><br><p> Por que este artigo é necessário?  De fato, seis anos se passaram desde 2013 e muitas tecnologias perderam sua relevância, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Script #</a> .  Por outro lado, novos surgiram.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bridge.NET</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blazor com</a> base no sofisticado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebAssembly</a> . </p><br><p>  No entanto, algumas idéias ainda podem ser usadas.  Neste artigo, tentei descrevê-los o mais detalhadamente possível.  Espero que a menção de Silverlight e Flash cause um sorriso com uma pitada de nostalgia, e não um desejo de criticar as soluções antigas.  De qualquer forma, eles contribuíram para o desenvolvimento da indústria da web. </p><a name="habracut"></a><br><h2 id="contents">  Conteúdo </h2><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Objetivo</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Descrição dos filtros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Descrição das colagens</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementação</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escolhendo uma plataforma para processamento de fotos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Traduzindo C # para Javascript</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vantagens</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desvantagens</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando alias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Links para arquivos</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notas sobre a implementação do .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando descarte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando bloqueio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Armazenando máscaras na memória</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notas sobre implementação de JavaScript</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minificação</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minificação manual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minificação automatizada</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modos de depuração e lançamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Propriedade crossOrigin</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Otimizações</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando os valores pré-calculados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Convertendo uma imagem em uma matriz de pixels</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de código</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geral</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detectando se uma string é um número</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Divisão inteira</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Girando e invertendo uma imagem usando a tela e o bitmap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Carregamento de imagem síncrona e assíncrona</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Somente script #</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detectando o tipo e a versão de um navegador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderizando uma linha tracejada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Animação de rotação</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclusão</a> </li></ul><br><br><h2 id="goal">  Objetivo </h2><br><p>  O desafio é implementar a colagem de fotos e a funcionalidade de edição de fotos com base em filtro no lado do cliente e, se possível, no lado do servidor.  Para começar, abordarei como os filtros e colagens são implementados. </p><br><h3 id="description-of-filters">  Descrição dos filtros </h3><br><p>  No contexto do nosso projeto, <strong>um filtro</strong> é uma série de ações realizadas no Photoshop e aplicadas a uma foto específica.  Abaixo estão os exemplos de tais ações: </p><br><ul><li>  Ajuste de brilho </li><li>  Ajuste de contraste </li><li>  Ajuste de saturação </li><li>  Ajuste de curvas de cores </li><li>  Mascaramento em diferentes modos </li><li>  Enquadramento </li><li>  ... </li></ul><br><p>  Precisamos de um certo formato para descrever essas ações.  Claro, existem formatos comuns como JSON e XML, mas foi decidido criar nosso próprio formato pelos seguintes motivos: </p><br><ul><li>  Necessidade de uma arquitetura de código independente da plataforma (.NET, JavaScript, WinPhone etc.) </li><li>  Necessidade de um formato não hierárquico simples de filtros, o que facilita a gravação de um analisador </li><li>  Dados XML e JSON consomem mais memória (nesse caso em particular) </li></ul><br><p>  Aqui está a aparência da sequência de ações para o filtro <strong>XPro Film</strong> : </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y_/oy/ad/y_oyadt7qubbsa9an37h32ostqs.png"></div><br><p>  Além de editar uma foto com um filtro, precisávamos cortar e girar a imagem.  Sim, eu sabia que existem plugins jQuery para cortar e rotacionar imagens, mas eles pareciam estar sobrecarregados e divergir da arquitetura universal do projeto. </p><br><h3 id="description-of-collages">  Descrição das colagens </h3><br><p>  <strong>Uma colagem</strong> é um arranjo de várias fotos em miniatura em uma foto inteira (com ou sem o uso de máscara).  Também era necessário permitir aos usuários arrastar e soltar as imagens disponíveis na colagem, alterar sua posição e escala.  Sua colagem pode ficar assim: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/250/1f8/0842501f87761a3c128b5f117719b10c.jpg"></div><br><p> O recurso de colagem implica o uso de um formato simples para armazenar retângulos com coordenadas relativas de <code>0</code> a <code>1</code> , os endereços das fotos e os dados de modificação da imagem.  As coordenadas relativas são usadas porque as mesmas transformações do lado do cliente são aplicadas a imagens de tamanho grande no lado do servidor. </p><br><h2 id="implementation">  Implementação </h2><br><p>  Tivemos que escolher a plataforma que permite aos usuários trabalhar com filtros e colagens </p><br><h3 id="choosing-a-platform-for-photo-processing">  Escolhendo uma plataforma para processamento de fotos </h3><br><p>  Existem várias tecnologias Rich Internet Application ( <strong>RIA</strong> ), como: </p><br><ul><li>  Adobe flash </li><li>  Microsoft silverlight </li><li>  HTML 5 + JavaScript </li><li>  Cliente nativo </li></ul><br><p>  Por razões óbvias, Flash e HTML são as únicas tecnologias que merecem atenção, pois o restante delas não é compatível com várias plataformas.  Além disso, o cliente Silverlight está começando a morrer.  Embora eu realmente goste do conceito de <del>  sal </del>  NaCl, infelizmente, essa tecnologia é suportada apenas pelo navegador Chrome e ainda não se sabe quando será suportada (e será que será sempre suportada) por outros navegadores populares.  <em>Nota de 2019: será e o nome é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebAssembly</a> .</em> </p><br><p>  A escolha foi feita em favor da plataforma HTML5 moderna e progressiva, cuja funcionalidade é atualmente suportada pelo iOS, em oposição ao Flash.  Essa opção também se baseia no fato de existirem muitas bibliotecas, que permitem compilar o código C # em Javascript.  Você também pode usar o Visual Studio para esse fim.  Os detalhes são fornecidos abaixo. </p><br><h3 id="translating-c-into-javascript">  Traduzindo C # para Javascript </h3><br><p>  O HTML 5 + JavaScript foi selecionado como plataforma na seção anterior.  Portanto, deixa-nos uma questão de saber se é possível escrever um código C # universal que possa ser compilado em .NET e JavaScript. </p><br><p>  Assim, foram encontradas várias bibliotecas para realizar a tarefa: </p><br><ul><li>  Jsil </li><li>  Sharpkit </li><li>  Script # </li><li>  E alguns outros disponíveis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> . </li></ul><br><p>  Como resultado, foi decidido usar o <strong>Script #</strong> devido ao fato de o JSIL trabalhar diretamente com assemblies e gerar código menos puro (embora ele suporte uma ampla variedade de recursos da linguagem C #) e o SharpKit é um produto comercial.  Para uma comparação detalhada dessas ferramentas, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a pergunta sobre stackoverflow</a> . </p><br><p>  Em resumo, o ScriptSharp comparado ao JavaScript escrito manualmente tem os seguintes prós e contras: </p><br><h4 id="advantages">  Vantagens </h4><br><ul><li>  Possibilidade de escrever um código C # universal que possa ser compilado no .NET e em outras plataformas (WinPhone, Mono) </li><li>  Desenvolvimento em uma linguagem C # fortemente tipada que suporta OOP </li><li>  Suporte para recursos IDE (preenchimento automático e refatoração) </li><li>  Capacidade de detectar a maioria dos erros no estágio de compilação </li></ul><br><h4 id="disadvantages">  Desvantagens </h4><br><ul><li>  Redundância e irregularidade do código JavaScript gerado (devido ao mscorlib). </li><li>  Suporte apenas para ISO-2 (sem sobrecarga de função ou inferência de tipo, extensão e genéricos) </li></ul><br><h3 id="structure">  Estrutura </h3><br><p>  O processo de compilação do mesmo código C # no .NET e Javascript pode ser ilustrado pelo seguinte esquema: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/8ba/bce/32c/8babce32c532d3b3954cdabebabb0e06.png" width="70%" alt="Tradução de C # para esquema .NET e JavaScript"></div><br><p>  Embora .NET e HTML5 sejam tecnologias completamente diferentes, eles também têm recursos semelhantes.  Isso também se aplica ao trabalho com gráficos.  Por exemplo, o .NET suporta <strong>Bitmap</strong> , o JavaScript suporta o seu análogo - <strong>Canvas</strong> .  O mesmo acontece com <strong>gráficos</strong> , <strong>contexto</strong> e matrizes de pixels.  Para combinar tudo isso em um código, decidiu-se desenvolver a seguinte arquitetura: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/89c/427/74c/89c42774cf90bdc873a0c34619cf7207.png" width="50%" alt="GraphicsContext comum do .NET e JavaScript"></div><br><p>  Obviamente, não se limita a duas plataformas.  Como acompanhamento, está planejado adicionar suporte ao WinPhone e, talvez, Android e iOS. </p><br><p>  Note-se que existem dois tipos de operações gráficas: </p><br><ul><li>  <strong>Usando funções da API</strong> ( <code>DrawImage</code> , <code>Arc</code> , <code>MoveTo</code> , <code>LineTo</code> ).  Alto desempenho e suporte à aceleração de hardware são vantagens competitivas importantes.  A desvantagem é que eles podem ser implementados de maneira diferente em plataformas diferentes. </li><li>  <strong>Pixel por pixel.</strong>  Suporte para a implementação de quaisquer efeitos e cobertura entre plataformas estão entre os benefícios.  A desvantagem é o baixo desempenho.  No entanto, você pode atenuar as desvantagens por paralelização, sombreadores e tabelas pré-calculadas (discutiremos isso mais adiante na próxima seção sobre otimização). </li></ul><br><p>  Como você pode ver, a classe abstrata <strong>Graphics</strong> descreve todos os métodos para trabalhar com gráficos;  esses métodos são implementados para várias plataformas na classe derivada.  Os aliases a seguir foram escritos para abstrair também das classes Bitmap e Canvas.  A versão WinPhone também usa um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padrão de adaptador</a> . </p><br><h4 id="using-alias">  Usando alias </h4><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP using System.Html; using System.Html.Media.Graphics; using System.Runtime.CompilerServices; using Bitmap = System.Html.CanvasElement; using Graphics = System.Html.Media.Graphics.CanvasContext2D; using ImageData = System.Html.Media.Graphics.ImageData; using Image = System.Html.ImageElement; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using Bitmap = System.Drawing.Bitmap; using Graphics = System.Drawing.Graphics; using ImageData = System.Drawing.Imaging.BitmapData; using Image = System.Drawing.Bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Infelizmente, é impossível criar aliases para tipos e matrizes não seguros, ou seja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alias ​​para ponteiro (byte *) em C #</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]</code> </pre> <br><p>  Para executar o processamento rápido de pixels usando código C # não gerenciado, ao mesmo tempo em que o compila no Script #, introduzimos o seguinte esquema com a ajuda de diretivas: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP PixelArray data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET byte* data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  A matriz de <code>data</code> é subseqüentemente usada para implementar várias operações de pixel por pixel (como mascaramento, olho de peixe, ajuste de saturação etc.), paralelamente e não. </p><br><h4 id="links-to-files">  Links para arquivos </h4><br><p>  Um projeto separado é adicionado à solução para cada plataforma, mas, é claro, Mono, Script # e até o Silverlight não podem se referir aos assemblies .NET habituais.  Felizmente, o Visual Studio possui um mecanismo para adicionar links a arquivos, o que permite reutilizar o mesmo código em projetos diferentes. </p><br><p>  As diretivas do compilador ( <code>DOTNET</code> , <code>SCRIPTSHARP</code> ) são definidas nas propriedades do projeto em Símbolos de compilação condicional. </p><br><h3 id="notes-on-net-implementation">  Notas sobre a implementação do .NET </h3><br><p>  As abstrações e aliases acima nos ajudaram a escrever o código C # com baixa redundância.  Além disso, quero apontar os problemas com as plataformas .NET e JavaScript que enfrentamos ao desenvolver o código da solução. </p><br><h4 id="using-dispose">  Usando descarte </h4><br><p>  Observe que a inclusão de qualquer instância de uma classe C #, que implementa a interface <code>IDisposable</code> , requer a chamada do método <strong><code>Dispose</code></strong> ou a aplicação da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instrução Using</a> .  Neste projeto, essas classes são Bitmap e Contexto.  O que eu disse acima não é apenas a teoria, ele realmente tem uma aplicação prática: o processamento de um grande número de fotos de tamanho grande (até 2400 x 2400 dpi) no ASP.NET Developer Server x86 resultou em uma exceção de falta de memória.  O problema foi resolvido depois de adicionar <code>Dispose</code> nos lugares certos.  Alguns outros conselhos úteis sobre manipulação de imagens são fornecidos no artigo a seguir: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">20 Redimensionamento de armadilhas</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vazamento de memória .NET: Para descartar ou não descartar, essa é a questão de 1 GB</a> . </p><br><h4 id="using-lock">  Usando bloqueio </h4><br><p>  Em JavaScript, há uma diferença entre a imagem já carregada com a tag <code>img</code> , para a qual você pode especificar o evento de origem e de carregamento, e a tela com tags de <code>canvas</code> , na qual é possível desenhar algo.  No .NET esses elementos são representados pela mesma classe <code>Bitmap</code> .  Assim, os aliases Bitmap e Imagem no .NET apontam para a mesma classe <code>System.Drawing.Bitmap</code> conforme mostrado acima. </p><br><p>  No entanto, essa divisão em <code>img</code> e <code>canvas</code> em JavaScript também foi muito útil na versão .NET.  O ponto é que os filtros usam máscaras pré-carregadas de diferentes threads;  portanto, o padrão de <strong>bloqueio</strong> é necessário para evitar a exceção durante a sincronização (a imagem é copiada com <strong>bloqueio</strong> e o resultado é usado sem bloqueio): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloneImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Image image</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP Bitmap result = (Bitmap)Document.CreateElement("canvas"); result.Width = image.Width; result.Height = image.Height; Graphics context = (Graphics)result.GetContext(Rendering.Render2D); context.DrawImage(image, 0, 0); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Bitmap result; lock (image) result = new Bitmap(image); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><p>  Afinal, o <strong>bloqueio</strong> também deve ser usado ao acessar as propriedades de um objeto sincronizado (de fato, quaisquer propriedades são métodos). </p><br><h4 id="storing-masks-in-memory">  Armazenando máscaras na memória </h4><br><p>  Para acelerar o processamento, todas as máscaras potencialmente usadas para filtros são carregadas na memória quando o servidor é iniciado.  Independentemente do formato da máscara, o Bitmap carregado no servidor usa <code>4 * 2400 * 2400</code> ou <code>≈24 MB</code> de memória (o tamanho máximo da imagem é <code>2400 * 2400</code> ; o número de bytes por pixel é 4).  Todas as máscaras para filtros (≈30) e colagens (40) consumirão 1,5 GB - isso não é muito para o servidor;  no entanto, conforme o número de máscaras aumenta, esse valor pode aumentar significativamente.  No futuro, possivelmente usaremos técnicas de compactação para máscaras armazenadas na memória (nos formatos .jpg e .png) seguidas de descompactação quando necessário.  Na verdade, o tamanho pode ser reduzido em até 300 vezes.  Uma vantagem adicional dessa abordagem é que a cópia das imagens compactadas é mais rápida em comparação às grandes;  portanto, a operação de <strong>bloqueio</strong> levará menos tempo e os threads serão bloqueados com menos frequência. </p><br><h3 id="notes-on-javascript-implementation">  Notas sobre implementação de JavaScript </h3><br><h4 id="minification">  Minificação </h4><br><p>  Recusei-me a usar o termo "ofuscação" pelo seguinte motivo: este termo é pouco aplicável a uma linguagem de código-fonte totalmente aberto, que no nosso caso é JavaScript.  No entanto, o anonimato dos identificadores pode atrapalhar a legibilidade e a lógica do código.  E o mais importante, essa técnica reduzirá significativamente o tamanho do script (a versão compactada é de ≈80 KB). </p><br><p>  Existem duas abordagens para a minificação do JavaScript: </p><br><ul><li>  <strong>Minificação manual,</strong> que é executada no estágio de geração usando o ScriptSharp. </li><li>  <strong>Minificação automatizada,</strong> realizada após o estágio de geração usando ferramentas externas, como o Google Closure Compiler, Yui e outras ferramentas. </li></ul><br><h5 id="manual-minification">  Minificação manual </h5><br><p>  Para encurtar os nomes dos métodos, classes e atributos, usamos essa sintaxe antes da declaração das entidades mencionadas acima.  Obviamente, não é necessário fazer isso se você estiver trabalhando com métodos chamados de scripts e classes externos (público). </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP &amp;&amp; !DEBUG [ScriptName("a0")] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  De qualquer forma, as variáveis ​​locais não puderam ser minificadas.  Essas construções poluem o código e prejudicam a legibilidade do código, o que também é uma séria desvantagem.  No entanto, essa técnica pode reduzir significativamente a quantidade de código JavaScript gerado e atrapalhar também. </p><br><p>  Outra desvantagem é que você precisa ficar de olho nesses nomes abreviados se eles renomearem os nomes de métodos e de campos (especialmente nomes substituídos nas classes filho), porque nesse caso o Script # não se importará com nomes repetitivos.  No entanto, não permitirá classes duplicadas. </p><br><p>  A propósito, a funcionalidade de minificação para métodos e campos privados e internos já foi adicionada à versão desenvolvida do Script #. </p><br><h5 id="automated-minification">  Minificação automatizada </h5><br><p>  Embora existam muitas ferramentas para minificação de JavaScript, usei o Google Closure Compiler por sua marca e boa qualidade de compactação.  A desvantagem da ferramenta de minificação do Google é que ela não pode compactar arquivos CSS;  por outro lado, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YUI</a> enfrenta esse desafio com sucesso.  De fato, o Script # também pode reduzir scripts, mas lida com esse desafio muito pior que o Google Closure. </p><br><p>  A ferramenta de minificação do Google possui vários níveis de compactação: espaço em branco, simples e avançado.  Escolhemos o nível Simples para o projeto;  embora, o nível Avançado permita alcançar a qualidade máxima de compactação, requer código escrito dessa maneira para que os métodos sejam acessíveis de fora da classe.  Essa minificação foi parcialmente realizada manualmente usando o Script #. </p><br><h4 id="debug-and-release-modes">  Modos de depuração e lançamento </h4><br><p>  As bibliotecas de depuração e versão foram adicionadas às páginas do ASP.NET da seguinte maneira: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Gfranq.JavaScriptFilters.HtmlHelper.IsDebug</span></span></span><span class="hljs-tag">) { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span><span class="hljs-tag"> { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } %&gt;</span></span></code> </pre> <br><p>  Neste projeto, reduzimos os scripts e os arquivos de descrição do filtro. </p><br><h4 id="crossorigin-property">  Propriedade crossOrigin </h4><br><p>  Para acessar os pixels de uma imagem em particular, precisamos primeiro convertê-la em tela.  Mas isso pode levar a um erro CORS (Cross Origin Request Security).  No nosso caso, o problema foi resolvido da seguinte maneira: </p><br><ul><li>  Configurando o <code>crossOrigin = ''</code> no lado do servidor. </li><li>  Adicionando um cabeçalho específico ao pacote HTTP no lado do servidor. </li></ul><br><p>  Como o ScriptSharp não suporta essa propriedade para elementos img, o seguinte código foi gravado: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Imported</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AdvImage</span></span> { [IntrinsicProperty] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CrossOrigin { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { } } }</code> </pre> <br><p>  Então, vamos usá-lo assim: </p><br><pre> <code class="plaintext hljs">((AdvImage)(object)result).CrossOrigin = "";</code> </pre> <br><p>  Essa técnica permite adicionar qualquer recurso ao objeto sem erros de compilação.  Particularmente, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedade <code>wheelDelta</code> ainda não foi implementada</a> no ScriptSharp (pelo menos na versão 0.7.5).  Esta propriedade indica a quantidade da roda de rolagem, usada para criar colagens.  É por isso que foi implementado dessa maneira.  Um hack tão sujo com as propriedades não é bom;  normalmente, você precisa fazer alterações no projeto.  Mas, apenas para constar, ainda não descobri uma maneira de compilar o ScriptSharp a partir da fonte. </p><br><p>  Essas imagens requerem que o servidor retorne os seguintes cabeçalhos em seus cabeçalhos de resposta (em Global.asax): </p><br><pre> <code class="cs hljs">Response.AppendHeader(<span class="hljs-string"><span class="hljs-string">"Access-Control-Allow-Origin"</span></span>, <span class="hljs-string"><span class="hljs-string">"\*"</span></span>);</code> </pre> <br><p>  Para obter mais informações sobre a segurança de solicitação de origem cruzada, visite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://enable-cors.org/</a> . </p><br><h3 id="optimizations">  Otimizações </h3><br><h4 id="using-the-precalculated-values">  Usando os valores pré-calculados </h4><br><p>  Utilizamos a otimização para algumas operações, como ajuste de brilho, contraste e curvas de cores, através do cálculo preliminar dos componentes de cores resultantes (r, g, b) para todos os valores possíveis e uso adicional das matrizes obtidas para alterar diretamente as cores dos pixels. .  Note-se que esse tipo de otimização é adequado apenas para operações nas quais a cor do pixel resultante não é afetada pelo pixel adjacente. </p><br><p>  O cálculo dos componentes de cores resultantes para todos os valores possíveis: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { r[i] = ActionFuncR(i); g[i] = ActionFuncG(i); b[i] = ActionFuncB(i); }</code> </pre> <br><p>  O uso de componentes de cores pré-calculados: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { data[i] = r[data[i]]; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = g[data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]]; data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = b[data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]]; }</code> </pre> <br><p>  Se essas operações da tabela forem uma por uma, não será necessário calcular imagens intermediárias - você pode passar apenas as matrizes do componente de cores.  Como o código funcionava rapidamente no lado do cliente e do servidor, foi decidido deixar de lado a implementação dessa otimização.  Além disso, a otimização causou algum comportamento indesejado.  No entanto, darei uma lista da otimização: </p><br><table><tbody><tr><td>  Código original </td><td>  Código otimizado </td></tr><tr><td>  `` cs <br>  // Cálculo de valores para a primeira tabela. <br>  for (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  } <br>  // ... <br><br>  // Cálculo da imagem intermediária resultante. <br>  for (int i = 0; i &lt;data.Length; i + = 4) <br>  { <br>  dados [i] = r [dados [i]]; <br>  dados [i + 1] = g [dados [i + 1]]; <br>  dados [i + 2] = b [dados [i + 2]]; <br>  } <br>  // ... <br><br>  // Cálculo de valores para a segunda tabela. <br>  for (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc2R (i); <br>  g [i] = ActionFunc2G (i); <br>  b [i] = ActionFunc2B (i); <br>  } <br>  // ... <br><br>  // Cálculo da imagem resultante. <br>  for (int i = 0; i &lt;data.Length; i + = 4) <br>  { <br>  dados [i] = r [dados [i]]; <br>  dados [i + 1] = g [dados [i + 1]]; <br>  dados [i + 2] = b [dados [i + 2]]; <br>  } <br>  `` `` <br><br></td><td>  `` cs <br>  // Cálculo de valores para a primeira tabela. <br>  for (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  } <br>  // ... <br><br>  // Cálculo de valores para a segunda tabela. <br>  tr = r.Clone (); <br>  tg = g.Clone (); <br>  clone (); <br>  for (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = tr [ActionFunc2R (i)]; <br>  g [i] = tg [ActionFunc2G (i)]; <br>  b [i] = t [ActionFunc2B (i)]; <br>  } <br>  // ... <br><br>  // Cálculo da imagem resultante. <br>  for (int i = 0; i &lt;data.Length; i + = 4) <br>  { <br>  dados [i] = r [dados [i]]; <br>  dados [i + 1] = g [dados [i + 1]]; <br>  dados [i + 2] = b [dados [i + 2]]; <br>  } <br>  `` `` <br><br></td></tr></tbody></table><br><p>  Mas mesmo isso não é tudo.  Se você der uma olhada na tabela à direita, notará que novas matrizes são criadas usando o método <code>Clone</code> .  Na verdade, você pode simplesmente mudar os ponteiros para as novas e antigas matrizes, em vez de copiar a própria matriz (isso lembra a analogia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer duplo</a> ). </p><br><h4 id="converting-an-image-to-an-array-of-pixels">  Convertendo uma imagem em uma matriz de pixels </h4><br><p>  O criador de perfil JavaScript no Google Chrome revelou que a função <code>GetImageData</code> (usada para converter a tela em uma matriz de pixels) é executada por tempo suficiente.  A propósito, essas informações podem ser encontradas em vários artigos sobre otimização do Canvas em JavaScript. </p><br><p>  No entanto, o número de chamadas dessa função pode ser minimizado.  Ou seja, podemos usar a mesma matriz de pixels para operações pixel por pixel, por analogia com a otimização anterior. </p><br><h2 id="code-examples">  Exemplos de código </h2><br><p>  Nos exemplos abaixo, fornecerei os fragmentos de código que achei interessantes e úteis.  Para evitar que o artigo seja muito longo, ocultei os exemplos em um spoiler. </p><br><h3 id="general">  Geral </h3><br><h4 id="detecting-whether-a-string-is-a-number">  Detectando se uma string é um número </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNumeric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !SCRIPTSHARP return ((Number)int.Parse(n)).ToString() != "NaN"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> double number; return double.TryParse(n, out number); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><h4 id="integer-division">  Divisão inteira </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = n / k; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP result = Math.Floor(n / k); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return result; }</span></span></code> </pre> <br><h4 id="rotating-and-flipping-an-image-using-canvas-and-bitmap">  Girando e invertendo uma imagem usando a tela e o bitmap </h4><br><p>  Observe que, no html5, as imagens de tela podem ser giradas 90 e 180 graus apenas usando matrizes, enquanto o .NET fornece funcionalidade aprimorada.  Assim, uma função precisa e precisa para trabalhar com pixels foi escrita. </p><br><p>  Também é importante notar que uma rotação de 90 graus de qualquer lado na versão .NET pode retornar resultados incorretos.  Portanto, você precisa criar um novo <code>Bitmap</code> depois de usar a função <code>RotateFlip</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateFlip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap, RotFlipType rotFlipType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP int t, i4, j4, w, h, c; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipNone) return bitmap; GraphicsContext context; PixelArray data; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; for (int i = 0; i &lt; h; i++) { c = (i + 1) * w * 4 - 4; for (int j = 0; j &lt; w / 2; j++) { i4 = (i * w + j) * 4; j4 = j * 4; t = (int)data[i4]; data[i4] = data[c - j4]; data[c - j4] = t; t = (int)data[i4 + 1]; data[i4 + 1] = data[c - j4 + 1]; data[c - j4 + 1] = t; t = (int)data[i4 + 2]; data[i4 + 2] = data[c - j4 + 2]; data[c - j4 + 2] = t; t = (int)data[i4 + 3]; data[i4 + 3] = data[c - j4 + 3]; data[c - j4 + 3] = t; } } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone || rotFlipType == RotFlipType.Rotate180FlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; c = w * 4 - 4; int dlength4 = data.Length - 4; for (int i = 0; i &lt; data.Length / 4 / 2; i++) { i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone) j4 = i4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> j4 = (Math.Truncate((double)i / w) * w + (w - i % w)) * 4; t = (int)data[j4]; data[j4] = data[dlength4 - i4]; data[dlength4 - i4] = t; t = (int)data[j4 + 1]; data[j4 + 1] = data[dlength4 - i4 + 1]; data[dlength4 - i4 + 1] = t; t = (int)data[j4 + 2]; data[j4 + 2] = data[dlength4 - i4 + 2]; data[dlength4 - i4 + 2] = t; t = (int)data[j4 + 3]; data[j4 + 3] = data[dlength4 - i4 + 3]; data[dlength4 - i4 + 3] = t; } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { Bitmap tempBitmap = PrivateUtils.CreateCloneBitmap(bitmap); GraphicsContext tempContext = GraphicsContext.GetContext(tempBitmap); PixelArray temp = tempContext.GetPixelArray(); t = bitmap.Width; bitmap.Width = bitmap.Height; bitmap.Height = t; context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = tempBitmap.Width; h = tempBitmap.Height; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone || rotFlipType == RotFlipType.Rotate90FlipX) { c = w * h - w; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c - w * (i % h) + t) * 4; //j4 = (w * (h - 1 - i4 % h) + i4 / h) * 4; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone || rotFlipType == RotFlipType.Rotate270FlipX) { c = w - 1; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c + w * (i % h) - t) * 4; // j4 = w * (1 + i4 % h) - i4 / h - 1; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } context.PutImageData(); } return bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET Bitmap result = null; switch (rotFlipType) { case RotFlipType.RotateNoneFlipNone: result = bitmap; break; case RotFlipType.Rotate90FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate90FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate270FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate270FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone); result = bitmap; break; case RotFlipType.RotateNoneFlipX: bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX); result = bitmap; break; case RotFlipType.Rotate90FlipX: bitmap.RotateFlip(RotateFlipType.Rotate90FlipX); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipX: bitmap.RotateFlip(RotateFlipType.Rotate180FlipX); result = bitmap; break; case RotFlipType.Rotate270FlipX: bitmap.RotateFlip(RotateFlipType.Rotate270FlipX); result = new Image(bitmap); bitmap.Dispose(); break; } return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h4 id="synchronous-and-asynchronous-image-loading">  Carregamento de imagem síncrona e assíncrona </h4><br><p>  Observe que, na versão Script #, especificamos uma função diferente <code>CollageImageLoad</code> , que é chamada após o carregamento de uma imagem, enquanto na versão .NET esses processos ocorrem simultaneamente (de um sistema de arquivos ou da Internet). </p><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CollageData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> smallMaskPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bigMaskPath, List&lt;CollageDataPart&gt; dataParts</span></span></span><span class="hljs-function">)</span></span> { SmallMaskImagePath = smallMaskPath; BigMaskImagePath = bigMaskPath; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP CurrentMask = PrivateUtils.CreateEmptyImage(); CurrentMask.AddEventListener("load", CollageImageLoad, false); CurrentMask.Src = CurrentMaskImagePath; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> CurrentMask = PrivateUtils.LoadBitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!CurrentMaskImagePath.Contains("http://") &amp;&amp; !CurrentMaskImagePath.Contains("https://")) CurrentMask = Bitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { var request = WebRequest.Create(CurrentMaskImagePath); using (var response = request.GetResponse()) using (var stream = response.GetResponseStream()) CurrentMask = (Bitmap)Bitmap.FromStream(stream); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DataParts = dataParts; }</span></span></code> </pre> </div></div><br><h3 id="script-only">  Somente script # </h3><br><h4 id="detecting-the-type-and-version-of-a-browser">  Detectando o tipo e a versão de um navegador </h4><br><p>  Esta função é usada para determinar os recursos de arrastar e soltar em diferentes navegadores.  Eu tentei usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modernizr</a> , mas ele retornou que o Safari e (no meu caso, era uma versão do Win) o IE9 o implementava.  Na prática, esses navegadores falham ao implementar os recursos de arrastar e soltar corretamente. </p><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BrowserVersion { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { DetectBrowserTypeAndVersion(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _browserVersion; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectBrowserTypeAndVersion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_browserDetected) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> userAgent = Window.Navigator.UserAgent.ToLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"opera"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Opera; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"chrome"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Chrome; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"safari"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Safari; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"firefox"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Firefox; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numberIndex = userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; _browser = BrowserType.IE; _browserVersion = userAgent.Substring(numberIndex, userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">';'</span></span>, numberIndex)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _browser = BrowserType.Unknown; _browserDetected = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> </div></div><br><h4 id="rendering-a-dash-dot-line">  Renderizando uma linha tracejada </h4><br><p>  Este código é usado para um retângulo para cortar imagens.  Obrigado pelas idéias a todos que responderam a esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pergunta no stackoverflow</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawDahsedLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GraphicsContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dashArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashArray == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) dashArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashCount = dashArray.Length; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = x2 - x1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dy = y2 - y1; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> xSlope = Math.Abs(dx) &gt; Math.Abs(dy); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> slope = xSlope ? dy / dx : dx / dy; context.MoveTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> distRemaining = Math.Sqrt(dx * dx + dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (distRemaining &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashLength = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Min(distRemaining, dashArray[dashIndex % dashCount]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> step = Math.Sqrt(dashLength * dashLength / (<span class="hljs-number"><span class="hljs-number">1</span></span> + slope * slope)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xSlope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += step; y1 += slope * step; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dy &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += slope * step; y1 += step; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashIndex % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) context.LineTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> context.MoveTo(x1, y1); distRemaining -= dashLength; dashIndex++; } }</code> </pre> </div></div><br><h4 id="rotation-animation">  Animação de rotação </h4><br><p>  <code>setInterval</code> função <code>setInterval</code> é usada para implementar a animação de rotação de imagem.  Observe que a imagem resultante é calculada durante a animação, para que não haja atrasos no final da animação. </p><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cw</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating &amp;&amp; !_flipping) { _rotating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _cw = cw; RotFlipType oldRotFlipType = _curRotFlipType; _curRotFlipType = RotateRotFlipValue(_curRotFlipType, _cw); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentStep = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stepCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(RotateFlipTimeSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span> / StepTimeTicks); Bitmap result = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _interval = Window.SetInterval(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentStep &lt; stepCount) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> absAngle = GetAngle(oldRotFlipType) + currentStep / stepCount * Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span> * (_cw ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); DrawRotated(absAngle); currentStep++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Window.ClearInterval(_interval); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Draw(result); _rotating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }, StepTimeTicks); result = GetCurrentTransformResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating) Draw(result); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawRotated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotAngle</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Save(); _resultContext._graphics.Translate(_result.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, _result.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.Rotate(-rotAngle); _resultContext._graphics.Translate(-_origin.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -_origin.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.DrawImage(_origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _resultContext.Restore(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Draw2(bitmap, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Width - bitmap.Width) / <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Height - bitmap.Height) / <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> </div></div><br><h2 id="conclusion">  Conclusão </h2><br><p>  Este artigo descreve como a linguagem C # (combinando código não gerenciado e compilação para JavaScript) pode ser usada para criar uma solução realmente multiplataforma.  Apesar do foco no .NET e JavaScript, a compilação para Android, iOS (usando Mono) e Windows Phone também é possível com base nessa abordagem, que, é claro, tem suas armadilhas.  O código é um pouco redundante devido à sua universalidade, mas não afeta o desempenho, pois as operações gráficas geralmente levam muito mais tempo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440342/">https://habr.com/ru/post/pt440342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440328/index.html">A probabilidade de ganhar uma partida com a probabilidade conhecida de ganhar um ponto II</a></li>
<li><a href="../pt440330/index.html">Brevemente sobre abstrações</a></li>
<li><a href="../pt440332/index.html">Banco de dados nas nuvens: para quem e por quê - a opinião dos especialistas em Data Egret</a></li>
<li><a href="../pt440336/index.html">HTML perdemos</a></li>
<li><a href="../pt440338/index.html">Como garantir a disponibilidade de um serviço da web na nuvem no caso de uma falha no data center</a></li>
<li><a href="../pt440344/index.html">InterNyet - como a Internet foi inventada na União Soviética e por que não funcionou</a></li>
<li><a href="../pt440346/index.html">No final de fevereiro, a Microsoft apresentará os óculos VR HoloLens 2</a></li>
<li><a href="../pt440350/index.html">Flying Bear Tornado 2 - um novo urso chegou</a></li>
<li><a href="../pt440352/index.html">Hack de massa VKontakte [XSS-worm]</a></li>
<li><a href="../pt440354/index.html">Eventos digitais em Moscou, de 18 a 24 de fevereiro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>