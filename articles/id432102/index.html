<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ» ğŸ‘ğŸ½ ğŸ§˜ğŸ» Fitur JavaScript Eksplisit ğŸ™… ğŸ¦… ğŸ‘·ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya membaca artikel lain tentang fitur yang sedikit diketahui dari bahasa JavaScript dan diam-diam kencing beberapa solusi gila di konsol brow...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur JavaScript Eksplisit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432102/"><p><img src="https://habrastorage.org/webt/f_/vy/_s/f_vy_sw3-w-pyxs4zrpqejzpkq4.jpeg" alt="Gambar"></p><br><p>  Ketika saya membaca artikel lain tentang fitur yang sedikit diketahui dari bahasa <strong>JavaScript</strong> dan diam-diam kencing beberapa solusi gila di konsol browser, saya sering mengatakan di kepala saya bahwa, yah, itu tentu tidak begitu pada prod!!  Lagipula, bahasa tersebut telah lama mengakuisisi komunitas besar dan memiliki cakupan pengembangan industri yang mengejutkan.  Jika demikian, lalu mengapa kita sering lupa tentang kemampuannya untuk dipahami oleh semua orang dan secara harfiah mempromosikan semua konstruksi yang spesifik dan "berkesan" ini?  <em>Buat saja Jelas!</em> </p><a name="habracut"></a><br><h2 id="rassuzhdeniya-na-temu">  Alasan pada topik </h2><br><p>  <em>Anda dapat melewati graphomania ini.</em> </p><br><p> Jika kita berbicara tentang pengembangan industri, dalam sebagian besar kasus, persyaratan untuk kode yang akan didukung bahkan lebih penting daripada menyelesaikan tugas yang ditimbulkan oleh bisnis.  Bagi banyak orang, ini jelas, bagi sebagian orang - sebagian (tentu saja, D'Artagnans langka juga ditemukan).  Semakin jelas kode kita, semakin sedikit risiko untuk sampai ke rak berdebu, dan bagi kita dan penerus kita mendapatkan masalah dengan sistem saraf. </p><br><p>  Bukan rahasia lagi bahwa JavaScript luar biasa dalam fleksibilitasnya, yang merupakan kebajikan terbesar dan kutukan yang menjengkelkan.  Jalur pengembang JavaScript sangat panjang dan sangat menarik: kami menyerap buku demi buku, artikel demi artikel, dan mendapatkan pengalaman unik, tetapi terkadang itu benar-benar spesifik bahasa.  Distribusi bahasa yang terluas dan pada saat yang sama sejumlah besar akumulasi dan pemberian yang tidak jelas berkontribusi pada pembentukan dua front: mereka yang hampir mengidolakan bahasa ini, dan mereka yang melihatnya sebagai bebek hak yang canggung dan bergoyang. </p><br><p>  Dan semua akan baik-baik saja, tetapi seringkali perwakilan dari kedua front bekerja pada proyek yang sama.  Dan yang biasa, semua praktik yang diterima adalah kesalahpahaman (keengganan untuk memahami dan bahkan mengabaikan) kode masing-masing.  Dan faktanya, <em>"Saya punya pengembang Java, dan bukan ini milik Anda!"</em>  .  Pengikut Javascript sendiri menambahkan bahan bakar ke api, mengatakan <em>"tidak ada yang benar-benar tahu JavaScript!"</em>  ya <em>"Saya bisa menulisnya dalam satu baris di js!"</em>  .  Saya mengaku bahwa saya sendiri menyalahgunakan pemrograman abnormal di waktu luang saya ... </p><br><p>  Anda mulai merasakan masalah ini ketika Anda menggantikan posisi marginal dan mendapatkan pengalaman bekerja dengan orang-orang dan kode mereka di kedua sisi barikade.  Perencanaan dan rapat lainnya lebih produktif ketika semua pengembang memahami satu sama lain, tidak hanya di tingkat lini bisnis, tetapi setidaknya sedikit di tingkat implementasi mereka.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Faktor bass yang</a> terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki</a> dampak yang lebih kecil pada proyek, ketika dalam hal penyakit front-ender tunggal, anggota tim lainnya tidak meremehkan untuk memperbaiki beberapa baris file <em>.js</em> .  Proses berbagi pengetahuan di dalam tim dan di luar menjadi lebih transparan bagi semua orang ketika semua orang memiliki gambaran yang lebih rinci.  Baik dan semuanya dalam nada yang sama. </p><br><p>  Saya tidak mendesak siapa pun untuk "full glass" atau "T-shape" (bagaimana mengatakannya sekarang?), Tapi mengapa kita tidak sedikit menaikkan tirai ini, jika hanya dari komunitas JavaScript?  Untuk melakukan ini, cukup dengan membawa sedikit kejelasan kode kita, menggunakan fleksibilitas bahasa untuk tidak pamer, tetapi untuk memahami kita. </p><br><h2 id="vzroslenie-i-prinyatie-otvetstvennosti">  Tumbuh dan mengambil tanggung jawab </h2><br><p>  Untuk bagiannya, JavaScript telah lama menyadari perannya, bukan sebagai bahasa untuk interaktivitas halaman Internet dan "menempelkan" sumber daya mereka, tetapi sebagai alat yang kuat dan cukup untuk membuat lintas-platform yang lengkap dan aplikasi yang seringkali sangat skalabel. </p><br><p>  Awalnya dirancang untuk perancang web, "bahasa pemrograman yang paling banyak disalahpahami" ini telah lama menginjak air, meskipun popularitas dan relevansinya berkembang pesat.  Selama 13-14 tahun sebelum edisi ECMAScript 5.1, sulit untuk mengingat setiap perubahan penting dalam standar atau memahami vektor perkembangannya.  Pada saat itu, komunitasnya memberikan kontribusi besar pada pembentukan ekosistem bahasa: Prototipe, jQuery, MooTools, dll.  Setelah menerima umpan balik ini dari para pengembang, JavaScript melakukan pekerjaan signifikan pada bug: rilis ES6 6-tahun yang keras pada tahun 2015 dan sekarang rilis tahunan ECMAScript, berkat komite TC39 yang mendesain ulang proses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperkenalkan fitur-fitur baru</a> ke dalam spesifikasi. </p><br><p>  Nah, ketika aplikasi kita menjadi cukup besar, model OOP prototipe untuk menggambarkan tipe pengguna tidak lagi dibenarkan karena pendekatan yang tidak biasa.  Baik serius, ada apa? </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Call me via new and I will be the constructor ;) */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} Rabbit.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Animal.prototype); Rabbit.prototype.constructor = Rabbit;</code> </pre> <br><p>  Kelas tidak muncul dalam bahasa, tetapi sintaksisnya muncul.  Dan kode tersebut telah tersedia untuk penganut paradigma tradisional yang berorientasi kelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* Obviously, the constructor is here! */</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Sekarang pada tahap kandidat untuk rilis adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bidang pribadi</a> kelas.  Sulit dipercaya bahwa cepat atau lambat kita akan berhenti saling menertawakan dengan kesepakatan tentang penamaan properti pribadi melalui garis bawah. </p><br><p>  Pada saat yang sama, dalam bahasa di mana fungsi adalah objek orde pertama dan peristiwa konstan terjadi, itu cukup umum: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  Dan kemudian penjelasan tentang konteks <em>ini</em> dan penutupan dalam JavaScript dimulai, yang membuat takut setiap pengembang eksternal kedua.  Tetapi dalam banyak kasus, bahasa menghindari kejutan yang tidak perlu dengan secara eksplisit menggunakan <em>Function.prototype.bind</em> atau bahkan lebih: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  Kami juga punya fungsi panah, dan ini benar-benar fungsi, bukan antarmuka fungsional (ya, Java?).  Bersama-sama dengan serangkaian metode yang diperluas untuk bekerja dengan array, mereka juga membantu untuk menulis garis perhitungan deklaratif yang biasa: </p><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, x)) .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, x</span></span></span><span class="hljs-function">) =&gt;</span></span> s + x, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Bahasa dengan tepat menganggap dirinya multi-paradigmatik.  Tapi di sini adalah contoh sederhana tentang tanda tangan beberapa fungsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* send ping to host count times */</span></span> }</code> </pre> <br><p>  Pertama, seseorang yang lewat akan mengajukan pertanyaan yang mengatakan bahwa mungkin suatu fungsi hanya dapat mengambil argumen pertama, dan kemudian mengatakan apa sih dalam kasus ini, <em>menghitung</em> menjadi Boolean!  Memang, fungsi memiliki dua kegunaan: dengan <em>menghitung</em> dan tanpa.  Tetapi ini sama sekali tidak jelas: Anda harus melihat implementasinya dan mengerti.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSDoc</a> dapat membantu, tetapi ini bukan praktik yang umum.  Dan di sini JavaScript maju, menambahkan dukungan bukan untuk kelebihan beban, tetapi setidaknya untuk parameter default: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Meringkas, JavaScript mendapat sejumlah besar hal-hal yang akrab: generator, iterator, <em>Kumpulan</em> koleksi dan kamus <em>Peta</em> , array yang diketik, dan bahkan ekspresi reguler mulai menyenangkan lihat di belakang dukungan!  Bahasa melakukan segalanya agar cocok untuk banyak hal dan menjadi ramah bagi semua orang. </p><br><h2 id="blagopriyatnyy-put-k-ochevidnomu">  Jalur yang menguntungkan ke yang jelas </h2><br><p>  Bahasa itu sendiri sudah pasti dilakukan dengan baik, dan sulit untuk membantahnya!  Tapi apa yang salah dengan kita?  Mengapa kita terus-menerus mengingatkan seluruh dunia bahwa JavaScript berbeda?  Mari kita lihat contoh-contoh dari beberapa teknik yang banyak digunakan dan bertanya tentang kesesuaian mereka. </p><br><h3 id="privedenie-tipov">  Ketik casting </h3><br><p>  Ya, JavaScript memiliki sistem tipe dinamis dan lemah dan memungkinkan Anda untuk melakukan operasi pada apa pun, secara implisit melakukan transformasi untuk kami.  Namun seringkali, casting eksplisit masih diperlukan bagi kami, dan berikut ini dapat diamati: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = !!(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = +(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">''</span></span>+(expr);</code> </pre> <br><p>  Trik ini diketahui oleh setiap pengembang JavaScript dan mereka termotivasi oleh fakta bahwa mereka mengatakan bahwa Anda dapat "dengan cepat" mengubah sesuatu menjadi sesuatu: kecepatan berarti catatan pendek.  Bisakah itu juga menulis <em>false</em> segera sebagai <em>! 1</em> ?  Jika pengembang sangat khawatir dengan karakter yang dapat dicetak, maka dalam IDE favoritnya Anda dapat dengan mudah mengonfigurasi <em>templat langsung yang</em> diperlukan atau melengkapi otomatis.  Dan jika - untuk ukuran kode yang diterbitkan, maka kita selalu menjalankannya melalui obfuscator, siapa yang tahu lebih baik dari kita bagaimana cara merendahkan semua ini.  Kenapa tidak: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(expr);</code> </pre> <br><p>  Hasilnya sama, hanya jelas untuk semua orang. </p><br><p>  Untuk konversi string, kita <em>harusString</em> , tetapi untuk yang numerik ada <em>valueOf yang</em> menarik, yang juga bisa diganti.  Contoh klasik yang memperkenalkan "belum tahu" ke dalam keadaan pingsan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>;</code> </pre> <br><p>  Tetapi <em>Date</em> memang memiliki metode <em>getTime yang</em> dikenal, mari kita gunakan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).getTime();</code> </pre> <br><p>  atau fungsi siap pakai: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code> </pre> <br><p>  Sama sekali tidak perlu mengeksploitasi konversi tipe implisit. </p><br><h3 id="logicheskie-operatory">  Operator logis </h3><br><p>  Perhatian khusus diberikan kepada operator logis AND (&amp;&amp;) dan OR (||), yang tidak cukup logis dalam JavaScript: mereka menerima dan mengembalikan nilai dari jenis apa pun.  Kami tidak akan masuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail operasi kalkulator</a> ekspresi logis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kami akan mempertimbangkan contoh.  Opsi yang disajikan sebelumnya dengan fungsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Mungkin terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// OR arguments.length? if (typeof count == 'undefined') { count = 5; } /* ... */ }</span></span></code> </pre> <br><p>  Verifikasi semacam itu lebih akrab, dan dalam beberapa kasus dapat membantu menghindari kesalahan. </p><br><p>  Sebaliknya, tampaknya kebiadaban bagi pengembang yang awalnya memilih jalur JavaScript.  Tetapi bagi sebagian besar orang lain, kode ini benar-benar liar: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; self.self === self &amp;&amp; self) || (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; global.global === global &amp;&amp; global);</code> </pre> <br><p>  Ya, itu kompak, dan ya, perpustakaan populer dapat membelinya.  Tapi tolong, jangan menyalahgunakannya, karena kode kita tidak akan dibaca oleh kontributor dalam JavaScript, tetapi oleh pengembang yang memecahkan masalah bisnis dalam kerangka waktu. </p><br><p>  Pola seperti itu dapat terjadi sama sekali: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> opts == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; opts.count || <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  Ini jelas lebih pendek dari operator ternary biasa, tetapi ketika membaca kode seperti itu, hal pertama yang Anda ingat adalah prioritas operasi yang digunakan. </p><br><p>  Jika kita menulis fungsi predikat, yang kita lewati ke <em>Array.prototype.filter yang</em> sama, maka membungkus nilai kembali dalam <em>Boolean</em> adalah nada yang baik.  Tujuan dari fungsi ini segera menjadi jelas dan tidak ada disonansi di antara pengembang yang bahasanya memiliki operator logis "benar". </p><br><h3 id="pobitovye-operacii">  Operasi bitwise </h3><br><p>  Contoh umum memeriksa keberadaan elemen dalam array atau substring dalam string menggunakan bitwise NOT (NOT), yang ditawarkan bahkan oleh beberapa tutorial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'yes'</span></span>); }</code> </pre> <br><p>  Masalah apa yang dipecahkan ini?  kita tidak perlu memeriksa <em>! == -1</em> , karena <em>indexOf</em> akan mendapatkan indeks elemen atau -1, dan tilde akan menambahkan 1 dan mengubah tanda.  Dengan demikian, ekspresi akan berubah menjadi "false" dalam kasus indeks -1. </p><br><p>  Tetapi duplikasi kode dapat dihindari dengan cara lain: meletakkan tanda centang pada fungsi terpisah dari beberapa objek-utils, seperti yang dilakukan semua orang, daripada menggunakan operasi bitwise untuk tujuan lain.  Ada fungsi <a href="">menyertakan</a> dalam lodash untuk ini, dan itu tidak berhasil <del>  brengsek </del>  tilde  Anda dapat bersukacita, karena dalam ECMAScript 2016, metode <em>Array.prototype.includes</em> telah <em>diperbaiki</em> (baris juga memiliki satu). </p><br><p>  Tapi itu dia!  Tilde lain (bersama dengan XOR) digunakan untuk membulatkan angka, membuang bagian desimal: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(~~<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(2.72^0); // 2</span></span></code> </pre> <br><p>  Tetapi ada <em>parseInt</em> atau <em>Math.floor</em> untuk keperluan ini.  Operasi bitwise di sini nyaman untuk mengetik kode dengan cepat di konsol, karena mereka juga memiliki prioritas rendah selama sisa aritmatika.  Tetapi pada ulasan kode, lebih baik jangan sampai ketinggalan. </p><br><h3 id="sintaksis-i-konstrukcii-yazyka">  Sintaks dan konstruksi bahasa </h3><br><p>  Beberapa praktik aneh sulit untuk dikaitkan dengan bagian tertentu.  Misalnya, mereka mengatakan bahwa tanda kurung adalah opsional ketika memanggil konstruktor, dan dua ekspresi berikut ini identik: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit;</code> </pre> <br><p>  Dan memang benar!  tapi mengapa membuat pertanyaan dari awal?  Tidak semua bahasa dapat membanggakan "fitur" tersebut.  Dan jika Anda masih ingin, maka biarkan itu menjadi kesepakatan di seluruh proyek.  Kalau tidak, ada perasaan salah bahwa ada beberapa perbedaan. </p><br><p>  Situasi serupa dengan mendeklarasikan serangkaian variabel.  Sintaks dari <em>var</em> dan <em>biarkan</em> arahan memungkinkan Anda untuk mendeklarasikan (dan mendefinisikan) beberapa variabel sekaligus, dipisahkan oleh koma: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>, host, retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Seseorang menggunakan umpan baris untuk keterbacaan, tetapi dalam hal apa pun, sintaks ini tidak umum dalam bahasa populer.  Tidak ada yang akan membantu dan bertanya apakah Anda menulis seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> host;</code> </pre> <br><p>  Sekali lagi, jika ada kesepakatan tentang gaya yang baik di tingkat proyek / perusahaan, maka tidak ada pertanyaan.  Hanya saja Anda tidak perlu menggabungkan terlalu banyak sintaks untuk suasana hati Anda. </p><br><p>  Ada konstruksi khusus dalam bahasa tersebut, seperti IIFE, yang memungkinkan Anda untuk memanggil fungsi segera di tempat definisinya.  Triknya adalah agar parser mengenali ekspresi fungsional, bukan deklarasi fungsi.  Dan ini dapat dilakukan dengan banyak cara berbeda: membungkus tanda kurung secara klasik, melalui <em>kekosongan</em> atau operator unary lainnya.  Dan tidak ada yang luar biasa tentang itu!  Penting untuk memilih satu-satunya pilihan dan tidak meninggalkannya tanpa perlu: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }());</code> </pre> <br><p>  Tidak perlu menggunakan operator untuk meretas parser.  Ketika seorang pendatang baru datang ke proyek, saya ingin membenamkannya dalam logika bisnis aplikasi, dan tidak memberi makan dengan penjelasan dari mana semua tanda seru dan kekosongan ini dimata-matai.  Ada juga entri tanda kurung klasik kedua dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Crockford</a> tentang hal ini. </p><br><p>  Munculnya sintaks kelas di ES6 tidak disertai dengan pengubah akses yang biasa.  Dan terkadang pengembang ingin buang air kecil di kelas dan mengamati privasi.  Yang mengarah ke kode Frankenstein ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.getName()}</span></span></span><span class="hljs-string">`</span></span>; } }</code> </pre> <br><p>  Artinya, pengakses diciptakan untuk contoh dalam konstruktor, dan privasi dicapai dengan akses mereka ke variabel properti lokal melalui penutupan.  Contoh ini terlihat bahkan Lacconcino, tetapi ini adalah pendekatan yang sepenuhnya tidak dapat dilakukan, kecuali jika Anda membangun solusi kerangka kerja yang terdokumentasi di sekitarnya.  Tuan-tuan, mari kita gunakan kelas yang tersedia (dan tunggu standarisasi bidang pribadi), atau modul pola populer.  Untuk membuat semacam solusi campuran menengah di sini adalah hal seperti itu untuk Anda sendiri, karena kelas tidak lagi menjadi kelas, dan kode dapat dipahami. </p><br><p>  Kesimpulannya, ia akan membagikan akal sehatnya dengan panduan gaya yang diadopsi dalam proyek, konfigurasi untuk linter, atau hanya kode fragmen dengan rekan-rekan yang berkontribusi komponen non-JavaScript untuk proyek.  Bahasa ini menawarkan beberapa opsi untuk setiap tugas yang khas, sehingga meningkatkan pemahaman satu sama lain dan jatuh di bawah common denominator tidak sulit (atau hampir). </p><br><h2 id="zloklyuchenie">  Pelanggaran yang salah </h2><br><p>  Topik ini tentu saja holistik dan ada lebih banyak contoh, tetapi pesan utama dari artikel ini adalah Anda tidak boleh menyalahgunakan ketidakjelasan dalam JavaScript di mana hal ini dapat dihindari.  Sifat bahasanya unik: memungkinkan Anda untuk menulis solusi yang elegan dan ekspresif (cukup "runcing"), serta dapat dimengerti dan dapat diakses oleh semua orang.  Saya pada dasarnya tidak setuju dengan kebijaksanaan konvensional bahwa JavaScript "menghukum dirinya sendiri" atau "dimakamkan di bawah tumpukan niat baik dan kesalahan."  Karena sekarang sebagian besar keanehan ditunjukkan bukan oleh bahasa, tetapi oleh budaya pengembang dan (tidak) acuh tak acuh yang terbentuk di sekitarnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432102/">https://habr.com/ru/post/id432102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432092/index.html">Kesalahan tidak menyenangkan saat menulis unit test</a></li>
<li><a href="../id432094/index.html">Hackathon online gabungan dari OpenGift dan Credits Blockchain Platform</a></li>
<li><a href="../id432096/index.html">Panduan Lengkap CMake. Bagian Dua: Membangun Sistem</a></li>
<li><a href="../id432098/index.html">Autopilots dalam transportasi jalan, bagaimana berinteraksi dengan spesial. dengan transportasi?</a></li>
<li><a href="../id432100/index.html">Bagaimana Kami Meningkatkan Konversi Penagihan</a></li>
<li><a href="../id432104/index.html">Digest Event IT Desember (Bagian Satu)</a></li>
<li><a href="../id432106/index.html">Intisari Desain Makanan, November 2018</a></li>
<li><a href="../id432108/index.html">Pendaftaran intensif terbuka untuk Kubernetes 1-3 Februari di St. Petersburg</a></li>
<li><a href="../id432110/index.html">Teknologi Web untuk Desainer - Membayar Utang</a></li>
<li><a href="../id432112/index.html">Intel XMM 8160 - modem 5G multi-mode universal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>