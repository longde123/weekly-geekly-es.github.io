<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòõ üïé üë©üèª‚Äç‚öñÔ∏è Turing-Maschine als Modell von Automatenprogrammen üéå ‚ôªÔ∏è ‚ô£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Turing-Maschine als Modell von Automatenprogrammen 
 1. Einleitung 
 Die Programmierung erfordert neue universelle algorithmische Modelle, und die Har...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turing-Maschine als Modell von Automatenprogrammen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481998/"><h2>  Turing-Maschine als Modell von Automatenprogrammen </h2><br><h3>  1. Einleitung </h3><br>  Die Programmierung erfordert neue universelle algorithmische Modelle, und die Hardware implementiert Algorithmen nicht nur in einer anderen Form, sondern auch auf der Grundlage eines anderen algorithmischen Modells - automatisch.  Die √úbernahme von Technologien aus dem Bereich der Hardwareentwicklung ist eine Schl√ºsselidee der automatisierten Programmierung.  Die Synthese digitaler Ger√§te unterscheidet sich jedoch von der Programmierung.  Ein Modell auszuleihen, ist einerseits nicht ratsam, es grundlegend zu √§ndern, andererseits kann man die bestehende Theorie und Praxis der Programmierung nicht ignorieren. <br><br>  Als n√§chstes betrachten wir die SWITCH-Technologie zum Entwerfen automatisierter Programme, in denen Sie st√§ndig auf solche Prozesse sto√üen.  Zum einen hat es das Zustandsmaschinenmodell so ver√§ndert, dass es tats√§chlich √ºber den Rahmen der Automatentheorie hinausging.  Zum anderen f√ºhrt es in Programmierkonzepte ein, die f√ºr Programmierer nur schwer erkennbar und mitunter einfach √ºberfl√ºssig sind, weil  Es gibt bekanntere Gegenst√ºcke aus der Programmtheorie und der Programmierpraxis. <br><br>  Als Grundlage f√ºr die Diskussion von Problemen der automatischen Programmierung nehmen wir den j√ºngsten Vortrag von A. Shalyto  [1] und seine ‚Äûprogrammatischen‚Äú Artikel zur Definition des Paradigmas der automatischen Programmierung [2, 3]. <br><a name="habracut"></a><br>  <b>1. Automatisierte Objekte, Programmschemata</b> <br><br>  Das Erreichen der automatischen Programmierung ist in der Vorlesung die Einf√ºhrung in das Konzept der automatisierten Steuerungsobjekte, das der Theorie der automatischen Steuerung (TAU) entlehnt ist.  Denken Sie jedoch daran, dass in der TAU nicht so viele Objekte, sondern Systeme betrachtet werden, von denen die folgenden unterschieden werden [4]: <br><br><img src="https://habrastorage.org/webt/zx/3w/k7/zx3wk7apg6vumkx6wkrhhorjrpg.jpeg" alt="Bild"><br><br>  Auf dieser Grundlage w√§re es richtiger, von automatischen Steuersystemen (ACS) zu sprechen.  Betrachten wir nun das typische Funktionsdiagramm der in Abb. 1 gezeigten selbstfahrenden Pistolen.  1. Wenn das Band der Turingmaschine als Steuerobjekt betrachtet wird, sind die Bet√§tigungsvorrichtungen (IS) MT-Elemente, die das √Ñndern des Bandinhalts und das Bewegen des Kopfes implementieren, und Messvorrichtungen (IS) sind die Elemente, die Informationen vom Band lesen. <br><br><img src="https://habrastorage.org/webt/mt/ns/y5/mtnsy5l-h2msdra8jmld6l_mn5i.jpeg" alt="Bild"><br>  <i>1.</i>  <i>Funktionsschema selbstfahrender Gesch√ºtze</i> <br><br>  Aber warum wenden Sie sich an die TAU, wenn es eine Praxis gibt, die der Programmierung des Entwurfs von Computersystemen n√§her kommt, bei der Betriebsger√§te (OS), zu denen nat√ºrlich auch MT geh√∂rt, als eine Kombination von Betriebs- (OA) und Steuerungsmaschinen (UA) betrachtet werden.  Und das ist n√§her an dem, was wir letztendlich anstreben - die Berechtigung der automatischen Programmierung.  In Abb.  2 zeigt einen Bildschirm mit Text aus einer Monographie von Mayorov S.A., Novikov G.I.  Die Struktur elektronischer Computer [5], in der die Designaspekte von Operationsverst√§rkern im Detail betrachtet werden. <br><br><img src="https://habrastorage.org/webt/fv/14/en/fv14ens27xhjytujiwia279csxq.jpeg" alt="Bild"><br>  <i>2.</i>  <i>Das Konzept des Managers und des Bedienens von Maschinen</i> <br><br>  Vergleicht man jedoch die Theorie des Computerdesigns und die Theorie der Programme, so l√§sst sich eine offensichtliche strukturelle Analogie zwischen ihnen feststellen.  In der Programmiertheorie kann das Modell jedes Programms auf struktureller Ebene als Programmschema S = (M, A, C) dargestellt werden, wobei M die Menge der Speicherelemente ist, A die Menge der Operatoren ist und C die Steuerung ist [10].  Nach diesem Ansatz kann jedes Turing-Maschinenprogramm auch als ein Programmschema definiert werden, bei dem die Menge M durch Bandzellen dargestellt wird, wobei die Menge der Operatoren durch MT-Aktionen mit 1) Zellanalyse, 2) √Ñndern von Zeichen in den Bandzellen und 3) Bewegen des Kopfes verbunden ist. <br><br>  Somit ist das Konzept eines Programmschemas v√∂llig analog zu dem betrachteten Konzept von Betriebs- und Steuerautomaten, wobei das Modell von UA ‚Äã‚Äãdas Modell der unten betrachteten strukturellen Finite-State-Maschine (SKA) ist und OA eine Struktur zum Ausf√ºhren von Aktionen auf Informationen ist.  In diesem Fall enth√§lt OA Datenspeicherelemente (oben ist der Speicher) und Bl√∂cke zur Verarbeitung von Informationen, die die Berechnung logischer Bedingungen und die Implementierung bestimmter Aktionen (oben - viele Operatoren) implementieren. <br><br>  Aus dem Vorstehenden kann verstanden werden, dass das Band nur bedingt als das Steuerobjekt f√ºr MT betrachtet werden kann.  Schon allein deshalb, weil das Steuerger√§t der Turingmaschine keinen direkten Zugriff darauf hat, weil  Alle Operationen mit Zellen werden indirekt durch OA-Bl√∂cke realisiert.  Dar√ºber hinaus scheint es nicht sehr vertraut oder, um es nicht zu sagen, seltsam zu sein, ein Objekt, das einen Speicher (ein Band) darstellt, als Ziel des Programmmanagements als ein Steuersystem zu betrachten. <br>  F√ºr eine formale Definition einer Turing-Maschine und in ihrem Kontext einen Platz f√ºr ein Finite-State-Machine-Modell reichen daher die Konzepte der Programmtheorie aus.  Im Gegensatz zu der sehr vagen Definition von Automatenprogrammen im Rahmen der SWITCH-Technologie kann man nun sagen, dass ein Automatenprogramm ein Programm ist, das die Kontrolle in Form eines endlichen Automatenmodells hat. <br><br>  Was wird das Programm selbst sein - mit einfachem oder komplexem Verhalten, was ist seine "Vielfalt" - mit logischer Kontrolle, "mit expliziter Zuweisung von Zust√§nden" usw.  usw.  spielt absolut keine rolle.  Die Hauptsache ist die Art des Managements.  Die √ºbrigen Elemente des Programms lassen sich √ºber einen weiten Bereich bestimmen - vom einfachsten wie zum Beispiel mit einer Turing-Maschine bis zum komplexesten - jede Form von Operatoren, Funktionen und Datenstrukturen von Programmiersprachen - Assembler, Hochsprache usw. <br><br>  Sie k√∂nnen sich auch daran erinnern, dass eine Turing-Maschine lange als automatische Matte [6] oder im Extremfall als einfache Erweiterung [7] galt.  Aber Sie m√ºssen verstehen, um welche Art von Automat es sich handelt, um welche Art von Erweiterung es sich handelt und ob sie den Modellen klassischer endlicher Automaten entsprechen.  Versuchen wir dies zu kl√§ren. <br><br>  <b>2. Programmierung in einer automatisierten Programmierumgebung</b> <br><br>  In Abb.  Abbildung 3 zeigt den Automaten f√ºr die MT-Inkrementfunktion aus der Monographie [8].  In der Form ist dies eindeutig kein MT-Programm, sondern bereits keine klassische Finite-State-Maschine.  In Abb.  Abbildung 4 zeigt den Graphen der klassischen strukturellen Finite-State-Maschine (SKA) und ihre Implementierung in der VKPa-Umgebung (die Umgebung der automatischen Programmierung visueller Komponenten in C ++ im Rahmen der Qt-Bibliothek und der Qt Creator-Umgebung), in der derselbe MT-Steuerger√§tealgorithmus implementiert ist. <br><br><img src="https://habrastorage.org/webt/6n/xv/rn/6nxvrne_9pugaykk9zhfxekzvju.jpeg" alt="Bild"><br>  <i>3.</i>  <i>Erh√∂hen Sie die Anzahl pro Einheit mit einer Turing-Maschine</i> <br><br><img src="https://habrastorage.org/webt/iq/fx/d2/iqfxd2lsiammfthsrdqcl3bkneo.jpeg" alt="Bild"><br>  <i>Abb. 4 Modell des Inkrementprogramms f√ºr MT in Form von SKA</i> <br><br>  Sie sehen, dass die Strukturmaschine vier Eingangs- und f√ºnf Ausgangskan√§le hat.  Jedem dieser Kan√§le ist eine gleichnamige Programmfunktion zugeordnet - ein Pr√§dikat oder eine Aktion.  In diesem Fall sind Pr√§dikate Funktionen ohne Parameter, die abh√§ngig vom Wert der angezeigten Bandzelle einen Booleschen Wert zur√ºckgeben, und Aktionen sind Funktionen ohne Parameter, die die eine oder andere Aktion ausf√ºhren, um die Bandzelle zu √§ndern und den Kopf der Turing-Maschine zu bewegen. <br><br>  Diese SKA hat den gleichen Satz von Zust√§nden wie der Automat in Fig. 3.  Zus√§tzlich zu der von SKA pr√§sentierten Automatenzuordnung selbst werden zwei weitere Zuordnungen implementiert: die Zuordnung der Menge von Pr√§dikaten (x1, ..., xM) zu der Menge von Eingangskan√§len derselben Maschine und die Menge von Ausgangskan√§len der Maschine zu der Menge derselben Aktionen - y1, ..., yN.  Beispielsweise gibt das Pr√§dikat x3 true zur√ºck (Wert 1 f√ºr das gleichnamige Eingangssignal), wenn die aktuelle Zelle eine 1 enth√§lt, und die Aktion y4, die ausgel√∂st wird, wenn dasselbe Ausgangssignal der Maschine den Wert 1 annimmt, entspricht dem Bewegen des Kopfes nach links (L) und etc.  usw. <br><br>  Beachten Sie, dass die SKA das Band nicht direkt steuert, sondern [zus√§tzliche] Zuordnungen implementiert, die die Signale des Automaten mit den Funktionen verkn√ºpfen, die die vielen Operationen der Turing-Maschine bestimmen.  Dies √ºberzeugt uns erneut davon, dass es nicht erforderlich ist, das Konzept eines automatisierten Steuerobjekts in einer Situation einzuf√ºhren, in der das ‚Äûaltmodische‚Äú, aber mathematisch strenge Mapping-Konzept ausreicht. <br><br>  Vergleich der Automaten in Abb.  3 und fig.  In 4 ist zu sehen, dass SKA den Befehl ‚Äû*‚Äú nicht verwendet (siehe 1).  In einer solchen Situation reicht es aus, dass er kein mit diesem Befehl verbundenes Signal ausgibt.  Au√üerdem sind zwei oder mehr Signale (sowohl Eingang als auch Ausgang) am selben √úbergang parallel.  Wenn daher ein Konflikt beim Zugriff auf gemeinsam genutzte Objekte besteht (z. B. m√ºssen Sie die Zelle wechseln und den Kopf bewegen), wird eine Vereinbarung verwendet: Aktionen f√ºr einen √úbergang werden nacheinander in der Reihenfolge ihrer Nummern ausgef√ºhrt, d. H.  Eine Aktion mit einer h√∂heren Nummer wird nach einer Aktion mit einer niedrigeren Nummer ausgef√ºhrt.  Diese Vereinbarung gilt nicht f√ºr Vergleichselemente wie  Sie wechseln das Band nicht.  So machen wir die Maschine kompakter und intuitiver (keine Notwendigkeit, Zwischenzust√§nde einzuf√ºhren). <br><br>  Beim Testen des Inkrementierungsprogramms wurden Situationen identifiziert, in denen Probleme w√§hrend des Betriebs des MT auftreten k√∂nnen.  Erstens ist das reale Band nicht unendlich, und wenn Sie dar√ºber hinausgehen, kann ein Programm abst√ºrzen.  Zweitens muss die Ausgangsposition des Kopfes angegeben werden.  Befindet sich zum Beispiel die Nummer an einer beliebigen Stelle des Bandes und befindet sich der Anfangszustand des Kopfes links von der Nummer und gegen√ºber dem Leerzeichen, beginnt der Kopf sofort, sich nach links zu bewegen.  Dann kann es √ºber die Grenzen des Bandes hinausgehen und das Programm zum ‚ÄûAbsturz‚Äú bringen. Wenn es einen Schritt nach links verschoben wird, schreibt es in Zelle 1 und schlie√üt den ‚Äûerfolgreichen‚Äú Vorgang ab.  Wenn die Zahl eine 1 in allen Ziffern enth√§lt und vom Bandanfang an geschrieben wird, f√ºhrt der letzte Versuch, eine 1 auf die √ºbergeordnete Ziffer zu √ºbertragen, zum gleichen ‚ÄûAbsturz‚Äú. <br><br>  <b>2.1.</b>  <b>Objektimplementierung von MT in C ++</b> <br><br>  Betrachten Sie die Implementierung der Objektsoftware einer Turing-Maschine in C ++ in der VKPa-Umgebung, die ein beliebiges Programm f√ºr MT implementiert, einschlie√ülich des Inkrementberechnungsprogramms. <br><br>  Zu diesem Zweck wurde eine Basisklasse erstellt, die jede Turing-Maschine darstellt, die von Softwareobjekten geerbt wird, die das eine oder andere MT-Programm implementieren.  Diese grundlegende Aufgabe wird in Listing 1 gezeigt, und das Programm, das die Inkrementierungsaufgabe implementiert, wird in Listing 2 gezeigt. <br><br>  Listing 1. Software-Implementierung der MT-Basisklasse <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> class FTuringMashine : public LFsaAppl { public: FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL); protected: int x15(); int x16(); void y14(); void y15(); void y16(); void y17(); QString strSrc; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    QString strTape; //  QString strHead; //  int nIndexHead{0}; //   bool bRestart{false}; //   int nHeadPosition{0}; //    }; #include "stdafx.h" #include "FTuringMashine.h" FTuringMashine::FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL): LFsaAppl(pTBL, strNam, nullptr, pCVFL) { nHeadPosition = 0; strHead = "________________________________________"; nIndexHead = nHeadPosition; } //============================================================== //  //  ? int FTuringMashine::x15() { return strTape[nIndexHead] == '#'; } // ? int FTuringMashine::x16() { return bRestart; } //============================================================== //  //      void FTuringMashine::y14() { strTape[nIndexHead] = '#'; } //    ( ) void FTuringMashine::y15() { nIndexHead++; } //    ( ) void FTuringMashine::y16() { nIndexHead--; } //     void FTuringMashine::y17() { strTape = strSrc; nIndexHead = 0; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre> <br>  Listing 2. Inkrementierungsprogramm f√ºr eine Turingmaschine <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTIncrement : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTIncrement(nameFsa, pCVarFsaLibrary); } FTIncrement(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); void y1(); void y2(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTIncrement.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TIncrement[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . . , .   , 2- , 2011 ., // .17-18 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= LArc(" ", " ", "^x1", "y15"), LArc(" ", " ", "x1", "y16"), LArc(" ", " ", "x2", "y2y16"), LArc(" ", "", "x1", "y1"), LArc(" ", "", "x3", "y1"), LArc("", " ", "x16", "y17"), LArc() }; FTIncrement::FTIncrement(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TIncrement) { strSrc = "11011110011111 "; strTape = strSrc; } //  int FTIncrement::x1() { return strTape[nIndexHead] == ' '; } int FTIncrement::x2() { return strTape[nIndexHead] == '1'; } int FTIncrement::x3() { return strTape[nIndexHead] == '0'; } //  void FTIncrement::y1() { strTape[nIndexHead] = '1'; } void FTIncrement::y2() { strTape[nIndexHead] = '0'; }</span></span></span></span></code> </pre><br>  <b>2.2.</b>  <b>Beispiele f√ºr Programme f√ºr MT mit Implementierung in C ++</b> <br><br>  Man betrachte ein Beispiel eines Programms f√ºr MT, das "als Sprachakzeptor fungiert, d. H.  es kann Sprache erkennen ‚Äúaus [9].  Seine √úbergangsfunktion ist in Abb.  5 und der √§quivalente Automat in Form von SKA in Fig.  6. <br><br><pre> <code class="plaintext hljs">Œ¥(1, a) = (2, x, R) Œ¥(1, y) = (4, y, R) Œ¥(2, a) = (2, a, R) Œ¥(2, y) = (2, y, R) Œ¥(2, b) = (3, y, L) Œ¥(3, y) = (3, y, L) Œ¥(3, a) = (3, a, R) Œ¥(3, x) = (1, x, R) Œ¥(4, y) = (4, a, R) Œ¥(4, #) = (F, #, L)</code> </pre> <br>  <i>Abb.</i>  <i>5. Die √úbergangsfunktion der Turingmaschine, die die Sprache erkennt {anbn: n‚â•1}</i> <br><br><img src="https://habrastorage.org/webt/z9/ab/hl/z9abhlvacupxhkbuzbfbupsmikq.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>6. SKA-Grafik einer Turingmaschine, die die Sprache erkennt {anbn: n‚â•1}</i> <br><br>  Das MT-Steuerger√§t in Form von SKA verf√ºgt √ºber 6 Eingangs- und 7 Ausgangskan√§le.  Das Akzeptorprogramm enth√§lt auch die entsprechende Anzahl von Pr√§dikaten und Aktionen, die in der Abbildung rechts neben dem Automatengraphen dargestellt sind.  Die Implementierung des C ++ - Programms in der VKPA-Umgebung ist in Listing 3 dargestellt. <br><br>  Listing 3. Programm f√ºr eine Turingmaschine, die die Sprache erkennt {anbn: n‚â•1} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> extern LArc TBL_TAcceptor[]; class FTAcceptor : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTAcceptor(nameFsa, pCVarFsaLibrary); } FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB = TBL_TAcceptor); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y18(); int nState{1}; friend class CDlgTAcceptor; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTAcceptor.h"</span></span></span><span class="hljs-meta"> LArc TBL_TAcceptor[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . .Ma  .   . 2013 ., //     , .304 //=====    ============== // f(1,a) = (2,x,R) f(1,y) = (4,y,R) // f(2,a) = (2,x,R) f(2,y) = (2,y,R) // f(2,b) = (2,x,R) f(3,y) = (3,y,L) // f(3,a) = (3,a,R) f(3,x) = (1,x,R) // f(4,y) = (4,a,R) f(4,#) = (F,#,L) //========================================= LArc("1", "2","x1", "y1y15"), // 1,a,2,x,R LArc("1", "4","x3", "y15"), // 1,y,4,R LArc("2", "2","x1", "y15"), // 2,a,2,R LArc("2", "3","x2", "y2y16"), // 2,b,3,y,L LArc("2", "2","x3", "y15"), // 2,y,2,R LArc("3", "3","x1", "y16"), // 3,a,3,L LArc("3", "3","x3", "y16"), // 3,y,3,L LArc("3", "1","x4", "y15"), // 3,x,1,R LArc("4", "4","x3", "y2y15"), // 4,y,4,a,R LArc("4", "F","x15", "-"), // 4,#,F,-,- LArc("F", "1","x16", "y17"), // LArc("1", "1","x16", "y17"), // LArc("2", "1","x16", "y17"), // LArc("3", "1","x16", "y17"), // LArc("4", "1","x16", "y17"), // // LArc("1", "1","--", "y18"), // LArc() }; FTAcceptor::FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB): FTuringMashine(strNam, pCVFL, pTB) { strSrc = "aaaaaaaaaabbbbbbbbbb#"; strTape = strSrc; } int FTAcceptor::x1() { return strTape[nIndexHead] == 'a'; } int FTAcceptor::x2() { return strTape[nIndexHead] == 'b'; } int FTAcceptor::x3() { return strTape[nIndexHead] == 'y'; } int FTAcceptor::x4() { return strTape[nIndexHead] == 'x'; } void FTAcceptor::y1() { strTape[nIndexHead] = 'x'; } void FTAcceptor::y2() { strTape[nIndexHead] = 'y'; } void FTAcceptor::y3() { strTape[nIndexHead] = 'a'; } void FTAcceptor::y18() { switch(nState) { case 1: if (x1()) { nState = 2; y1(); y5(); break; } if (x3()) { nState = 4; y5(); break; } break; case 2: if (x1()) { nState = 2; y5(); break; } if (x2()) { nState = 3; y2();y6(); break; } if (x3()) { nState = 2; y5(); break; } break; case 3: if (x1()) { nState = 3; y6(); break; } if (x3()) { nState = 3; y6(); break; } if (x4()) { nState = 1; y5(); break; } break; case 4: if (x3()) { nState = 4; y2(); y5(); break; } if (x5()) { nState = 5; break; } break; case 5: if (x6()) { y7(); nState = 1; break; } break; } }</span></span></span></span></code> </pre><br>  In Listing 3 repr√§sentiert die Aktion y18 eine Variante des MT-Programms gem√§√ü dem SWITCH-Technologie-Ansatz.  Im Rahmen der Implementierung der automatischen Programmierung der VKPA-Umgebung wird in diesem Fall anstelle des Automaten in Abb.  In 6 muss ein Automat mit einem Zustand implementiert werden, der im Zyklus ein Signal y18 ausgibt.  Es entspricht der auskommentierten Zeile der Konvertierungstabelle in Listing 3. Damit der Automat als SWICH arbeitet, m√ºssen Sie den Kommentar aus dieser Zeile entfernen und die verbleibenden Zeilen auskommentieren. <br><br>  Betrachten Sie ein weiteres Beispiel eines Programms f√ºr eine Turing-Maschine aus [7], in dem MT als ‚Äûsehr einfache Erweiterung eines Modells einer endlichen Maschine‚Äú definiert ist.  In diesem Fall ist das Programm f√ºr die Turingmaschine eine endliche Liste von F√ºnfern der teilweise definierten Funktion von √úberg√§ngen und Ausg√§ngen Œ¥: S √ó XÔÇÆS √ó X √ó G. <br><br>  Das MT-Programm, das den gr√∂√üten gemeinsamen Divisor (GCD) zweier Zahlen findet, ist in Abb. 2 dargestellt.  7. Das dazu √§quivalente SKA-Diagramm ist in Abb.  8. Beachten Sie, dass der Befehl zum Umschreiben auch hier nicht verwendet wird.  Die C ++ - Implementierung ist in Listing 4 dargestellt. <br><br><img src="https://habrastorage.org/webt/ce/zf/s_/cezfs_layjwqcyzmvo0vhqupkwk.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>7. Das √úbergangsdiagramm einer Turing-Maschine, die den GCD aus zwei Zahlen und mehreren ihrer Konfigurationen berechnet, wenn ein Zahlenpaar &lt;4, 6&gt; verarbeitet wird</i> <i><br></i> <br><img src="https://habrastorage.org/webt/_p/ai/vl/_paivlzhwtehlewnthhkcrpndba.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>8. Das SKA-Diagramm, das dem Diagramm in Abb.</i>  <i>7</i> <br><br>  Listing 4. Programm f√ºr eine Turingmaschine zum Auffinden des GCD aus zwei Zahlen <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTGrCmDiv: public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTGrCmDiv(nameFsa, pCVarFsaLibrary); } FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y17(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTGrCmDiv.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TGrCmDiv[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//=====     (Greatest Common Divider) ============== // . ..   , - .: , 2003. - 208 . // .194 // .  ..    . .:  , 1974, - 200. // .76, 84-87 LArc("s","s","x1", "y16"), // LArc("s","s","x2", "y16"), // LArc("s","p","x3", "y1"), // LArc("s","r","x15", "y15"), // LArc("p","p","x1", "y15"), // LArc("p","p","x2", "y15"), // LArc("p","s","x3", "y2"), // LArc("p","q","x15", "y16"), // LArc("q","q","x1", "y3y16"), // LArc("q","q","x2", "y14y16"), // LArc("q","s","x3", "y15"), // LArc("q","s","x15", "y15"), // LArc("r","r","x1", "y14y15"), // LArc("r","r","x2", "y3y15"), // LArc("r","s","x3", "y16"), // LArc("r","!","x15", "--"), // LArc("!","s","x16", "y17"), // LArc() }; FTGrCmDiv::FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TGrCmDiv) { nHeadPosition = 4; strSrc = "#1111111111## "; strTape = strSrc; nIndexHead = nHeadPosition; } int FTGrCmDiv::x1() { return strTape[nIndexHead] == 'a'; } int FTGrCmDiv::x2() { return strTape[nIndexHead] == 'b'; } int FTGrCmDiv::x3() { return strTape[nIndexHead] == '1'; } int FTGrCmDiv::x4() { return strTape[nIndexHead] == '#'; } void FTGrCmDiv::y1() { strTape[nIndexHead] = 'a'; } void FTGrCmDiv::y2() { strTape[nIndexHead] = 'b'; } void FTGrCmDiv::y3() { strTape[nIndexHead] = '1'; } void FTGrCmDiv::y17() { strTape = strSrc; nIndexHead = 4; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre><br>  Abschlie√üend ein weiteres MT-Programm der Entwickler der SWITH-Technologie, das im Artikel [11] behandelt wird und die Aufgabe darstellt, Klammern in zwei Versionen zu erkennen.  Eine ist in der Form einer Miley-Maschine, die zweite ist eine gemischte Maschine (jeweils in Fig. 9 und Fig. 11).  Die ihnen entsprechenden Strukturautomaten sind in Abb.  10 und fig.  12. Die Implementierung des C ++ - Programms ist in Listing 5 dargestellt. <br><br><img src="https://habrastorage.org/webt/z4/uk/_t/z4uk_t3un74er2osfmikfgmrhni.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>9. Erkennung von Klammern beliebiger Tiefe.</i>  <i>Meile Conversion Graph</i> <br><br><img src="https://habrastorage.org/webt/is/s6/mg/iss6mgjxclciek9s1az1t70oomg.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>10. Erkennung von Klammern beliebiger Tiefe.</i>  <i>Earl SKA Miles</i> <br><br><img src="https://habrastorage.org/webt/dp/xy/_k/dpxy_kpzxw59qwy2tu0_c_fhpz8.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>11. Erkennung von Klammern beliebiger Tiefe.</i>  <i>√úbergangsdiagramm eines gemischten Automaten</i> <br><br><img src="https://habrastorage.org/webt/un/ju/2h/unju2hogmmbwqr1zs4rnaxolbj4.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>12. Erkennung von Klammern beliebiger Tiefe.</i>  <i>SCA-Diagramm der √úberg√§nge eines gemischten Automaten</i> <br><br>  Listing 5. Programm f√ºr eine Turingmaschine zur Erkennung von Klammern <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTListing2 : public FTuringMashine { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTListing2(nameFsa, pCVarFsaLibrary); } FTListing2(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y4(); void y5(); int i{0}; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTListing2.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TListing2[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// .  ..,  ..     , , ‚Ññ2, .144-149 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= /* //  LArc("0", "1", "x2", "y2"), // '(';  LArc("0", "3", "x3", "--"), // '('; LArc("1", "1", "x2", "y2"), // '(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "3", "^x1x4", "--"), // i!=0;' ';  LArc("1", "3", "x1x3", "--"), // i==0;')';  LArc("1", "2", "x1x4", "--"), // i==0;' ';  LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  */ //* //   - LArc("0", "1", "x2", "y2"), // '(' LArc("0", "3", "x3", "--"), // ')' LArc("1", "1", "x2", "y2"), //'(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "2", "x1x4", "--"), // i==0;' '; LArc("1", "3", "^x1x4", "--"), // i!=0;' '; LArc("1", "3", "x1x3", "--"), // i==0;')'; LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  //*/ LArc() }; FTListing2::FTListing2(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TListing2) { strSrc = "(()()) "; strTape = strSrc; } //  int FTListing2::x1() { return i == 0; } int FTListing2::x2() { return strTape[nIndexHead] == '('; } // int FTListing2::x3() { return strTape[nIndexHead] == ')'; } // int FTListing2::x4() { return strTape[nIndexHead] == ' '; } // //  void FTListing2::y1() { i = 0; } // z1_0 void FTListing2::y2() { i++; } // z1_1 void FTListing2::y3() { i--; } // z1_2 void FTListing2::y4() { strTape = ""; } // z2_0 void FTListing2::y5() { strTape = ""; } // z2_1 void FTListing2::MooreAction() { string strState = FGetState(); if (strState=="0") { y1(); } //   else if (strState=="1") { y15(); } //    else if (strState=="2") { y4(); } //  else if (strState=="3") { y5(); } //  }</span></span></span></span></code> </pre><br>  Da der Automat in Abb.  12 weigerte sich zu arbeiten, es wurde beschlossen, an die Maschine in Abb.  9. Ein dazu √§quivalenter Automat in Form eines SKA ist in Abb. 9 dargestellt.  Dies ist zwar formal auch ein gemischter Automat, von dem das Signal im Zustand "0" und das Signal y15 im Zustand "1" von der ersten Implementierung √ºbrig geblieben sind (Fig. 12).  Die erste ist bei der Erstinstallation erforderlich, und das y15-Signal f√ºhrt eine Kopfverschiebung nach rechts durch, um das n√§chste Bandzeichen zu lesen.  Der Rest der SKA entspricht der Miles-Maschine in Abb.  9. <br><br>  Nach dem Automaten in Abb.  10 wurde erfolgreich getestet und an die Maschine in Abb.  11. Und es wurde klar, dass das Signal z1_1 mit dem Zustand "1" f√ºr ihn √ºberfl√ºssig ist (f√ºr den Automaten in Fig. 12 ist es das Signal y2).  Das Problem ist, dass er, wenn er die ‚Äûlinke Klammer‚Äú findet, den Z√§hler um zwei Einheiten erh√∂ht und wenn er die ‚Äûlinke Klammer‚Äú findet, √§ndert er sie √ºberhaupt nicht.  Wenn die ‚Äûlinke Klammer‚Äú erkannt wird, wird sie zweimal aufgerufen - einmal in der mit x2 / y2 gekennzeichneten Schleife und das zweite Mal beim Eintritt in den Status.  Und wenn eine ‚Äûrechte Klammer‚Äú erkannt wird, verringert sich der Z√§hler zuerst in der Schleife und erh√∂ht sich dann beim Eintritt in den Zustand. <br><br>  Der Grund f√ºr diese Arbeit der MT-Steuerung liegt in der falschen Interpretation der Funktionsweise einer Maschine vom Typ Moore durch die Autoren.  Anscheinend glauben sie, dass ein Signal mit einem Zustand am Moore-Automaten nur ausgef√ºhrt wird, wenn es in diesen Zustand √ºbergeht (siehe √úbergang von Zustand ‚Äû0‚Äú zu ‚Äû1‚Äú), aber tats√§chlich wird es jedes Mal ausgegeben, wenn Sie in diesen Zustand eintreten.  Einschlie√ülich beim Durchlaufen einer Schleife.  Es handelt sich also nicht um einen Fehler (wer hat sich nicht get√§uscht?), Sondern um ein gravierenderes Problem - eine Fehlinterpretation im Rahmen der SWITH-Funktionstechnologie von Moore-Automaten.  Das Testen des √§quivalenten Modells hat dies gezeigt. <br><br>  <b>3. Fazit</b> <br><br>  Zusammenfassend kann gesagt werden, dass es keine formalen Unterschiede zwischen Turing und der automatischen Programmierung gibt  Turing-Maschine ist ein abstraktes Modell von Automatenprogrammen.  Nur im letzteren Fall wird ein gr√∂√üerer Satz von Operatoren und Datenstrukturen (Speicher) verwendet.  Jetzt k√∂nnen wir mit Zuversicht die Frage beantworten, inwiefern sich die Post-Maschine als Modell gew√∂hnlicher Programme von der Turing-Maschine, dem Modell automatischer Programme, unterscheidet.  Managementmodell und nur es, weil  der Rest - der Speicher und die Operatoren k√∂nnen gleich sein. <br>  Folglich unterscheidet sich die normale Programmierung von der automatischen Programmierung nur in einer Sache - dem Steuerungsmodell.  W√§hrend also f√ºr die Implementierung von Automaten gew√∂hnliche Steueroperatoren des Schaltertyps verwendet werden und dergleichen nicht verwendet werden k√∂nnen, wird eine solche Programmierung streng genommen als automatisch angesehen.  Dies kann eine Nachahmung von Automaten mit dem Verlust ihrer spezifischen Eigenschaften sein und sonst nichts. <br><br>  Wenn wir also die Konzepte eines Automatenprogramms und einer Automatenprogrammierung definieren, m√ºssen wir nicht von ‚Äûautomatisierten Steuerungsobjekten‚Äú sprechen, sondern von Programmen und nur von Programmen, die eine Steuerung in Form einer klassischen endlichen Zustandsmaschine haben. <br>  Und noch eine interessante Tatsache, auf die ich aufmerksam machen m√∂chte.  In den fr√ºhen 2000er Jahren √§u√üerten die Autoren ihr Verst√§ndnis f√ºr automatisches Programmieren f√ºr ein breites Publikum.  Ihre Artikel √ºber abstrakte Maschinen wurden im PC World Magazin Nr. 2 von 2002 ver√∂ffentlicht [11, 12, 13].  Es kann argumentiert werden, dass im Laufe der Jahre die √úberzeugungen der Parteien nicht beeintr√§chtigt wurden.  Vielleicht spiegelt dies jedoch nur den Grad ihres Vertrauens in die gew√§hlten Entscheidungen wider. <br><br>  Zum Beispiel in ‚Äûeiner neuen Vorlesung √ºber automatisches Programmieren‚Äú von A. Shalyto  Im Vergleich zur vorherigen ‚ÄûVorlesung mit Folien‚Äú (vor zehn Jahren) wurde nur ein Video des Beispiels hinzugef√ºgt, das auf dem Stateflow ‚ÄûState-of-the-Art-Paket‚Äú basiert.  Es scheint, dass dies die Richtigkeit der Ideen von A. Shalyto best√§tigt, weil  Was in UniMod nicht implementiert werden konnte (das Projekt scheint "eingefroren" zu sein), verk√∂rperten die Entwickler von Stateflow.  Und wahrscheinlich ist es nicht so wichtig, wer es getan hat ... <br><br>  Zum Zeitpunkt der Ver√∂ffentlichung der genannten Artikel war den Autoren der SWITCH-Technologie jedoch bereits Kritik daran bekannt.  Dies war seitdem kein Geheimnis  es war auf der SoftCraft-Website verf√ºgbar [14].  Au√üerdem wurden Abschnitte erstellt, die der automatischen Programmierung im Allgemeinen und der SWITH-Technologie und der KA-Technologie im Besonderen gewidmet sind.  Die Positionen der Autoren wurden im Forum der Site diskutiert (es war zu dieser Zeit offen).  Aber alle blieben nicht √ºberzeugt. <br><br>  Die Ergebnisse sind im Moment wie folgt.  Die Kritik an der SWITH-Technologie ist aktuell und aktuell.  Dies gilt auch f√ºr das Stateflow-Paket.  In der SWITH-Technologie gab es keine und es gibt keine klare Definition der automatischen Programmierung, der Ansatz f√ºr die Implementierung von Automaten hat sich nicht ge√§ndert, das Modell selbst ist nicht klassisch, es gibt kein Parallel-Computing-Modell usw.  usw.  Ohne diese Probleme zu beseitigen, beansprucht eine solche automatisierte Programmierung bestenfalls eine ziemlich begrenzte Rolle. <br><br>  Die Gr√ºnde f√ºr die oben genannten Probleme liegen auf der Hand: Die Theorie der Programme wird ignoriert, die Theorie der Automaten wird vergessen, obwohl viele gute und korrekte Worte √ºber die Automaten selbst und ihre wunderbaren Eigenschaften gesprochen werden.  Tats√§chlich handelt es sich jedoch um andere Maschinen.  Der Autor ist √ºberzeugt von der Zweifelhaftigkeit schlecht durchdachter Versuche, originelle Modelle zu schaffen.  Es geht um synchrone, reaktive und andere Modelle.  Sie k√∂nnen beim L√∂sen einer engen Klasse von Problemen praktisch sein und nicht mehr.  Ernsthafter ist jedoch, dass sie aus der Theorie der Automaten herausfallen, ohne eine eigene Theorie zu haben.  Das Modell au√üerhalb der Theorie ist jedoch hilflos und daher praktisch bedeutungslos. <br><br><div class="spoiler">  <b class="spoiler_title">Referenzliste</b> <div class="spoiler_text">  1. Shalyto A. A. Eine neue Vorlesung √ºber automatische Programmierung.  2019, [Elektronische Ressource], Zugriffsmodus: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , kostenlos.  Yaz.  Russisch  (Datum der Behandlung 5. Dezember 2019). <br>  2. Shalyto A.A.  Das Paradigma der automatischen Programmierung.  Wissenschaftliches und technisches Bulletin der Staatlichen Universit√§t f√ºr Informationstechnologien, Mechanik und Optik St. Petersburg.  Vol.  53. Automatisierte Programmierung.  2008, p.  3-23. <br>  3. Shalyto A.A.  Das Paradigma der automatischen Programmierung.  Tagungsband der XI. Allrussischen Konferenz f√ºr Wissenschaft und Hochschulbildung "Grundlagenforschung und Innovation an technischen Universit√§ten".  SPbSPU.  2007, p.  202‚Äì205., [Elektronische Ressource], Zugriffsmodus: <a href="http://is.ifmo.ru/works/_2007_09_27_shalyto.pdf" rel="nofollow">is.ifmo.ru/works/_2007_09_27_shalyto.pdf</a> , kostenlos.  Yaz.  Russisch  (Datum der Behandlung 5. Dezember 2019). <br>  4. Miroshnik I.V.  Theorie der automatischen Steuerung.  Lineare Systeme.  - St. Petersburg: Peter, 2005 .-- 336 p. <br>  5. Mayorov S.A., Novikov G.I.  Die Struktur elektronischer Computer.  - L .: Engineering, 1979. - 384 p. <br>  6. Minsky M. Berechnungen und Automaten.  M .: Mir, 1971. - 364 p. <br>  7. Karpov Yu.G.  Theorie der Automaten.  - St. Petersburg: Peter, 2003 .-- 208 p. <br>  8. Polikarpova N., A. Shalyto A. Automatisierung.  2nd ed., St. Petersburg.: Peter, 2011 .-- 176 p. <br>  9. J. MacConell-Analyse von Algorithmen.  Aktiver Lernansatz.  3. Auflage.  - M .: Technosphere, 2013 .-- 415 p. <br>  10. Algorithmen, Software und Architektur von Multiprozessor-Computersystemen.  M .: Nauka, 1982, - 336s. <br>  11. Shalyto A.A., Tukkel N.I.  Vom Turing-Programmieren zum automatischen // MirPK.  Nr. 2.  <a href="http://is.ifmo.ru/%3Fi0%3Dworks%26i1%3Dturing" rel="nofollow">is.ifmo.ru/?i0=works&amp;i1=turing</a> <br>  12. Lyubchenko V.S.  Experimente an abstrakten Maschinen.  "PC World", Nr. 2,3 / 02.  <a href="https://www.osp.ru/pcworld/2002/02/162923/" rel="nofollow">www.osp.ru/pcworld/2002/02/162923</a> , <a href="https://www.osp.ru/pcworld/2002/03/163137/" rel="nofollow">www.osp.ru/pcworld/2002/03/163137</a> <br>  13. Lyubchenko V.S.  Von einer Turingmaschine zu einem Miley-Auto.  "PC World", Nr. 8/02.  <a href="http://www.osp.ru/pcworld/2002/08/163856/" rel="nofollow">www.osp.ru/pcworld/2002/08/163856</a> <br>  14. SoftCraft-Website.  Verwendung der Automatentheorie in der Programmierung.  [Elektronische Ressource], Zugriffsmodus: <a href="http://www.softcraft.ru/auto/" rel="nofollow">www.softcraft.ru/auto</a> , kostenlos.  Yaz.  Russisch  (Datum der Behandlung 5. Dezember 2019). <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481998/">https://habr.com/ru/post/de481998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481980/index.html">Wie wir Skripte in Unity optimiert haben</a></li>
<li><a href="../de481988/index.html">Warum ist Koji die perfekte Ressource f√ºr Anf√§nger KaiOS App-Ersteller</a></li>
<li><a href="../de481990/index.html">Zehn Jahre Malware: 2010 die gr√∂√üten Botnets</a></li>
<li><a href="../de481992/index.html">Tekton-Pipeline - Kubernetes-native Pipelines</a></li>
<li><a href="../de481996/index.html">Habra Detektiv am Wochenende 2. Neues Level</a></li>
<li><a href="../de482000/index.html">Magst du dein Gesch√§ft?</a></li>
<li><a href="../de482002/index.html">Erstellen eines Microservice-Blogs - Teil 3 ‚ÄûBenutzer‚Äú</a></li>
<li><a href="../de482004/index.html">Wir testen 1C auf dem VPS Server</a></li>
<li><a href="../de482008/index.html">LEGO Konstruktor und absolute Null</a></li>
<li><a href="../de482010/index.html">"Neue Epen". F√ºr Entwickler, Ops und Neugierige</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>