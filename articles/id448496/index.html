<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴 🚪 🎅🏽 .NET Core di Linux, DevOps dengan menunggang kuda 🚩 🐌 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami mengembangkan DevOps semampu kami. Ada 8 dari kita, dan Vasya adalah yang paling keren di Windows. Tiba-tiba, Vasya pergi, dan aku punya tugas un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET Core di Linux, DevOps dengan menunggang kuda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448496/">  Kami mengembangkan DevOps semampu kami.  Ada 8 dari kita, dan Vasya adalah yang paling keren di Windows.  Tiba-tiba, Vasya pergi, dan aku punya tugas untuk mengeluarkan proyek baru yang memasok pengembangan Windows.  Ketika saya menuangkan seluruh tumpukan pengembangan Windows ke atas meja, saya menyadari bahwa situasinya menyakitkan ... <br><br>  Maka mulailah kisah <b>Alexander Sinchinov</b> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf</a> .  Ketika spesialis Windows terkemuka meninggalkan perusahaan, Alexander bertanya-tanya apa yang harus dilakukan sekarang.  Beralih ke Linux, tentu saja!  Alexander akan memberi tahu bagaimana ia mengatur preseden dan mentransfer bagian dari pengembangan Windows ke Linux menggunakan contoh proyek yang telah selesai untuk 100.000 pengguna akhir. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e76/321/dcde7632138481f5c01f851d9af8e2e2.png"><br><br>  Bagaimana dengan mudah dan mudah mengirimkan proyek ke RPM menggunakan TFS, Puppet, Linux .NET core?  Bagaimana mempertahankan versi database proyek jika pengembangan pertama kali mendengar kata-kata Postgres dan Flyway, dan batas waktu lusa?  Bagaimana cara mengintegrasikan dengan Docker?  Bagaimana memotivasi pengembang .NET untuk meninggalkan Windows dan smoothie demi Puppet dan Linux?  Bagaimana mengatasi konflik ideologis, jika tidak ada kekuatan, tidak ada keinginan, tidak ada sumber daya untuk melayani Windows dalam produksi?  Tentang ini, serta tentang Penyebaran Web, pengujian, CI, tentang praktik menggunakan TFS dalam proyek yang ada, dan, tentu saja, tentang kruk yang rusak dan solusi kerja, dalam memecahkan kode laporan Alexander. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZH9Ro9j9KQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jadi, Vasya pergi, tugasnya untuk saya, para pengembang menantikan <s>dengan garpu rumput</s> .  Ketika saya akhirnya menyadari bahwa Vasya tidak dapat dikembalikan, saya mulai berbisnis.  Untuk mulai dengan, saya memperkirakan persentase Win VM di taman kami.  Skor itu tidak mendukung Windows. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/3d8/061/fa73d80617e31117f8c2575cc747a17b.png"><br><br>  Karena kami secara aktif mengembangkan DevOps, saya menyadari bahwa ada sesuatu yang perlu diubah dalam pendekatan mengambil aplikasi baru.  Solusinya adalah satu - jika mungkin, transfer semuanya ke Linux.  Google membantu saya - pada waktu itu. Net sudah porting ke Linux, dan saya menyadari bahwa solusi ini! <br><br><h2>  Mengapa .NET core dibundel dengan Linux? </h2><br>  Ada beberapa alasan untuk ini.  Antara "bayar uang" dan "jangan bayar", mayoritas akan memilih yang kedua - seperti saya.  Lisensi untuk MSDB harganya sekitar $ 1.000, pemeliharaan armada mesin virtual Windows harganya ratusan dolar.  Untuk perusahaan besar itu adalah pengeluaran besar.  Karena itu, <b>menabung</b> adalah <b>alasan pertama</b> .  Bukan yang paling penting, tetapi salah satu yang paling penting. <br><br>  Mesin virtual Windows membutuhkan lebih banyak sumber daya daripada saudara-saudara Linux <b>mereka</b> - <b>mereka berat</b> .  Mengingat skala perusahaan besar, kami memilih Linux. <br><br>  <b>Sistem ini hanya diintegrasikan ke dalam CI yang ada</b> .  Kami menganggap diri kami sebagai DevOps progresif, kami menggunakan Bamboo, Jenkins dan GitLab CI, sehingga sebagian besar pekerjaan kami adalah di Linux. <br><br>  Alasan terakhir adalah <b>pengawalan yang nyaman.</b>  Kami harus menurunkan ambang masuk untuk "pengawalan" - orang yang memahami bagian teknis, memastikan operasi dan layanan layanan tanpa gangguan dari baris kedua.  Mereka sudah terbiasa dengan tumpukan Linux, sehingga jauh lebih mudah bagi mereka untuk memahami produk baru, memelihara dan memelihara, daripada menghabiskan sumber daya tambahan untuk menangani fungsionalitas yang sama dari perangkat lunak untuk platform Windows. <br><br><h2>  Persyaratan </h2><br>  Pertama dan terpenting, <b>kenyamanan solusi baru untuk pengembang</b> .  Tidak semua dari mereka siap untuk berubah, terutama setelah kata yang diucapkan Linux.  Pengembang menginginkan Visual Studio tercinta mereka, TFS dengan tes build dan smoothie.  Bagaimana pengiriman terjadi dalam produksi - mereka tidak peduli.  Oleh karena itu, kami memutuskan untuk tidak mengubah proses yang biasa dan membiarkan semuanya tidak berubah untuk pengembangan Windows. <br><br>  Proyek baru perlu <b>tertanam dalam CI yang ada</b> .  Rel sudah ada di sana dan semua pekerjaan harus dilakukan dengan mempertimbangkan parameter sistem manajemen konfigurasi, standar pengiriman yang diterima, dan sistem pemantauan. <br><br>  <b>Kesederhanaan dalam dukungan dan operasi</b> , sebagai syarat untuk ambang masuk minimum untuk semua peserta baru dari berbagai departemen dan departemen dukungan. <br><br>  <b>Batas waktu - kemarin</b> . <br><br><h2>  Menangkan Kelompok Pengembangan </h2><br>  Apa yang bekerja dengan tim Windows saat itu? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/527/4b9/5e9/5274b95e93a6d270259487b5c68ca600.png"><br><br>  Sekarang saya dapat dengan yakin mengatakan bahwa <b>IdentityServer4</b> adalah alternatif bebas keren untuk ADFS dengan kemampuan serupa, atau bahwa <b>Entity Framework Core</b> adalah surga pengembang di mana Anda tidak dapat repot menulis skrip SQL, tetapi jelaskan kueri dalam database dalam istilah OOP.  Tapi kemudian, ketika membahas rencana aksi, saya melihat tumpukan ini sebagai tulisan rune Sumeria yang hanya mengenali PostgreSQL dan Git. <br><br>  Pada saat itu, kami secara aktif menggunakan <b>Puppet</b> sebagai sistem manajemen konfigurasi.  Dalam sebagian besar proyek kami, kami menggunakan <b>GitLab CI</b> , <b>Elastis</b> , layanan seimbang yang sangat dimuat menggunakan <b>HAProxy,</b> memantau semuanya dengan <b>Zabbix</b> , sekelompok <b>Grafana</b> dan <b>Prometheus</b> , <b>Jaeger</b> , dan semua ini berputar pada perangkat keras <b>HP</b> dengan <b>ESXi</b> pada <b>VMware</b> .  Semua orang tahu - klasik genre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffb/768/38f/ffb76838f0538bd215bc5a54d5e005ad.png"><br><br>  Mari kita lihat dan coba pahami apa yang terjadi sebelum kita memulai semua intervensi ini. <br><br><h2>  Apa itu </h2><br>  TFS adalah sistem yang cukup kuat yang tidak hanya mengirimkan kode dari pengembang ke mesin produksi akhir, tetapi juga memiliki satu set untuk integrasi yang sangat fleksibel dengan berbagai layanan - untuk memberikan CI pada level lintas platform. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b7/9a3/146/9b79a3146abb65be1c4dad29ad50e406.png"><br>  Sebelumnya, ini adalah jendela padat.  TFS menggunakan beberapa agen Build, yang mengumpulkan banyak proyek.  Setiap agen memiliki 3-4 pekerja-a untuk memparalelkan tugas dan mengoptimalkan proses.  Selanjutnya, sesuai dengan rencana rilis, TFS mengirimkan Build yang baru dipanggang ke server aplikasi Windows. <br><br><h2>  Apa yang kami inginkan </h2><br>  Untuk pengiriman dan pengembangan, kami menggunakan TFS, dan kami meluncurkan aplikasi pada server Aplikasi Linux, dan ada beberapa jenis keajaiban di antara mereka.  <b>Kotak Ajaib</b> ini adalah garam dari pekerjaan yang akan datang.  Sebelum membongkar sebagian, saya akan mengambil langkah ke samping dan mengatakan dua kata tentang aplikasi. <br><br><h2>  Proyek </h2><br>  Aplikasi ini menyediakan fungsionalitas untuk menangani kartu prabayar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c2/3be/4cc/4c23be4cce98ad3b48de986826817c19.png"><br><br><h3>  Klien </h3><br>  Ada dua jenis pengguna.  <b>Yang pertama</b> mendapat akses dengan masuk dengan sertifikat SSL SHA-2.  Yang <b>kedua</b> memiliki akses dengan login dan kata sandi. <br><br><h3>  HAProxy </h3><br>  Selanjutnya, permintaan klien jatuh ke dalam HAProxy, yang menyelesaikan tugas-tugas berikut: <br><br><ul><li>  otorisasi utama; <br></li><li>  Pengakhiran SSL <br></li><li>  pencarian permintaan HTTP; <br></li><li>  permintaan siaran. <br></li></ul><br>  Verifikasi sertifikat klien melewati rantai.  Kami adalah <b>otoritas</b> dan kami mampu membelinya, karena kami sendiri mengeluarkan sertifikat untuk melayani pelanggan. <br><br>  Perhatikan poin ketiga, sebentar lagi kita akan kembali ke sana. <br><br><h3>  Backend </h3><br>  Mereka berencana membuat backend di Linux.  Backend berinteraksi dengan database, memuat daftar hak istimewa yang diperlukan dan kemudian, tergantung pada hak istimewa apa yang dimiliki oleh pengguna yang berwenang, menyediakan akses untuk menandatangani dokumen keuangan dan mengirimkannya untuk dieksekusi, atau menghasilkan semacam laporan. <br><br><h2>  Menyimpan dengan HAProxy </h2><br>  Selain dua konteks yang digunakan oleh setiap klien, ada juga konteks identitas.  <b>IdentityServer4</b> hanya memungkinkan Anda untuk masuk, ini adalah analog yang kuat dan gratis untuk <b>ADFS</b> - <b>Active Directory Federation Services</b> . <br><br>  Permintaan identitas diproses dalam beberapa langkah.  Langkah pertama - <b>klien</b> <b>jatuh ke backend</b> , yang bertukar data dengan server ini dan memeriksa keberadaan token untuk klien.  Jika saya tidak menemukannya, permintaan kembali ke konteks dari mana asalnya, tetapi dengan pengalihan, dan dengan pengalihan pergi ke identitas. <br><br>  Langkah kedua - permintaan pergi <b>ke halaman otentikasi di IdentityServer,</b> tempat klien terdaftar, dan token yang sangat lama ditunggu-tunggu muncul di database IdentityServer. <br><br>  Langkah ketiga - <b>klien diarahkan kembali</b> ke konteks dari mana dia datang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ead/cc3/039/eadcc3039f4585956ccf9d25512a4370.png"><br><br>  IdentityServer4 memiliki kekhasan: <b>mengembalikan respons terhadap permintaan pengembalian melalui HTTP</b> .  Tidak peduli bagaimana kami berjuang dengan pengaturan server, tidak peduli bagaimana kami menjadi tercerahkan dengan dokumentasi, setiap kali kami menerima permintaan klien awal dengan URL yang datang melalui HTTPS, dan IdentityServer mengembalikan konteks yang sama, tetapi dengan HTTP.  Kami kaget!  Dan semua ini ditransfer melalui konteks identitas ke HAProxy, dan di header kami harus memodifikasi protokol HTTP ke HTTPS. <br><br>  Apa perbaikannya dan di mana mereka menyimpan? <br><br><blockquote>  Kami menghemat uang dengan menggunakan solusi gratis untuk mengotorisasi sekelompok pengguna, sumber daya, karena kami tidak menggunakan IdentityServer4 sebagai catatan terpisah di segmen terpisah, tetapi menggunakannya bersama dengan backend di server yang sama di mana aplikasi backend berputar. </blockquote><br><h2>  Bagaimana cara kerjanya </h2><br>  Jadi, seperti yang saya janjikan - Kotak Ajaib.  Kami sudah mengerti bahwa kami dijamin akan pindah ke Linux.  Mari kita merumuskan tugas-tugas spesifik yang membutuhkan solusi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59b/f2c/bde/59bf2cbdeb581a1e53cea2dabfbd4aca.png"><br><br>  <b>Manifestasi wayang.</b>  Untuk mengirim dan mengelola konfigurasi layanan dan aplikasi, Anda harus menulis resep keren.  Gulungan pensil dengan fasih menunjukkan seberapa cepat dan efisien hal ini dilakukan. <br><br>  <b>Metode pengiriman.</b>  Standarnya adalah RPM.  Semua orang mengerti bahwa di Linux tidak ada jalan tanpa itu, tetapi proyek itu sendiri setelah perakitan adalah satu set file DLL yang dapat dieksekusi.  Ada sekitar 150 di antaranya, proyeknya cukup sulit.  Satu-satunya solusi harmonis adalah mengemas binari ini ke dalam RPM dan menyebarkan aplikasi darinya. <br><br>  <b>Versi</b>  Kami harus merilis sangat sering, dan kami harus memutuskan bagaimana membentuk nama paket.  Ini adalah masalah tingkat integrasi TFS.  Kami memiliki agen pembangun di Linux.  Ketika TFS mengirimkan tugas ke pawang - pekerja - ke agen Bangun, itu juga mengirimkan sekelompok variabel yang jatuh ke lingkungan proses pawang.  Variabel lingkungan ini meneruskan nama Build, nama versi, dan variabel lainnya.  Baca lebih lanjut tentang ini di bagian "Merakit Paket RPM". <br><br>  <b>Menyiapkan TFS datang</b> untuk mengatur Pipeline.  Sebelumnya, kami mengumpulkan semua proyek Windows pada agen Windows, dan sekarang ada agen Linux - agen Build yang perlu dimasukkan dalam kelompok perakitan, diperkaya dengan beberapa artefak, memberi tahu jenis proyek apa yang akan dibangun pada agen Build ini, dan entah bagaimana memodifikasi Pipeline. <br><br>  <b>IdentityServer.</b>  ADFS bukan jalan kami, kami tenggelam untuk Open Source. <br><br>  Mari kita lihat komponen-komponennya. <br><br><h2>  Kotak ajaib </h2><br>  Terdiri dari empat bagian. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/737/6ef/bb5/7376efbb54d21a0dcc88f191b70dfe9f.png"><br><br>  <b>Linux build agent.</b>  Linux, karena kami mengompilasinya, adalah logis.  Bagian ini dilakukan dalam tiga langkah. <br><br><ul><li>  <b>Konfigurasikan pekerja</b> dan lebih dari satu, karena diasumsikan didistribusikan pekerjaan pada proyek. <br></li><li>  <b>Instal .NET Core 1.x.</b>  Mengapa 1.x ketika 2.0 sudah tersedia di repositori standar?  Karena ketika kami memulai pengembangan, versi stabil adalah 1.09, dan diputuskan untuk melakukan proyek untuk itu. <br></li><li>  <b>Git 2.x.</b> <br></li></ul><br>  <b>Repositori RPM.</b>  Paket RPM perlu disimpan di suatu tempat.  Diasumsikan bahwa kita akan menggunakan repositori RPM korporat yang sama yang tersedia untuk semua host Linux.  Dan begitulah yang mereka lakukan.  Sebuah <b>webhook</b> dikonfigurasi pada server repositori yang mengunduh paket RPM yang diperlukan dari lokasi yang ditentukan.  Versi paket dilaporkan ke webhook oleh agen Build. <br><br>  <b>Gitlab</b>  Perhatian!  GitLab digunakan di sini bukan oleh pengembang, tetapi oleh departemen operasi untuk mengontrol versi aplikasi, versi paket, memantau status semua mesin Linux dan menyimpan resep - semua manifes wayang. <br><br>  <b>Wayang</b> - menyelesaikan semua masalah kontroversial dan memberikan konfigurasi persis seperti yang kita inginkan dari Gitlab. <br><br>  Kami mulai menyelam.  Bagaimana DLL disampaikan dalam RPM? <br><br><h3>  Pengiriman DDL ke RPM </h3><br>  Katakanlah kita memiliki bintang rock untuk pengembangan .NET.  Ini menggunakan Visual Studio dan membuat cabang rilis.  Setelah itu memuatnya ke Git, dan Git di sini adalah entitas TFS, yaitu, repositori aplikasi tempat pengembang bekerja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1fd/fcd/8db/1fdfcd8dbe8f5395907ce2e5ec450539.png"><br><br>  Setelah itu TFS melihat bahwa komit baru telah tiba.  Aplikasi yang mana?  Dalam pengaturan TFS ada label tentang sumber daya apa yang dimiliki agen Build tertentu.  Dalam hal ini, ia melihat bahwa kami sedang membangun proyek .NET Core dan memilih agen pembangun Linux dari kumpulan. <br><br>  Agen build menerima sumber, mengunduh <b>dependensi yang</b> diperlukan dari .NET, repositori npm, dll.  dan setelah membangun aplikasi itu sendiri dan pengemasan selanjutnya, ia mengirimkan paket RPM ke repositori RPM. <br><br>  Di sisi lain, berikut ini terjadi.  Insinyur pemeliharaan terlibat langsung dalam meluncurkan proyek: ia mengubah versi paket di <b>Hiera</b> di repositori tempat resep aplikasi disimpan, setelah itu Wayang memicu <b>Yum</b> , mengambil paket baru dari repositori, dan versi baru aplikasi siap digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/135/3dd/9ae/1353dd9ae0bf83bd4527ceaa8f4db1ee.png"><br><br>  Dengan kata lain, semuanya sederhana, tetapi apa yang terjadi di dalam pada agen Build itu sendiri? <br><br><h3>  Pengemasan RPM DLL </h3><br>  Sumber proyek dan tugas pembangunan dari TFS diterima.  Agen pembuat <b>mulai membangun proyek dari sumber</b> .  Proyek rakitan tersedia dalam bentuk banyak <b>file DLL</b> yang dikemas dalam arsip zip untuk mengurangi beban pada sistem file. <br><br>  Arsip ZIP dilemparkan <b>ke direktori build paket RPM.</b>  Selanjutnya, skrip Bash menginisialisasi variabel lingkungan, menemukan versi Build, versi proyek, path ke direktori build, dan meluncurkan RPM-build.  Pada akhir perakitan, paket diterbitkan ke <b>repositori lokal</b> , yang terletak di agen Build. <br><br>  Selanjutnya, <b>permintaan JSON dikirim</b> dari agen Build ke server di repositori RPM dengan nama versi dan build.  Webhook, tentang yang saya bicarakan sebelumnya, mengunduh paket yang sama ini dari repositori lokal pada agen Build dan membuat perakitan baru tersedia untuk instalasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44c/9a5/b5c/44c9a5b5c05b30293723eec126e0ff24.png"><br><br>  Mengapa skema untuk mengirimkan paket ke repositori RPM?  Mengapa saya tidak bisa langsung mengirim paket yang sudah dirakit ke repositori?  Faktanya adalah ini adalah syarat untuk keamanan.  Skenario ini membatasi kemungkinan pengunduhan paket RPM oleh orang luar ke server yang dapat diakses oleh semua mesin Linux. <br><br><h2>  Versi DB </h2><br>  Pada konsultasi dengan pengembangan, ternyata orang-orang lebih dekat dengan MS SQL, tetapi di sebagian besar proyek non-Windows kami sudah menggunakan PostgreSQL dengan kekuatan dan utama.  Karena kami sudah memutuskan untuk meninggalkan semua yang dibayar, kami mulai menggunakan PostgreSQL di sini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9c/e1a/815/a9ce1a81549ee0de97167823755f9b25.png"><br><br>  Pada bagian ini saya ingin berbicara tentang bagaimana kami mengimplementasikan versi database dan bagaimana memilih antara Flyway dan Entity Framework Core.  Pertimbangkan pro dan kontra mereka. <br><br><h3>  Cons </h3><br>  Flyway hanya berjalan satu arah, kami <b>tidak dapat memutar kembali</b> - ini adalah minus yang signifikan.  Perbandingan dengan Entity Framework Core dapat dilakukan sesuai dengan parameter lain - dari sudut pandang kenyamanan pengembang.  Anda ingat kami menempatkan ini sebagai yang terdepan, dan kriteria utama adalah tidak mengubah apa pun untuk pengembangan Windows. <br><br>  Untuk Flyway, kami <b>membutuhkan semacam pembungkus</b> sehingga orang-orang tidak menulis <b>pertanyaan SQL</b> .  Mereka jauh lebih dekat untuk beroperasi dalam hal OOP.  Kami menulis instruksi untuk bekerja dengan objek database, membentuk kueri SQL dan dieksekusi.  Versi baru dari database siap, digulung - semuanya baik-baik saja, semuanya berfungsi. <br><br>  Entity Framework Core memiliki minus - di bawah beban berat itu <b>membangun query SQL tidak optimal</b> , dan penarikan database bisa signifikan.  Tetapi karena kami tidak memiliki layanan beban tinggi, kami tidak menghitung beban dengan ratusan RPS, kami mengambil risiko ini dan mendelegasikan masalah ke masa depan kami. <br><br><h3>  Pro </h3><br>  Entity Framework Core <b>bekerja di luar kotak dan mudah dikembangkan</b> , dan Flyway <b>terintegrasi dengan mulus ke CI yang ada</b> .  Tapi kami melakukannya dengan nyaman untuk pengembang :) <br><br><h3>  Prosedur roll-up </h3><br>  Wayang melihat bahwa ada perubahan dalam versi paket di antaranya yang bertanggung jawab untuk migrasi.  Pertama, ia menginstal paket yang berisi skrip migrasi dan fungsionalitas yang terkait dengan database.  Setelah itu, aplikasi yang berfungsi dengan database di-restart.  Selanjutnya adalah pemasangan komponen yang tersisa.  Urutan paket yang diinstal dan aplikasi diluncurkan dijelaskan dalam manifes Wayang. <br><br>  Aplikasi menggunakan data sensitif, seperti token, kata sandi ke database, semua ini ditarik ke dalam konfigurasi dengan master Wayang, di mana mereka disimpan dalam bentuk terenkripsi. <br><br><h2>  Masalah TFS </h2><br>  Setelah kami memutuskan dan menyadari bahwa semuanya benar-benar bekerja untuk kami, saya memutuskan untuk melihat apa yang terjadi dengan majelis di TFS secara keseluruhan untuk departemen Win-development untuk proyek-proyek lain - dengan cepat atau tidak, kami akan / melepaskan, dan menemukan masalah signifikan dengan kecepatan . <br><br>  Salah satu proyek utama akan memakan waktu 12-15 menit - ini adalah waktu yang lama, Anda tidak bisa hidup seperti itu.  Analisis cepat menunjukkan drawdown mengerikan pada I / O, dan ini pada array. <br><br>  Setelah menganalisis secara komponen, saya mengidentifikasi tiga fokus.  Yang pertama adalah <b>antivirus Kaspersky</b> , yang memindai kode sumber pada semua agen Windows Build.  Yang kedua adalah <b>Windows</b> <b>Indexer.</b>  Itu tidak terputus, dan pada agen Build secara real time semuanya diindeks selama proses penyebaran. <br><br>  Yang ketiga adalah <b>instalasi Npm.</b>  Ternyata di sebagian besar Pipeline kami menggunakan skenario khusus ini.  Kenapa dia jahat?  Prosedur instalasi Npm dimulai ketika pohon dependensi dibentuk di <b>package-lock.json</b> , di mana versi paket yang akan digunakan untuk membangun proyek diperbaiki.  Yang minus adalah bahwa instalasi Npm menarik versi terbaru paket-paket dari Internet setiap kali, dan ini adalah waktu yang cukup besar dalam kasus proyek besar. <br><br><blockquote>  Pengembang kadang-kadang bereksperimen dengan mesin lokal untuk menguji operasi bagian individu atau proyek secara keseluruhan.  Kadang-kadang ternyata secara lokal semuanya keren, tetapi berkumpul, diluncurkan - tidak ada yang berhasil.  Kami mulai memahami apa masalahnya - ya, berbagai versi paket dependensi. </blockquote><br><h3>  Solusi </h3><br><ul><li>  Sumber untuk pengecualian AV. <br></li><li>  Menonaktifkan pengindeksan. <br></li><li>  Beralih ke <b>npm ci</b> . <br></li></ul><br>  Keuntungan dari npm ci adalah bahwa kami <b>mengumpulkan pohon dependensi satu kali</b> , dan mendapatkan kesempatan untuk menyediakan pengembang dengan <b>daftar paket terbaru</b> yang ia dapat bereksperimen secara lokal sebanyak yang ia inginkan.  Ini <b>menghemat waktu untuk</b> pengembang yang menulis kode. <br><br><h3>  Konfigurasi </h3><br>  Sekarang sedikit tentang konfigurasi repositori.  Secara historis, kami telah menggunakan <b>Nexus</b> untuk mengelola repositori, termasuk <b>REPO Internal</b> .  Semua komponen yang kami gunakan untuk tujuan internal, misalnya, pemantauan yang ditulis sendiri, dikirimkan ke repositori internal ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25d/4d9/204/25d4d920402193190f95e0783f31fc04.png"><br><br>  Kami juga menggunakan <b>NuGet</b> , karena cache lebih baik daripada manajer paket lainnya. <br><br><h3>  Hasil </h3><br>  Setelah kami mengoptimalkan agen Build, waktu rata-rata build berkurang dari 12 menit menjadi 7. <br><br><blockquote>  Jika kami menghitung semua mesin yang bisa kami gunakan untuk Windows, tetapi ditransfer ke Linux dalam proyek ini, kami menghemat sekitar $ 10.000. Dan ini hanya pada lisensi, dan jika Anda memperhitungkan konten - lebih banyak. </blockquote><br><h2>  Paket </h2><br>  Kuartal berikutnya, rencana meletakkan bekerja pada mengoptimalkan pengiriman kode. <br><br>  <b>Transisi ke gambar Docker pra-bangun</b> .  TFS adalah hal yang keren dengan banyak plugin yang memungkinkan Anda untuk berintegrasi ke dalam Pipeline, termasuk perakitan sesuai dengan pemicunya, misalnya, gambar Docker.  Kami ingin membuat pemicu ini pada <b>package-lock.json yang sama</b> .  Jika entah bagaimana komposisi komponen yang digunakan untuk membangun perubahan proyek, kita akan memiliki gambar Docker baru.  Ini kemudian digunakan untuk menggunakan wadah dengan aplikasi yang dikompilasi.  Sekarang ini bukan, tapi kami berencana untuk beralih ke arsitektur layanan-mikro di Kubernetes, yang secara aktif berkembang di perusahaan kami dan telah lama melayani solusi produksi. <br><br><h2>  Ringkasan </h2><br>  Saya mendesak semua orang untuk melempar Windows, tetapi ini bukan karena saya tidak tahu cara memasaknya.  Alasannya adalah bahwa sebagian besar solusi opensource adalah <b>tumpukan Linux</b> .  Anda akan <b>menghemat sumber daya dengan baik</b> .  Menurut pendapat saya, masa depan terletak pada solusi Open Source Linux dengan komunitas yang kuat. <br><br>  <i>Profil pembicara Alexander Sinchinov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> .</i> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOps Conf</a> adalah konferensi tentang integrasi pengembangan, pengujian dan proses operasi untuk para profesional dari para profesional.  Itu sebabnya proyek yang dibicarakan Alexander?  diimplementasikan dan bekerja, dan pada hari kinerja dua rilis berhasil dibuat.  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOps Conf on RIT ++</a> pada 27 dan 28 Mei akan ada lebih banyak lagi kasus dari para praktisi.  Anda masih dapat melompat ke gerbong terakhir dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirimkan laporan,</a> atau meluangkan waktu untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memesan</a> tiket.  Temui aku di Skolkovo! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448496/">https://habr.com/ru/post/id448496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448484/index.html">Root mikroba</a></li>
<li><a href="../id448486/index.html">"Pada November 2018, kami keliru jatuh ke dalam spam di semua lini." Bagaimana saya menyimpan surat dari perusahaan dengan basis juta</a></li>
<li><a href="../id448488/index.html">Ketakutan dan Membenci DevSecOps</a></li>
<li><a href="../id448490/index.html">Cara memulai transformasi DevOps</a></li>
<li><a href="../id448492/index.html">Apa itu DevOps</a></li>
<li><a href="../id448498/index.html">"Russia 404": Seberapa banyak internet gratis yang tersisa untuk hidup</a></li>
<li><a href="../id448500/index.html">Memecahkan Crackme sederhana untuk Sega Mega Drive</a></li>
<li><a href="../id448504/index.html">Mereka mengumpulkan untuk semua orang "Habrom" buku referensi "Oleh siapa itu diterbitkan ..." untuk paspor. Unduh untuk kesehatan</a></li>
<li><a href="../id448506/index.html">Matrix berusia 20 tahun: bagaimana Wachowski membuat cyberpunk, yang menentukan agenda untuk seluruh generasi</a></li>
<li><a href="../id448510/index.html">Acer in 2019: bagaimana jika Anda menghapus semua lalat dari laptop gaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>