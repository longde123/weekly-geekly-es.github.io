<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥥 👩🏼‍🎓 ⚪️ Hierarchische Schlüsselgenerierung 💰 🎂 🔖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir über deterministische Geldbörsen, die hierarchische Schlüsselgenerierung und deren mathematische Funktionsweise sprechen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hierarchische Schlüsselgenerierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/distributedlab/blog/413627/">  In diesem Artikel werden wir über deterministische Geldbörsen, die hierarchische Schlüsselgenerierung und deren mathematische Funktionsweise sprechen. In welchen Fällen ist es praktisch, sie in die Praxis umzusetzen.  Dieses Material ist für Spezialisten nützlich, deren Aktivitäten sich auf Zahlungsgateways, Bitcoin-Geldbörsen und andere Münzgeschäfte beziehen.  Darüber hinaus ist das Material für diejenigen von Interesse, die sich für die Bereitstellung von elliptischen Kryptografien und Schlüsseln für die elektronische Signatur interessieren. <br><a name="habracut"></a><br><h2>  <b>Deterministische Brieftasche</b> </h2><br>  Definieren wir zunächst, was eine deterministische Geldbörse ist.  Wenn wir über die Schlüsselgenerierung sprechen, verwenden wir häufig das Wort „Brieftasche“, da der Besitz eines privaten Schlüssels im Zusammenhang mit Kryptowährungen ein Beweis für den Besitz von Münzen ist und in diesem Fall Brieftasche und Schlüssel eine ähnliche Bedeutung haben. <br><br>  Deterministic Wallet ist eine Brieftasche, in der alle verwendeten privaten Schlüssel aus einem Geheimnis generiert wurden, das von allen Schlüsseln gemeinsam genutzt wird.  Die Besonderheit ist, dass es aus einem Geheimnis möglich ist, eine beliebige Anzahl von Schlüsselpaaren für die elektronische Signatur zu erzeugen.  Sie können für jede eingehende Zahlung und Änderung neue Adressen verwenden. <br><br>  Praktischerweise können die Schlüssel einer solchen Brieftasche einfach auf ein anderes Gerät übertragen, eine Sicherungskopie erstellt und dann wiederhergestellt werden, da Sie tatsächlich nur ein Hauptgeheimnis reservieren müssen.  Außerdem sind nicht alle aus dem Hauptgeheimnis generierten privaten Schlüssel miteinander verbunden.  Es ist unmöglich, die Verbindung zwischen den generierten Adressen zu verfolgen (um festzustellen, ob sie alle einem Benutzer gehören), und mit dem generierten privaten Schlüssel können Sie das gemeinsame Geheimnis nicht wiederherstellen. <br><br><h3>  Grundlegende geheime Kodierung </h3><br>  Lassen Sie uns nun über die Kodierung des Hauptgeheimnisses sprechen.  Es gibt einen standardisierten Ansatz, der in BIP39 definiert wurde.  Dies ist die sogenannte Check Encoding-Codierung des Hauptgeheimnisses in eine mnemonische Phrase - eine Reihe von Wörtern, die leicht auf Papier zu schreiben sind und bei Bedarf zu merken sind.  Bei der Eingabe ist es möglich, die Prüfsumme zu überprüfen, dh gegebenenfalls einen Fehler mit einer ziemlich hohen Wahrscheinlichkeit zu identifizieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/c02/e0f/00ec02e0fe0b361673229ecc9fa59e14.png" alt="Bild"><br><br>  Wie funktioniert es  In der Tat haben Sie das Hauptgeheimnis (Entropie) - die Daten, aus denen alle persönlichen Schlüssel der Brieftasche erweitert werden.  Dieses Geheimnis kann unterschiedlich lang sein.  Was die Prüfsumme betrifft: Für jeweils 32 Bits Entropie gibt es 1 Bit der Prüfsumme, dh die Prüfsumme wird nach der Formel als Länge der Entropie in Bits geteilt durch 32 berechnet. <br><br>  Die Entropie verkettet sich mit einer Prüfsumme, die als doppelter SHA-256-Hash (SHA-2 mit einer Länge von 256 Bit) berechnet wird. Danach wird die erforderliche Anzahl von Bits abgeschnitten.  Verkettete Daten werden auf ein anderes Zahlensystem übertragen: von binär auf das Zahlensystem auf der Basis von 2048 (wie Sie sehen können, ist 2048 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>11</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>11</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {11} </script>  )  Wenn Sie die Länge der Entropiebits und die Prüfsumme addieren, erhalten Sie ein Vielfaches von 11.  Somit erhalten wir die Anzahl der Wörter in der ausgegebenen Mnemonik. <br><br>  Tatsächlich werden die Daten in 11-Bit-Teile "aufgeteilt".  Es gibt ein Wörterbuch mit 2048 Wörtern ( <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>11</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>11</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {11} </script>  ) für die bestimmte Anforderungen gelten.  Die Standardsprache des Wörterbuchs ist Englisch, aber jeder kann verwendet werden.  Wörter sollten eine bestimmte Länge nicht überschreiten (normalerweise maximal 7 Zeichen).  Alle von ihnen müssen in UTF-8 mit einer bestimmten Normalisierung aller Zeichen codiert sein.  Obligatorisch ist die Eindeutigkeit jedes Wortes in den ersten vier Zeichen. <br><br>  Die ersten vier Zeichen identifizieren das Wort im Wörterbuch eindeutig, und die verbleibenden Zeichen werden verwendet, um dieses Wort in einer bequemen Form zum Lesen, Speichern usw. zu vervollständigen. Somit erhält jedes aus 11 Bits bestehende Datenelement eine eindeutige Übereinstimmung in Form eines Wortes von Wörterbuch.  Wenn die Entropie Ihres Geheimnisses 256 Bit beträgt, betragen die Daten für die Codierung 264 Bit, und Ihre mnemonische Phrase enthält 24 Wörter.  Dies ist der Hauptansatz zum Verschlüsseln von Brieftaschengeheimnissen in BIP39, der in der Praxis am häufigsten verwendet wird. <br><br>  Um in Zukunft eine Sicherungskopie zu erstellen und diese zu verwenden, können Sie diesen Satz auf ein externes Medium schreiben.  Papier, das Sie an einem sicheren Ort aufbewahren, ist am besten geeignet.  So können Sie den vollständigen Zugriff auf alle Ihre Schlüssel wiederherstellen. <br><br><h3>  Arten von deterministischen Geldbörsen </h3><br>  Es gibt zwei Arten von deterministischen Geldbörsen.  Betrachten Sie ihre Hauptunterschiede. <br><br>  Der erste ist der einfachste.  Das Hauptgeheimnis hier ist mit dem Index des untergeordneten Schlüssels verknüpft, den wir erhalten möchten, wonach die verketteten Daten gehasht werden.  Meistens geschieht dies mit der SHA-256-Hash-Funktion. <br><br>  Der zweite Typ umfasst hierarchisch deterministische Wallets (HD Wallets), deren Prinzipien in BIP32 definiert sind und ein sehr verbreiteter Ansatz für die hierarchische Schlüsselgenerierung sind. <br><br><h3>  Determininistische Generation </h3><br>  Berücksichtigen Sie die Unterschiede zwischen diesen Brieftaschentypen im Diagramm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/271/a5a/477/271a5a47790684700751178bcee9d340.png" alt="Bild"><br><br>  Eine gewöhnliche deterministische Geldbörse hat einen Samen, aus dem eine große Anzahl privater Schlüssel direkt generiert wird.  Ihre Anzahl kann nur durch die Dimension des Index begrenzt werden, der vor dem Hashing mit dem Geheimnis verknüpft wird.  Normalerweise sind es 4 Bytes, das heißt, der Platz möglicher Optionen ermöglicht ungefähr 4 Milliarden eindeutige deterministische Brieftaschenschlüssel.  In der Praxis sollte dies für jede Situation ausreichen. <br><br><h3>  Hierarchische deterministische Erzeugung </h3><br>  Kommen wir zu einer hierarchischen deterministischen Brieftasche, deren zentrales Bereitstellungsschema bisher in vereinfachter Form dargestellt wurde.  Es gibt Seed, aus dem ein Paar Hauptschlüssel direkt erhalten wird.  Wenn wir in einer gewöhnlichen deterministischen Brieftasche einen privaten Schlüssel erhalten, erhalten wir hier ein Schlüsselpaar.  Darüber hinaus gibt es Hierarchieebenen, auf denen wir jeweils den Index berechnen, um den untergeordneten Schlüssel zu generieren.  Wir können auch Zweigstellen mit öffentlichem und privatem Schlüssel bauen. <br><br><h3>  Hierarchieebenen </h3><br>  In Bezug auf HD-Wallets ist zu beachten, dass ein Spawning-Knoten gemäß den BIP32-Regeln auf jeder Hierarchieebene drei Objekte hat: einen privaten Schlüssel, einen öffentlichen Schlüssel und einen Kettencode, mit dem die nächste Hierarchieebene erzeugt wird. <br><br><h3>  Hierarchisches Generierungsschema </h3><br>  Betrachten wir das Schlüsselgenerierungsschema für BIP32 genauer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/685/e79/e3e/685e79e3eae45b867f3033aad03f1743.png" alt="Bild"><br><br>  Alles beginnt mit Seed, es wird auch Master Seed genannt, aus dem die Nullstufe der Hierarchie berechnet wird - ein Paar Hauptschlüssel und Kettencode. <br><br>  Aus einem Paar von Hauptschlüsseln kann eine große Anzahl von Schlüsselpaaren mit bestimmten Indizes generiert werden.  Es wird eine neue Hierarchieebene gebildet, mit der Konten generiert werden.  Angenommen, ein Benutzer hat einen Startwert und möchte mehrere Adressen erstellen, die sich voneinander unterscheiden.  Die Münzen dieser Adressen werden nicht gemischt, nicht zusammen veröffentlicht, und bei abgeschlossenen Transaktionen zwischen ihnen kann keine Verbindung gefunden werden.  Diese Schlüssel werden vollständig getrennt voneinander verwendet.  In einem der Konten wird die Schlüsselgruppe für das Arbeitsbudget verwendet, in dem anderen für das persönliche Budget und in einem anderen Konto für die schwarze Buchhaltung.  Münzen vermischen sich nicht miteinander. <br><br>  Die nächste Hierarchieebene definiert verschiedene Schlüsselgenerierungsketten.  Am häufigsten werden Ketten mit den Indizes 0 und 1 verwendet. Eine Kette mit Index 0 generiert endgültige Schlüssel, um eine Adresse für eingehende Zahlungen zu bilden, und eine Kette mit Index 1 generiert Brieftaschen für Münzen, die der Benutzer an sich selbst sendet, d. H. Ändern.  Dies ist erforderlich, damit die Brieftasche auf Programmebene von außen gesendete Zahlungen von der Änderung unterscheidet, die Änderungen im Saldo jeder Transaktion berechnet und eine visuelle Liste mit dem Verlauf aller Zahlungen erstellt.  Dies vereinfacht die Entwicklung der Brieftasche und deren Verwendung für alltägliche Zahlungen. <br><br><h3>  Hash-basierter Nachrichtenauthentifizierungscode </h3><br>  Kommen wir nun zur mathematischen Komponente hierarchischer Schlüsselgenerierungsprozesse.  Betrachten Sie zunächst den Hash-basierten Nachrichtenauthentifizierungscode.  Dies ist eine andere Klasse zur Berechnung von Hash-Funktionen.  Es unterscheidet sich darin, dass am Eingang zwei Werte und nicht einer verwendet werden.  Der erste Wert ist der private Schlüssel und der zweite ist die Nachricht selbst. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>H</mi><mi>M</mi><mi>A</mi><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>K</mi><mo>,</mo><mi>m</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>H</mi><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><msup><mi>K</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>o</mi><mi>p</mi><mi>a</mi><mi>d</mi></mrow></msup><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>H</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>K</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mi>p</mi><mi>a</mi><mi>d</mi></mrow></msup><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>m</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="44.281ex" height="3.021ex" viewBox="0 -987.6 19065.2 1300.8" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-48" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-4D" x="888" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-41" x="1940" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-43" x="2690" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-28" x="3451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-4B" x="3840" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-2C" x="4730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6D" x="5175" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-29" x="6053" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-3D" x="6720" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-48" x="7777" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-28" x="8665" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-28" x="9055" y="0"></use><g transform="translate(9444,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-4B" x="0" y="0"></use><g transform="translate(901,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6F" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-70" x="485" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-61" x="989" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-64" x="1518" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-29" x="11890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-7C" x="12279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-7C" x="12558" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-48" x="12836" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-28" x="13725" y="0"></use><g transform="translate(14114,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-4B" x="0" y="0"></use><g transform="translate(901,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-70" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-61" x="849" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-64" x="1378" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-29" x="16461" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-7C" x="16850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-7C" x="17129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6D" x="17407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-29" x="18286" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-29" x="18675" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>H</mi><mi>M</mi><mi>A</mi><mi>C</mi><mo stretchy="false">(</mo><mi>K</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>o</mi><mi>p</mi><mi>a</mi><mi>d</mi></mrow></msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>H</mi><mo stretchy="false">(</mo><msup><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mi>p</mi><mi>a</mi><mi>d</mi></mrow></msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> HMAC (K, m) = H ((K ^ {opad}) || H (K ^ {ipad}) || m)) </script></p><br><br>  K ist der Schlüssel <br>  m - Nachricht <br>  opad, ipad - einige konstante Werte, die zum Generieren von Schlüsseln erforderlich sind, die sich in verschiedenen Phasen des Hashings voneinander unterscheiden. <br>  Als Hash-Funktion wird SHA-512 verwendet. <br><br>  Die Besonderheit ist, dass Sie zur Verwendung von HMAC einen geheimen Schlüssel besitzen müssen, um den korrekten Hashwert der Nachricht zu erhalten. <br><br>  Um den HMAC-Hashwert zu berechnen, entspricht der Wert des XOR-Schlüssels dem konstanten Wert des ipad. Danach wird das Ergebnis gehasht.  Eine Nachricht wird mit diesem Wert verkettet, wonach der Schlüssel XOR mit einem konstanten Wert berechnet, mit einem Hashwert verkettet und dann erneut gehasht wird.  Als Ergebnis erhalten wir 512 Bits des Hashwerts. <br><br><h3>  Ableitungsfunktionen </h3><br>  Schauen wir uns einige Funktionen an, die bei der Berechnung hierarchischer Schlüssel verwendet werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96e/f47/b41/96ef47b4141a2060395a9933dd56c52f.png" alt="Bild"><br><br>  Zunächst möchten wir den Master-Seed in ein Master-Schlüsselpaar umwandeln.  Danach müssen Sie den untergeordneten privaten Schlüssel und den untergeordneten öffentlichen Schlüssel vom persönlichen übergeordneten Schlüssel abrufen.  Im zweiten Fall wird genau die gleiche Funktion wie im ersten Fall verwendet, aber die Multiplikation der Zahl mit dem Basispunkt wird addiert, daher wird sie nicht separat betrachtet.  Der nächste Schritt besteht darin, die untergeordnete Öffentlichkeit vom öffentlichen übergeordneten Schlüssel abzurufen.  Es ist anzumerken, dass es nicht möglich ist, ein persönliches Kind vom öffentlichen Schlüssel des Elternteils zu erhalten.  Diese Einschränkung ist auf bestimmte Eigenschaften von HD-Geldbörsen zurückzuführen, die wir weiter betrachten werden. <br><br>  Lassen Sie uns also jede der Generierungsfunktionen separat durchgehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/736/372/31c/73637231c62a14b4bf5f8e7a5d498d01.png" alt="Bild"><br><br>  Um den Hauptschlüssel von der Haupt-Sid zu erhalten, wird die HMAC-Funktion verwendet, bei der die konstante Zeichenfolge "Bitcoin Seed" als Schlüssel und die wichtigsten geheimen Daten selbst als Nachricht übertragen werden.  Somit wird ein Hashwert von 512 Bits erhalten, den wir als zwei Teile betrachten: links und rechts.  Die linke Seite ist der private Hauptschlüssel und die rechte Seite ist der Kettencode.  Darüber hinaus werden diese Werte verwendet, um nachfolgende Ebenen von untergeordneten Schlüsseln zu generieren. <br><br>  Um den Master öffentlich zu machen, multiplizieren Sie einfach den Wert des Basispunkts mit dem Wert des privaten Masterschlüssels.  Wie Sie sehen können, geschieht dies in Analogie zu gewöhnlichen Tasten in einer Gruppe von Punkten auf einer elliptischen Kurve. <br><br>  Nun wollen wir sehen, wie der untergeordnete private Schlüssel vom übergeordneten privaten stammt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6f/eeb/022/a6feeb0227ea2d2ba18ed42ce4d47d01.png" alt="Bild"><br><br>  Wir werden die HMAC-Funktion wieder verwenden.  Als Schlüssel übergeben wir den Kettencode der aktuellen Hierarchieebene und als Nachricht die Verkettung, wobei der erste Teil der persönliche übergeordnete Schlüssel multipliziert mit dem Basispunkt ist.  In der Tat ist dies eine Besetzung zu einem Punkt und eine Serialisierung dieses Punktes.  Die Verkettung erfolgt mit dem Index des untergeordneten Schlüssels, den wir empfangen möchten, serialisiert mit 32 Bit, dh 4 Byte. <br><br>  Basierend auf dem Ergebnis der HMAC-Funktion erhalten wir den Wert I und betrachten ihn erneut getrennt: Der linke und der rechte Teil der Ausgabewerte sind 256 Bit.  Dann der untergeordnete private Schlüssel <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>k</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.011ex" height="2.419ex" viewBox="0 -780.1 865.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-69" x="737" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>k</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> k_i </script>  Wir berechnen durch Addition zum linken Ausgabewert <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>I</mi><mi>l</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.746ex" height="2.419ex" viewBox="0 -780.1 751.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-49" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6C" x="622" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mi>l</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> I_l </script>  Werte des übergeordneten privaten Schlüssels.  Die Addition erfolgt modulo n, wobei n die Reihenfolge des Basispunkts der elliptischen Kurve ist, um den Maximalwert des privaten Schlüssels nicht zu überschreiten.  So haben wir einen untergeordneten privaten Schlüssel erhalten. <br><br>  Dementsprechend ist der untergeordnete Kettencode gleich dem richtigen Ausgabewert der HMAC-Funktion, d.h. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>I</mi><mi>R</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.503ex" height="2.419ex" viewBox="0 -780.1 1077.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-49" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-52" x="622" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mi>R</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> I_R </script>  .  Wenn wir den untergeordneten öffentlichen Schlüssel aus dem persönlichen übergeordneten Schlüssel ermitteln möchten, multiplizieren wir den Wert <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>k</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.011ex" height="2.419ex" viewBox="0 -780.1 865.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-69" x="737" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>k</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> k_i </script>  durch den Wert des Basispunkts auf der elliptischen Kurve.  So bekommen wir den öffentlichen Schlüssel <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>K</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.773ex" height="2.419ex" viewBox="0 -780.1 1193.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-4B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMATHI-69" x="1201" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>K</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-8"> K_i </script>  . <br><br>  Wie berechnen wir den öffentlichen Schlüssel des Kindes aus dem öffentlichen Elternschlüssel? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/bbe/e55/39abbee5560b44abbe7a271a88153198.png" alt="Bild"><br><br>  Hier wird die Berechnung etwas anders sein.  Wir übergeben die Kettenhierarchie der aktuellen Hierarchieebene als Schlüssel an die HMAC-Funktion. Anschließend serialisieren wir den übergeordneten öffentlichen Schlüssel und verketten ihn mit dem gewünschten Index, der auf 32 Bit serialisiert ist.  Die Eingabedaten werden genauso wie im vorherigen Fall erhalten.  Um den öffentlichen Schlüssel zu berechnen, nehmen wir die linke Seite des Ausgabewerts der HMAC-Funktion und betrachten ihn als 256 Bit modulo in der Reihenfolge des Basispunkts, bringen ihn zu einem Punkt auf der elliptischen Kurve, dh multiplizieren mit dem Basispunkt, und addieren das Ergebnis mit dem übergeordneten öffentlichen Schlüssel .  Das Ergebnis der Hinzufügung wird ebenfalls ein Punkt sein und es wird ein öffentlicher untergeordneter Schlüssel sein.  Der Kettencode für diesen Schlüssel befindet sich auf der rechten Seite des Ausgabewerts der HMAC-Funktion. <br><br><h3>  Übereinstimmende Schlüssel zueinander </h3><br>  Dies kann eine logische Frage aufwerfen, wie private und öffentliche Schlüssel, die auf unterschiedliche Weise erhalten werden, einander entsprechen.  Ist es wirklich möglich, aus einem öffentlichen Schlüssel, der auf öffentliche Weise generiert wurde, genau den gleichen Wert zu erhalten, indem ein auf andere Weise erhaltener privater Schlüssel mit einem Basispunkt multipliziert wird?  Dies ist leicht zu überprüfen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e44/ac2/851/e44ac28516cc2774373bc76d94d0c244.png" alt="Bild"><br><br>  Wenn wir uns daran erinnern, wie wir den persönlichen untergeordneten Schlüssel berechnet haben, und ihn mit dem Basispunkt multiplizieren, dh zur Punktfunktion führen, und dann die Berechnung des untergeordneten öffentlichen Schlüssels aufrufen und diese Berechnungen vergleichen, werden wir feststellen, dass wir den übergeordneten öffentlichen Schlüssel als Produkt des persönlichen übergeordneten Schlüssels betrachten Schlüssel zum Basispunkt, dann werden wir sehen, dass die gleichen Berechnungen nur in einer anderen Reihenfolge durchgeführt wurden. <br><br>  In einem Fall haben wir die privaten Schlüssel hinzugefügt und mit dem Basispunkt multipliziert, und im zweiten Fall haben wir zuerst die Werte mit dem Basispunkt multipliziert und sie dann hinzugefügt und das Ergebnis erhalten.  Basierend auf der Tatsache, dass das Hinzufügen von Punkten auf einer elliptischen Kurve additiv ist, können wir sagen, dass diese beiden Werte gleich sind - wir erhalten denselben öffentlichen Schlüssel, der auf zwei Arten berechnet wird. <br><br><h3>  Beispiel für einen öffentlichen Schlüssel </h3><br>  Aus Gründen des Interesses können wir uns ein Beispiel eines öffentlichen Schlüssels ansehen, der für Testwerte und BIP32-Berechnungen erhalten wurde.  Wenn unsere Entropie aus 128 Bit bestand, sieht sie im Hexadezimalzahlensystem wie im Bild unten aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64c/ca1/01a/64cca101a12268bda803fd8f447c719e.png" alt="Bild"><br><br>  Der gleiche Wert, der in der BIP39-Mnemonik codiert ist, sieht aus wie die 12 gezeigten Wörter.  Wenn Sie diese Mnemonik als Master-Seed für die hierarchische Schlüsselgenerierung verwenden, erhalten Sie einen solchen privaten Master-Schlüssel mit dem entsprechenden 256-Bit-Kettencode. <br><br><h3>  Erweiterte Schlüssel </h3><br>  Es gibt auch Konzepte wie den erweiterten öffentlichen Schlüssel und den erweiterten privaten Schlüssel.  Wie wird es verwendet?  Zum besseren Verständnis beschreiben wir die visuelle Situation. <br><br>  Angenommen, wir haben einen bestimmten Benutzer und einen Dienst.  Ein Dienst überträgt Zahlungen, beispielsweise in Bitcoins, mit einer bestimmten Häufigkeit an einen Benutzer.  Sowohl der Benutzer als auch der Dienst sind daran interessiert, für jede Zahlung eine neue Adresse zu verwenden, um es einem externen Beobachter zu erschweren, eine Tatsache festzustellen und die Geschichte der Interaktion miteinander zu verwechseln. <br><br>  Im einfachsten Fall würde es so aussehen: Der Benutzer generiert für jede eingehende Zahlung ein neues Schlüsselpaar, berechnet die Adresse, die er an den Dienst übergibt, wonach der Dienst eine Transaktion generieren und die Zahlung ausführen kann.  Dies ist jedoch für beide Parteien unpraktisch, wenn die Intensität dieser Zahlungen hoch ist. <br><br><h3>  Erweiterter öffentlicher Schlüssel </h3><br>  In einer ähnlichen Situation hilft der erweiterte öffentliche Schlüssel (xPubKey), die Unannehmlichkeiten zu beseitigen.  Der Benutzer kann einem Drittanbieter-Dienst ermöglichen, Adressen anstelle von sich selbst zu generieren, die dem Dienst bekannt sind, aber nur der Benutzer verfügt über private Schlüssel.  Der Dienst kann ohne Wissen des Benutzers eine beliebige Anzahl von Adressen generieren und Geld an diese senden, und der Benutzer kann nach Belieben private Schlüssel bereitstellen und Zugriff auf eine dieser Adressen erhalten. <br><br>  Wie funktioniert es  Der Benutzer muss ein neues Konto auf der zweiten Ebene der Schlüsselhierarchie erstellen und für ihn den öffentlichen Schlüssel und den Kettencode für die aktuelle Ebene berechnen.  Danach müssen Sie sowohl den öffentlichen Schlüssel als auch den Kettencode an den Dienst übertragen.  Der Einfachheit halber wurde die Base58Check-Codierung eingeführt, über die wir gesprochen haben (hier gibt es eine spezielle Version).  Als nächstes werden der öffentliche Schlüssel, der Kettencode und die Prüfsumme verkettet.  Dies alles ist im Basisnummernsystem 58 codiert und wir erhalten einen öffentlichen erweiterten Schlüssel, der bereits nach einem bestimmten Standard codiert ist.  Es beginnt mit den Zeichen „xpub“, die leicht zu erkennen sind.  Es sieht aus wie im Bild gezeigt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c61/aae/082/c61aae082f6a423d35712fcf63246f68.png" alt="Bild"><br><br>  Ein Dienst kann einen solchen Schlüssel akzeptieren und öffentliche Schlüssel für den Benutzer über BIP32 bereitstellen, Adressen von ihm empfangen und dafür bezahlen.  Es kann jedoch nur der Benutzer die entsprechenden privaten Schlüssel berechnen. <br><br><h3>  Gehärtete Ableitung </h3><br>  Bei der hierarchischen Generierung von Schlüsseln gibt es eine gehärtete Ableitung.  Dies ist ein Ansatz, der die Berechnung von untergeordneten öffentlichen Schlüsseln aus dem entsprechenden übergeordneten öffentlichen Schlüssel nicht zulässt.  Dies unterscheidet sich von der normalen Generierung darin, dass wir darin die Verkettung des serialisierten Punkts als übergeordneten öffentlichen Schlüssel als Nachricht an die HMAC-Funktion verwenden und bei der gehärteten Ableitung die Serialisierung des übergeordneten privaten Schlüssels verwenden. <br><br>  Außerdem ist die Indexberechnung anders.  Der Index bei der normalen Generierung wird direkt auf 32 Bit serialisiert und bei der gehärteten Ableitung leicht konvertiert: Es wird ein konstanter Wert hinzugefügt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>31</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>31</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-9"> 2 ^ {31} </script>  Dadurch wird das höchstwertige Bit auf 1 gesetzt (es wird leicht, zwischen Ableitungstypen zu unterscheiden).  Dementsprechend ist der Raum der Varianten möglicher Schlüssel sowohl für die normale Erzeugung als auch für die gehärtete Ableitung gleich und gleich <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>31</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhg-s5h7KUqTerTrzEu6xgiDAy0qRA#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>31</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-10"> 2 ^ {31} </script>  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/160/ab3/cea160ab30c57ea702407dd53893d25e.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einem übergeordneten öffentlichen Schlüssel und einer gehärteten Ableitung ist es daher nicht möglich, untergeordnete öffentliche Schlüssel zu berechnen. </font><font style="vertical-align: inherit;">Wenn der Angreifer den übergeordneten öffentlichen Schlüssel erhält, kann er die untergeordneten Schlüssel nicht berechnen. </font><font style="vertical-align: inherit;">Daher können die Adressen und ihre Beziehung zum empfangenen übergeordneten Schlüssel nicht berechnet werden. </font><font style="vertical-align: inherit;">Im Falle einer normalen Ableitung, dh im Üblichen, kann eine solche Funktion verwendet werden und die Beziehung von Adressen untereinander verfolgen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wege der Generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns darüber sprechen, wie Schlüssel generiert werden können. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/0bc/006/c7d0bc0061acf64d206c73d305de73c4.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf jeder Hierarchieebene gibt es einen spezifischen Index, der Aspekte der Schlüsselgenerierung definiert. Der Pfad vom Hauptschlüssel zum endgültigen Schlüssel kann durch Schrägstriche als Indizes geschrieben werden. Wenn es sich um einen privaten Schlüssel handelt, beginnt die Aufnahme mit einem kleinen „m“, und wenn wir über das Generieren eines öffentlichen Schlüssels sprechen, dann mit einem großen „M“. Wenn der Index durch ein Apostroph angezeigt wird, sollte verstanden werden, dass es sich um eine gehärtete Ableitung ohne Apostroph handelt - normale Ableitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie einen der gängigen Schlüsselgenerierungspfade in BIP32, in denen hierarchische Schlüssel definiert wurden.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ab/564/b7c/1ab564b7cbe935bfbe5aa2075c1fce31.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird ein Pfad verwendet, in dem der Hauptschlüssel die Null-Ebene der Hierarchie ist. Im Folgenden sind die Kontenindizes aufgeführt, die denselben Benutzer bestimmen, gefolgt von Ketten, in denen Adressketten außerhalb veröffentlicht werden können, um eingehende Zahlungen zu akzeptieren. Mit Index 1 werden die Ketten erstellt, an die der Benutzer Zahlungen an sich selbst sendet (häufiger) das alles ist Kapitulation). Der endgültige Index wird verwendet, um die Schlüssel zu generieren, aus denen die Adressen berechnet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den allerersten Schlüssel mit Index 0 gemäß dem BIP32-Standard zu berechnen, haben wir m, 0 mit der Erzeugung von gehärtet, Kette - 0, Index - 0 (m / 0 '/ 0/0). So erhalten wir den Pfad für den ersten hierarchisch generierten Schlüssel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen Vorschlag zur Verbesserung von Bitcoin, der als BIP43 bezeichnet wird. Dabei wird die Verbesserungsnummer, die einen neuen Spawn-Pfad (m / bip_number '/ *) bietet, auf die erste Ebene der Hierarchie geschrieben. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/652/61f/68c65261f576ac3e75c412c2de9b50b5.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So erschien BIP44, das das Merkmal des vorherigen Satzes verwendete, dh der Index 44 wurde für die erste Hierarchieebene geschrieben und schlug die folgenden Verbesserungen vor: Notieren Sie im Index der zweiten Hierarchieebene einen bestimmten Wert, der dem Münztyp entspricht, den wir für diese Brieftasche verwenden. Jetzt können Schlüssel für verschiedene Währungen in einer Brieftasche bereitgestellt und verwendet werden.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/739/3bd/23b7393bd44abf5568d476c03d0a8bf8.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Bitcoin sieht der Pfad wie folgt aus: "m / 44 '/ 0' / 0 '/ 0/0", für Bitcoin testnet - "m / 44' / 1 '/ 0' / 0/0", für Litecoin - "m / 44 '/ 2' / 0 '/ 0/0 ”für Dash -“ m / 44' / 5 '/ 0' / 0/0 ”. Interessanterweise verwendet Ethereum genau die gleiche elliptische Kurve für die Berechnung der Schlüssel und die digitale Signatur. Für die Brieftasche sieht der Pfad wie folgt aus: „m / 44 '/ 60' / 0 '/ 0/0“. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt noch eine weitere Verbesserung - BIP45. Die Verbesserung zielt darauf ab, die Regeln zum Generieren von Schlüsseln für den Fall ihrer Verwendung in Multisignatur-Geldbörsen und die Bildung von Adressen unter Verwendung von BIP16, d. H. P2SH, zu bestimmen. Es enthält den BIP43-Satz und gibt den Index 45 auf der ersten Ebene der Hierarchie an, auf der zweiten Ebene der Hierarchie muss ein Unterzeichner (Mitunterzeichner) angegeben werden.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bc/2c8/fd1/4bc2c8fd1c785ef5c9deb48417db9c53.png" alt="Bild"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise gibt es eine 3-aus-5-Mehrfachsignaturregel. Daher gibt es 5 Unterzeichner, aber um Münzen auszugeben, benötigen Sie mindestens 3 Unterschriften. Somit verfügt jeder der Unterzeichner über eine HD-Brieftasche mit einem eigenen Master-Seed und gibt seine Seriennummer auf seinem Weg an. Sie kann als Index berechnet werden, wenn die auf der ersten Hierarchieebene jedes Benutzers generierten Schlüssel sortiert werden. Angenommen, auf der ersten Ebene generiert jeder Benutzer Schlüssel, tauscht sie miteinander aus, sortiert und findet heraus, wer welchen Index für die zweite Ebene der Hierarchie hat. Dies ist erforderlich, um die Notwendigkeit einer solchen Interaktion weiter zu beseitigen und sofort Adressen korrekt zu generieren und Ihre Seriennummer zu kennen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das heißt, Sie können den erweiterten öffentlichen Schlüssel einmal austauschen, um unabhängig von anderen Mitgliedern der Gruppe Multisignaturadressen zu bilden und Zahlungen für diese zu akzeptieren. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommen wir zu häufig gestellten Fragen. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wie unterscheiden sich Mastersamen in verschiedenen Münzen?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seed ist eine zufällig generierte Zahl, eine Folge von Bits oder eine Mnemonikphrase, die beispielsweise gemäß BIP39 generiert wird und zum Generieren von Schlüsseln verwendet wird. Es kann sowohl für eine Münze als auch für jede andere verwendet werden - es ist nicht erforderlich, unterschiedliche Mnemonikphrasen für unterschiedliche Währungen zu verwenden. Darüber hinaus gibt es BIP44, das die Regeln zum Generieren von Schlüsseln für verschiedene Währungen aus derselben Mnemonik definiert. Diese privaten Schlüssel überschneiden sich nicht, sondern werden für verschiedene Adressen verschiedener Währungen verwendet. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wörterbuch aus BIP39, in dem 2048 Wörter für eine mnemonische Phrase standardisiert sind? Kann ich es in allen Geldbörsen und Anwendungen verwenden?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsache ist, dass dieser Standard für BIP39 beschrieben ist. Für BIP39 gibt es Wörterbücher: Englisch, zwei Japanisch, Chinesisch, Italienisch, Russisch, Ukrainisch usw. Wenn also eine Anwendung behauptet, BIP39 zu verwenden und das Importieren und Exportieren einer Mnemonikphrase zu ermöglichen, bedeutet dies, dass auch eine Reihe von Wörtern verwendet wird das gleiche. Es gibt jedoch Brieftaschen, die nicht BIP39 verwenden, sondern ihre eigene Modifikation. Sie müssen sich die Brieftaschenbeschreibung ansehen und entweder standardisierte oder Ihre eigene Entwicklung oder die Entwicklung des Dienstes verwenden, den die Brieftasche bietet. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Werden bei Börsen und zentralisierten Speichern wie Coinbase die Brieftaschenschlüssel für alle Benutzer aus derselben gemeinsamen Phrase für alle generiert oder nicht?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist schwer zu sagen, da sie ihre interne Struktur nicht öffnen, aber die neuen Dienste, die angezeigt werden, können entweder separat Schlüssel generieren oder den BIP32-Standard verwenden oder seine modifizierte Version verwenden. Die Dienste, die vor dem Erscheinen der Standards für die hierarchische Schlüsselgenerierung existierten, generieren höchstwahrscheinlich weiterhin nur separate private Schlüssel. Vielleicht sind sie so einfacher zu verwalten, wenn alle Schlüssel einen großen Umsatz haben. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ist der Schlüssel ein Punkt auf der elliptischen Kurve, dh zwei sehr große Zahlen X und Y?"</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der öffentliche Schlüssel - ja, dies ist ein Punkt auf der elliptischen Kurve, und der private Schlüssel ist eine natürliche Zahl, die angibt, wie oft Sie den Basispunkt mit sich selbst hinzufügen müssen. Der öffentliche Schlüssel selbst besteht aus zwei Werten - dies sind die X- und Y-Koordinaten, von denen jeder eine Größe von 256 Bit hat. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Was ist "Cast to Point" und Serialisierung von Punkt und Index?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduktion auf einen Punkt bedeutet, dass es eine natürliche Zahl gibt, die wir als privaten Schlüssel betrachten. Wir addieren den Basispunkt so oft mit uns selbst, dh in der Gruppe der Punkte auf der elliptischen Kurve wird nur die Additionsoperation definiert, dann können wir den Punkt mit einer natürlichen Zahl multiplizieren. Die Serialisierung eines Punktes bedeutet, auf eine bestimmte Weise zwei Koordinaten aufzuzeichnen. Dies kann ein komprimierter Datensatz sein, ist jedoch nicht erforderlich. Komprimiert in dem Sinne, dass eine der Koordinaten, nämlich Y, in ein Vorzeichen umgewandelt wird, werden die Daten in die Gleichung eingesetzt und es wird untersucht, wo sich der Punkt befindet: oben oder unten. Bei der Indexserialisierung müssen Sie verstehen, dass eine reguläre Zahl, die je nach Größe in Bytes oder Bits geschrieben werden kann. Je größer die Anzahl, desto mehr Daten werden benötigt. Bei den von uns untersuchten Berechnungeneine Nummer einer bestimmten Länge ist erforderlich. Sie müssen es auf eine bestimmte Länge serialisieren - 4 Bytes. Infolgedessen bezieht sich dies auf das Umwandeln des Index in eine 4-Byte-Zahl. Wenn die Senior-Werte dort leer bleiben, sind sie Null.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wer hat diese Berechnungen für die Ableitungsfunktionen von HD-Geldbörsen erstellt? Warum solche Formeln, in denen es Rechtfertigungen gibt und in denen Sie mehr darüber lesen können?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie können mehr in BIP32 lesen, wenn Sie an einer Mnemonik interessiert sind, dann in BIP39 usw. Sie können GitHub öffnen und einen Benutzer unter dem Spitznamen Bitcoin finden. Er verfügt über ein Bitcoin-Repository, in dem der Bitcoin-Quellcode gespeichert ist, und über ein BIPs-Repository (primäre Quelle), in dem alle Vorschläge zur Verbesserung von Bitcoin aufgezeichnet sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie kamen auf die Idee, Berechnungen auf diese Weise durchzuführen, da sie an eine Gruppe von Punkten einer elliptischen Kurve gebunden sind. Wenn Sie eine solche Funktionalität erreichen möchten, mit der Sie die Zweige öffentlicher und privater Schlüssel getrennt berechnen und gleichzeitig ihre Korrespondenz untereinander aufrechterhalten können, war dies die einfachste Implementierungsoption. Tatsächlich verwendeten die Entwickler die einfachste Option, mit der Sie mithilfe der im Laufe der Zeit getesteten Kryptografie interessante Eigenschaften erzielen können. Die Autoren der vorgeschlagenen Verbesserungen sind viele. Die Bitcoin-Community, deren Teilnehmer Verbesserungen und mathematische Transformationen entwickeln, ist ziemlich groß. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Gehärtete Ableitung ist immer nur auf der zweiten Ebene der Hierarchie?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hängt alles von der Situation ab. Bei der Generierung von Schlüsseln für die Mehrfachsignatur ist es sinnvoll, eine gehärtete Ableitung nur auf der ersten Hierarchieebene durchzuführen. In BIP44 wird die gehärtete Ableitung auf die ersten drei Ebenen angewendet: Auf der ersten Ebene ist die Nummer des BIP selbst, auf der zweiten die Kontonummer, wo sie relevant ist, auf der dritten die Währungsnummer, wo sie ebenfalls sinnvoll ist. Angenommen, es wird Ihnen wahrscheinlich nicht gefallen, wenn Sie den öffentlichen Schlüssel veröffentlichen, und die Benutzer können alle Ihre Adressen in Bitcoin verfolgen. Wenn Sie ein Konto verwenden, um Zahlungen von bestimmten Diensten zu erhalten, können Sie diesen Schlüssel offenlegen, und Sie benötigen hier keine gehärtete Ableitung. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wo kann die hierarchische Schlüsselgenerierung angewendet werden?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können es anwenden, wenn Sie mit der Börse arbeiten, sodass die Börse Sie immer an verschiedene Adressen bezahlt. </font><font style="vertical-align: inherit;">In diesem Fall ist es jedoch besser, dies alles manuell zu organisieren. </font><font style="vertical-align: inherit;">Dies ist für alltägliche digitale Geldbörsen am relevantesten, da es hier sehr einfach ist, eine Sicherung privater Schlüssel zu erstellen und eine Geldbörse wiederherzustellen. </font><font style="vertical-align: inherit;">Die Schlüsselgenerierung für verschiedene Währungen wird ebenfalls unterstützt, und der Standard selbst wird bereits in verschiedenen Implementierungen digitaler Geldbörsen verwendet. </font><font style="vertical-align: inherit;">Die Schlüssel zwischen diesen Brieftaschen lassen sich bequem mit derselben Mnemonik übertragen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Thema wird in einer der Vorlesungen des Online-Blockchain-Kurses „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierarchical Key Generation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ behandelt.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413627/">https://habr.com/ru/post/de413627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413615/index.html">Der VPNFilter-Virus, der 500.000 Router infizierte, erwies sich als noch gefährlicher als angenommen</a></li>
<li><a href="../de413617/index.html">30% der Leistungsbeschreibung wurden geändert und der Plan wurde zweimal übertroffen: Wie VTB die Berichterstellung automatisierte</a></li>
<li><a href="../de413619/index.html">Neue Informationen zu VPNFilter: Durch einen Angriff auf Benutzergeräte wurde die Liste der Netzwerkgeräte erweitert</a></li>
<li><a href="../de413621/index.html">Lebe es. Stirb. Auferstehen. Wiederholen</a></li>
<li><a href="../de413623/index.html">Wie man Omega 2 oder die Legende von I2S spricht</a></li>
<li><a href="../de413631/index.html">Verschlüsselung von Zertifikatstoken auf einem Token unter Linux am Beispiel von JaCarta, Debian und dem Evolution-Mail-Client</a></li>
<li><a href="../de413633/index.html">Wie ich Englisch beherrschte</a></li>
<li><a href="../de413635/index.html">Wir entwerfen eine Viehfarm. Und nanoCAD VK verwenden?</a></li>
<li><a href="../de413637/index.html">Google hat 7 KI-Ethikprinzipien veröffentlicht</a></li>
<li><a href="../de413639/index.html">Geschützte Smartphones: Wer braucht sie und wie unterscheiden sie sich voneinander?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>