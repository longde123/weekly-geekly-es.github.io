<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèΩ üêõ ‚ö°Ô∏è Meningkatkan IDA Pro. Debugger untuk Sega Mega Drive (bagian 1) üòπ ‚ôåÔ∏è ‚õ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salam! 


 Kamerad pembalik, romhackers: pada dasarnya artikel ini akan dikhususkan untuk Anda. Di dalamnya, saya akan memberi tahu Anda cara menulis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meningkatkan IDA Pro. Debugger untuk Sega Mega Drive (bagian 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434992/"><p><img src="https://habrastorage.org/webt/mj/6l/rl/mj6lrl7zl2pq7itjpw3cr3s15fw.png"></p><br><p>  Salam! </p><br><p> Kamerad pembalik, romhackers: pada dasarnya artikel ini akan dikhususkan untuk Anda.  Di dalamnya, saya akan memberi tahu Anda cara menulis plugin debugger Anda sendiri untuk <code>IDA Pro</code> .  Ya, sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">upaya pertama untuk memulai cerita</a> , tetapi sejak itu banyak air telah mengalir, banyak prinsip telah direvisi.  Secara umum, mereka mengemudi! <a name="habracut"></a></p><br><h4 id="liricheskoe-vstuplenie">  Pengantar liris </h4><br><p>  Sebenarnya, dari artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> ), saya pikir itu tidak akan menjadi rahasia bahwa prosesor favorit saya adalah <code>Motorola 68000</code> .  Ngomong-ngomong, wanita tua favorit saya <code>Sega Mega Drive</code> / <code>Genesis</code> mengerjakannya.  Dan, karena saya selalu tertarik pada bagaimana permainan Segov diatur, dari bulan-bulan pertama penggunaan komputer saya, saya memutuskan untuk pergi jauh ke dalam hutan pembongkaran dan membalikkan untuk waktu yang lama. </p><br><p>  Inilah bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Smd IDA Tools</a> muncul. <br>  Proyek ini mencakup berbagai hal tambahan yang membuat pekerjaan mempelajari ROM di Sega jauh lebih mudah: loader, debugger, penolong untuk perintah <code>VDP</code> .  Semuanya ditulis untuk <code>IDA 6.8</code> , dan berfungsi dengan baik.  Tetapi, ketika saya memutuskan untuk memberi tahu dunia bagaimana saya melakukan semua hal yang sama, menjadi jelas bahwa akan sangat sulit untuk menunjukkan kode seperti itu kepada orang-orang, dan bahkan lebih untuk menggambarkannya.  Karena itu, saya tidak bisa melakukan ini. </p><br><p>  Dan kemudian <code>IDA 7.0</code> keluar.  Keinginan untuk mem-porting proyek saya langsung muncul, tetapi arsitektur emulator <code>Gens</code> , atas dasar yang saya tuliskan debuggernya, ternyata tidak cocok untuk porting: sisipan perakitan <code>x86</code> , kruk, kode yang sulit dipahami, dan banyak lagi.  Dan permainan <code>Pier Solar and the Great Architects</code> , yang dirilis pada kartrid pada tahun 2010, dan yang saya benar-benar ingin jelajahi (dan ada banyak trik anti-emulasi di sana), tidak dimulai pada <code>Gens</code> . </p><br><p><img src="https://habrastorage.org/webt/5f/in/pg/5finpgxicxyqorxx1qa50ka7zne.jpeg"></p><br><p>  Mencari sumber emulator yang cocok yang dapat diadaptasi untuk debugger, saya akhirnya menemukan <code>EkeEke</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Genesis Plus GX</a> <code>EkeEke</code> .  Jadi artikel ini muncul. </p><br><h2 id="chast-pervaya-yadro-otladchika">  Bagian Satu: Inti Debugger </h2><br><p>  Musashi menangani persaingan instruksi prosesor Motorola dalam <code>Genesis Plus GX</code> .  Sumber aslinya sudah memiliki fungsi debugging dasar (sebuah kait untuk menjalankan instruksi), tetapi <code>EkeEke</code> memutuskan untuk menghapusnya sebagai tidak perlu.  Kami kembali. </p><br><p><img src="https://habrastorage.org/webt/qp/1v/ls/qp1vls4m3ghzf3aqmknj-23xulu.png"></p><br><p><img src="https://habrastorage.org/webt/tr/wp/rw/trwprwbfno8tkajpbfaftwyqyu8.png"></p><br><p>  Sekarang yang paling penting: Anda perlu memutuskan arsitektur debugger.  Persyaratannya adalah sebagai berikut: </p><br><ul><li>  Breaks (breakpoints) untuk eksekusi, untuk membaca dan menulis ke memori </li><li>  <code>Step Into</code> Fungsi <code>Step Into</code> , <code>Step Over</code> </li><li>  Jeda, <code>Resume</code> Emulasi </li><li>  Baca / atur register, baca / tulis memori </li></ul><br><p>  Jika keempat poin ini adalah pekerjaan debugger dari dalam, maka Anda masih perlu mempertimbangkan akses ke fungsi ini dari luar.  Tambahkan item lain: </p><br><ul><li>  Protokol komunikasi dari debugger-server (kernel) dengan debugger-client (GUI, pengguna) </li></ul><br><h3 id="yadro-otladchika-spisok-bryakov">  Inti debugger: daftar istirahat </h3><br><p>  Untuk mengimplementasikan daftar, kami memulai struktur berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enabled; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">bpt_type_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>;</code> </pre> <br><p>  Bidang <code>next</code> dan <code>next</code> akan masing-masing menyimpan pointer ke elemen berikutnya dan sebelumnya. <br>  Kolom yang <code>enabled</code> akan menyimpan <code>0</code> jika breakpoint ini perlu dilewati dalam tes operasi. <br>  <code>width</code> - jumlah byte yang dimulai dari alamat di bidang <code>address</code> yang dicakup pemutus. <br>  Nah, di bidang <code>type</code> kita akan menyimpan tipe breakpoint (eksekusi, membaca, menulis).  Lebih detail di bawah ini. </p><br><p>  Untuk bekerja dengan daftar breakpoint, saya menambahkan fungsi-fungsi berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi Breakpoint</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp = (<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp == first_bp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp-&gt;next == bp) { first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp-&gt;next != first_bp ? bp-&gt;next : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bpt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { ++i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bpt_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ++i; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first_bp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) delete_breakpoint(first_bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) clear_bpt_list(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bp = first_bp; bp; bp = next_breakpoint(bp)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((address &lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> </div></div><br><h3 id="yadro-otladchika-osnovnye-peremennye">  Inti debugger: variabel inti </h3><br><p>  Sebenarnya, saya melihat implementasi ini di debugger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PCSXR</a> lain. </p><br><p>  Tambahkan variabel yang akan menyimpan status emulasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_first_paused, dbg_trace, dbg_dont_check_bp; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_last_pc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over_addr; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_active, dbg_paused;</code> </pre> <br><p>  Variabel <code>dbg_first_paused</code> akan bertanggung jawab untuk menghentikan emulasi pada awal debugging.  Jika <code>0</code> - maka Anda perlu menjeda emulasi dan mengirim pesan ke klien bahwa emulasi dimulai.  Setelah jeda pertama, atur ke <code>1</code> . </p><br><p>  Kami membutuhkan <code>dbg_trace</code> untuk dieksekusi sesuai dengan satu instruksi ( <code>Step Into</code> fungsionalitas).  Jika sama dengan <code>1</code> , kami menjalankan satu instruksi, jeda, dan setel ulang nilainya ke <code>0</code> . </p><br><p>  Saya mengatur variabel <code>dbg_dont_check_bp</code> sehingga memori baca / tulis tidak akan berfungsi jika debugger melakukannya. </p><br><p>  <code>dbg_step_over</code> akan disimpan pada <code>1</code> jika kita berada dalam mode <code>Step Over</code> sampai <code>PC</code> saat ini ( <em>Program Counter</em> , alias <em>Instruction Pointer</em> ) menjadi sama dengan alamat di <code>dbg_step_over_addr</code> .  Setelah itu, kedua variabel diatur ulang.  Saya akan <code>dbg_step_over_addr</code> perhitungan nilai <code>dbg_step_over_addr</code> nanti. </p><br><p>  Saya mengatur variabel <code>dbg_last_pc</code> untuk satu kasus tertentu: ketika kita sudah berdiri pada istirahat, dan klien meminta untuk <code>Resume</code> .  Agar pemutus tidak berfungsi lagi, saya membandingkan alamat <code>PC</code> terakhir dalam variabel ini dengan yang baru, dan jika nilainya berbeda, Anda dapat memeriksa breakpoint pada <code>PC</code> saat ini. </p><br><p>  <code>dbg_active</code> - pada kenyataannya, ia menyimpan status <code>1</code> ketika debugging aktif dan Anda perlu memeriksa jeda, memproses permintaan dari klien. </p><br><p>  Dengan variabel <code>dbg_paused</code> , saya pikir semuanya jelas: <code>1</code> - kita sedang jeda (misalnya, setelah istirahat), dan kami menunggu perintah dari klien, <code>0</code> - kami mengikuti instruksi. </p><br><p>  Kami menulis fungsi untuk bekerja dengan variabel-variabel ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">0</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clear_bpt_list(); resume_debugger(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Kita melihat bahwa dalam implementasi <code>detach_debugger()</code> saya digunakan untuk menghapus daftar istirahat.  Ini diperlukan agar setelah memutuskan hubungan klien, breakpoint lama tidak terus bekerja. </p><br><h3 id="yadro-otladchika-realizuem-huk-na-instrukcii">  Inti Debugger: kami menerapkan hook pada instruksi </h3><br><p>  Sebenarnya, di sini pekerjaan utama akan berlangsung dengan jeda, melanjutkan emulasi, <code>Step Into</code> , <code>Step Over</code> . </p><br><p>  Berikut adalah kode untuk fungsi <code>process_breakpoints()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_breakpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handled_event = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_over = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_active) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_first_paused) { dbg_first_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send emulation started event } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_paused = 1; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event that Step Into has been triggered handled_event = 1; } if (!dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event about Step Over or breakpoint has been triggered handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send paused event } dbg_last_pc = pc; if (dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } }</span></span></code> </pre> <br><p>  Mari kita pahami: </p><br><ol><li>  Jika debugging tidak diaktifkan, keluar saja dari kail </li><li>  Trik dengan <code>setjmp</code> / <code>longjmp</code> diperlukan karena <code>RetroArch</code> shell <code>RetroArch</code> , di mana kami menulis versi kami sendiri <code>Genesis Plus GX</code> , yang dengannya kami menjalankan emulasi, hang menunggu emulator untuk keluar dari fungsi rendering bingkai.  Saya akan menunjukkan bagian kedua dari trik ini nanti, karena  itu menyentuh shell di atas emulator, bukan inti. </li><li>  Jika ini adalah operasi pertama kami dari pengait, dan, dengan demikian, awal dari persaingan, kami menghentikan sebentar dan mengirimkan peristiwa dimulainya persaingan ke klien. </li><li>  Jika klien sebelumnya mengirim perintah <code>Step Into</code> , kami <code>dbg_trace</code> nilai variabel <code>dbg_trace</code> dan mengatur emulasi menjadi jeda.  Kami mengirimkan acara yang sesuai kepada klien. </li><li>  Jika kita tidak jeda, mode <code>Step Over</code> dihidupkan, dan <code>PC</code> saat ini sama dengan alamat tujuan <code>dbg_step_over_addr</code> , kita <code>dbg_step_over_addr</code> variabel yang diperlukan dan jeda. </li><li>  Kami memeriksa breakpoint jika kami tidak menggunakannya sekarang, dan jika break telah bekerja, kami menjeda dan mengirimkan klien acara tentang <code>Step Over</code> atau break. </li><li>  Jika ini bukan gangguan, bukan <code>Step Into</code> , dan bukan <code>Step Over</code> , maka klien meminta istirahat.  Kami mengirim acara tentang jeda yang dipicu. </li><li>  Kami menerapkan trik dengan <code>longjump</code> sebagai implementasi dari loop tak terbatas yang menunggu tindakan dari klien selama jeda. </li></ol><br><p>  Kode untuk menghitung alamat untuk <code>Step Over</code> tidak sesederhana yang Anda duga.  Prosesor Motorola memiliki panjang instruksi yang berbeda, jadi Anda harus mempertimbangkan alamat selanjutnya secara manual, tergantung pada opcode.  Selain itu, Anda perlu menghindari instruksi seperti <code>bra</code> , <code>jmp</code> , <code>rts</code> conditional jumps forward, dan jalankan sebagai <code>Step Into</code> .  Implementasinya adalah sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Calc_step_over () kode fungsi</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_step_over</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sp = m68k_get_reg(M68K_REG_SP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc = m68ki_read_imm_16(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_pc = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc;</span></span></code> </pre> </div></div><br><h3 id="yadro-otladchika-inicializaciya-i-ostanovka-otladki">  Kernel Debugger: Menginisialisasi dan Menghentikan Debugging </h3><br><p>  Semuanya sederhana di sini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_debugging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send Stopped event to client detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; }</span></span></code> </pre> <br><h3 id="yadro-otladchika-realizaciya-protokola">  Debugger Kernel: Implementasi Protokol </h3><br><p>  Protokol komunikasi antara server debug dan klien klien dapat dengan aman disebut jantung kedua dari proses debugging, karena  itu mengimplementasikan fungsionalitas pemrosesan permintaan dari klien, dan reaksi terhadapnya. <br>  Diputuskan untuk mengimplementasikan berdasarkan <em>Memori Bersama</em> , karena perlu mengirim blok memori besar: <code>VRAM</code> , <code>RAM</code> , <code>ROM</code> , dan melalui jaringan ini akan lebih menyenangkan. </p><br><p>  Intinya adalah ini: kernel menciptakan memori bersama dengan struktur yang telah ditentukan, dan mengharapkan permintaan masuk dari klien.  Setelah memproses permintaan, jawabannya disimpan dalam memori yang sama, dan informasi yang sesuai ditambahkan ke daftar peristiwa debugger di memori yang sama. </p><br><p>  Prototipe dipilih sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Unduh Paket Sumber debug_wrap.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #define SHARED_MEM_NAME "GX_PLUS_SHARED_MEM" #define MAX_BREAKPOINTS 1000 #define MAX_DBG_EVENTS 20 #ifndef MAXROMSIZE #define MAXROMSIZE ((unsigned int)0xA00000) #endif #pragma pack(push, 4) typedef enum { BPT_ANY = (0 &lt;&lt; 0), // M68K BPT_M68K_E = (1 &lt;&lt; 0), BPT_M68K_R = (1 &lt;&lt; 1), BPT_M68K_W = (1 &lt;&lt; 2), BPT_M68K_RW = BPT_M68K_R | BPT_M68K_W, // VDP BPT_VRAM_R = (1 &lt;&lt; 3), BPT_VRAM_W = (1 &lt;&lt; 4), BPT_VRAM_RW = BPT_VRAM_R | BPT_VRAM_W, BPT_CRAM_R = (1 &lt;&lt; 5), BPT_CRAM_W = (1 &lt;&lt; 6), BPT_CRAM_RW = BPT_CRAM_R | BPT_CRAM_W, BPT_VSRAM_R = (1 &lt;&lt; 7), BPT_VSRAM_W = (1 &lt;&lt; 8), BPT_VSRAM_RW = BPT_VSRAM_R | BPT_VSRAM_W, // Z80 BPT_Z80_E = (1 &lt;&lt; 11), BPT_Z80_R = (1 &lt;&lt; 12), BPT_Z80_W = (1 &lt;&lt; 13), BPT_Z80_RW = BPT_Z80_R | BPT_Z80_W, // REGS BPT_VDP_REG = (1 &lt;&lt; 9), BPT_M68K_REG = (1 &lt;&lt; 10), } bpt_type_t; typedef enum { REQ_NO_REQUEST, REQ_GET_REGS, REQ_SET_REGS, REQ_GET_REG, REQ_SET_REG, REQ_READ_68K_ROM, REQ_READ_68K_RAM, REQ_WRITE_68K_ROM, REQ_WRITE_68K_RAM, REQ_READ_Z80, REQ_WRITE_Z80, REQ_ADD_BREAK, REQ_TOGGLE_BREAK, REQ_DEL_BREAK, REQ_CLEAR_BREAKS, REQ_LIST_BREAKS, REQ_ATTACH, REQ_PAUSE, REQ_RESUME, REQ_STOP, REQ_STEP_INTO, REQ_STEP_OVER, } request_type_t; typedef enum { REG_TYPE_M68K = (1 &lt;&lt; 0), REG_TYPE_S80 = (1 &lt;&lt; 1), REG_TYPE_Z80 = (1 &lt;&lt; 2), REG_TYPE_VDP = (1 &lt;&lt; 3), } register_type_t; typedef enum { DBG_EVT_NO_EVENT, DBG_EVT_STARTED, DBG_EVT_PAUSED, DBG_EVT_BREAK, DBG_EVT_STEP, DBG_EVT_STOPPED, } dbg_event_type_t; typedef struct { dbg_event_type_t type; unsigned int pc; char msg[256]; } debugger_event_t; typedef struct { int index; unsigned int val; } reg_val_t; typedef struct { unsigned int d0, d1, d2, d3, d4, d5, d6, d7; unsigned int a0, a1, a2, a3, a4, a5, a6, a7; unsigned int pc, sr, sp, usp, isp, ppc, ir; } regs_68k_data_t; typedef enum { REG_68K_D0, REG_68K_D1, REG_68K_D2, REG_68K_D3, REG_68K_D4, REG_68K_D5, REG_68K_D6, REG_68K_D7, REG_68K_A0, REG_68K_A1, REG_68K_A2, REG_68K_A3, REG_68K_A4, REG_68K_A5, REG_68K_A6, REG_68K_A7, REG_68K_PC, REG_68K_SR, REG_68K_SP, REG_68K_USP, REG_68K_ISP, REG_68K_PPC, REG_68K_IR, REG_VDP_00, REG_VDP_01, REG_VDP_02, REG_VDP_03, REG_VDP_04, REG_VDP_05, REG_VDP_06, REG_VDP_07, REG_VDP_08, REG_VDP_09, REG_VDP_0A, REG_VDP_0B, REG_VDP_0C, REG_VDP_0D, REG_VDP_0E, REG_VDP_0F, REG_VDP_10, REG_VDP_11, REG_VDP_12, REG_VDP_13, REG_VDP_14, REG_VDP_15, REG_VDP_16, REG_VDP_17, REG_VDP_18, REG_VDP_19, REG_VDP_1A, REG_VDP_1B, REG_VDP_1C, REG_VDP_1D, REG_VDP_1E, REG_VDP_1F, REG_VDP_DMA_LEN, REG_VDP_DMA_SRC, REG_VDP_DMA_DST, REG_Z80_PC, REG_Z80_SP, REG_Z80_AF, REG_Z80_BC, REG_Z80_DE, REG_Z80_HL, REG_Z80_IX, REG_Z80_IY, REG_Z80_WZ, REG_Z80_AF2, REG_Z80_BC2, REG_Z80_DE2, REG_Z80_HL2, REG_Z80_R, REG_Z80_R2, REG_Z80_IFFI1, REG_Z80_IFFI2, REG_Z80_HALT, REG_Z80_IM, REG_Z80_I, } regs_all_t; typedef struct { unsigned int pc, sp, af, bc, de, hl, ix, iy, wz; unsigned int af2,bc2,de2,hl2; unsigned char r, r2, iff1, iff2, halt, im, i; } regs_z80_data_t; typedef struct { unsigned char regs_vdp[0x20]; unsigned short dma_len; unsigned int dma_src, dma_dst; } vdp_regs_t; typedef struct { int type; // register_type_t regs_68k_data_t regs_68k; reg_val_t any_reg; vdp_regs_t vdp_regs; regs_z80_data_t regs_z80; } register_data_t; typedef struct { int size; unsigned int address; unsigned char m68k_rom[MAXROMSIZE]; unsigned char m68k_ram[0x10000]; unsigned char z80_ram[0x2000]; } memory_data_t; typedef struct { bpt_type_t type; unsigned int address; int width; int enabled; } bpt_data_t; typedef struct { int count; bpt_data_t breaks[MAX_BREAKPOINTS]; } bpt_list_t; typedef struct { request_type_t req_type; register_data_t regs_data; memory_data_t mem_data; bpt_data_t bpt_data; int dbg_events_count; debugger_event_t dbg_events[MAX_DBG_EVENTS]; bpt_list_t bpt_list; int dbg_active, dbg_paused; int is_ida; } dbg_request_t; #pragma pack(pop) dbg_request_t *open_shared_mem(); void close_shared_mem(dbg_request_t **request); int recv_dbg_event(dbg_request_t *request, int wait); void send_dbg_request(dbg_request_t *request, request_type_t type); #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>  Bidang pertama dalam struktur yang akan kita miliki adalah jenis permintaan: </p><br><ul><li>  baca / atur register </li><li>  baca / tulis memori </li><li>  bekerja dengan breakpoints </li><li>  jeda / lanjutkan emulasi, putuskan / hentikan debugger </li><li>  <code>Step Into</code> / <code>Step Over</code> </li></ul><br><p>  Berikutnya adalah register <code>M68K</code> , <code>Z80</code> , <code>VDP</code> .  Berikut ini adalah blok memori <code>ROM</code> , <code>RAM</code> , <code>VRAM</code> , <code>Z80</code> . </p><br><p>  Untuk menambah / menghapus celah, saya juga membuat struktur yang sesuai.  Nah, daftar mereka juga ada di sini (sebagian besar, itu hanya untuk tampilan di GUI, tanpa perlu mengingat semua jeda yang diinstal, seperti yang dilakukan <code>IDA</code> ). </p><br><p>  Berikut ini adalah daftar acara debug: </p><br><ul><li>  Debugging dimulai (diperlukan untuk <code>IDA Pro</code> ) </li><li>  Debugging dijeda ( <code>PC</code> di mana emulasi saat ini dijeda disimpan dalam acara tersebut) </li><li>  Breakpoint berfungsi (juga menyimpan nilai <code>PC</code> tempat operasi terjadi) </li><li>  <code>Step Into</code> atau <code>Step Over</code> dilakukan (juga, sebenarnya, hanya diperlukan untuk <code>IDA</code> , karena Anda dapat melakukannya hanya dengan satu jeda acara) </li><li>  Proses emulasi telah dihentikan.  Setelah mengklik tombol <code>Stop</code> di <code>IDA</code> tanpa menerima acara ini, ia akan menunggu tanpa henti untuk berhenti </li></ul><br><p>  Berbekal gagasan protokol, kami mengimplementasikan pemrosesan permintaan klien, sehingga mendapatkan kode kernel debugger berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Unduh Paket Sumber debug.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"debug.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> m68ki_cpu m68k #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MUL (7) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BUILD_TABLES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68ki_cycles.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kconf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kcpu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kops.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vdp_ctrl.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Z80.h"</span></span></span><span class="hljs-meta"> static int dbg_first_paused, dbg_trace, dbg_dont_check_bp; static int dbg_step_over; static int dbg_last_pc; static unsigned int dbg_step_over_addr; static dbg_request_t *dbg_req = NULL; static HANDLE hMapFile = 0; typedef struct breakpoint_s { struct breakpoint_s *next, *prev; int enabled; int width; bpt_type_t type; unsigned int address; } breakpoint_t; static breakpoint_t *first_bp = NULL; static breakpoint_t *add_bpt(bpt_type_t type, unsigned int address, int width) { breakpoint_t *bp = (breakpoint_t *)malloc(sizeof(breakpoint_t)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } return bp; } static void delete_breakpoint(breakpoint_t * bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp == first_bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp-&gt;next == bp) { first_bp = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; free(bp); } static breakpoint_t *next_breakpoint(breakpoint_t *bp) { return bp-&gt;next != first_bp ? bp-&gt;next : 0; } static breakpoint_t *find_breakpoint(unsigned int address, bpt_type_t type) { breakpoint_t *p; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) return p; } return 0; } static void remove_bpt(unsigned int address, bpt_type_t type) { breakpoint_t *bpt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } static int count_bpt_list() { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { ++i; } return i; } static void get_bpt_data(int index, bpt_data_t *data) { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; break; } ++i; } } static void clear_bpt_list() { while (first_bp != NULL) delete_breakpoint(first_bp); } static void init_bpt_list() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) clear_bpt_list(); } void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) return; breakpoint_t *bp; for (bp = first_bp; bp; bp = next_breakpoint(bp)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) continue; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((address </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = 1; break; } } } static void pause_debugger() { dbg_trace = 1; dbg_req-&gt;dbg_paused = 1; } static void resume_debugger() { dbg_trace = 0; dbg_req-&gt;dbg_paused = 0; } static void detach_debugger() { clear_bpt_list(); resume_debugger(); } static void activate_debugger() { dbg_req-&gt;dbg_active = 1; } static void deactivate_debugger() { dbg_req-&gt;dbg_active = 0; } int activate_shared_mem() { hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(dbg_request_t), SHARED_MEM_NAME); if (hMapFile == 0) { return -1; } dbg_req = (dbg_request_t*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (dbg_req == 0) { CloseHandle(hMapFile); return -1; } memset(dbg_req, 0, sizeof(dbg_request_t)); return 0; } void deactivate_shared_mem() { UnmapViewOfFile(dbg_req); CloseHandle(hMapFile); hMapFile = NULL; dbg_req = NULL; } static unsigned int calc_step_over() { unsigned int pc = m68k_get_reg(M68K_REG_PC); unsigned int sp = m68k_get_reg(M68K_REG_SP); unsigned int opc = m68ki_read_imm_16(); unsigned int dest_pc = (unsigned int)(-1); // jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc; } void process_request() { if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;req_type == REQ_NO_REQUEST) return; switch (dbg_req-&gt;req_type) { case REQ_GET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) regs_data-&gt;any_reg.val = m68k_get_reg(regs_data-&gt;any_reg.index); if (regs_data-&gt;type &amp; REG_TYPE_VDP) regs_data-&gt;any_reg.val = reg[regs_data-&gt;any_reg.index]; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { regs_data-&gt;any_reg.val = ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index]; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { regs_data-&gt;any_reg.val = ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13]; } } } break; case REQ_SET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) m68k_set_reg(regs_data-&gt;any_reg.index, regs_data-&gt;any_reg.val); if (regs_data-&gt;type &amp; REG_TYPE_VDP) reg[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13] = regs_data-&gt;any_reg.val &amp; 0xFF; } } } break; case REQ_GET_REGS: case REQ_SET_REGS: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) { regs_68k_data_t *m68kr = &amp;regs_data-&gt;regs_68k; if (dbg_req-&gt;req_type == REQ_GET_REGS) { m68kr-&gt;d0 = m68k_get_reg(M68K_REG_D0); m68kr-&gt;d1 = m68k_get_reg(M68K_REG_D1); m68kr-&gt;d2 = m68k_get_reg(M68K_REG_D2); m68kr-&gt;d3 = m68k_get_reg(M68K_REG_D3); m68kr-&gt;d4 = m68k_get_reg(M68K_REG_D4); m68kr-&gt;d5 = m68k_get_reg(M68K_REG_D5); m68kr-&gt;d6 = m68k_get_reg(M68K_REG_D6); m68kr-&gt;d7 = m68k_get_reg(M68K_REG_D7); m68kr-&gt;a0 = m68k_get_reg(M68K_REG_A0); m68kr-&gt;a1 = m68k_get_reg(M68K_REG_A1); m68kr-&gt;a2 = m68k_get_reg(M68K_REG_A2); m68kr-&gt;a3 = m68k_get_reg(M68K_REG_A3); m68kr-&gt;a4 = m68k_get_reg(M68K_REG_A4); m68kr-&gt;a5 = m68k_get_reg(M68K_REG_A5); m68kr-&gt;a6 = m68k_get_reg(M68K_REG_A6); m68kr-&gt;a7 = m68k_get_reg(M68K_REG_A7); m68kr-&gt;pc = m68k_get_reg(M68K_REG_PC); m68kr-&gt;sr = m68k_get_reg(M68K_REG_SR); m68kr-&gt;sp = m68k_get_reg(M68K_REG_SP); m68kr-&gt;usp = m68k_get_reg(M68K_REG_USP); m68kr-&gt;isp = m68k_get_reg(M68K_REG_ISP); m68kr-&gt;ppc = m68k_get_reg(M68K_REG_PPC); m68kr-&gt;ir = m68k_get_reg(M68K_REG_IR); } else { m68k_set_reg(M68K_REG_D0, m68kr-&gt;d0); m68k_set_reg(M68K_REG_D1, m68kr-&gt;d1); m68k_set_reg(M68K_REG_D2, m68kr-&gt;d2); m68k_set_reg(M68K_REG_D3, m68kr-&gt;d3); m68k_set_reg(M68K_REG_D4, m68kr-&gt;d4); m68k_set_reg(M68K_REG_D5, m68kr-&gt;d5); m68k_set_reg(M68K_REG_D6, m68kr-&gt;d6); m68k_set_reg(M68K_REG_D7, m68kr-&gt;d7); m68k_set_reg(M68K_REG_A0, m68kr-&gt;a0); m68k_set_reg(M68K_REG_A1, m68kr-&gt;a1); m68k_set_reg(M68K_REG_A2, m68kr-&gt;a2); m68k_set_reg(M68K_REG_A3, m68kr-&gt;a3); m68k_set_reg(M68K_REG_A4, m68kr-&gt;a4); m68k_set_reg(M68K_REG_A5, m68kr-&gt;a5); m68k_set_reg(M68K_REG_A6, m68kr-&gt;a6); m68k_set_reg(M68K_REG_A7, m68kr-&gt;a7); m68k_set_reg(M68K_REG_PC, m68kr-&gt;pc); m68k_set_reg(M68K_REG_SR, m68kr-&gt;sr); m68k_set_reg(M68K_REG_SP, m68kr-&gt;sp); m68k_set_reg(M68K_REG_USP, m68kr-&gt;usp); m68k_set_reg(M68K_REG_ISP, m68kr-&gt;isp); } } if (regs_data-&gt;type &amp; REG_TYPE_VDP) { vdp_regs_t *vdp_regs = &amp;regs_data-&gt;vdp_regs; for (int i = 0; i &lt; (sizeof(vdp_regs) / sizeof(vdp_regs-&gt;regs_vdp[0])); ++i) { if (dbg_req-&gt;req_type == REQ_GET_REGS) vdp_regs-&gt;regs_vdp[i] = reg[i]; else reg[i] = vdp_regs-&gt;regs_vdp[i]; } if (dbg_req-&gt;req_type == REQ_GET_REGS) { vdp_regs-&gt;dma_len = (reg[20] &lt;&lt; 8) | reg[19]; if (!vdp_regs-&gt;dma_len) vdp_regs-&gt;dma_len = 0x10000; vdp_regs-&gt;dma_src = vdp_dma_calc_src(); vdp_regs-&gt;dma_dst = vdp_dma_get_dst(); } } if (regs_data-&gt;type &amp; REG_TYPE_Z80) { regs_z80_data_t *z80r = &amp;regs_data-&gt;regs_z80; if (dbg_req-&gt;req_type == REQ_GET_REGS) { z80r-&gt;pc = Z80.pc.d; z80r-&gt;sp = Z80.sp.d; z80r-&gt;af = Z80.af.d; z80r-&gt;bc = Z80.bc.d; z80r-&gt;de = Z80.de.d; z80r-&gt;hl = Z80.hl.d; z80r-&gt;ix = Z80.ix.d; z80r-&gt;iy = Z80.iy.d; z80r-&gt;wz = Z80.wz.d; z80r-&gt;af2 = Z80.af2.d; z80r-&gt;bc2 = Z80.bc2.d; z80r-&gt;de2 = Z80.de2.d; z80r-&gt;hl2 = Z80.hl2.d; z80r-&gt;r = Z80.r; z80r-&gt;r2 = Z80.r2; z80r-&gt;iff1 = Z80.iff1; z80r-&gt;iff2 = Z80.iff2; z80r-&gt;halt = Z80.halt; z80r-&gt;im = Z80.im; z80r-&gt;i = Z80.i; } else { Z80.pc.d = z80r-&gt;pc; Z80.sp.d = z80r-&gt;sp; Z80.af.d = z80r-&gt;af; Z80.bc.d = z80r-&gt;bc; Z80.de.d = z80r-&gt;de; Z80.hl.d = z80r-&gt;hl; Z80.ix.d = z80r-&gt;ix; Z80.iy.d = z80r-&gt;iy; Z80.wz.d = z80r-&gt;wz; Z80.af2.d = z80r-&gt;af2; Z80.bc2.d = z80r-&gt;bc2; Z80.de2.d = z80r-&gt;de2; Z80.hl2.d = z80r-&gt;hl2; Z80.r = z80r-&gt;r; Z80.r2 = z80r-&gt;r2; Z80.iff1 = z80r-&gt;iff1; Z80.iff2 = z80r-&gt;iff2; Z80.halt = z80r-&gt;halt; Z80.im = z80r-&gt;im; Z80.i = z80r-&gt;i; } } } break; case REQ_READ_68K_ROM: case REQ_READ_68K_RAM: case REQ_READ_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_READ_68K_ROM: mem_data-&gt;m68k_rom[mem_data-&gt;address + i] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_68K_RAM: mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_Z80: mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF] = z80_readmem(mem_data-&gt;address + i); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_WRITE_68K_ROM: case REQ_WRITE_68K_RAM: case REQ_WRITE_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_WRITE_68K_ROM: m68ki_write_8(mem_data-&gt;address + i, mem_data-&gt;m68k_rom[mem_data-&gt;address + i]); break; case REQ_WRITE_68K_RAM: m68ki_write_8(0xFF0000 | ((mem_data-&gt;address + i) &amp; 0xFFFF), mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF]); break; case REQ_WRITE_Z80: z80_writemem(mem_data-&gt;address + i, mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF]); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_ADD_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; if (!find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type)) add_bpt(bpt_data-&gt;type, bpt_data-&gt;address, bpt_data-&gt;width); } break; case REQ_TOGGLE_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; breakpoint_t *bp = find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type); if (bp != NULL) bp-&gt;enabled = !bp-&gt;enabled; } break; case REQ_DEL_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; remove_bpt(bpt_data-&gt;address, bpt_data-&gt;type); } break; case REQ_CLEAR_BREAKS: clear_bpt_list(); case REQ_LIST_BREAKS: { bpt_list_t *bpt_list = &amp;dbg_req-&gt;bpt_list; bpt_list-&gt;count = count_bpt_list(); for (int i = 0; i &lt; bpt_list-&gt;count; ++i) get_bpt_data(i, &amp;bpt_list-&gt;breaks[i]); } break; case REQ_ATTACH: activate_debugger(); dbg_first_paused = 0; break; case REQ_PAUSE: pause_debugger(); break; case REQ_RESUME: resume_debugger(); break; case REQ_STOP: stop_debugging(); break; case REQ_STEP_INTO: { if (dbg_req-&gt;dbg_paused) { dbg_trace = 1; dbg_req-&gt;dbg_paused = 0; } } break; case REQ_STEP_OVER: { if (dbg_req-&gt;dbg_paused) { unsigned int dest_pc = calc_step_over(); if (dest_pc != (unsigned int)(-1)) { dbg_step_over = 1; dbg_step_over_addr = dest_pc; } else { dbg_step_over = 0; dbg_step_over_addr = 0; dbg_trace = 1; } dbg_req-&gt;dbg_paused = 0; } } break; default: break; } dbg_req-&gt;req_type = REQ_NO_REQUEST; } void send_dbg_event(dbg_event_type_t type) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].type = type; dbg_req-&gt;dbg_events_count += 1; } void stop_debugging() { send_dbg_event(DBG_EVT_STOPPED); detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_req != NULL &amp;&amp; dbg_req-&gt;dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } int is_debugger_accessible() { return (dbg_req != NULL); } void process_breakpoints() { int handled_event = 0; int is_step_over = 0; int is_step_in = 0; unsigned int pc = m68k_get_reg(M68K_REG_PC); if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, 1); if (!dbg_first_paused) { dbg_first_paused = 1; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; strncpy(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg, "gpgx", sizeof(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg)); send_dbg_event(DBG_EVT_STARTED); } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_STEP); handled_event = 1; } if (!dbg_req-&gt;dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_req-&gt;dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(is_step_over ? DBG_EVT_STEP : DBG_EVT_BREAK); handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_PAUSED); } dbg_last_pc = pc; if (dbg_req-&gt;dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } } int is_debugger_paused() { return is_debugger_accessible() &amp;&amp; dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace; }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">  debug.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;setjmp.h&gt; #include "debug_wrap.h" extern void start_debugging(); extern void stop_debugging(); extern int is_debugger_accessible(); extern void process_request(); extern int is_debugger_paused(); extern int activate_shared_mem(); extern void deactivate_shared_mem(); void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value); extern jmp_buf jmp_env; #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>              . <br> ,    <code>check_breakpoint</code>  <code>VDP</code>       <code>#ifdef LOGVDP</code> .       <code>vdp_ctrl.c</code> : </p><br><pre> <code class="cpp hljs">check_breakpoint(BPT_VRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data);</code> </pre> <br><p>  <code>RAM</code>     ( <code>m68kcpu.h</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// m68ki_read_8 check_breakpoint(BPT_M68K_R, 1, address, val); // m68ki_read_16 check_breakpoint(BPT_M68K_R, 2, address, val); // m68ki_read_32 check_breakpoint(BPT_M68K_R, 4, address, val); // m68ki_write_8 check_breakpoint(BPT_M68K_W, 1, address, val); // m68ki_write_16 check_breakpoint(BPT_M68K_W, 2, address, val); // m68ki_write_32 check_breakpoint(BPT_M68K_W, 4, address, val);</span></span></code> </pre> <br><p>      ,      ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  debug_wrap.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include &lt;process.h&gt; #include "debug_wrap.h" static HANDLE hMapFile = NULL, hStartFunc = NULL; dbg_request_t *open_shared_mem() { hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, SHARED_MEM_NAME); if (hMapFile == NULL) { return NULL; } dbg_request_t *request = (dbg_request_t *)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (request == NULL) { CloseHandle(hMapFile); return NULL; } return request; } void close_shared_mem(dbg_request_t **request) { UnmapViewOfFile(*request); CloseHandle(hMapFile); hMapFile = NULL; *request = NULL; } int recv_dbg_event(dbg_request_t *request, int wait) { while (request-&gt;dbg_active || request-&gt;dbg_events_count) { for (int i = 0; i &lt; MAX_DBG_EVENTS; ++i) { if (request-&gt;dbg_events[i].type != DBG_EVT_NO_EVENT) { request-&gt;dbg_events_count -= 1; return i; } } if (!wait) return -1; Sleep(10); } return -1; } void send_dbg_request(dbg_request_t *request, request_type_t type) { if (!request) return; request-&gt;req_type = type; while (request-&gt;dbg_active &amp;&amp; request-&gt;req_type != REQ_NO_REQUEST) { Sleep(10); } }</span></span></span></span></code> </pre> </div></div><br><p>       .   ,  . ,         , ,      . </p><br><h3 id="yadro-otladchika-zapusk">  :  </h3><br><p>          <code>Genesis Plus GX</code> : </p><br><pre> <code class="cpp hljs"> var.key = <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>; environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &amp;var); { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var.value || !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(var.value, <span class="hljs-string"><span class="hljs-string">"disabled"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_accessible()) { stop_debugging(); stop_gui(); deactivate_shared_mem(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { activate_shared_mem(); start_debugging(); run_gui(); } } ... { <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>, <span class="hljs-string"><span class="hljs-string">"Debugger; disabled|enabled"</span></span> },</code> </pre> <br><p>    <code>RetroArch</code> : <br>   ,      <code>retro_run()</code> .      (      ),    . ,      <code>retro_run()</code> ,  <code>RetroArch</code>  .      <code>setjmp()</code> / <code>longjmp()</code> .  ,        <code>retro_run()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_paused()) { longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_paused = setjmp(jmp_env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_paused) { process_request(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>      <code>retro_run()</code>      <code>process_request()</code> ,      ,    . </p><br><h3 id="ps-zatravka-dlya-vtoroy-chasti"> PS     </h3><br><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p> <strong>Update</strong> : <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>      -  <code>IDA Pro</code> ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434992/">https://habr.com/ru/post/id434992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434976/index.html">Fablab ITMO University: DIY-rekan kerja untuk orang-orang kreatif - tunjukkan apa yang ada di dalamnya</a></li>
<li><a href="../id434978/index.html">Memperkenalkan HealthKit</a></li>
<li><a href="../id434982/index.html">Perspektif: MultiClet S1</a></li>
<li><a href="../id434984/index.html">Mengapa saya membenci ORM yang fasih</a></li>
<li><a href="../id434986/index.html">Konsep dasar dari pustaka C ++ standar</a></li>
<li><a href="../id434994/index.html">Android: Membuat Citarasa Produk Dinamis dan Menandatangani Konfigurasi</a></li>
<li><a href="../id434996/index.html">Bagaimana saya berbagi lokasi melalui VK API</a></li>
<li><a href="../id434998/index.html">Artikel lain tentang cara memilih smartphone</a></li>
<li><a href="../id435000/index.html">Konsep interaksi saluran iklan dan aplikasi praktisnya</a></li>
<li><a href="../id435006/index.html">Di mana dan bagaimana reaktor nuklir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>