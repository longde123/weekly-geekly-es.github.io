<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎨 👨🏽‍🔬 👏🏼 Entendendo os Corretores de Mensagens. Aprendendo a mecânica das mensagens através do ActiveMQ e Kafka. Capítulo 3. Kafka 🙎🏿 👩🏽‍🚀 👩🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuação da tradução de um pequeno livro: 
 "Entendendo os Message Brokers", 
 autor: Jakub Korab, editor: O'Reilly Media, Inc., data de publicação...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entendendo os Corretores de Mensagens. Aprendendo a mecânica das mensagens através do ActiveMQ e Kafka. Capítulo 3. Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466585/"> Continuação da tradução de um pequeno livro: <br>  "Entendendo os Message Brokers", <br>  autor: Jakub Korab, editor: O'Reilly Media, Inc., data de publicação: junho de 2017, ISBN: 9781492049296. <br><br>  <b>Tradução concluída: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tele.gg/middle_java</a></b> <br><br>  Parte anterior: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compreendendo os Message Brokers.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprendendo a mecânica das mensagens através do ActiveMQ e Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 2. ActiveMQ</a> <br><a name="habracut"></a><br><h2>  CAPÍTULO 3 </h2><br><h2>  Kafka </h2><br>  O Kafka foi desenvolvido no LinkedIn para contornar algumas das limitações dos agentes de mensagens tradicionais e evitar a necessidade de configurar vários agentes de mensagens para diferentes interações ponto a ponto, conforme descrito no livro "Escala vertical e horizontal" na página 28 deste livro. O LinkedIn se baseou fortemente na absorção unidirecional de grandes quantidades de dados, como cliques em páginas e logs de acesso, permitindo que vários sistemas usassem esses dados.  am, sem afetar o desempenho de outros produtores ou konsyumerov.  De fato, a razão pela qual Kafka existe é obter a arquitetura de mensagens que o Universal Data Pipeline descreve. <br><br>  Dado esse objetivo final, outros requisitos surgiram naturalmente.  Kafka deve: <br><br><ul><li>  Seja extremamente rápido </li><li>  Forneça maior rendimento de mensagens </li><li>  Suporte aos modelos Publisher-Subscriber e Point-to-Point </li><li>  Não diminua a velocidade com a adição de consumidores.  Por exemplo, o desempenho das filas e dos tópicos no ActiveMQ se deteriora à medida que o número de consumidores no destino aumenta. </li><li>  Seja escalável horizontalmente;  se uma única mensagem persistente puder fazer isso apenas na velocidade máxima do disco, para aumentar o desempenho, faz sentido ir além dos limites de uma instância do broker </li><li>  Delinear o acesso ao armazenamento e recuperação de mensagens </li></ul><br>  Para conseguir tudo isso, Kafka adotou uma arquitetura que redefiniu as funções e responsabilidades de clientes e intermediários de mensagens.  O modelo JMS é muito focado no broker, onde ele é responsável pela distribuição de mensagens, e os clientes precisam apenas se preocupar em enviar e receber mensagens.  Kafka, por outro lado, é orientado ao cliente, com o cliente assumindo muitas das funções de um corretor tradicional, como a distribuição justa de mensagens relevantes entre os consumidores, em troca de receber um corretor extremamente rápido e escalável.  Para as pessoas que trabalham com sistemas de mensagens tradicionais, trabalhar com Kafka requer uma mudança fundamental de atitude. <br>  Essa direção de engenharia levou à criação de uma infraestrutura de mensagens que pode aumentar a taxa de transferência em muitas ordens de magnitude em comparação com um corretor convencional.  Como veremos, essa abordagem está cheia de compromissos, o que significa que o Kafka não é adequado para certos tipos de cargas e software instalado. <br><br><h3>  Modelo de destino unificado </h3><br>  Para cumprir os requisitos descritos acima, Kafka combinou a assinatura de publicação e as mensagens ponto a ponto em um tipo de destinatário - <i>tópico</i> .  Isso é confuso para as pessoas que trabalham com sistemas de mensagens, onde a palavra "tópico" se refere a um mecanismo de transmissão do qual (a partir do tópico) a leitura não é confiável (não é durável).  Os tópicos Kafka devem ser considerados um tipo de destino híbrido, conforme definido na introdução deste livro. <br><blockquote>  No restante deste capítulo, a menos que especifique explicitamente o contrário, o termo tópico se referirá ao tópico Kafka. </blockquote><br>  Para entender completamente como os tópicos se comportam e quais garantias eles fornecem, primeiro precisamos considerar como eles são implementados no Kafka. <br>  <i>Cada tópico no Kafka tem seu próprio diário.</i> <br>  Os produtores que enviam mensagens para Kafka anexam-se a esta revista, e os consumidores lêem a revista usando indicadores que avançam constantemente.  Kafka exclui periodicamente as partes mais antigas do diário, independentemente de as mensagens nessas partes terem sido lidas ou não.  Uma parte central do design da Kafka é que o broker não se importa se as mensagens são lidas ou não - essa é a responsabilidade do cliente. <br><blockquote>  Os termos "diário" e "índice" não são encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka</a> .  Esses termos conhecidos são usados ​​aqui para ajudar a entender. </blockquote><br>  Esse modelo é completamente diferente do ActiveMQ, em que as mensagens de todas as filas são armazenadas em um diário e o broker marca as mensagens como excluídas após serem lidas. <br>  Vamos agora um pouco mais fundo e examinar a revista de tópicos com mais detalhes. <br>  A Revista Kafka consiste em várias partições ( <a href="">Figura 3-1</a> ).  O Kafka garante pedidos rigorosos em todas as partições.  Isso significa que as mensagens gravadas na partição em uma determinada ordem serão lidas na mesma ordem.  Cada partição é implementada como um arquivo de log contínuo (log) que contém um <i>subconjunto de</i> todas as mensagens enviadas ao tópico por seus produtores.  O tópico criado contém uma partição por padrão.  O particionamento é a ideia central de Kafka para dimensionamento horizontal. <br><br><img src="https://habrastorage.org/webt/tm/w2/yf/tmw2yf3lanppqtrumxoidotplhi.png"><br>  <i>Figura 3-1.</i>  <i>Divisórias Kafka</i> <br><br>  Quando o produtor envia uma mensagem para o tópico Kafka, ele decide para qual partição enviar a mensagem.  Consideraremos isso com mais detalhes posteriormente. <br><br><h2>  Lendo mensagens </h2><br>  Um cliente que deseja ler mensagens controla um ponteiro nomeado chamado <i>grupo de consumidores</i> , que indica o <i>deslocamento de uma</i> mensagem em uma partição.  Um deslocamento é uma posição com um número crescente que começa em 0 no início da partição.  Esse grupo de consumidores, referido na API por meio de um identificador definido pelo usuário group_id, corresponde a um <i>único consumidor ou sistema lógico</i> . <br><br>  A maioria dos sistemas de mensagens lê dados do destinatário através de várias instâncias e threads para processar mensagens em paralelo.  Assim, geralmente haverá muitos casos de consumidores que compartilham o mesmo grupo de consumidores. <br><br>  O problema de leitura pode ser representado da seguinte maneira: <br><br><ul><li>  O tópico possui várias partições </li><li>  Vários grupos de consumidores podem usar o tópico ao mesmo tempo. </li><li>  Um grupo de consumidores pode ter várias instâncias separadas. </li></ul><br>  Esse é um problema não trivial de muitos para muitos.  Para entender como o Kafka lida com os relacionamentos entre grupos de consumidores, instâncias de consumidores e partições, vamos dar uma olhada em uma série de scripts de leitura cada vez mais complexos. <br><br><h3>  Consumidores e grupos de consumidores </h3><br>  Vamos considerar um tópico de partição única como ponto de partida ( <a href="">Figura 3-2</a> ). <br><br><img src="https://habrastorage.org/webt/6z/tz/dh/6ztzdhqmjweck-z15htxb2xbe28.png"><br>  <i>Figura 3-2.</i>  <i>O consumidor lê da partição</i> <br><br>  Quando uma instância do consumidor é conectada com seu próprio group_id nesse tópico, é designada uma partição para leitura e um deslocamento nessa partição.  A posição desse deslocamento é configurada no cliente como um ponteiro para a posição mais recente (a mensagem mais recente) ou a posição mais antiga (a mensagem mais antiga).  O consumidor solicita (pesquisas) mensagens do tópico, o que leva à leitura sequencial do diário. <br>  A posição de deslocamento é confirmada regularmente de volta ao Kafka e salva como mensagens no tópico interno <i>_consumer_offsets</i> .  As mensagens de leitura ainda não são excluídas, ao contrário de um broker regular, e o cliente pode retroceder o deslocamento para processar novamente as mensagens já exibidas. <br><br>  Quando um segundo consumidor lógico é conectado usando outro group_id, ele controla um segundo ponteiro que é independente do primeiro ( <a href="">Figura 3-3</a> ).  Assim, o tópico Kafka atua como uma fila na qual há um consumidor e, como um tópico regular, como assinante-publicador (pub-sub), ao qual vários consumidores estão inscritos, com a vantagem adicional de que todas as mensagens são salvas e podem ser processadas várias vezes. <br><br><img src="https://habrastorage.org/webt/qe/v1/yk/qev1yktga3s-g1gqlynylbe3n9w.png"><br>  <i>Figura 3-3.</i>  <i>Dois consumidores em diferentes grupos de consumidores lêem da mesma partição</i> <br><br><h3>  Consumidores no grupo de consumidores </h3><br>  Quando uma instância do consumidor lê dados da partição, controla completamente o ponteiro e processa as mensagens, conforme descrito na seção anterior. <br>  Se várias instâncias dos consumidores foram conectadas com o mesmo group_id ao tópico com uma partição, a instância que foi conectada por último terá controle sobre o ponteiro e a partir de então receberá todas as mensagens ( <a href="">Figura 3-4</a> ). <br><br><img src="https://habrastorage.org/webt/0j/ao/f2/0jaof2mdwg3cqvmwemhtxkrltuq.png"><br>  <i>Figura 3-4.</i>  <i>Dois consumidores no mesmo grupo de consumidores lêem da mesma partição</i> <br><br>  Esse modo de processamento, no qual o número de instâncias de consumidores excede o número de partições, pode ser considerado como um tipo de consumidor de monopólio.  Isso pode ser útil se você precisar do cluster "ativo-passivo" (ou "quente e quente") de suas instâncias de consumidores, embora a operação paralela de vários consumidores ("ativo-ativo" ou "quente e quente") seja muito mais típica do que os consumidores no modo de espera. <br><blockquote>  Esse comportamento de distribuição de mensagens, descrito acima, pode ser surpreendente em comparação com o comportamento de uma fila JMS comum.  Nesse modelo, as mensagens enviadas para a fila serão distribuídas igualmente entre os dois consumidores. </blockquote><br>  Na maioria das vezes, quando criamos várias instâncias de compiladores, fazemos isso para processamento paralelo de mensagens, ou para aumentar a velocidade da leitura ou para aumentar a estabilidade do processo de leitura.  Como apenas uma instância de um consumidor pode ler dados de uma partição, como isso é alcançado no Kafka? <br><br>  Uma maneira de fazer isso é usar uma instância do consumidor para ler todas as mensagens e enviá-las ao conjunto de encadeamentos.  Embora essa abordagem aumente a taxa de transferência de processamento, aumenta a complexidade da lógica dos consumidores e não faz nada para aumentar a estabilidade do sistema de leitura.  Se uma instância do consumidor desligar devido a uma falha de energia ou evento semelhante, a revisão será interrompida. <br><br>  A maneira canônica de resolver esse problema no Kafka é usar mais partições. <br><br><h3>  Particionamento </h3><br>  Partições são o principal mecanismo para paralelizar a leitura e o dimensionamento do tópico além da largura de banda de uma instância do broker.  Para entender melhor isso, vejamos uma situação em que há um tópico com duas partições e um consumidor assina esse tópico ( <a href="">Figura 3-5</a> ). <br><br><img src="https://habrastorage.org/webt/en/9g/ct/en9gct0o017cqp8buawguwlscty.png"><br>  <i>Figura 3-5.</i>  <i>Um consumidor lê de várias partições</i> <br><br>  Nesse cenário, o consultor tem controle sobre os ponteiros correspondentes ao seu group_id em ambas as partições, e a leitura das mensagens de ambas as partições é iniciada. <br>  Quando um compurador adicional é adicionado a este tópico para o mesmo group_id, o Kafka reatribui (realoca) uma das partições da primeira para a segunda.  Depois disso, cada instância do consumidor será subtraída de uma partição do tópico ( <a href="">Figura 3-6</a> ). <br><br>  Para garantir que as mensagens sejam processadas em paralelo em 20 threads, você precisará de pelo menos 20 partições.  Se houver menos partições, você ainda terá consumidores com os quais não trabalhar, conforme descrito anteriormente na discussão de monitores exclusivos. <br><br><img src="https://habrastorage.org/webt/8b/a0/um/8ba0umn2yzr9yy3vztonhdfiub0.png"><br>  <i>Figura 3-6.</i>  <i>Dois consumidores no mesmo grupo de consumidores lêem partições diferentes</i> <br><br>  Esse esquema reduz significativamente a complexidade do broker Kafka em comparação com a distribuição de mensagens necessária para suportar a fila JMS.  Não há necessidade de cuidar dos seguintes pontos: <br><br><ul><li>  Qual consumidor deve receber a próxima mensagem com base na distribuição round-robin, capacidade atual do buffer de pré-busca ou mensagens anteriores (como nos grupos de mensagens JMS). </li><li>  Quais mensagens foram enviadas para quais consumidores e se eles devem ser reenviados em caso de falha. </li></ul><br>  Tudo o que o corretor Kafka deve fazer é enviar consistentemente mensagens ao consultor quando este solicitar. <br><br>  No entanto, os requisitos para paralelizar a revisão e reenviar mensagens sem êxito não desaparecem - a responsabilidade por eles simplesmente passa do intermediário para o cliente.  Isso significa que eles devem ser incluídos no seu código. <br><br><h2>  Enviando mensagens </h2><br>  A responsabilidade de decidir para qual partição enviar a mensagem é o produtor da mensagem.  Para entender o mecanismo pelo qual isso é feito, você primeiro precisa considerar o que exatamente estamos enviando. <br><br>  Enquanto no JMS usamos uma estrutura de mensagens com metadados (cabeçalhos e propriedades) e um corpo contendo uma carga, no Kafka a mensagem é <i>um par de valores-chave</i> .  A carga útil da mensagem é enviada como um valor.  Uma chave, por outro lado, é usada principalmente para particionar e deve conter uma <i>chave específica da lógica de negócios</i> para colocar as mensagens relacionadas na mesma partição. <br><br>  No capítulo 2, discutimos o cenário de apostas on-line, quando eventos relacionados devem ser processados ​​em ordem por um único consumidor: <br><br><ol><li>  A conta do usuário está configurada. </li><li>  O dinheiro é creditado na conta. </li><li>  É feita uma aposta que retira dinheiro da conta. </li></ol><br>  Se cada evento for uma mensagem enviada ao tópico, nesse caso, o identificador da conta será a chave natural. <br>  Quando uma mensagem é enviada usando a API do Kafka Producer, ela é passada para a função de partição, que, dada a mensagem e o estado atual do cluster Kafka, retorna o identificador da partição para a qual a mensagem deve ser enviada.  Esse recurso é implementado em Java através da interface do Partitioner. <br><br>  Essa interface é a seguinte: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Partitioner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String topic, Object key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, Object value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] valueBytes, Cluster cluster)</span></span></span></span>; }</code> </pre> <br>  A implementação do Particionador usa o algoritmo de hash de uso geral padrão sobre a chave ou round-robin se a chave não for especificada para determinar a partição.  Esse valor padrão funciona bem na maioria dos casos.  No entanto, no futuro você vai querer escrever o seu. <br><br><h3>  Escrevendo sua própria estratégia de particionamento </h3><br>  Vejamos um exemplo quando você deseja enviar metadados junto com a carga útil da mensagem.  A carga útil em nosso exemplo é uma instrução para fazer um depósito em uma conta de jogo.  Uma instrução é algo que gostaríamos de garantir para não modificar durante a transmissão, e queremos ter certeza de que apenas um sistema superior confiável pode iniciar essa instrução.  Nesse caso, os sistemas de envio e recebimento concordam com o uso da assinatura para autenticar a mensagem. <br>  Em um JMS regular, simplesmente definimos a propriedade de assinatura da mensagem e a adicionamos à mensagem.  No entanto, Kafka não nos fornece um mecanismo para transmitir metadados - apenas a chave e o valor. <br><br>  Como o valor é a carga útil de uma transferência bancária (carga útil de transferência bancária), cuja integridade queremos manter, não temos escolha a não ser determinar a estrutura de dados para uso na chave.  Supondo que precisamos de um identificador de conta para particionar, como todas as mensagens relacionadas à conta devem ser processadas em ordem, criaremos a seguinte estrutura JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"541661622185851c248b41bf0cea7ad0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"accountId"</span></span>: <span class="hljs-string"><span class="hljs-string">"10007865234"</span></span> }</code> </pre> <br>  Como o valor da assinatura varia de acordo com a carga, a estratégia padrão de hash da interface do Partitioner não agrupará mensagens relacionadas de maneira confiável.  Portanto, precisaremos escrever nossa própria estratégia, que analisará essa chave e compartilhará o valor de accountId. <br><blockquote>  O Kafka inclui somas de verificação para detectar corrupção de mensagens no repositório e possui um conjunto completo de recursos de segurança.  Mesmo assim, às vezes aparecem requisitos específicos do setor, como o acima. </blockquote><br>  A estratégia de particionamento do usuário deve garantir que todas as mensagens relacionadas terminem na mesma partição.  Embora isso pareça simples, o requisito pode ser complicado devido à importância de solicitar mensagens relacionadas e à correção do número de partições no tópico. <br><br>  O número de partições no tópico pode mudar ao longo do tempo, pois elas podem ser adicionadas se o tráfego ultrapassar as expectativas iniciais.  Assim, as chaves de mensagem podem ser associadas à partição para a qual foram originalmente enviadas, implicando uma parte do estado que deve ser distribuída entre as instâncias do produtor. <br><br>  Outro fator a considerar é a distribuição uniforme de mensagens entre partições.  Como regra, as chaves não são distribuídas igualmente entre as mensagens e as funções de hash não garantem uma distribuição justa de mensagens para um pequeno conjunto de chaves. <br>  É importante observar que, não importa como você decida dividir as mensagens, talvez o próprio separador precise ser reutilizado. <br><br>  Considere o requisito para replicação de dados entre clusters Kafka em diferentes localizações geográficas.  Para esse fim, o Kafka vem com uma ferramenta de linha de comando chamada MirrorMaker, usada para ler mensagens de um cluster e transferi-las para outro. <br><br>  O MirrorMaker deve entender as chaves do tópico replicado para manter a ordem relativa entre as mensagens durante a replicação entre clusters, pois o número de partições para esse tópico pode não coincidir em dois clusters. <br><br>  Estratégias de particionamento personalizadas são relativamente raras, pois hashes padrão ou rodízio funcionam com êxito na maioria dos cenários.  No entanto, se você precisar de garantias estritas de pedido ou extrair metadados das cargas, o particionamento é algo que você deve examinar mais de perto. <br><br>  Os benefícios de escalabilidade e desempenho da Kafka vêm da transferência de algumas das responsabilidades de um corretor tradicional para um cliente.  Nesse caso, é tomada uma decisão sobre a distribuição de mensagens potencialmente relacionadas entre vários consumidores que trabalham em paralelo. <br><blockquote>  Os corretores JMS também devem lidar com esses requisitos.  Curiosamente, o mecanismo para enviar mensagens relacionadas para a mesma conta implementada por meio dos Grupos de Mensagens JMS (um tipo de estratégia de balanceamento de SLB) também requer que o remetente marque as mensagens como relacionadas.  No caso do JMS, o broker é responsável por enviar esse grupo de mensagens relacionadas a um dos muitos clientes e transferir a propriedade do grupo se o cliente cair. </blockquote><br><h2>  Acordo de Produtor </h2><br>  Particionar não é a única coisa a considerar ao enviar mensagens.  Vejamos os métodos send () da classe Producer na API Java: <br><br><pre> <code class="java hljs">Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record); Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record, Callback callback);</code> </pre> <br>  Deve-se notar imediatamente que ambos os métodos retornam Future, o que indica que a operação de envio não é executada imediatamente.  Como resultado, verifica-se que a mensagem (ProducerRecord) é gravada no buffer de envio para cada partição ativa e transmitida ao broker no fluxo em segundo plano na biblioteca do cliente Kafka.  Embora isso torne o trabalho incrivelmente rápido, significa que um aplicativo inexperiente pode perder mensagens se o processo for interrompido. <br><br>  Como sempre, existe uma maneira de tornar a operação de envio mais confiável devido ao desempenho.  O tamanho desse buffer pode ser definido como 0 e o encadeamento do aplicativo de envio será forçado a esperar até que a mensagem seja enviada ao broker, da seguinte maneira: <br><br><pre> <code class="java hljs">RecordMetadata metadata = producer.send(record).get();</code> </pre> <br><h2>  Mais uma vez sobre a leitura de mensagens </h2><br>  A leitura de mensagens tem dificuldades adicionais que precisam ser consideradas.  Diferente da API JMS, que pode iniciar um ouvinte de mensagem em resposta a uma mensagem, a interface <i>Consumer</i> Kafka é pesquisada apenas.  Vamos dar uma olhada no método <i>poll ()</i> usado para esta finalidade: <br><br><pre> <code class="java hljs">ConsumerRecords &lt; K, V &gt; poll(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeout);</code> </pre> <br>  O valor de retorno do método é uma estrutura de contêiner que contém vários objetos <i>ConsumerRecord</i> de potencialmente várias partições.  <i>Um ConsumerRecord em</i> si é um objeto detentor de um par de valores-chave com metadados associados, como a partição da qual é derivada. <br><br>  Conforme discutido no Capítulo 2, devemos lembrar constantemente o que acontece com as mensagens depois que elas são processadas com ou sem êxito, por exemplo, se o cliente não puder processar a mensagem ou se interromper o trabalho.  No JMS, isso foi tratado através do modo de reconhecimento.  O broker excluirá a mensagem processada com êxito ou entregará novamente a mensagem bruta ou invertida (desde que as transações tenham sido usadas). <br>  Kafka funciona de uma maneira completamente diferente.  As mensagens não são excluídas no broker após a revisão, e a responsabilidade pelo que acontece após a falha está no próprio código. <br><br>  Como já dissemos, um grupo de consumidores está associado a um deslocamento na revista.  A posição do log associada a esse viés corresponde à próxima mensagem que será emitida em resposta a <i>poll ()</i> .  Crucial na leitura é o momento em que esse deslocamento aumenta. <br><br>  Retornando ao modelo de leitura discutido anteriormente, o processamento de mensagens consiste em três estágios: <br><br><ol><li>  Recupere uma mensagem para ler. </li><li>  Processe a mensagem. </li><li>  Confirme a mensagem. </li></ol><br>  O Kafka Consumer Advisor vem com a <i>opção de</i> configuração <i>enable.auto.commit</i> .  Essa é uma configuração padrão comumente usada, como é geralmente o caso das configurações que contêm a palavra "automático". <br><br>  Antes do Kafka 0.10, o cliente que usava esse parâmetro enviava o deslocamento da última mensagem lida na próxima chamada <i>poll ()</i> após o processamento.  Isso significava que todas as mensagens que já foram buscadas poderiam ser processadas novamente se o cliente já as tivesse processado, mas foram destruídas inesperadamente antes de chamar <i>poll ()</i> .  Como o broker não mantém nenhum status com relação a quantas vezes a mensagem foi lida, o próximo consumidor que recupera essa mensagem não saberá que algo ruim aconteceu.  Esse comportamento foi pseudo-transacional.  O deslocamento foi confirmado apenas no caso de processamento bem-sucedido da mensagem, mas se o cliente interrompido, o broker enviou novamente a mesma mensagem para outro cliente.  Esse comportamento foi consistente com a garantia de entrega " <i>pelo menos uma vez</i> ". <br><br>  No Kafka 0.10, o código do cliente foi alterado de forma que o commit começou a ser iniciado periodicamente pela biblioteca do cliente, de acordo com a configuração <i>auto.commit.interval.ms</i> .  Esse comportamento está em algum lugar entre os modos JMS AUTO_ACKNOWLEDGE e DUPS_OK_ACKNOWLEDGE.  Ao usar a confirmação automática, as mensagens podem ser confirmadas independentemente de terem sido realmente processadas - isso pode acontecer no caso de um consumidor lento.  Se o computador foi interrompido, as mensagens foram recuperadas pelo computador seguinte, iniciando em uma posição segura, o que poderia levar a uma mensagem pulando.  Nesse caso, Kafka não perdeu mensagens, o código de leitura simplesmente não as processou. <br><br>  Esse modo tem as mesmas perspectivas da versão 0.9: as mensagens podem ser processadas, mas no caso de uma falha, o deslocamento pode não ser fechado, o que pode levar a uma duplicação da entrega.  Quanto mais mensagens você recuperar ao fazer <i>poll ()</i> , maior será esse problema. <br><br>  Conforme discutido na seção "Subtraindo mensagens da fila" no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 2</a> , não existe entrega de mensagens únicas no sistema de mensagens, dados os modos de falha. <br><br>  No Kafka, existem duas maneiras de corrigir (confirmar) um deslocamento (deslocamento): automática e manualmente.  Nos dois casos, as mensagens podem ser processadas várias vezes, caso a mensagem tenha sido processada, mas falhou antes de ser confirmada.  Também não é possível processar a mensagem se a confirmação ocorreu em segundo plano e seu código foi concluído antes de iniciar o processamento (possivelmente no Kafka 0.9 e versões anteriores). <br><br>  Você pode controlar o processo de confirmar compensações manualmente na API do Kafka <i>Consumer</i> , definindo <i>enable.auto.commit</i> como false e chamando explicitamente um dos seguintes métodos: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Se você deseja processar a mensagem “pelo menos uma vez”, confirme o deslocamento manualmente usando <i>commitSync ()</i> executando este comando imediatamente após o processamento das mensagens. <br><br>  Esses métodos não permitem que mensagens reconhecidas sejam processadas antes de serem processadas, mas não fazem nada para eliminar a possível duplicação de processamento, criando ao mesmo tempo a aparência de transacionalidade.  Kafka não tem transações.  O cliente não tem a oportunidade de fazer o seguinte: <br><br><ul><li>  Reverter automaticamente uma mensagem de reversão.  Os próprios consumidores devem lidar com exceções decorrentes de cargas problemáticas e desconexões de back-end, pois não podem confiar no broker para entregar novamente as mensagens. </li><li>  Envie mensagens para vários tópicos em uma operação atômica.  Como veremos em breve, o controle sobre vários tópicos e partições pode estar localizado em máquinas diferentes no cluster Kafka, que não coordenam as transações durante o envio.  No momento da redação deste artigo, algum trabalho foi feito para tornar isso possível com o KIP-98. </li><li>  Associe a leitura de uma mensagem de um tópico ao envio de outra mensagem para outro tópico.  Novamente, a arquitetura do Kafka depende de muitas máquinas independentes funcionando como um barramento e nenhuma tentativa é feita para ocultá-lo.  Por exemplo, não há componentes de API que permitam que o <i>Consumidor</i> e o <i>Produtor</i> sejam vinculados em uma transação.  No JMS, isso é fornecido pelo objeto <i>Session a</i> partir do qual <i>MessageProducers</i> e <i>MessageConsumers</i> são criados. </li></ul><br>  Se não podemos confiar nas transações, como podemos fornecer semânticas mais próximas das fornecidas pelos sistemas de mensagens tradicionais? <br><br>  Se houver a possibilidade de o deslocamento do consumidor aumentar antes que a mensagem tenha sido processada, por exemplo, durante a falha do cliente, o cliente não terá como saber se o grupo de clientes perdeu a mensagem ao receber uma partição.  Assim, uma estratégia é rebobinar o deslocamento para a posição anterior.  A API do Kafka Consumer Advisor fornece os seguintes métodos para isso: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopicPartition partition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekToBeginning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection &lt; TopicPartition &gt; partitions)</span></span></span></span>;</code> </pre> <br>  O método <i>seek ()</i> pode ser usado com o método <br>  <i>offsetsForTimes (Map &lt;TopicPartition, Long&gt; timestampsToSearch)</i> para retroceder para um estado em qualquer ponto específico do passado. <br><br>  Implicitamente, o uso dessa abordagem significa que é muito provável que algumas mensagens processadas anteriormente sejam lidas e processadas novamente.  Para evitar isso, podemos usar a leitura idempotente, conforme descrito no Capítulo 4, para rastrear mensagens visualizadas anteriormente e eliminar duplicatas. <br><br>  Como alternativa, o código do seu consumidor pode ser simples se a perda ou duplicação de mensagens for permitida.  Quando analisamos os cenários de uso nos quais o Kafka geralmente é usado, por exemplo, processando eventos de log, métricas, rastreamento de cliques etc., entendemos que é improvável que a perda de mensagens individuais tenha um impacto significativo nos aplicativos vizinhos.  Nesses casos, os valores padrão são aceitáveis.  Por outro lado, se seu aplicativo precisar transferir pagamentos, você deverá cuidar cuidadosamente de cada mensagem individual.  Tudo se resume ao contexto. <br><br>  Observações pessoais mostram que, com o aumento da intensidade da mensagem, o valor de cada mensagem individual diminui.  As mensagens de alto volume tendem a se tornar valiosas quando exibidas de forma agregada. <br><br><h2>  Alta disponibilidade </h2><br>  A abordagem de alta disponibilidade de Kafka é muito diferente do ActiveMQ.  O Kafka é desenvolvido com base em clusters escaláveis ​​horizontalmente, nos quais todas as instâncias do broker recebem e distribuem mensagens simultaneamente. <br><br>  O cluster Kafka consiste em várias instâncias do broker em execução em servidores diferentes.  O Kafka foi projetado para funcionar em um hardware independente convencional, em que cada nó tem seu próprio armazenamento dedicado.  O uso do SAN (Network Attached Storage) não é recomendado porque vários nós de computação podem competir por intervalos de tempo de armazenamento e criar conflitos. <br><br>  Kafka é um sistema <i>constantemente</i> ativo.  Muitos usuários grandes do Kafka nunca extinguem seus clusters e o software sempre fornece atualizações por meio de uma reinicialização consistente.  Isso é obtido garantindo a compatibilidade com a versão anterior para mensagens e interações entre os intermediários. <br><br>  Os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intermediários</a> estão conectados a um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cluster de</a> servidores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZooKeeper</a> , que atua como um determinado registro de configuração e é usado para coordenar as funções de cada intermediário.  O ZooKeeper em si é um sistema distribuído que fornece alta disponibilidade através da replicação de informações, estabelecendo um <i>quorum</i> . <br><br>  No caso base, o tópico é criado no cluster Kafka com as seguintes propriedades: <br><br><ul><li>  O número de partições.  Como discutido anteriormente, o valor exato usado aqui depende do nível desejado de leitura simultânea. </li><li>  O coeficiente de replicação (fator) determina quantas instâncias do broker no cluster devem conter os logs para esta partição. </li></ul><br>  Usando o ZooKeepers para coordenação, Kafka está tentando distribuir de forma justa novas partições entre os intermediários no cluster.  Isso é feito por uma instância, que atua como o Controller. <br><br>  Em tempo <i>de</i> execução <i>para cada partição do tópico, o</i> <i>Controlador</i> atribui ao intermediário as funções de <i>líder</i> (líder, mestre, líder) e <i>seguidores</i> (seguidores, escravos, subordinados).  O corretor, atuando como líder dessa partição, é responsável por receber todas as mensagens enviadas a ele pelos produtores e distribuir mensagens aos consumidores.  Ao enviar mensagens para uma partição de tópico, elas são replicadas para todos os nós do intermediário que atuam como seguidores dessa partição.  Cada nó que contém os logs da partição é chamado de <i>réplica</i> .  Um corretor pode atuar como líder em algumas partições e como seguidor em outras. <br><br>  Um seguidor que contém todas as mensagens armazenadas pelo líder é chamado de <i>réplica sincronizada</i> (uma réplica em estado sincronizado, réplica sincronizada).  Se o intermediário que atua como líder da partição for desconectado, qualquer intermediário que esteja no estado atualizado ou sincronizado para esta partição poderá assumir a função de líder.  Este é um design incrivelmente sustentável. <br><br>  Parte da configuração do produtor é o parâmetro <i>acks</i> , que determina quantas réplicas devem confirmar o recebimento de uma mensagem antes que o fluxo do aplicativo continue enviando: 0, 1 ou todos.  Se o valor estiver definido como <i>todos</i> , quando a mensagem for recebida, o líder enviará uma confirmação de volta ao produtor assim que receber a confirmação das várias réplicas (incluindo ele mesmo) definidas pela <i>configuração do</i> tópico <i>min.insync.replicas</i> (por padrão 1).  Se a mensagem não puder ser replicada com êxito, o produtor lançará uma exceção para o aplicativo ( <i>NotEnoughReplicas</i> ou <i>NotEnoughReplicasAfterAppend</i> ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em uma configuração típica, um tópico é criado com um coeficiente de replicação 3 (1 líder, 2 seguidores para cada partição) e o parâmetro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min.insync.replicas é</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definido como 2. Nesse caso, o cluster permitirá que um dos intermediários que gerenciam a partição seja desconectado. sem afetar os aplicativos clientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso nos leva de volta ao compromisso já familiar entre desempenho e confiabilidade. A replicação ocorre devido ao tempo de espera adicional para agradecimentos (agradecimentos) dos seguidores. Embora, como é executado em paralelo, a replicação de pelo menos três nós tenha o mesmo desempenho que dois (ignorando o aumento no uso da largura de banda da rede).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esse esquema de replicação, o Kafka evita inteligentemente a necessidade de gravar fisicamente cada mensagem no disco usando a operação </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cada mensagem enviada pelo produtor será gravada no log da partição, mas, conforme discutido no Capítulo 2, a gravação no arquivo é inicialmente executada no buffer do sistema operacional. Se essa mensagem for replicada para outra instância do Kafka e estiver em sua memória, a perda de um líder não significa que a mensagem foi perdida - uma réplica sincronizada pode assumir isso sozinha. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desativar a operação </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que Kafka pode receber mensagens na velocidade com que pode gravá-las na memória. Por outro lado, quanto mais você evitar a descarga da memória no disco, melhor. Por esse motivo, não é incomum os corretores Kafka alocarem 64 GB ou mais de memória. Esse uso de memória significa que uma instância do Kafka pode funcionar facilmente em velocidades milhares de vezes mais rápidas que um broker de mensagens tradicional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Kafka também pode ser configurado para usar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para pacotes de mensagens. Como tudo no Kafka é orientado a pacotes, ele realmente funciona muito bem para muitos casos de uso e é uma ferramenta útil para usuários que exigem garantias muito fortes. A maior parte do desempenho puro de Kafka está relacionada às mensagens enviadas ao broker como pacotes e ao fato de que essas mensagens são lidas do broker em blocos sucessivos usando </font><font style="vertical-align: inherit;">operações de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cópia zero</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (operações que não executam a tarefa de copiar dados de uma área de memória para outro). O último é um grande ganho em termos de desempenho e recursos e só é possível através do uso da estrutura de dados de log subjacente que define o esquema de partição.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em um cluster Kafka, é possível um desempenho muito mais alto do que ao usar um único broker Kafka, pois as partições de tópicos podem ser dimensionadas horizontalmente em muitas máquinas separadas. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumário </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste capítulo, examinamos como a arquitetura Kafka reinterpreta o relacionamento entre clientes e corretores para fornecer um pipeline de mensagens incrivelmente robusto, com largura de banda muitas vezes maior que um corretor de mensagens comum. Discutimos a funcionalidade usada para atingir esse objetivo e revisamos brevemente a arquitetura dos aplicativos que fornecem essa funcionalidade. No próximo capítulo, discutiremos problemas comuns que os aplicativos de mensagens precisam resolver e discutir estratégias para resolvê-los. Concluímos o capítulo descrevendo como falar sobre tecnologias de mensagens em geral, para que você possa avaliar a adequação deles para seus casos de uso. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tradução concluída: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continua ...</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466585/">https://habr.com/ru/post/pt466585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466575/index.html">Passando listas bidimensionais de python para DLL</a></li>
<li><a href="../pt466577/index.html">Como dois alunos fizeram o jogo no iOS e quanto ganharam nele</a></li>
<li><a href="../pt466579/index.html">A história dos algoritmos de randomização Tetris</a></li>
<li><a href="../pt466581/index.html">Darwinismo quântico: uma idéia que explica a realidade objetiva passa no primeiro teste</a></li>
<li><a href="../pt466583/index.html">Uma Breve História do Detector de Mentiras</a></li>
<li><a href="../pt466587/index.html">Variáveis ​​CSS e tema de cores para o site em várias linhas</a></li>
<li><a href="../pt466589/index.html">Como receber dados do Google Analytics usando R no Microsoft SQL Server</a></li>
<li><a href="../pt466591/index.html">MVC sem C: O que mudará o SwiftUI na arquitetura do aplicativo?</a></li>
<li><a href="../pt466593/index.html">Situação: nuvem híbrida e perspectivas de IaaS</a></li>
<li><a href="../pt466597/index.html">Histórico do Segundo Lugar no Mini AI Cup 4: Paper IO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>