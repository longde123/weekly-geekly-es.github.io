<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏾 👃🏽 👨🏿‍🎨 22 Tipps für einen Angular-Entwickler. Teil 1 ✌🏻 ⚪️ 👌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels, dessen erster Teil der Übersetzung wir veröffentlichen, sagt, dass er seit etwa zwei Jahren an einer groß angelegten Angular-A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>22 Tipps für einen Angular-Entwickler. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/425661/">  Der Autor des Artikels, dessen erster Teil der Übersetzung wir veröffentlichen, sagt, dass er seit etwa zwei Jahren an einer groß angelegten Angular-Anwendung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trade Me arbeitet</a> .  In den letzten Jahren hat das Anwendungsentwicklungsteam das Projekt sowohl hinsichtlich der Codequalität als auch der Leistung ständig verbessert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/9dc/3bc/7bb9dc3bca3b7f924e2835f11f666917.jpg"></div><br>  Diese Reihe von Materialien konzentriert sich auf die Entwicklungsansätze des Trade Me-Teams, die in Form von mehr als zwei Dutzend Empfehlungen zu Technologien wie Angular, TypeScript, RxJS und @ ngrx / store zum Ausdruck kommen.  Darüber hinaus wird universellen Programmiertechniken besondere Aufmerksamkeit gewidmet, die darauf abzielen, den Anwendungscode sauberer und genauer zu machen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Über trackBy</font> </h2><br>  Verwenden <code>ngFor</code> dieses Konstrukt mit <code>ngFor</code> zum Durchlaufen von Arrays in Vorlagen mit der Funktion <code>trackBy</code> , die für jedes Element einen eindeutigen Bezeichner zurückgibt. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Wenn sich das Array ändert, rendert Angular den gesamten DOM-Baum neu.  Wenn Sie jedoch <code>trackBy</code> , weiß das System, welches Element geändert wurde, und nimmt Änderungen am DOM vor, die nur für dieses bestimmte Element gelten.  Details dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items;"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ item }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs django"><span class="xml"><span class="xml">//   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items; trackBy: trackByFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ item }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //   trackByFn(index, item) {     return item.id; //  id,   }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">2. Schlüsselwörter const und let</font> </h2><br>  Wenn Sie eine Variable deklarieren möchten, deren Wert Sie nicht ändern <code>const</code> , verwenden Sie das Schlüsselwort <code>const</code> . <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Die angemessene Verwendung der Schlüsselwörter <code>let</code> und <code>const</code> verdeutlicht die Absicht hinsichtlich der Verwendung von Entitäten, deren Verwendung deklariert wurde.  Darüber hinaus erleichtert dieser Ansatz das Erkennen von Problemen, die durch versehentliches Überschreiben konstanter Werte verursacht werden.  In dieser Situation wird ein Kompilierungsfehler ausgelöst.  Darüber hinaus wird die Lesbarkeit des Codes verbessert. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> car = <span class="hljs-string"><span class="hljs-string">'ludicrous car'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">let</span></span> myCar = `My <span class="hljs-variable"><span class="hljs-variable">${car}</span></span>`; <span class="hljs-attribute"><span class="hljs-attribute">let</span></span> yourCar = `Your <span class="hljs-variable"><span class="hljs-variable">${car}</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (iHaveMoreThanOneCar) {  <span class="hljs-attribute"><span class="hljs-attribute">myCar</span></span> = `<span class="hljs-variable"><span class="hljs-variable">${myCar}</span></span>s`; } <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (youHaveMoreThanOneCar) {  <span class="hljs-attribute"><span class="hljs-attribute">yourCar</span></span> = `<span class="hljs-variable"><span class="hljs-variable">${youCar}</span></span>s`; }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs powershell">//  car  ,     car  const car = <span class="hljs-string"><span class="hljs-string">'ludicrous car'</span></span>; let myCar = `My <span class="hljs-variable"><span class="hljs-variable">$</span></span>{car}`; let yourCar = `Your <span class="hljs-variable"><span class="hljs-variable">$</span></span>{car}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iHaveMoreThanOneCar) {  myCar = `${myCar}s`; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (youHaveMoreThanOneCar) {  yourCar = `${youCar}s`; }</code> </pre> <br><h2>  <font color="#3AC1EF">3. Fördererbetreiber</font> </h2><br>  Verwenden Sie bei der Arbeit mit RxJS Pipeline-Operatoren. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Die übermittelten Operatoren unterstützen den Tree-Shake-Algorithmus, dh, wenn sie importiert werden, wird nur der Code in das Projekt aufgenommen, dessen Ausführung geplant ist.  Dies macht es auch einfach, nicht verwendete Anweisungen in Dateien zu identifizieren. <br><br>  Bitte beachten Sie, dass diese Empfehlung für Angular Version 5.5 und höher relevant ist. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/map'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/take'</span></span>; iAmAnObservable   .map(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.item)   .take(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map, take } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; iAmAnObservable   .pipe(      map(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.item),      take(<span class="hljs-number"><span class="hljs-number">1</span></span>)    );</code> </pre> <br><h2>  <font color="#3AC1EF">4. Isolierung von API-Fixes</font> </h2><br>  Nicht alle APIs sind vollständig stabil und fehlerfrei.  Daher ist es manchmal erforderlich, eine Logik in den Code einzuführen, um API-Probleme zu beheben.  Anstatt diese Logik in Komponenten zu platzieren, in denen gepatchte APIs verwendet werden, ist es besser, sie irgendwo zu isolieren, z. B. in einem Dienst, und auf den entsprechenden Dienst zu verweisen, anstatt auf die problematische API der Komponente. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Der vorgeschlagene Ansatz ermöglicht es, Korrekturen „näher“ an der API zu halten, dh so nah wie möglich an dem Code, aus dem Netzwerkanforderungen gestellt werden.  Infolgedessen wird die Menge an Anwendungscode, der mit problematischen APIs interagiert, reduziert.  Darüber hinaus stellt sich heraus, dass sich alle Korrekturen an einem Ort befinden, wodurch es einfacher wird, mit ihnen zu arbeiten.  Wenn Sie Fehler in der API beheben müssen, ist es viel einfacher, dies in einer einzigen Datei zu tun, als diese Korrekturen in der gesamten Anwendung zu verteilen.  Dies erleichtert nicht nur die Erstellung von Korrekturen, sondern auch die Suche nach dem geeigneten Code im Projekt und dessen Unterstützung. <br><br>  Darüber hinaus können Sie eigene Tags erstellen, z. B. <code>API_FIX</code> (ähnlich dem <code>TODO</code> Tag), und Korrekturen damit <code>API_FIX</code> .  Dies erleichtert das Auffinden solcher Korrekturen. <br><br><h2>  <font color="#3AC1EF">5. Abonnement in der Vorlage</font> </h2><br>  Vermeiden Sie das Abonnieren von Observablen aus Komponenten.  Abonnieren Sie sie stattdessen in Vorlagen. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Asynchrone Pipeline-Betreiber melden sich automatisch ab, was den Code vereinfacht und die manuelle Abonnementverwaltung überflüssig macht.  Dies verringert außerdem das Risiko, dass der Entwickler vergisst, sich von der Komponente abzumelden, was zu Speicherlecks führen kann.  Es ist möglich, die Wahrscheinlichkeit von Speicherlecks mithilfe von Linter-Regeln zu verringern, die darauf abzielen, beobachtbare Objekte zu identifizieren, von denen sie sich nicht abgemeldet haben. <br><br>  Darüber hinaus führt die Anwendung dieses Ansatzes dazu, dass die Komponenten keine statusbehafteten Komponenten mehr sind, was zu Fehlern führen kann, wenn sich Daten außerhalb des Abonnements ändern. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs django"><span class="xml"><span class="xml">//  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ textToDisplay }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  iAmAnObservable   .pipe(      map(value =&gt; value.item),      takeUntil(this._destroyed$)    )   .subscribe(item =&gt; this.textToDisplay = item);</span></span></code> </pre><br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs django"><span class="xml"><span class="xml">//  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ textToDisplay$ | async }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  this.textToDisplay$ = iAmAnObservable   .pipe(      map(value =&gt; value.item)    );</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">6. Abonnements entfernen</font> </h2><br>  <code>takeUntil</code> beim Abonnieren von überwachten Objekten immer sicher, dass Abonnements mit Operatoren wie <code>take</code> , <code>takeUntil</code> usw. korrekt gelöscht werden. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Wenn Sie das beobachtete Objekt nicht abbestellen, führt dies zu Speicherverlusten, da der Stream des beobachteten Objekts offen bleibt. Dies ist auch möglich, nachdem die Komponente zerstört wurde oder nachdem der Benutzer eine andere Seite der Anwendung aufgerufen hat. <br><br>  Noch besser wäre es, eine Linter-Regel zu erstellen, um beobachtete Objekte mit einem gültigen Abonnement zu erkennen. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs javascript">iAmAnObservable   .pipe(      map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.item)        )   .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.textToDisplay = item);</code> </pre><br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br>  Verwenden Sie den Operator <code>takeUntil</code> , wenn Sie die Änderungen eines Objekts beobachten möchten, bis ein anderes beobachtetes Objekt einen bestimmten Wert generiert: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> destroyed$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> {   iAmAnObservable   .pipe(      map(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.item)     <span class="hljs-comment"><span class="hljs-comment">//    iAmAnObservable         takeUntil(this._destroyed$)    )   .subscribe(item =&gt; this.textToDisplay = item); } public ngOnDestroy (): void {   this._destroyed$.next(); }</span></span></code> </pre> <br>  Die Verwendung von so etwas ist ein Muster, mit dem das Entfernen von Abonnements für viele beobachtete Objekte in einer Komponente gesteuert wird. <br><br>  Verwenden Sie <code>take</code> wenn Sie nur den ersten Wert benötigen, der vom beobachteten Objekt zurückgegeben wird: <br><br><pre> <code class="hljs javascript">iAmAnObservable   .pipe(      map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.item),      take(<span class="hljs-number"><span class="hljs-number">1</span></span>),      takeUntil(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._destroyed$)   )   .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.textToDisplay = item);</code> </pre> <br>  Bitte beachten Sie, dass wir hier <code>takeUntil</code> mit <code>take</code> .  Dies geschieht, um Speicherverluste zu vermeiden, die dadurch verursacht werden, dass das Abonnement erst nach Zerstörung der Komponente zum Abrufen des Werts führte.  Wenn die Funktion <code>takeUntil</code> hier nicht verwendet würde, würde das Abonnement bestehen, bis der erste Wert empfangen wurde. Da die Komponente jedoch bereits zerstört worden wäre, wäre dieser Wert niemals empfangen worden, was zu einem Speicherverlust führen würde. <br><br><h2>  <font color="#3AC1EF">7. Verwenden geeigneter Operatoren</font> </h2><br>  Wenden Sie mithilfe von Glättungsoperatoren mit beobachtbaren Objekten diejenigen an, die den Merkmalen des zu lösenden Problems entsprechen. <br><br><ul><li>  Verwenden Sie <code>switchMap</code> wenn Sie die vorherige geplante Aktion ignorieren müssen, wenn eine neue Aktion eintrifft. </li><li>  Verwenden Sie <code>mergeMap</code> falls Sie alle <code>mergeMap</code> Aktionen parallel verarbeiten müssen. </li><li>  Verwenden Sie <code>concatMap</code> wenn Aktionen nacheinander in der Reihenfolge <code>concatMap</code> verarbeitet werden müssen. </li><li>  Verwenden Sie <code>exhaustMap</code> in Situationen, in denen Sie bei der Verarbeitung zuvor empfangener Aktionen neue ignorieren müssen. </li></ul><br>  Details dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Wenn Sie nach Möglichkeit einen Operator verwenden, anstatt den gleichen Effekt durch Kombinieren mehrerer Operatoren in einer Kette zu erzielen, wird die Menge an Anwendungscode reduziert, die an den Benutzer gesendet werden muss.  Die Verwendung eines falsch ausgewählten Operators kann zu einem falschen Programmverhalten führen, da verschiedene Operatoren beobachtete Objekte unterschiedlich verarbeiten. <br><br><h2>  <font color="#3AC1EF">8. Faules Laden</font> </h2><br>  Versuchen Sie dann, wann immer möglich, das verzögerte Laden von Modulen der Angular-Anwendung zu organisieren.  Diese Technik beruht auf der Tatsache, dass etwas nur geladen wird, wenn es verwendet wird.  Beispielsweise wird eine Komponente nur geladen, wenn sie angezeigt werden muss. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Durch verzögertes Laden wird die Größe der Anwendungsmaterialien reduziert, die der Benutzer herunterladen muss.  Dies kann die Download-Geschwindigkeit der Anwendung verbessern, da nicht verwendete Module nicht vom Server auf Clients übertragen werden. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs pgsql">// app.routing.ts { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'not-lazy-loaded'</span></span>, component: NotLazyLoadedComponent }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.routing.ts { path: <span class="hljs-string"><span class="hljs-string">'lazy-load'</span></span>, loadChildren: <span class="hljs-string"><span class="hljs-string">'lazy-load.module#LazyLoadModule'</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> lazy-load.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { RouterModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LazyLoadComponent }   <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lazy-load.component'</span></span>; @NgModule({ imports: [   CommonModule,   RouterModule.forChild([        {            path: <span class="hljs-string"><span class="hljs-string">''</span></span>,            component: LazyLoadComponent        }   ]) ], declarations: [   LazyLoadComponent ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyModule</span></span></span><span class="hljs-class"> {}</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">9. Informationen zu Abonnements in anderen Abonnements</font> </h2><br>  Manchmal benötigen Sie zum Ausführen einer Aktion Daten von mehreren beobachtbaren Objekten.  Vermeiden Sie in einer solchen Situation, Abonnements für solche Objekte in den <code>subscribe</code> anderer beobachtbarer Objekte zu erstellen.  Verwenden Sie stattdessen geeignete Operatoren, um Befehle zu verketten.  Unter solchen Operatoren kann man <code>withLatestFrom</code> und <code>combineLatest</code> .  Betrachten Sie die Beispiele und kommentieren Sie sie dann. <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs javascript">firstObservable$.pipe(  take(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstValue</span></span></span><span class="hljs-function"> =&gt;</span></span> {   secondObservable$.pipe(       take(<span class="hljs-number"><span class="hljs-number">1</span></span>)   )   .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secondValue</span></span></span><span class="hljs-function"> =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Combined values are: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${firstValue}</span></span></span><span class="hljs-string"> &amp; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${secondValue}</span></span></span><span class="hljs-string">`</span></span>);   }); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs powershell">firstObservable<span class="hljs-variable"><span class="hljs-variable">$</span></span>.pipe(   withLatestFrom(secondObservable<span class="hljs-variable"><span class="hljs-variable">$</span></span>),   first() ) .subscribe(([<span class="hljs-type"><span class="hljs-type">firstValue</span></span>, <span class="hljs-type"><span class="hljs-type">secondValue</span></span>]) =&gt; {   console.log(`Combined values are: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{firstValue} &amp; <span class="hljs-variable"><span class="hljs-variable">$</span></span>{secondValue}`); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Wenn wir über die Lesbarkeit, die Komplexität des Codes oder die Anzeichen von fehlerhaftem Code sprechen, bedeutet dies, dass der Entwickler die RxJS-API nicht gut kennt, wenn das Programm die RxJS-Funktionen nicht vollständig nutzt.  Wenn wir das Thema Leistung <code>firstObservable</code> , stellt sich heraus, dass wenn das beobachtete Objekt einige Zeit zum Initialisieren benötigt, es <code>firstObservable</code> abonniert, das System auf den Abschluss des Vorgangs wartet und erst danach die Arbeit mit dem zweiten beobachteten Objekt beginnt.  Wenn es sich bei diesen Objekten um Netzwerkanforderungen handelt, sieht es wie eine synchrone Ausführung von Anforderungen aus. <br><br><h2>  <font color="#3AC1EF">10. Über das Tippen</font> </h2><br>  Versuchen Sie immer, Variablen oder Konstanten mit einem anderen Typ als einem anderen zu deklarieren. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Wenn eine Variable oder Konstante in TypeScript ohne Angabe eines Typs deklariert wird, wird der Typ basierend auf dem ihm zugewiesenen Wert abgeleitet.  Dies kann zu Problemen führen.  Betrachten Sie ein klassisches Beispiel für das Systemverhalten in einer ähnlichen Situation: <br><br><pre> <code class="hljs pgsql">const x = <span class="hljs-number"><span class="hljs-number">1</span></span>; const y = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; const z = x + y; console.log(`<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>: ${z}` //  <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>a</code> </pre> <br>  Es wird angenommen, dass <code>y</code> hier eine Zahl ist, aber unser Programm weiß nichts darüber, sodass etwas angezeigt wird, das falsch aussieht, aber keine Fehlermeldungen erzeugt.  Ähnliche Probleme können vermieden werden, indem Variablen und Konstanten geeignete Typen zugewiesen werden. <br><br>  Wir schreiben das obige Beispiel neu: <br><br><pre> <code class="hljs pgsql">const x: number = <span class="hljs-number"><span class="hljs-number">1</span></span>; const y: number = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; const z: number = x + y; //    : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'"a"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const y:number</code> </pre> <br>  Dies hilft, Datentypfehler zu vermeiden. <br><br>  Ein weiterer Vorteil eines systematischen Typisierungsansatzes besteht darin, dass er das Refactoring vereinfacht und die Wahrscheinlichkeit von Fehlern während dieses Prozesses verringert. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ngOnInit (): <span class="hljs-type"><span class="hljs-type">void</span></span> {   let myFlashObject = {       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'My cool name'</span></span>,       age: <span class="hljs-string"><span class="hljs-string">'My cool age'</span></span>,       loc: <span class="hljs-string"><span class="hljs-string">'My cool location'</span></span>   }   this.processObject(myFlashObject); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> processObject(myObject: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>): <span class="hljs-type"><span class="hljs-type">void</span></span> {   console.log(`<span class="hljs-type"><span class="hljs-type">Name</span></span>: ${myObject.name}`);   console.log(`Age: ${myObject.age}`);   console.log(`<span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: ${myObject.loc}`); } //  <span class="hljs-type"><span class="hljs-type">Name</span></span>: My cool <span class="hljs-type"><span class="hljs-type">name</span></span> Age: My cool age <span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: My cool <span class="hljs-keyword"><span class="hljs-keyword">location</span></span></code> </pre> <br>  Angenommen, wir wollten im <code>myFlashObject</code> den Namen der <code>loc</code> Eigenschaft in <code>location</code> ändern und haben <code>myFlashObject</code> Bearbeiten des Codes einen Fehler gemacht: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ngOnInit (): <span class="hljs-type"><span class="hljs-type">void</span></span> {   let myFlashObject = {       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'My cool name'</span></span>,       age: <span class="hljs-string"><span class="hljs-string">'My cool age'</span></span>,       <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>: <span class="hljs-string"><span class="hljs-string">'My cool location'</span></span>   }   this.processObject(myFlashObject); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> processObject(myObject: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>): <span class="hljs-type"><span class="hljs-type">void</span></span> {   console.log(`<span class="hljs-type"><span class="hljs-type">Name</span></span>: ${myObject.name}`);   console.log(`Age: ${myObject.age}`);   console.log(`<span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: ${myObject.loc}`); } //  <span class="hljs-type"><span class="hljs-type">Name</span></span>: My cool <span class="hljs-type"><span class="hljs-type">name</span></span> Age: My cool age <span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: undefined</code> </pre> <br>  Wenn beim Erstellen des <code>myFlashObject</code> Objekts keine Eingabe verwendet wird, geht das System in unserem Fall davon aus, dass der Wert der Eigenschaft <code>loc</code> von <code>myFlashObject</code> <code>undefined</code> .  Sie glaubt nicht, dass <code>loc</code> ein ungültiger Eigenschaftsname sein könnte. <br><br>  Wenn bei der Beschreibung des <code>myFlashObject</code> Objekts die <code>myFlashObject</code> wird, wird in einer ähnlichen Situation beim Kompilieren des Codes eine wunderbare Fehlermeldung angezeigt: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> FlashObject = {   <span class="hljs-type"><span class="hljs-type">name</span></span>: string,   age: string,   <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>: string } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ngOnInit (): <span class="hljs-type"><span class="hljs-type">void</span></span> {   let myFlashObject: FlashObject = {       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'My cool name'</span></span>,       age: <span class="hljs-string"><span class="hljs-string">'My cool age'</span></span>,       //         <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'{ name: string; age: string; loc: string; }'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'FlashObjectType'</span></span>.       <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> literal may <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> specify known properties, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'loc'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'FlashObjectType'</span></span>.       loc: <span class="hljs-string"><span class="hljs-string">'My cool location'</span></span>   }   this.processObject(myFlashObject); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> processObject(myObject: FlashObject): <span class="hljs-type"><span class="hljs-type">void</span></span> {   console.log(`<span class="hljs-type"><span class="hljs-type">Name</span></span>: ${myObject.name}`);   console.log(`Age: ${myObject.age}`)   //     Property <span class="hljs-string"><span class="hljs-string">'loc'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'FlashObjectType'</span></span>.   console.log(`<span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: ${myObject.loc}`); }</code> </pre> <br>  Wenn Sie mit der Arbeit an einem neuen Projekt beginnen, ist es hilfreich, in der Datei <code>tsconfig.json</code> die Option <code>strict:true</code> <code>tsconfig.json</code> , um die strikte Typprüfung zu aktivieren. <br><br><h2>  <font color="#3AC1EF">11. Über die Verwendung von Linter</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tslint</a> hat verschiedene Standardregeln wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">No-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Any</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">No-Magic-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Numbers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">No-Console</a> .  Der Linter kann durch Bearbeiten der Datei <code>tslint.json</code> angepasst werden, um die <code>tslint.json</code> nach bestimmten Regeln zu organisieren. <br><br><h3>  <font color="#3AC1EF">▍ Erklärungen</font> </h3><br>  Die Verwendung eines Linter zur Überprüfung des Codes bedeutet, dass Sie eine Fehlermeldung erhalten, wenn in dem Code etwas erscheint, das durch die Regeln verboten ist.  Dies trägt zur Einheitlichkeit des Projektcodes bei und verbessert dessen Lesbarkeit.  Weitere tslint-Regeln finden Sie hier. <br><br>  Es ist zu beachten, dass einige Regeln Mittel zur Korrektur dessen enthalten, was als unzulässig angesehen wird.  Bei Bedarf können Sie Ihre eigenen Regeln erstellen.  Wenn Sie interessiert sind, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an, in dem die Erstellung benutzerdefinierter Regeln für den Linter mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TSQuery erläutert wird</a> . <br><br><h3>  <font color="#3AC1EF">»Um</font> </h3><br><pre> <code class="hljs javascript">public ngOnInit (): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am a naughty console log message'</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.warn(<span class="hljs-string"><span class="hljs-string">'I am a naughty console warning message'</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'I am a naughty console error message'</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// .    ,    : I am a naughty console message I am a naughty console warning message I am a naughty console error message</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Nachher</font> </h3><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> tslint.json {   <span class="hljs-string"><span class="hljs-string">"rules"</span></span>: {       .......       <span class="hljs-string"><span class="hljs-string">"no-console"</span></span>: [            <span class="hljs-literal"><span class="hljs-literal">true</span></span>,            <span class="hljs-string"><span class="hljs-string">"log"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log             <span class="hljs-string"><span class="hljs-string">"warn"</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.warn        ]  } } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ..component.ts public ngOnInit (): void {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am a naughty console log message'</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.warn(<span class="hljs-string"><span class="hljs-string">'I am a naughty console warning message'</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'I am a naughty console error message'</span></span>); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .      <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.warn        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error,         Calls to <span class="hljs-string"><span class="hljs-string">'console.log'</span></span> are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> allowed. Calls to <span class="hljs-string"><span class="hljs-string">'console.warn'</span></span> are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> allowed.</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir 11 Empfehlungen überprüft, von denen wir hoffen, dass sie für Angular-Entwickler nützlich sind.  Warten Sie das nächste Mal auf 11 weitere Tipps. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie das Angular-Framework für die Entwicklung von Webprojekten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425661/">https://habr.com/ru/post/de425661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425647/index.html">UI-Test: Überprüfen des Systems mit unterschiedlichen Auflösungen</a></li>
<li><a href="../de425649/index.html">BDSM, Gore und das Drupal Developer Pursuit</a></li>
<li><a href="../de425653/index.html">Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 1</a></li>
<li><a href="../de425657/index.html">Die Unvermeidlichkeit der Bestrafung, die Wirksamkeit plötzlicher Kontrollen</a></li>
<li><a href="../de425659/index.html">Interaktives Design muss nicht kompliziert sein.</a></li>
<li><a href="../de425663/index.html">22 Tipps für einen Angular-Entwickler. Teil 2</a></li>
<li><a href="../de425665/index.html">Git: Fehler beheben und Commits beheben</a></li>
<li><a href="../de425667/index.html">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a></li>
<li><a href="../de425669/index.html">Webdesign-Handbuch für Nicht-Designer</a></li>
<li><a href="../de425671/index.html">MBLT DEV 2018: Roboterbericht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>