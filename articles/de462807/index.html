<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèæ ü•ó ü•â WinForms: Fehler, Holmes ü•ò üõåüèº üö¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir lieben es, in Microsoft-Projekten nach Fehlern zu suchen. Warum? Es ist ganz einfach: Ihre Projekte sind normalerweise leicht zu √ºberpr√ºfen (die A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: Fehler, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462807/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Bild 5"></div><br>  Wir lieben es, in Microsoft-Projekten nach Fehlern zu suchen.  Warum?  Es ist ganz einfach: Ihre Projekte sind normalerweise leicht zu √ºberpr√ºfen (die Arbeit kann sofort in der Visual Studio-Umgebung ausgef√ºhrt werden, f√ºr die PVS-Studio √ºber ein praktisches Plug-In verf√ºgt) und sie enthalten nur wenige Fehler.  Daher lautet der √ºbliche Betriebsalgorithmus wie folgt: Suchen und Herunterladen eines offenen Projekts von MS;  schau es dir an;  w√§hle interessante Fehler;  Stellen Sie sicher, dass es nur wenige sind.  Schreiben Sie einen Artikel, ohne zu vergessen, die Entwickler zu loben.  Gro√üartig!  Win-Win-Win: Es hat ein wenig gedauert, das Handbuch freut sich, neue Materialien auf dem Blog zu sehen, und das Karma ist in perfekter Ordnung.  Aber diesmal ging etwas schief.  Mal sehen, was im Quellcode von Windows Forms interessant war und ob Microsoft diesmal gelobt werden sollte. <br><a name="habracut"></a><br>  <b>Einf√ºhrung</b> <br><br>  Anfang Dezember 2018 k√ºndigte Microsoft die Ver√∂ffentlichung von .NET Core 3 Preview 1 an. Etwas fr√ºher (ungef√§hr ab Mitte Oktober) begann GitHub aktiv mit der Ver√∂ffentlichung des Quellcodes f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Forms</a> , der .NET Core UI-Plattform zum Erstellen von Windows-Desktopanwendungen.  Sie k√∂nnen die Commit-Statistiken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Jetzt kann jeder den WinForms-Quellcode zur √úberpr√ºfung herunterladen. <br><br>  Ich habe auch die Quellen heruntergeladen, um dort mit PVS-Studio nach Fehlern zu suchen.  √úberpr√ºfung verursachte keine Schwierigkeiten.  Erforderlich: Visual Studio 2019, .NET Core 3.0 SDK-Vorschau, PVS-Studio.  Und jetzt wird das Warnprotokoll des Analysators empfangen. <br><br>  Nachdem ich das PVS-Studio-Protokoll erhalten habe, sortiere ich es normalerweise in aufsteigender Reihenfolge der Diagnosenummern (das Fenster mit dem PVS-Studio-Nachrichtenprotokoll in Visual Studio bietet verschiedene Optionen zum Sortieren und Filtern der Liste).  Auf diese Weise k√∂nnen Sie mit Fehlergruppen desselben Typs arbeiten, was die Analyse des Quellcodes erheblich vereinfacht.  Ich markiere interessante Fehler in der Liste mit einem Sternchen und erst dann, nachdem ich das gesamte Protokoll analysiert habe, schreibe ich Codefragmente aus und mache eine Beschreibung.  Und da es normalerweise nur wenige Fehler gibt, vermische ich sie und versuche, die interessantesten am Anfang und Ende des Artikels zu platzieren.  Aber diesmal stellte sich heraus, dass die Fehler ein bisschen gro√ü waren (eh, es war nicht m√∂glich, die Intrige f√ºr eine lange Zeit zu retten), und ich werde sie in der Reihenfolge der Diagnosenummern bringen. <br><br>  Was wurde gefunden?  833 Warnungen des hohen und mittleren Konfidenzniveaus (249 bzw. 584) wurden f√ºr 540.000 Codezeilen (ausgenommen leere) in 1670 cs-Dateien ausgegeben.  Und ja, der Tradition nach habe ich die Tests nicht √ºberpr√ºft und die Warnungen des niedrigen Konfidenzniveaus (215 wurden ausgegeben) nicht ber√ºcksichtigt.  Nach meinen fr√ºheren Beobachtungen gibt es zu viele Warnungen von MS f√ºr das Projekt.  Aber nicht alle Warnungen sind Fehler. <br><br>  F√ºr dieses Projekt betrug die Anzahl der falsch positiven Ergebnisse etwa 30%.  In etwa 20% der F√§lle konnte ich einfach keine genaue Schlussfolgerung dar√ºber ziehen, ob dies ein Fehler ist oder nicht, da ich mit dem Code nicht gut vertraut bin.  Nun, mindestens 20% der Fehler, die ich verpasst habe, sind auf den menschlichen Faktor zur√ºckzuf√ºhren: Eile, M√ºdigkeit usw.  Der gegenteilige Effekt ist auch m√∂glich: √úbrigens habe ich einige der gleichen Arten von Ausl√∂sungen durchgesehen, deren Anzahl 70-80 erreichen k√∂nnte, durch eine, die gelegentlich die Anzahl der Fehler erh√∂hen k√∂nnte, die ich f√ºr real hielt. <br><br>  In jedem Fall weisen 30% der Warnungen auf echte Fehler hin, was einen sehr gro√üen Prozentsatz darstellt, da der Analysator nicht vorkonfiguriert wurde. <br><br>  Die Anzahl der Fehler, die ich feststellen konnte, betrug ungef√§hr 240, was innerhalb der Grenzen der Statistik liegt.  Ich wiederhole meiner Meinung nach, dass dies f√ºr ein Projekt von MS nicht das herausragendste Ergebnis ist (obwohl dies nur 0,44 Fehler pro 1000 Codezeilen sind), und es gibt wahrscheinlich mehr echte Fehler im WinForms-Code.  Ich schlage vor, am Ende des Artikels √ºber die Gr√ºnde zu sprechen, aber jetzt sehen wir uns die interessantesten Fehler an. <br><br>  <b>Fehler</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3003</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  In <i>if-</i> und <i>else if-</i> Bl√∂cken wird dieselbe Bedingung √ºberpr√ºft.  Es sieht aus wie Kopieren und Einf√ºgen.  Ist das ein Fehler?  Wenn Sie sich die Deklaration der <i>IsHighContrastHighlighted-</i> Methode <i>ansehen</i> , gibt es Zweifel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  Die Methode kann wahrscheinlich bei aufeinanderfolgenden Aufrufen unterschiedliche Werte zur√ºckgeben.  Und was in der aufrufenden Methode gemacht wird, sieht nat√ºrlich seltsam aus, hat aber das Recht auf Leben.  Ich w√ºrde den Autoren jedoch raten, sich diesen Code anzusehen.  Nur f√ºr den Fall.  Dies ist jedoch ein gutes Beispiel daf√ºr, wie schwierig es ist, bei der Analyse von unbekanntem Code Schlussfolgerungen zu ziehen. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  Und hier ist der Fehler beim Kopieren und Einf√ºgen definitiv gemacht.  Unabh√§ngig von der Bedingung <i>erh√§lt die</i> Variable <i>selCharOffset</i> immer den gleichen Wert. <br><br>  Es gab zwei weitere √§hnliche Fehler im WinForms-Code: <ul><li>  V3004 Die Anweisung 'then' entspricht der Anweisung 'else'.  SplitContainer.cs 1700 </li><li>  V3004 Die Anweisung 'then' entspricht der Anweisung 'else'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  Die Methode <i>f√ºllt</i> das <i>rgbTable-</i> W√∂rterbuch.  Der Analysator zeigte auf einen Code, in dem zwei verschiedene Werte nacheinander auf denselben Schl√ºssel geschrieben werden.  Und alles w√§re in Ordnung, aber es gab 16 weitere solcher Stellen in dieser Methode. Dies sieht nicht mehr wie ein einzelner Fehler aus.  Aber warum das tun, f√ºr mich bleibt es ein R√§tsel.  Ich habe keine Anzeichen von automatisch generiertem Code gefunden.  Im Editor sieht es so aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Bild 3"></div><br>  Ich werde die ersten zehn Operationen mit einer Liste geben: <br><br><ol><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3011</a> Es wurden zwei entgegengesetzte Bedingungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festgestellt</a> .  Die zweite Bedingung ist immer falsch.  √úberpr√ºfen Sie die Zeilen: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  Die <i>return-Anweisung</i> wird niemals ausgef√ºhrt.  H√∂chstwahrscheinlich ist die Bedingung <i>myGridTable! = Null</i> im externen <i>if-</i> Block, der sp√§ter w√§hrend des Refactorings hinzugef√ºgt wurde.  Und jetzt <i>ist es</i> sinnlos, <i>myGridTable == null zu</i> √ºberpr√ºfen.  Entfernen Sie diese Pr√ºfung, um die Qualit√§t des Codes zu verbessern. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'left', 'cscLeft'.  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'right', 'cscRight'.  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  Der Analysator gab sofort zwei Warnungen f√ºr die <i>Vergleichsmethode aus</i> .  Was ist das Problem?  Es ist so, dass die Werte von <i>cscLeft</i> und <i>cscRight</i> nicht auf Gleichheit <i>null</i> gepr√ºft werden.  Sie k√∂nnen diesen Wert nach erfolglosem Casting in den Typ <i>OrderedCodeStatementCollection erhalten</i> .  Dann wird in der letzten <i>return-Anweisung</i> eine Ausnahme ausgel√∂st.  Eine solche Situation ist m√∂glich, wenn alle Pr√ºfungen f√ºr <i>links</i> und <i>rechts</i> bestanden werden und nicht zu einem vorl√§ufigen Verlassen der Methode f√ºhren. <br><br>  Um den Code zu <i>korrigieren,</i> sollte <i>cscLeft</i> / <i>cscRight √ºberall</i> anstelle von <i>links</i> / <i>rechts verwendet werden</i> . <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> Eine bedingungslose Unterbrechung innerhalb einer Schleife.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Dieses Fragment bezieht sich vielmehr auf den Code "mit Geruch".  Hier gibt es keinen Fehler.  Es stellen sich jedoch Fragen zur Organisation des <i>Foreach-</i> Zyklus.  Warum wird es hier ben√∂tigt - es ist klar: aufgrund der Notwendigkeit, die Elemente der Sammlung zu extrahieren, die als <i>ICollection √ºbergeben wurden</i> .  Aber warum war in der Schleife, die urspr√ºnglich f√ºr eine einzelne Iteration ausgelegt war (Voraussetzung ist das Vorhandensein eines einzelnen Elements in der <i>Komponentensammlung</i> ), ein zus√§tzliches Sicherheitsnetz in Form einer <i>Unterbrechung</i> erforderlich?  Wahrscheinlich kann die Antwort in Betracht gezogen werden: "Es hat sich historisch entwickelt."  Der Code sieht h√§sslich aus. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> Ausdruck 'ocxState! = Null' ist immer wahr.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  Aufgrund eines logischen Fehlers wurde in diesem Fragment ein "toter Code" gebildet.  Ausdr√ºcke im <i>else-</i> Block werden niemals ausgef√ºhrt. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3027</a> Die Variable 'e' wurde im logischen Ausdruck verwendet, bevor sie im gleichen logischen Ausdruck gegen null verifiziert wurde.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  Die Variable <i>e</i> in der Bedingung wird zuerst verwendet und dann auf die <i>Nullungleichung</i> √ºberpr√ºft.  Hallo, <i>NullReferenceException</i> . <br><br>  Ein weiterer √§hnlicher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3027</a> Die Variable 'dropDownItem' wurde im logischen Ausdruck verwendet, bevor sie im selben logischen Ausdruck gegen null verifiziert wurde.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  Eine Situation √§hnlich der vorherigen, nur mit der Variablen <i>dropDownItem</i> .  Ich denke, dass solche Fehler auf Unaufmerksamkeit beim Refactoring zur√ºckzuf√ºhren sind.  Wahrscheinlich ein Teil der Bedingung <i>! (DropDownItem.Owner ist ToolStripDropDownMenu)</i> wurde sp√§ter zum Code hinzugef√ºgt. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3030</a> Wiederkehrende Pr√ºfung.  Die Bedingung 'columnCount&gt; 0' wurde bereits in Zeile 3900 √ºberpr√ºft. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Ein Fehler, der harmlos erscheinen mag.  In der Tat wird eine zus√§tzliche Pr√ºfung durchgef√ºhrt, die die Logik der Arbeit nicht beeinflusst.  Und manchmal tun sie dies sogar, wenn Sie den Status einer visuellen Komponente erneut √ºberpr√ºfen m√ºssen, indem Sie beispielsweise die Anzahl der Eintr√§ge in der Liste abrufen.  Nur in diesem Fall √ºberpr√ºfen sie die <i>lokale</i> Variable <i>columnCount</i> .  Das ist sehr verd√§chtig.  Entweder wollten sie eine andere Variable √ºberpr√ºfen, oder bei einer der √úberpr√ºfungen verwenden sie die falsche Bedingung. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3061 Der</a> Parameter 'lprcClipRect' wird vor seiner Verwendung immer im Methodenk√∂rper neu geschrieben.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Unverst√§ndlicher Fehler.  Ja, der Parameter <i>lprcClipRect wird</i> wirklich mit einem neuen Wert initialisiert, ohne ihn in irgendeiner Weise zu verwenden.  Aber was bringt das?  Ich denke, dass irgendwo im aufrufenden Code der durch diesen Parameter √ºbergebene Link unver√§ndert bleibt, obwohl er anders gedacht war.  Schauen Sie sich in der Tat die Arbeit mit anderen Variablen in dieser Methode an.  Sogar der Name (das Pr√§fix ‚ÄûGet‚Äú) weist darauf hin, dass innerhalb der Methode √ºber die √ºbergebenen Parameter eine Initialisierung vorgenommen wird.  Und so ist es auch.  Die ersten beiden Parameter ( <i>ppFrame</i> und <i>ppDoc</i> ) werden mit dem Modifikator <i>out √ºbergeben</i> und erhalten neue Werte.  Die Links <i>lprcPosRect</i> und <i>lpFrameInfo</i> werden verwendet, um auf die Felder der Klasse zuzugreifen und sie zu initialisieren.  Und nur <i>lprcClipRect</i> wird aus der allgemeinen Liste entfernt.  H√∂chstwahrscheinlich ist f√ºr diesen Parameter der Modifikator <i>out</i> oder <i>ref</i> erforderlich. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3066</a> M√∂glicherweise falsche Reihenfolge der Argumente, die an die Methode 'AdjustCellBorderStyle' √ºbergeben wurden: 'isFirstDisplayedRow' und 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  Der Analysator vermutete, dass die letzten beiden Argumente verwechselt wurden.  Schauen wir uns die Deklaration der <i>AdjustCellBorderStyle-</i> Methode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  Sieht aus wie ein Fehler.  Ja, h√§ufig werden einige Argumente absichtlich in umgekehrter Reihenfolge √ºbergeben, um beispielsweise einige Variablen auszutauschen.  Aber ich denke nicht, dass dies genau der Fall ist.  Nichts in den aufrufenden oder aufgerufenen Methoden sagt ein solches Verwendungsmuster aus.  Erstens werden Variablen vom Typ <i>Bool</i> verwirrt.  Zweitens sind auch die Namen der Methoden gebr√§uchlich: kein "Swap" oder "Reverse".  Dar√ºber hinaus ist es nicht so schwierig, einen solchen Fehler zu machen.  Menschen nehmen die Reihenfolge des Zeilen- / Spaltenpaars oft unterschiedlich wahr.  F√ºr mich ist zum Beispiel nur "Zeile / Spalte" bekannt.  F√ºr den Autor der aufgerufenen <i>AdjustCellBorderStyle-</i> Methode ist die bekanntere Reihenfolge nat√ºrlich "Spalte / Zeile". <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3070</a> Nicht initialisierte Variable 'LANG_USER_DEFAULT' wird beim Initialisieren der Variablen 'LOCALE_USER_DEFAULT' verwendet.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Ein seltener Fehler.  Die Reihenfolge der Initialisierung der Klassenfelder ist verwechselt.  <i>Verwenden Sie</i> zum Berechnen des Werts des <i>Felds LOCALE_USER_DEFAULT das</i> Feld <i>LANG_USER_DEFAULT</i> , das noch nicht initialisiert ist und den Wert 0 hat. Die Variable <i>LANG_USER_DEFAULT</i> wird <i>√ºbrigens an</i> keiner anderen Stelle im Code verwendet.  Ich war nicht zu faul und schrieb ein kleines Konsolenprogramm, das die Situation simuliert.  Anstelle der Werte einiger Konstanten, die im WinForms-Code verwendet werden, habe ich ihre tats√§chlichen Werte ersetzt: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  Als Ergebnis des Starts wird auf der Konsole Folgendes angezeigt: 0. Jetzt tauschen wir die Deklaration der <i>Felder</i> <i>LOCALE_USER_DEFAULT</i> und <i>LANG_USER_DEFAULT aus</i> .  Das Ergebnis des Programms in dieser Form: 1024. Ich denke, hier gibt es nichts mehr zu kommentieren. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von "ces".  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  Der Code, der "fallen" sollte, ist stabil genug, da Sie nur dann in den <i>else-</i> Zweig gelangen k√∂nnen, wenn die <i>ces-</i> Referenz <i>null ist</i> . <br><br>  Ein weiteres √§hnliches Beispiel: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die 'comboBox'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  Der paradoxe Code.  Anscheinend haben sie den Test <i>verwechselt,</i> indem sie <i>if (comboBox! = Null)</i> anstelle von <i>if (comboBox == null) geschrieben haben</i> .  Und so erhalten wir die n√§chste <i>NullReferenceException</i> . <br><br>  Wir haben zwei ziemlich offensichtliche Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080 untersucht</a> , bei denen Sie die Situation der m√∂glichen Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenzen</a> innerhalb der Methode visuell verfolgen k√∂nnen.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch</a> viel intelligenter und kann nach √§hnlichen Fehlern f√ºr Ketten von Methodenaufrufen suchen.  Vor nicht allzu langer Zeit haben wir die Mechanismen des Datenflusses und der interprozeduralen Analyse erheblich gest√§rkt.  Sie k√∂nnen dies im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullable Reference Types in C # 8.0 und Static Analysis</a> " lesen.  Und hier ist ein √§hnlicher Fehler in WinForms: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung innerhalb der Methode bei 'reader.NameTable'.  √úberpr√ºfen Sie das erste Argument: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Sehen Sie sich an, was mit der Variablen <i>contentReader</i> im Hauptteil der Methode passiert.  Nach der Initialisierung mit einer Nullreferenz wird der Link als Ergebnis einer der √úberpr√ºfungen initialisiert.  Eine Reihe von √úberpr√ºfungen endet jedoch nicht mit einem <i>else-</i> Block.  Dies bedeutet, dass in einigen seltenen F√§llen (oder aufgrund zuk√ºnftiger Umgestaltungen) die Verkn√ºpfung immer noch Null bleiben kann.  Als n√§chstes wird es an die <i>SetupNameTable-</i> Methode √ºbergeben, wo es ohne √úberpr√ºfung verwendet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Dies ist m√∂glicherweise unsicherer Code. <br><br>  Und noch ein Fehler, bei dem der Analysator eine Reihe von Aufrufen durchlaufen musste, um ein Problem zu identifizieren: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie das Layout.  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  Der Analysator behauptet, dass es m√∂glich ist, eine <i>Nullreferenz</i> von der <i>GetAnchorInfo-</i> Methode <i>abzurufen</i> , die bei der Berechnung des <i>linken</i> Werts eine Ausnahme <i>ausl√∂st</i> .  Lassen Sie uns die gesamte Anrufkette durchgehen und pr√ºfen, ob dies der Fall ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  In einigen F√§llen gibt die <i>GetObject-</i> Methode, die die <i>Aufrufkette</i> schlie√üt, <i>null zur√ºck</i> , die ohne zus√§tzliche √úberpr√ºfungen an die aufrufende Methode √ºbergeben wird.  Wahrscheinlich sollte die <i>GetAnchorDestination-</i> Methode eine solche Situation vorsehen. <br><br>  Im WinForms-Code gab es einige solcher Fehler, <b>mehr als 70</b> .  Sie sind alle √§hnlich und ich werde ihre Beschreibung im Artikel nicht geben. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3091</a> Empirische Analyse.  M√∂glicherweise ist im Zeichenfolgenliteral ein Tippfehler vorhanden: "ShowCheckMargin".  Das Wort 'ShowCheckMargin' ist verd√§chtig.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Ein gutes Beispiel f√ºr einen Fehler, der nicht so leicht zu erkennen ist.  Beim Initialisieren von Klassenfeldern verwenden sie denselben Wert, obwohl der Autor des Codes dies offensichtlich nicht gedacht hat (Kopieren und Einf√ºgen ist schuld).  Der Analysator kam zu diesem Schluss, indem er die Namen der Variablen und die Werte der zugewiesenen Zeichenfolgen verglich.  Ich habe nur die Fehlerzeilen angegeben, aber sehen Sie sich an, wie es im Code-Editor aussieht: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Bild 2"></div><br>  Es ist die Erkennung solcher Fehler, die die Leistungsf√§higkeit und unendliche Sorgfalt statischer Analysewerkzeuge demonstriert. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das Objekt 'currentForm' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  Klassisch  Die Variable <i>currentForm wird</i> ohne Pr√ºfung verwendet.  Aber weiter im Code gibt es seine Pr√ºfung auf <i>Nullgleichheit</i> .  In diesem Fall kann ich Ihnen raten, beim Arbeiten mit Referenztypen vorsichtiger zu sein und statische Analyseger√§te zu verwenden :). <br><br>  Ein weiterer √§hnlicher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das Objekt 'backgroundBrush' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  Im WinForms-Code sind mehr <b>als 60</b> solcher Fehler aufgetreten.  Meiner Meinung nach sind alle sehr kritisch und erfordern die Aufmerksamkeit der Entwickler.  Aber in dem Artikel ist es nicht so interessant, dar√ºber zu sprechen, deshalb beschr√§nke ich mich auf die beiden oben diskutierten. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> Das Objekt '_propInfo' wurde verwendet und in verschiedenen Ausf√ºhrungszweigen gegen Null verifiziert.  √úberpr√ºfen Sie die Zeilen: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Um das Bild zu vervollst√§ndigen - auch eine Art Klassiker, Bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> .  Die umgekehrte Situation.  Zuerst wird eine potenziell Null-Referenz sicher verwendet, um nach <i>Null</i> zu <i>suchen</i> , aber dann tun sie dies im Code nicht mehr. <br><br>  Und noch ein √§hnlicher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> Das Objekt 'owner' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  Sch√∂nheit  Dies ist jedoch aus der Sicht eines externen Forschers.  Zus√§tzlich zu diesen beiden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> fand der Analysator mehr <b>als 50</b> √§hnliche Muster im WinForms-Code.  Entwickler haben Arbeit zu erledigen. <br><br>  Und schlie√ülich - meiner Meinung nach ein ziemlich interessanter Fehler. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3137</a> Die Variable 'hCurrentFont' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Mal sehen, was der Analysator alarmiert hat und warum die Tatsache, dass einer Variablen ein Wert zugewiesen wurde, dieser jedoch in der Methode nicht weiter verwendet wird, auf ein Problem hinweisen kann. <br><br>  Eine <i>Teilklasse</i> wird in der Datei <i>DeviceContext2.cs deklariert</i> .  Die <i>DisposeFont-</i> Methode <i>wird</i> verwendet, um Ressourcen nach der Arbeit mit Grafiken <i>freizugeben</i> : Ger√§tekontext und Schriftarten.  Zum besseren Verst√§ndnis habe ich die gesamte <i>DisposeFont-</i> Methode <i>bereitgestellt</i> .  <i>Achten Sie</i> auf die lokale Variable <i>hCurrentFont</i> .  Das Problem ist, dass durch das Deklarieren dieser Variablen in einer Methode das gleichnamige Klassenfeld ausgeblendet wird.  Ich habe zwei Methoden der <i>DeviceContext-</i> Klasse gefunden, bei denen ein <b>Feld</b> namens <i>hCurrentFont verwendet wird</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  Schauen Sie sich die <i>ResetFont-</i> Methode an.  Die letzte Zeile dort ist genau das, was die <i>DisposeFont-</i> Methode im verschachtelten <i>if-</i> Block <i>tut</i> (der Analysator zeigt auf diese Stelle).  Und dieses gleichnamige <i>hCurrentFont-</i> Feld wurde in einem anderen Teil der <i>Teilklasse</i> in der Datei <i>DeviceContext.cs deklariert</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Somit wurde ein offensichtlicher Fehler gemacht.  Eine andere Frage ist seine Kritikalit√§t.  Aufgrund der <i>DisposeFont-</i> Methode, <i>die</i> in dem mit dem Kommentar ‚Äû <i>W√§hlen</i> Sie die urspr√ºngliche Schriftart wieder ein‚Äú gekennzeichneten Abschnitt <i>arbeitet</i> , wird dem Feld <i>hCurrentFont</i> kein Anfangswert zugewiesen.  Ich denke, dass nur Code-Autoren ein genaues Urteil abgeben k√∂nnen. <br><br>  <b>Schlussfolgerungen</b> <br><br>  Also muss ich diesmal MS ein bisschen "schelten".  In WinForms gab es viele Fehler, die die Aufmerksamkeit der Entwickler erfordern.  M√∂glicherweise liegt dies an der Eile, mit der MS an .NET Core 3 und Komponenten, einschlie√ülich WinForms, arbeitet.  Meiner Meinung nach ist der WinForms-Code immer noch "feucht", aber ich hoffe, dass sich die Situation bald zum Besseren √§ndert. <br><br>  Der zweite Grund f√ºr eine gro√üe Anzahl von Fehlern kann sein, dass unser Analysator gerade besser geworden ist, um nach ihnen zu suchen :). <br><br>  √úbrigens wird in K√ºrze ein Artikel meines Kollegen Sergey Vasiliev ver√∂ffentlicht, in dem er einige Probleme im Code von .NET Core-Bibliotheken sucht und findet.  Ich hoffe, dass seine Arbeit auch zur Verbesserung der Leistung der .NET-Plattform beitr√§gt, da wir immer versuchen, den Entwicklern die Ergebnisse der Analyse ihrer Projekte mitzuteilen. <br><br>  F√ºr diejenigen, die ihre Produkte selbst verbessern oder Nachforschungen anstellen m√∂chten, um Fehler in den Projekten anderer Leute zu finden, empfehle ich, PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterzuladen und</a> auszuprobieren. <br><br>  Alles sauberer Code! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinForms: Fehler, Holmes</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462807/">https://habr.com/ru/post/de462807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462797/index.html">Und wieder √ºber die Wolken, nicht nur die Profis</a></li>
<li><a href="../de462799/index.html">RAVIS und DAB bei einem niedrigen Start. DRM beleidigt. Die seltsame Zukunft des Digitalradios der Russischen F√∂deration</a></li>
<li><a href="../de462801/index.html">15 unverzichtbare Tools f√ºr Produktmanager im Jahr 2019</a></li>
<li><a href="../de462803/index.html">Migration von einem ERP-System zu einem anderen</a></li>
<li><a href="../de462805/index.html">Analyse: Wie Geld beim Handel an der B√∂rse tats√§chlich gesch√ºtzt ist</a></li>
<li><a href="../de462809/index.html">WinForms: Fehler, Holmes</a></li>
<li><a href="../de462811/index.html">Warum brauchen wir Generika in Go?</a></li>
<li><a href="../de462813/index.html">Jekaterinburg, 14. August - Atlassian User Group mitap</a></li>
<li><a href="../de462815/index.html">Mein dritter Tag mit Haiku: Das ganze Bild nimmt Gestalt an</a></li>
<li><a href="../de462819/index.html">M√§ngel im Sprachunterricht in der GUS: eine polyglotte Sichtweise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>