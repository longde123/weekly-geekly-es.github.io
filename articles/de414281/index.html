<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé® üòõ üê™ Entwicklung eines Fahrradtachometers basierend auf einem Display des Nokia 3310 üåî „äóÔ∏è üå™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In j√ºngster Zeit haben sich die sogenannten digitalen Fahrradtachometer (Fahrradcomputer) unter Fahrradzubeh√∂r verbreitet. Diese Ger√§te k√∂nnen viele P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines Fahrradtachometers basierend auf einem Display des Nokia 3310</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414281/">  In j√ºngster Zeit haben sich die sogenannten digitalen Fahrradtachometer (Fahrradcomputer) unter Fahrradzubeh√∂r verbreitet.  Diese Ger√§te k√∂nnen viele Parameter messen, von denen die Geschwindigkeit und die Entfernung die wichtigsten sind.  Das Prinzip der Geschwindigkeitsmessung basiert auf der Berechnung der Umdrehungsdauer des Rades, und der Abstand wird auf der Grundlage der Messung der Anzahl solcher Umdrehungen berechnet.  Oft ist der Radumdrehungssensor ein Reedschalter in Verbindung mit einem Magneten an der Radspeiche.  Je nach Funktionalit√§t variiert der Preis solcher Ger√§te stark.  Der billigste Fahrradtachometer kann f√ºr ca. 500 p gekauft werden. <br><br>  Ich hatte immer den Wunsch, ein √§hnliches Ger√§t zu haben.  Gleichzeitig formulierte ich eine Reihe meiner eigenen Anforderungen, die es erf√ºllen sollte.  Zun√§chst wollte ich unbedingt eine grafische Darstellung der Geschwindigkeits√§nderungen in Abh√§ngigkeit von der Entfernung oder der Zeit sehen, die sich w√§hrend der Bewegung √ºber einen kurzen Zeitraum angesammelt haben.  Und auch, um Messungen auf einem Speicherger√§t aufzuzeichnen (zu protokollieren), um statistische Daten weiter auf einen Computer zu √ºbertragen, deren detailliertere Anzeige.  Billige Modelle erf√ºllen meine Anforderungen nicht vollst√§ndig, aber ich m√∂chte teure Modelle nicht √ºberbezahlen. <br><a name="habracut"></a><br>  Aufgrund des Vorstehenden habe ich beschlossen, einen eigenen Fahrradtachometer auf der Basis des ATmega8-Mikrocontrollers zu entwickeln.  Es gab viele Fragen, insbesondere zu den verwendeten Peripherieger√§ten.  Ich bin versehentlich auf Artikel √ºber die Verwendung des Displays des einst beliebten Nokia 3310 gesto√üen. Nachdem ich das Datenblatt gelesen und sichergestellt hatte, dass es einfach zu bedienen war, hatte ich keinen Zweifel daran, dass der Tacho im Geh√§use des oben genannten Telefons mit einem eigenen Display hergestellt werden w√ºrde.  Der Fall ist ziemlich gut und das Ger√§t selbst ist nicht schwer zu finden. <br><br><img src="https://habrastorage.org/webt/co/vu/d2/covud2fzqkaw8fiojo2mes8xfl4.png"><br><br>  Als ROM f√ºr die Aufzeichnung von Messstatistiken habe ich mich f√ºr ein klassisches 24XX512-ROM (512 Kbit / s) entschieden, das √ºber die I2C-Schnittstelle gesteuert wird.  Ich habe mich nicht mit der Verwendung einer SD / MMC-Speicherkarte besch√§ftigt.  Eine weitere wichtige Funktion im Ger√§t ist die Uhr.  Sie dienen dazu, einige gemessene spezifische Parameter (z. B. maximale Geschwindigkeit) an Datum und Uhrzeit zu binden und sind auch f√ºr die Aufzeichnung von Zeitstempeln in Statistiken erforderlich.  Als Uhr habe ich einen separaten Mikrouhr-Chip (RTC) vom Mikrocontroller verwendet, der √ºber eine unabh√§ngige Batterieleistung verf√ºgt und auch √ºber I2C mit dem Controller kommuniziert. <br><br>  Ich habe beim Schreiben des Programms zus√§tzliche sekund√§re Anforderungen an die Funktionalit√§t des Ger√§ts implementiert.  Dies umfasst alle Arten von organisatorischen Problemen: die Anzahl der beteiligten Schaltfl√§chen, die Position auf der Anzeige verschiedener Elemente, die Navigation auf der Benutzeroberfl√§che usw.  In Bezug auf die Navigation habe ich mich im Voraus entschieden, das Programm nicht zu komplizieren, zum Beispiel das Einstellungsmen√º, insbesondere die Datums- und Uhrzeiteinstellungen, nicht zu implementieren.  Die Uhr wird einmal eingestellt.  Dank eines 32,768-kHz-Quarzes und einer langlebigen Batterie tickt die Uhr im RTC-Chip selbstst√§ndig.  Datums- und Uhrzeiteinstellungen werden √ºber die UART-Schnittstelle des Tachometers vorgenommen, die mit einem Klick an den COM-Anschluss des Computers angeschlossen wird.  √úber dieselbe Schnittstelle sollte es Statistikdaten vom ROM auf einen Computer lesen.  F√ºr all dies m√ºssen Sie das entsprechende Programm f√ºr den Computer schreiben.  Wie die weitere Praxis zeigte, musste letzteres jedoch aufgegeben werden.  Erstens gab es das Problem, den Empfang von Daten von der Steuerung zum Computer beim Schreiben eines Computerprogramms zu implementieren.  Und noch wichtiger ist, dass die Lautst√§rke des Programms f√ºr die Steuerung erh√∂ht wurde.  Es war viel interessanter, das ROM (im SMIC-Geh√§use SOIC-8) auf einer austauschbaren Plattform zu platzieren, die der SIM-Karte entspricht, und den entsprechenden freien Steckplatz auf dem Mobiltelefon zu verwenden.  Zu diesem Zweck ist es erforderlich, einen ROM-Leser basierend auf einem SIM-Leser gem√§√ü einem der bekannten Schemata des I2C-ROM-Programmierger√§ts herzustellen.  Wie sich sp√§ter herausstellte, verursachte diese Entscheidung keine unn√∂tigen Unannehmlichkeiten. <br><br>  Ein weiteres wichtiges Thema ist die Ausgabe symbolischer (einschlie√ülich digitaler) Informationen auf einem Grafikdisplay.  Dies erfordert grafische Informationen zu einem bestimmten Symbol.  Diese Informationen stehen in engem Zusammenhang mit einem Parameter wie der Gr√∂√üe der angezeigten Schriftart.  Um den Hauptparameter, die Bewegungsgeschwindigkeit, f√ºr eine gute Klarheit anzuzeigen, ist es w√ºnschenswert, eine gro√üe Schriftart zu verwenden.  Wie sp√§ter gezeigt wird, passen solche grafischen Informationen √ºber zehn Ziffern nicht in den Speicher von MK, und die Verwendung desselben externen, umfangreicheren ROM verlangsamt die Geschwindigkeit des Zeichnens der Schriftart.  Ich habe mich f√ºr eine Schriftart mit einer H√∂he von 8 Punkten als gr√∂√üte Schriftart entschieden.  Ich habe die grafischen Informationen f√ºr diese Schriftart aus der Datei ‚Äû8X8.FNT‚Äú eines Programms von MS DOS abgerufen, nachdem ich zuvor die Struktur entschl√ºsselt und weiterverarbeitet hatte. <br><br><img src="https://habrastorage.org/webt/wu/eo/ft/wueoftqpob-qnbg5kpd3phvlfes.png"><br><br>  Wie sich sp√§ter in der Praxis herausstellte, reicht diese Gr√∂√üe f√ºr eine klare Geschwindigkeit aus.  Als Gr√∂√üe f√ºr die zus√§tzliche Schriftart habe ich die Gr√∂√üe 3x5 gew√§hlt und die Grafiken f√ºr die Nummern dieser Gr√∂√üe unabh√§ngig gezeichnet.  Diese kleinen Zahlen zeigen zus√§tzliche Parameter an: Datum / Uhrzeit, Durchschnitts- und H√∂chstgeschwindigkeit, Pfad. <br><br>  Die grafischen Informationen beider Schriftarten werden in bestimmten zweidimensionalen Arrays gespeichert.  Jedes Array-Element mit einer Gr√∂√üe von 1 Byte bezeichnet die Pixelverteilung einer bestimmten Spalte einer bestimmten Ziffer.  Bei Gro√üdruck werden 8 Spalten f√ºr jede Ziffer und 3 f√ºr 3 zugewiesen. Bei Kleingedruckten mit einer Gr√∂√üe von 3 x 5 betr√§gt die formale H√∂he nicht 5, sondern 8 Punkte (auf ein Byte gerundet).  Auf diese Weise k√∂nnen Sie die Position der 5-Positionen-Schriftart innerhalb des 8-Positionen-Bereichs in vertikaler Richtung mit einer von 4 m√∂glichen Methoden vorab anordnen.  Diese Fakten sind in der folgenden Abbildung gut dargestellt, die die Modellierung von Grafiken f√ºr die ersten beiden Ziffern dieser Schriftart demonstriert.  Excel ist bekannt f√ºr die Modellierung.  Die Anfangsdaten sind die Anordnung von "Einheiten" in den entsprechenden Feldern f√ºr die gew√ºnschten Grafiken.  Von diesen berechnen die Formeln die Werte von Arrays bis zum C-Sprachcode, der sp√§ter in den Programmtext f√ºr den Mikrocontroller kopiert werden kann. <br><br><img src="https://habrastorage.org/webt/fh/ls/ov/fhlsov48egokegrdbnlteowsxh0.png"><br><br>  Jetzt werden wir √ºber die Steuerfunktionen des verwendeten Displays sprechen.  Dieses Display ist monochrom und hat eine Gr√∂√üe von 84 x 48 Pixel.  Die Anzeigesteuerung vom MK erfolgt √ºber die SPI-Schnittstelle.  Von SPI √ºbertragene Bytes werden in der Anzeige in zwei Modi interpretiert: Bytes f√ºr die Anzeige und Bytes f√ºr Konfigurationsbefehle.  Diese Modi werden vom MK selbst f√ºr einen bestimmten Anzeigestift (D / C) eingestellt.  Eine vollst√§ndige Liste der Befehle finden Sie im Datenblatt auf dem Display.  Einige dieser Befehle werden in meinem Ger√§t verwendet und dienen zum Initialisieren der Anzeige, wenn das Ger√§t mit Strom versorgt wird: Temperaturkoeffizient, Kontrast, sequentieller Zeichenmodus (horizontal oder vertikal) usw.  Ich stelle sofort fest, dass der horizontale Zeichenmodus angewendet wird.  Dies bedeutet, dass beim √úbertragen eines Bytes im Anzeigemodus die Adresse automatisch um eine Zeile Zeile f√ºr Zeile nach rechts erh√∂ht wird.  Wenn die Zeile endet, geht die Positionsadresse an den Anfang der n√§chsten Zeile.  Es reicht aus, zuerst einen speziellen Positionierungsbefehl an die Anzeige an eine bestimmte Zeilen- und Spaltenadresse (Anfangsposition) zu senden und dann nacheinander Datenbytes zu senden, um Grafiken anzuzeigen.  Es ist erw√§hnenswert, dass der Adressraum und die Interpretation der Grafiken von den von der Anzeige empfangenen Bytes abh√§ngen.  Ich stelle fest, dass f√ºr monochrome Grafiken ein Byte Informationen √ºber ungef√§hr acht Pixel gleichzeitig enth√§lt. <br><br>  Die betreffende Anzeige ist vertikal in 6 horizontale Zonen mit jeweils 8 Linien unterteilt (6 * 8 = 48).  Jede Spalte jeder Zone entspricht einem bestimmten Byte, das mit der Adresse der entsprechenden Spalte (0 ... 83) und der Zonennummer (0 ... 5) gesendet wird.  Die Adresse wird nicht von Grund auf neu gez√§hlt.  Wenn Sie sich beispielsweise an der Adresse (34; 2) positionieren und ein Datenbyte von 255 (in bin√§rer Form ‚Äû11111111‚Äú) senden, leuchten alle 8 Pixel vertikal von 16 bis 23 und horizontal in der 35. Spalte auf.  Meiner Meinung nach ergibt sich aus diesem Merkmal einer der Nachteile: Die Unf√§higkeit, den Zustand jedes Pixels einzeln auf Hardwareebene zu steuern.  Ein Byte ist das kleinste Datenelement f√ºr Grafiken.  Wenn ein Byte an die aktuelle Adresse √ºbertragen wird, werden alle 8 entsprechenden Pixel in der aktuellen Zone aktualisiert.  Das Display unterst√ºtzt nicht das Lesen der aktuell angezeigten Grafikinformationen zum Mikrocontroller.  Daher ist es bei Bedarf erforderlich, die Ausgabeinformationen im Voraus in einem dedizierten Puffer zu speichern und den Status von Pixeln (Bits) zu √§ndern, Bitmasken f√ºr Bytes aus diesem Puffer anzuwenden und sie erneut an die Anzeige zu √ºbertragen. <br><br>  Das Modellieren und √úberlegen der Position einer bestimmten grafischen Information auf dem Display wurde unter Ber√ºcksichtigung der obigen Merkmale durchgef√ºhrt.  Dies wurde durchgef√ºhrt, um den Code beim Schreiben des Programms zu vereinfachen.  Und es ist kein Zufall, dass die Schriftgr√∂√üe aus der Kategorie 8, 16, 24, dh einem Vielfachen von 8, ber√ºcksichtigt wurde. Analog zur Anzeige habe ich auch die grafischen Informationen in 6 horizontale Zonen unterteilt.  In der ersten Zone werden die absoluten und aktuellen Drehzahlwerte (ab dem Zeitpunkt des Einschaltens des Ger√§ts) im Kleingedruckten angezeigt.  In der zweiten Zone die absoluten und aktuellen Werte des Pfades (in Kilometern mit Rundung auf Hundertstel).  In der dritten Zone - Durchschnittsgeschwindigkeit.  Im vierten - maximale Geschwindigkeit und im Gro√üdruck - die aktuelle Geschwindigkeit.  In der f√ºnften Zone werden zwei Fortschrittsbalken angezeigt, um anzuzeigen, dass das ROM voll ist und die Anzahl der √úberschreibungen.  In der sechsten, letzten Zone das Datum und die Uhrzeit.  Dies ist die f√ºnfte Zone, die die Ausnahme darstellt, wenn in vertikaler Richtung einer aufgenommenen Spalte Pixel vorhanden sind, die sich auf unterschiedliche Informationen beziehen.  Daher werden diese Informationen unter Verwendung von Bitmasken in einem Puffer gesammelt, dessen Inhalt dann in dieser f√ºnften Zone angezeigt wird.  In 3-5 Zonen gibt es auch Informationen zum Zeichnen eines Rahmens um den angezeigten Geschwindigkeitswert.  In der letzten Zone wird jedes erste (niedrigstwertige) Bit in allen Spalten auf "1" gesetzt, um die Trennlinie (40. Zeile) zu zeichnen.  F√ºr diese Simulation und Visualisierung von Adressen habe ich alle oben genannten Punkte in Excel-Zellen dargestellt. <br><br><img src="https://habrastorage.org/webt/nd/5z/vk/nd5zvk7smre6acj0voalhm5bimi.png"><br><br>  So sieht das erste Anzeigefenster aus.  Nur zwei Fenster.  Das zweite Fenster ist die Ausgabe des Diagramms (Histogramm) der Bewegung.  Daf√ºr werden 5 Zonen vertikal (40 Zeilen) und alle 84 Spalten horizontal zugewiesen.  Die sechste Zone mit der Uhr ist f√ºr beide Fenster gleich. <br><br>  Beim Programmieren habe ich beschlossen, keine Bibliothek zu verwenden, um mit dieser Anzeige zu arbeiten.  Pers√∂nlich ist es f√ºr mich einfacher, das Datenblatt zu verstehen, einen Teil der Funktionen selbst zu implementieren, als die Bibliothek zu verstehen.  Dar√ºber hinaus wurden darin gewisse Vorteile gefunden.  Nachdem ich k√ºrzlich eine der Bibliotheken heruntergeladen hatte, fand ich dennoch deren Funktionsmerkmale heraus.  Es ist universell, mit seiner Hilfe k√∂nnen Sie Pixel individuell steuern und sich auf der realen Pixeladresse positionieren.  Die Bibliothek verwendet jedoch einen Puffer mit einer Gr√∂√üe von 84 * 6 Byte. Dieser Zeitgeberpuffer wird regelm√§√üig an die Anzeige gesendet, um die Grafiken zu aktualisieren.  Somit sind der Timer und ein Teil des Speichers MK besch√§ftigt.  In meinem speziellen Fall ist es nicht erforderlich, eine Bibliothek zu verwenden, da ich bei der Modellierung im Voraus darauf geachtet habe, die Trennung der Informationen zwischen den angezeigten Zonen zu maximieren, die den Anzeigezonen vollst√§ndig entsprechen.  Die Informationen auf dem Display m√ºssen nicht regelm√§√üig aktualisiert werden: Die Informationen werden nur dann aktualisiert, wenn sie sich √§ndern (bei jeder Drehung des Rads, bei jedem Knopfdruck usw.).  Daher betone ich noch einmal: Je nach Aufgabe k√∂nnen Sie die Verwendung von Bibliotheken vermeiden. <br><br>  Um mit einer Uhr-Mikroschaltung und einem ROM zu arbeiten, habe ich auch nicht auf die Verwendung von Bibliotheken zur√ºckgegriffen: Alle Funktionen sind recht einfach und werden von mir nach dem Studium der Datenbl√§tter f√ºr diese Komponenten implementiert. <br><br>  Betrachten Sie nun den Stromkreis des Ger√§ts. <br><br><img src="https://habrastorage.org/webt/fj/6h/ry/fj6hryk8yrvhu4wr9ckd9njfkj0.png"><br><br>  Das Layout des Tachometers ist relativ einfach.  Dar√ºber hinaus enth√§lt die Schaltung ein IC5 MAX756-Element, das als 3- bis 5-Volt-Stromrichter f√ºr eine zuverl√§ssige Stromversorgung aus dem Originalakku des Nokia 3310-Mobiltelefons dient. Die Schaltung f√ºr eine 3-Volt-Stromversorgung wurde aufgrund des Fehlens des entsprechenden MK und der entsprechenden Peripherieger√§te nicht implementiert.  Zum jetzigen Zeitpunkt habe ich den MAX756 noch nicht erworben, und die gesamte Schaltung wird immer noch von einer externen Krona-Batterie mit dem LM7805-Regler gespeist (nicht ganz die beste Option).  Es wird an die Kopfh√∂rerbuchse an der Unterseite des Telefons angeschlossen.  Der Reedschalter SF1, bei dem es sich um einen Raddrehungssensor handelt, ist mit dem Interrupt-Port INT0 MK (Pin 32) verbunden.  Es wird sicher von der Unterseite des Telefons mit dem Ladeanschluss verbunden.  Die mit den Tasten ‚Äû1‚Äú, ‚Äû2‚Äú, ‚Äû3‚Äú des Mobiltelefons verbundenen Funktionstasten S1-S3 sind mit beliebigen Anschl√ºssen (Pins 23, 27, 28) verbunden.  Ein Pin S4 ist mit Pin 29 des MK-Resets verbunden, der mit der oberen Endtaste zum Einschalten des Mobiltelefons zusammenf√§llt.  Ich habe es einfach so gemacht.  Das Ger√§t selbst hat keinen Standby-Modus und schaltet sich mit Strom ein.  Ein IC2-Display und ein Anschluss zum Blinken von X1 sind an den SPI-Port des Controllers angeschlossen (Pins 15-17).  Mit dem Anschluss, den ich auf der Grundlage der vorhandenen ‚ÄûSpots‚Äú auf dem Original-Motherboard zum Koppeln mit einem PC (am selben Ort) herstellen wollte, habe ich einen kleinen Haken bekommen und werde ihn in Zukunft an einen anderen Ort √ºbertragen.  Eine UART-Schnittstelle f√ºr die Benutzerverbindung zu einem Computer ist mit demselben Anschluss verbunden, √ºber den Datum und Uhrzeit auf dem Ger√§t konfiguriert werden (Pins 30-31, RX / TX).  Das Display ist √ºber Teiler an Widerst√§nden mit der Steuerung verbunden, die zur Spannungsreduzierung dienen, da das Display mit einer Spannung von 3,3 V arbeitet. Zus√§tzlich sind die Display-Pins D / C (Daten / Befehl), SCE (Strobe) und RES (Display Reset) mit beliebigen Ports verbunden MK PB0, PB1 bzw. PB2 (Pins 12-14).  Die Anzeige wird √ºber die Dioden D1-D3 und den Widerstand R6 mit Strom versorgt, die dazu dienen, die Spannung von 5 auf 3,3 V zu reduzieren, ohne dass ein Linearregler verwendet werden muss.  Von MK getakteter Quarz Cr1 mit einem Nennwert von 4,5 MHz wurde zuf√§llig, aber absichtlich ausgew√§hlt.  Er fiel einfach in meinen Arm und ich entschied mich, ihn zu benutzen.  Die Transistoren Q1 und Q2 sind mit den Anschl√ºssen des PD4 und PD5 MK (Pins 2 und 9) verbunden, auf die die LEDs f√ºr die Hintergrundbeleuchtung des Displays und der Tastatur geladen sind.  Der Controller bietet die M√∂glichkeit, die Hintergrundbeleuchtung individuell zu steuern, wie es das urspr√ºngliche Layout des Mobiltelefons vorsieht (dies war auf Hardwareebene und nicht auf Benutzerebene), obwohl dies in der Praxis nicht erforderlich ist.  Der I2C-Bus ist mit den PC2-PC3-Ports (Pins 25-26) verbunden und wird der Einfachheit halber programmgesteuert unter Verwendung der entsprechenden Bibliothek implementiert (obwohl er mit den Hardware-TWI-Ports verbunden ist).  Das IC3-ROM und die Echtzeituhr (RTC) IC4 sind am Bus aufgeh√§ngt.  Machen Sie sofort eine Reservierung, damit es in den Kommentaren keine Kritik gibt: Ich wei√ü, dass der DS1307 nicht die beste L√∂sung ist, aber zum Zeitpunkt der Entwicklung der Schaltung wusste ich nichts √ºber die Existenz des DS3231.  Das ROM befindet sich auf einem abnehmbaren Anschluss, √§hnlich einer SIM-Karte.  Ein zus√§tzlicher Port des PC1-Controllers (Pin 24) wird verwendet, um Impulse mit einer Frequenz von 1 Hz mit RTC zu empfangen, um die die Zeit auf dem Display aktualisiert wird.  Alle passiven Body-Kit-Komponenten - gem√§√ü Datenbl√§ttern f√ºr jede aktive Komponente. <br><br>  Ber√ºcksichtigen Sie mathematische √úberlegungen zur Berechnung bestimmter Parameter.  Wie bereits eingangs erw√§hnt, basiert das Prinzip der Geschwindigkeitsmessung auf der Berechnung der Umdrehungsdauer des Rades, und der Abstand wird auf der Grundlage der Messung der Anzahl solcher Umdrehungen berechnet.  Die Steuerung misst die Zeit zwischen dem vorherigen und dem vom Reed-Schalter eingehenden Impuls.  Das Messergebnis wird in einen Geschwindigkeitswert umgewandelt, indem der Wert des Radumfangs durch die Umdrehungsdauer dividiert wird. Dieser Wert wird mit jedem Impuls (Radumdrehung) auf dem Display aktualisiert.  Hierbei ist anzumerken, dass aus physikalischer Sicht die Durchschnittsgeschwindigkeit eines Fahrrads auf einem dem Radumfang entsprechenden Streckenabschnitt berechnet wird.  Separat wird die Anzahl der Impulse berechnet und dann in einen Abstandswert umgewandelt.  Um die Drehzeit des Rades zu messen, verwendet die Steuerung einen eigenen Timer.  ATmega8 verf√ºgt √ºber einen 8-Bit- und einen 16-Bit-Timer.  Der Dynamikbereich der Messung h√§ngt von der Bittiefe des Timers ab.  In meinem Fall wird ein 16-Bit-Timer verwendet, da 8 Bit (256 Z√§hlungen) kategorisch unzureichend sind.  Die maximale Messdauer (bevor der Timer √ºberl√§uft) entspricht der minimalen Messgeschwindigkeit.  Sie k√∂nnen den sogenannten Software-Timer eingeben, der gro√üe Zeitr√§ume misst.  Um das Programm zu vereinfachen, habe ich dies jedoch nicht getan.  Mit dem verwendeten Quarz von 4,5 MHz und einem maximalen Teilerwert von 1024 in der Timerkonfiguration haben wir: (1 / (4500000/1024)) = 0,000227556 ‚Äã‚ÄãSek.  Dieser Wert entspricht der Mindestlaufzeit des Kontos.  Der maximale Kontodauer betr√§gt 0,000227556 ‚Äã‚Äã* 65536 = 14,913 Sekunden.  Die maximale messbare Geschwindigkeit, die der minimalen messbaren Periode entspricht, betr√§gt ungef√§hr 30.000 km / h.  Dies war nicht einmal eine Vereinbarung wert, die ‚ÄûReserve von oben‚Äú ist einfach riesig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die minimale gemessene Geschwindigkeit, die der maximalen gemessenen Periode entspricht, betr√§gt jedoch 2,26 / 14,913 / 1000 * 3600 = 0,54 km / h. Hier ist 2,26 der Umfang des Fahrradrades (in Metern) in meinem Fall. Mit diesem minimalen Messwert bin ich sehr zufrieden. Wenn sich das Fahrrad mit einer Geschwindigkeit von weniger als 0,54 km / h bewegt, zeichnet der Fahrradtacho den Bewegungsmangel (und den Timer√ºberlauf) auf. Mit diesem Quarz funktioniert die 4,5-MHz-UART-Schnittstelle bei einer Geschwindigkeit von 2400 Baud mit einem akzeptablen akzeptablen Fehler einwandfrei. Diese Geschwindigkeit ist auch v√∂llig ausreichend, insbesondere da ich UART f√ºr einmalige Uhreinstellungen von einem Computer aus verwende (zum Kopieren von Datum und Uhrzeit von einem Computer auf ein Ger√§t). Wenn Sie eine h√∂here Quarzfrequenz nehmen, erh√∂ht sich die messbare Mindestgeschwindigkeit, was f√ºr mich nicht akzeptabel ist.und Sie m√ºssen einen Software-Timer verwenden. Und wenn Sie es unten betrachten, nimmt die Leistung des gesamten Ger√§ts ab. Deshalb habe ich mich entschlossen, diesen speziellen Quarz zu verlassen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich stelle fest, dass die Perioden- und Geschwindigkeitswerte umgekehrt proportional sind und der Mikrocontroller-Timer die Periode diskret misst. In unserem Fall ist der Messbereich (0,000227556 ‚Äã‚Äã... 14,913) gleichm√§√üig mit Punkten in H√∂he von 65535 markiert und in viele gleiche Intervalle unterteilt. Und diese Punkte entsprechen allen Arten von Messwerten. Unter Verwendung der Umrechnung von Intervallen von Zeit zu Geschwindigkeit wird dieses Intervallsystem von gleichm√§√üig zu umgekehrt proportional umgerechnet. Daher ist der Bereich unterschiedlich gemessener Geschwindigkeiten in ungleichm√§√üige Intervalle unterteilt. Die L√§nge dieser Intervalle nimmt mit zunehmendem Geschwindigkeitswert selbst zu. Angesichts dieser Tatsache wird die riesige "Reserve von oben", √ºber die ich etwas h√∂her geschrieben habe, nicht verkehrt sein. In der Praxis reicht es v√∂llig aus, den Wert von 100 km / h f√ºr die maximal gemessene Geschwindigkeit des Fahrrads anzunehmen.Dies dient nur dazu, keine neue Ziffer (Hunderte) einzuf√ºhren und die Breite des auf dem Display angezeigten Parameters nicht zu erh√∂hen. Wir berechnen, wie lang das Intervall zwischen benachbarten m√∂glichen Werten bei einer Geschwindigkeit in der Nachbarschaft ist, beispielsweise 90 km / h. Unter Verwendung der inversen Formeln oder Auswahl ist es einfach zu berechnen, dass f√ºr den Wert des Zeitgebers 397 (von 65536 m√∂glich) die gemessene Geschwindigkeit 90,06 km / h entspricht. Und mit einem benachbarten Timerwert von 398 - 89,83 km / h. Und der Unterschied zwischen den Geschwindigkeiten betr√§gt 0,23 km / h, was bereits mehr als akzeptabel ist. Und bei niedrigeren Geschwindigkeiten wird dieser Unterschied noch geringer sein. Das Display zeigt den Geschwindigkeitswert auf das n√§chste Hundertstel an. In der Praxis reicht es jedoch normalerweise aus, auf das n√§chste Ganze oder auf die Zehntel zu runden. Aus dem Vorstehenden k√∂nnen wir schlie√üen: Die Ungleichm√§√üigkeit des ‚ÄûGitters‚Äú der Geschwindigkeiten kann vernachl√§ssigt werden.da der dadurch verursachte Messfehler den zul√§ssigen Fehler nicht √ºberschreitet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Entfernung zu berechnen, reicht es aus, die Anzahl der Impulse (Umdrehungen) mit dem Umfang des Rades zu multiplizieren. In diesem Fall wird der Abstand nat√ºrlich genau auf den Umfang des Rades berechnet, was durchaus akzeptabel ist. Die aktuelle Durchschnittsgeschwindigkeit wird als Verh√§ltnis der aktuell zur√ºckgelegten Strecke zum Zeitwert ab dem Zeitpunkt des Einschaltens berechnet. Dies ist die Zeit, die der Controller ber√ºcksichtigt, indem er die Anzahl der Impulse z√§hlt, die einmal pro Sekunde mit RTC ankommen. Die durchschnittliche Geschwindigkeit auf dem Display wird zusammen mit der Zeitaktualisierung aktualisiert (einmal pro Sekunde). Alle anderen Parameter werden mit jeder Umdrehung des Rades aktualisiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun zu den kleinen Funktionen der Benutzeroberfl√§che. Mit der ersten Taste k√∂nnen Sie zwischen den Modi wechseln (Grafikmodus oder Wertanzeigemodus). Die zweite Taste - zeigt die absolute (f√ºr alle Zeiten) maximale Geschwindigkeit anstelle der relativen an, wenn Sie sie gedr√ºckt halten. Au√üerdem werden Datum und Uhrzeit des Erreichens dieser Geschwindigkeit anstelle des aktuellen Datums und der aktuellen Uhrzeit angezeigt. Au√üerdem wird der Wert der aktuellen ROM-Adresse anstelle des Werts der relativen Geschwindigkeit (zur Steuerung) angezeigt. Dieser Wert kann durch den horizontalen Fortschrittsbalken in der 38. Zeile der Anzeige gesch√§tzt werden. Auf diesem ROM mit einer Kapazit√§t von 65536 Bytes (512 kbit) werden die gemessenen Parameter aufgezeichnet. Wie sp√§ter gesagt wird, reicht es aus, den anf√§nglich gemessenen Parameter (die Rotationsdauer des Rades) mit dem anf√§nglichen Zeitstempel aufzuzeichnen.Alle anderen Parameter k√∂nnen von einem Computerprogramm im Stadium des ROM-Scannens leicht berechnet werden. Die dritte Taste dient zur Steuerung der Hintergrundbeleuchtung. Im Gegensatz zur obigen Bildschirmskizze habe ich sp√§ter unbedeutende Nullen auf den sekund√§ren Parametern entfernt, um sie deutlicher anzuzeigen. Im grafischen Modus wird ein Histogramm der Bewegungsgeschwindigkeit von links nach rechts gezeichnet, das den Prozess der Geschwindigkeits√§nderung √ºber einen kleinen Teil der Entfernung von 84 Umdrehungen des Rads deutlich zeigt. Der Histogrammwert ist die Geschwindigkeit auf einer Skala von 1 Pixel pro 1 km / h. Wenn die Geschwindigkeit 40 km / h √ºberschreitet, wird das Bild zweimal vertikal verkleinert, um eine Abweichung vom Ma√üstab zu vermeiden. Gr√ºndliche Merkmale des Ger√§teverhaltens m√ºssen hier nicht beschrieben werden.Ich habe sp√§ter unbedeutende Nullen auf den sekund√§ren Parametern entfernt, um sie deutlicher anzuzeigen. Im grafischen Modus wird ein Histogramm der Bewegungsgeschwindigkeit von links nach rechts gezeichnet, das den Prozess der Geschwindigkeits√§nderung √ºber einen kleinen Teil der Entfernung von 84 Umdrehungen des Rads deutlich zeigt. Der Histogrammwert ist die Geschwindigkeit auf einer Skala von 1 Pixel pro 1 km / h. Wenn die Geschwindigkeit 40 km / h √ºberschreitet, wird das Bild zweimal vertikal verkleinert, um eine Abweichung vom Ma√üstab zu vermeiden. Gr√ºndliche Merkmale des Ger√§teverhaltens m√ºssen hier nicht beschrieben werden.Ich habe sp√§ter unbedeutende Nullen auf den sekund√§ren Parametern entfernt, um sie deutlicher anzuzeigen. Im grafischen Modus wird ein Histogramm der Bewegungsgeschwindigkeit von links nach rechts gezeichnet, das den Prozess der Geschwindigkeits√§nderung √ºber einen kleinen Teil der Entfernung von 84 Umdrehungen des Rads deutlich zeigt. Der Histogrammwert ist die Geschwindigkeit auf einer Skala von 1 Pixel pro 1 km / h. Wenn die Geschwindigkeit 40 km / h √ºberschreitet, wird das Bild zweimal vertikal verkleinert, um eine Abweichung vom Ma√üstab zu vermeiden. Gr√ºndliche Merkmale des Ger√§teverhaltens m√ºssen hier nicht beschrieben werden.Der Histogrammwert ist die Geschwindigkeit auf einer Skala von 1 Pixel pro 1 km / h. Wenn die Geschwindigkeit 40 km / h √ºberschreitet, wird das Bild zweimal vertikal verkleinert, um eine Abweichung vom Ma√üstab zu vermeiden. Gr√ºndliche Merkmale des Ger√§teverhaltens m√ºssen hier nicht beschrieben werden.Der Histogrammwert ist die Geschwindigkeit auf einer Skala von 1 Pixel pro 1 km / h. Wenn die Geschwindigkeit 40 km / h √ºberschreitet, wird das Bild zweimal vertikal verkleinert, um eine Abweichung vom Ma√üstab zu vermeiden. Gr√ºndliche Merkmale des Ger√§teverhaltens m√ºssen hier nicht beschrieben werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist erw√§hnenswert, einen der charakteristischen Unterschiede zwischen meinem Tacho und billig gekauft. Es besteht in der Geschwindigkeit der Aktualisierung der Geschwindigkeitsanzeige auf dem Display. In meinem Ger√§t wird es bei jeder Umdrehung des Rads sofort wie berechnet aktualisiert. Bei gekauften Ger√§ten wird es mit einer gewissen Verz√∂gerung aktualisiert. M√∂glicherweise ist diese Verz√∂gerung auf den Versuch zur√ºckzuf√ºhren, das Messrauschen zu filtern (z. B. unter Verwendung der Methode des gleitenden Durchschnitts), um die Geschwindigkeitsanzeige auf dem Display f√ºr eine detailliertere Klarheit zu stabilisieren. Oder die Anzeige wird in regelm√§√üigen Abst√§nden (z. B. zweimal pro Sekunde) vollst√§ndig aktualisiert. Es mag praktisch sein, aber ich wollte mit jeder Umdrehung des Rades ein Geschwindigkeitsupdate implementieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Leiterplatte wird nach der LUT-Methode in Form der Originalplatine des verwendeten Mobiltelefons hergestellt. Bei der Herstellung der Leiterplatte habe ich das SLayout-Programm verwendet. Gleichzeitig habe ich vorab ein Bild von der Originalplatine auf beiden Seiten des Scanners aufgenommen und die Bilder als Vorlage in SLayout abgelegt. Dies ist erforderlich, um Pads zum Anschlie√üen des Displays, der Tasten und Anschl√ºsse an ausschlie√ülich erforderlichen Stellen zu zeichnen. Bei der Herstellung der Platte trat ein Fehler von ca. 0,5 mm auf. Dieser Fehler erwies sich hinsichtlich der Kombination von Pads und Elementen als akzeptabel. Dieser Fehler beeintr√§chtigte jedoch die Qualit√§t der Hintergrundbeleuchtung: Versiegelte LEDs wurden um einen Bruchteil von Millimetern verschoben und fielen nicht in den Fokus von Lichtstreudornen. Aus diesem Grund nahm die Helligkeit der Hintergrundbeleuchtung ab, wodurch die Effizienz verringert wurde.Die folgenden Abbildungen zeigen eine Ansicht der Leiterplatte in SLayout zusammen mit drei kleinen Leiterplatten f√ºr ROM in Form einer SIM-Karte. Au√üerdem werden Scans der urspr√ºnglichen Leiterplatte von zwei Seiten angezeigt.</font></font><br><br><img src="https://habrastorage.org/webt/t4/x_/5a/t4x_5ad0pzcc8eyisyxrlmngkvu.png"><br><br><img src="https://habrastorage.org/webt/hj/gm/wp/hjgmwpma4fq8jbfeasauhjgfaqw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Elemente (Tasten, Anschl√ºsse) sind durch d√ºnne Drahtbr√ºcken miteinander verbunden, da keine Schienen verlegt werden k√∂nnen. Es gibt einen Spielraum f√ºr alle verf√ºgbaren Schaltfl√§chen, dh es ist m√∂glich, jede verf√ºgbare Schaltfl√§che zu verwenden. Es kann zweckm√§√üig sein, die gro√üe Taste in der Mitte zu einer Taste zum Umschalten der Anzeigemodi zu machen. In der oberen linken Ecke der Platine befindet sich eine 3-Volt-RTC-Batterie. Im Allgemeinen werden alle Elemente auf der Platine korrekt platziert, wobei ihre Abmessungen mit den Abmessungen des Geh√§uses abgestimmt werden. Im Gegensatz zum vergoldeten Original ist die hauseigene Platine mit normalem Lot beschichtet. Wie in der ersten √úbung gezeigt, geht der Kontakt mit dem Display und anderen Peripherieger√§ten nicht verloren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Programm f√ºr MK erwies sich als ziemlich umfangreich und nimmt einen bedeutenden Teil seines Ged√§chtnisses ein. </font><font style="vertical-align: inherit;">Dar√ºber hinaus sieht das Programm die Verwendung eines eigenen nichtfl√ºchtigen Speichers der Steuerung (EEPROM) zum Aufzeichnen und Speichern der erforderlichen Informationen vor. </font><font style="vertical-align: inherit;">Die folgende Tabelle zeigt die Verteilung dieser Informationen nach EEPROM-Adressen.</font></font><br><br><table border="1" cellpadding="7"><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adresse</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√∂√üe</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten</font></font></b> </td></tr><tr><td>  0 </td><td>  4 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n (f√ºr S) </font></font></td></tr><tr><td>  4 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t_min (f√ºr v_max) </font></font></td></tr><tr><td>  6 </td><td>  6 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datum von t_min </font></font></td></tr><tr><td>  12 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adresse EEPROM </font></font></td></tr><tr><td>  14 </td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EEPROM RW Count </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 128 </font></font></td><td>  80 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ziffern 8X8 </font></font></td></tr><tr><td>  208 </td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ziffern 3X5 </font></font></td></tr></tbody></table> Die ersten vier Bytes speichern die zur√ºckgelegte Strecke als Anzahl der Umdrehungen des Rades.  Ich habe speziell den 32-Bit-Integer-Typ f√ºr diese Variable gew√§hlt, da in der Praxis die Werte des zur√ºckgelegten Pfades relativ gro√ü sind.  Beispielsweise k√∂nnte eine ganzzahlige 16-Bit-Variable maximal 65.536 Umdrehungen (ca. 148 km) einsparen, was nat√ºrlich klein ist.  Es folgen zwei Bytes, um die absolute H√∂chstgeschwindigkeit aufrechtzuerhalten.  Tats√§chlich wird die minimale Raddrehzeit gespart.  Die Variable nimmt zwei Bytes ein, da ihr Wert das Ergebnis der Messung eines 16-Bit-Timers ist.  Die n√§chsten 6 Bytes sind das Datum und die Uhrzeit, zu der die oben angegebene H√∂chstgeschwindigkeit erreicht wurde.  Die Daten werden genau in dem Format dargestellt, in dem sie vom RTC-Chip gelesen werden (au√üer am Wochentag).  Als n√§chstes zwei Bytes, die den Wert der aktuellen Adresse des externen ROM speichern.  Dies ist eine Art Zeiger, der erforderlich ist, um die Aufzeichnung von Statistiken im ROM nach dem n√§chsten Einschalten des Ger√§ts fortzusetzen.  MK sollte wissen, an welcher Position des Adressraums des externen ROMs es zuletzt gestoppt wurde.  Von dieser Position aus setzt MK die Aufnahme fort.  Diesem Wert werden 2 Bytes zugewiesen, da der Adressraum des externen ROM 16 Bit betr√§gt.  Dies ergibt sich aus einer ROM-Gr√∂√üe von 64 kB.  Als n√§chstes folgt eine Einzelbyte-Variable, die den Wert der Anzahl der ROM-√úberschreibungen speichert.  Das √úberschreiben ist der Fall, wenn der obige Zeiger den Maximalwert erreicht und auf Null geht.  In diesem Fall werden neu empfangene Informationen auf dem ROM von Anfang an aufgezeichnet, wobei die darauf verf√ºgbaren alten Informationen gel√∂scht werden.  Eine ganzzahlige Einzelbyte-Variable kann maximal 256 Werte speichern.  Ich erinnere Sie daran, dass die Werte des ROM-Adresszeigers und die Anzahl der √úberschreibungen visuell durch zwei Fortschrittsbalken auf dem Display angezeigt werden.  Ferner werden nach einem gro√üen Sicherungsspeicher des EEPROM MK ab Adresse 128 grafische Informationen √ºber 8 x 8 Ziffern gespeichert.  Daf√ºr werden 80 Bytes zugewiesen (8 Bytes f√ºr jede Ziffer, wie bereits erw√§hnt).  Und schlie√ülich werden ab Adresse 208 30 Bytes f√ºr grafische Informationen √ºber kleine 3x5-Ziffern (drei Bytes pro Ziffer) gespeichert. <br><br>  Zus√§tzlich zum Hauptprogramm f√ºr den Mikrocontroller habe ich drei weitere Hilfsprogramme f√ºr den Computer geschrieben, auf die weiter unten eingegangen wird.  Alle Programme haben keine grafische Oberfl√§che und arbeiten √ºber die Befehlszeile von Windows XP. <br><br>  Mit dem ersten Programm k√∂nnen Sie Datum und Uhrzeit √ºber den COM-Anschluss von einem Computer auf den Fahrradtachometer kopieren.  Der Fahrradtachometer ist √ºber den MAX232-Chip mit dem Computer verbunden.  Mit WinAPI empf√§ngt das Programm das aktuelle Datum und die aktuelle Uhrzeit in einer speziellen Strukturvariablen vom Typ SYSTEMTIME.  Aus dieser Variablen werden der aktuelle Tag, Monat, Jahr, Wochentagsnummer, Stunden, Minuten, Sekunden im Dezimalformat extrahiert.  Alle diese Zahlen mit Ausnahme des Jahres √ºberschreiten nicht zwei Dezimalstellen (weniger als 100) und liegen innerhalb eines Bytes.  Der Wert des Jahres wird in eine zweistellige Zahl umgewandelt, indem die Zahl 2000, der Wert des aktuellen Jahrtausends, davon abgezogen wird.  Jede dieser zweistelligen Dezimalzahlen wird in das f√ºr den RTC-Chip charakteristische bin√§re Dezimalformat konvertiert.  In diesem Format belegt eine zweistellige Zahl auch ein Volumen von einem Byte.  Die h√∂chstwertigen 4 Bits werden mit der Zehnerstelle und die niedrigstwertigen mit der Anzahl der Einheiten codiert.  Anschlie√üend wird aus diesen Zahlen ein 13-Byte-Paket gem√§√ü einem Protokoll gebildet, das ich zuvor bestimmt habe.  Die ersten f√ºnf Bytes repr√§sentieren das Wort "TIME =" gem√§√ü Standard-ASCII-Codierung.  Dann folgen Sekunden, Minuten, Stunden, Wochentag, Tag, Monat, Jahr.  Das letzte Byte ist das Zeichen "#" als Ende des Nachrichtenzeichens.  Dieses Paket wird vom Computer √ºber den COM-Anschluss an das Ger√§t gesendet.  Das Mikrocontroller-Programm empf√§ngt das Paket und √ºberpr√ºft es gem√§√ü dem obigen Format auf Richtigkeit.  Wenn die ersten f√ºnf Bytes "TIME =" und das letzte "#" sind, wird das Senden als korrekt angesehen und die darin enthaltenen Bytes werden in der entsprechenden Reihenfolge interpretiert.  Ohne diese Byte-Zeichenfolge zu √§ndern, sendet der Controller sie √ºber den I2C-Bus an den RTC-Chip und konfiguriert sie f√ºr das aktuelle Datum und die aktuelle Uhrzeit.  Ich stelle fest, dass diese Mikroschaltung die Berechnung der Wochentage von 1 bis 7 unterst√ºtzt, obwohl dies als solcher Kalender, der die Entsprechung von Datum und Wochentag bestimmt, nicht der Fall ist.  Ich habe auf meinem Ger√§t keine Informationen zum Wochentag angezeigt. <br><br>  Das zweite Programm dient zur Verarbeitung von Daten aus dem Inhalt eines externen ROM.  Zun√§chst wurde angenommen, dass dieser Inhalt mit einem bekannten Programm, das mit bekannten MK- und ROM-Programmierern (z. B. ‚Äûicprog‚Äú) zusammenarbeitet, aus dem ROM in die Bilddatei kopiert werden sollte.  Nachdem ich das Prinzip des I2C-Betriebs genauer untersucht hatte, gelang es mir, diese Funktionalit√§t zu implementieren und in mein Programm aufzunehmen.  Das Schema des ROM-Programmierger√§ts dieser Serie, das ich im Ger√§t verwendet habe, ist in der folgenden Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/ke/be/p1/kebep1s6zkpkgf0i5eyxu5jcvbi.png"><br><br>  Das ROM ist mit dem COM-Port des Computers verbunden, der nicht als Mittel zum Informationsaustausch √ºber RS-232 (wo es ausreicht, die Ausg√§nge von TX, RX, GND zu verwenden) verwendet wird, sondern als Mittel zur willk√ºrlichen Eingabe / Ausgabe von logischen Signalen.  √úber den TX-Anschluss wird das ROM mit Strom versorgt, das vom 78L05-Regler auf 5 V stabilisiert wird.  Durch Steuern der TX-Ausgabe vom Computer k√∂nnen wir den ROM-Chip ein- oder ausschalten.  Die unidirektionale SCL-Taktleitung ist auf den RTS-Pin des COM-Ports konzentriert, und die bidirektionale SDA-Datenleitung ist auf zwei Pins konzentriert: CTS (Datenempfang) und DTR (Daten√ºbertragung).  Widerst√§nde und Zenerdioden D1 und D2 werden verwendet, um den Signalpegel auf TTL zu begrenzen, an dem der ROM arbeitet. <br><br>  Ich habe diesen Standardprogrammierer f√ºr meinen speziellen Fall entwickelt, bei dem anstelle eines ROM-Sockels ein SIM-Leseger√§t eines defekten Mobiltelefons verwendet wird. <br><br><img src="https://habrastorage.org/webt/-w/as/0e/-was0enetz2tighj_9_bziqip90.jpeg"><br><br>  √úber WinAPI greift das Programm auf die Pins des COM-Ports des Computers zu, setzt die daf√ºr erforderlichen Werte (0 oder 1) und entfernt den eingehenden Bin√§rwert aus dem ROM vom CTS-Pin.  Basierend auf diesem Toolkit wurde die I2C-Funktionalit√§t gem√§√ü der entsprechenden Spezifikation implementiert, auf die ich nicht n√§her eingehen werde.  Das Programm kann den Inhalt des ROM in ein Dateibild einlesen (wie ein normaler Programmierer) und auch eine solche Datei verarbeiten oder Informationen direkt aus dem ROM verarbeiten.  Die Informationsverarbeitung besteht darin, die Ausgabestatistikdateien in einem vorbestimmten Tabellenformat basierend auf den Eingabeinformationen aus dem ROM zu erhalten.  Jede solche Datei entspricht einer Ausl√∂sung (vom Moment des Stroms bis zum n√§chsten Einschalten des Ger√§ts).  Zun√§chst werde ich kurz das Eingabeformat beschreiben, das ich im Voraus definiert habe.  Bei jedem Einschalten des Ger√§ts werden zwei Byte Nullen in die aktuelle Adresse geschrieben, die aus dem EEPROM des Mikrocontrollers gelesen wird.  Wenn sich das Rad nach einer Zeit√ºberschreitung oder nach dem Einschalten des Ger√§ts (beim ersten Impuls) zu drehen beginnt, werden das aktuelle Datum und die aktuelle Uhrzeit im bin√§ren Dezimalformat geschrieben (wie es in den Registern des RTC-Chips gespeichert ist).  Und dann werden zwei Bytes von "Einheiten" 0xFF aufgezeichnet.  W√§hrend der Drehung des Rades wird f√ºr jeden k-ten Impuls (k = 2,3, ...) die Zeit der Raddrehung zwischen dem (k-1) -ten und dem k-ten Impuls durch zwei Bytes (hoch und niedrig) aufgezeichnet.  Offensichtlich reichen diese Informationen aus, um die aktuelle (nicht absolute) zur√ºckgelegte Strecke und die Geschwindigkeit mit Datum und Uhrzeit zu verkn√ºpfen.  Das Ausgabeformat ist Text und eine tabellarische Tabelle in * .csv-Dateien, die in Excel durch Doppelklick mit der Maus ge√∂ffnet werden.  Die Zeilen in dieser Tabelle entsprechen den Radumdrehungen, und die Spaltenwerte sind unten aufgef√ºhrt. <br><br><table border="1" cellpadding="7"><tbody><tr><td>  <b>ADR</b> </td><td>  ROM-Adresswert </td></tr><tr><td>  <b>DATUM / ZEIT</b> </td><td>  Startdatum und -zeit </td></tr><tr><td>  <b>Dez.</b> </td><td>  Dezimaler Timer-Wert </td></tr><tr><td>  <b>Zeit</b> </td><td>  Aktuelle Zeit </td></tr><tr><td>  <b>t</b> </td><td>  Reisezeit seit dem Einschalten </td></tr><tr><td>  <b>v</b> </td><td>  Geschwindigkeit </td></tr><tr><td>  <b>n</b> </td><td>  Geschwindigkeit </td></tr><tr><td>  <b>S.</b> </td><td>  Der Weg </td></tr><tr><td>  <b>an</b> </td><td>  Die absolute Anzahl der Umdrehungen (nur innerhalb des aktuellen ROM) </td></tr><tr><td>  <b>aS</b> </td><td>  Absoluter Pfad (nur innerhalb des aktuellen ROM) </td></tr><tr><td>  <b>n_Tag</b> </td><td>  Die Anzahl der Umdrehungen f√ºr den aktuellen Tag </td></tr><tr><td>  <b>S_day</b> </td><td>  Der Weg f√ºr den aktuellen Tag </td></tr><tr><td>  <b>v_max</b> </td><td>  H√∂chstgeschwindigkeit f√ºr die aktuelle Fahrt </td></tr><tr><td>  <b>av_max</b> </td><td>  Absolute H√∂chstgeschwindigkeit (nur innerhalb des aktuellen ROM) </td></tr><tr><td>  <b>v_mid</b> </td><td>  Durchschnittsgeschwindigkeit f√ºr die aktuelle Fahrt </td></tr></tbody></table>  Ein Screenshot des Inhalts einer solchen Datei in Excel ist in der folgenden Abbildung dargestellt.  Au√üerdem werden Diagramme der √Ñnderungen der aktuellen, durchschnittlichen und maximalen Geschwindigkeit in verschiedenen Farben in einem Koordinatensystem angezeigt.  Argument (X-Achse) - Geschwindigkeitswerte als Eingabedaten.  Die Abbildung zeigt die Parameter√§nderungen f√ºr die ersten 730 Umdrehungen.  Die zur√ºckgelegte Strecke ist mit dieser variablen linearen Abh√§ngigkeit verbunden (730 Umdrehungen entsprechen ungef√§hr 1650 m).  Daher k√∂nnen wir sagen, dass die Grafiken die Abh√§ngigkeit der Geschwindigkeit von der Entfernung (genau auf die horizontale Skala) widerspiegeln, im Gegensatz zu der traditionellen Abh√§ngigkeit der Geschwindigkeit von der Zeit, die beachtet werden sollte.  Wie bereits erw√§hnt, beruht dieses Merkmal auf der Ideologie und dem Prinzip der Messung der Geschwindigkeit anhand der Radgeschwindigkeit.  Schlie√ülich ist jeder Umdrehung des Rades ein bestimmter Zeitpunkt zugeordnet (der Moment der Ann√§herung des Magneten und des Reed-Schalters).  Nat√ºrlich ist diese Abfolge von Zeitstempeln nicht einheitlich.  Aus Gr√ºnden der Formalit√§t und Bequemlichkeit kann Excel jedoch ein Array von Zeitwerten im Pfad oder in der aktuellen Zeit als Argument f√ºr Diagramme angeben.  Trotzdem sollte beachtet werden, dass die tats√§chliche Abh√§ngigkeit der Geschwindigkeit von der Zeit (in einheitlichen Zeitintervallen f√ºr den diskreten Fall) mit einer variablen horizontalen Skala anders ausgesehen h√§tte. <br><br><img src="https://habrastorage.org/webt/fn/af/to/fnaftofg4-o5ihmbxhhn9olwlha.png"><br><br><img src="https://habrastorage.org/webt/lw/ul/qa/lwulqayq1gcskndypndok_opb3i.png"><br><br>  Die folgende Abbildung zeigt die gleiche Abh√§ngigkeit der Geschwindigkeit von den Umdrehungen, verwendet jedoch bereits den Filter nach der Methode des gleitenden Durchschnitts mit einer Fensterbreite von 11 Umdrehungen.  Alle Diagramme werden mit bekannten Methoden in Excel erstellt. <br><br><img src="https://habrastorage.org/webt/gx/xu/qk/gxxuqkk_mqlghugdmrgkhevpeem.png"><br><br>  Beim Vergleich der beiden Graphen der Geschwindigkeits√§nderung ist es offensichtlich, dass die Hochfrequenzkomponente in dem gefilterten Graphen fehlt, d.h.  L√§rm entfernt.  Die Breite des gleitenden Durchschnittsfensters von 11 Umdrehungen (ca. 25 m) ist meiner Meinung nach zu gro√ü.  Wenn Sie wirklich die Frage nach dem Filtern von Messwerten aus Rauschen aufwerfen, reicht es aus, eine kleine Fensterbreite von beispielsweise drei zu verwenden.  Dieser Algorithmus kann in das Fahrrad-Tacho-Programm integriert werden, da er nicht nur zur Analyse der Messwerte verwendet werden kann, sondern auch zur Anzeige dieser Messwerte in Echtzeit.  Trotz der Einfachheit dieses Algorithmus werde ich nicht auf die Details seiner Beschreibung eingehen, da dieses Thema im Verlauf der Mathematik behandelt wird und den Rahmen dieses Artikels sprengt.  Und hier ist eine weitere Klarstellung √ºber die Durchschnittsgeschwindigkeit.  Wie ich bereits geschrieben habe, ist die Durchschnittsgeschwindigkeit der einzige Parameter, der nicht bei jeder Umdrehung des Rades, sondern bei jeder Sekunde aktualisiert wird.  Ich habe dies getan, um sicherzustellen, dass das Display auch bei sehr langsamen Bewegungen eine √Ñnderung der Durchschnittsgeschwindigkeit anzeigt.  Daher weichen die Werte der Messwerte auf dem Display in Echtzeit geringf√ºgig von den Werten ab, die in Zukunft vom Computerprogramm beim Scannen des ROM berechnet werden.  Die Messwerte f√ºr die absolute Geschwindigkeit, den absoluten Pfad und die absolute H√∂chstgeschwindigkeit unterscheiden sich ebenfalls.  Das Display zeigt wirklich absolute Werte (f√ºr die gesamte Lebensdauer des Ger√§ts) und in den Ausgabetabellen - nur innerhalb der Grenzen des aktuell gelesenen ROM. <br><br>  Das dritte Programm ist im Wesentlichen das gleiche Programm f√ºr den Firmware-Mikrocontroller.  Ich arbeite mit dem einfachsten ‚ÄûSTK 200‚Äú -Programmierer, der an den LPT-Anschluss des Computers angeschlossen ist, oder besser gesagt mit seinem Analog, wenn Sie es so nennen k√∂nnen, da der Programmierer im einfachsten Fall √ºberhaupt keine aktiven Elemente enth√§lt.  Tats√§chlich stellt MK √ºber die SPI-Schnittstelle eine direkte Verbindung zu bestimmten Pins des LPT-Ports her und arbeitet als Slave.  Das Programm implementiert ein Protokoll f√ºr den Datenaustausch mit dem ATmega8-Controller gem√§√ü seinem Datenblatt (S. 237).  Die physische SPI-Schicht wird implementiert, indem die LPT-Portregister mithilfe der bekannten dynamischen Bibliothek ‚Äûinpout32.dll‚Äú verwaltet werden.  Meine Bibliothek ist nicht als Projekt verbunden (da ich das Erstellen eines Projekts als solches in ‚ÄûDev-cpp‚Äú vermieden habe, indem ich eine einfache ‚ÄûDatei‚Äú erstellt habe), sondern mithilfe der LoadLibrary-Funktion unter Verwendung des Strukturtyps HINSTANCE.  Die Bibliothek ‚Äûinpout32.dll‚Äú wird einer Variablen dieses Typs zugeordnet, und anschlie√üend werden Zeiger auf Funktionen aus dieser Bibliothek in separate Variablen extrahiert.  Inpout32.dll hat nur zwei Funktionen, die f√ºr die Eingabe und Ausgabe von Daten verantwortlich sind.  Auf diese Funktionen wird mit vorextrahierten Zeigern zugegriffen.  Die LPT-Port-Pins werden einzeln √ºber Bitmasken gesteuert.  In meinem speziellen Fall funktioniert das von mir geschriebene Programm mit dem EEPROM-Bereich des Controllers und dient zum Lesen, Sichern, Schreiben, Korrigieren und Wiederherstellen einer Sicherungskopie der darin gespeicherten Daten, die ich zuvor gezeichnet habe.  Wie alle anderen Programme wird das Programm √ºber die Befehlszeile ausgef√ºhrt.  In solchen F√§llen werden zur Implementierung der Multifunktionalit√§t des Programms die "Switch-Case" -Funktionen und ein Textbenutzerdialog verwendet, z. B. "Geben Sie '1' f√ºr Operation Nr. 1 ein, ... geben Sie '0' ein, um das Programm zu beenden."  Daten werden in verschiedenen f√ºr mich geeigneten Formaten angezeigt.  Dar√ºber hinaus kann das Programm einen vollst√§ndigen Speicherauszug des EEPROM-Controllers in 512 Byte auf dem Bildschirm anzeigen.  Das Programm kann auch grafische Informationen zu den im Speicher des Controllers verwendeten Schriftarten aufzeichnen.  Bei Kleingedruckten der Gr√∂√üe 3X5 bezieht das Programm Informationen aus der Textdatei "Fonts 3X5.txt", die sich im selben Verzeichnis befindet.  Die Datei enth√§lt eine tabellarische Tabelle mit 30 Bytes (3 x 10) im Hexadezimalformat.  Falls gew√ºnscht, kann es einfach in einem Texteditor bearbeitet werden, wodurch die Grafiken dieser Schriftart ge√§ndert werden.  Wie bereits erw√§hnt, ist dieses Kleingedruckte so einfach, dass eine √Ñnderung der Grafik keinen Sinn ergibt.  Das einzige ist, dass die vertikale Verschiebung m√∂glicherweise nur erforderlich ist, da ein Speicherplatz mit einer H√∂he von 8 Pixeln vorhanden ist und die Schrift eine H√∂he von 5 hat. Bei einer gro√üen Schrift mit der Gr√∂√üe 8 x 8, die die aktuelle Geschwindigkeit anzeigt, habe ich die Funktionalit√§t viel interessanter bereitgestellt.  Grafische Informationen zu dieser Schriftart werden nicht in einer Textdatei als Bytetabelle, sondern in grafischen visuellen BMP-Dateien dargestellt.  Jede Ziffer entspricht einer solchen Datei.  Die Parameter sind Gr√∂√üe 8X8, monochrom mit einer Schwarz-Wei√ü-Palette.  Unten sehen Sie einen Screenshot des bekannten Grafikeditors ‚ÄûMS Paint‚Äú mit der darin ge√∂ffneten Datei ‚Äû8.bmp‚Äú. <br><br><img src="https://habrastorage.org/webt/s3/7o/ek/s37oekzshuoye0acdpxotluebas.png"><br><br>  Empirisch habe ich die Struktur von monochromen BMP-Dateien untersucht, die von MS Paint erhalten wurden. Auf dieser Grundlage konnte ich lernen, jedes Pixel eines monochromen BMP-Bildes zu lesen (ohne Verwendung von Strukturen und Hilfsbibliotheken).  In der Phase des horizontalen zeilenweisen Lesens von unten nach oben (so ist die Struktur der BMP-Datei organisiert) konvertiert das Programm die Informationen in das vertikale Format, das f√ºr die verwendete Anzeige spezifisch ist.  Diese Operation wird in einem Durchgang ausgef√ºhrt, wobei Bitmasken und die Akkumulation von Variablenwerten verwendet werden.  Im Folgenden werde ich diesen Codeabschnitt f√ºr die i-te Ziffer zeigen und dabei auf die Einfachheit des Prozesses achten. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ fnt[i][k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; j++){ fseek(f, <span class="hljs-number"><span class="hljs-number">62</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*j, SEEK_SET); byte = ~fgetc(f); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte &amp; pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-k)){ fnt[i][k] += pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-j); } } }</code> </pre> <br>  In der ersten Schleife werden die Elemente des fnt-Arrays mit Nullen initialisiert.  Ferner tr√§gt jedes k-te Element dieses Arrays (k = 0 ... 7) f√ºr die i-te Ziffer (i = 0 ... 9) grafische Informationen √ºber jede entsprechende Spalte jeder entsprechenden Ziffer.  Der n√§chste Zyklus ist der Lauf entlang des Bildes der BMP-Datei.  Mit dem Operator fseek positionieren wir uns Bytes am Offset 62 + 4 * j der vordefinierten BMP-Datei f.  Die Spezifit√§t der Formel, mit der der Versatz in Abh√§ngigkeit von der Zeilennummer j berechnet wird, wird durch die Struktur der BMP-Datei bestimmt.  In der Byte-Zwischenvariablen erhalten wir den Byte-Wert am obigen Offset.  Dieses Byte speichert Informationen √ºber alle acht Pixel eines monochromen Bildes in der aktuellen Zeile j.  Der Operator '~' f√ºhrt eine bitweise Inversion des Bytes durch, was zu einer Farbinversion jedes Pixels f√ºhrt.  Dies liegt an der Tatsache, dass ein schwarzes Pixel in der Palette einer monochromen BMP-Datei einer logischen ‚Äû0‚Äú und Wei√ü - ‚Äû1‚Äú entspricht.  Im angewandten Display dagegen.  In einer verschachtelten Schleife findet eine Byteanalyse des Bytes statt und gleichzeitig werden Informationen im fnt-Ausgabearray akkumuliert.  Funktion pow2 - Erh√∂hen einer Zwei auf eine nicht negative ganzzahlige Potenz, unabh√§ngig geschrieben.  Anstelle dieser Funktion k√∂nnen Sie den effizienteren bitweisen Verschiebungsoperator "&lt;&lt;" verwenden, aber zum Zeitpunkt des Schreibens dieses Programms habe ich es nicht verwendet. <br><br>  Dar√ºber hinaus bietet das Programm die M√∂glichkeit, eine von mehreren Grafikoptionen f√ºr diese Schriftart meiner Wahl in den Speicher von MK zu schreiben.  Diese Optionen werden mithilfe von Verzeichnissen (Ordnern) mit einem Namen der Form "v1", "v2", "v3" usw. implementiert, die sich im Ordner "Fonts 8X8" im selben Verzeichnis wie das Programm befinden.  Und schon in diesen Ordnern befinden sich die notwendigen BMP-Dateien.  Dank der oben genannten Funktionalit√§t ist es m√∂glich, Zahlen aus einem ‚Äûleeren Blatt‚Äú in einem grafischen Editor zu korrigieren oder zu zeichnen und diese zu speichern und auf Verzeichnisse zu verteilen.  Ich habe drei Schriftartenoptionen.  Die erste Option ist das Original.  Die zweite - wie das Original, jedoch mit einer durchgestrichenen Null und einer modifizierten Einheit (ohne Unterstrich).  Die dritte ist eine Schriftart mit einem rechteckigen Rand. <br><br>  Die Fotos unten zeigen: die hergestellte Leiterplatte des Ger√§ts von hinten;  ein Ger√§t auf dem Tisch, an das Strom angeschlossen ist (mit einer nicht endg√ºltigen Version der Firmware);  ein in Betrieb befindliches Ger√§t, das an einem Fahrrad montiert ist und auf dem ein Diagramm der Geschwindigkeits√§nderungen angezeigt wird. <br><br><img src="https://habrastorage.org/webt/zm/5l/ly/zm5llykx8zbjhlpvl9hw72tfd98.jpeg"><br><br><img src="https://habrastorage.org/webt/kx/_b/mz/kx_bmzvxzlw-srwhzbudrpsdcg0.jpeg"><br><br><img src="https://habrastorage.org/webt/ak/lh/gx/aklhgxhxfzvj653rpxh4uqbrbri.jpeg"><br><br>  W√§hrend des Betriebs der Vorrichtung wurden jedoch kleine Fehler identifiziert, die mit den Herstellungsmerkmalen verbunden waren.  Zuallererst - schlechter Kontakt des Displays mit den Pads der Leiterplatte.  Beim Original-Mobiltelefon sind die Kontakte auf der Platine vergoldet und es kommt zu keiner Oxidation.  In meinem Fall sind sie einfach verzinnt. <br><br>  Auf der Grundlage des Vorstehenden wurde beschlossen, das Ger√§t in einem anderen Fall neu zu erstellen und die Leiterplatte neu zu erstellen, auf die das Display unversch√§mt gel√∂tet wird.  Ich habe diesen Prozess k√ºrzlich gestartet.  Das Ergebnis ist ein robusteres Design. <br><br><img src="https://habrastorage.org/webt/el/tw/r1/eltwr1m1zmbt1q5bj11v3a3cxks.png"><br><br><img src="https://habrastorage.org/webt/rh/hs/dw/rhhsdwamztytb2ix0le9mmyj2na.jpeg"><br><br><img src="https://habrastorage.org/webt/mp/rt/-h/mprt-hnrwvztbrvggcj6jhwx0qk.jpeg"><br><br>  Ich habe den Fall f√ºr das Ger√§t aus einem 17 mm dicken St√ºck Plexiglas auf einer CNC-Fr√§smaschine hergestellt.  Zu diesem Zweck habe ich die Skizzen des Falls im SPlan-Programm vorl√§ufig skizziert, wobei ich das Thema Zeichnungen, CAD usw. fast vollst√§ndig nicht kannte. <br><br><img src="https://habrastorage.org/webt/tn/j6/w-/tnj6w-zgduldrbd4-t9rqw1hihe.jpeg"><br><br>  Diese Skizzen werden f√ºr die allgemeine Darstellung und das Erhalten der Koordinaten von Kontrollpunkten ben√∂tigt.  Darauf aufbauend wird ein Programm f√ºr die CNC-Maschine geschrieben, das die allgemeinen Prinzipien und Abl√§ufe des Fr√§sens ber√ºcksichtigt.  Ich habe das CNC-Programm manuell in Excel geschrieben und dabei die Autocomplete-Funktionen f√ºr wiederholte Vorg√§nge verwendet. <br><br><img src="https://habrastorage.org/webt/eb/g1/ie/ebg1iewnui1ptplfwit3gvrbya0.jpeg"><br><br><img src="https://habrastorage.org/webt/qr/qa/kk/qrqakkmdcsuifjphgg_h8wcqybc.jpeg"><br><br>  Ich habe auch das Ger√§telayout leicht korrigiert, es ist in der folgenden Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/wd/e5/lh/wde5lh6inym01_4elygpybkuuqy.png"><br><br>  Anstelle der ohnehin schon unn√∂tigen Hintergrundbeleuchtung der Tastatur gibt es eine LED f√ºr Sch√∂nheit, die bei jeder Umdrehung des Rades blinkt.  Die Anschl√ºsse werden ebenfalls neu gezeichnet, und es gibt keine anderen Elemente, die in der aktualisierten Version des Designs nicht ben√∂tigt wurden.  Au√üerdem habe ich Quarz 4,433619 MHz gefunden und installiert, wobei einige Konstanten im Quellcode meines eigenen Programms leicht korrigiert wurden.  Einige kleinere √Ñnderungen am Programm wurden ebenfalls vorgenommen. <br><br>  Ein Foto des fertigen Produkts ist unten dargestellt.  Das Ger√§t wird von einer Batterie gespeist, die an Bord des Fahrrads steht.  Daraus ergibt sich auch eine Beleuchtung f√ºr Fahrten im Dunkeln. <br><br><img src="https://habrastorage.org/webt/qa/1w/ln/qa1wln2ikvghei7heep_puqn9ay.jpeg"><br><br>  Bei diesem Design funktionierte das Ger√§t v√∂llig st√∂rungsfrei.  Der einzige Nachteil ist die Verwendung eines nicht sehr hochwertigen RTC-Chips: Im Winter bei niedrigen Temperaturen ist die Zeit merklich in Eile, Sie m√ºssen sie einmal im Monat anpassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414281/">https://habr.com/ru/post/de414281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414269/index.html">"20.000 IOPS pro Knoten bieten eine gute Leistung bei einer Latenz von 5 ms." F√ºr OLTP - nein</a></li>
<li><a href="../de414271/index.html">So z√§hmen Sie eine Festplatte in einem Laptop und verhindern das Parken in 8 Sekunden Ausfallzeit</a></li>
<li><a href="../de414273/index.html">Was Sie wissen m√ºssen, bevor Sie einen Backtester f√ºr eine Handelsstrategie entwickeln: typische Probleme, Systemtypen und deren Parameter</a></li>
<li><a href="../de414277/index.html">Der Mensch, seine Umwelt und das Internet der Dinge</a></li>
<li><a href="../de414279/index.html">Abstimmung f√ºr Berichte beim achten DIY-Meeting in der Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../de414283/index.html">Unterscheiden von Kryptow√§hrung von Nicht-Kryptow√§hrung</a></li>
<li><a href="../de414285/index.html">Wir verwenden einen 433-MHz-Funkschalter zur Steuerung des PCs</a></li>
<li><a href="../de414289/index.html">SpaceX hat eine Stelle als Raketeningenieur f√ºr die Erstellung eines BFR er√∂ffnet</a></li>
<li><a href="../de414293/index.html">Das dritte j√§hrliche ReactOS Hackfest findet vom 14. bis 21. August 2018 in Berlin statt</a></li>
<li><a href="../de414295/index.html">"Es war m√∂glich": ungew√∂hnliche, aber effektive M√∂glichkeiten, "Audio" -Technologien einzusetzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>