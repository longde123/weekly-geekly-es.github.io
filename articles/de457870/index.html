<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏾 👩🏼‍🤝‍👨🏾 🗻 Projekterstellungsinfrastruktur mit Docker 👩🏼‍🚀 💘 🤖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt bereits Materialien zu Habr, wie Docker- Container für die Kompilierung des Projekts konfiguriert werden können . Beispiel: Verwenden von Dock...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Projekterstellungsinfrastruktur mit Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457870/"><p>  Es gibt bereits Materialien zu Habr, wie <strong>Docker-</strong> Container für die Kompilierung des Projekts konfiguriert werden <strong>können</strong> .  Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden von Docker zum Erstellen und Ausführen eines C ++ - Projekts</a> .  In diesem Artikel wird wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> Artikel das Problem des Erstellens des Projekts behandelt, aber hier möchte ich über das Lernprogramm hinausgehen und die Probleme der Verwendung von Containern in solchen Aufgaben sowie des Aufbaus der Erstellungsinfrastruktur mit <strong>Docker</strong> genauer betrachten. </p><a name="habracut"></a><br><h2 id="nemnogo-o-docker">  Ein bisschen über Docker </h2><br><p>  Zur Klarheit der weiteren Diskussion ist es notwendig, eine Beschreibung einiger <strong>Docker-</strong> Komponenten bereitzustellen. </p><br><h3 id="image">  Bild </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Docker-Image</a> ist eine <strong>schreibgeschützte</strong> Vorlage mit Anweisungen zum Erstellen eines Containers.  Um das <strong>Image</strong> zu erstellen <strong>, müssen</strong> Sie eine <strong>Docker-Datei</strong> erstellen, die alle Schritte der Assembly beschreibt.  Jeder dieser Schritte erstellt eine separate Ebene im <strong>Bild</strong> .  Jede nachfolgende Ebene wird über alle vorherigen Ebenen gelegt und enthält nur die Änderungen, die an der vorherigen Ebene vorgenommen werden müssen. </p><br><p>  Zum Beispiel für eine <strong>Docker-Datei</strong> : </p><br><pre><code class="plaintext hljs">FROM ubuntu:18.04 ADD app.sh /app ENTRYPOINT /bin/bash /app/app.sh</code> </pre> <br><p>  <strong>Das Docker-</strong> Image hat die folgende Struktur: </p><br><p><img src="https://habrastorage.org/webt/va/pv/rh/vapvrhrjuhirk1fw2up-_h-osau.png"></p><br><p>  Ebenen im <strong>Bild werden</strong> zwischengespeichert und können wiederverwendet werden, wenn keine Änderungen erkannt werden.  Wenn die Ebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geändert (hinzugefügt / gelöscht) wird</a> , werden alle nachfolgenden Ebenen von Grund auf neu erstellt.  Um Änderungen am Container-Image (und entsprechend an der Umgebung des gestarteten Prozesses) <strong>vorzunehmen</strong> , reicht es aus, die <strong>Docker-Datei</strong> zu reparieren und mit dem <strong>Erstellen</strong> des Images zu beginnen. </p><br><h3 id="konteyner">  Behälter </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Docker-Container</a> ist eine Startinstanz des <strong>Images</strong> .  Es kann erstellt, gestartet, gestoppt, gelöscht usw. werden. Standardmäßig sind Container voneinander und vom Hostsystem isoliert.  Beim Start startet der Container einen Befehl, der in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ENTRYPOINT</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMD angegeben werden kann</a> , und stoppt, wenn er abgeschlossen ist.  Eine akzeptable Situation ist, wenn sowohl <strong>CMD</strong> als auch <strong>ENTRYPOINT vorhanden sind</strong> , da sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation beschrieben</a> interagieren. </p><br><p>  Wenn Sie jeden Container erstellen, wird zusätzlich zu allen vorhandenen eine neue Ebene hinzugefügt.  Es ist im aktuellen Container beschreibbar und wird zusammen mit dem Container zerstört.  Alle Schreibvorgänge, bei denen während des Betriebs des Containers neue Dateien erstellt werden, werden auf diese Ebene angewendet. Das <strong>Bild</strong> bleibt immer unverändert.  Die Ebenenstruktur des erstellten Containers sieht also folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/yj/eb/rk/yjebrku_12g3cuu3qnl6xfdtdbo.png"></p><br><p>  Bei Verwendung des <code>docker run</code> wird jedes Mal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein <strong>neuer</strong></a> Container mit <strong>einer eigenen</strong> Ebene zum Schreiben erstellt.  Bei Build-Tasks bedeutet dies, dass bei jedem Start eine neue saubere Umgebung erstellt wird, die nichts mit früheren Ausführungen zu tun hat.  Die Liste der erstellten Container kann durch Ausführen des folgenden Befehls angezeigt werden: <code>docker container ls -a</code> . </p><br><h2 id="sobiraem-proekt-v-konteynere">  Wir sammeln das Projekt im Container </h2><br><p>  Der Klarheit halber beschreiben wir kurz den Prozess des Erstellens einer Anwendung in einem Container. Dieser Prozess wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2</a> ausführlicher beschrieben. </p><br><p>  Schematisch mögliche Schritte zum Erstellen der Anwendung in <strong>Docker</strong> können wie folgt dargestellt werden: <br><img src="https://habrastorage.org/webt/g_/ru/kt/g_ruktfloq-0loozoxjo9aafxga.png"></p><br><p>  Lassen Sie uns die gezeigten Schritte analysieren: </p><br><ol><li>  Wir verwenden die <strong>Docker-Datei</strong> , die die Umgebung beschreibt, Befehle zum Zusammenstellen und Kopieren der Ergebnisse und basierend darauf erstellen wir ein Image des Containers. </li><li>  Wir verwenden das resultierende Image, um den Container mit dem <code>docker run</code> zu erstellen und zu starten.  Wir mounten den Quellordner und den Ordner, in den das Assembly-Ergebnis in den Container kopiert wird. </li><li>  Nach Abschluss des Containers werden Assembly-Artefakte im bereitgestellten Verzeichnis abgelegt. </li></ol><br><p>  Ein Beispiel finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> . </p><br><p>  Da hier der <code>docker run</code> verwendet wird, wird für jeden Start ein separater Container mit einer eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebene zum Schreiben erstellt</a> , sodass temporäre Dateien aus früheren Assemblys nicht in die aktuelle gelangen.  Denken Sie daran, angehaltene Behälter zu reinigen. </p><br><p>  Das Mounten des Quellverzeichnisses erleichtert das Debuggen der Assembly.  Es birgt jedoch Risiken: Sie können eine Version von Code erfassen, der die Qualitätskontrolle nicht bestanden hat oder dem Versionskontrollsystem überhaupt nicht hinzugefügt wurde.  Um dies zu vermeiden, können Sie das Git-Repository bei jedem Build in den Container klonen, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Datei</a> : </p><br><pre> <code class="plaintext hljs">FROM ubuntu:bionic RUN apt-get update \ &amp;&amp; apt-get install -y apt-utils RUN apt-get update \ &amp;&amp; apt-get install -y make gcc g++ qt5-default git RUN mkdir -p /app/src WORKDIR /app/build #       ENTRYPOINT git -C /app/src clone https://github.com/sqglobe/SimpleQtProject.git \ &amp;&amp; qmake /app/src/SimpleQtProject/SimpleQtProject.pro \ &amp;&amp; make \ &amp;&amp; cp SimpleQtProject /app/res/SimpleQtProject-ubuntu-bionic</code> </pre> <br><p>  Hier erfolgt das Klonen aufgrund von Caching in <code>ENTRYPOINT</code> , nicht in der <code>RUN</code> Anweisung.  <code>ENTRYPOINT</code> wird <strong>immer</strong> ausgeführt, wenn der Container <code>ENTRYPOINT</code> wird, und das Ergebnis des <code>RUN</code> Befehls kann <strong>aus dem Cache entnommen werden</strong> . </p><br><h2 id="infrastruktura-dlya-sborki">  Infrastruktur aufbauen </h2><br><p>  Um ein Projekt für verschiedene Betriebssysteme oder Linux- <strong>Distributionen zu</strong> erstellen, kann eine bestimmte Konfiguration von Servern (Build-Maschinen, Server mit einem Versionskontrollsystem usw.) verwendet werden.  In der Praxis musste ich mich mit folgender Infrastruktur befassen: </p><br><p><img src="https://habrastorage.org/webt/ue/0i/1w/ue0i1wmgapl-8x9h9-zw-bsrbi8.png"></p><br><p>  Hier greift der Benutzer auf den Webserver zu, über den das Projekt auf Computern mit <strong>Ubuntu</strong> und <strong>Red Hat erstellt wird</strong> .  Als nächstes wird auf jedem Computer das Git-Repository mit dem Projekt in ein temporäres Verzeichnis geklont und die Assembly gestartet.  Der Benutzer kann die resultierenden Dateien von derselben Seite herunterladen, von der aus er den gesamten Prozess gestartet hat. </p><br><p>  Eine solche Assembly ist wiederholbar, da die Entwickler dieselbe Umgebung verwenden. </p><br><p>  Von den Minuspunkten ist es notwendig, eine gesamte Infrastruktur zu warten, mehrere Server zu verwalten, Fehler in Skripten und <strong>Webanwendungen zu</strong> beseitigen usw. </p><br><h2 id="uproschaem-s-docker">  Mit Docker vereinfachen </h2><br><p>  Die Unterstützung der oben gezeigten Infrastruktur erfordert bestimmte finanzielle und personelle Kosten.  Wenn Ihr Team an einem kleinen Startup arbeitet oder Sie der einzige Entwickler sind, können Sie <strong>Docker-</strong> Container verwenden, um Ihre Build-Infrastruktur zu implementieren. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stellen</a> Sie sich ein triviales <strong>Qt-</strong> Projekt vor, das mit <strong>qmake</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SimpleQtProject erstellt wurde</a> .  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Ordner des angegebenen Projekts enthält eine Reihe von Dateien: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">centos7.docker</a> - beschreibt einen Container zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen</a> eines Projekts für <strong>CentOS 7</strong> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ubuntu-bionic.docker</a> - ein Container zum Bauen unter <strong>Ubuntu 18.04</strong> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ubuntu-xenial.docker</a> - beschreibt einen Container zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen</a> unter <strong>Ubuntu 16.04</strong> . </li></ul><br><p>  Diese Dateien implementieren die Idee, Quellcode in einen Container zu klonen. </p><br><p>  Die gesamte Assembly wird mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makefile</a> gestartet.  Es ist sehr kurz und enthält genügend Kommentare.  Grundlage ist die Erstellung eines Images und der Start des Containers: </p><br><pre> <code class="plaintext hljs">%: %.docker docker build -t simple-qt-$(strip $(subst .docker,, $&lt; )) --file $&lt; . docker run --mount type=bind,source=$(RELEASE_DIR),target=/app/res simple-qt-$(strip $(subst .docker,, $&lt; ))</code> </pre> <br><p>  In dieser Phase der Assembly wird ein Image des Containers mit dem Namen erstellt, der aus dem Präfix <strong>simple-qt-</strong> und dem Namen des Systems besteht (für <strong>Centos 7 ist</strong> es <strong>simple-qt-centos7</strong> ).  Als <strong>Docker-</strong> Datei wird die entsprechende Datei mit der <strong>Berechtigung .docker verwendet</strong> .  Als Nächstes wird der Container basierend auf dem erstellten Image gestartet und ein Ordner zum Kopieren von Baugruppenartefakten darauf gemountet. </p><br><p>  Nachdem Sie den <code>make</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Verzeichnis ausgeführt haben, enthält der Ordner <strong>Docker / Releases</strong> die Build-Ergebnisse für mehrere Plattformen. </p><br><p>  Daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sieht</a> unsere Infrastruktur zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von SimpleQtProject folgendermaßen</a> aus: </p><br><p><img src="https://habrastorage.org/webt/bs/bg/ru/bsbgru5mo2bcrqb4z_31sdreyt8.png"></p><br><p>  Vorteile dieser Konfiguration: </p><br><ol><li>  <strong>Lokalität</strong> .  Der Entwickler sammelt ein Projekt für mehrere Plattformen auf seinem lokalen Computer. Dadurch entfällt die Notwendigkeit, eine Flotte von Servern aufzunehmen, das Kopieren von Artefakten zwischen Servern über das Netzwerk zu konfigurieren, Netzwerkbefehle zu senden und zu verarbeiten. </li><li>  <strong>Isolierung der Umwelt</strong> .  Der Container bietet eine vollständig isolierte Umgebung zum Erstellen einer bestimmten Anwendung.  Es ist möglich, Projekte mit inkompatiblen Umgebungen auf demselben Computer zu erstellen (z. B. solche, für die unterschiedliche Versionen derselben Bibliothek erforderlich sind). </li><li>  <strong>Versionierung</strong>  Durch Platzieren der <strong>Docker-Datei</strong> im Git-Repository können Sie Änderungen in der Build-Umgebung mit der Veröffentlichung neuer Releases verfolgen, auf frühere Versionen der Build-Umgebung <strong>zurücksetzen</strong> usw. </li><li>  <strong>Mobilität</strong> .  Bei Bedarf wird diese Infrastruktur problemlos auf einem anderen Computer bereitgestellt.  Mit der Technologie zum Erstellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eines Container-Images</a> können Sie ganz einfach Änderungen am Image selbst <strong>vornehmen.</strong> Aktualisieren <strong>Sie</strong> einfach die <strong>Docker-Datei</strong> und beginnen Sie mit der <strong>Erstellung</strong> des Images. </li><li>  <strong>Selbstdokumentierend</strong> .  Im <strong>Wesentlichen</strong> enthält eine <strong>Docker-Datei</strong> Schritte zum Bereitstellen einer Assembly-Umgebung.  Stellen Sie daher bei Bedarf eine solche Umgebung bereit, aber bereits in einem regulären System. Sie können die Befehle daraus verwenden. </li><li>  <strong>Leichtigkeit</strong> .  Der Container startet zu dem Zeitpunkt, an dem die Montage beginnt, und stoppt automatisch nach Abschluss.  Es verschwendet keine CPU-Zeit und RAM. </li></ol><br><p>  Es gibt jedoch ein deutliches Minus: Für die Zusammenstellung des Projekts muss das Container-Image zusammengesetzt werden.  Wenn Sie zum ersten Mal starten, kann dies lange dauern.  Bei wiederholten <strong>Bildern</strong> , insbesondere wenn sich die <strong>Docker-Datei</strong> nicht geändert hat, wird das Bild mithilfe des Caches um ein Vielfaches schneller zusammengestellt. </p><br><p>  Denken Sie auch daran, angehaltene Behälter zu reinigen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Abschließend möchte ich darauf hinweisen, dass <strong>Docker</strong> nicht die einzige Containerisierungstechnologie ist.  Es gibt jedoch einige Merkmale, die es für Montageaufgaben von demselben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXC</a> günstig unterscheiden: </p><br><ol><li>  Sie können einen Container mithilfe einer Text- <strong>Docker-Datei erstellen</strong> .  Dies ist eine Datei mit einfacher Syntax. Sie können sie (wie immer) zum Projekt-Repository hinzufügen und ständig zur Hand haben. </li><li>  Jedes Mal, wenn wir den <strong>Docker-</strong> Container mit dem <code>docker run</code> wir eine <em>saubere</em> Umgebung, als würden wir zum ersten Mal alles tun.  Temporäre Dateien zwischen Assemblys werden nicht gespeichert. </li><li>  Der Container startet nicht das gesamte Betriebssystem, sondern nur den erforderlichen Montageprozess. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457870/">https://habr.com/ru/post/de457870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457854/index.html">Hallo von den Programmierern der 80er Jahre</a></li>
<li><a href="../de457860/index.html">Entwicklung einer Anwendung für das Streaming mit Node.js und React</a></li>
<li><a href="../de457862/index.html">iOS Digest Nr. 8 (14. - 27. Juni)</a></li>
<li><a href="../de457864/index.html">Mythen und Legenden der Systemanalyse oder was ein Analyst bei einer Bank tut</a></li>
<li><a href="../de457866/index.html">Unit Testing in Laravel</a></li>
<li><a href="../de457872/index.html">Wie man Zeit verwaltet und aufhört zu zögern?</a></li>
<li><a href="../de457874/index.html">Warum kommen Mitarbeiter zurück? Geschichten von Abreise und Rückkehr</a></li>
<li><a href="../de457876/index.html">Übersetzung: IEEE 802.15.4z Standard. Was erwartet uns in Zukunft?</a></li>
<li><a href="../de457884/index.html">Souveränes Internet - Klärung von Befehlen</a></li>
<li><a href="../de457886/index.html">Zwei-Faktor-Authentifizierung auf der Site mithilfe eines USB-Tokens. Jetzt für Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>