<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 🚘 🎭 Nach Highload ++ Siberia 2019 - 8 Oracle-Aufgaben 👨🏼‍💻 💇🏾 ♣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! 

 Vom 24. bis 25. Juni fand in Nowosibirsk die Konferenz Highload ++ Siberia 2019 statt. Unsere Mitarbeiter waren auch beim Bericht „Oracle Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nach Highload ++ Siberia 2019 - 8 Oracle-Aufgaben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/459680/">  Hallo! <br><br>  Vom 24. bis 25. Juni fand in Nowosibirsk die Konferenz Highload ++ Siberia 2019 statt. Unsere Mitarbeiter waren auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beim Bericht</a> „Oracle Container Bases (CDB / PDB) und ihre praktische Verwendung für die Softwareentwicklung“ dabei. Wir werden etwas später eine Textversion veröffentlichen.  Es war cool, danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">olegbunin</a> für die Organisation sowie allen, die gekommen sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-7/k4/u1/-7k4u1btcjxquu515qeoyxnxigu.jpeg" width="350"></div><br>  In diesem Beitrag möchten wir Ihnen die Aufgaben an unserem Stand mitteilen, damit Sie Ihr Wissen in Oracle testen können.  Beantworten Sie unter den 8 Aufgaben die Optionen und Erklärungen. <br><a name="habracut"></a><br><h3>  Was ist der Maximalwert der Sequenz, die wir als Ergebnis des folgenden Skripts sehen werden? </h3><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.currval, s.nextval, s.currval, s.nextval, s.currval <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><ul><li>  1 </li><li>  5 </li><li>  10 </li><li>  25 </li><li>  Nein, es wird einen Fehler geben </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Gemäß Oracle-Dokumentation (zitiert aus 8.1.6): <br>  Innerhalb einer einzelnen SQL-Anweisung erhöht Oracle die Sequenz nur einmal pro Zeile.  Wenn eine Anweisung mehr als einen Verweis auf NEXTVAL für eine Sequenz enthält, erhöht Oracle die Sequenz einmal und gibt für alle Vorkommen von NEXTVAL denselben Wert zurück.  Wenn eine Anweisung Verweise auf CURRVAL und NEXTVAL enthält, erhöht Oracle die Sequenz und gibt unabhängig von ihrer Reihenfolge innerhalb der Anweisung denselben Wert für CURRVAL und NEXTVAL zurück. <br><br>  Somit entspricht der <b>Maximalwert der Anzahl der Zeilen, d</b> . <b>H. 5</b> . <br></div></div><br><h3>  Wie viele Zeilen enthält das folgende Skript in der Tabelle? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> p(p_from <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_from .. p_to <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / exec p(1, 3); exec p(4, 6); exec p(7, 9);</code> </pre> <br><ul><li>  0 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  9 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Laut Oracle-Dokumentation (zitiert aus 11.2): <br><br>  Vor dem Ausführen einer SQL-Anweisung markiert Oracle einen impliziten Sicherungspunkt (der Ihnen nicht zur Verfügung steht).  Wenn die Anweisung fehlschlägt, setzt Oracle sie automatisch zurück und gibt den entsprechenden Fehlercode an SQLCODE in der SQLCA zurück.  Wenn beispielsweise eine INSERT-Anweisung einen Fehler verursacht, indem versucht wird, einen doppelten Wert in einen eindeutigen Index einzufügen, wird die Anweisung zurückgesetzt. <br><br>  Ein Anruf vom Kunden wird ebenfalls als einzelne Anweisung betrachtet und verarbeitet.  Somit wird der erste Aufruf von HP erfolgreich abgeschlossen, indem drei Datensätze eingefügt werden.  Der zweite Aufruf von HP endet mit einem Fehler und setzt den vierten Datensatz zurück, den ich einfügen konnte.  Der dritte Aufruf schlägt fehl <b>und drei Einträge werden in der Tabelle angezeigt</b> . <br></div></div><br><h3>  Wie viele Zeilen enthält das folgende Skript in der Tabelle? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> i_ch <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>); exception when others then dbms_output.put_line('Oops!'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Laut Oracle-Dokumentation (zitiert aus 11.2): <br><br>  Mit einer Prüfbedingung können Sie eine Bedingung angeben, die jede Zeile in der Tabelle erfüllen muss.  Um die Einschränkung zu erfüllen, muss jede Zeile in der Tabelle die Bedingung entweder WAHR oder unbekannt machen (aufgrund einer Null).  Wenn Oracle eine Prüfbedingung für eine bestimmte Zeile auswertet, beziehen sich alle Spaltennamen in der Bedingung auf die Spaltenwerte in dieser Zeile. <br><br>  Somit besteht der Nullwert den Test und der anonyme Block wird erfolgreich ausgeführt, bis versucht wird, den Wert 3 einzufügen. Danach löst der Fehlerbehandlungsblock eine Ausnahme aus, es erfolgt kein Rollback, und <b>die Tabelle enthält vier Zeilen</b> mit den Werten 1, null, 2 und null. <br></div></div><br><h3>  Welche Wertepaare belegen den gleichen Platz im Block? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), i <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), j <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">14</span></span>), k <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>), x varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), y varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), z varchar2(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (a, b, i, j, x, y) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br><ul><li>  A und X. </li><li>  B und Y. </li><li>  C und K. </li><li>  C und Z. </li><li>  K und Z. </li><li>  Ich und J. </li><li>  J und X. </li><li>  Alle aufgelistet </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Hier finden Sie Auszüge aus der Dokumentation (12.1.0.2) zum Speichern verschiedener Datentypen in Oracle. <br><br>  <b>Char Datentyp</b> <br>  Der Datentyp CHAR gibt eine Zeichenfolge fester Länge im Datenbankzeichensatz an.  Sie geben den Datenbankzeichensatz an, wenn Sie Ihre Datenbank erstellen.  Oracle stellt sicher, dass alle in einer CHAR-Spalte gespeicherten Werte die Länge haben, die in der ausgewählten Längensemantik durch die Größe angegeben ist.  Wenn Sie einen Wert einfügen, der kürzer als die Spaltenlänge ist, füllt Oracle den Wert mit der Spaltenlänge auf. <br><br>  <b>Datentyp VARCHAR2</b> <br>  Der Datentyp VARCHAR2 gibt eine Zeichenfolge variabler Länge im Datenbankzeichensatz an.  Sie geben den Datenbankzeichensatz an, wenn Sie Ihre Datenbank erstellen.  Oracle speichert einen Zeichenwert in einer VARCHAR2-Spalte genau so, wie Sie ihn angegeben haben, ohne Leerzeichen, sofern der Wert die Länge der Spalte nicht überschreitet. <br><br>  <b>NUMBER Datentyp</b> <br>  Der Datentyp NUMBER speichert null sowie positive und negative feste Zahlen mit absoluten Werten von 1,0 x 10-130 bis 1,0 x 10126. Wenn Sie einen arithmetischen Ausdruck angeben, dessen Wert einen absoluten Wert größer oder gleich 1,0 x hat 10126, dann gibt Oracle einen Fehler zurück.  Jeder NUMBER-Wert benötigt 1 bis 22 Bytes.  Unter Berücksichtigung dessen kann die Spaltengröße in Bytes für einen bestimmten numerischen Datenwert NUMBER (p), wobei p die Genauigkeit eines gegebenen Werts ist, unter Verwendung der folgenden Formel berechnet werden: <i>ROUND ((Länge (p) + s) / 2)) + 1</i> wobei s gleich Null ist, wenn die Zahl positiv ist, und s gleich 1 ist, wenn die Zahl negativ ist. <br><br>  Außerdem nehmen wir einen Auszug aus der Dokumentation zum Speichern von Nullwerten. <br><br>  Eine Null ist das Fehlen eines Wertes in einer Spalte.  Nullen zeigen fehlende, unbekannte oder nicht anwendbare Daten an.  Nullen werden in der Datenbank gespeichert, wenn sie zwischen Spalten mit Datenwerten liegen.  In diesen Fällen benötigen sie 1 Byte, um die Länge der Spalte (Null) zu speichern.  Nachgestellte Nullen in einer Zeile erfordern keinen Speicherplatz, da ein neuer Zeilenkopf signalisiert, dass die verbleibenden Spalten in der vorherigen Zeile null sind.  Wenn beispielsweise die letzten drei Spalten einer Tabelle null sind, werden für diese Spalten keine Daten gespeichert. <br><br>  Basierend auf diesen Daten bauen wir Argumente auf.  Wir glauben, dass die Datenbank die Codierung AL32UTF8 verwendet.  In dieser Codierung belegen russische Buchstaben 2 Bytes. <br><br>  1) A und X, der Wert des Feldes a 'Y' ist 1 Byte, der Wert des Feldes x 'D' ist 2 Bytes <br>  2) B und Y, 'Vasya' im b-Wert wird durch Leerzeichen mit bis zu 10 Zeichen ergänzt und belegt 14 Bytes, 'Vasya' in d - benötigt 8 Bytes. <br>  3) C und K. Beide Felder sind NULL, danach gibt es signifikante Felder, sodass sie 1 Byte belegen. <br>  4) C und Z. Beide Felder sind NULL, aber das Z-Feld ist das letzte in der Tabelle, sodass es keinen Speicherplatz belegt (0 Byte).  Feld C nimmt 1 Byte ein. <br>  5) K und Z. Ähnlich wie im vorherigen Fall.  Der Wert im K-Feld beträgt 1 Byte in Z - 0. <br>  6) I und J. Gemäß der Dokumentation benötigen beide Werte jeweils 2 Byte.  Wir betrachten die Länge gemäß der Formel aus der Dokumentation: rund ((1 + 0) / 2) +1 = 1 + 1 = 2. <br>  7) J und X. Der Wert im Feld J benötigt 2 Bytes, der Wert im Feld X 2 Bytes. <br><br>  <b>Insgesamt sind die richtigen Optionen: C und K, I und J, J und X.</b> <br></div></div><br><br><h3>  Wie hoch wird der Clustering-Faktor des T_I-Index ungefähr sein? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t (i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(i);</code> </pre><br><ul><li>  Über Dutzende </li><li>  Über Hunderte </li><li>  In der Größenordnung von Tausenden </li><li>  In der Größenordnung von Zehntausenden </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Laut Oracle-Dokumentation (zitiert aus 12.1): <br><br>  Bei einem B-Tree-Index misst der Index-Clustering-Faktor die physische Gruppierung von Zeilen in Bezug auf einen Indexwert. <br><br>  Der Index-Clustering-Faktor hilft dem Optimierer bei der Entscheidung, ob ein Index-Scan oder ein vollständiger Tabellenscan für bestimmte Abfragen effizienter ist.  Ein niedriger Clustering-Faktor zeigt einen effizienten Index-Scan an. <br><br>  Ein Clustering-Faktor, der nahe an der Anzahl der Blöcke in einer Tabelle liegt, gibt an, dass die Zeilen in den Tabellenblöcken durch den Indexschlüssel physisch geordnet sind.  Wenn die Datenbank einen vollständigen Tabellenscan durchführt, ruft die Datenbank die Zeilen ab, wenn sie auf der Festplatte gespeichert sind, sortiert nach dem Indexschlüssel.  Ein Clustering-Faktor, der nahe an der Anzahl der Zeilen liegt, zeigt an, dass die Zeilen in Bezug auf den Indexschlüssel zufällig über die Datenbankblöcke verteilt sind.  Wenn die Datenbank einen vollständigen Tabellenscan durchführt, ruft die Datenbank keine Zeilen in einer nach diesem Indexschlüssel sortierten Reihenfolge ab. <br><br>  In diesem Fall sind die Daten ideal sortiert, sodass der Clustering-Faktor gleich oder nahe an der Anzahl der belegten Blöcke in der Tabelle liegt.  Bei einer Standardblockgröße von 8 Kilobyte können Sie erwarten, dass ungefähr tausend enge Zahlenwerte in einen Block passen, sodass die Anzahl der Blöcke und damit der Clustering-Faktor in der <b>Größenordnung von zehn liegt</b> . <br></div></div><br><h3>  Bei welchen Werten von N wird das folgende Skript erfolgreich in einer regulären Datenbank mit Standardeinstellungen ausgeführt? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), d varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t (a, b, c, d);</code> </pre><br><ul><li>  100 </li><li>  200 </li><li>  400 </li><li>  800 </li><li>  1600 </li><li>  3200 </li><li>  6400 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Laut Oracle-Dokumentation (zitiert aus 11.2): <br><br>  Logische Datenbankgrenzen <br><br><div class="scrollable-table"><table><thead><tr><td>  <strong>Artikel</strong> </td><td>  <strong>Art der Begrenzung</strong> </td><td>  <strong>Grenzwert</strong> </td></tr></thead><tbody><tr><td>  Indizes </td><td>  Gesamtgröße der indizierten Spalte </td><td>  75% der Datenbankblockgröße abzüglich eines gewissen Overheads </td></tr></tbody></table></div><br>  Daher sollte die Gesamtgröße der indizierten Spalten 6 KB nicht überschreiten.  Ferner hängt es von der ausgewählten Codierungsbasis ab.  Bei der AL32UTF8-Codierung kann ein Zeichen maximal 4 Byte belegen. Im schlimmsten Fall passen 6 Kilobyte auf etwa 1.500 Zeichen.  Daher verbietet Oracle die Erstellung eines Index bei N = 400 (wenn die Schlüssellänge im schlimmsten Fall 1600 Zeichen * 4 Byte + Zeilen-ID-Länge beträgt), während die Erstellung des Index <b>bei N = 200 (oder weniger)</b> problemlos funktioniert. <br></div></div><br><h3>  Die INSERT-Anweisung mit dem APPEND-Hinweis dient zum Laden von Daten im direkten Modus.  Was passiert, wenn es auf die Tabelle angewendet wird, an der der Trigger hängt? </h3><br><ul><li>  Die Daten werden im Direktmodus geladen, der Trigger funktioniert wie es sollte </li><li>  Daten werden im direkten Modus geladen, aber der Trigger wird nicht ausgeführt </li><li>  Die Daten werden im herkömmlichen Modus geladen, der Trigger funktioniert wie gewünscht </li><li>  Daten werden im herkömmlichen Modus geladen, aber der Trigger wird nicht ausgeführt </li><li>  Daten werden nicht hochgeladen, Fehler behoben </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Im Prinzip ist dies eher eine Frage der Logik.  Um die richtige Antwort zu finden, würde ich das folgende Argumentationsmodell vorschlagen: <br><br><ol><li>  Das Einfügen im Direktmodus erfolgt durch direkte Bildung eines Datenblocks hinter der SQL-Engine, wodurch eine hohe Geschwindigkeit sichergestellt wird.  Daher ist es sehr schwierig, die Ausführung des Triggers sicherzustellen, wenn dies überhaupt möglich ist, und dies macht keinen Sinn, da dies das Einfügen ohnehin dramatisch verlangsamt. </li><li>  Wenn nicht ausgelöst wird, hängt der Status der gesamten Datenbank (anderer Tabellen) bei gleichen Daten in der Tabelle davon ab, in welchen Modus die Daten eingefügt werden.  Dies wird offensichtlich die Datenintegrität zerstören und kann nicht als Lösung in der Produktion angewendet werden. </li><li>  Die Unfähigkeit, die angeforderte Operation auszuführen, wird im Allgemeinen als Fehler behandelt.  Hierbei ist jedoch zu beachten, dass APPEND ein Hinweis ist und die allgemeine Logik von Hinweisen darin besteht, dass sie nach Möglichkeit berücksichtigt werden. Andernfalls wird der Operator ohne Berücksichtigung des Hinweises ausgeführt. </li></ol><br>  Die erwartete Antwort lautet daher, dass die <b>Daten im normalen (SQL) Modus geladen werden und der Trigger ausgelöst wird.</b> <br><br>  Laut Oracle-Dokumentation (zitiert ab 8.04): <br><br>  Verstöße gegen die Einschränkungen führen dazu, dass die Anweisung unter Verwendung des herkömmlichen Einfügepfads ohne Warnungen oder Fehlermeldungen seriell ausgeführt wird.  Eine Ausnahme ist die Einschränkung, dass Anweisungen in einer Transaktion mehrmals auf dieselbe Tabelle zugreifen, was zu Fehlermeldungen führen kann. <br>  Wenn beispielsweise Trigger oder referenzielle Integrität in der Tabelle vorhanden sind, wird der APPEND-Hinweis ignoriert, wenn Sie versuchen, INSERT (seriell oder parallel) direkt zu laden, sowie gegebenenfalls den PARALLEL-Hinweis oder die PARALLEL-Klausel. </div></div><br><h3>  Was passiert beim Ausführen des folgenden Skripts? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, j <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> t_a_i <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (:new.i + <span class="hljs-number"><span class="hljs-number">1</span></span>, :new.i); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><ul><li>  Erfolgreiche Ausführung </li><li>  Syntaxfehler fehlgeschlagen </li><li>  Ungültiger Offline-Transaktionsfehler </li><li>  Fehler im Zusammenhang mit dem Überschreiten der maximalen Anrufverschachtelung </li><li>  Fehler bei der Verletzung von Fremdschlüsseln </li><li>  Sperrfehler </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Die Tabelle und der Trigger werden korrekt erstellt und dieser Vorgang sollte nicht zu Problemen führen.  Autonome Transaktionen im Trigger sind ebenfalls zulässig, andernfalls wäre beispielsweise eine Protokollierung nicht möglich. <br><br>  Nach dem Einfügen der ersten Zeile würde die erfolgreiche Operation des Triggers zum Einfügen der zweiten Zeile führen, in Verbindung mit der der Trigger wieder funktionieren würde, die dritte Zeile einfügen usw., bis die Anweisung aufgrund des Überschreitens der maximalen Verschachtelung von Aufrufen abfällt.  Ein weiterer subtiler Punkt wird jedoch ausgelöst.  Zum Zeitpunkt der Ausführung des Triggers wird das Commit für den ersten eingefügten Datensatz noch nicht ausgeführt.  Daher versucht ein Trigger, der in einer autonomen Transaktion arbeitet, eine Zeile in die Tabelle einzufügen, die durch einen Fremdschlüssel auf einen Datensatz verweist, der noch nicht festgeschrieben wurde.  Dies führt zu einer Wartezeit (eine autonome Transaktion wartet darauf, dass das Haupt-Commit versteht, ob Daten eingefügt werden können), und gleichzeitig wartet die Haupttransaktion darauf, dass das autonome Commit nach dem Trigger weiter funktioniert.  <b>Ein Deadlock tritt auf und infolgedessen wird eine autonome Transaktion aus dem mit Sperren verbundenen Grund zurückgeschickt</b> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459680/">https://habr.com/ru/post/de459680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459662/index.html">PVS-Studio wollte, konnte aber keine Fehler in robots.txt finden</a></li>
<li><a href="../de459668/index.html">Erkennen von Text auf einem Foto: Neue Funktionen des Vision-Frameworks</a></li>
<li><a href="../de459670/index.html">Gehe nach Amsterdam</a></li>
<li><a href="../de459672/index.html">Unterstreichen Sie in Python</a></li>
<li><a href="../de459674/index.html">Threat Intelligence Epic Saga</a></li>
<li><a href="../de459682/index.html">Datenqualität im Speicher</a></li>
<li><a href="../de459684/index.html">Karte der Moskauer U-Bahn und der ganzen Welt für Android</a></li>
<li><a href="../de459688/index.html">Urbanismus in China: Weniger Hipster, mehr Wissenschaft und IT</a></li>
<li><a href="../de459692/index.html">Wie wir Materialmodifikationen entdeckten, die etablierten chemischen Prinzipien widersprechen</a></li>
<li><a href="../de459694/index.html">Museum DataArt. Packen Sie Radio 86RK aus und starten Sie es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>