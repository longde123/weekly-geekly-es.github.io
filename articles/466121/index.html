<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèΩ üë©üèø‚Äçü§ù‚Äçüë©üèæ ü•´ Generaci√≥n de sonido en microcontroladores AVR por el m√©todo de tablas de ondas con soporte de polifon√≠a. üßëüèø‚Äçü§ù‚Äçüßëüèø üßñüèΩ üë©üèæ‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los microcontroladores AVR son bastante baratos y generalizados. Probablemente, casi cualquier desarrollador incrustado comienza con ellos. Y entre lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generaci√≥n de sonido en microcontroladores AVR por el m√©todo de tablas de ondas con soporte de polifon√≠a.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/">  Los microcontroladores AVR son bastante baratos y generalizados.  Probablemente, casi cualquier desarrollador incrustado comienza con ellos.  Y entre los aficionados, el Arduino gobierna la pelota, cuyo coraz√≥n suele ser el ATmega328p.  Seguramente muchos se preguntaron: ¬øc√≥mo puedes hacerlos sonar? <br><br>  Si observa los proyectos existentes, son de varios tipos: <br><br><ol><li>  Generadores de pulso cuadrado.  Genere usando PWM o pines de tir√≥n en interrupciones.  En cualquier caso, se obtiene un sonido chirriante muy caracter√≠stico. </li><li>  Uso de equipos externos como un decodificador de MP3. </li><li>  Uso de PWM para emitir sonido de 8 bits (a veces 16 bits) en formato PCM o ADPCM.  Como la memoria en los microcontroladores claramente no es suficiente para esto, generalmente usan una tarjeta SD. </li><li>  Usando PWM para generar sonido basado en tablas de ondas como MIDI. </li></ol><br>  El √∫ltimo tipo fue especialmente interesante para m√≠, porque  Casi no requiere equipo adicional.  Presento mi opci√≥n a la comunidad.  Primero, una peque√±a demostraci√≥n: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Interesado, pido gato. <br><a name="habracut"></a><br>  Entonces, el equipo: <br><br><ul><li>  ATmega8 o ATmega328.  Portar a otros ATmega no es dif√≠cil.  E incluso en ATtiny, pero m√°s sobre eso m√°s tarde; </li><li>  Resistencia; </li><li>  Condensador; </li><li>  Altavoz o auriculares; </li><li>  Nutrici√≥n; </li></ul><br>  Como todo <br><br>  Un circuito RC simple con un altavoz est√° conectado a la salida del microcontrolador.  La salida es un sonido de 8 bits con una frecuencia de muestreo de 31250Hz.  A una frecuencia de cristal de 8 MHz, se pueden generar hasta 5 canales de sonido + un canal de ruido para percusi√≥n.  En este caso, se usa casi todo el tiempo del procesador, pero despu√©s de llenar el b√∫fer, el procesador puede ocuparse con algo √∫til adem√°s del sonido: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este ejemplo encaja completamente en la memoria ATmega8, se procesan 5 canales + ruido a una frecuencia de cristal de 8 MHz y hay poco tiempo para la animaci√≥n en la pantalla. <br><br>  En este ejemplo, tambi√©n quer√≠a mostrar que la biblioteca se puede usar no solo como una postal musical normal, sino tambi√©n para conectar el sonido a proyectos existentes, por ejemplo, para notificaciones.  E incluso cuando se usa solo un canal de sonido, las notificaciones pueden ser mucho m√°s interesantes que un simple tweeter. <br><br>  Y ahora los detalles ... <br><br><h2>  Tablas de olas o tablas de olas </h2><br>  La matem√°tica es extremadamente simple.  Hay una funci√≥n de tono peri√≥dica, por ejemplo, <i>tono (t) = sin (t * freq / (2 * Pi))</i> . <br><br>  Tambi√©n hay una funci√≥n para cambiar el volumen del tono fundamental a lo largo del tiempo, por ejemplo, <i>volumen (t) = e ^ (- t)</i> . <br><br>  En el caso m√°s simple, el sonido de un instrumento es el producto de estas funciones <i>instrumento (t) = tono (t) * volumen (t)</i> : <br><br>  En el gr√°fico, todo se ve as√≠: <br><br><img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br><br>  A continuaci√≥n, tomamos todos los instrumentos que suenan en un momento dado y los resumimos con algunos factores de volumen (pseudoc√≥digo): <br><br><pre><code class="cmake hljs">for (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CHANNELS; i++) { value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume; }</code> </pre> <br>  Solo es necesario seleccionar el volumen para que no haya desbordamiento.  Y eso es casi todo. <br><br>  El canal de ruido funciona de la misma manera, pero en lugar de una funci√≥n de tono, un generador de secuencia pseudoaleatoria. <br><br>  La percusi√≥n es una mezcla de canal de ruido y onda de baja frecuencia, a aproximadamente 50-70 Hz. <br>  Por supuesto, el sonido de alta calidad de esta manera es dif√≠cil de lograr.  Pero solo tenemos 8 kilobytes para todo.  Espero que esto pueda ser perdonado. <br><br><h2>  ¬øQu√© puedo sacar de 8 bits? </h2><br>  Inicialmente, me concentr√© en ATmega8.  Sin cuarzo externo, funciona a una frecuencia de 8 MHz y tiene un PWM de 8 bits, que proporciona una frecuencia de muestreo base de 8000000/256 = 31250 Hz.  Un temporizador usa PWM para emitir sonido, y provoca una interrupci√≥n durante el desbordamiento para transmitir el siguiente valor al generador PWM.  En consecuencia, tenemos 256 ciclos para calcular el valor de la muestra para todo, incluida la sobrecarga de interrupci√≥n, la actualizaci√≥n de los par√°metros del canal de sonido, el seguimiento del tiempo en que necesita tocar la siguiente nota, etc. <br><br>  Para la optimizaci√≥n, utilizaremos activamente los siguientes trucos: <br><br><ul><li>  Como tenemos un procesador de ocho bits, intentaremos que las variables sean las mismas.  A veces usaremos 16 bits. </li><li>  Los c√°lculos se dividen condicionalmente en frecuentes y no tan frecuentes.  Los primeros deben calcularse para cada muestra, el segundo, con mucha menos frecuencia, una vez cada varias decenas / cientos de muestras. </li><li>  Para distribuir uniformemente la carga a lo largo del tiempo, utilizamos un b√∫fer circular.  En el bucle principal del programa, llenamos el b√∫fer, lo restamos en la interrupci√≥n.  Si todo est√° bien, entonces el b√∫fer se llena m√°s r√°pido de lo que se vac√≠a y tenemos tiempo para otra cosa. </li><li>  El c√≥digo est√° escrito en C con mucha l√≠nea.  La pr√°ctica muestra que es mucho m√°s r√°pido. </li><li>  Todo lo que el preprocesador puede calcular, especialmente con la participaci√≥n de la divisi√≥n, lo hace el preprocesador. </li></ul><br>  Primero, divida el tiempo en intervalos de 4 milisegundos (los llam√© ticks).  A una frecuencia de muestreo de 31250Hz, obtenemos 125 muestras por tic.  El hecho de que cada muestra debe leerse debe contarse en cada muestra y el resto, una vez por marca o menos.  Por ejemplo, dentro de un tic, el volumen del instrumento ser√° constante: <i>instrumento (t) = tono (t) * volumen actual</i> ;  y el Volumen actual se volver√° a calcular una vez por marca teniendo en cuenta el volumen (t) y el volumen seleccionado del canal de sonido. <br><br>  Se eligi√≥ una duraci√≥n de tics de 4 ms en funci√≥n de un l√≠mite simple de 8 bits: con un contador de muestras de ocho bits, puede trabajar con una frecuencia de muestreo de hasta 64 kHz, con un contador de tics de ocho bits podemos medir el tiempo hasta 1 segundo. <br><br><h2>  Un poco de c√≥digo </h2><br>  El canal en s√≠ se describe mediante esta estructura: <br><br><pre> <code class="cmake hljs">typedef struct { // Info about wave const int8_t* waveForm; // Wave table array uint16_t waveSample; // High byte is an index in waveForm array uint16_t waveStep; // Frequency, how waveSample is changed in time // Info about volume envelope const uint8_t* volumeForm; // Array of volume change in time uint8_t volumeFormLength; // Length of volumeForm uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample // Info about volume uint8_t currentVolume; // Precalculated volume for current tick uint8_t instrumentVolume; // Volume of channel } waveChannel;</code> </pre> <br>  Condicionalmente, los datos aqu√≠ se dividen en 3 partes: <br><br><ol><li>  Informaci√≥n sobre la forma de onda, fase, frecuencia. <br><br>  waveForm: informaci√≥n sobre la funci√≥n tone (t): una referencia a una matriz de 256 bytes de longitud.  Establece el tono, el sonido del instrumento. <br><br>  waveSample: el byte alto indica el √≠ndice actual de la matriz waveForm. <br><br>  waveStep: establece la frecuencia con la que se incrementar√° waveSample al contar la siguiente muestra. <br><br>  Cada muestra se considera algo as√≠: <br><br><pre> <code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>]; channelData.waveSample += channelaData.waveStep; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tone * channelData.currentVolume;</code> </pre> <br></li><li>  Informaci√≥n de volumen.  Establece la funci√≥n de cambiar el volumen a lo largo del tiempo.  Dado que el volumen no cambia con tanta frecuencia, puede contarlo con menos frecuencia, una vez por marca.  Esto se hace as√≠: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample; channel-&gt;volumeFormLength--; channel-&gt;volumeForm++; } channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br></li><li>  Establece el volumen del canal y el volumen actual calculado. <br></li></ol><br>  Tenga en cuenta: la forma de onda es de ocho bits, el volumen tambi√©n es de ocho bits y el resultado es de 16 bits.  Con una ligera p√©rdida de rendimiento, puede hacer que el sonido (casi) sea de 16 bits. <br><br>  En la lucha por la productividad, tuve que recurrir a algo de magia negra. <br><br>  Ejemplo n√∫mero 1. C√≥mo volver a calcular el volumen de canales: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tickSampleCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //    tickSampleCounter = SAMPLES_PER_TICK ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; //   - } // volume recalculation should no be done so often for all channels <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickSampleCounter &lt; CHANNELS_SIZE) { recalculateVolume(channels[tickSampleCounter]); }</code> </pre> <br>  Por lo tanto, todos los canales cuentan el volumen una vez por marca, pero no simult√°neamente. <br><br>  Ejemplo n√∫mero 2. Mantener la informaci√≥n del canal en una estructura est√°tica es m√°s barata que en una matriz.  Sin entrar en detalles sobre la implementaci√≥n de wavechannel.h, dir√© que este archivo se inserta en el c√≥digo varias veces (igual al n√∫mero de canales) con diferentes directivas de preprocesador.  Cada inserci√≥n crea nuevas variables globales y una nueva funci√≥n de c√°lculo de canal, que luego est√° en l√≠nea en el c√≥digo principal: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1 val += channel0NextSample(); #endif #if CHANNELS_SIZE &gt;= 2 val += channel1NextSample(); #endif ‚Ä¶</span></span></code> </pre><br>  Ejemplo n√∫mero 3. Si comenzamos a tocar la siguiente nota un poco m√°s tarde, nadie se dar√° cuenta.  Imaginemos la situaci√≥n: tomamos el procesador con algo y durante este tiempo el b√∫fer estaba casi vac√≠o.  Luego comenzamos a llenarlo y de repente resulta que viene una nueva medida: necesitamos actualizar las notas actuales, leer de la matriz lo que sigue, etc.  Si no tenemos tiempo, habr√° un tartamudeo caracter√≠stico.  Es mucho mejor llenar un poco el b√∫fer con datos antiguos y solo luego actualizar el estado de los canales. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((samplesToWrite) &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { //          fillBuffer(SAMPLES_PER_TICK); //     -  updateMusicData(); //    }</code> </pre> <br>  En el buen sentido, ser√≠a necesario rellenar el b√∫fer despu√©s del ciclo, pero como tenemos casi todo en l√≠nea, el tama√±o del c√≥digo est√° notablemente inflado. <br><br><h2>  Musica </h2><br>  Se utiliza un contador de ticks de ocho bits.  Cuando se alcanza el cero, comienza una nueva medida, al contador se le asigna la duraci√≥n de la medida (en ticks), un poco m√°s tarde se verifica la matriz de comandos musicales. <br><br>  Los datos de m√∫sica se almacenan en una matriz de bytes.  Est√° escrito algo como esto: <br><br><pre> <code class="cmake hljs">const uint8_t demoSample[] PROGMEM = { DATA_TEMPO(<span class="hljs-number"><span class="hljs-number">160</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> beats per minute DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_PLAY(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOTE_A4, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A4 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_PLAY(<span class="hljs-number"><span class="hljs-number">1</span></span>, NOTE_A3, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_WAIT(<span class="hljs-number"><span class="hljs-number">63</span></span>), // Wait <span class="hljs-number"><span class="hljs-number">63</span></span> beats DATA_END() // End of data stream };</code> </pre> <br>  Todo lo que comienza con DATA_ son macros de preprocesador que expanden los par√°metros al n√∫mero requerido de bytes de datos. <br><br>  Por ejemplo, el comando DATA_PLAY se expande en 2 bytes en los que se almacenan: el marcador de comando (1 bit), la pausa antes del siguiente comando (3 bits), el n√∫mero de canal en el que tocar la nota (4 bits), informaci√≥n sobre la nota (8 bits).  La limitaci√≥n m√°s importante es que este comando no se puede usar para pausas largas, con un m√°ximo de 7 medidas.  Si necesita m√°s, entonces necesita usar el comando DATA_WAIT (hasta 63 medidas).  Desafortunadamente, no encontr√© si la macro se puede expandir a un n√∫mero diferente de bytes de la matriz dependiendo del par√°metro de macro.  E incluso advirtiendo que no s√© c√≥mo mostrar.  Quiz√°s t√∫ me lo digas. <br><br><h2>  Uso </h2><br>  En el directorio de demos hay varios ejemplos para diferentes microcontroladores.  Pero en resumen, aqu√≠ hay una pieza del archivo L√©ame, realmente no tengo nada que agregar: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h" #include "../../microsound/micromusic.h" // Make some settings #define CHANNELS_SIZE 5 #define SAMPLES_SIZE 16 #define USE_NOISE_CHANNEL initMusic(); // Init music data and sound control sei(); // Enable interrupts, silence sound should be generated setSample(0, instrument1); // Use instrument1 as sample 0 setSample(1, instrument2); // Init all other instruments‚Ä¶ playMusic(mySong); // Start playing music at pointer mySong while (!isMusicStopped) { fillMusicBuffer(); // Fill music buffer in loop // Do some other stuff }</span></span></code> </pre> <br>  Si desea hacer otra cosa adem√°s de m√∫sica, puede aumentar el tama√±o del b√∫fer utilizando BUFFER_SIZE.  El tama√±o del b√∫fer debe ser 2 ^ n, pero, desafortunadamente, con un tama√±o de 256, se produce una degradaci√≥n del rendimiento.  Hasta que lo descubr√≠. <br><br>  Para aumentar la productividad, puede aumentar la frecuencia con cuarzo externo, puede reducir el n√∫mero de canales, puede reducir la frecuencia de muestreo.  Con el √∫ltimo truco, puede utilizar la interpolaci√≥n lineal, que compensa algo la ca√≠da de la calidad del sonido. <br><br>  No se recomienda ning√∫n retraso, porque  Se pierde tiempo de CPU.  En cambio, su propio m√©todo se implementa en el <i>archivo microsound / delay.h</i> , que, adem√°s de la pausa, est√° involucrado en llenar el b√∫fer.  Este m√©todo puede no funcionar con mucha precisi√≥n en pausas cortas, pero en pausas largas m√°s o menos sanas. <br><br><h2>  Haciendo tu propia m√∫sica </h2><br>  Si escribe comandos manualmente, debe poder escuchar lo que sucede.  Verter cada cambio en el microcontrolador no es conveniente, especialmente si hay una alternativa. <br><br>  Hay un servicio bastante divertido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wavepot.com</a> : un editor de JavaScript en l√≠nea en el que debe configurar la funci√≥n de la se√±al de sonido de vez en cuando, y esta se√±al se env√≠a a la tarjeta de sonido.  El ejemplo m√°s simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dsp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * t * <span class="hljs-number"><span class="hljs-number">440</span></span>); }</code> </pre> <br>  Port√© el motor a JavaScript, se encuentra en <i>demos / wavepot.js</i> .  El contenido del archivo debe insertarse en el editor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wavepot.com</a> y puede realizar experimentos.  Escribimos nuestros datos en la matriz soundData, escucha, no te olvides de guardar. <br><br>  Tambi√©n debemos mencionar la variable simulate8bits.  Ella, seg√∫n el nombre, simula un sonido de ocho bits.  Si de repente parece que la bater√≠a est√° zumbando y aparece ruido en instrumentos amortiguados con un sonido silencioso, entonces esto es todo, una distorsi√≥n de un sonido de ocho bits.  Puede intentar deshabilitar esta opci√≥n y escuchar la diferencia.  El problema es mucho menos notable si no hay silencio en la m√∫sica. <br><br><h2>  Conexi√≥n </h2><br>  En una versi√≥n simple, el circuito se ve as√≠: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VC | R1 | Pin+---/\/\--+-----&gt; OUT | | | +---+GN | === C1 | +-------+ | | | --- Grnd --- Grnd</code> </pre> <br>  El pin de salida depende del microcontrolador.  La resistencia R1 y el condensador C1 deben seleccionarse en funci√≥n de la carga, el amplificador (si corresponde), etc.  No soy ingeniero electr√≥nico y no dar√© f√≥rmulas; son f√°ciles de buscar en Google junto con las calculadoras en l√≠nea. <br><br>  Tengo R1 = 130 ohmios, C1 = 0.33 uF.  A la salida conecto auriculares chinos comunes. <br><br><h2>  ¬øQu√© hab√≠a sobre el sonido de 16 bits? </h2><br>  Como dije anteriormente, cuando multiplicamos dos n√∫meros de ocho bits (frecuencia y volumen), obtenemos un n√∫mero de 16 bits.  No puede redondearlo a ocho bits, pero genera ambos bytes en 2 canales PWM.  Si mezcla estos 2 canales en la relaci√≥n 1/256, entonces podemos obtener un sonido de 16 bits.  La diferencia con los ocho bits es especialmente f√°cil de escuchar en sonidos y tambores que se desvanecen suavemente en momentos en que solo suena un instrumento. <br><br>  Conexi√≥n de salida de 16 bits: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VCC | R1 | PinH+---/\/\--+-----&gt; OUT | | | | | R2 | | PinL+---/\/\--+ +---+GND | | | +-------+ === C1 | | --- Grnd --- Grnd</code> </pre> <br>  Es importante mezclar las 2 salidas correctamente: la resistencia R2 debe ser 256 veces mayor que la resistencia R1.  Cuanto m√°s preciso, mejor.  Desafortunadamente, incluso las resistencias con un error del 1% no dan la precisi√≥n requerida.  Sin embargo, incluso con una selecci√≥n no muy precisa de resistencias, la distorsi√≥n puede atenuarse notablemente. <br><br>  Desafortunadamente, cuando se usa sonido de 16 bits, el rendimiento se degrada y 5 canales + ruido ya no tienen tiempo para procesarse en los 256 ciclos de reloj asignados. <br><br><h2>  ¬øEs posible en Arduino? </h2><br>  Si puedes.  Solo tengo un nano clon chino en ATmega328p, funciona en √©l.  Lo m√°s probable es que otros arduins en el ATmega328p tambi√©n funcionen.  El ATmega168 parece tener los mismos registros de control del temporizador.  Lo m√°s probable es que funcionen sin cambios.  En otros microcontroladores que necesita verificar, es posible que deba agregar un controlador. <br><br>  Hay un boceto en <i>demos / arduino328p</i> , pero para que se abra normalmente en el IDE de Arduino, debe copiarlo en la ra√≠z del proyecto. <br><br>  En el ejemplo, se genera sonido de 16 bits y se utilizan las salidas D9 y D10.  Para simplificar, puede limitarse al sonido de 8 bits y usar solo una salida D9. <br><br>  Como casi todas las arduins operan a 16 MHz, entonces, si lo desea, puede aumentar el n√∫mero de canales a 8. <br><br><h2>  ¬øQu√© hay de ATtiny? </h2><br>  ATtiny no tiene multiplicaci√≥n de hardware.  La multiplicaci√≥n de software que utiliza el compilador es extremadamente lenta y es mejor evitarla.  Cuando se utilizan insertos de ensamblador optimizados, el rendimiento se reduce 2 veces en comparaci√≥n con ATmega.  Parece que no tiene sentido usar ATtiny, pero ... <br><br>  Algunos ATtiny tienen un multiplicador de frecuencia, PLL.  Y esto significa que en tales microcontroladores hay 2 caracter√≠sticas interesantes: <br><br><ol><li>  La frecuencia del generador PWM es de 64 MHz, lo que da un per√≠odo PWM de 250 kHz, que es mucho mejor que 31250 Hz a 8 MHz o 62500 Hz con cuarzo a 16 MHz en cualquier ATmega. </li><li>  El mismo multiplicador de frecuencia permite que el cristal registre a 16 MHz sin cuarzo. </li></ol><br>  De ah√≠ la conclusi√≥n: algunos ATtiny se pueden usar para generar sonido.  Logran procesar los mismos 5 instrumentos + canal de ruido, pero a 16 MHz y no necesitan cuarzo externo. <br><br>  La desventaja es que la frecuencia ya no se puede aumentar, y los c√°lculos toman casi todo el tiempo.  Para liberar recursos, puede reducir el n√∫mero de canales o la frecuencia de muestreo. <br><br>  Otro inconveniente es la necesidad de usar dos temporizadores a la vez: uno para PWM, el segundo para interrupci√≥n.  Aqu√≠ es donde generalmente terminan los temporizadores. <br><br>  De los microcontroladores PLL que conozco, puedo mencionar ATtiny85 / 45/25 (8 patas), ATtiny861 / 461/261 (20 patas), ATtiny26 (20 patas). <br><br>  En cuanto a la memoria, la diferencia con ATmega no es grande.  En 8kb, varios instrumentos y melod√≠as encajar√°n perfectamente.  En 4kb puedes poner 1-2 instrumentos y 1-2 melod√≠as.  Es dif√≠cil poner algo en 2 kilobytes, pero si realmente quieres, puedes hacerlo.  Es necesario separar los m√©todos, deshabilitar algunas funciones como el control de volumen sobre los canales, reducir la frecuencia de muestreo y la cantidad de canales.  En general, para un aficionado, pero hay un ejemplo de trabajo en ATtiny26. <br><br><h2>  Los problemas </h2><br>  Hay problemas  Y el mayor problema es la velocidad de la inform√°tica.  El c√≥digo est√° completamente escrito en C con peque√±os insertos de multiplicaci√≥n de ensamblador para ATtiny.  La optimizaci√≥n se da al compilador y a veces se comporta de manera extra√±a.  Con peque√±os cambios que no deber√≠an influir en nada, puede obtener una disminuci√≥n notable en el rendimiento.  Adem√°s, cambiar de -Os a -O3 no siempre ayuda.  Un ejemplo de ello es el uso de un b√∫fer de 256 bytes.  Particularmente desagradable es que no hay garant√≠a de que en las nuevas versiones del compilador no obtengamos una ca√≠da en el rendimiento del mismo c√≥digo. <br><br>  Otro problema es que el mecanismo de atenuaci√≥n antes de la siguiente nota no est√° implementado en absoluto.  Es decir  cuando en un canal una nota se reemplaza por otra, el sonido antiguo se interrumpe abruptamente, a veces se escucha un peque√±o clic.  Me gustar√≠a encontrar una manera de deshacerme de esto sin perder rendimiento, pero hasta ahora. <br><br>  No hay comandos para aumentar / disminuir suavemente el volumen.  Es especialmente cr√≠tico para tonos de llamada cortos de notificaci√≥n, donde al final debe hacer una atenuaci√≥n r√°pida del volumen para que no haya una interrupci√≥n brusca en el sonido.  Parte del problema es escribir una serie de comandos con la configuraci√≥n manual del volumen y una breve pausa. <br><br>  El enfoque elegido, en principio, no es capaz de proporcionar un sonido naturalista para los instrumentos.  Para un sonido m√°s natural, debe dividir los sonidos de los instrumentos en ataque-sostenimiento-liberaci√≥n, use al menos las primeras 2 partes y con una duraci√≥n mucho m√°s larga que un per√≠odo de oscilaci√≥n.  Pero entonces los datos para la herramienta necesitar√°n mucho m√°s.  Hubo una idea de usar tablas de onda m√°s cortas, por ejemplo, en 32 bytes en lugar de 256, pero sin interpolaci√≥n, la calidad del sonido disminuye dr√°sticamente, y con la interpolaci√≥n, el rendimiento disminuye.  Y otros 8 bits de muestreo claramente no son suficientes para la m√∫sica, pero esto se puede evitar. <br><br>  El tama√±o del b√∫fer est√° limitado a 256 muestras.  Esto corresponde a aproximadamente 8 milisegundos y este es el per√≠odo de tiempo integral m√°ximo que puede asignarse a otras tareas.  Adem√°s, la ejecuci√≥n de tareas todav√≠a se suspende peri√≥dicamente por interrupciones. <br><br>  Reemplazar el retraso est√°ndar no funciona con mucha precisi√≥n para pausas cortas. <br><br>  Estoy seguro de que esta no es una lista completa. <br><br><h2>  Referencias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√°lculo del filtro PWM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algunas ideas y una melod√≠a de demostraci√≥n tomaron de aqu√≠</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466121/">https://habr.com/ru/post/466121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466105/index.html">Overclocking Magento Rest API con RoadRunner</a></li>
<li><a href="../466107/index.html">Sistema de hogar inteligente h√°galo usted mismo</a></li>
<li><a href="../466109/index.html">Resoluci√≥n de problemas con pwnable.kr 22 - brainfuck. Ataque Ret2libc</a></li>
<li><a href="../466111/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 32. Recuperaci√≥n de contrase√±a, XMODEM / TFTPDNLD y activaci√≥n de licencia de Cisco</a></li>
<li><a href="../466113/index.html">Definici√≥n de codificaci√≥n de texto en PHP en lugar de mb_detect_encoding</a></li>
<li><a href="../466123/index.html">Crecimiento. Peso. Tres vecinos</a></li>
<li><a href="../466127/index.html">Central nuclear de Kola o de pie en el reactor</a></li>
<li><a href="../466129/index.html">Eficiencia del transporte de gasolina, bater√≠as e hidr√≥geno.</a></li>
<li><a href="../466135/index.html">Megapack: c√≥mo los desarrolladores de Factorio lograron resolver el problema con el modo multijugador de 200 jugadores</a></li>
<li><a href="../466137/index.html">System.IO. Pipelines: una herramienta poco conocida para los amantes del alto rendimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>