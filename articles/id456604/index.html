<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☂️ 👩🏽‍🤝‍👨🏿 🙇🏿 Bagaimana kami mengotomatiskan toko online besar dan mulai mencocokkan produk secara otomatis ⏏️ 🎨 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini lebih teknis daripada tentang bisnis, tetapi kami juga akan menarik beberapa kesimpulan dari sudut pandang bisnis. Sebagian besar perhatia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami mengotomatiskan toko online besar dan mulai mencocokkan produk secara otomatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456604/"><img src="https://habrastorage.org/webt/vm/sf/by/vmsfbyuh4sqwgsjidvjpzleydcu.jpeg" alt="gambar"><br><br>  Artikel ini lebih teknis daripada tentang bisnis, tetapi kami juga akan menarik beberapa kesimpulan dari sudut pandang bisnis.  Sebagian besar perhatian akan diberikan pada perbandingan otomatis barang dari berbagai sumber. <br><br>  Pekerjaan toko online terdiri dari sejumlah komponen yang cukup besar.  Dan apa pun rencananya, untuk mendapatkan untung saat ini, atau untuk tumbuh dan mencari investor, atau, misalnya, untuk mengembangkan bidang terkait, setidaknya Anda harus menutup pertanyaan ini: <br><br><ul><li> Bekerja dengan pemasok.  Untuk menjual sesuatu yang tidak perlu, Anda harus terlebih dahulu membeli sesuatu yang tidak perlu. </li><li>  Manajemen Direktori.  Seseorang memiliki spesialisasi yang sempit, sementara seseorang menjual ratusan ribu barang yang berbeda. </li><li>  Manajemen harga eceran.  Di sini Anda harus mempertimbangkan harga pemasok, dan harga pesaing, dan instrumen keuangan yang terjangkau. </li><li>  Bekerja dengan gudang.  Pada prinsipnya, adalah mungkin untuk tidak memiliki gudang sendiri, tetapi untuk mengambil barang dari gudang mitra, tetapi dengan satu atau lain cara pertanyaannya adalah. </li><li>  Pemasaran.  Di sini situs diisi dengan konten, penempatan di situs, iklan (online dan offline), promosi, dan banyak lagi. </li><li>  Penerimaan dan pemrosesan pesanan.  Pusat panggilan, keranjang di situs, pesanan melalui kurir instan, pesanan melalui platform dan pasar. </li><li>  Pengiriman </li><li>  Akuntansi dan sistem internal lainnya. </li></ul><br>  Toko, yang akan kita bicarakan, tidak memiliki spesialisasi yang sempit, tetapi menawarkan banyak hal mulai dari kosmetik hingga traktor mini.  Saya akan memberi tahu Anda bagaimana kami bekerja dengan pemasok, memantau pesaing, manajemen katalog dan harga (grosir dan eceran), bekerja dengan pelanggan grosir.  Sedikit sentuhan pada topik gudang. <br><br>  Untuk lebih memahami beberapa solusi teknis, tidak akan berlebihan untuk mengetahui hal itu <br>  pada titik tertentu kami memutuskan bahwa hal-hal teknologi, jika mungkin, akan dilakukan bukan untuk diri kita sendiri, tetapi universal.  Dan, mungkin, setelah beberapa upaya, akan keluar untuk mengembangkan bisnis baru.  Ternyata, secara kondisional, sebuah startup di dalam perusahaan. <br><br>  Jadi kami mempertimbangkan sistem terpisah, yang kurang lebih bersifat universal, yang dengannya seluruh infrastruktur perusahaan terintegrasi. <br><a name="habracut"></a><br><h2>  Apa masalah bekerja dengan pemasok? </h2><br>  Dan sebenarnya ada banyak dari mereka.  Hanya untuk memberi beberapa: <br><br><ul><li>  Ada banyak pemasok per se.  Kami punya sekitar 400 orang. Setiap orang perlu waktu. </li><li>  Tidak ada cara tunggal untuk mendapatkan penawaran dari pemasok.  Seseorang mengirim surat sesuai jadwal, seseorang atas permintaan, seseorang mengunggah ke hosting, seseorang menempatkan di situs.  Ada banyak cara, hingga mengirim file melalui skype. </li><li>  Tidak ada format data tunggal.  Saya bahkan menggambar gambar tentang subjek ini (lebih rendah, tabel melambangkan format yang berbeda). </li><li>  Ada konsep minimum eceran dan harga grosir minimum yang harus diperhatikan agar dapat terus bekerja dengan pemasok.  Seringkali mereka disediakan dalam format mereka sendiri. </li><li>  Nomenklatur masing-masing pemasok berbeda.  Akibatnya, produk yang sama disebut secara berbeda, dan tidak ada kunci unik yang dengannya mereka dapat dengan mudah dibandingkan.  Karena itu, kami membandingkannya dengan sulit. </li><li>  Sistem penempatan pesanan dengan pemasok tidak otomatis.  Kami memesan dari seseorang di Skype, dari seseorang di akun Anda, ke seseorang yang kami kirim file exel setiap malam dengan daftar pesanan. </li></ul><br><img src="https://habrastorage.org/webt/84/x_/0c/84x_0cekqji4tmiu6j8fw3470ko.png" alt="gambar"><br><br>  Kami telah belajar untuk mengatasi masalah ini.  Selain yang terakhir, bekerja pada yang terakhir sedang berlangsung.  Sekarang akan ada detail teknis, dan kemudian pertimbangkan daftar berikut. <br><br><h2>  Mengumpulkan data </h2><br><h3>  Seperti dulu </h3><br>  File pemasok dikumpulkan secara manual dari berbagai sumber dan disiapkan.  Persiapan termasuk penggantian nama sesuai dengan templat tertentu dan konten pengeditan.  Tergantung pada file, perlu untuk menghapus barang yang tidak standar, barang yang tidak tersedia, mengganti nama kolom atau mengonversi mata uang, mengumpulkan data dari berbagai tab pada satu. <br><br><h3>  Bagaimana bisa? </h3><br>  Pertama-tama, kami belajar memeriksa surat dan mengambil surat dengan lampiran dari sana.  Kemudian mereka mengotomatiskan pekerjaan dengan tautan langsung dan tautan ke drive Yandex dan Google.  Ini menyelesaikan masalah penerimaan penawaran dari sekitar 75% pemasok kami.  Kami juga memperhatikan bahwa melalui saluran inilah penawaran lebih sering diperbarui, sehingga persentase otomatisasi sesungguhnya lebih banyak.  Kami masih mendapatkan beberapa harga dari kurir. <br><br>  Kedua, kami tidak lagi memproses file secara manual.  Untuk melakukan ini, kami telah memasukkan profil pemasok, di mana Anda dapat menentukan kolom dan tab mana yang akan digunakan, cara menentukan mata uang dan ketersediaan, waktu pengiriman, dan jadwal kerja pemasok. <br><br>  Ternyata fleksibel.  Secara alami, kami tidak mempertimbangkan segalanya untuk pertama kalinya, tetapi sekarang ada cukup fleksibilitas untuk mengonfigurasi pemrosesan 400 penyedia, mengingat setiap orang memiliki format file yang berbeda. <br><br>  Adapun format file, kami memahami xls, xlsx, csv, xml (yml).  Dalam kasus kami, ini sudah cukup. <br><br>  Mereka juga menemukan cara untuk memfilter catatan.  Kami membuat daftar kata-kata berhenti, dan jika penawaran pemasok berisi itu, maka kami tidak memprosesnya.  Rincian teknis adalah sebagai berikut: pada daftar kecil Anda dapat dan bahkan lebih baik "langsung", pada daftar besar filter Bloom lebih cepat.  Kami bereksperimen dengannya dan meninggalkan semuanya apa adanya, karena untungnya dirasakan dalam daftar urutan besarnya lebih besar dari kita. <br><br>  Hal penting lainnya adalah jadwal kerja pemasok.  Pemasok kami mengerjakan jadwal yang berbeda, di samping itu, mereka berlokasi di berbagai negara, di mana akhir pekan tidak bersamaan.  Dan waktu pengiriman biasanya ditunjukkan sebagai angka atau kisaran angka dalam hari kerja.  Ketika kita membentuk harga eceran dan grosir, kita harus entah bagaimana mengevaluasi waktu kapan kita dapat mengirimkan barang kepada klien.  Untuk melakukan ini, kami membuat kalender yang dapat dikonfigurasi, dan dalam pengaturan masing-masing penyedia Anda dapat menentukan kalender mana yang berfungsi. <br><br>  Saya harus membuat konfigurasi diskon dan margin tergantung pada kategori dan produsen.  Kebetulan pemasok memiliki file umum untuk semua mitra, tetapi ada perjanjian diskon dengan beberapa mitra.  Berkat ini, masih mungkin untuk menambah atau mengurangi PPN jika perlu. <br><br>  Omong-omong, konfigurasi diskon dan aturan mark-up membawa kita ke topik berikutnya.  Lagi pula, sebelum menggunakannya Anda perlu mencari tahu apa jenis produk itu. <br><br><h2>  Bagaimana pemetaan bekerja </h2><br>  Contoh kecil tentang bagaimana produk yang sama dapat dipanggil dari pemasok yang berbeda, untuk memahami apa yang harus Anda kerjakan: <br><blockquote>  Monitor LG LCD 22MP48D-P <br>  21.5 "LG 22MP48D-P Black (16: 9, 1920x1080, IPS, 60 Hz, DVI + D-Sub (VGA)) <br>  COMP - Peripheral Komputer - Monitor LG 22MP48D-P <br>  hingga 22 "termasuk Monitor LG LG 22MP48D-P (21.5", hitam, IPS LED 5ms 16: 9 DVI matte 250cd 1920x1080 D-Sub FHD) 22MP48D-P <br>  Monitor LG 22 "LG 22MP48D-P Glossy-Black (IPS, LED, 1920x1080, 5 ms, 178 ° / 178 °, 250 cd / m, 100M: 1, + DVI) Monitor <br>  Monitor LCD Monitor LCD LG 22 "IPS 22MP48D-P LG 22MP48D-P <br>  LG Monitor 21.5 "LG 22MP48D-P gl. Hitam IPS, 1920x1080, 5ms, 250 cd / m2, 1000: 1 (Mega DCR), D-Sub, DVI-D (HDCP), vesa 22MP48D-P.ARUZ <br>  LG Monitor LG 22MP48D-P Hitam 22MP48D-P.ARUZ <br>  Monitor LG 22MP48D-P 22MP48D-P <br>  Monitor LG 22MP48D-P Glossy-Hitam 22MP48D-P <br>  Monitor 21.5 "LG Flatron 22MP48D-P gl.Hitam (IPS, 1920x1080, 16: 9, 178/178, 250cd / m2, 1000: 1, 5ms, D-Sub, DVI-D) (22MP48D-P) 22MP48D-P <br>  Monitor 22 "LG 22MP48D-P <br>  LG 22MP48D-P IPS DVI <br>  LG LG 21.5 "22MP48D-P IPS LED, 1920x1080, 5ms, 250cd / m2, 5Mln: 1, 178 ° / 178 °, D-Sub, DVI, Miring, VESA, Hitam Mengkilap 22MP48D-P <br>  LG 21.5 "22MP48D-P (16: 9, IPS, VGA, DVI) 22MP48D-P <br>  Monitor 21,5`` LG 22MP48D-P Black <br>  LG MONITOR 21.5 "LG 22MP48D-P Glossy-Hitam (IPS, LED, 1920x1080, 5 ms, 178 ° / 178 °, 250 cd / m, 100M: 1, + DVI) 22MP48D-P <br>  Monitor LCD LG 21,5 '' [16: 9] 1920x1080 (FHD) IPS, nonGLARE, 250cd / m2, H178 ° / V178 °, 1000: 1, 16,7M Warna, 5ms, VGA, DVI, Tilt, 2Y, Black OK 22MP48D -P <br>  LCD LG 21.5 "22MP48D-P hitam {IPS LED 1920x1080 5ms 16: 9 250cd 178 ° / 178 ° DVI D-Sub} 22MP48D-P.ARUZ <br>  IDS_Monitors LG LG 22 "LCD 22MP48D 22MP48D-P <br>  21.5 "16x9 LG Monitor LG 21.5" 22MP48D-P hitam IPS LED 5ms 16: 9 DVI matte 250cd 1920x1080 D-Sub FHD 2.7kg 22MP48D-P.ARUZ <br>  Monitor 21,5 "LG 22MP48D-P [Hitam]; 5ms; 1920x1080, DVI, IPS </blockquote><h3>  Seperti dulu </h3><br>  Perbandingan melibatkan 1C (modul bayaran pihak ketiga).  Sedangkan untuk kenyamanan / kecepatan / ketepatan, sistem seperti itu memungkinkan untuk memelihara katalog dengan 60 ribu produk yang tersedia di level ini oleh 6 orang.  Artinya, setiap hari, ketinggalan zaman dan menghilang dari penawaran pemasok, sebanyak mungkin barang yang cocok dengan yang baru dibuat.  Sangat kira-kira - 0,5% dari ukuran katalog, mis.  300 produk. <br><br><h3>  Bagaimana itu menjadi: gambaran umum dari pendekatan tersebut </h3><br>  Sedikit lebih tinggi, saya memberi contoh tentang apa yang harus kita cocokkan.  Menjelajahi topik pencocokan, saya sedikit terkejut bahwa ElasticSearch populer untuk tugas pencocokan, menurut pendapat saya, itu memiliki batasan konseptual.  Adapun tumpukan teknologi kami, kami menggunakan MS SQL Server untuk penyimpanan data, tetapi perbandingannya bekerja pada infrastruktur kami sendiri, dan karena ada banyak data dan kami perlu memprosesnya dengan cepat, kami menggunakan struktur data yang dioptimalkan untuk tugas tertentu dan mencoba untuk tidak mengakses disk atau basis data tanpa perlu. dan sistem lambat lainnya. <br><br>  Jelas, masalah perbandingan dapat dipecahkan dengan banyak cara, dan jelas, tidak ada dari mereka yang akan memberikan akurasi absolut.  Oleh karena itu, ide utamanya adalah mencoba menggabungkan metode-metode ini, memberi peringkat berdasarkan akurasi dan kecepatan dan menerapkannya dalam urutan akurasi yang menurun, dengan mempertimbangkan kecepatan akun. <br><br>  Rencana eksekusi untuk setiap algoritme kami (dengan reservasi tentang kasus degenerasi) dapat secara singkat diwakili oleh urutan umum berikut: <br><br>  Tokenisasi  Kami memecah baris sumber menjadi bagian independen yang bermakna.  Ini dapat dilakukan sekali dan selanjutnya digunakan dalam semua algoritma. <br><br>  Normalisasi token.  Dalam cara yang baik, Anda perlu membawa kata-kata bahasa alami ke angka umum dan kemerosotan, dan pengidentifikasi seperti "ABC15MX" (ini adalah Cyrillic, jika itu) harus dikonversi ke bahasa Latin.  Dan membawa semuanya ke register yang sama. <br><br>  Kategorisasi token.  Mencoba memahami arti setiap bagian.  Misalnya, Anda dapat memilih kategori, pabrikan, warna, dan sebagainya. <br><br>  Cari kandidat terbaik untuk sebuah pertandingan. <br><br>  Perkiraan kemungkinan garis asli dan kandidat terbaik menunjukkan produk yang sama. <br><br>  Dua poin pertama adalah umum untuk semua algoritma yang saat ini tersedia, dan kemudian improvisasi dimulai. <br><br>  Tokenisasi  Di sini kami melakukan hal itu, kami memecah garis menjadi beberapa bagian sesuai dengan karakter khusus seperti spasi, garis miring, dan sebagainya.  Set karakter dari waktu ke waktu ternyata signifikan, tetapi kami tidak menggunakan sesuatu yang rumit dalam algoritma itu sendiri. <br><br>  Maka kita perlu menormalkan token.  Konversikan menjadi huruf kecil.  Alih-alih mengarahkan semuanya ke kasus nominatif, kami hanya memotong ujungnya.  Kami juga memiliki kamus kecil, dan kami menerjemahkan token kami ke dalam bahasa Inggris.  Antara lain, terjemahan menyelamatkan kita dari sinonim, serupa artinya kata-kata Rusia diterjemahkan ke dalam bahasa Inggris dengan cara yang sama.  Di mana kami gagal menerjemahkan, kami mengubah karakter Cyrillic seperti ejaan ke alfabet Latin.  (Ternyata sama sekali tidak berlebihan, ternyata. Bahkan di mana Anda tidak mengharapkan trik kotor, misalnya, di baris "Samsung UE43NU7100U" Cyrillic E mungkin terjadi). <br><br><img src="https://habrastorage.org/webt/j2/wv/2s/j2wv2spiz0vsmlp2iycrtnu8y4w.png" alt="gambar"><br><br>  Kategorisasi token.  Kita dapat menyoroti kategori, pabrikan, model, artikel, EAN, warna.  Kami memiliki direktori tempat data disusun.  Kami memiliki data tentang pesaing yang disediakan platform perdagangan kepada kami.  Saat memprosesnya, jika memungkinkan, kami menyusun data.  Kita dapat memperbaiki kesalahan atau kesalahan ketik, misalnya, pabrikan atau warna, yang terjadi hanya sekali di semua sumber kami, tidak untuk masing-masing mempertimbangkan pabrikan dan warna.  Akibatnya, kami memiliki kamus besar kemungkinan produsen, model, artikel, warna, dan kategorisasi token hanyalah pencarian kamus untuk O (1).  Secara teoritis, Anda dapat memiliki daftar kategori terbuka dan beberapa jenis algoritma klasifikasi pintar, tetapi pendekatan dasar kami berfungsi dengan baik, dan kategorisasi bukanlah hambatan. <br><br>  Perlu dicatat bahwa kadang-kadang pemasok menyediakan data yang sudah terstruktur, misalnya, artikel berada di sel yang terpisah dalam tabel, atau pemasok membuat diskon pada ritel pada penjualan grosir, dan harga eceran dapat diperoleh dalam format yml (xml).  Kemudian kami menyimpan struktur data, dan secara heuristik membagi token ke dalam kategori hanya dari data yang tidak terstruktur. <br><br>  Dan sekarang tentang algoritma apa dan dalam urutan apa kita gunakan. <br><br><h3>  Pencocokan tepat dan hampir persis </h3><br>  Kasus paling sederhana.  Garis-garis dibagi menjadi token, mereka membawanya ke satu bentuk.  Kemudian mereka datang dengan fungsi hash yang tidak sensitif terhadap urutan token.  Selain itu, dengan mencocokkan dengan hash, kita dapat menyimpan semua data dalam memori, kita dapat membeli 16 megabyte bersyarat per kamus dengan sejuta tombol.  Dalam praktiknya, algoritma ini bekerja lebih baik daripada perbandingan string sederhana. <br><br>  Adapun hashing, penggunaan "eksklusif atau" menunjukkan dirinya, dan fungsi seperti ini: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLongHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; tokens</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tokens.Distinct()) { hash ^= GetLongHashCode(token); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br>  Hal yang paling menarik pada tahap ini adalah mendapatkan hash dari satu baris.  Dalam prakteknya, ternyata 32 bit kecil, banyak tabrakan yang didapat.  Dan juga - bahwa Anda tidak bisa hanya mengambil kode sumber fungsi dari kerangka kerja dan mengubah jenis nilai kembali, ada lebih sedikit tabrakan untuk setiap baris, tetapi setelah "eksklusif atau" mereka masih terjadi, jadi kami menulis sendiri.  Bahkan, mereka hanya menambahkan fungsi dari kerangka nonlinier dari data input.  Itu jelas lebih baik, dengan fungsi baru dengan tabrakan, kami hanya bertemu sekali dalam jutaan rekaman kami, direkam dan ditunda hingga waktu yang lebih baik. <br><br>  Dengan demikian, kami mencari pasangan tanpa memperhitungkan urutan kata dan bentuknya.  Pencarian seperti itu berfungsi untuk O (1). <br><br>  Sayangnya, jarang, tetapi itu juga terjadi: "ABC 42 Type 16" dan "ABC 16 Type 42", dan ini adalah dua produk yang berbeda.  Kami juga belajar menangani hal-hal seperti itu, tetapi lebih banyak tentang itu nanti. <br><br><h3>  Mencocokkan Produk yang Dikonfirmasi Manusia </h3><br>  Kami memiliki produk yang dicocokkan secara manual (paling sering ini adalah produk yang dicocokkan secara otomatis, tetapi yang telah diperiksa secara manual).  Faktanya, kami melakukan hal yang sama dalam kasus ini, hanya sekarang kami telah menambahkan kamus hash yang cocok, pencarian yang tidak mengubah kompleksitas waktu dari algoritma. <br><br>  Baris yang cocok secara manual terletak pada basis data, untuk berjaga-jaga, data mentah tersebut akan memungkinkan Anda untuk mengubah algoritma hashing di masa mendatang, menghitung ulang semuanya dan tidak kehilangan apa pun. <br><br><h3>  Pemetaan Atribut </h3><br>  Dua algoritma pertama cepat dan akurat, tetapi tidak cukup.  Selanjutnya kita menerapkan pencocokan atribut. <br><br>  Sebelumnya, kami sudah mempresentasikan data dalam bentuk token yang dinormalisasi dan bahkan mengurutkannya ke dalam kategori.  Dalam bab ini, saya memanggil atribut kategori token. <br><br>  Atribut yang paling dapat diandalkan adalah EAN (https://ru.wikipedia.org/wiki/European_Article_Number).  Pertandingan EAN memberi Anda jaminan hampir 100% bahwa mereka adalah produk yang sama.  Namun, ketidaksesuaian EAN tidak mengatakan apa-apa, karena satu produk mungkin memiliki EAN yang berbeda.  Semuanya akan baik-baik saja, tetapi dalam data kami EAN jarang terjadi, oleh karena itu pengaruhnya terhadap perbandingan pada tingkat kesalahan. <br><br>  Artikel itu kurang bisa diandalkan.  Sesuatu yang aneh sering didapat langsung dari data terstruktur pemasok, tetapi dalam kasus apa pun pada tahap ini kami menggunakannya. <br><br>  Seperti pada tahap terakhir, di sini kita menggunakan kamus (mencari O (1)), dan hash dari (produsen + model + artikel) digunakan sebagai kunci.  Hashing memungkinkan Anda untuk melakukan semua operasi dalam memori.  Dalam hal ini, kami juga memperhitungkan warna, jika cocok atau tidak ada, maka kami percaya bahwa barang tersebut bertepatan. <br><br><h3>  Cari yang paling cocok </h3><br>  Langkah-langkah sebelumnya sederhana, cepat, dan cukup dapat diandalkan, tetapi sayangnya mereka mencakup kurang dari setengah perbandingan. <br><br>  Dalam mencari yang paling cocok, ada ide sederhana: kebetulan token langka memiliki bobot besar, kebetulan token sering kecil.  Token yang berisi angka dinilai lebih dari token surat.  Token yang cocok dengan urutan yang sama dihargai lebih dari token yang disusun ulang.  Pertandingan panjang lebih baik daripada pertandingan pendek. <br><br>  Sekarang tetap dengan struktur data cepat yang dapat mengambil semua ini pada saat yang sama dan sesuai dengan memori direktori beberapa juta catatan. <br><br>  Kami datang dengan ide menghadirkan katalog kami dalam bentuk kamus kamus, pada tingkat pertama, kuncinya adalah hash dari pabrikan (data dalam katalog terstruktur, kami tahu pabrikan), nilainya adalah kamus.  Sekarang level kedua.  Kunci di tingkat kedua adalah hash dari token, nilainya adalah daftar item id dari katalog tempat token ini ditemukan.  Dan dalam hal ini, kami menggunakan termasuk token kombinasi dalam urutan di mana mereka muncul dalam katalog kami.  Kami memutuskan apa yang akan digunakan sebagai kombinasi, dan apa yang tidak, tergantung pada jumlah token, panjangnya dan sebagainya, ini adalah kompromi antara kecepatan, akurasi dan memori yang diperlukan.  Dalam gambar, saya menyederhanakan struktur ini, tanpa hash dan tanpa normalisasi. <br><br><img src="https://habrastorage.org/webt/kl/wu/k8/klwuk8-3nkyfo8db2schr5nt2mk.png" alt="gambar"><br><br>  Jika rata-rata 20 token digunakan untuk setiap produk, maka dalam daftar kami, yang memiliki nilai kamus terlampir, tautan ke produk akan terjadi rata-rata 20 kali.  Tidak akan ada lebih dari 20 kali token yang berbeda dari yang ada dalam katalog.  Kira-kira, Anda dapat menghitung memori yang diperlukan untuk katalog sejuta catatan: 20 juta kunci, masing-masing 4 byte, masing-masing 20 juta id produk, masing-masing byte di atas kepala, untuk mengatur kamus dan daftar (urutannya sama, tetapi karena ukuran daftar dan kamus kami tidak tahu sebelumnya, tetapi meningkat saat bepergian, kalikan dua).  Total - 480 megabita.  Pada kenyataannya, ternyata sedikit lebih banyak token untuk barang, dan kami membutuhkan hingga 800 megabyte per katalog dalam sejuta barang.  Apa yang bisa diterima, kemampuan besi modern memungkinkan Anda untuk secara bersamaan menyimpan dalam memori lebih dari seratus direktori ukuran ini. <br><br>  Kembali ke algoritme.  Memiliki string yang harus dicocokkan, kita dapat menentukan pabrikan (kami memiliki algoritme kategorisasi), dan kemudian mendapatkan token menggunakan algoritme yang sama dengan barang dari katalog.  Maksud saya, termasuk kombinasi token. <br><br>  Maka semuanya relatif sederhana.  Untuk setiap token, kami dapat dengan cepat menemukan semua produk yang ada di dalamnya, memperkirakan berat setiap pertandingan, memperhitungkan semua yang kami bicarakan sebelumnya - panjang, frekuensi, keberadaan angka atau karakter khusus, dan mengevaluasi "kesamaan" dari semua kandidat yang ditemukan.  Pada kenyataannya, ada juga optimasi di sini, kami tidak mempertimbangkan semua kandidat, pertama kami membuat daftar kecil kecocokan token dengan bobot besar, dan kami tidak menerapkan kecocokan token dengan bobot rendah untuk semua produk, tetapi hanya pada daftar ini. <br><br>  Kami memilih yang paling cocok, melihat kebetulan dari token yang ternyata dikategorikan dan mempertimbangkan skor perbandingan.  Selanjutnya, kami memiliki dua nilai ambang P1 dan P2, P1 &lt;P2.  Jika penilaian ternyata lebih dari nilai ambang P2 - partisipasi manusia tidak diperlukan, semuanya terjadi secara otomatis.  Jika antara dua nilai - kami menawarkan untuk melihat perbandingan secara manual, sebelum itu ia tidak akan berpartisipasi dalam penentuan harga.  Jika kurang dari P1 - kemungkinan besar, produk seperti itu tidak ada dalam katalog, kami tidak mengembalikan apa pun. <br><br>  Kembali ke baris "ABC 42 Type 16" dan "ABC 16 Type 42".  Solusinya sangat sederhana - jika beberapa produk memiliki hash yang sama, maka kami tidak mencocokkannya dengan hash.  Dan algoritma terakhir akan memperhitungkan urutan token.  Secara teoritis, garis-garis seperti itu dalam daftar harga pemasok tidak dapat dicocokkan dengan apa pun yang sewenang-wenang, di mana angka 16 dan 42 tidak muncul sama sekali.  Faktanya, kami tidak menemukan kebutuhan seperti itu. <br><br><h3>  Kecepatan dan ketepatan </h3><br>  Sekarang untuk kecepatan semuanya.  Waktu yang diperlukan untuk menyiapkan kamus secara linear tergantung pada ukuran katalog.  Waktu yang diperlukan secara langsung untuk perbandingan, secara linier tergantung pada jumlah barang yang dibandingkan.  Semua struktur data yang terlibat dalam pencarian tidak berubah setelah pembuatan.  Ini memberi kami kesempatan untuk menggunakan multithreading pada tahap pencocokan.  Pekerjaan persiapan untuk katalog sejuta catatan membutuhkan waktu sekitar 40-80 detik.  Perbandingannya bekerja pada kecepatan 20-40 ribu catatan per detik dan tidak tergantung pada ukuran direktori.  Namun, Anda harus menyimpan hasilnya.  Pendekatan yang dipilih umumnya bermanfaat untuk volume besar, tetapi file dengan selusin catatan akan panjang tidak proporsional.  Karena itu, kami menggunakan cache dan menceritakan kembali struktur pencarian kami setiap 15 menit sekali. <br><br>  Benar, data untuk perbandingan perlu dibaca di suatu tempat (paling sering ini adalah file excel), dan kalimat yang cocok perlu disimpan di suatu tempat, dan ini juga membutuhkan waktu.  Jadi jumlah totalnya adalah 2-4 ribu catatan per detik. <br><br>  Untuk mengevaluasi akurasi, kami menyiapkan serangkaian uji sekitar 20.000 perbandingan yang diverifikasi secara manual dari berbagai pemasok dari berbagai kategori.  Setelah setiap perubahan, algoritma diuji pada data ini.  Hasilnya adalah sebagai berikut: <br><br><ul><li>  barang ada di katalog dan dibandingkan dengan benar - 84% </li><li>  produk ada di katalog, tetapi belum cocok, pencocokan manual diperlukan - 16% </li><li>  barang ada di katalog dan dibandingkan secara tidak benar - 0,2% </li><li>  produk tidak ada dalam katalog, dan program mengidentifikasinya dengan benar - 98.5% </li><li>  produk tidak ada dalam katalog, tetapi program mencocokkannya dengan salah satu produk - 1,5% </li></ul><br>  Dalam 80% kasus ketika produk tersebut cocok, konfirmasi manual tidak diperlukan (kami secara otomatis mengkonfirmasi perbandingan), di antara penawaran yang dikonfirmasi secara otomatis tersebut adalah 0,1% kesalahan. <br><br>  Omong-omong, 0,1% kesalahan banyak, ternyata.  Untuk sejuta catatan yang cocok, ini adalah seribu catatan yang cocok secara salah.  Dan ini banyak karena pembeli menemukan catatan seperti itu terbaik.  Nah, bagaimana tidak memesan traktor untuk harga lampu depan dari traktor ini.  Namun, ribuan kesalahan ini pada awal pengerjaan atas sejuta proposal, secara bertahap diperbaiki.  Karantina untuk harga yang mencurigakan, yang menutup masalah ini, muncul kemudian, beberapa bulan pertama kami bekerja tanpa itu. <br><br>  Ada kategori kesalahan lain yang tidak terkait dengan perbandingan, ini adalah harga yang salah dari pemasok kami.  Ini adalah sebagian alasan mengapa kami tidak mempertimbangkan harga sebagai perbandingan.  Kami memutuskan bahwa karena kami memiliki informasi tambahan dalam bentuk harga, kami akan menggunakannya untuk mencoba menentukan tidak hanya kesalahan kami sendiri, tetapi juga kesalahan orang lain. <br><br><h3>  Cari harga yang salah </h3><br>  Ini adalah bagian yang kami coba secara aktif.  Versi dasarnya adalah, dan itu tidak memungkinkan Anda untuk menjual ponsel dengan harga sebuah case, tapi saya merasa lebih baik. <br><br>  Untuk setiap produk kami menemukan batasan harga pemasok yang dapat diterima.  Bergantung pada data apa yang tersedia, kami memperhitungkan harga pemasok untuk produk ini, harga pesaing, harga pemasok barang dari produsen ini dalam kategori ini.  Harga-harga yang tidak termasuk dalam perbatasan dikarantina dan diabaikan dalam semua algoritme kami.  Secara manual, Anda dapat menandai harga yang mencurigakan seperti biasa, maka kami ingat ini untuk produk ini dan menceritakan batas-batas harga yang dapat diterima. <br><br>  Algoritma langsung untuk menghitung harga maksimum dan minimum yang dapat diterima sekarang terus berubah, kami mencari kompromi antara jumlah positif palsu dan jumlah harga yang salah terdeteksi. <br><br>  Kami menggunakan nilai median dalam perhitungan (rata-rata memberikan hasil terburuk) dan belum menganalisis formulir distribusi.  Analisis bentuk distribusi hanyalah tempat di mana, menurut saya, algoritme dapat ditingkatkan. <br><br><h3>  Bekerja dengan basis data </h3><br>  Dari semua hal di atas, kita dapat menyimpulkan bahwa kita sering memperbarui data tentang pemasok dan pesaing dan dalam banyak hal, dan bekerja dengan basis data dapat menjadi hambatan.  Pada prinsipnya, kami awalnya memperhatikan hal ini dan mencoba mencapai kinerja maksimal.  Saat bekerja dengan sejumlah besar catatan, kami melakukan hal berikut: <br><br><ul><li>  kami menghapus indeks dari tabel tempat kami bekerja </li><li>  nonaktifkan pengindeksan teks lengkap pada tabel ini </li><li>  hapus semua rekaman dengan kondisi tertentu (misalnya, semua penawaran pemasok tertentu yang sedang kami proses) </li><li>  masukkan catatan baru dengan BULK COPY </li><li>  buat kembali indeks </li><li>  aktifkan pengindeksan teks lengkap </li></ul><br><br>  Salinan massal beroperasi pada kecepatan 10-40 ribu catatan per detik, mengapa penyebaran yang begitu besar masih harus dilihat, tetapi sangat dapat diterima. <br><br>  Menghapus catatan membutuhkan waktu yang hampir bersamaan dengan memasukkan.  Masih diperlukan waktu untuk membuat ulang indeks. <br><br>  Omong-omong, untuk setiap direktori kami memiliki basis data yang terpisah.  Kami membuatnya dengan cepat.  Dan sekarang saya akan memberi tahu Anda mengapa kami memiliki lebih dari satu katalog. <br><br><h2>  Apa masalah katalogisasi? </h2><br>  Dan ada banyak dari mereka juga.  Sekarang kita akan daftar: <br><br><ul><li>  Katalog berisi sekitar 400 ribu produk dari kategori yang sangat berbeda.  Tidak mungkin untuk memahami secara profesional setiap kategori. </li><li>  Anda perlu mengikuti gaya tertentu, mengikuti aturan umum untuk nama katalog, menamai subkategori, dan sebagainya.  Jadi kami berusaha untuk mencapai struktur direktori yang koheren dan logis. </li><li>  Anda dapat membuat produk yang sama beberapa kali, dan ini merupakan masalah.  Tanpa alat yang menganalisis nama yang mirip, duplikat terus-menerus dibuat. </li><li>  Masuk akal untuk menambah katalog barang-barang yang ada dalam persediaan oleh pemasok.  Dalam hal ini, Anda perlu memiliki prioritas untuk kategori produk. </li><li>  Kami membutuhkan beberapa direktori.  Salah satu dari kami sendiri, kami melakukannya sendiri, yang lain - katalog agregator, kami memperbaruinya dengan api.  Arti katalog kedua adalah bahwa platform agregator hanya berfungsi dengan katalognya sendiri, dan, karenanya, menerima penawaran dalam nomenklaturnya.  Ini adalah tempat lain di mana ternyata Anda perlu perbandingan. </li></ul><br>  Kami pikir logis dan benar untuk mempertahankan direktori di tempat yang sama dengan perbandingan.  Jadi kami dapat memberi tahu pengguna yang mengelola direktori apa yang dimiliki pemasok, tetapi tidak di direktori. <br><br><h2>  Bagaimana cara kita menyimpan katalog </h2><br>  Ini akan tentang katalog tanpa karakteristik rinci, karakteristik adalah cerita besar yang terpisah, tentang itu lain waktu. <br><br>  Sebagai properti dasar, kami memilih yang berikut: <br><br><ul><li>  produser </li><li>  kategori </li><li>  model </li><li>  nomor barang </li><li>  warna </li><li>  Ean </li></ul><br>  Pertama, kami membuat api untuk mendapatkan katalog dari sumber eksternal, dan kemudian kami bekerja pada kenyamanan membuat, mengedit, dan menghapus catatan. <br><br><h3>  Cara kerja pencarian </h3><br>  Kenyamanan mengelola katalog, pertama-tama, adalah kemampuan untuk dengan cepat menemukan produk dalam katalog atau penawaran pemasok, dan ada nuansa.  Misalnya, Anda harus dapat mencari baris "LG 21.5" 22MP48D-P (16: 9, IPS, VGA, DVI) 22MP48D-P "untuk" 2MP48 ". <br><br>  Pencarian sql server teks lengkap di luar kotak tidak sesuai, karena tidak tahu bagaimana melakukannya, dan pencarian dengan LIKE '% 2MP48%' terlalu lambat. <br><br>  Solusi kami cukup standar, kami menggunakan N-gram.  Lebih tepatnya, lalu trigram.  Dan sudah oleh trigram kami membangun indeks teks lengkap dan melakukan pencarian teks lengkap.  Saya tidak yakin bahwa kami menggunakan ruang dengan sangat rasional dalam kasus ini, tetapi dalam hal kecepatan solusi ini muncul, tergantung pada permintaan, ia bekerja dari 50 hingga 500 milidetik, kadang-kadang hingga satu detik dengan susunan tiga juta rekaman. <br><br>  Biarkan saya jelaskan, baris “LG 21.5” 22MP48D-P (16: 9, IPS, VGA, DVI) 22MP48D-P ”dikonversi ke baris“ lg2 g21 215 152 522 22m 2mp mp4 p48 48d 8dp dp1 p16 169 69i 9ip ips psv svg vga gad adv dvi vi2 i22 ”, yang disimpan dalam bidang terpisah yang berpartisipasi dalam indeks teks lengkap. <br><br>  Ngomong-ngomong, trigram masih berguna bagi kita. <br><br><h3>  Buat produk baru </h3><br>  Sebagian besar, produk dalam katalog dibuat atas saran pemasok.  Artinya, kami sudah memiliki informasi bahwa pemasok menawarkan "LG Monitor LCD 21.5 '' [16: 9] 1920x1080 (FHD) IPS, nonGLARE, 250cd / m2, H178 ° / V178 °, 1000: 1, 16.7M Warna, 5ms, VGA, DVI, Tilt, 2Y, Black OK 22MP48D-P ”dengan harga $ 120, dan ia memiliki stok 5 hingga 10 unit. <br><br>  Saat membuat produk, pertama-tama, kita perlu memastikan bahwa produk tersebut belum dibuat dalam katalog.  Kami memecahkan masalah ini dalam empat tahap. <br><br>  Pertama, jika kita memiliki produk di katalog, sangat mungkin bahwa proposal pemasok akan dicocokkan dengan produk ini secara otomatis. <br><br>  Kedua, sebelum menunjukkan kepada pengguna formulir untuk membuat produk baru, kami akan melakukan pencarian dengan trigram dan menunjukkan hasil yang paling relevan.  (secara teknis ini dilakukan dengan menggunakan CONTAINSTABLE). <br><br>  Ketiga, saat kami mengisi kolom untuk produk baru, kami akan menunjukkan produk yang sama yang sudah ada.  Ini memecahkan dua masalah: membantu menghindari duplikat dan mempertahankan gaya dalam nama, produk serupa dapat digunakan sebagai model. <br><br>  Dan keempat, ingat, kita memecah garis menjadi token, menormalkannya, menghitung hash?  Kami akan melakukan hal yang sama dan tidak akan membiarkan membuat barang dengan hash yang sama. <br><br>  Pada tahap ini, kami mencoba membantu pengguna.  Pada baris yang ada dalam daftar harga, kami akan mencoba menentukan produsen, kategori, artikel, EAN dan warna barang.  Pertama, dengan token (kami dapat membaginya ke dalam kategori), lalu, jika tidak berhasil, kami akan menemukan produk yang paling mirip dengan trigram.  Dan, jika cukup mirip, isikan pabrikan dan kategorinya. <br><br>  Pengeditan produk bekerja hampir sama, hanya saja tidak semuanya berlaku. <br><br><h2>  Bagaimana kami menetapkan harga kami </h2><br>  Tugasnya adalah ini: untuk menjaga keseimbangan antara kuantitas dan margin penjualan, pada kenyataannya - untuk mencapai laba maksimum.  Semua aspek lain dari pekerjaan toko juga tentang hal ini, tetapi apa yang terjadi pada tahap penetapan harga memiliki dampak terbesar. <br><br>  Paling tidak, kita akan memerlukan informasi tentang penawaran dari pemasok dan pesaing.  Juga layak mempertimbangkan harga eceran dan grosir minimum dan biaya pengiriman, serta instrumen keuangan - pinjaman dan angsuran. <br><br><h3>  Kami mengumpulkan harga pesaing </h3><br>  Untuk mulai dengan, kami memiliki banyak profil harga kami sendiri.  Ada profil untuk ritel, ada beberapa untuk pelanggan grosir.  Semuanya dibuat dan dikonfigurasi dalam sistem kami. <br><br>  Dengan demikian, pesaing untuk setiap profil berbeda.  Dalam ritel - toko ritel lain, dalam penjualan grosir - pemasok kami yang sama. <br><br>  Semuanya jelas dengan pemasok, tetapi untuk ritel kami mengumpulkan data pesaing dalam beberapa cara.  Pertama, beberapa agregator memberikan informasi tentang semua harga untuk semua barang yang ada di situs.  Dalam nomenklatur kita sendiri, tetapi kita dapat mencocokkan produk, sehingga itu bekerja secara otomatis.  Dan ini hampir cukup untuk saat ini.  Kedua, kami memiliki parser pesaing.  Karena belum otomatis dan ada dalam bentuk aplikasi konsol (yang terkadang macet), kami jarang menggunakannya. <br><br><h3>  Kustomisasi profil Anda </h3><br>  Dalam profil, kami memiliki peluang untuk mengkonfigurasi rentang margin yang berbeda tergantung pada harga barang dari pemasok, kategori, pabrikan, pemasok.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih dimungkinkan untuk menunjukkan dengan pemasok mana dalam kategori atau produsen mana kami bekerja, dan dengan siapa - tidak, pesaing mana yang kami perhitungkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kami menyiapkan instrumen keuangan, menunjukkan cicilan mana yang tersedia dan berapa banyak bank akan mengambil sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sudah dalam margin margin, kami membentuk harga kami sendiri, berusaha mempertahankan keseimbangan yang sama di tempat pertama, dan membuat barang gudang kami menjual lebih baik di tempat kedua. </font><font style="vertical-align: inherit;">Singkatnya, tetapi sebenarnya saya tidak berani menjelaskan dengan kata-kata sederhana apa yang terjadi di sana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya dapat memberi tahu Anda apa yang tidak terjadi. </font><font style="vertical-align: inherit;">Sayangnya, kami belum tahu bagaimana memperkirakan permintaan dan memperhitungkan biaya penyimpanan barang di gudang.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integrasi dengan sistem pihak ketiga </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian penting dari sudut pandang bisnis, tetapi tidak menarik dari sudut pandang teknis. </font><font style="vertical-align: inherit;">Singkatnya, saya akan mengatakan bahwa kami dapat mengirim data ke sistem pihak ketiga (termasuk yang inkremental, yaitu, kami memahami apa yang telah berubah sejak pertukaran terakhir) dan kami dapat melakukan milis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nawala dapat disesuaikan, jadi (dan tidak hanya itu) kami memberikan penawaran kami kepada pelanggan grosir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara lain untuk bekerja dengan pelanggan grosir adalah portal b2b. </font><font style="vertical-align: inherit;">Masih dalam pengembangan aktif, itu akan bekerja secara harfiah dalam sebulan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akun, ubah logging </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan lain yang tidak menarik dari sudut pandang teknis. </font><font style="vertical-align: inherit;">Setiap pengguna memiliki akun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkatnya, berikut ini dapat dikatakan: jika ORM digunakan, maka ia memiliki mekanisme pelacakan perubahan bawaan. </font><font style="vertical-align: inherit;">Jika Anda masuk ke dalamnya (dan dalam kasus kami ini adalah EF Core dan bahkan ada API di sana), maka Anda dapat masuk hampir dua baris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk histori perubahan, kami membuat antarmuka, dan sekarang Anda dapat melacak siapa yang mengubah apa yang ada di pengaturan sistem, siapa yang mengedit atau membandingkan produk tertentu, dan sebagainya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut log, statistik dapat dipertimbangkan, yang kami lakukan. </font><font style="vertical-align: inherit;">Kami tahu siapa yang membuat atau mengedit berapa banyak produk, berapa perbandingan yang dikonfirmasi secara manual dan berapa banyak yang ditolak, Anda dapat melihat setiap perubahan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sedikit tentang struktur umum sistem </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki satu database untuk akun dan hal-hal yang tidak tergantung pada katalog, satu database untuk log, dan database untuk setiap direktori. Ini membuat kueri direktori lebih mudah, dan analisis data lebih mudah, dan kode lebih mudah dimengerti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, sistem logging ini ditulis sendiri, kita benar-benar perlu mengelompokkan log terkait dengan satu permintaan atau satu tugas berat, di samping itu, kita memerlukan fungsionalitas dasar untuk analisis mereka. Dengan solusi turnkey, ini ternyata sulit, ditambah lagi ini adalah ketergantungan yang perlu didukung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka web dibuat pada ASP.NET Core dan bootstrap, dan operasi berat dilakukan oleh layanan Windows.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur lain yang menguntungkan proyek ini, menurut saya, adalah model yang berbeda untuk membaca dan menulis data. Kami tidak menerapkan CQRS sepenuhnya, tetapi kami mengambil salah satu konsep dari sana. Kami menulis ke database melalui repositori, tetapi objek yang digunakan untuk merekam tidak pernah meninggalkan metode update / create / delete. Pembaruan massal dilakukan melalui BULK COPY. Model terpisah dan lapisan akses data yang terpisah dibuat untuk membaca, jadi kami hanya membaca apa yang kami butuhkan pada saat tertentu. Ternyata Anda dapat menggunakan ORM, sambil menghindari pertanyaan berat, mengakses database pada waktu yang tidak pasti (seperti dengan pemuatan malas), masalah N + 1. Dan kami juga menggunakan model untuk membaca sebagai DTO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari dependensi utama, kami memiliki ASP.NET Core, beberapa paket nuget pihak ketiga, dan MS SQL Server. </font><font style="vertical-align: inherit;">Meskipun mungkin, kami berusaha untuk tidak bergantung pada banyak sistem pihak ketiga. </font><font style="vertical-align: inherit;">Untuk sepenuhnya menyebarkan proyek secara lokal, cukup instal SQL Server, ambil kode sumber dari sistem kontrol versi dan bangun proyek. </font><font style="vertical-align: inherit;">Basis data yang diperlukan akan dibuat secara otomatis, tetapi tidak ada lagi yang diperlukan. </font><font style="vertical-align: inherit;">Anda mungkin harus mengubah satu atau dua baris dalam konfigurasi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang tidak </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami belum membuat sistem pengetahuan proyek. </font><font style="vertical-align: inherit;">Kami ingin melakukan wiki dan tips di tempat. </font><font style="vertical-align: inherit;">Mereka tidak membuat antarmuka intuitif yang sederhana, antarmuka yang tidak buruk, tetapi sedikit bingung untuk orang yang tidak siap. </font><font style="vertical-align: inherit;">CI / CD sejauh ini hanya dalam rencana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak menangani detail karakteristik barang. </font><font style="vertical-align: inherit;">Kami juga berencana, tetapi belum ada tenggat waktu yang spesifik.</font></font><br><br><img src="https://habrastorage.org/webt/dm/9t/jo/dm9tjobx0gdp9te5pb_uatrndli.jpeg" alt="gambar"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ringkasan Bisnis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari awal pengembangan aktif hingga peluncuran produksi, dua orang bekerja di proyek selama 7 bulan. Pada awalnya, kami memiliki prototipe yang dibuat di waktu luang kami. Integrasi yang paling sulit diberikan kepada sistem yang ada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama tiga bulan kami dalam produksi, jumlah barang yang tersedia untuk pelanggan grosir telah berkembang dari 70 ribu menjadi 230 ribu, jumlah barang di situs - dari 60 ribu menjadi 140 ribu. Situs ini selalu terlambat karena membutuhkan fitur, gambar, deskripsi produk. Kami menurunkan 106 ribu penawaran pada agregator, bukan 40 ribu tiga bulan lalu. Jumlah orang yang bekerja dengan katalog tidak berubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami bekerja dengan 425 pemasok, jumlah ini hampir dua kali lipat dalam tiga bulan. Kami melacak harga lebih dari seribu pesaing. Yah, saat kami melacaknya - kami memiliki sistem untuk parsing, tetapi dalam kebanyakan kasus kami mengambil data yang sudah jadi dari mereka yang secara teratur menyediakannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, saya tidak bisa memberi tahu Anda tentang penjualan, saya sendiri tidak memiliki data yang dapat diandalkan. Permintaan bersifat musiman, dan tidak mungkin untuk langsung membandingkan bulan ke bulan sebelumnya. Dan dalam satu tahun terlalu banyak yang terjadi untuk menyoroti pengaruh sistem kami dari semua faktor. Sangat, sangat kondisional, plus atau minus satu kilometer, pertumbuhan katalog, harga yang lebih fleksibel dan kompetitif dan pertumbuhan penjualan terkait telah membayar untuk pengembangan dan implementasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil lain - kami mendapatkan proyek yang pada dasarnya tidak terkait dengan infrastruktur toko tertentu, dan Anda dapat membuat layanan publik darinya. Itu dikandung sejak awal, dan rencana ini hampir berhasil. Sayangnya, solusi kotak gagal. Untuk menawarkan proyek sebagai layanan tempat Anda dapat mendaftar, centang kotak "Saya setuju", dan yang berfungsi "apa adanya", tanpa beradaptasi dengan klien, Anda perlu mendesain ulang antarmuka, menambah fleksibilitas dan membuat wiki. Dan untuk membuat infrastruktur mudah terukur dan menghilangkan satu titik kegagalan. Sekarang kami hanya memiliki cadangan reguler dari cara memastikan keandalan. Sebagai solusi perusahaan, saya pikir kami siap untuk menyelesaikan masalah bisnis. Usaha kecil adalah mencari bisnis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, kami telah menarik satu klien pihak ketiga, yang memiliki fungsi paling dasar. </font><font style="vertical-align: inherit;">Orang-orang membutuhkan alat untuk membandingkan barang, dan ketidaknyamanan yang terkait dengan pengembangan aktif tidak menakuti mereka.</font></font><br><br><img src="https://habrastorage.org/webt/z7/7-/uo/z77-uo8184l_r3fbdrginrvtyik.png" alt="gambar"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456604/">https://habr.com/ru/post/id456604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456582/index.html">Mengapa Internet masih online?</a></li>
<li><a href="../id456594/index.html">2 menit dengan goyangan pohon Webpack dan ekspor kembali</a></li>
<li><a href="../id456596/index.html">Mikrobiota. Bagaimana cara kerja pengujian?</a></li>
<li><a href="../id456600/index.html">Resep Nginx: otorisasi LDAP dengan captcha</a></li>
<li><a href="../id456602/index.html">Panduan untuk Menerapkan Langganan yang Dapat Diperbarui Secara Otomatis di Aplikasi iOS</a></li>
<li><a href="../id456606/index.html">Berita dari dunia OpenStreetMap No. 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../id456608/index.html">Southbridge di Chelyabinsk dan Bitrix di Kubernetes</a></li>
<li><a href="../id456610/index.html">Jangan menekan dan tidak menyetujui</a></li>
<li><a href="../id456612/index.html">Salah satu dari ratusan cara untuk mempublikasikan beberapa proyek produksi pada satu server</a></li>
<li><a href="../id456614/index.html">How A Plague Tale: Innocence Frame Render</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>