<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’„ ğŸ˜± ğŸ¤¹ğŸ» Buku "Kode kinerja tinggi pada platform .NET. Edisi ke-2 ğŸ–• ğŸ˜¼ ğŸ—³ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buku ini akan mengajarkan Anda bagaimana memaksimalkan kinerja kode terkelola, idealnya tanpa mengorbankan manfaat dari lingkungan .NET, atau dalam ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Kode kinerja tinggi pada platform .NET. Edisi ke-2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/sl/sj/0d/slsj0dvgahq6ejfp9lenc9s8mzu.jpeg" align="left" alt="gambar"></a>  Buku ini akan mengajarkan Anda bagaimana memaksimalkan kinerja kode terkelola, idealnya tanpa mengorbankan manfaat dari lingkungan .NET, atau dalam kasus terburuk, mengorbankan sejumlah kecil dari mereka.  Anda akan mempelajari metode pemrograman rasional, mencari tahu apa yang harus dihindari dan, kemungkinan besar, yang paling penting, cara menggunakan alat yang tersedia secara bebas untuk dengan mudah mengukur tingkat produktivitas.  Materi pelatihan akan memiliki air minimum - hanya yang paling diperlukan.  Buku ini memberikan apa yang perlu Anda ketahui, itu relevan dan ringkas, tidak mengandung terlalu banyak.  Sebagian besar bab dimulai dengan informasi umum dan latar belakang, diikuti oleh tip-tip spesifik, ditetapkan seperti resep, dan diakhiri dengan pengukuran langkah-demi-langkah dan bagian debugging untuk berbagai skenario. <br><br>  Sepanjang jalan, Ben Watson akan terjun ke komponen tertentu dari lingkungan .NET, khususnya, Common Language Runtime (CLR) berdasarkan itu, dan kita akan melihat bagaimana memori mesin Anda dikelola, kode dihasilkan, eksekusi multi-threaded diatur, dan banyak lagi yang dilakukan .  Anda akan diperlihatkan bagaimana arsitektur .NET sekaligus membatasi alat perangkat lunak Anda dan menyediakannya dengan fitur tambahan dan bagaimana pilihan jalur pemrograman dapat secara signifikan mempengaruhi kinerja keseluruhan aplikasi.  Sebagai bonus, penulis akan berbagi dengan Anda cerita dari pengalaman menciptakan sistem .NET yang sangat besar, kompleks, berkinerja tinggi di Microsoft selama sembilan tahun terakhir. <br><a name="habracut"></a><br><h3>  Kutipan: Pilih ukuran kumpulan thread yang sesuai </h3><br>  Seiring waktu, thread pool dikonfigurasikan secara independen, tetapi pada awalnya ia tidak memiliki sejarah dan itu akan dimulai pada keadaan awal.  Jika produk perangkat lunak Anda sangat tidak sinkron dan menggunakan prosesor terpusat secara signifikan, produk ini mungkin menderita biaya peluncuran awal yang sangat tinggi, sambil menunggu pembuatan dan ketersediaan lebih banyak utas.  Menyesuaikan parameter awal sehingga dari saat aplikasi diluncurkan Anda akan memiliki sejumlah utas siap pakai di ujung jari Anda: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int MinWorkerThreads = <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int MinIoThreads = <span class="hljs-number"><span class="hljs-number">25</span></span>; ThreadPool.SetMinThreads(MinWorkerThreads, MinIoThreads);</code> </pre> <br>  Hati-hati di sini.  Saat menggunakan objek Task, pengiriman mereka akan didasarkan pada jumlah utas yang tersedia untuk ini.  Jika ada terlalu banyak dari mereka, objek Tugas dapat menjalani penjadwalan yang berlebihan, yang setidaknya akan menyebabkan penurunan efisiensi prosesor pusat karena lebih sering beralih konteks.  Jika beban kerja tidak terlalu tinggi, kumpulan thread dapat beralih menggunakan algoritme yang dapat mengurangi jumlah utas, membawanya ke jumlah yang lebih rendah dari yang ditentukan. <br><br>  Anda juga dapat mengatur angka maksimumnya menggunakan metode SetMaxThreads, tetapi teknik ini memiliki risiko serupa. <br><br>  Untuk mengetahui jumlah utas yang diperlukan, biarkan parameter ini sendirian dan analisis aplikasi Anda dalam keadaan stabil menggunakan metode ThreadPool.GetMaxThreads dan ThreadPool.GetMinThreads atau penghitung kinerja yang menunjukkan jumlah utas yang terlibat dalam proses. <br><br><h3>  Jangan menyela arus </h3><br>  Mengganggu pekerjaan utas tanpa koordinasi dengan pekerjaan utas lain adalah prosedur yang agak berbahaya.  Streaming harus membersihkan diri mereka sendiri, dan memanggil mereka metode Abort tidak memungkinkan mereka untuk menutup tanpa konsekuensi negatif.  Ketika sebuah utas dihancurkan, bagian-bagian aplikasi berada dalam kondisi yang tidak ditentukan.  Akan lebih baik untuk crash program, tetapi idealnya restart bersih diperlukan. <br><br>  Untuk mematikan utas dengan aman, Anda perlu menggunakan beberapa jenis status bersama, dan fungsi utas itu sendiri harus memeriksa status ini untuk menentukan kapan harus dimatikan.  Keamanan harus dicapai melalui koherensi. <br><br>  Secara umum, Anda harus selalu menggunakan objek Tugas - API tidak disediakan untuk mengganggu tugas.  Agar dapat menghentikan utas secara konsisten, Anda harus, seperti yang disebutkan sebelumnya, menggunakan token PembatalanToken. <br><br><h3>  Jangan ubah prioritas utas </h3><br>  Secara umum, mengubah prioritas utas adalah upaya yang sangat tidak berhasil.  Di Windows, pengiriman utas dilakukan sesuai dengan tingkat prioritasnya.  Jika utas prioritas tinggi selalu siap dijalankan, maka utas prioritas rendah akan diabaikan dan sangat jarang mereka akan mendapatkan kesempatan untuk menjalankan.  Dengan meningkatkan prioritas utas, Anda mengatakan bahwa pekerjaannya harus didahulukan dari semua pekerjaan lain, termasuk proses lainnya.  Ini tidak aman untuk sistem yang stabil. <br><br>  Lebih baik menurunkan prioritas utas jika menjalankan sesuatu yang dapat menunggu hingga tugas-tugas prioritas normal diselesaikan.  Salah satu alasan bagus untuk menurunkan prioritas utas mungkin untuk menemukan utas yang tidak terkontrol yang menjalankan loop tak terbatas.  Tidak mungkin untuk menghentikan utas dengan aman, jadi satu-satunya cara untuk mengembalikan utas dan sumber daya prosesor yang diberikan adalah memulai kembali proses.  Sampai menjadi mungkin untuk menutup aliran dan melakukannya dengan bersih, menurunkan prioritas aliran di luar kendali akan menjadi cara yang masuk akal untuk meminimalkan konsekuensinya.  Perlu dicatat bahwa bahkan utas dengan prioritas yang lebih rendah masih akan dijamin berjalan seiring waktu: semakin lama mereka kehilangan permulaan, semakin tinggi prioritas dinamis mereka akan ditetapkan oleh Windows.  Pengecualian adalah prioritas siaga THREAD_ - PRIORITY_IDLE, di mana sistem operasi hanya menjadwalkan utas untuk dieksekusi ketika secara harfiah tidak ada lagi yang harus dimulai. <br><br>  Mungkin ada alasan yang dibenarkan untuk meningkatkan prioritas aliran, misalnya, kebutuhan untuk cepat menanggapi situasi langka.  Tetapi menggunakan teknik seperti itu harus sangat hati-hati.  Utas pengiriman di Windows dilakukan terlepas dari proses yang menjadi bagiannya, sehingga utas prioritas tinggi dari proses Anda akan diluncurkan dengan mengorbankan tidak hanya utas lainnya, tetapi juga semua utas dari aplikasi lain yang berjalan pada sistem Anda. <br><br>  Jika kolam utas digunakan, maka setiap perubahan prioritas dibuang setiap kali utas kembali ke kolam.  Jika Anda terus mengelola utas dasar saat menggunakan pustaka Tugas Paralel, Anda harus ingat bahwa beberapa tugas dapat diluncurkan di utas yang sama sebelum dikembalikan ke kumpulan. <br><br><h3>  Sinkronisasi dan pemblokiran utas </h3><br>  Segera setelah percakapan muncul di beberapa utas, menjadi perlu untuk menyinkronkannya.  Sinkronisasi terdiri dari penyediaan akses hanya satu utas ke status bersama, misalnya, ke bidang kelas.  Biasanya, utas disinkronkan menggunakan objek sinkronisasi seperti Monitor, Semaphore, ManualResetEvent, dll. Kadang-kadang mereka disebut kunci secara tidak resmi, dan proses sinkronisasi dalam utas tertentu disebut kunci. <br><br>  Salah satu kebenaran mendasar tentang kunci adalah ini: mereka tidak pernah meningkatkan kinerja.  Dalam skenario kasus terbaik - dengan primitif sinkronisasi yang diimplementasikan dengan baik dan tidak ada persaingan - pemblokiran dapat menjadi netral.  Ini mengarah pada penghentian pelaksanaan pekerjaan yang bermanfaat oleh utas lain dan fakta bahwa waktu CPU terbuang, meningkatkan konteks waktu pengalihan dan menyebabkan konsekuensi negatif lainnya.  Anda harus menerima ini karena kebenaran jauh lebih penting daripada kinerja sederhana.  Apakah hasil yang salah dihitung dengan cepat tidak masalah! <br><br>  Sebelum Anda mulai memecahkan masalah menggunakan peralatan kunci, kami akan mempertimbangkan prinsip-prinsip paling mendasar. <br><br><h3>  Apakah saya perlu peduli dengan kinerja? </h3><br>  Membenarkan kebutuhan untuk meningkatkan produktivitas terlebih dahulu.  Ini membawa kita kembali ke prinsip-prinsip yang dibahas dalam bab 1. Kinerja tidak sama pentingnya untuk semua kode aplikasi Anda.  Tidak semua kode harus menjalani optimasi tingkat ke-n.  Sebagai aturan, semuanya dimulai dengan "loop dalam" - kode yang paling sering dieksekusi atau paling penting untuk kinerja - dan menyebar ke segala arah hingga biaya melebihi manfaat yang diterima.  Ada banyak area dalam kode yang kurang penting dalam hal kinerja.  Dalam situasi seperti itu, jika Anda membutuhkan kunci, dengan tenang menerapkannya. <br><br>  Dan sekarang kamu harus hati-hati.  Jika kode non-kritis Anda dijalankan di utas dari utas dan Anda memblokirnya untuk waktu yang lama, kumpulan utas mungkin mulai memasukkan lebih banyak utas untuk menangani permintaan lainnya.  Jika satu atau dua utas melakukan ini dari waktu ke waktu, tidak apa-apa.  Tetapi jika banyak thread melakukan hal-hal seperti itu, masalah mungkin timbul, karena karena ini, sumber daya yang harus melakukan pekerjaan nyata dihabiskan sia-sia.  Ketidaksengajaan ketika memulai suatu program dengan beban konstan yang signifikan dapat menyebabkan dampak negatif pada sistem bahkan dari bagian-bagian yang kinerjanya tinggi tidak penting, karena pengalihan konteks yang tidak perlu atau keterlibatan yang tidak masuk akal dari kumpulan ulir.  Seperti dalam semua kasus lain, pengukuran harus dilakukan untuk menilai situasi. <br><br><h3>  Apakah Anda benar-benar membutuhkan kunci? </h3><br>  Mekanisme penguncian yang paling efektif adalah yang tidak.  Jika Anda dapat sepenuhnya menghilangkan kebutuhan sinkronisasi utas, ini akan menjadi cara terbaik untuk mendapatkan kinerja tinggi.  Ini adalah cita-cita yang tidak mudah dicapai.  Biasanya ini berarti bahwa Anda perlu memastikan bahwa tidak ada status bersama yang dapat diubah - setiap permintaan yang melewati aplikasi Anda dapat diproses secara terpisah dari permintaan lain atau beberapa data yang dapat diubah (baca-tulis) terpusat.  Fitur ini akan menjadi skenario terbaik untuk mencapai kinerja tinggi. <br><br>  Dan tetap hati-hati.  Dengan restrukturisasi, mudah untuk keluar dari jalur dan mengubah kode menjadi berantakan yang tak seorang pun, termasuk Anda, bisa mengetahuinya.  Anda tidak boleh melangkah terlalu jauh kecuali produktivitas tinggi benar-benar merupakan faktor kritis dan tidak dapat dicapai sebaliknya.  Ubah kode menjadi asinkron dan independen, tetapi agar tetap jelas. <br><br>  Jika beberapa utas baru saja membaca dari variabel (dan tidak ada petunjuk untuk menulis dari suatu aliran), sinkronisasi tidak diperlukan.  Semua utas dapat memiliki akses tanpa batas.  Ini secara otomatis berlaku untuk objek yang tidak dapat diubah seperti string atau nilai dari tipe yang tidak dapat diubah, tetapi dapat berlaku untuk semua jenis objek jika Anda menjamin keabadian nilainya selama membaca oleh banyak utas. <br><br>  Jika ada beberapa utas yang menulis ke beberapa variabel bersama, lihat apakah akses yang disinkronkan dapat dihilangkan dengan pindah menggunakan variabel lokal.  Jika Anda dapat membuat salinan sementara untuk pekerjaan, kebutuhan untuk sinkronisasi akan hilang.  Ini sangat penting untuk akses sinkronisasi yang berulang.  Dari mengakses kembali variabel yang dibagikan, Anda harus pindah ke mengakses kembali variabel lokal mengikuti akses satu kali ke variabel yang dibagikan, seperti dalam contoh sederhana berikut untuk menambahkan item ke yang dibagikan oleh koleksi beberapa utas. <br><br><pre> <code class="javascript hljs">object syncObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> masterList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function"> = 8; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[] </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function">]; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; NumTasks; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">)=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5000000</span></span>; j++) { lock (syncObj) { masterList.Add(j); } } }); } Task.WaitAll(tasks);</code> </pre> <br>  Kode ini dapat dikonversi sebagai berikut: <br><br><pre> <code class="javascript hljs">object syncObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> masterList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function"> = 8; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[] </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function">]; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; NumTasks; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">)=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5000000</span></span>; j++) { localList.Add(j); } lock (syncObj) { masterList.AddRange(localList); } }); } Task.WaitAll(tasks);</code> </pre> <br>  Di mesin saya, versi kedua kode berjalan lebih dari dua kali lebih cepat daripada yang pertama. <br>  Pada akhirnya, keadaan bersama yang bisa berubah adalah musuh fundamental kinerja.  Dibutuhkan sinkronisasi untuk keamanan data, yang menurunkan kinerja.  Jika desain Anda memiliki setidaknya sedikit peluang untuk menghindari pemblokiran, maka Anda hampir menerapkan sistem multi-threaded yang ideal. <br><br><h3>  Sinkronkan Urutan Preferensi </h3><br>  Ketika memutuskan apakah jenis sinkronisasi apa pun diperlukan, harus dipahami bahwa tidak semuanya memiliki karakteristik kinerja atau perilaku yang sama.  Dalam sebagian besar situasi, Anda hanya perlu menggunakan kunci, dan biasanya ini harus menjadi opsi asli.  Penggunaan sesuatu selain pemblokiran, untuk menjustifikasi kompleksitas tambahan, membutuhkan pengukuran intensif.  Secara umum, kami mempertimbangkan mekanisme sinkronisasi dalam urutan berikut. <br><br>  1. Kunci / kelas Monitor - menjaga kesederhanaan, kelengkapan kode dan memberikan keseimbangan kinerja yang baik. <br><br>  2. Kurangnya sinkronisasi.  Singkirkan status yang dapat diubah bersama, restrukturisasi, dan optimalkan.  Ini lebih sulit, tetapi jika berhasil, pada dasarnya ia akan bekerja lebih baik daripada menerapkan pemblokiran (kecuali ketika kesalahan dibuat atau arsitektur terdegradasi). <br><br>  3. Metode saling bertautan yang sederhana - dalam beberapa skenario mungkin lebih cocok, tetapi begitu situasinya menjadi lebih rumit, lanjutkan menggunakan kunci kunci. <br><br>  Dan akhirnya, jika Anda benar-benar dapat membuktikan manfaat dari penggunaannya, gunakan kunci yang lebih rumit dan kompleks (perlu diingat: mereka jarang menjadi berguna seperti yang Anda harapkan): <br><br><ol><li>  kunci asinkron (akan dibahas nanti dalam bab ini); </li><li>  semua orang. </li></ol><br>  Keadaan tertentu dapat menentukan atau menghalangi penggunaan beberapa teknologi ini.  Misalnya, menggabungkan beberapa metode yang saling terkait tidak akan mengungguli pernyataan kunci tunggal. <br><br>  Â»Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>.NET</b> <br><br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458520/">https://habr.com/ru/post/id458520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458506/index.html">Bukan Portal 3, tapi tutup: teleportasi kuantum informasi di dalam berlian</a></li>
<li><a href="../id458508/index.html">Pandangan dari dalam: sekolah pascasarjana di EPFL. Bagian 4.2: sisi keuangan</a></li>
<li><a href="../id458514/index.html">Pelanggaran GDPR dihukum lebih aktif - denda baru dan dampak peraturan di luar UE</a></li>
<li><a href="../id458516/index.html">Dapatkan worklog dari Jira</a></li>
<li><a href="../id458518/index.html">Python menghabiskan banyak memori atau cara mengurangi ukuran objek?</a></li>
<li><a href="../id458524/index.html">Kata cloud VC di atas lutut</a></li>
<li><a href="../id458530/index.html">Zabbix, seri waktu dan TimescaleDB</a></li>
<li><a href="../id458532/index.html">Pelopor teknologi baru: Vadim Artsev memberi tahu bagaimana ia tidak lagi buta</a></li>
<li><a href="../id458536/index.html">Python + Pyside2 atau cukup "Kalkulator"</a></li>
<li><a href="../id458546/index.html">Hari Otomasi, atau bagaimana kami membangun lapisan autotest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>