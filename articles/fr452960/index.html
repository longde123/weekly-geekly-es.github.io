<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💻 💓 👩‍💼 Vous répondrez de tout! Contrats axés sur le consommateur à travers les yeux du développeur 👨🏾‍💻 🥠 🎒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous parlerons des problèmes résolus par les contrats pilotés par les consommateurs et montrerons comment l'appliquer à l'aide de l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vous répondrez de tout! Contrats axés sur le consommateur à travers les yeux du développeur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/452960/">  Dans cet article, nous parlerons des problèmes résolus par les contrats pilotés par les consommateurs et montrerons comment l'appliquer à l'aide de l'exemple de Pacte avec Node.js et Spring Boot.  Et parlez des limites de cette approche. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/vg/za/guvgzadja02vflw5bi8mgh_wbbo.png"></div><br><h2>  Problème </h2><br>  Lors des tests de produits, des tests de scénarios sont souvent utilisés dans lesquels l'intégration de divers composants du système dans un environnement spécialement sélectionné est vérifiée.  Ces tests sur les services en direct donnent le résultat le plus fiable (sans compter les tests au combat).  Mais en même temps, ils sont l'un des plus chers. <br><a name="habracut"></a><br><ul><li>  On pense souvent à tort que l'environnement d'intégration ne doit pas être tolérant aux pannes.  SLA, les garanties pour de tels environnements sont rarement exprimées, mais s'il n'est pas disponible, les équipes doivent soit retarder les versions, soit espérer le meilleur et se battre sans tests.  Bien que tout le monde sache que l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">espoir n'est pas une stratégie</a> .  De plus, les nouvelles technologies d'infrastructure compliquent le travail avec les environnements d'intégration. </li><li>  <b>Une autre douleur est de travailler avec des données de test</b> .  De nombreux scénarios nécessitent un certain état du système, des appareils.  À quel point doivent-ils être proches pour combattre les données?  Comment les mettre à jour avant le test et les nettoyer après la fin? </li><li> <b>Les tests sont trop instables</b> .  Et pas seulement à cause de l'infrastructure que nous avons mentionnée dans le premier paragraphe.  Le test peut échouer car une équipe voisine a lancé ses propres contrôles qui ont cassé l'état attendu du système!  De nombreux faux tests négatifs, tests floconneux <code>@Ignored</code> fin à leurs jours chez <code>@Ignored</code> .  En outre, différentes parties de l'intégration peuvent être prises en charge par différentes équipes.  Ils ont déployé une nouvelle version candidate avec des erreurs - ils ont cassé tous les consommateurs.  Quelqu'un résout ce problème avec des boucles de test dédiées.  Mais au prix de multiplier le coût du support. </li><li>  <b>De tels tests prennent beaucoup de temps</b> .  Même en pensant à l'automatisation, les résultats peuvent être attendus pendant des heures. </li><li>  Et pour couronner le tout, si le test a vraiment bien fonctionné, il est loin d'être toujours possible de trouver immédiatement la cause du problème.  Il peut se cacher profondément derrière les couches d'intégration.  Ou cela peut être le résultat d'une combinaison inattendue d'états de nombreux composants du système. </li></ul><br>  Des tests stables dans un environnement d'intégration nécessitent un investissement sérieux de la part de l'AQ, des développeurs et même des opérateurs.  Pas étonnant qu'ils soient tout en haut de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyramide des tests</a> .  Ces tests sont utiles, mais l'économie des ressources ne leur permet pas de tout vérifier.  La principale source de leur valeur est l'environnement. <br><br>  En dessous de la même pyramide se trouvent d'autres tests dans lesquels nous échangeons la confiance pour des maux de tête de support plus petits - en utilisant des contrôles d'isolement.  Plus le granulaire est petit, plus l'échelle du test est petite, moins la dépendance à l'environnement externe est importante.  Tout en bas de la pyramide se trouvent des tests unitaires.  Nous vérifions les fonctions individuelles, les classes, nous opérons moins avec la sémantique métier qu'avec les constructions d'une implémentation spécifique.  Ces tests donnent un retour rapide. <br><br>  Mais dès que nous descendons la pyramide, nous devons remplacer l'environnement par quelque chose.  Les stubs apparaissent - comme des services entiers et des entités individuelles du langage de programmation.  C'est à l'aide de fiches que nous pouvons tester les composants isolément.  Mais ils réduisent également la validité des chèques.  Comment s'assurer que le talon renvoie les données correctes?  Comment garantir sa qualité? <br><br>  <b>La solution peut être une documentation complète</b> qui décrit divers scénarios et états possibles des composants du système.  Mais toute formulation laisse encore la liberté d'interprétation.  Par conséquent, une bonne documentation est un artefact vivant qui s'améliore constamment à mesure que l'équipe comprend le problème.  Comment alors assurer le respect des talons de documentation? <br><br>  Sur de nombreux projets, vous pouvez observer une situation où les talons sont écrits par les mêmes gars qui ont développé l'artefact de test.  Par exemple, les développeurs d'applications mobiles créent eux-mêmes des talons pour leurs tests.  En conséquence, les programmeurs peuvent comprendre la documentation à leur manière (ce qui est tout à fait normal), ils créent le stub avec le mauvais comportement attendu, écrivent le code conformément à celui-ci (avec des tests verts) et des erreurs se produisent lors de la véritable intégration. <br><br>  De plus, la documentation se déplace généralement en aval - les clients utilisent des spécifications de services (dans ce cas, un autre service peut être client du service).  Il n'exprime pas <strong>comment les</strong> consommateurs utilisent les données, quelles données sont nécessaires, quelles hypothèses ils font pour ces données.  La conséquence de cette ignorance est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">loi d'Hyrum</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ek/bh/ho/ekbhhofe0ox95w50drdg8tybsbi.png" width="300"></div><br><br>  Hyrum Wright développe depuis longtemps des outils publics au sein de Google et a observé comment les plus petits changements peuvent provoquer des pannes pour les clients qui ont utilisé les fonctionnalités implicites (non documentées) de ses bibliothèques.  Cette connectivité cachée complique l'évolution de l'API. <br><br>  Ces problèmes peuvent être résolus dans une certaine mesure à l'aide de contrats axés sur le consommateur.  Comme toute approche et tout outil, il a une gamme d'applicabilité et de coût, que nous considérerons également.  Les implémentations de cette approche ont atteint un niveau de maturité suffisant pour essayer leurs projets. <br><br><h2>  Qu'est-ce qu'un CDC? </h2><br>  Trois éléments clés: <br><br><ul><li>  <b>Le contrat</b> .  Décrit à l'aide de DSL, dépend de l'implémentation.  Il contient une description de l'API sous forme de scénarios d'interaction: si une demande spécifique arrive, le client doit recevoir une réponse spécifique. </li><li>  <b>Tests clients</b> .  De plus, ils utilisent un talon, qui est généré automatiquement à partir du contrat. </li><li>  <b>Tests pour l'API</b> .  Ils sont également générés à partir du contrat. </li></ul><br>  Ainsi, le contrat est exécutable.  Et la principale caractéristique de l'approche est que les exigences pour le comportement de l'API vont en <b>amont</b> , du client au serveur. <br><br>  Le contrat se concentre sur le comportement qui compte <strong>vraiment</strong> pour le consommateur.  Rend ses hypothèses sur l'API explicites. <br><br>  L'objectif principal du CDC est d'apporter une compréhension du comportement de l'API à ses développeurs et aux développeurs de ses clients.  Cette approche est bien combinée avec BDD, lors de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réunions de trois amigo,</a> vous pouvez esquisser les blancs pour le contrat.  En fin de compte, ce contrat sert également à améliorer les communications;  partager une compréhension commune de la problématique et mettre en œuvre la solution au sein et entre les équipes. <br><br><h2>  Pacte </h2><br>  Envisagez d'utiliser CDC comme exemple de Pact, l'une de ses implémentations.  Supposons que nous créons une application Web pour les participants à la conférence.  Dans la prochaine itération, l'équipe élabore un calendrier de présentation - jusqu'à présent sans histoires comme le vote ou les notes, uniquement la sortie de la grille des rapports.  Le code source de l'exemple est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Lors d'une réunion de <s>trois</s> quatre amigo, un produit, un testeur, les développeurs du backend et une application mobile se rencontrent.  Ils disent que <br><br><ul><li>  Une liste avec le texte sera affichée dans l'interface utilisateur: titre du rapport + conférenciers + date et heure. </li><li>  Pour ce faire, le backend doit renvoyer des données comme dans l'exemple ci-dessous. </li></ul><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }</code> </pre> <br>  Après quoi le développeur frontend va écrire le code client (backend pour frontend).  Il installe une bibliothèque de contrats de pacte dans le projet: <br><br><pre> <code class="bash hljs">yarn add --dev @pact-foundation/pact</code> </pre> <br>  Et commence à écrire un test.  Il configure le serveur de stub local, qui simulera le service avec des planifications de rapports: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pact({ <span class="hljs-comment"><span class="hljs-comment">//      consumer: "schedule-consumer", provider: "schedule-producer", // ,     port: pactServerPort, //  pact     log: path.resolve(process.cwd(), "logs", "pact.log"), // ,     dir: path.resolve(process.cwd(), "pacts"), logLevel: "WARN", //  DSL  spec: 2 });</span></span></code> </pre> <br>  Le contrat est un fichier JSON qui décrit les scénarios d'interaction du client avec le service.  Mais vous n'avez pas besoin de le décrire manuellement, car il est formé à partir des paramètres du stub dans le code.  Le développeur avant le test décrit le comportement suivant. <br><br><pre> <code class="javascript hljs">provider.setup().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> provider .addInteraction({ <span class="hljs-attr"><span class="hljs-attr">uponReceiving</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">withRequest</span></span>: { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">willRespondWith</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] } } }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()) );</code> </pre> <br>  Ici, dans l'exemple, nous avons spécifié la demande de service attendue spécifique, mais pact-js prend également en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs méthodes pour déterminer les correspondances</a> . <br><br>  Enfin, le programmeur écrit un test de la partie du code qui utilise ce stub.  Dans l'exemple suivant, nous l'appellerons directement pour plus de simplicité. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"fetches schedule"</span></span>, done =&gt; { fetch(<span class="hljs-string"><span class="hljs-string">`http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pactServerPort}</span></span></span><span class="hljs-string">/schedule`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">json</span></span></span><span class="hljs-function"> =&gt;</span></span> expect(json).toStrictEqual({ <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] })) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()); });</code> </pre> <br>  Dans un projet réel, cela peut être soit un test unitaire rapide d'une fonction d'interprétation de réponse distincte, soit un test d'interface utilisateur lent pour afficher les données reçues d'un service. <br><br>  Pendant le test, pact vérifie que le stub a reçu la demande spécifiée dans les tests.  Les écarts peuvent être considérés comme différents dans le fichier pact.log. <br><br><pre> <code class="plaintext hljs">E, [2019-05-21T01:01:55.810194 #78394] ERROR -- : Diff with interaction: "a request for schedule" Diff -------------------------------------- Key: - is expected + is actual Matching keys and values are not shown { "headers": { - "Accept": "application/json" + "Accept": "*/*" } } Description of differences -------------------------------------- * Expected "application/json" but got "*/*" at $.headers.Accept</code> </pre> <br><br>  Si le test réussit, un contrat est généré au format JSON.  Il décrit le comportement attendu de l'API. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"consumer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-consumer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-producer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"interactions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Accept"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }}} ], <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pactSpecification"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0.0"</span></span> } } }</code> </pre> <br>  Il donne ce contrat au développeur backend.  Disons que l'API est sur Spring Boot.  Pact possède une bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pact-jvm-provider-spring</a> qui peut fonctionner avec MockMVC.  Mais nous allons jeter un œil au Spring Cloud Contract, qui implémente CDC dans l'écosystème Spring.  Il utilise son propre format de contrats, mais dispose également d'un point d'extension pour connecter des convertisseurs d'autres formats.  Son format de contrat natif n'est pris en charge que par le contrat Spring Cloud lui-même - contrairement à Pact, qui possède des bibliothèques pour JVM, Ruby, JS, Go, Python, etc. <br><br>  Supposons, dans notre exemple, que le développeur principal utilise Gradle pour créer le service.  Il connecte les dépendances suivantes: <br><br><pre> <code class="plaintext hljs">buildscript { // ... dependencies { classpath "org.springframework.cloud:spring-cloud-contract-pact:2.1.1.RELEASE" } } plugins { id "org.springframework.cloud.contract" version "2.1.1.RELEASE" // ... } // ... dependencies { // ... testImplementation 'org.springframework.cloud:spring-cloud-starter-contract-verifier' }</code> </pre> <br>  Et il place le contrat Pact reçu du soumissionnaire dans le répertoire <code>src/test/resources/contracts</code> . <br><br>  Par défaut, le plugin Spring-Cloud-Contract soustrait les contrats.  Pendant l'assemblage, la tâche Gradle generateContractTests est exécutée, ce qui génère le test suivant dans le répertoire build / generated-test-sources. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given: MockMvcRequestSpecification request = given() .header("Accept", "application/json"); // when: ResponseOptions response = given().spec(request) .get("/scheduler"); // then: assertThat(response.statusCode()).isEqualTo(200); assertThat(response.header("Content-Type")).isEqualTo("application/json;charset=UTF-8"); // and: DocumentContext parsedJson = JsonPath.parse(response.getBody().asString()); assertThatJson(parsedJson).array("['talks']").array("['speakers']").contains("['name']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['time']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['title']").isEqualTo( /*...*/ ); } }</span></span></code> </pre> <br><br>  Au démarrage de ce test, nous verrons une erreur: <br><br><pre> <code class="plaintext hljs">java.lang.IllegalStateException: You haven't configured a MockMVC instance. You can do this statically</code> </pre> <br>  Comme nous pouvons utiliser différents outils pour les tests, nous devons indiquer au plug-in celui que nous avons configuré.  Cela se fait via la classe de base, qui héritera des tests générés par les contrats. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScheduleController scheduleController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScheduleController(); <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestAssuredMockMvc.standaloneSetup(scheduleController); } }</code> </pre> <br><br>  Pour utiliser cette classe de base lors de la génération, vous devez configurer le plugin gradle Spring-Cloud-Contract. <br><br><pre> <code class="plaintext hljs">contracts { baseClassForTests = 'ru.example.schedule.ContractsBaseTest' }</code> </pre> <br><br>  Maintenant, nous avons généré le test suivant: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Le test démarre correctement, mais échoue avec une erreur de vérification - le développeur n'a pas encore écrit l'implémentation du service.  Mais maintenant, il peut le faire sur la base d'un contrat.  Il peut s’assurer qu’il est en mesure de traiter la demande du client et de renvoyer la réponse attendue. <br><br>  Le développeur de services sait par le contrat ce qu'il doit faire, quel comportement mettre en œuvre. <br><br>  Le pacte peut être intégré plus profondément dans le processus de développement.  Vous pouvez déployer un courtier Pact qui regroupe ces contrats, prend en charge leur versioning et peut afficher un graphique de dépendance. <br><br><img src="https://habrastorage.org/webt/dq/pd/v0/dqpdv0c4qk89kboewjxrafys1iq.png"><br><br>  Le téléchargement d'un nouveau contrat généré vers le courtier peut être effectué à l'étape CI lors de la création du client.  Et dans le code du serveur, indiquez le chargement dynamique du contrat par URL.  Spring Cloud Contract prend également cela en charge. <br><br><h2>  Applicabilité CDC </h2><br>  Quelles sont les limites des contrats axés sur le consommateur? <br><br>  Pour utiliser cette approche, <b>vous devez payer avec des outils supplémentaires</b> comme le pacte.  Les contrats en soi sont un artefact supplémentaire, une autre abstraction qui doit être soigneusement entretenue et appliquée consciemment des pratiques d'ingénierie. <br><br>  <b>Ils ne remplacent pas les tests e2e</b> , car les <b>stubs</b> restent des stubs - des modèles de composants système réels, qui peuvent être un peu, mais ne correspondent pas à la réalité.  Grâce à eux, les scénarios complexes ne peuvent pas être vérifiés. <br><br>  De plus, les <b>CDC ne remplacent pas les tests fonctionnels de l'API</b> .  Ils sont plus coûteux à gérer que les tests unitaires simples anciens.  Les développeurs de Pact recommandent d'utiliser les heuristiques suivantes - si vous supprimez le contrat et que cela ne provoque pas d'erreurs ou d'interprétation erronée par le client, cela n'est pas nécessaire.  Par exemple, il n'est pas nécessaire de décrire absolument tous les codes d'erreur API via un contrat si le client les traite de la même manière.  En d'autres termes, le contrat ne décrit pour le service <strong>que ce qui est important pour son client</strong> .  Pas plus, mais pas moins. <br><br>  Trop de contrats compliquent également l'évolution de l'API.  <b>Chaque contrat supplémentaire est l'occasion de tests rouges</b> .  Il est nécessaire de concevoir un CDC de telle manière que chaque test d'échec porte une charge sémantique utile qui l'emporte sur le coût de son support.  Par exemple, si le contrat fixe la longueur minimale d'un certain champ de texte indifférent au consommateur (il utilise la technique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toleran Reader</a> ), chaque modification de cette valeur minimale rompra le contrat et les nerfs de ceux qui l'entourent.  Une telle vérification doit être transférée au niveau de l'API elle-même et implémentée en fonction de la source des restrictions. <br><br><h2>  Conclusion </h2><br>  CDC améliore la qualité du produit en décrivant explicitement le comportement d'intégration.  Il aide les clients et les développeurs de services à parvenir à une compréhension commune, vous permet de parler de code.  Mais cela se fait au prix de l'ajout d'outils, de l'introduction de nouvelles abstractions et d'actions supplémentaires des membres de l'équipe. <br><br>  Dans le même temps, les outils et frameworks CDC sont activement développés et sont déjà arrivés à maturité pour tester vos projets.  Test :) <br><br><blockquote>  Lors de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QualityConf</a> du 27 au 28 mai, Andrei Markelov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlera</a> des techniques de test sur prod, et Arthur Khineltsev parlera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de la surveillance d'un</a> front-end très chargé, alors que le prix d'une petite erreur est de dizaines de milliers d'utilisateurs tristes. <br><br>  Venez discuter pour la qualité! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452960/">https://habr.com/ru/post/fr452960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452946/index.html">Relire la «philosophie de programmation de Windows 95 / NT» de Lou Greenaw</a></li>
<li><a href="../fr452952/index.html">Journée portes ouvertes JetBrains à Saint-Pétersbourg</a></li>
<li><a href="../fr452954/index.html">Temps de construction, vitesse du réseau et routage: comment nous avons amélioré notre réseau maillé et un peu sur les réseaux de neurones</a></li>
<li><a href="../fr452956/index.html">Référence de consommation de CPU pour Istio et Linkerd</a></li>
<li><a href="../fr452958/index.html">JMAP - un protocole ouvert remplace IMAP lors de l'échange de courriels</a></li>
<li><a href="../fr452962/index.html">La principale cause d'accidents dans les centres de données est la pose entre l'ordinateur et le fauteuil</a></li>
<li><a href="../fr452964/index.html">Une explication abordable de l'hypothèse de Riemann</a></li>
<li><a href="../fr452966/index.html">Le mythe de la pleine conscience: une vision «neurocentrique» de la méditation</a></li>
<li><a href="../fr452968/index.html">Index dans PostgreSQL - 10 (Bloom)</a></li>
<li><a href="../fr452974/index.html">Programmation asynchrone (cours complet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>