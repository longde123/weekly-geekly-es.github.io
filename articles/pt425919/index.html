<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üë∏üèæ ü§∑üèæ Mapas hexagonais no Unity: salvamento e carregamento, texturas, dist√¢ncias üë©üèæ‚Äç‚úàÔ∏è üîá üë©üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das c√©lulas 

 Partes 4-7: solavancos, rios e estradas 

 Pe√ßas 8-11: √°gua, formas terrestres e muralhas 

 Pe√ßas 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonais no Unity: salvamento e carregamento, texturas, dist√¢ncias</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das c√©lulas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 8-11: √°gua, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 12-15: salvar e carregar, texturas, dist√¢ncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadr√µes de jogadores, anima√ß√µes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Gera√ß√£o de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 12: salvar e carregar </h1><br><ul><li>  Acompanhe o tipo de terreno em vez de cor. </li><li>  Crie um arquivo </li><li>  N√≥s escrevemos os dados em um arquivo e depois lemos. </li><li>  Serializamos os dados da c√©lula. </li><li>  Reduza o tamanho do arquivo. </li></ul><br>  J√° sabemos como criar mapas bastante interessantes.  Agora voc√™ precisa aprender como salv√°-los. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Carregado do arquivo <a href="">test.map</a> .</i> <br><br><h2>  Tipo de terreno </h2><br>  Ao salvar um mapa, n√£o precisamos armazenar todos os dados que rastreamos durante a execu√ß√£o do aplicativo.  Por exemplo, precisamos apenas lembrar o n√≠vel de altura da c√©lula.  Sua pr√≥pria posi√ß√£o vertical √© retirada desses dados, para que voc√™ n√£o precise armazen√°-los.  Na verdade, √© melhor n√£o armazenar essas m√©tricas calculadas.  Assim, os dados do mapa permanecer√£o corretos, mesmo que mais tarde decidamos alterar o deslocamento da altura.  Os dados s√£o separados da sua apresenta√ß√£o. <br><br>  Da mesma forma, n√£o precisamos armazenar a cor exata da c√©lula.  Voc√™ pode escrever que a c√©lula √© verde.  Mas o tom exato de verde pode mudar com uma mudan√ßa no estilo visual.  Para fazer isso, podemos salvar o √≠ndice de cores, n√£o as pr√≥prias cores.  De fato, pode ser suficiente armazenarmos esse √≠ndice em vez de cores reais nas c√©lulas em tempo de execu√ß√£o.  Isso permitir√°, posteriormente, a visualiza√ß√£o mais complexa do relevo. <br><br><h3>  Movendo uma matriz de cores </h3><br>  Se as c√©lulas n√£o tiverem mais dados de cores, eles dever√£o ser armazenados em outro lugar.  √â mais conveniente armazen√°-lo no <code>HexMetrics</code> .  Ent√£o, vamos adicionar uma variedade de cores a ele. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Como todos os outros dados globais, como ru√≠do, podemos inicializar essas cores com o <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  E como agora n√£o atribu√≠mos cores diretamente √†s c√©lulas, nos livraremos da cor padr√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; ‚Ä¶ void CreateCell (int x, int z, int i) { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; ‚Ä¶ }</span></span></code> </pre> <br>  Defina as novas cores para corresponder √† matriz geral do editor de mapas hexagonais. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Cores adicionadas √† grade.</i> <br><br><h3>  Refatora√ß√£o de C√©lulas </h3><br>  Remova o campo de cores do <code>HexCell</code> .  Em vez disso, armazenaremos o √≠ndice.  Em vez de um √≠ndice de cores, usamos um √≠ndice mais geral do tipo de relevo. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  A propriedade color pode usar esse √≠ndice apenas para obter a cor correspondente.  Agora, como n√£o est√° definido diretamente, exclua esta parte.  Nesse caso, obtemos um erro de compila√ß√£o, que corrigiremos em breve. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // ‚Ä¶ // } }</span></span></code> </pre> <br>  Adicione uma nova propriedade para obter e definir um novo √≠ndice de tipo de eleva√ß√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Refatora√ß√£o do editor </h3><br>  Dentro do <code>HexMapEditor</code> todo o c√≥digo referente √†s cores.  Isso corrigir√° o erro de compila√ß√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ // Color activeColor; ‚Ä¶ // bool applyColor; ‚Ä¶ // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } ‚Ä¶ // void Awake () { // SelectColor(0); // } ‚Ä¶ void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } ‚Ä¶ } }</span></span></code> </pre> <br>  Agora adicione um campo e m√©todo para controlar o √≠ndice do tipo de eleva√ß√£o ativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Usamos esse m√©todo como um substituto para o m√©todo <code>SelectColor</code> agora ausente.  Conecte os widgets de cores na interface do usu√°rio ao <code>SetTerrainTypeIndex</code> , deixando o restante inalterado.  Isso significa que um √≠ndice negativo ainda est√° em uso e significa que a cor n√£o deve mudar. <br><br>  Altere <code>EditCell</code> para que o √≠ndice do tipo de eleva√ß√£o seja atribu√≠do √† c√©lula que est√° sendo editada. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } ‚Ä¶ } }</code> </pre> <br>  Embora tenhamos removido os dados de cores das c√©lulas, o mapa deve funcionar da mesma maneira que antes.  A √∫nica diferen√ßa √© que a cor padr√£o agora √© a primeira da matriz.  No meu caso, √© amarelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Amarelo √© a nova cor padr√£o.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Salvando dados em um arquivo </h2><br>  Para controlar o salvamento e o carregamento do mapa, usamos o <code>HexMapEditor</code> .  Vamos criar dois m√©todos que far√£o isso e, por enquanto, deix√°-los vazios. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Adicione dois bot√µes √† interface do usu√°rio ( <em>GameObject / UI / Button</em> ).  Conecte-os aos bot√µes e d√™ as etiquetas apropriadas.  Coloquei-os na parte inferior do painel direito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Bot√µes Salvar e Carregar.</i> <br><br><h3>  Local do arquivo </h3><br>  Para armazenar um cart√£o, voc√™ precisa salv√°-lo em algum lugar.  Como √© feito na maioria dos jogos, armazenaremos dados em um arquivo.  Mas onde colocar esse arquivo no sistema de arquivos?  A resposta depende do sistema operacional em que o jogo est√° sendo executado.  Cada sistema operacional possui seus pr√≥prios padr√µes para armazenar arquivos relacionados a aplicativos. <br><br>  N√£o precisamos conhecer esses padr√µes.  O Unity sabe o caminho certo que podemos obter com <code>Application.persistentDataPath</code> .  Voc√™ pode verificar como ser√° com voc√™, no m√©todo <code>Save</code> , exibindo-o no console e pressionando o bot√£o no modo Reproduzir. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  Nos sistemas de desktop, o caminho conter√° o nome da empresa e do produto.  Esse caminho √© usado pelo editor e pela montagem.  Os nomes podem ser configurados em <em>Editar / Configura√ß√µes do projeto / Player</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Nome da empresa e produto.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que n√£o consigo encontrar a pasta Biblioteca no Mac?</b> <div class="spoiler_text">  A pasta <em>Biblioteca</em> geralmente est√° oculta.  A maneira como ele pode ser exibido depende da vers√£o do OS X. Se voc√™ n√£o possui uma vers√£o anterior, selecione a pasta pessoal no Finder e v√° para <em>Mostrar op√ß√µes de exibi√ß√£o</em> .  H√° uma caixa de sele√ß√£o para a pasta <em>Biblioteca</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">E o WebGL?</b> <div class="spoiler_text">  Os jogos WebGL n√£o podem acessar o sistema de arquivos do usu√°rio.  Em vez disso, todas as opera√ß√µes de arquivo s√£o redirecionadas para um sistema de arquivos localizado na mem√≥ria.  Ela √© transparente para n√≥s.  No entanto, para salvar dados, voc√™ precisar√° solicitar manualmente a p√°gina da Web para despejar dados no armazenamento do navegador. </div></div><br><h3>  Cria√ß√£o de arquivo </h3><br>  Para criar um arquivo, precisamos usar classes do espa√ßo para nome <code>System.IO</code> .  Portanto, adicionamos uma instru√ß√£o <code>using</code> para ela na classe <code>HexMapEditor</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br>  Primeiro, precisamos criar o caminho completo para o arquivo.  Usamos <em>test.map</em> como o <em>nome</em> do arquivo.  Ele deve ser adicionado ao caminho dos dados armazenados.  A necessidade de inserir uma barra invertida ou dianteira (barra invertida) depende da plataforma.  O m√©todo <code>Path.Combine</code> far√° <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Em seguida, precisamos acessar o arquivo neste local.  Fazemos isso usando o m√©todo <code>File.Open</code> .  Como queremos gravar dados nesse arquivo, precisamos usar o modo de cria√ß√£o.  Nesse caso, um novo arquivo ser√° criado no caminho especificado ou um arquivo existente ser√° substitu√≠do. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  O resultado da chamada desse m√©todo ser√° um fluxo de dados aberto associado a esse arquivo.  Podemos us√°-lo para gravar dados em um arquivo.  E n√£o devemos esquecer de fechar o fluxo quando n√£o precisarmos mais dele. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  Nesse est√°gio, quando voc√™ clica no bot√£o <em>Salvar</em> , o arquivo <em>test.map</em> ser√° criado na pasta especificada como o caminho para os dados armazenados.  Se voc√™ estudar esse arquivo, ele estar√° vazio e ter√° um tamanho de 0 bytes, porque at√© agora n√£o escrevemos nada nele. <br><br><h3>  Gravar no arquivo </h3><br>  Para gravar dados em um arquivo, precisamos de uma maneira de transmitir dados para ele.  A maneira mais f√°cil de fazer isso √© com o <code>BinaryWriter</code> .  Esses objetos permitem gravar dados primitivos em qualquer fluxo. <br><br>  Crie um novo objeto <code>BinaryWriter</code> e nosso fluxo de arquivos ser√° seu argumento.  O escritor de fechamento fecha o fluxo usado.  Portanto, n√£o precisamos mais armazenar um link direto para o fluxo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Para transferir dados para um fluxo, podemos usar o m√©todo <code>BinaryWriter.Write</code> .  Existe uma variante do m√©todo <code>Write</code> para todos os tipos primitivos, como inteiro e float.  Tamb√©m pode gravar linhas.  Vamos tentar escrever o n√∫mero inteiro 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Clique no bot√£o <em>Salvar</em> e examine <em>test.map</em> novamente.  Agora, seu tamanho √© de 4 bytes, porque o tamanho inteiro √© de 4 bytes. <br><br><div class="spoiler">  <b class="spoiler_title">Por que meu gerenciador de arquivos mostra que o arquivo ocupa mais espa√ßo?</b> <div class="spoiler_text">  Porque os sistemas de arquivos dividem o espa√ßo em blocos de bytes.  Eles n√£o controlam bytes individuais.  Como <em>test.map</em> leva apenas quatro bytes at√© agora, requer um bloco de espa√ßo de armazenamento. </div></div><br>  Observe que armazenamos dados bin√°rios, n√£o textos leg√≠veis por humanos.  Portanto, se abrirmos o arquivo em um editor de texto, veremos um conjunto de caracteres indistintos.  Voc√™ provavelmente ver√° o s√≠mbolo <em>{</em> seguido por nada ou alguns espa√ßos reservados. <br><br>  Voc√™ pode abrir o arquivo em um editor hexadecimal.  Nesse caso, veremos <em>7b 00 00 00</em> .  Estes s√£o quatro bytes do nosso n√∫mero inteiro, mapeados em nota√ß√£o hexadecimal.  Em n√∫meros decimais comuns, isso √© <em>123 0 0 0</em> .  Em bin√°rio, o primeiro byte se parece com <em>01111011</em> . <br><br>  O c√≥digo ASCII para <em>{</em> √© 123, portanto, esse caractere pode ser exibido em um editor de texto.  ASCII 0 √© um caractere nulo que n√£o corresponde a nenhum caractere vis√≠vel. <br><br>  Os tr√™s bytes restantes s√£o iguais a zero, porque escrevemos um n√∫mero menor que 256. Se escrev√™ssemos 256, ver√≠amos <em>00 01 00 00</em> no editor hexadecimal. <br><br><div class="spoiler">  <b class="spoiler_title">123 n√£o deve ser armazenado como 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> usa o formato little-endian para salvar n√∫meros.  Isso significa que os bytes menos significativos s√£o gravados primeiro.  Este formato foi usado pela Microsoft no desenvolvimento da estrutura .Net.  Provavelmente foi escolhido porque o CPU Intel usa o formato little-endian. <br><br>  Uma alternativa √© o big-endian, no qual os bytes mais significativos s√£o armazenados primeiro.  Isso corresponde √† ordem usual de n√∫meros em n√∫meros.  123 √© cento e vinte e tr√™s porque queremos dizer o recorde de big endian.  Se fosse um pequeno endian, 123 significaria trezentos e vinte e um. </div></div><br><h3>  Tornamos os recursos livres </h3><br>  √â importante que fechemos escritor.  Enquanto est√° aberto, o sistema de arquivos bloqueia o arquivo, impedindo que outros processos sejam gravados nele.  Se esquecermos de fech√°-lo, tamb√©m nos bloquearemos.  Se pressionarmos o bot√£o Salvar duas vezes, na segunda vez n√£o poderemos abrir o fluxo. <br><br>  Em vez de fechar o gravador manualmente, podemos criar um bloco <code>using</code> para isso.  Ele define o escopo dentro do qual o escritor √© v√°lido.  Quando o c√≥digo execut√°vel ultrapassa esse escopo, o gravador √© exclu√≠do e o thread √© fechado. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Isso funcionar√° porque as classes de gravador e de fluxo de arquivos implementam a interface <code>IDisposable</code> .  Esses objetos t√™m um m√©todo <code>Dispose</code> , que √© chamado indiretamente quando eles v√£o al√©m do escopo de <code>using</code> . <br><br>  A grande vantagem do <code>using</code> √© que ele funciona, n√£o importa como o programa fique fora do escopo.  Retornos antecipados, exce√ß√µes e erros n√£o o incomodam.  Al√©m disso, ele √© muito conciso. <br><br><h3>  Recupera√ß√£o de dados </h3><br>  Para ler dados escritos anteriormente, precisamos inserir o c√≥digo no m√©todo <code>Load</code> .  Como no caso de salvar, precisamos criar um caminho e abrir o fluxo de arquivos.  A diferen√ßa √© que agora abrimos o arquivo para leitura, n√£o para grava√ß√£o.  E, em vez de escritor, precisamos do <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  Nesse caso, podemos usar o m√©todo <code>File.OpenRead</code> para abrir o arquivo para leitura. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por que n√£o podemos usar o File.OpenWrite ao escrever?</b> <div class="spoiler_text">  Esse m√©todo cria um fluxo que adiciona dados aos arquivos existentes, em vez de substitu√≠-los. </div></div><br>  Ao ler, precisamos indicar explicitamente o tipo de dados recebidos.  Para ler n√∫meros inteiros de um fluxo, precisamos usar <code>BinaryReader.ReadInt32</code> .  Este m√©todo l√™ um n√∫mero inteiro de 32 bits, ou seja, quatro bytes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Note-se que, ao receber <em>123,</em> ser√° suficiente lermos um byte.  Mas, ao mesmo tempo, tr√™s bytes pertencentes a esse n√∫mero inteiro permanecer√£o no fluxo.  Al√©m disso, isso n√£o funcionar√° para n√∫meros fora do intervalo de 0 a 255.  Portanto, n√£o fa√ßa isso. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Escrevendo e lendo dados do mapa </h2><br>  Ao salvar dados, uma pergunta importante √© se deve ser usado um formato leg√≠vel por humanos.  Normalmente, os formatos leg√≠veis por humanos s√£o JSON, XML e ASCII simples com algum tipo de estrutura.  Esses arquivos podem ser abertos, interpretados e editados em editores de texto.  Al√©m disso, eles simplificam a troca de dados entre diferentes aplicativos. <br><br>  No entanto, esses formatos t√™m seus pr√≥prios requisitos.  Os arquivos ocupam mais espa√ßo (√†s vezes muito mais) do que usando dados bin√°rios.  Eles tamb√©m podem aumentar bastante o custo de codifica√ß√£o e decodifica√ß√£o de dados, em termos de tempo de execu√ß√£o e de espa√ßo na mem√≥ria. <br><br>  Por outro lado, os dados bin√°rios s√£o compactos e r√°pidos.  Isso √© importante ao gravar grandes quantidades de dados.  Por exemplo, ao salvar automaticamente um mapa grande em cada turno do jogo.  Portanto, <br>  vamos usar o formato bin√°rio.  Se voc√™ conseguir lidar com isso, poder√° trabalhar com formatos mais detalhados. <br><br><div class="spoiler">  <b class="spoiler_title">E a serializa√ß√£o autom√°tica?</b> <div class="spoiler_text">  Imediatamente durante o processo de serializa√ß√£o dos dados do Unity, podemos escrever diretamente classes serializadas no fluxo.  Detalhes da grava√ß√£o de campos individuais ser√£o escondidos de n√≥s.  No entanto, n√£o podemos serializar diretamente as c√©lulas.  S√£o classes <code>MonoBehaviour</code> que cont√™m dados que n√£o precisamos salvar.  Portanto, precisamos usar uma hierarquia separada de objetos, que destrua a simplicidade da serializa√ß√£o autom√°tica.  Al√©m disso, ser√° mais dif√≠cil oferecer suporte a futuras altera√ß√µes de c√≥digo.  Portanto, manteremos controle total com serializa√ß√£o manual.  Al√©m disso, nos far√° realmente entender o que est√° acontecendo. </div></div><br>  Para serializar o mapa, precisamos armazenar os dados de cada c√©lula.  Para salvar e carregar uma √∫nica c√©lula, adicione os m√©todos <code>Save</code> and <code>Load</code> ao <code>HexCell</code> .  Como eles precisam de um escritor ou leitor para trabalhar, n√≥s os adicionaremos como par√¢metros. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Adicione m√©todos <code>Save</code> e <code>Load</code> ao <code>HexGrid</code> .  Esses m√©todos simplesmente ignoram todas as c√©lulas chamando seus m√©todos <code>Load</code> e <code>Save</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Se fizermos o download de um mapa, ele precisar√° ser atualizado ap√≥s a altera√ß√£o dos dados da c√©lula.  Para fazer isso, basta atualizar todos os fragmentos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Finalmente, substitu√≠mos nosso c√≥digo de teste no <code>HexMapEditor</code> pelas chamadas para os m√©todos <code>Save</code> and <code>Load</code> da grade, passando o escritor ou o leitor com eles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Salvando um tipo de relevo </h3><br>  No est√°gio atual, salvar novamente cria um arquivo vazio e o download n√£o faz nada.  Vamos come√ßar gradualmente gravando e carregando apenas o √≠ndice do tipo de eleva√ß√£o <code>HexCell</code> . <br><br>  Atribua o valor diretamente ao campo terrainTypeIndex.  N√£o usaremos propriedades.  Como atualizamos explicitamente todos os fragmentos, as chamadas para as propriedades de <code>Refresh</code> n√£o s√£o necess√°rias.  Al√©m disso, como salvamos apenas os mapas corretos, assumiremos que todos os mapas baixados tamb√©m est√£o corretos.  Portanto, por exemplo, n√£o verificaremos se o rio ou estrada √© permitido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Ao salvar neste arquivo, um ap√≥s o outro, o √≠ndice do tipo de al√≠vio de todas as c√©lulas ser√° gravado.  Como o √≠ndice √© um n√∫mero inteiro, seu tamanho √© de quatro bytes.  Meu cart√£o cont√©m 300 c√©lulas, ou seja, o tamanho do arquivo ser√° de 1200 bytes. <br><br>  A carga l√™ os √≠ndices na mesma ordem em que s√£o gravados.  Se voc√™ alterou as cores das c√©lulas ap√≥s salvar, o carregamento do mapa retornar√° as cores ao estado ao salvar.  Como n√£o salvamos mais nada, o restante dos dados da c√©lula permanecer√° o mesmo.  Ou seja, o carregamento alterar√° o tipo de terreno, mas n√£o a sua altura, n√≠vel da √°gua, caracter√≠sticas do terreno, etc. <br><br><h3>  Salvando todo o n√∫mero inteiro </h3><br>  Salvar um √≠ndice de tipo de al√≠vio n√£o √© suficiente para n√≥s.  Voc√™ precisa salvar todos os outros dados.  Vamos come√ßar com todos os campos inteiros.  Este √© um √≠ndice do tipo de relevo, altura da c√©lula, n√≠vel da √°gua, n√≠vel da cidade, n√≠vel da fazenda, n√≠vel da vegeta√ß√£o e √≠ndice de objetos especiais.  Eles precisar√£o ser lidos na mesma ordem em que foram gravados. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Tente agora salvar e carregar o mapa, fazendo altera√ß√µes entre essas opera√ß√µes.  Tudo o que inclu√≠mos nos dados armazenados foi restaurado da melhor forma poss√≠vel, exceto a altura da c√©lula.  Isso aconteceu porque quando voc√™ altera o n√≠vel de altura, √© necess√°rio atualizar a posi√ß√£o vertical da c√©lula.  Isso pode ser feito atribuindo-o √† propriedade, e n√£o ao campo, o valor da altura carregada.  Mas essa propriedade faz um trabalho adicional que n√£o precisamos.  Portanto, vamos extrair o c√≥digo que atualiza a posi√ß√£o da c√©lula do levantador de <code>Elevation</code> e inseri-lo em um m√©todo <code>RefreshPosition</code> separado.  A √∫nica altera√ß√£o que voc√™ precisa fazer aqui √© substituir o <code>value</code> refer√™ncia ao campo de <code>elevation</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Agora podemos chamar o m√©todo ao definir a propriedade, bem como depois de carregar os dados da altura. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); ‚Ä¶ } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br>  Ap√≥s essa altera√ß√£o, as c√©lulas mudar√£o corretamente sua altura aparente ao carregar. <br><br><h3>  Salvando todos os dados </h3><br>  A presen√ßa de paredes e rios de entrada / sa√≠da na c√©lula √© armazenada em campos booleanos.  Podemos escrev√™-los simplesmente como um n√∫mero inteiro.  Al√©m disso, os dados da estrada s√£o uma matriz de seis valores booleanos que podemos escrever com um loop. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  As dire√ß√µes dos rios de entrada e sa√≠da s√£o armazenadas nos campos <code>HexDirection</code> .  O tipo <code>HexDirection</code> √© uma enumera√ß√£o armazenada internamente como v√°rios valores inteiros.  Portanto, tamb√©m podemos serializ√°-los como um n√∫mero inteiro usando uma convers√£o expl√≠cita. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Os valores booleanos s√£o lidos usando o m√©todo <code>BinaryReader.ReadBoolean</code> .  As dire√ß√µes dos rios s√£o inteiras, que devemos converter novamente em <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Agora, salvamos todos os dados da c√©lula necess√°rios para o salvamento e a restaura√ß√£o completos do mapa.  Isso requer nove n√∫meros inteiros e nove valores booleanos por c√©lula.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada valor booleano ocupa um byte, portanto, usamos um total de 45 bytes por c√©lula. </font><font style="vertical-align: inherit;">Ou seja, um cart√£o com 300 c√©lulas requer um total de 13.500 bytes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzir o tamanho do arquivo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora pare√ßa que 13.500 bytes n√£o sejam muito para 300 c√©lulas, talvez possamos fazer com uma quantidade menor. </font><font style="vertical-align: inherit;">No final, temos controle total sobre como os dados s√£o serializados. </font><font style="vertical-align: inherit;">Vamos ver se existe uma maneira mais compacta de armazen√°-los.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redu√ß√£o num√©rica do intervalo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes n√≠veis e √≠ndices de c√©lulas s√£o armazenados como um n√∫mero inteiro. </font><font style="vertical-align: inherit;">No entanto, eles usam apenas um pequeno intervalo de valores. </font><font style="vertical-align: inherit;">Cada um deles permanecer√° definitivamente na faixa de 0 a 255. </font><font style="vertical-align: inherit;">Isso significa que apenas o primeiro byte de cada n√∫mero inteiro ser√° usado. </font><font style="vertical-align: inherit;">Os tr√™s restantes sempre ser√£o zero. </font><font style="vertical-align: inherit;">N√£o faz sentido armazenar esses bytes vazios. </font><font style="vertical-align: inherit;">Podemos descart√°-los escrevendo n√∫mero inteiro em byte antes de gravar no fluxo.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, para retornar esses n√∫meros, temos que usar </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A convers√£o de byte para inteiro √© feita implicitamente, por isso n√£o precisamos adicionar convers√µes expl√≠citas.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, nos livramos de tr√™s bytes por n√∫mero inteiro, o que economiza 27 bytes por c√©lula. Agora gastamos 18 bytes por c√©lula e apenas 5.400 bytes por 300 c√©lulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale a pena notar que os dados antigos do cart√£o se tornam sem sentido nesse est√°gio. Ao carregar o salvamento antigo, os dados s√£o misturados e obtemos c√©lulas confusas. Isso ocorre porque agora estamos lendo menos dados. Se lermos mais dados do que antes, obteremos um erro ao tentar ler al√©m do final do arquivo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A incapacidade de processar dados antigos nos conv√©m, porque estamos determinando o formato. </font><font style="vertical-align: inherit;">Por√©m, quando decidimos o formato de salvamento, precisamos garantir que o c√≥digo futuro sempre possa l√™-lo. </font><font style="vertical-align: inherit;">Mesmo se mudarmos o formato, o ideal √© que ainda possamos ler o formato antigo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, usamos quatro bytes para armazenar dados do rio, dois por dire√ß√£o. </font><font style="vertical-align: inherit;">Para cada dire√ß√£o, armazenamos a presen√ßa do rio e a dire√ß√£o em que ele flui.Parece </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√≥bvio que n√£o precisamos armazenar a dire√ß√£o do rio, se n√£o estiver. </font><font style="vertical-align: inherit;">Isso significa que as c√©lulas sem um rio precisam de dois bytes a menos. </font><font style="vertical-align: inherit;">De fato, um byte na dire√ß√£o do rio ser√° suficiente para n√≥s, independentemente de sua exist√™ncia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos seis dire√ß√µes poss√≠veis, que s√£o armazenadas como n√∫meros no intervalo de 0 a 5. </font><font style="vertical-align: inherit;">Tr√™s bits s√£o suficientes para isso, porque na forma bin√°ria os n√∫meros de 0 a 5 se parecem com 000, 001, 010, 011, 100, 101 e 110. Ou seja, mais um byte permanece sem uso de mais cinco bits. </font><font style="vertical-align: inherit;">Podemos usar um deles para indicar se existe um rio. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode usar o oitavo bit, correspondente ao n√∫mero 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, adicionaremos 128 a ele antes de converter a dire√ß√£o em bytes. Ou seja, se tivermos um rio fluindo para o noroeste, escreveremos 133, que na forma bin√°ria √© 10000101. E se n√£o houver rio, simplesmente escrevemos um byte zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao mesmo tempo, mais quatro bits permanecem sem uso, mas isso √© normal. </font><font style="vertical-align: inherit;">Podemos combinar as duas dire√ß√µes do rio em um byte, mas isso j√° ser√° muito confuso.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para decodificar dados do rio, primeiro precisamos ler o byte de volta. </font><font style="vertical-align: inherit;">Se seu valor n√£o for menor que 128, isso significa que existe um rio. </font><font style="vertical-align: inherit;">Para obter sua dire√ß√£o, subtraia 128 e converta para </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtivemos 16 bytes por c√©lula. </font><font style="vertical-align: inherit;">A melhoria parece n√£o ser grande, mas esse √© um daqueles truques usados ‚Äã‚Äãpara reduzir o tamanho dos dados bin√°rios.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvar estradas em um byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar um truque semelhante para compactar dados da estrada. </font><font style="vertical-align: inherit;">Temos seis valores booleanos que podem ser armazenados nos primeiros seis bits de um byte. </font><font style="vertical-align: inherit;">Ou seja, cada dire√ß√£o da estrada √© representada por um n√∫mero que √© uma pot√™ncia de dois. </font><font style="vertical-align: inherit;">S√£o 1, 2, 4, 8, 16 e 32, ou na forma bin√°ria 1, 10, 100, 1000, 10000 e 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar um byte finalizado, precisamos definir os bits que correspondem √†s dire√ß√µes usadas das estradas. </font><font style="vertical-align: inherit;">Para obter a dire√ß√£o certa, podemos usar o operador </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, combine-os usando o operador OR bit a bit. </font><font style="vertical-align: inherit;">Por exemplo, se a primeira, segunda, terceira e sexta estradas forem usadas, o byte finalizado ser√° 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o &lt;&lt; funciona?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para recuperar o valor booleano da estrada, √© necess√°rio verificar se o bit est√° definido. </font><font style="vertical-align: inherit;">Nesse caso, mascare todos os outros bits usando o operador AND bit a bit com o n√∫mero apropriado. </font><font style="vertical-align: inherit;">Se o resultado n√£o for igual a zero, o bit √© definido e a estrada existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de espremer seis bytes em um, recebemos 11 bytes por c√©lula. </font><font style="vertical-align: inherit;">Com 300 c√©lulas, isso √© apenas 3.300 bytes. </font><font style="vertical-align: inherit;">Ou seja, depois de trabalhar um pouco com bytes, reduzimos o tamanho do arquivo em 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preparando-se para o futuro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de declarar nosso formato de salvamento completo, adicionamos mais um detalhe. </font><font style="vertical-align: inherit;">Antes de salvar os dados do mapa, for√ßaremos a </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrever um n√∫mero inteiro zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso adicionar√° quatro bytes vazios ao in√≠cio de nossos dados. </font><font style="vertical-align: inherit;">Ou seja, antes de carregar o cart√£o, precisamos ler esses quatro bytes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora esses bytes sejam in√∫teis at√© agora, eles s√£o usados ‚Äã‚Äãcomo um cabe√ßalho que fornecer√° compatibilidade com vers√µes anteriores no futuro. </font><font style="vertical-align: inherit;">Se n√£o tiv√©ssemos adicionado esses bytes nulos, o conte√∫do dos primeiros bytes dependeria da primeira c√©lula do mapa. </font><font style="vertical-align: inherit;">Portanto, no futuro, seria mais dif√≠cil descobrir com qual vers√£o do formato de salvamento estamos lidando. </font><font style="vertical-align: inherit;">Agora podemos apenas verificar os quatro primeiros bytes. </font><font style="vertical-align: inherit;">Se eles estiverem vazios, ent√£o estamos lidando com uma vers√£o do formato 0. Nas vers√µes futuras, ser√° poss√≠vel adicionar outra coisa l√°. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, se o t√≠tulo for diferente de zero, estamos lidando com uma vers√£o desconhecida. </font><font style="vertical-align: inherit;">Como n√£o conseguimos descobrir quais dados existem, devemos nos recusar a baixar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 13: gerenciamento de cart√µes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos novas cartas no modo Play. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione suporte para v√°rios tamanhos de cart√£o. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione o tamanho do mapa aos dados salvos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salve e carregue mapas arbitr√°rios. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exiba uma lista de cart√µes. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, adicionaremos suporte para v√°rios tamanhos de cart√µes, al√©m de salvar arquivos diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir desta parte, os tutoriais ser√£o criados no Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O in√≠cio da</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca de mapas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar novos mapas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© esse ponto, criamos a grade hexagonal apenas uma vez - ao carregar a cena. </font><font style="vertical-align: inherit;">Agora tornaremos poss√≠vel iniciar um novo mapa a qualquer momento. </font><font style="vertical-align: inherit;">O novo cart√£o simplesmente substituir√° o atual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Desperta </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, algumas m√©tricas s√£o inicializadas e, em seguida, o n√∫mero de c√©lulas √© determinado e os fragmentos e c√©lulas necess√°rios s√£o criados. </font><font style="vertical-align: inherit;">Criando um novo conjunto de fragmentos e c√©lulas, criamos um novo mapa. </font><font style="vertical-align: inherit;">Vamos dividir </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em duas partes - o c√≥digo fonte de inicializa√ß√£o e o m√©todo geral </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um bot√£o na interface do usu√°rio para criar um novo mapa. </font><font style="vertical-align: inherit;">Fiz grande e coloquei sob os bot√µes salvar e carregar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo bot√£o de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos conectar o evento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deste bot√£o ao m√©todo do </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nosso objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou seja, n√£o passaremos pelo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de mapa hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas chamaremos diretamente o m√©todo de objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um mapa clicando em.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limpando dados antigos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando voc√™ clica no bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um novo conjunto de fragmentos e c√©lulas ser√° criado. </font><font style="vertical-align: inherit;">No entanto, os antigos n√£o s√£o exclu√≠dos automaticamente. </font><font style="vertical-align: inherit;">Portanto, como resultado, obtemos v√°rias malhas de mapas sobrepostas umas √†s outras. </font><font style="vertical-align: inherit;">Para evitar isso, primeiro precisamos nos livrar de objetos antigos. </font><font style="vertical-align: inherit;">Isso pode ser feito destruindo todos os fragmentos atuais no in√≠cio </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reutilizar objetos existentes?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    ‚Äî    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â poss√≠vel destruir elementos filho como este em um loop?</font></font></b> <div class="spoiler_text">  Claro.         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Especifique o tamanho nas c√©lulas em vez de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto definimos o tamanho do mapa atrav√©s dos campos </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e do </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas ser√° muito mais conveniente indicar o tamanho do mapa nas c√©lulas. </font><font style="vertical-align: inherit;">Ao mesmo tempo, podemos alterar o tamanho do fragmento no futuro sem alterar o tamanho dos cart√µes. </font><font style="vertical-align: inherit;">Portanto, vamos trocar as fun√ß√µes dos campos n√∫mero de c√©lulas e n√∫mero de fragmentos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; ‚Ä¶ // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; ‚Ä¶ public void CreateMap () { ‚Ä¶ // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso levar√° a um erro de compila√ß√£o, porque ele </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa tamanhos de fragmento </font><font style="vertical-align: inherit;">para limitar sua posi√ß√£o </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mude </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele use diretamente o n√∫mero de c√©lulas que ele ainda precisa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um fragmento tem um tamanho de 5 por 5 c√©lulas e os mapas por padr√£o t√™m um tamanho de 4 por 3 fragmentos. </font><font style="vertical-align: inherit;">Portanto, para manter os cart√µes iguais, teremos que usar um tamanho de 20 por 15 c√©lulas. </font><font style="vertical-align: inherit;">E embora tenhamos atribu√≠do valores padr√£o no c√≥digo, o objeto de grade ainda n√£o os utilizar√° automaticamente, porque os campos j√° existiam e tinham como padr√£o 0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padr√£o, o cart√£o tem um tamanho de 20 por 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamanhos de cart√µes personalizados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥ximo passo ser√° o suporte √† cria√ß√£o de cart√µes de qualquer tamanho, n√£o apenas do tamanho padr√£o. </font><font style="vertical-align: inherit;">Para fazer isso, adicione </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X e Z </font><font style="vertical-align: inherit;">aos </font><font style="vertical-align: inherit;">par√¢metros, que substituir√£o o n√∫mero de c√©lulas existente. </font><font style="vertical-align: inherit;">L√° dentro, </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vamos cham√°-los com o n√∫mero atual de c√©lulas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, isso funcionar√° corretamente apenas com o n√∫mero de c√©lulas que √© um m√∫ltiplo do tamanho do fragmento. </font><font style="vertical-align: inherit;">Caso contr√°rio, a divis√£o inteira criar√° muito poucos fragmentos. </font><font style="vertical-align: inherit;">Embora possamos adicionar suporte para fragmentos parcialmente preenchidos com c√©lulas, vamos proibir o uso de tamanhos que n√£o correspondem a fragmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar o operador </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular o restante da divis√£o do n√∫mero de c√©lulas pelo n√∫mero de fragmentos. </font><font style="vertical-align: inherit;">Se n√£o for igual a zero, haver√° uma discrep√¢ncia e n√£o criaremos um novo mapa. </font><font style="vertical-align: inherit;">E enquanto fazemos isso, vamos adicionar prote√ß√£o contra tamanhos zero e negativo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Novo menu do cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No est√°gio atual, o bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o funciona mais, porque o m√©todo </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora possui dois par√¢metros. N√£o podemos conectar diretamente eventos do Unity a esses m√©todos. Al√©m disso, para oferecer suporte a diferentes tamanhos de cart√µes, precisamos de alguns bot√µes. Em vez de adicionar todos esses bot√µes √† interface principal, vamos criar um menu pop-up separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma nova tela √† cena ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Usaremos as mesmas configura√ß√µes da tela existente, exceto que sua </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordem de classifica√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser igual a 1. Gra√ßas a isso, ela estar√° no topo da interface do usu√°rio do editor principal. Tornei a tela e o sistema de eventos um filho do novo objeto de interface do usu√°rio para que a hierarquia da cena permanecesse limpa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Tela Novo mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um </font><font style="vertical-align: inherit;">painel </font><font style="vertical-align: inherit;">ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que feche a tela inteira. </font><font style="vertical-align: inherit;">√â necess√°rio escurecer o fundo e n√£o permitir que o cursor interaja com todo o resto quando o menu estiver aberto. </font><font style="vertical-align: inherit;">Dei a ele uma cor uniforme, limpando sua imagem de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><font style="vertical-align: inherit;">defini (0, 0, 0, 200) </font><font style="vertical-align: inherit;">como a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura√ß√µes da imagem de fundo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma barra de menus ao centro da tela, semelhante aos pain√©is do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos criar uma etiqueta e bot√µes claros para seus cart√µes pequenos, m√©dios e grandes. </font><font style="vertical-align: inherit;">Tamb√©m adicionaremos um bot√£o de cancelamento a ela, caso o jogador mude de id√©ia. </font><font style="vertical-align: inherit;">Ap√≥s terminar de criar o design, desative todo o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo menu de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para gerenciar o menu, crie um componente </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e adicione-o ao objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para criar um novo mapa, precisamos acessar o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Portanto, adicionamos um campo comum a ele e o conectamos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente do novo menu de mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abertura e fechamento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir e fechar o menu pop-up simplesmente ativando e desativando o objeto de tela. </font><font style="vertical-align: inherit;">Vamos adicionar </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois m√©todos comuns para fazer isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora conecte o bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">editor ao m√©todo </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrindo o menu pressionando. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conecte tamb√©m o bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao m√©todo </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso nos permitir√° abrir e fechar o menu pop-up.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar novos mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar novos mapas, precisamos chamar o </font><font style="vertical-align: inherit;">m√©todo </font><font style="vertical-align: inherit;">no objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Al√©m disso, depois disso, precisamos fechar o menu pop-up. </font><font style="vertical-align: inherit;">Adicione ao </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que ir√° lidar com isso, levando em considera√ß√£o um tamanho arbitr√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo n√£o deve ser geral, porque ainda n√£o podemos conect√°-lo diretamente aos eventos do bot√£o. </font><font style="vertical-align: inherit;">Em vez disso, crie um m√©todo por bot√£o que chamar√° </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o tamanho especificado. </font><font style="vertical-align: inherit;">Para um mapa pequeno, usei um tamanho de 20 por 15, correspondendo ao tamanho padr√£o do mapa. </font><font style="vertical-align: inherit;">Para a carta do meio, decidi dobrar esse tamanho, obtendo 40 por 30, e dobrar novamente para a carta grande. </font><font style="vertical-align: inherit;">Conecte os bot√µes com os m√©todos apropriados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloqueio da c√¢mera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar o menu pop-up para criar novos mapas com tr√™s tamanhos diferentes! Tudo funciona bem, mas precisamos cuidar de um pequeno detalhe. Quando o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa est√°</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ativo, n√£o podemos mais interagir com a interface do usu√°rio do editor e editar c√©lulas. No entanto, ainda podemos controlar a c√¢mera. Idealmente, com o menu aberto, a c√¢mera deve travar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como temos apenas uma c√¢mera, uma solu√ß√£o r√°pida e pragm√°tica √© simplesmente adicionar uma propriedade est√°tica a ela </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para uso amplo, esta solu√ß√£o n√£o √© muito adequada, mas para a nossa interface simples √© suficiente. Isso requer que rastreie a inst√¢ncia est√°tica interna </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que √© definida quando a c√¢mera Desperta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma propriedade </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser uma propriedade booleana est√°tica simples apenas com um setter. </font><font style="vertical-align: inherit;">Tudo o que faz √© desativar a inst√¢ncia </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando estiver bloqueada e ativ√°-la quando estiver desbloqueada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode bloquear a c√¢mera e </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- desbloque√°-la.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manuten√ß√£o da posi√ß√£o correta da c√¢mera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe outro problema prov√°vel com a c√¢mera. </font><font style="vertical-align: inherit;">Ao criar um novo mapa menor que o atual, a c√¢mera pode aparecer fora das bordas do mapa. </font><font style="vertical-align: inherit;">Ela permanecer√° l√° at√© que o jogador tente mover a c√¢mera. </font><font style="vertical-align: inherit;">E s√≥ ent√£o ser√° limitado pelos limites do novo mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, podemos adicionar ao </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo est√°tico </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chamar um m√©todo de </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inst√¢ncia com deslocamento zero for√ßar√° a c√¢mera a se mover para as bordas do mapa. </font><font style="vertical-align: inherit;">Se a c√¢mera j√° estiver dentro das bordas do novo mapa, ela permanecer√° no lugar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame o m√©todo dentro </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depois de criar um novo mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando o tamanho do mapa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora possamos criar cart√µes de tamanhos diferentes, isso n√£o √© levado em considera√ß√£o ao salvar e carregar. </font><font style="vertical-align: inherit;">Isso significa que carregar um mapa levar√° a um erro ou a um mapa incorreto se o tamanho do mapa atual n√£o corresponder ao tamanho do mapa carregado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, antes de carregar os dados da c√©lula, precisamos criar um novo mapa do tamanho apropriado. </font><font style="vertical-align: inherit;">Digamos que temos um pequeno mapa salvo. </font><font style="vertical-align: inherit;">Nesse caso, tudo ficar√° bem se criarmos </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um mapa de 20 por 15 </font><font style="vertical-align: inherit;">no in√≠cio </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armazenamento de tamanho de cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, podemos armazenar um cart√£o de qualquer tamanho. </font><font style="vertical-align: inherit;">Portanto, uma solu√ß√£o generalizada ser√° salvar o tamanho do mapa na frente dessas c√©lulas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, podemos obter o tamanho real e us√°-lo para criar um mapa com os tamanhos corretos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora podemos carregar mapas de tamanhos diferentes, somos novamente confrontados com o problema da posi√ß√£o da c√¢mera. </font><font style="vertical-align: inherit;">Resolveremos isso verificando sua posi√ß√£o </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ap√≥s carregar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Novo formato de arquivo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora essa abordagem funcione com cart√µes que manteremos no futuro, n√£o funcionar√° com cart√µes antigos. </font><font style="vertical-align: inherit;">E vice-versa - o c√≥digo da parte anterior do tutorial n√£o poder√° carregar corretamente novos arquivos de mapa. </font><font style="vertical-align: inherit;">Para distinguir entre formatos antigos e novos, aumentaremos o valor inteiro do cabe√ßalho. </font><font style="vertical-align: inherit;">O formato antigo de salvar sem tamanho de mapa tinha a vers√£o 0. O novo formato com tamanho de mapa ter√° a vers√£o 1. Portanto, ao gravar, ele </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve gravar 1 em vez de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de agora, os cart√µes ser√£o salvos como vers√£o 1. Se tentarmos abri-los na montagem do tutorial anterior, eles se recusar√£o a carregar e relatar um formato de cart√£o desconhecido. </font><font style="vertical-align: inherit;">De fato, isso acontecer√° se j√° tentarmos carregar esse cart√£o. </font><font style="vertical-align: inherit;">Voc√™ precisa alterar o m√©todo </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele aceite a nova vers√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidade com vers√µes anteriores </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, se quisermos, ainda podemos baixar mapas da vers√£o 0, supondo que todos tenham o mesmo tamanho 20 por 15. Ou seja, o t√≠tulo n√£o precisa ser 1, tamb√©m pode ser zero. </font><font style="vertical-align: inherit;">Uma vez que cada vers√£o requer sua pr√≥pria abordagem, </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© transmitir o m√©todo de cabe√ßalho </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inclua um </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√≠tulo </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">par√¢metro e use-o para tomar decis√µes sobre outras a√ß√µes. </font><font style="vertical-align: inherit;">Se o cabe√ßalho n√£o for menor que 1, voc√™ precisar√° ler os dados de tamanho do cart√£o. </font><font style="vertical-align: inherit;">Caso contr√°rio, usamos o tamanho antigo do cart√£o fixo de 20 por 15 e ignoramos a leitura dos dados do tamanho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); ‚Ä¶ }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers√£o do arquivo de mapa 0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica√ß√£o do tamanho do cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como na cria√ß√£o de um novo mapa, √© teoricamente poss√≠vel que tenhamos de carregar um mapa incompat√≠vel com o tamanho do fragmento. </font><font style="vertical-align: inherit;">Quando isso acontece, devemos interromper o download do cart√£o. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√° se recusa a criar um mapa e exibe um erro no console. </font><font style="vertical-align: inherit;">Para dizer isso ao chamador do m√©todo, vamos retornar um booleano informando se o mapa foi criado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele tamb√©m pode interromper a execu√ß√£o quando a cria√ß√£o do mapa falha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o carregamento substitui todos os dados nas c√©lulas existentes, n√£o precisamos criar um novo mapa se um mapa do mesmo tamanho estiver carregado. </font><font style="vertical-align: inherit;">Portanto, esta etapa pode ser ignorada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de arquivos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos salvar e carregar cart√µes de tamanhos diferentes, mas sempre escreva e leia </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agora vamos adicionar suporte para arquivos diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de salvar ou carregar diretamente o mapa, usamos outro menu pop-up que fornece gerenciamento avan√ßado de arquivos. </font><font style="vertical-align: inherit;">Crie outra tela, como no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas desta vez vamos cham√°-lo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Salvar carregamento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este menu salva e carrega mapas, dependendo do bot√£o pressionado para abri-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criaremos o design do </font><em><font style="vertical-align: inherit;">menu Salvar carregamento</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como se fosse um menu para salvar. Mais tarde, n√≥s o transformaremos dinamicamente em um menu de inicializa√ß√£o. Como outro menu, ele deve ter um plano de fundo e uma barra de menus, um r√≥tulo de menu e um bot√£o de cancelamento. Em seguida, adicione uma exibi√ß√£o de rolagem ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ao menu para exibir uma lista de arquivos. Abaixo, inserimos o campo de entrada ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) para indicar os nomes dos novos cart√µes. Tamb√©m precisamos de um bot√£o de a√ß√£o para salvar o mapa. E finalmente adicione um bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excluir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para excluir cart√µes desnecess√°rios.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Salvar menu de carregamento.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por padr√£o, a exibi√ß√£o de rolagem permite rolagem horizontal e vertical, mas precisamos apenas de uma lista com rolagem vertical. Portanto, desative a rolagem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e retire o rolagem horizontal bar. Tamb√©m configuramos o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de movimento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font><font style="vertical-align: inherit;">fixar </font><font style="vertical-align: inherit;">e desativar a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in√©rcia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tornar a lista mais restritiva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op√ß√µes da lista de arquivos. </font></font></i> <font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">Removeremos o</font></em></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filho </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font><em><font style="vertical-align: inherit;">Barra de Rolagem</font></em><font style="vertical-align: inherit;"> do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de Arquivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque n√£o precisamos dele. </font><font style="vertical-align: inherit;">Em seguida, redimensione a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barra de rolagem vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ela </font><em><font style="vertical-align: inherit;">atinja o</font></em><font style="vertical-align: inherit;"> final da lista. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O texto do espa√ßo reservado para o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de Nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser alterado em seu espa√ßo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reservado</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filho </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usei texto descritivo, mas voc√™ pode deix√°-lo em branco e se livrar do espa√ßo reservado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design do menu alterado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclu√≠mos o design e agora desativamos o menu para que por padr√£o ele fique oculto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de menu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que o menu funcione, precisamos de outro script, neste caso - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele precisa de um link para a grade, bem como m√©todos </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione esse componente ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e atribua um link ao objeto de grade.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um menu ser√° aberto para salvar ou carregar. </font><font style="vertical-align: inherit;">Para simplificar o trabalho, adicione um </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metro booleano </font><font style="vertical-align: inherit;">ao m√©todo </font><font style="vertical-align: inherit;">Determina se o menu deve estar no modo de salvamento. </font><font style="vertical-align: inherit;">Seguiremos esse modo no campo para saber qual a√ß√£o executar posteriormente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora combinar os bot√µes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carregar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Editor de mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o m√©todo </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar carregar o menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verifique o par√¢metro booleano apenas para o bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrindo o menu no modo de salvamento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ ainda n√£o o fez, conecte o evento do bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao m√©todo </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agora </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar Menu de Carregamento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser aberta e fechada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mudan√ßa na apar√™ncia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos o menu como um menu para salvar, mas seu modo √© determinado pelo bot√£o pressionado para abrir. </font><font style="vertical-align: inherit;">Precisamos alterar a apar√™ncia do menu, dependendo do modo. </font><font style="vertical-align: inherit;">Em particular, precisamos alterar o r√≥tulo do menu e o bot√£o do bot√£o de a√ß√£o. </font><font style="vertical-align: inherit;">Isso significa que precisaremos de links para essas tags.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conex√£o com tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o menu √© aberto no modo de salvamento, usamos os r√≥tulos existentes, ou seja, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o menu e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o bot√£o de a√ß√£o. </font><font style="vertical-align: inherit;">Caso contr√°rio, estamos no modo de carregamento, ou seja, usamos o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Digite o nome do cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos deixar a lista de arquivos por enquanto. </font><font style="vertical-align: inherit;">O usu√°rio pode especificar o arquivo salvo ou baixado digitando o nome do cart√£o no campo de entrada. </font><font style="vertical-align: inherit;">Para obter esses dados, precisamos de uma refer√™ncia ao componente </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conex√£o ao campo de entrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O usu√°rio n√£o precisa ser for√ßado a inserir o caminho completo para o arquivo de mapa. </font><font style="vertical-align: inherit;">Basta o nome do cart√£o sem a extens√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos adicionar um m√©todo que aceite a entrada do usu√°rio e crie o caminho certo para ela. </font><font style="vertical-align: inherit;">Isso n√£o √© poss√≠vel quando a entrada est√° vazia, portanto, neste caso, retornaremos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que acontece se o usu√°rio digitar caracteres inv√°lidos?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando e carregando </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele estar√° envolvido em salvar e carregar </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, n√≥s nos movemos os m√©todos </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles n√£o precisam mais ser compartilhados e funcionar√£o com o par√¢metro path em vez do caminho fixo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora estamos carregando arquivos arbitr√°rios, seria bom verificar se o arquivo realmente existe e s√≥ ent√£o tentar l√™-lo. </font><font style="vertical-align: inherit;">Caso contr√°rio, lan√ßamos um erro e encerramos a opera√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora adicione o m√©todo geral </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Come√ßa com a obten√ß√£o do caminho selecionado pelo usu√°rio. </font><font style="vertical-align: inherit;">Se houver um caminho, salve ou carregue-o. </font><font style="vertical-align: inherit;">Depois feche o menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao anexar um evento do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bot√£o de a√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a esse m√©todo </font><font style="vertical-align: inherit;">, podemos salvar e carregar usando nomes de mapas arbitr√°rios. </font><font style="vertical-align: inherit;">Como n√£o redefinimos o campo de entrada, o nome selecionado permanecer√° at√© o pr√≥ximo salvamento ou carregamento. </font><font style="vertical-align: inherit;">Isso √© conveniente para salvar ou carregar de um arquivo v√°rias vezes seguidas, para que n√£o alteremos nada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itens da lista de mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, preencheremos a lista de arquivos com todos os cart√µes que est√£o no caminho de armazenamento de dados. </font><font style="vertical-align: inherit;">Quando voc√™ clica em um dos itens da lista, ele ser√° usado como texto na </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de Nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adicione um </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo geral para isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos de algo que √© um item da lista. </font><font style="vertical-align: inherit;">O bot√£o de sempre serve. </font><font style="vertical-align: inherit;">Crie-o e reduza a altura para 20 unidades, para que n√£o ocupe muito espa√ßo na vertical. </font><font style="vertical-align: inherit;">Como n√£o deve parecer um bot√£o, limparemos o link </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem de origem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesse caso, ele ficar√° completamente branco. </font><font style="vertical-align: inherit;">Al√©m disso, garantiremos que o r√≥tulo esteja alinhado √† esquerda e que haja espa√ßo entre o texto e o lado esquerdo do bot√£o. </font><font style="vertical-align: inherit;">Depois de terminar com o design do bot√£o, o transformamos em uma pr√©-fabricada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot√£o √© um item da lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos conectar diretamente o evento do bot√£o ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque √© uma pr√©-fabricada e ainda n√£o existe na cena. </font><font style="vertical-align: inherit;">Portanto, um item de menu precisa de um link para o menu para que ele possa chamar um m√©todo quando clicado </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele tamb√©m precisa acompanhar o nome do cart√£o que ele representa e definir seu texto. </font><font style="vertical-align: inherit;">Vamos criar um pequeno componente para isso </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um componente ao item de menu e fa√ßa o bot√£o chamar seu m√©todo </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente de item.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preenchimento de lista </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para preencher a lista, voc√™ </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisa de um link para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conte√∫do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">janela</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><em><font style="vertical-align: inherit;">exibi√ß√£o</font></em><font style="vertical-align: inherit;"> do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de Arquivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ele tamb√©m precisa de um link para o item pr√©-fabricado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misture o conte√∫do de uma lista e uma pr√©-fabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos um novo m√©todo para preencher esta lista. </font><font style="vertical-align: inherit;">A primeira etapa √© identificar os arquivos de mapa existentes. </font><font style="vertical-align: inherit;">Para uma disposi√ß√£o de caminhos para arquivos dentro do diret√≥rio, podemos usar o m√©todo </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo possui um segundo par√¢metro que permite filtrar arquivos. </font><font style="vertical-align: inherit;">No nosso caso, apenas os arquivos correspondentes √† m√°scara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o necess√°rios </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, a ordem dos arquivos n√£o √© garantida. </font><font style="vertical-align: inherit;">Para exibi-los em ordem alfab√©tica, precisamos classificar a matriz com </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criaremos inst√¢ncias pr√©-fabricadas para cada elemento da matriz. </font><font style="vertical-align: inherit;">Ligue o item ao menu, defina o nome do mapa e torne-o filho do conte√∫do da lista.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ele </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna os caminhos completos para os arquivos, precisamos limp√°-los. </font><font style="vertical-align: inherit;">Felizmente, √© exatamente isso que torna o m√©todo conveniente </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de exibir o menu, precisamos preencher uma lista. </font><font style="vertical-align: inherit;">E, como √© prov√°vel que os arquivos sejam alterados, precisamos fazer isso sempre que abrirmos o menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao preencher novamente a lista, precisamos excluir todos os antigos antes de adicionar novos itens. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itens sem arranjo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disposi√ß√£o dos pontos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora a lista exibir√° itens, mas eles se sobrepor√£o e estar√£o em uma posi√ß√£o incorreta. Para transform√°-los em uma lista vertical, adicione o </font><font style="vertical-align: inherit;">componente </font><em><font style="vertical-align: inherit;">Grupo de Layout Vertical</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Componente / Layout / Grupo de Layout Vertical</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">ao objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conte√∫do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font><font style="vertical-align: inherit;">lista </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que a organiza√ß√£o funcione corretamente, ative </font><em><font style="vertical-align: inherit;">Largura</font></em><font style="vertical-align: inherit;"> do </font><em><font style="vertical-align: inherit;">tamanho do controle </font></em><em><font style="vertical-align: inherit;">infantil</font></em><font style="vertical-align: inherit;"> e </font><em><font style="vertical-align: inherit;">expans√£o da for√ßa infantil</font></em><font style="vertical-align: inherit;"> . As duas op√ß√µes de </font><em><font style="vertical-align: inherit;">altura</font></em><font style="vertical-align: inherit;"> devem estar desabilitadas.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o grupo de layout vertical. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos uma bela lista de itens. </font><font style="vertical-align: inherit;">No entanto, o tamanho do conte√∫do da lista n√£o se ajusta ao n√∫mero real de itens. </font><font style="vertical-align: inherit;">Portanto, a barra de rolagem nunca altera o tamanho. </font><font style="vertical-align: inherit;">Podemos for√ßar o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conte√∫do a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redimensionar automaticamente adicionando um componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajustador de tamanho de conte√∫do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente / Layout / Ajustador de tamanho de conte√∫do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Seu modo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajuste vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser definido como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamanho preferido</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o ajuste de tamanho de conte√∫do. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, com um pequeno n√∫mero de pontos, a barra de rolagem desaparecer√°. </font><font style="vertical-align: inherit;">E quando h√° muitos itens na lista que n√£o cabem na janela de exibi√ß√£o, a barra de rolagem √© exibida e possui um tamanho apropriado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma barra de rolagem √© exibida.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exclus√£o do cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos trabalhar convenientemente com muitos arquivos de mapa. </font><font style="vertical-align: inherit;">No entanto, √†s vezes √© necess√°rio se livrar de alguns cart√µes. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ pode usar o bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excluir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos criar um m√©todo para isso e fazer o bot√£o cham√°-lo. </font><font style="vertical-align: inherit;">Se houver um caminho selecionado, simplesmente exclua-o com </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui tamb√©m devemos verificar se estamos trabalhando com um arquivo realmente existente. </font><font style="vertical-align: inherit;">Se n√£o for esse o caso, n√£o devemos tentar remov√™-lo, mas isso n√£o leva a um erro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de remover o cart√£o, n√£o precisamos fechar o menu. </font><font style="vertical-align: inherit;">Isso facilita a exclus√£o de v√°rios arquivos por vez. </font><font style="vertical-align: inherit;">No entanto, ap√≥s a remo√ß√£o, precisamos limpar a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e atualizar a lista de arquivos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 14: texturas de relevo </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use cores de v√©rtice para criar um mapa de splat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando um ativo de textura de matriz. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando √≠ndices de eleva√ß√£o a malhas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transi√ß√µes entre texturas de relevo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© o momento, usamos cores s√≥lidas para colorir cart√µes. </font><font style="vertical-align: inherit;">Agora vamos aplicar a textura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenho de texturas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma mistura de tr√™s tipos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora as cores uniformes sejam claramente distingu√≠veis e bastante adequadas √† tarefa, elas n√£o parecem muito interessantes. </font><font style="vertical-align: inherit;">O uso de texturas aumentar√° significativamente a atratividade dos mapas. </font><font style="vertical-align: inherit;">Claro que, para isso, temos que misturar texturas, n√£o apenas cores. </font><font style="vertical-align: inherit;">No tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3, Combining Textures,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falei sobre como misturar v√°rias texturas usando o mapa de splat. </font><font style="vertical-align: inherit;">Em nossos mapas hexagonais, voc√™ pode usar uma abordagem semelhante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas quatro texturas s√£o misturadas e, com um mapa splat, podemos suportar at√© cinco texturas. </font><font style="vertical-align: inherit;">No momento, usamos cinco cores diferentes, ent√£o isso √© bastante adequado para n√≥s. </font><font style="vertical-align: inherit;">No entanto, mais tarde, podemos adicionar outros tipos. </font><font style="vertical-align: inherit;">Portanto, √© necess√°rio suporte para um n√∫mero arbitr√°rio de tipos de al√≠vio. </font><font style="vertical-align: inherit;">Ao usar propriedades de textura definidas explicitamente, isso n√£o √© poss√≠vel; portanto, √© necess√°rio usar uma matriz de texturas. </font><font style="vertical-align: inherit;">Mais tarde vamos cri√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar matrizes de textura, precisamos, de alguma forma, dizer ao sombreador quais texturas misturar. </font><font style="vertical-align: inherit;">A mistura mais dif√≠cil √© necess√°ria para tri√¢ngulos angulares, que podem estar entre tr√™s c√©lulas com seu pr√≥prio tipo de terreno. </font><font style="vertical-align: inherit;">Portanto, precisamos misturar suporte entre os tr√™s tipos por tri√¢ngulo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando cores de v√©rtice como mapas do Splat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supondo que possamos dizer quais texturas misturar, podemos usar cores de v√©rtice para criar um mapa de splat para cada tri√¢ngulo. </font><font style="vertical-align: inherit;">Como em cada caso s√£o usadas no m√°ximo tr√™s texturas, precisamos apenas de tr√™s canais de cores. </font><font style="vertical-align: inherit;">Vermelho representar√° a primeira textura, verde - a segunda e azul - a terceira.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa de tri√¢ngulo Splat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A soma do mapa de splat do tri√¢ngulo √© sempre igual a um?</font></font></b> <div class="spoiler_text">  Sim         .     . ,        (1, 0, 0)  ,  (¬Ω, ¬Ω, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se um tri√¢ngulo precisa de apenas uma textura, usamos apenas o primeiro canal. </font><font style="vertical-align: inherit;">Ou seja, sua cor ser√° completamente vermelha. </font><font style="vertical-align: inherit;">No caso de mixar entre dois tipos diferentes, usamos o primeiro e o segundo canais. </font><font style="vertical-align: inherit;">Ou seja, a cor do tri√¢ngulo ser√° uma mistura de vermelho e verde. </font><font style="vertical-align: inherit;">E quando todos os tr√™s tipos forem encontrados, haver√° uma mistura de vermelho, verde e azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr√™s configura√ß√µes de mapa splat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usaremos essas configura√ß√µes de mapa splat, independentemente de quais texturas realmente se misturam. </font><font style="vertical-align: inherit;">Ou seja, o mapa splat sempre ser√° o mesmo. </font><font style="vertical-align: inherit;">Somente as texturas ser√£o alteradas. </font><font style="vertical-align: inherit;">Como fazer isso, descobriremos mais adiante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos mudar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar esses mapas de splat, em vez de usar cores de c√©lula. </font><font style="vertical-align: inherit;">Como geralmente usamos tr√™s cores, criaremos campos est√°ticos para elas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centros celulares </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar substituindo a cor do centro das c√©lulas por padr√£o. </font><font style="vertical-align: inherit;">Nenhuma mistura √© feita aqui, ent√£o usamos apenas a primeira cor, ou seja, vermelho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centros vermelhos de c√©lulas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os centros celulares agora ficam vermelhos. </font><font style="vertical-align: inherit;">Todos eles usam a primeira das tr√™s texturas, independentemente da textura. </font><font style="vertical-align: inherit;">Seus mapas de splat s√£o os mesmos, independentemente da cor com a qual colorimos as c√©lulas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bairro do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudamos de segmento apenas dentro das c√©lulas sem rios fluindo ao longo deles. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo para os segmentos adjacentes aos rios. </font><font style="vertical-align: inherit;">No nosso caso, isso √© uma tira de costela e um leque de tri√¢ngulos da costela. </font><font style="vertical-align: inherit;">Aqui tamb√©m apenas o vermelho √© suficiente para n√≥s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentos vermelhos adjacentes aos rios.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos cuidar da geometria dos rios dentro das c√©lulas. </font><font style="vertical-align: inherit;">Todos eles tamb√©m devem ficar vermelhos. </font><font style="vertical-align: inherit;">Para come√ßar, vamos dar uma olhada no come√ßo e no fim dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ent√£o a geometria que comp√µe as margens e o leito do rio. </font><font style="vertical-align: inherit;">Agrupei as chamadas do m√©todo de cores para facilitar a leitura do c√≥digo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios vermelhos ao longo das celas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costelas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as arestas s√£o diferentes porque est√£o entre c√©lulas que podem ter diferentes tipos de terreno. </font><font style="vertical-align: inherit;">Usamos a primeira cor para o tipo de c√©lula atual e a segunda cor para o tipo vizinho. </font><font style="vertical-align: inherit;">Como resultado, o mapa de splat se tornar√° um gradiente vermelho-verde, mesmo se as duas c√©lulas forem do mesmo tipo. </font><font style="vertical-align: inherit;">Se as duas c√©lulas usarem a mesma textura, ela se tornar√° uma mistura da mesma textura nos dois lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costelas verde-avermelhadas, exceto bordas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A transi√ß√£o acentuada entre vermelho e verde n√£o causaria problemas?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As arestas com as bordas s√£o um pouco mais complicadas, porque possuem v√©rtices adicionais. </font><font style="vertical-align: inherit;">Felizmente, o c√≥digo de interpola√ß√£o existente funciona muito bem com cores de mapa splat. </font><font style="vertical-align: inherit;">Basta usar a primeira e a segunda cores, n√£o as cores das c√©lulas do come√ßo e do fim.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas verde-avermelhadas das costelas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Çngulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os √¢ngulos das c√©lulas s√£o os mais dif√≠ceis porque precisam misturar tr√™s texturas diferentes. </font><font style="vertical-align: inherit;">Usamos vermelho para o pico inferior, verde para a esquerda e azul para a direita. </font><font style="vertical-align: inherit;">Vamos come√ßar com os cantos de um tri√¢ngulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cantos vermelho-verde-azul, exceto para bordas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, podemos novamente usar o c√≥digo de interpola√ß√£o de cores existente para cantos com bordas. </font><font style="vertical-align: inherit;">Apenas a interpola√ß√£o √© feita entre tr√™s e n√£o duas cores. </font><font style="vertical-align: inherit;">Primeiro, considere as bordas que n√£o est√£o pr√≥ximas dos penhascos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas de canto vermelho-verde-azul, exceto bordas ao longo de fal√©sias. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando se trata de fal√©sias, precisamos usar um m√©todo </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo recebeu as c√©lulas inicial e esquerda como par√¢metros. </font><font style="vertical-align: inherit;">No entanto, agora precisamos das cores splat apropriadas, que podem variar dependendo da topologia. </font><font style="vertical-align: inherit;">Portanto, substitu√≠mos esses par√¢metros por cores.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere-o </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele use as cores corretas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E fa√ßa o mesmo por </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa de relevo completo splat. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrizes de textura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que nosso terreno possui um mapa de splat, podemos passar a cole√ß√£o de texturas para o shader. </font><font style="vertical-align: inherit;">N√£o podemos apenas atribuir um sombreador a uma matriz de texturas em C #, porque a matriz deve existir na mem√≥ria da GPU como uma √∫nica entidade. </font><font style="vertical-align: inherit;">Teremos que usar um objeto especial </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que √© suportado no Unity desde a vers√£o 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as GPUs suportam matrizes de textura?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li> PlayStation 4 </li></ul></div></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mestre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, o suporte do Unity para matrizes de textura na vers√£o 5.5 √© m√≠nimo. </font><font style="vertical-align: inherit;">N√£o podemos apenas criar um recurso de matriz de textura e atribuir texturas a ele. </font><font style="vertical-align: inherit;">Temos que fazer isso manualmente. </font><font style="vertical-align: inherit;">Podemos criar uma matriz de texturas no modo Reproduzir ou criar um ativo no editor. </font><font style="vertical-align: inherit;">Vamos criar um ativo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que criar um ativo?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma variedade de texturas, montaremos nosso pr√≥prio mestre. </font><font style="vertical-align: inherit;">Crie um script </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e coloque-o dentro da pasta </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em vez disso, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele deve estender o tipo </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do espa√ßo para nome </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir o assistente atrav√©s de um m√©todo est√°tico generalizado </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seus par√¢metros s√£o os nomes da janela do assistente e seu bot√£o de cria√ß√£o. </font><font style="vertical-align: inherit;">Vamos chamar esse m√©todo em um m√©todo est√°tico </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para acessar o assistente atrav√©s do editor, precisamos adicionar esse m√©todo ao menu do Unity. </font><font style="vertical-align: inherit;">Isto pode ser feito atrav√©s da adi√ß√£o de um atributo para o m√©todo </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos adicion√°-lo ao menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ativos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e mais especificamente √† </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz Ativos / Criar / Textura</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso assistente personalizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o novo item de menu, voc√™ pode abrir o menu pop-up do nosso assistente personalizado. </font><font style="vertical-align: inherit;">N√£o √© muito bonito, mas adequado para resolver o problema. </font><font style="vertical-align: inherit;">No entanto, ainda est√° vazio. </font><font style="vertical-align: inherit;">Para criar uma matriz de texturas, precisamos de uma matriz de texturas. </font><font style="vertical-align: inherit;">Adicione um campo geral a ele para o mestre. </font><font style="vertical-align: inherit;">A GUI padr√£o do assistente a exibe como um inspetor padr√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mestre com texturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos criar algo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando voc√™ clica no bot√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">assistente, ele desaparece. </font><font style="vertical-align: inherit;">Al√©m disso, a Unity reclama que n√£o h√° m√©todo </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esse √© o m√©todo que √© chamado quando o bot√£o de cria√ß√£o √© clicado, portanto, precisamos adicion√°-lo ao assistente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vamos criar nossa matriz de texturas. </font><font style="vertical-align: inherit;">Pelo menos se o usu√°rio adicionasse texturas ao mestre. </font><font style="vertical-align: inherit;">Caso contr√°rio, n√£o h√° nada para criar e o trabalho precisa ser interrompido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pr√≥xima etapa √© solicitar o local para salvar o ativo da matriz de textura. </font><font style="vertical-align: inherit;">Salve o arquivo de painel pode ser aberto por </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seus par√¢metros definem o nome do painel, o nome do arquivo padr√£o, a extens√£o e a descri√ß√£o do arquivo. </font><font style="vertical-align: inherit;">Matrizes de textura usam a extens√£o de arquivo do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ativo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geral </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o caminho do arquivo selecionado pelo usu√°rio. </font><font style="vertical-align: inherit;">Se o usu√°rio clicar em cancelar neste painel, o caminho ser√° uma sequ√™ncia vazia. </font><font style="vertical-align: inherit;">Portanto, neste caso, devemos interromper o trabalho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando uma matriz de texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se tivermos o caminho certo, podemos seguir em frente e criar um novo objeto </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seu m√©todo construtor requer a especifica√ß√£o da largura e altura da textura, o comprimento da matriz, o formato das texturas e a necessidade de texturas mip. </font><font style="vertical-align: inherit;">Esses par√¢metros devem ser os mesmos para todas as texturas na matriz. </font><font style="vertical-align: inherit;">Para configurar o objeto, usamos a primeira textura. </font><font style="vertical-align: inherit;">O usu√°rio deve verificar se todas as texturas t√™m o mesmo formato.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a matriz de textura √© um √∫nico recurso da GPU, ela usa os mesmos modos de filtragem e dobra para todas as texturas. </font><font style="vertical-align: inherit;">Aqui, novamente usamos a primeira textura para configurar tudo.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos copiar a textura de uma matriz usando o m√©todo </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O m√©todo copia dados brutos de textura, um n√≠vel mip por vez. </font><font style="vertical-align: inherit;">Portanto, precisamos percorrer todas as texturas e seus n√≠veis de mip. </font><font style="vertical-align: inherit;">Os par√¢metros do m√©todo s√£o dois conjuntos que consistem em um recurso de textura, um √≠ndice e um n√≠vel mip. </font><font style="vertical-align: inherit;">Como as texturas originais n√£o s√£o matrizes, seu √≠ndice √© sempre zero.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, temos na mem√≥ria a matriz correta de texturas, mas ainda n√£o √© um ativo. </font><font style="vertical-align: inherit;">O passo final ser√° chamar </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a matriz e seu caminho. </font><font style="vertical-align: inherit;">Nesse caso, os dados ser√£o gravados em um arquivo em nosso projeto e aparecer√£o na janela do projeto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { ‚Ä¶ } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma variedade real de texturas, precisamos das texturas originais. Aqui est√£o cinco texturas que correspondem √†s cores que usamos at√© agora. Amarelo se torna areia, verde se torna grama, azul se torna terra, laranja se torna pedra e branco se torna neve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturas de areia, grama, terra, pedra e neve. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que essas texturas n√£o s√£o fotografias desse relevo. </font><font style="vertical-align: inherit;">Estes s√£o os padr√µes pseudo-aleat√≥rios f√°ceis que eu criei usando o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu me esforcei para criar tipos e detalhes de relevo reconhec√≠veis que n√£o entrem em conflito com o relevo poligonal abstrato. </font><font style="vertical-align: inherit;">O fotorrealismo acabou sendo inadequado para isso. </font><font style="vertical-align: inherit;">Al√©m disso, embora os padr√µes acrescentem variabilidade, existem poucos recursos distintos que tornariam as repeti√ß√µes imediatamente percept√≠veis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione essas texturas √† matriz principal, certificando-se de que a ordem delas corresponda √†s cores. </font><font style="vertical-align: inherit;">Ou seja, primeiro areia, depois grama, terra, pedra e finalmente neve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando uma matriz de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s criar o ativo da matriz de textura, selecione-o e examine-o no inspetor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspetor de matriz de textura.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa √© a exibi√ß√£o mais simples de uma parte dos dados da matriz de textura. Observe que h√° uma op√ß√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â leg√≠vel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que est√° ativada inicialmente. Como n√£o precisamos ler dados de pixel da matriz, desative-os. N√£o podemos fazer isso no assistente, porque n√£o existem </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todos ou propriedades para acessar esse par√¢metro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(No Unity 5.6, existe um erro que estraga as matrizes de textura em montagens em v√°rias plataformas. Voc√™ pode contorn√°-lo sem desabilitar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â leg√≠vel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m √© importante notar que existe um campo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espa√ßo de cor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao qual √© atribu√≠do o valor 1. Isso significa que as texturas s√£o assumidas como estando no espa√ßo gama, o que √© verdadeiro. </font><font style="vertical-align: inherit;">Se eles deveriam estar no espa√ßo linear, o campo precisava receber o valor 0. Na verdade, o designer </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui um par√¢metro adicional para especificar o espa√ßo de cores, mas </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o mostra se est√° no espa√ßo linear ou n√£o; portanto, em qualquer caso, √© necess√°rio definir valor manualmente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos uma variedade de texturas, precisamos ensinar ao shader como trabalhar com ele. </font><font style="vertical-align: inherit;">Por enquanto, usamos o sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para renderizar o terreno </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como agora usaremos texturas em vez de cores, renomeie-o para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em seguida, transformamos seu par√¢metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em uma matriz de texturas e atribu√≠mos a ele um ativo.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material de al√≠vio com uma variedade de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para habilitar matrizes de textura em todas as plataformas que as suportam, voc√™ precisa aumentar o n√≠vel de destino do shader de 3.0 para 3.5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a vari√°vel </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora se refere a uma matriz de texturas, precisamos alterar seu tipo. </font><font style="vertical-align: inherit;">O tipo depende da plataforma de destino e a macro cuidar√° disso </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como em outros shaders, para provar a textura do relevo, precisamos das coordenadas do mundo XZ. </font><font style="vertical-align: inherit;">Portanto, adicionaremos uma posi√ß√£o no mundo √† estrutura de entrada do shader de superf√≠cie. </font><font style="vertical-align: inherit;">Tamb√©m exclu√≠mos as coordenadas UV padr√£o, porque n√£o precisamos delas.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para provar uma variedade de texturas, precisamos usar uma macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para provar uma matriz, ela precisa de tr√™s coordenadas. </font><font style="vertical-align: inherit;">Os dois primeiros s√£o coordenadas UV regulares. </font><font style="vertical-align: inherit;">Usaremos as coordenadas do mundo XZ na escala de 0,02. </font><font style="vertical-align: inherit;">Portanto, obtemos uma boa resolu√ß√£o de textura com amplia√ß√£o total. </font><font style="vertical-align: inherit;">As texturas ser√£o repetidas aproximadamente a cada quatro c√©lulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A terceira coordenada √© usada como o √≠ndice da matriz de texturas, como em uma matriz regular. </font><font style="vertical-align: inherit;">Como as coordenadas s√£o flutuantes, antes da indexa√ß√£o, a matriz da GPU as arredonda. </font><font style="vertical-align: inherit;">At√© que saibamos que textura √© necess√°ria, vamos sempre usar a primeira. </font><font style="vertical-align: inherit;">Al√©m disso, a cor do v√©rtice n√£o afetar√° o resultado final, porque √© um mapa de splat.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo se tornou areia. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o de textura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos de um mapa de relevo que mistura os tr√™s tipos em um tri√¢ngulo. </font><font style="vertical-align: inherit;">Temos uma variedade de texturas com uma textura para cada tipo de terreno. </font><font style="vertical-align: inherit;">Temos um shader que mostra uma variedade de texturas. </font><font style="vertical-align: inherit;">Mas, por enquanto, n√£o temos como dizer ao sombreador quais texturas escolher para cada tri√¢ngulo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como cada tri√¢ngulo combina at√© tr√™s tipos, precisamos associar tr√™s √≠ndices a cada tri√¢ngulo. </font><font style="vertical-align: inherit;">Como n√£o podemos armazenar informa√ß√µes para tri√¢ngulos, precisamos armazenar √≠ndices para v√©rtices. </font><font style="vertical-align: inherit;">Todos os tr√™s v√©rtices do tri√¢ngulo simplesmente armazenam os mesmos √≠ndices da cor s√≥lida.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dados de malhas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar um dos conjuntos da malha UV para armazenar √≠ndices. </font><font style="vertical-align: inherit;">Como tr√™s √≠ndices s√£o armazenados em cada v√©rtice, os conjuntos de 2D UV existentes n√£o ser√£o suficientes. </font><font style="vertical-align: inherit;">Felizmente, os conjuntos de UV podem conter at√© quatro coordenadas. </font><font style="vertical-align: inherit;">Portanto, adicionamos √† </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √† qual nos referiremos como tipos de al√≠vio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ative os tipos de terreno para o </font><font style="vertical-align: inherit;">filho do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da pr√©-fabricada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos tipos de al√≠vio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se necess√°rio, faremos outra lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para os tipos de relevo durante a limpeza da malha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No processo de aplica√ß√£o dos dados da malha, salvamos os tipos de relevo no terceiro conjunto de UV. </font><font style="vertical-align: inherit;">Por isso, eles n√£o entrar√£o em conflito com outros dois conjuntos, se decidirmos us√°-los juntos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para definir os tipos de relevo do tri√¢ngulo, usaremos </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como os mesmos s√£o iguais para todo o tri√¢ngulo, apenas adicionamos os mesmos dados tr√™s vezes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misturar em quad funciona da mesma maneira. </font><font style="vertical-align: inherit;">Todos os quatro v√©rtices s√£o do mesmo tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√£s de Tri√¢ngulos de Costelas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos adicionar tipos aos dados da malha </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos come√ßar com </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, para melhor legibilidade, vamos separar as chamadas para os m√©todos de v√©rtice e cor. </font><font style="vertical-align: inherit;">Lembre-se de que a cada chamada para esse m√©todo, a passamos para ele </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que possamos usar essa cor diretamente e n√£o aplicar o par√¢metro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s as cores, adicionamos tipos de relevo. </font><font style="vertical-align: inherit;">Como os tipos no tri√¢ngulo podem ser diferentes, esse deve ser um par√¢metro que substitui a cor. </font><font style="vertical-align: inherit;">Use este tipo simples para criar </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas os quatro primeiros canais s√£o importantes para n√≥s, porque nesse caso o mapa splat √© sempre vermelho. </font><font style="vertical-align: inherit;">Como todos os tr√™s componentes do vetor precisam ser atribu√≠dos, vamos atribuir a eles um tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, precisamos alterar todas as chamadas para esse m√©todo, substituindo o argumento de cores por um √≠ndice do tipo de terreno da c√©lula. </font><font style="vertical-align: inherit;">Vnesom esta mudan√ßa </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, quando voc√™ inicia o modo de reprodu√ß√£o, ser√£o exibidos erros informando que os terceiros conjuntos de malhas UV est√£o fora dos limites. </font><font style="vertical-align: inherit;">Isso aconteceu porque ainda n√£o adicionamos tipos de relevo a cada tri√¢ngulo e quad. </font><font style="vertical-align: inherit;">Ent√£o, vamos continuar a mudar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listras de costela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, ao criar uma faixa de aresta, precisamos saber que tipos de terreno existem nos dois lados. </font><font style="vertical-align: inherit;">Portanto, n√≥s os adicionamos como par√¢metros e, em seguida, criamos um vetor de tipos cujos dois canais s√£o atribu√≠dos a esses tipos. </font><font style="vertical-align: inherit;">O terceiro canal n√£o √© importante, apenas o iguale ao primeiro. </font><font style="vertical-align: inherit;">Depois de adicionar as cores, adicione os tipos ao quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos mudar os desafios </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve usar o tipo de c√©lula para ambos os lados da tira da costela.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, o caso mais simples de uma aresta </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve usar o tipo de c√©lula para a aresta mais pr√≥xima e o tipo vizinho para a aresta mais distante. </font><font style="vertical-align: inherit;">Eles podem ser iguais ou diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mesmo se aplica </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√†quilo que desencadeia tr√™s vezes </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Os tipos para as bordas s√£o os mesmos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Çngulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O caso mais simples de um √¢ngulo √© um tri√¢ngulo simples. </font><font style="vertical-align: inherit;">A c√©lula inferior transfere o primeiro tipo, o esquerdo o segundo e o direito o terceiro. </font><font style="vertical-align: inherit;">Usando-os, crie um vetor de tipos e adicione-o ao tri√¢ngulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos a mesma abordagem </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apenas aqui criamos um grupo de quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao misturar bordas e fal√©sias, precisamos usar </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas d√™ a ele um par√¢metro de vetor de tipo e adicione-o a todos os seus tri√¢ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria√ß√£o de vector com base nos tipos de c√©lulas transmitidas. </font><font style="vertical-align: inherit;">Em seguida, adicione-o a um tri√¢ngulo e passe </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mesmo vale para </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫ltimo m√©todo para mudar √© este </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como aqui estamos no centro da c√©lula, estamos lidando apenas com o tipo da c√©lula atual. </font><font style="vertical-align: inherit;">Portanto, crie um vetor para ele e adicione-o a tri√¢ngulos e quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo de mistura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, as malhas cont√™m os √≠ndices de eleva√ß√£o necess√°rios. </font><font style="vertical-align: inherit;">Tudo o que resta para n√≥s √© for√ßar o shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font><font style="vertical-align: inherit;">us√°-los. </font><font style="vertical-align: inherit;">Para que os √≠ndices caiam no shader de fragmento, primeiro precisamos pass√°-los pelo shader de v√©rtice. </font><font style="vertical-align: inherit;">Podemos fazer isso em nossa pr√≥pria fun√ß√£o de v√©rtice, como fizemos no sombreador do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estu√°rio</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesse caso, adicionamos um campo √† estrutura de entrada </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e copiamos para ela </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos amostrar a matriz de textura tr√™s vezes por fragmento. </font><font style="vertical-align: inherit;">Portanto, vamos criar uma fun√ß√£o conveniente para criar coordenadas de textura, amostrar uma matriz e modular uma amostra com um mapa de splat para um √≠ndice.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos trabalhar com um vetor como uma matriz?</font></font></b> <div class="spoiler_text">  Sim   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando esta fun√ß√£o, podemos simplesmente amostrar a matriz de textura tr√™s vezes e combinar os resultados. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relevo texturizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos pintar o relevo com texturas. </font><font style="vertical-align: inherit;">Eles se misturam como cores s√≥lidas. </font><font style="vertical-align: inherit;">Como usamos as coordenadas mundiais como coordenadas UV, elas n√£o mudam com a altura. </font><font style="vertical-align: inherit;">Como resultado, ao longo de penhascos afiados, as texturas s√£o esticadas. </font><font style="vertical-align: inherit;">Se as texturas forem bastante neutras e muito vari√°veis, os resultados ser√£o aceit√°veis. </font><font style="vertical-align: inherit;">Caso contr√°rio, temos grandes estrias feias. </font><font style="vertical-align: inherit;">Voc√™ pode tentar ocult√°-lo com geometria ou textura adicional de fal√©sias, mas no tutorial n√£o faremos isso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando usarmos texturas em vez de cores, ser√° l√≥gico alterar o painel do editor. </font><font style="vertical-align: inherit;">Podemos criar uma interface bonita que pode at√© exibir texturas de relevo, mas vou me concentrar nas abrevia√ß√µes que correspondem ao estilo do esquema existente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op√ß√µes de al√≠vio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, a </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade color n√£o √© mais necess√°ria, portanto exclua-a.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m pode remover uma matriz de cores e c√≥digo associado.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ ‚Ä¶ void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, tamb√©m n√£o √© necess√°rio um conjunto de cores </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 15: dist√¢ncias </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exiba as linhas da grade. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterne entre os modos de edi√ß√£o e navega√ß√£o. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calcule a dist√¢ncia entre as c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s encontramos maneiras de contornar obst√°culos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Levamos em conta os custos vari√°veis ‚Äã‚Äãda mudan√ßa. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tendo criado mapas de alta qualidade, iniciaremos a navega√ß√£o. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O caminho mais curto nem sempre √© reto.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grade de exibi√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A navega√ß√£o no mapa √© realizada movendo de c√©lula para c√©lula. </font><font style="vertical-align: inherit;">Para chegar a algum lugar, voc√™ precisa passar por uma s√©rie de c√©lulas. </font><font style="vertical-align: inherit;">Para facilitar a estimativa de dist√¢ncias, vamos adicionar a op√ß√£o de exibir a grade hexagonal na qual nosso mapa se baseia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textura de malha </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar das irregularidades da malha do mapa, a malha subjacente √© perfeitamente plana. </font><font style="vertical-align: inherit;">Podemos mostrar isso projetando um padr√£o de grade em um mapa. </font><font style="vertical-align: inherit;">Isso pode ser conseguido usando uma textura de malha repetida.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetindo a textura da malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A textura mostrada acima cont√©m uma pequena parte da grade hexagonal cobrindo 2 por 2 c√©lulas. </font><font style="vertical-align: inherit;">Esta √°rea √© retangular, n√£o quadrada. </font><font style="vertical-align: inherit;">Como a textura em si √© um quadrado, o padr√£o parece esticado. </font><font style="vertical-align: inherit;">Ao amostrar, precisamos compensar isso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proje√ß√£o em grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para projetar um padr√£o de malha, precisamos adicionar </font><font style="vertical-align: inherit;">uma propriedade de textura ao </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material de al√≠vio com textura de malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prove a textura usando as coordenadas XZ do mundo e multiplique-a por albedo. </font><font style="vertical-align: inherit;">Como as linhas de grade da textura s√£o cinza, isso entrela√ßa o padr√£o no relevo.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo multiplicado por malha fina. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos escalar o padr√£o para que ele corresponda √†s c√©lulas no mapa. </font><font style="vertical-align: inherit;">A dist√¢ncia entre os centros das c√©lulas vizinhas √© 15, ela precisa ser dobrada para subir duas c√©lulas. </font><font style="vertical-align: inherit;">Ou seja, precisamos dividir as coordenadas da grade V por 30. O raio interno das c√©lulas √© 5‚àö3 e, para mover duas c√©lulas para a direita, precisamos de quatro vezes mais. </font><font style="vertical-align: inherit;">Portanto, √© necess√°rio dividir as coordenadas da grade U por 20‚àö3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tamanho de malha correto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora as linhas da grade correspondem √†s c√©lulas do mapa. </font><font style="vertical-align: inherit;">Como texturas de relevo, eles ignoram a altura, de modo que as linhas ser√£o esticadas ao longo dos penhascos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proje√ß√£o em c√©lulas com altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A deforma√ß√£o da malha geralmente n√£o √© t√£o ruim, especialmente quando se olha para um mapa a longa dist√¢ncia.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malha √† dist√¢ncia.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclus√£o de grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora exibir uma grade seja conveniente, nem sempre √© necess√°rio. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ deve desativ√°-lo quando tirar uma captura de tela. </font><font style="vertical-align: inherit;">Al√©m disso, nem todo mundo prefere ver a grade constantemente. </font><font style="vertical-align: inherit;">Ent√£o, vamos torn√°-lo opcional. </font><font style="vertical-align: inherit;">Adicionaremos a diretiva multi_compile ao shader para criar op√ß√µes com e sem uma grade. </font><font style="vertical-align: inherit;">Para fazer isso, usamos a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A compila√ß√£o condicional de sombreador √© descrita no tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5, Multiple Lights</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao declarar uma vari√°vel, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro atribu√≠mos a ela um valor 1. Como resultado, a grade ser√° desativada. </font><font style="vertical-align: inherit;">Em seguida, amostraremos a textura da grade apenas para a variante com uma palavra-chave espec√≠fica </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">est√° </font><font style="vertical-align: inherit;">inclu√≠da no sombreador de terreno, a grade desaparecer√°. </font><font style="vertical-align: inherit;">Para habilit√°-lo novamente, adicionaremos uma op√ß√£o √† interface do usu√°rio do editor de mapas. </font><font style="vertical-align: inherit;">Para tornar isso poss√≠vel, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preciso obter um link para o material do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e um m√©todo para ativar ou desativar a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de hex√°gonos de mar√ßo com refer√™ncia ao material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um comutador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grade</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† interface do usu√°rio </font><font style="vertical-align: inherit;">e conecte-o ao m√©todo </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor de grade.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvar estado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no modo Play, podemos mudar a exibi√ß√£o da grade. </font><font style="vertical-align: inherit;">No primeiro teste, a grade √© inicialmente desligada e fica vis√≠vel quando ligamos o interruptor. </font><font style="vertical-align: inherit;">Quando voc√™ o desliga, a grade desaparece novamente. </font><font style="vertical-align: inherit;">No entanto, se sairmos do modo de reprodu√ß√£o quando a grade estiver vis√≠vel, na pr√≥xima vez que voc√™ iniciar o modo de reprodu√ß√£o, ele ser√° ativado novamente, embora o interruptor esteja desligado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso ocorre porque estamos alterando a palavra-chave para o material geral do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como estamos editando o ativo do material, a altera√ß√£o √© salva no editor do Unity. </font><font style="vertical-align: inherit;">N√£o ser√° salvo na montagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para sempre iniciar o jogo sem uma grade, desabilitaremos a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desperta </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modo de edi√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se queremos controlar o movimento no mapa, precisamos interagir com ele. </font><font style="vertical-align: inherit;">No m√≠nimo, precisamos selecionar a c√©lula como o ponto de partida do caminho. </font><font style="vertical-align: inherit;">Mas quando voc√™ clica em uma c√©lula, ela ser√° editada. </font><font style="vertical-align: inherit;">Podemos desativar todas as op√ß√µes de edi√ß√£o manualmente, mas isso √© inconveniente. </font><font style="vertical-align: inherit;">Al√©m disso, n√£o queremos que os c√°lculos de deslocamento sejam executados durante a edi√ß√£o do mapa. </font><font style="vertical-align: inherit;">Ent√£o, vamos adicionar uma op√ß√£o que determina se estamos no modo de edi√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interruptor de edi√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo booleano </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bem como o m√©todo que o define. </font><font style="vertical-align: inherit;">Em seguida, adicione outra op√ß√£o √† interface do usu√°rio para control√°-la. </font><font style="vertical-align: inherit;">Vamos come√ßar com o modo de navega√ß√£o, ou seja, o modo de edi√ß√£o ser√° desativado por padr√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor do modo de edi√ß√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realmente desativar a edi√ß√£o, fa√ßa a chamada </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depender </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etiquetas de depura√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© o momento, n√£o temos unidades para percorrer o mapa. </font><font style="vertical-align: inherit;">Em vez disso, visualizamos as dist√¢ncias de movimento. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ pode usar r√≥tulos de c√©lulas existentes. </font><font style="vertical-align: inherit;">Portanto, os tornaremos vis√≠veis quando o modo de edi√ß√£o estiver desativado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como come√ßamos com o modo de navega√ß√£o, os r√≥tulos padr√£o devem estar ativados. </font><font style="vertical-align: inherit;">Atualmente os </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desativa, mas ele n√£o deve mais fazer isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≥tulos de coordenadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As coordenadas das c√©lulas agora ficam vis√≠veis imediatamente ap√≥s o in√≠cio do modo Play. </font><font style="vertical-align: inherit;">Mas n√£o precisamos de coordenadas, usamos r√≥tulos para exibir dist√¢ncias. </font><font style="vertical-align: inherit;">Como isso requer apenas um n√∫mero por c√©lula, voc√™ pode aumentar o tamanho da fonte para que eles possam ser lidos melhor. </font><font style="vertical-align: inherit;">Altere a pr√©-fabricada do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ele use fonte em negrito com tamanho 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags com tamanho de fonte em negrito 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, depois de iniciar o modo Play, veremos tags grandes. </font><font style="vertical-align: inherit;">Somente as primeiras coordenadas da c√©lula s√£o vis√≠veis, o restante n√£o √© colocado no r√≥tulo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags grandes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como n√£o precisamos mais das coordenadas, excluiremos o </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font><font style="vertical-align: inherit;">na </font><font style="vertical-align: inherit;">atribui√ß√£o </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tamb√©m pode remover a op√ß√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seu m√©todo associado </font><font style="vertical-align: inherit;">da interface do usu√°rio </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mudan√ßa de m√©todo n√£o existe mais. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrando dist√¢ncias </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos o modo de navega√ß√£o marcado, podemos come√ßar a exibir dist√¢ncias. </font><font style="vertical-align: inherit;">Selecionaremos uma c√©lula e, em seguida, exibiremos a dist√¢ncia dessa c√©lula para todas as c√©lulas no mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibi√ß√£o dist√¢ncia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para rastrear a dist√¢ncia at√© a c√©lula, adicione ao </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo inteiro </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso indicar√° a dist√¢ncia entre esta c√©lula e a selecionada. </font><font style="vertical-align: inherit;">Portanto, para a c√©lula selecionada em si, ser√° zero, para o vizinho imediato √© 1 e assim por diante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a dist√¢ncia √© definida, devemos atualizar o r√≥tulo da c√©lula para exibir seu valor. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem uma refer√™ncia ao </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto de interface </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">usu√°rio. </font><font style="vertical-align: inherit;">Precisamos ligar </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">ele </font><font style="vertical-align: inherit;">para chegar ao celular. </font><font style="vertical-align: inherit;">Considere o que </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√° no espa√ßo </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">nome </font><font style="vertical-align: inherit;">, portanto, use-o no in√≠cio do script.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o devemos manter um link direto para o componente Texto?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos definir a propriedade geral para receber e definir a dist√¢ncia para a c√©lula, al√©m de atualizar seu r√≥tulo. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo geral </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o par√¢metro cell. </font><font style="vertical-align: inherit;">Por enquanto, simplesmente definiremos a dist√¢ncia zero para cada c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o modo de edi√ß√£o n√£o estiver ativado, </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamaremos um novo m√©todo com a c√©lula atual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dist√¢ncias entre coordenadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no modo de navega√ß√£o, depois de tocar em um deles, todas as c√©lulas exibem zero. </font><font style="vertical-align: inherit;">Mas, √© claro, eles devem exibir a verdadeira dist√¢ncia da c√©lula. </font><font style="vertical-align: inherit;">Para calcular a dist√¢ncia at√© eles, podemos usar as coordenadas da c√©lula. </font><font style="vertical-align: inherit;">Portanto, suponha que ele </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenha um m√©todo </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e use-o </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora adicione ao </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele deve comparar suas pr√≥prias coordenadas com as de outro conjunto. </font><font style="vertical-align: inherit;">Vamos come√ßar apenas medindo X e subtrairemos as coordenadas X uma da outra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtemos um deslocamento ao longo de X em rela√ß√£o √† c√©lula selecionada. </font><font style="vertical-align: inherit;">Como as dist√¢ncias n√£o podem ser negativas, √© necess√°rio retornar a diferen√ßa de coordenadas X m√≥dulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist√¢ncias ao longo de X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portanto, s√≥ obtemos as dist√¢ncias corretas se considerarmos apenas uma dimens√£o. </font><font style="vertical-align: inherit;">Mas existem tr√™s dimens√µes em uma grade de hex√°gonos. </font><font style="vertical-align: inherit;">Ent√£o, vamos somar as dist√¢ncias para todas as tr√™s dimens√µes e ver o que isso nos d√°.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soma das dist√¢ncias XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que temos o dobro da dist√¢ncia. </font><font style="vertical-align: inherit;">Ou seja, para obter a dist√¢ncia correta, esse valor deve ser dividido pela metade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist√¢ncias reais.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a soma √© igual ao dobro da dist√¢ncia?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, ‚àí3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trabalhe com obst√°culos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As dist√¢ncias calculadas por n√≥s correspondem aos caminhos mais curtos da c√©lula selecionada para a outra c√©lula. </font><font style="vertical-align: inherit;">N√£o podemos encontrar um caminho mais curto. </font><font style="vertical-align: inherit;">Mas √© garantido que esses caminhos estejam corretos se a rota n√£o bloquear nada. </font><font style="vertical-align: inherit;">Fal√©sias, √°gua e outros obst√°culos podem nos fazer girar. </font><font style="vertical-align: inherit;">Talvez algumas c√©lulas n√£o possam ser alcan√ßadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar uma maneira de contornar obst√°culos, precisamos usar uma abordagem diferente em vez de simplesmente calcular a dist√¢ncia entre as coordenadas. </font><font style="vertical-align: inherit;">N√£o podemos mais examinar cada c√©lula individualmente. </font><font style="vertical-align: inherit;">Teremos que procurar no mapa at√© encontrar todas as c√©lulas que podem ser alcan√ßadas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualiza√ß√£o de pesquisa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesquisa de mapa √© um processo iterativo. </font><font style="vertical-align: inherit;">Para entender o que estamos fazendo, seria √∫til ver cada est√°gio da pesquisa. </font><font style="vertical-align: inherit;">Podemos fazer isso transformando o algoritmo de pesquisa em uma rotina, para a qual precisamos de um espa√ßo de pesquisa </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A taxa de atualiza√ß√£o de 60 itera√ß√µes por segundo √© pequena o suficiente para vermos o que est√° acontecendo, e a pesquisa em um pequeno mapa n√£o demorou muito tempo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos garantir que apenas uma pesquisa esteja ativa a qualquer momento. </font><font style="vertical-align: inherit;">Portanto, antes de iniciar uma nova pesquisa, paramos todas as corotinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al√©m disso, precisamos concluir a pesquisa ao carregar um novo mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primeira pesquisa de largura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo antes de iniciar a pesquisa, sabemos que a dist√¢ncia para a c√©lula selecionada √© zero. E, √© claro, a dist√¢ncia para todos os seus vizinhos √© 1, se puderem ser alcan√ßados. Ent√£o podemos dar uma olhada em um desses vizinhos. Essa c√©lula provavelmente tem seus pr√≥prios vizinhos que podem ser alcan√ßados e para os quais a dist√¢ncia ainda n√£o foi calculada. Nesse caso, a dist√¢ncia para esses vizinhos deve ser 2. Podemos repetir esse processo para todos os vizinhos a uma dist√¢ncia de 1. Depois disso, repetimos para todos os vizinhos a uma dist√¢ncia de 2. E assim por diante, at√© atingirmos todas as c√©lulas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, primeiro encontramos todas as c√©lulas a uma dist√¢ncia de 1, depois encontramos tudo a uma dist√¢ncia de 2, depois a uma dist√¢ncia de 3 e assim por diante, at√© terminarmos. </font><font style="vertical-align: inherit;">Isso garante que encontramos a menor dist√¢ncia para cada c√©lula acess√≠vel. </font><font style="vertical-align: inherit;">Esse algoritmo √© chamado de busca pela primeira vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que funcione, precisamos saber se j√° determinamos a dist√¢ncia da c√©lula. </font><font style="vertical-align: inherit;">Muitas vezes, para isso, as c√©lulas s√£o colocadas em uma cole√ß√£o chamada conjunto pronto ou fechado. </font><font style="vertical-align: inherit;">Mas podemos definir a dist√¢ncia da c√©lula </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar que ainda n√£o a visitamos. </font><font style="vertical-align: inherit;">Precisamos fazer isso para todas as c√©lulas antes de realizar uma pesquisa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tamb√©m pode usar isso para ocultar todas as c√©lulas n√£o visitadas, alterando </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Depois disso, iniciaremos cada pesquisa em um mapa em branco.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos rastrear as c√©lulas que precisam ser visitadas e a ordem em que elas s√£o visitadas. </font><font style="vertical-align: inherit;">Essa cole√ß√£o geralmente √© chamada de borda ou conjunto aberto. </font><font style="vertical-align: inherit;">N√≥s apenas precisamos processar as c√©lulas na mesma ordem em que as encontramos. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ pode usar a fila </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que faz parte do espa√ßo para nome </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A c√©lula selecionada ser√° a primeira a ser colocada nessa fila e ter√° uma dist√¢ncia de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir deste momento, o algoritmo executa o loop enquanto houver algo na fila. </font><font style="vertical-align: inherit;">A cada itera√ß√£o, a c√©lula da frente √© recuperada da fila.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos a c√©lula atual, que pode estar a qualquer dist√¢ncia. </font><font style="vertical-align: inherit;">Em seguida, precisamos adicionar todos os seus vizinhos √† fila um passo al√©m da c√©lula selecionada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas devemos adicionar apenas as c√©lulas que ainda n√£o receberam uma dist√¢ncia. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa ampla.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite a √°gua </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de garantir que a primeira pesquisa de largura encontre as dist√¢ncias corretas no mapa mon√≥tono, podemos come√ßar a adicionar obst√°culos. </font><font style="vertical-align: inherit;">Isso pode ser feito recusando-se a adicionar c√©lulas √† fila se determinadas condi√ß√µes forem atendidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, j√° pulamos algumas c√©lulas: aquelas que n√£o existem e aquelas para as quais j√° indicamos a dist√¢ncia. </font><font style="vertical-align: inherit;">Vamos reescrever o c√≥digo para que, neste caso, pulemos explicitamente os vizinhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m vamos pular todas as c√©lulas que est√£o debaixo d'√°gua. </font><font style="vertical-align: inherit;">Isso significa que, ao procurar as dist√¢ncias mais curtas, consideramos apenas o movimento no solo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist√¢ncias sem se mover pela √°gua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo ainda encontra as dist√¢ncias mais curtas, mas agora evita toda a √°gua. </font><font style="vertical-align: inherit;">Portanto, as c√©lulas subaqu√°ticas nunca ganham dist√¢ncia, como √°reas isoladas da terra. </font><font style="vertical-align: inherit;">A c√©lula subaqu√°tica somente recebe dist√¢ncia se for selecionada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar fal√©sias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, para determinar a possibilidade de visitar um vizinho, podemos usar o tipo de costela. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode fazer fal√©sias bloquear o caminho. </font><font style="vertical-align: inherit;">Se voc√™ permitir o movimento nas encostas, as c√©lulas do outro lado do penhasco ainda poder√£o ser alcan√ßadas, apenas em outros caminhos. </font><font style="vertical-align: inherit;">Portanto, eles podem estar em dist√¢ncias muito diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist√¢ncias sem cruzar fal√©sias. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despesas de viagem </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos evitar c√©lulas e bordas, mas essas op√ß√µes s√£o bin√°rias. </font><font style="vertical-align: inherit;">Pode-se imaginar que √© mais f√°cil navegar em algumas dire√ß√µes do que em outras. </font><font style="vertical-align: inherit;">Nesse caso, a dist√¢ncia √© medida em trabalho ou tempo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estradas r√°pidas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° l√≥gico que √© mais f√°cil e r√°pido viajar nas estradas, portanto, vamos tornar a interse√ß√£o das arestas com as estradas menos caras. </font><font style="vertical-align: inherit;">Como usamos valores inteiros para definir a dist√¢ncia, deixaremos o custo de mover-se pelas estradas igual a 1, e o custo de atravessar outras arestas, aumentaremos para 10. Essa √© uma grande diferen√ßa que nos permite ver imediatamente se obtemos os resultados certos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas com dist√¢ncias erradas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classifica√ß√£o da borda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, verifica-se que a primeira pesquisa n√£o pode funcionar com custos vari√°veis ‚Äã‚Äãde movimenta√ß√£o. </font><font style="vertical-align: inherit;">Ele assume que as c√©lulas s√£o adicionadas √† borda na ordem crescente da dist√¢ncia e, para n√≥s, isso n√£o √© mais relevante. </font><font style="vertical-align: inherit;">Precisamos de uma fila de prioridade, ou seja, uma fila que se classifique. </font><font style="vertical-align: inherit;">N√£o h√° filas de prioridade padr√£o, porque voc√™ n√£o pode program√°-las de maneira que elas se ajustem a todas as situa√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos criar nossa pr√≥pria fila de prioridades, mas vamos otimiz√°-la para o futuro tutorial. </font><font style="vertical-align: inherit;">Por enquanto, simplesmente substitu√≠mos a fila por uma lista que ter√° um m√©todo </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o posso usar o ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que a borda esteja correta, precisamos classific√°-la ap√≥s adicionar uma c√©lula a ela. </font><font style="vertical-align: inherit;">De fato, podemos adiar a classifica√ß√£o at√© que todos os vizinhos da c√©lula sejam adicionados, mas, repito, at√© que as otimiza√ß√µes n√£o nos interessem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queremos classificar as c√©lulas por dist√¢ncia. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos chamar o m√©todo de classifica√ß√£o de lista com um link para o m√©todo que realiza essa compara√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esse m√©todo Sort funciona?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A borda classificada ainda est√° incorreta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualiza√ß√£o de fronteira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois que come√ßamos a classificar a borda, come√ßamos a obter melhores resultados, mas ainda existem erros. Isso ocorre porque quando uma c√©lula √© adicionada √† borda, n√£o encontramos necessariamente a menor dist√¢ncia para essa c√©lula. Isso significa que agora n√£o podemos mais ignorar os vizinhos que j√° receberam uma dist√¢ncia. Em vez disso, precisamos verificar se encontramos um caminho mais curto. Nesse caso, precisamos alterar a dist√¢ncia para o vizinho, em vez de adicion√°-lo √† borda.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As dist√¢ncias corretas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos as dist√¢ncias corretas, come√ßaremos a considerar os custos de mudan√ßa. </font><font style="vertical-align: inherit;">Voc√™ pode perceber que as dist√¢ncias para algumas c√©lulas s√£o inicialmente muito grandes, mas s√£o corrigidas quando removidas da borda. </font><font style="vertical-align: inherit;">Essa abordagem √© chamada algoritmo de Dijkstra, e recebe o nome do primeiro inventado por Edsger Dijkstra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encostas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o queremos nos limitar a custos diferentes apenas para estradas. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode reduzir o custo de atravessar arestas planas sem estradas para 5, deixando um valor de 10 para pistas sem estradas.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para superar as encostas, voc√™ precisa trabalhar mais e as estradas s√£o sempre r√°pidas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos de al√≠vio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos adicionar custos na presen√ßa de objetos de al√≠vio. </font><font style="vertical-align: inherit;">Por exemplo, em muitos jogos, √© mais dif√≠cil navegar pelas florestas. </font><font style="vertical-align: inherit;">Nesse caso, simplesmente adicionamos todos os n√≠veis de objetos √† dist√¢ncia. </font><font style="vertical-align: inherit;">E aqui novamente a estrada acelera tudo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos diminuem a velocidade se n√£o houver estrada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, vamos levar em conta as paredes. </font><font style="vertical-align: inherit;">As paredes devem bloquear o movimento se a estrada n√£o passar por elas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As paredes n√£o nos deixam passar, voc√™ precisa procurar o port√£o. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425919/">https://habr.com/ru/post/pt425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425905/index.html">Como escrever c√≥digo assembler com instru√ß√µes sobrepostas (outra t√©cnica para ofuscar bytecode)</a></li>
<li><a href="../pt425907/index.html">Estamos desenvolvendo um projeto de aprendizado de m√°quina em Python. Parte 2</a></li>
<li><a href="../pt425911/index.html">Transferir o CRM da nuvem para a vers√£o em caixa</a></li>
<li><a href="../pt425915/index.html">Como as comunica√ß√µes transfronteiri√ßas podem substituir os sem√°foros e diminuir o caminho para o trabalho</a></li>
<li><a href="../pt425917/index.html">Lutador da justi√ßa impede Waymo de patentear a tecnologia chave do lidar</a></li>
<li><a href="../pt425921/index.html">Reuni√£o da comunidade .NET no CLRium # 4 + online</a></li>
<li><a href="../pt425923/index.html">Desgra√ßa de 25 anos</a></li>
<li><a href="../pt425925/index.html">Impress√£o 3D na cria√ß√£o de layouts no exemplo do STUDIO 911</a></li>
<li><a href="../pt425927/index.html">Esta√ß√£o meteorol√≥gica no Arduino de A a Z. Parte 2</a></li>
<li><a href="../pt425929/index.html">Google abandonou a luta pelo bilion√©simo contrato do Pent√°gono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>