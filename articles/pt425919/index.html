<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 👸🏾 🤷🏾 Mapas hexagonais no Unity: salvamento e carregamento, texturas, distâncias 👩🏾‍✈️ 🔇 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das células 

 Partes 4-7: solavancos, rios e estradas 

 Peças 8-11: água, formas terrestres e muralhas 

 Peças 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonais no Unity: salvamento e carregamento, texturas, distâncias</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das células</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peças 8-11: água, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peças 12-15: salvar e carregar, texturas, distâncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadrões de jogadores, animações</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Geração de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da água, erosão, biomas, mapa cilíndrico</a> <br><br><h1>  Parte 12: salvar e carregar </h1><br><ul><li>  Acompanhe o tipo de terreno em vez de cor. </li><li>  Crie um arquivo </li><li>  Nós escrevemos os dados em um arquivo e depois lemos. </li><li>  Serializamos os dados da célula. </li><li>  Reduza o tamanho do arquivo. </li></ul><br>  Já sabemos como criar mapas bastante interessantes.  Agora você precisa aprender como salvá-los. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Carregado do arquivo <a href="">test.map</a> .</i> <br><br><h2>  Tipo de terreno </h2><br>  Ao salvar um mapa, não precisamos armazenar todos os dados que rastreamos durante a execução do aplicativo.  Por exemplo, precisamos apenas lembrar o nível de altura da célula.  Sua própria posição vertical é retirada desses dados, para que você não precise armazená-los.  Na verdade, é melhor não armazenar essas métricas calculadas.  Assim, os dados do mapa permanecerão corretos, mesmo que mais tarde decidamos alterar o deslocamento da altura.  Os dados são separados da sua apresentação. <br><br>  Da mesma forma, não precisamos armazenar a cor exata da célula.  Você pode escrever que a célula é verde.  Mas o tom exato de verde pode mudar com uma mudança no estilo visual.  Para fazer isso, podemos salvar o índice de cores, não as próprias cores.  De fato, pode ser suficiente armazenarmos esse índice em vez de cores reais nas células em tempo de execução.  Isso permitirá, posteriormente, a visualização mais complexa do relevo. <br><br><h3>  Movendo uma matriz de cores </h3><br>  Se as células não tiverem mais dados de cores, eles deverão ser armazenados em outro lugar.  É mais conveniente armazená-lo no <code>HexMetrics</code> .  Então, vamos adicionar uma variedade de cores a ele. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Como todos os outros dados globais, como ruído, podemos inicializar essas cores com o <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  E como agora não atribuímos cores diretamente às células, nos livraremos da cor padrão. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; … void CreateCell (int x, int z, int i) { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; … }</span></span></code> </pre> <br>  Defina as novas cores para corresponder à matriz geral do editor de mapas hexagonais. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Cores adicionadas à grade.</i> <br><br><h3>  Refatoração de Células </h3><br>  Remova o campo de cores do <code>HexCell</code> .  Em vez disso, armazenaremos o índice.  Em vez de um índice de cores, usamos um índice mais geral do tipo de relevo. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  A propriedade color pode usar esse índice apenas para obter a cor correspondente.  Agora, como não está definido diretamente, exclua esta parte.  Nesse caso, obtemos um erro de compilação, que corrigiremos em breve. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // … // } }</span></span></code> </pre> <br>  Adicione uma nova propriedade para obter e definir um novo índice de tipo de elevação. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Refatoração do editor </h3><br>  Dentro do <code>HexMapEditor</code> todo o código referente às cores.  Isso corrigirá o erro de compilação. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … // Color activeColor; … // bool applyColor; … // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } … // void Awake () { // SelectColor(0); // } … void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } … } }</span></span></code> </pre> <br>  Agora adicione um campo e método para controlar o índice do tipo de elevação ativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Usamos esse método como um substituto para o método <code>SelectColor</code> agora ausente.  Conecte os widgets de cores na interface do usuário ao <code>SetTerrainTypeIndex</code> , deixando o restante inalterado.  Isso significa que um índice negativo ainda está em uso e significa que a cor não deve mudar. <br><br>  Altere <code>EditCell</code> para que o índice do tipo de elevação seja atribuído à célula que está sendo editada. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } … } }</code> </pre> <br>  Embora tenhamos removido os dados de cores das células, o mapa deve funcionar da mesma maneira que antes.  A única diferença é que a cor padrão agora é a primeira da matriz.  No meu caso, é amarelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Amarelo é a nova cor padrão.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Salvando dados em um arquivo </h2><br>  Para controlar o salvamento e o carregamento do mapa, usamos o <code>HexMapEditor</code> .  Vamos criar dois métodos que farão isso e, por enquanto, deixá-los vazios. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Adicione dois botões à interface do usuário ( <em>GameObject / UI / Button</em> ).  Conecte-os aos botões e dê as etiquetas apropriadas.  Coloquei-os na parte inferior do painel direito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Botões Salvar e Carregar.</i> <br><br><h3>  Local do arquivo </h3><br>  Para armazenar um cartão, você precisa salvá-lo em algum lugar.  Como é feito na maioria dos jogos, armazenaremos dados em um arquivo.  Mas onde colocar esse arquivo no sistema de arquivos?  A resposta depende do sistema operacional em que o jogo está sendo executado.  Cada sistema operacional possui seus próprios padrões para armazenar arquivos relacionados a aplicativos. <br><br>  Não precisamos conhecer esses padrões.  O Unity sabe o caminho certo que podemos obter com <code>Application.persistentDataPath</code> .  Você pode verificar como será com você, no método <code>Save</code> , exibindo-o no console e pressionando o botão no modo Reproduzir. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  Nos sistemas de desktop, o caminho conterá o nome da empresa e do produto.  Esse caminho é usado pelo editor e pela montagem.  Os nomes podem ser configurados em <em>Editar / Configurações do projeto / Player</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Nome da empresa e produto.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que não consigo encontrar a pasta Biblioteca no Mac?</b> <div class="spoiler_text">  A pasta <em>Biblioteca</em> geralmente está oculta.  A maneira como ele pode ser exibido depende da versão do OS X. Se você não possui uma versão anterior, selecione a pasta pessoal no Finder e vá para <em>Mostrar opções de exibição</em> .  Há uma caixa de seleção para a pasta <em>Biblioteca</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">E o WebGL?</b> <div class="spoiler_text">  Os jogos WebGL não podem acessar o sistema de arquivos do usuário.  Em vez disso, todas as operações de arquivo são redirecionadas para um sistema de arquivos localizado na memória.  Ela é transparente para nós.  No entanto, para salvar dados, você precisará solicitar manualmente a página da Web para despejar dados no armazenamento do navegador. </div></div><br><h3>  Criação de arquivo </h3><br>  Para criar um arquivo, precisamos usar classes do espaço para nome <code>System.IO</code> .  Portanto, adicionamos uma instrução <code>using</code> para ela na classe <code>HexMapEditor</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br>  Primeiro, precisamos criar o caminho completo para o arquivo.  Usamos <em>test.map</em> como o <em>nome</em> do arquivo.  Ele deve ser adicionado ao caminho dos dados armazenados.  A necessidade de inserir uma barra invertida ou dianteira (barra invertida) depende da plataforma.  O método <code>Path.Combine</code> fará <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Em seguida, precisamos acessar o arquivo neste local.  Fazemos isso usando o método <code>File.Open</code> .  Como queremos gravar dados nesse arquivo, precisamos usar o modo de criação.  Nesse caso, um novo arquivo será criado no caminho especificado ou um arquivo existente será substituído. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  O resultado da chamada desse método será um fluxo de dados aberto associado a esse arquivo.  Podemos usá-lo para gravar dados em um arquivo.  E não devemos esquecer de fechar o fluxo quando não precisarmos mais dele. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  Nesse estágio, quando você clica no botão <em>Salvar</em> , o arquivo <em>test.map</em> será criado na pasta especificada como o caminho para os dados armazenados.  Se você estudar esse arquivo, ele estará vazio e terá um tamanho de 0 bytes, porque até agora não escrevemos nada nele. <br><br><h3>  Gravar no arquivo </h3><br>  Para gravar dados em um arquivo, precisamos de uma maneira de transmitir dados para ele.  A maneira mais fácil de fazer isso é com o <code>BinaryWriter</code> .  Esses objetos permitem gravar dados primitivos em qualquer fluxo. <br><br>  Crie um novo objeto <code>BinaryWriter</code> e nosso fluxo de arquivos será seu argumento.  O escritor de fechamento fecha o fluxo usado.  Portanto, não precisamos mais armazenar um link direto para o fluxo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Para transferir dados para um fluxo, podemos usar o método <code>BinaryWriter.Write</code> .  Existe uma variante do método <code>Write</code> para todos os tipos primitivos, como inteiro e float.  Também pode gravar linhas.  Vamos tentar escrever o número inteiro 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Clique no botão <em>Salvar</em> e examine <em>test.map</em> novamente.  Agora, seu tamanho é de 4 bytes, porque o tamanho inteiro é de 4 bytes. <br><br><div class="spoiler">  <b class="spoiler_title">Por que meu gerenciador de arquivos mostra que o arquivo ocupa mais espaço?</b> <div class="spoiler_text">  Porque os sistemas de arquivos dividem o espaço em blocos de bytes.  Eles não controlam bytes individuais.  Como <em>test.map</em> leva apenas quatro bytes até agora, requer um bloco de espaço de armazenamento. </div></div><br>  Observe que armazenamos dados binários, não textos legíveis por humanos.  Portanto, se abrirmos o arquivo em um editor de texto, veremos um conjunto de caracteres indistintos.  Você provavelmente verá o símbolo <em>{</em> seguido por nada ou alguns espaços reservados. <br><br>  Você pode abrir o arquivo em um editor hexadecimal.  Nesse caso, veremos <em>7b 00 00 00</em> .  Estes são quatro bytes do nosso número inteiro, mapeados em notação hexadecimal.  Em números decimais comuns, isso é <em>123 0 0 0</em> .  Em binário, o primeiro byte se parece com <em>01111011</em> . <br><br>  O código ASCII para <em>{</em> é 123, portanto, esse caractere pode ser exibido em um editor de texto.  ASCII 0 é um caractere nulo que não corresponde a nenhum caractere visível. <br><br>  Os três bytes restantes são iguais a zero, porque escrevemos um número menor que 256. Se escrevêssemos 256, veríamos <em>00 01 00 00</em> no editor hexadecimal. <br><br><div class="spoiler">  <b class="spoiler_title">123 não deve ser armazenado como 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> usa o formato little-endian para salvar números.  Isso significa que os bytes menos significativos são gravados primeiro.  Este formato foi usado pela Microsoft no desenvolvimento da estrutura .Net.  Provavelmente foi escolhido porque o CPU Intel usa o formato little-endian. <br><br>  Uma alternativa é o big-endian, no qual os bytes mais significativos são armazenados primeiro.  Isso corresponde à ordem usual de números em números.  123 é cento e vinte e três porque queremos dizer o recorde de big endian.  Se fosse um pequeno endian, 123 significaria trezentos e vinte e um. </div></div><br><h3>  Tornamos os recursos livres </h3><br>  É importante que fechemos escritor.  Enquanto está aberto, o sistema de arquivos bloqueia o arquivo, impedindo que outros processos sejam gravados nele.  Se esquecermos de fechá-lo, também nos bloquearemos.  Se pressionarmos o botão Salvar duas vezes, na segunda vez não poderemos abrir o fluxo. <br><br>  Em vez de fechar o gravador manualmente, podemos criar um bloco <code>using</code> para isso.  Ele define o escopo dentro do qual o escritor é válido.  Quando o código executável ultrapassa esse escopo, o gravador é excluído e o thread é fechado. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Isso funcionará porque as classes de gravador e de fluxo de arquivos implementam a interface <code>IDisposable</code> .  Esses objetos têm um método <code>Dispose</code> , que é chamado indiretamente quando eles vão além do escopo de <code>using</code> . <br><br>  A grande vantagem do <code>using</code> é que ele funciona, não importa como o programa fique fora do escopo.  Retornos antecipados, exceções e erros não o incomodam.  Além disso, ele é muito conciso. <br><br><h3>  Recuperação de dados </h3><br>  Para ler dados escritos anteriormente, precisamos inserir o código no método <code>Load</code> .  Como no caso de salvar, precisamos criar um caminho e abrir o fluxo de arquivos.  A diferença é que agora abrimos o arquivo para leitura, não para gravação.  E, em vez de escritor, precisamos do <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  Nesse caso, podemos usar o método <code>File.OpenRead</code> para abrir o arquivo para leitura. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por que não podemos usar o File.OpenWrite ao escrever?</b> <div class="spoiler_text">  Esse método cria um fluxo que adiciona dados aos arquivos existentes, em vez de substituí-los. </div></div><br>  Ao ler, precisamos indicar explicitamente o tipo de dados recebidos.  Para ler números inteiros de um fluxo, precisamos usar <code>BinaryReader.ReadInt32</code> .  Este método lê um número inteiro de 32 bits, ou seja, quatro bytes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Note-se que, ao receber <em>123,</em> será suficiente lermos um byte.  Mas, ao mesmo tempo, três bytes pertencentes a esse número inteiro permanecerão no fluxo.  Além disso, isso não funcionará para números fora do intervalo de 0 a 255.  Portanto, não faça isso. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Escrevendo e lendo dados do mapa </h2><br>  Ao salvar dados, uma pergunta importante é se deve ser usado um formato legível por humanos.  Normalmente, os formatos legíveis por humanos são JSON, XML e ASCII simples com algum tipo de estrutura.  Esses arquivos podem ser abertos, interpretados e editados em editores de texto.  Além disso, eles simplificam a troca de dados entre diferentes aplicativos. <br><br>  No entanto, esses formatos têm seus próprios requisitos.  Os arquivos ocupam mais espaço (às vezes muito mais) do que usando dados binários.  Eles também podem aumentar bastante o custo de codificação e decodificação de dados, em termos de tempo de execução e de espaço na memória. <br><br>  Por outro lado, os dados binários são compactos e rápidos.  Isso é importante ao gravar grandes quantidades de dados.  Por exemplo, ao salvar automaticamente um mapa grande em cada turno do jogo.  Portanto, <br>  vamos usar o formato binário.  Se você conseguir lidar com isso, poderá trabalhar com formatos mais detalhados. <br><br><div class="spoiler">  <b class="spoiler_title">E a serialização automática?</b> <div class="spoiler_text">  Imediatamente durante o processo de serialização dos dados do Unity, podemos escrever diretamente classes serializadas no fluxo.  Detalhes da gravação de campos individuais serão escondidos de nós.  No entanto, não podemos serializar diretamente as células.  São classes <code>MonoBehaviour</code> que contêm dados que não precisamos salvar.  Portanto, precisamos usar uma hierarquia separada de objetos, que destrua a simplicidade da serialização automática.  Além disso, será mais difícil oferecer suporte a futuras alterações de código.  Portanto, manteremos controle total com serialização manual.  Além disso, nos fará realmente entender o que está acontecendo. </div></div><br>  Para serializar o mapa, precisamos armazenar os dados de cada célula.  Para salvar e carregar uma única célula, adicione os métodos <code>Save</code> and <code>Load</code> ao <code>HexCell</code> .  Como eles precisam de um escritor ou leitor para trabalhar, nós os adicionaremos como parâmetros. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Adicione métodos <code>Save</code> e <code>Load</code> ao <code>HexGrid</code> .  Esses métodos simplesmente ignoram todas as células chamando seus métodos <code>Load</code> e <code>Save</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Se fizermos o download de um mapa, ele precisará ser atualizado após a alteração dos dados da célula.  Para fazer isso, basta atualizar todos os fragmentos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Finalmente, substituímos nosso código de teste no <code>HexMapEditor</code> pelas chamadas para os métodos <code>Save</code> and <code>Load</code> da grade, passando o escritor ou o leitor com eles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Salvando um tipo de relevo </h3><br>  No estágio atual, salvar novamente cria um arquivo vazio e o download não faz nada.  Vamos começar gradualmente gravando e carregando apenas o índice do tipo de elevação <code>HexCell</code> . <br><br>  Atribua o valor diretamente ao campo terrainTypeIndex.  Não usaremos propriedades.  Como atualizamos explicitamente todos os fragmentos, as chamadas para as propriedades de <code>Refresh</code> não são necessárias.  Além disso, como salvamos apenas os mapas corretos, assumiremos que todos os mapas baixados também estão corretos.  Portanto, por exemplo, não verificaremos se o rio ou estrada é permitido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Ao salvar neste arquivo, um após o outro, o índice do tipo de alívio de todas as células será gravado.  Como o índice é um número inteiro, seu tamanho é de quatro bytes.  Meu cartão contém 300 células, ou seja, o tamanho do arquivo será de 1200 bytes. <br><br>  A carga lê os índices na mesma ordem em que são gravados.  Se você alterou as cores das células após salvar, o carregamento do mapa retornará as cores ao estado ao salvar.  Como não salvamos mais nada, o restante dos dados da célula permanecerá o mesmo.  Ou seja, o carregamento alterará o tipo de terreno, mas não a sua altura, nível da água, características do terreno, etc. <br><br><h3>  Salvando todo o número inteiro </h3><br>  Salvar um índice de tipo de alívio não é suficiente para nós.  Você precisa salvar todos os outros dados.  Vamos começar com todos os campos inteiros.  Este é um índice do tipo de relevo, altura da célula, nível da água, nível da cidade, nível da fazenda, nível da vegetação e índice de objetos especiais.  Eles precisarão ser lidos na mesma ordem em que foram gravados. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Tente agora salvar e carregar o mapa, fazendo alterações entre essas operações.  Tudo o que incluímos nos dados armazenados foi restaurado da melhor forma possível, exceto a altura da célula.  Isso aconteceu porque quando você altera o nível de altura, é necessário atualizar a posição vertical da célula.  Isso pode ser feito atribuindo-o à propriedade, e não ao campo, o valor da altura carregada.  Mas essa propriedade faz um trabalho adicional que não precisamos.  Portanto, vamos extrair o código que atualiza a posição da célula do levantador de <code>Elevation</code> e inseri-lo em um método <code>RefreshPosition</code> separado.  A única alteração que você precisa fazer aqui é substituir o <code>value</code> referência ao campo de <code>elevation</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Agora podemos chamar o método ao definir a propriedade, bem como depois de carregar os dados da altura. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); … } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); … }</code> </pre> <br>  Após essa alteração, as células mudarão corretamente sua altura aparente ao carregar. <br><br><h3>  Salvando todos os dados </h3><br>  A presença de paredes e rios de entrada / saída na célula é armazenada em campos booleanos.  Podemos escrevê-los simplesmente como um número inteiro.  Além disso, os dados da estrada são uma matriz de seis valores booleanos que podemos escrever com um loop. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  As direções dos rios de entrada e saída são armazenadas nos campos <code>HexDirection</code> .  O tipo <code>HexDirection</code> é uma enumeração armazenada internamente como vários valores inteiros.  Portanto, também podemos serializá-los como um número inteiro usando uma conversão explícita. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Os valores booleanos são lidos usando o método <code>BinaryReader.ReadBoolean</code> .  As direções dos rios são inteiras, que devemos converter novamente em <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Agora, salvamos todos os dados da célula necessários para o salvamento e a restauração completos do mapa.  Isso requer nove números inteiros e nove valores booleanos por célula.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada valor booleano ocupa um byte, portanto, usamos um total de 45 bytes por célula. </font><font style="vertical-align: inherit;">Ou seja, um cartão com 300 células requer um total de 13.500 bytes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzir o tamanho do arquivo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora pareça que 13.500 bytes não sejam muito para 300 células, talvez possamos fazer com uma quantidade menor. </font><font style="vertical-align: inherit;">No final, temos controle total sobre como os dados são serializados. </font><font style="vertical-align: inherit;">Vamos ver se existe uma maneira mais compacta de armazená-los.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redução numérica do intervalo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes níveis e índices de células são armazenados como um número inteiro. </font><font style="vertical-align: inherit;">No entanto, eles usam apenas um pequeno intervalo de valores. </font><font style="vertical-align: inherit;">Cada um deles permanecerá definitivamente na faixa de 0 a 255. </font><font style="vertical-align: inherit;">Isso significa que apenas o primeiro byte de cada número inteiro será usado. </font><font style="vertical-align: inherit;">Os três restantes sempre serão zero. </font><font style="vertical-align: inherit;">Não faz sentido armazenar esses bytes vazios. </font><font style="vertical-align: inherit;">Podemos descartá-los escrevendo número inteiro em byte antes de gravar no fluxo.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, para retornar esses números, temos que usar </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A conversão de byte para inteiro é feita implicitamente, por isso não precisamos adicionar conversões explícitas.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, nos livramos de três bytes por número inteiro, o que economiza 27 bytes por célula. Agora gastamos 18 bytes por célula e apenas 5.400 bytes por 300 células. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale a pena notar que os dados antigos do cartão se tornam sem sentido nesse estágio. Ao carregar o salvamento antigo, os dados são misturados e obtemos células confusas. Isso ocorre porque agora estamos lendo menos dados. Se lermos mais dados do que antes, obteremos um erro ao tentar ler além do final do arquivo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A incapacidade de processar dados antigos nos convém, porque estamos determinando o formato. </font><font style="vertical-align: inherit;">Porém, quando decidimos o formato de salvamento, precisamos garantir que o código futuro sempre possa lê-lo. </font><font style="vertical-align: inherit;">Mesmo se mudarmos o formato, o ideal é que ainda possamos ler o formato antigo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, usamos quatro bytes para armazenar dados do rio, dois por direção. </font><font style="vertical-align: inherit;">Para cada direção, armazenamos a presença do rio e a direção em que ele flui.Parece </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">óbvio que não precisamos armazenar a direção do rio, se não estiver. </font><font style="vertical-align: inherit;">Isso significa que as células sem um rio precisam de dois bytes a menos. </font><font style="vertical-align: inherit;">De fato, um byte na direção do rio será suficiente para nós, independentemente de sua existência.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos seis direções possíveis, que são armazenadas como números no intervalo de 0 a 5. </font><font style="vertical-align: inherit;">Três bits são suficientes para isso, porque na forma binária os números de 0 a 5 se parecem com 000, 001, 010, 011, 100, 101 e 110. Ou seja, mais um byte permanece sem uso de mais cinco bits. </font><font style="vertical-align: inherit;">Podemos usar um deles para indicar se existe um rio. </font><font style="vertical-align: inherit;">Por exemplo, você pode usar o oitavo bit, correspondente ao número 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, adicionaremos 128 a ele antes de converter a direção em bytes. Ou seja, se tivermos um rio fluindo para o noroeste, escreveremos 133, que na forma binária é 10000101. E se não houver rio, simplesmente escrevemos um byte zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao mesmo tempo, mais quatro bits permanecem sem uso, mas isso é normal. </font><font style="vertical-align: inherit;">Podemos combinar as duas direções do rio em um byte, mas isso já será muito confuso.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para decodificar dados do rio, primeiro precisamos ler o byte de volta. </font><font style="vertical-align: inherit;">Se seu valor não for menor que 128, isso significa que existe um rio. </font><font style="vertical-align: inherit;">Para obter sua direção, subtraia 128 e converta para </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtivemos 16 bytes por célula. </font><font style="vertical-align: inherit;">A melhoria parece não ser grande, mas esse é um daqueles truques usados ​​para reduzir o tamanho dos dados binários.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvar estradas em um byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar um truque semelhante para compactar dados da estrada. </font><font style="vertical-align: inherit;">Temos seis valores booleanos que podem ser armazenados nos primeiros seis bits de um byte. </font><font style="vertical-align: inherit;">Ou seja, cada direção da estrada é representada por um número que é uma potência de dois. </font><font style="vertical-align: inherit;">São 1, 2, 4, 8, 16 e 32, ou na forma binária 1, 10, 100, 1000, 10000 e 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar um byte finalizado, precisamos definir os bits que correspondem às direções usadas das estradas. </font><font style="vertical-align: inherit;">Para obter a direção certa, podemos usar o operador </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, combine-os usando o operador OR bit a bit. </font><font style="vertical-align: inherit;">Por exemplo, se a primeira, segunda, terceira e sexta estradas forem usadas, o byte finalizado será 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o &lt;&lt; funciona?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para recuperar o valor booleano da estrada, é necessário verificar se o bit está definido. </font><font style="vertical-align: inherit;">Nesse caso, mascare todos os outros bits usando o operador AND bit a bit com o número apropriado. </font><font style="vertical-align: inherit;">Se o resultado não for igual a zero, o bit é definido e a estrada existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de espremer seis bytes em um, recebemos 11 bytes por célula. </font><font style="vertical-align: inherit;">Com 300 células, isso é apenas 3.300 bytes. </font><font style="vertical-align: inherit;">Ou seja, depois de trabalhar um pouco com bytes, reduzimos o tamanho do arquivo em 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preparando-se para o futuro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de declarar nosso formato de salvamento completo, adicionamos mais um detalhe. </font><font style="vertical-align: inherit;">Antes de salvar os dados do mapa, forçaremos a </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrever um número inteiro zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso adicionará quatro bytes vazios ao início de nossos dados. </font><font style="vertical-align: inherit;">Ou seja, antes de carregar o cartão, precisamos ler esses quatro bytes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora esses bytes sejam inúteis até agora, eles são usados ​​como um cabeçalho que fornecerá compatibilidade com versões anteriores no futuro. </font><font style="vertical-align: inherit;">Se não tivéssemos adicionado esses bytes nulos, o conteúdo dos primeiros bytes dependeria da primeira célula do mapa. </font><font style="vertical-align: inherit;">Portanto, no futuro, seria mais difícil descobrir com qual versão do formato de salvamento estamos lidando. </font><font style="vertical-align: inherit;">Agora podemos apenas verificar os quatro primeiros bytes. </font><font style="vertical-align: inherit;">Se eles estiverem vazios, então estamos lidando com uma versão do formato 0. Nas versões futuras, será possível adicionar outra coisa lá. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, se o título for diferente de zero, estamos lidando com uma versão desconhecida. </font><font style="vertical-align: inherit;">Como não conseguimos descobrir quais dados existem, devemos nos recusar a baixar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 13: gerenciamento de cartões </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos novas cartas no modo Play. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione suporte para vários tamanhos de cartão. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione o tamanho do mapa aos dados salvos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salve e carregue mapas arbitrários. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exiba uma lista de cartões. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, adicionaremos suporte para vários tamanhos de cartões, além de salvar arquivos diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir desta parte, os tutoriais serão criados no Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O início da</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca de mapas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar novos mapas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até esse ponto, criamos a grade hexagonal apenas uma vez - ao carregar a cena. </font><font style="vertical-align: inherit;">Agora tornaremos possível iniciar um novo mapa a qualquer momento. </font><font style="vertical-align: inherit;">O novo cartão simplesmente substituirá o atual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Desperta </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, algumas métricas são inicializadas e, em seguida, o número de células é determinado e os fragmentos e células necessários são criados. </font><font style="vertical-align: inherit;">Criando um novo conjunto de fragmentos e células, criamos um novo mapa. </font><font style="vertical-align: inherit;">Vamos dividir </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em duas partes - o código fonte de inicialização e o método geral </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um botão na interface do usuário para criar um novo mapa. </font><font style="vertical-align: inherit;">Fiz grande e coloquei sob os botões salvar e carregar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo botão de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos conectar o evento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deste botão ao método do </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nosso objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou seja, não passaremos pelo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de mapa hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas chamaremos diretamente o método de objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um mapa clicando em.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limpando dados antigos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando você clica no botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um novo conjunto de fragmentos e células será criado. </font><font style="vertical-align: inherit;">No entanto, os antigos não são excluídos automaticamente. </font><font style="vertical-align: inherit;">Portanto, como resultado, obtemos várias malhas de mapas sobrepostas umas às outras. </font><font style="vertical-align: inherit;">Para evitar isso, primeiro precisamos nos livrar de objetos antigos. </font><font style="vertical-align: inherit;">Isso pode ser feito destruindo todos os fragmentos atuais no início </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reutilizar objetos existentes?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    —    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É possível destruir elementos filho como este em um loop?</font></font></b> <div class="spoiler_text">  Claro.         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Especifique o tamanho nas células em vez de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto definimos o tamanho do mapa através dos campos </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e do </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas será muito mais conveniente indicar o tamanho do mapa nas células. </font><font style="vertical-align: inherit;">Ao mesmo tempo, podemos alterar o tamanho do fragmento no futuro sem alterar o tamanho dos cartões. </font><font style="vertical-align: inherit;">Portanto, vamos trocar as funções dos campos número de células e número de fragmentos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; … // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; … public void CreateMap () { … // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso levará a um erro de compilação, porque ele </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa tamanhos de fragmento </font><font style="vertical-align: inherit;">para limitar sua posição </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mude </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele use diretamente o número de células que ele ainda precisa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um fragmento tem um tamanho de 5 por 5 células e os mapas por padrão têm um tamanho de 4 por 3 fragmentos. </font><font style="vertical-align: inherit;">Portanto, para manter os cartões iguais, teremos que usar um tamanho de 20 por 15 células. </font><font style="vertical-align: inherit;">E embora tenhamos atribuído valores padrão no código, o objeto de grade ainda não os utilizará automaticamente, porque os campos já existiam e tinham como padrão 0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padrão, o cartão tem um tamanho de 20 por 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamanhos de cartões personalizados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O próximo passo será o suporte à criação de cartões de qualquer tamanho, não apenas do tamanho padrão. </font><font style="vertical-align: inherit;">Para fazer isso, adicione </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X e Z </font><font style="vertical-align: inherit;">aos </font><font style="vertical-align: inherit;">parâmetros, que substituirão o número de células existente. </font><font style="vertical-align: inherit;">Lá dentro, </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vamos chamá-los com o número atual de células.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, isso funcionará corretamente apenas com o número de células que é um múltiplo do tamanho do fragmento. </font><font style="vertical-align: inherit;">Caso contrário, a divisão inteira criará muito poucos fragmentos. </font><font style="vertical-align: inherit;">Embora possamos adicionar suporte para fragmentos parcialmente preenchidos com células, vamos proibir o uso de tamanhos que não correspondem a fragmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar o operador </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular o restante da divisão do número de células pelo número de fragmentos. </font><font style="vertical-align: inherit;">Se não for igual a zero, haverá uma discrepância e não criaremos um novo mapa. </font><font style="vertical-align: inherit;">E enquanto fazemos isso, vamos adicionar proteção contra tamanhos zero e negativo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Novo menu do cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No estágio atual, o botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não funciona mais, porque o método </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora possui dois parâmetros. Não podemos conectar diretamente eventos do Unity a esses métodos. Além disso, para oferecer suporte a diferentes tamanhos de cartões, precisamos de alguns botões. Em vez de adicionar todos esses botões à interface principal, vamos criar um menu pop-up separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma nova tela à cena ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Usaremos as mesmas configurações da tela existente, exceto que sua </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordem de classificação</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser igual a 1. Graças a isso, ela estará no topo da interface do usuário do editor principal. Tornei a tela e o sistema de eventos um filho do novo objeto de interface do usuário para que a hierarquia da cena permanecesse limpa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Tela Novo mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um </font><font style="vertical-align: inherit;">painel </font><font style="vertical-align: inherit;">ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que feche a tela inteira. </font><font style="vertical-align: inherit;">É necessário escurecer o fundo e não permitir que o cursor interaja com todo o resto quando o menu estiver aberto. </font><font style="vertical-align: inherit;">Dei a ele uma cor uniforme, limpando sua imagem de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><font style="vertical-align: inherit;">defini (0, 0, 0, 200) </font><font style="vertical-align: inherit;">como a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configurações da imagem de fundo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma barra de menus ao centro da tela, semelhante aos painéis do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos criar uma etiqueta e botões claros para seus cartões pequenos, médios e grandes. </font><font style="vertical-align: inherit;">Também adicionaremos um botão de cancelamento a ela, caso o jogador mude de idéia. </font><font style="vertical-align: inherit;">Após terminar de criar o design, desative todo o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo menu de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para gerenciar o menu, crie um componente </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e adicione-o ao objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para criar um novo mapa, precisamos acessar o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Portanto, adicionamos um campo comum a ele e o conectamos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente do novo menu de mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abertura e fechamento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir e fechar o menu pop-up simplesmente ativando e desativando o objeto de tela. </font><font style="vertical-align: inherit;">Vamos adicionar </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois métodos comuns para fazer isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora conecte o botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">editor ao método </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrindo o menu pressionando. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conecte também o botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao método </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso nos permitirá abrir e fechar o menu pop-up.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar novos mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar novos mapas, precisamos chamar o </font><font style="vertical-align: inherit;">método </font><font style="vertical-align: inherit;">no objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Além disso, depois disso, precisamos fechar o menu pop-up. </font><font style="vertical-align: inherit;">Adicione ao </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método que irá lidar com isso, levando em consideração um tamanho arbitrário.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este método não deve ser geral, porque ainda não podemos conectá-lo diretamente aos eventos do botão. </font><font style="vertical-align: inherit;">Em vez disso, crie um método por botão que chamará </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o tamanho especificado. </font><font style="vertical-align: inherit;">Para um mapa pequeno, usei um tamanho de 20 por 15, correspondendo ao tamanho padrão do mapa. </font><font style="vertical-align: inherit;">Para a carta do meio, decidi dobrar esse tamanho, obtendo 40 por 30, e dobrar novamente para a carta grande. </font><font style="vertical-align: inherit;">Conecte os botões com os métodos apropriados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloqueio da câmera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar o menu pop-up para criar novos mapas com três tamanhos diferentes! Tudo funciona bem, mas precisamos cuidar de um pequeno detalhe. Quando o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa está</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ativo, não podemos mais interagir com a interface do usuário do editor e editar células. No entanto, ainda podemos controlar a câmera. Idealmente, com o menu aberto, a câmera deve travar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como temos apenas uma câmera, uma solução rápida e pragmática é simplesmente adicionar uma propriedade estática a ela </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para uso amplo, esta solução não é muito adequada, mas para a nossa interface simples é suficiente. Isso requer que rastreie a instância estática interna </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que é definida quando a câmera Desperta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma propriedade </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser uma propriedade booleana estática simples apenas com um setter. </font><font style="vertical-align: inherit;">Tudo o que faz é desativar a instância </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando estiver bloqueada e ativá-la quando estiver desbloqueada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode bloquear a câmera e </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- desbloqueá-la.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manutenção da posição correta da câmera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe outro problema provável com a câmera. </font><font style="vertical-align: inherit;">Ao criar um novo mapa menor que o atual, a câmera pode aparecer fora das bordas do mapa. </font><font style="vertical-align: inherit;">Ela permanecerá lá até que o jogador tente mover a câmera. </font><font style="vertical-align: inherit;">E só então será limitado pelos limites do novo mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, podemos adicionar ao </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método estático </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chamar um método de </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instância com deslocamento zero forçará a câmera a se mover para as bordas do mapa. </font><font style="vertical-align: inherit;">Se a câmera já estiver dentro das bordas do novo mapa, ela permanecerá no lugar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame o método dentro </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depois de criar um novo mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando o tamanho do mapa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora possamos criar cartões de tamanhos diferentes, isso não é levado em consideração ao salvar e carregar. </font><font style="vertical-align: inherit;">Isso significa que carregar um mapa levará a um erro ou a um mapa incorreto se o tamanho do mapa atual não corresponder ao tamanho do mapa carregado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, antes de carregar os dados da célula, precisamos criar um novo mapa do tamanho apropriado. </font><font style="vertical-align: inherit;">Digamos que temos um pequeno mapa salvo. </font><font style="vertical-align: inherit;">Nesse caso, tudo ficará bem se criarmos </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um mapa de 20 por 15 </font><font style="vertical-align: inherit;">no início </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armazenamento de tamanho de cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, podemos armazenar um cartão de qualquer tamanho. </font><font style="vertical-align: inherit;">Portanto, uma solução generalizada será salvar o tamanho do mapa na frente dessas células.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, podemos obter o tamanho real e usá-lo para criar um mapa com os tamanhos corretos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora podemos carregar mapas de tamanhos diferentes, somos novamente confrontados com o problema da posição da câmera. </font><font style="vertical-align: inherit;">Resolveremos isso verificando sua posição </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">após carregar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Novo formato de arquivo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora essa abordagem funcione com cartões que manteremos no futuro, não funcionará com cartões antigos. </font><font style="vertical-align: inherit;">E vice-versa - o código da parte anterior do tutorial não poderá carregar corretamente novos arquivos de mapa. </font><font style="vertical-align: inherit;">Para distinguir entre formatos antigos e novos, aumentaremos o valor inteiro do cabeçalho. </font><font style="vertical-align: inherit;">O formato antigo de salvar sem tamanho de mapa tinha a versão 0. O novo formato com tamanho de mapa terá a versão 1. Portanto, ao gravar, ele </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve gravar 1 em vez de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de agora, os cartões serão salvos como versão 1. Se tentarmos abri-los na montagem do tutorial anterior, eles se recusarão a carregar e relatar um formato de cartão desconhecido. </font><font style="vertical-align: inherit;">De fato, isso acontecerá se já tentarmos carregar esse cartão. </font><font style="vertical-align: inherit;">Você precisa alterar o método </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele aceite a nova versão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidade com versões anteriores </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, se quisermos, ainda podemos baixar mapas da versão 0, supondo que todos tenham o mesmo tamanho 20 por 15. Ou seja, o título não precisa ser 1, também pode ser zero. </font><font style="vertical-align: inherit;">Uma vez que cada versão requer sua própria abordagem, </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é transmitir o método de cabeçalho </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inclua um </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">título </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">parâmetro e use-o para tomar decisões sobre outras ações. </font><font style="vertical-align: inherit;">Se o cabeçalho não for menor que 1, você precisará ler os dados de tamanho do cartão. </font><font style="vertical-align: inherit;">Caso contrário, usamos o tamanho antigo do cartão fixo de 20 por 15 e ignoramos a leitura dos dados do tamanho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); … }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão do arquivo de mapa 0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificação do tamanho do cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como na criação de um novo mapa, é teoricamente possível que tenhamos de carregar um mapa incompatível com o tamanho do fragmento. </font><font style="vertical-align: inherit;">Quando isso acontece, devemos interromper o download do cartão. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">já se recusa a criar um mapa e exibe um erro no console. </font><font style="vertical-align: inherit;">Para dizer isso ao chamador do método, vamos retornar um booleano informando se o mapa foi criado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele também pode interromper a execução quando a criação do mapa falha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o carregamento substitui todos os dados nas células existentes, não precisamos criar um novo mapa se um mapa do mesmo tamanho estiver carregado. </font><font style="vertical-align: inherit;">Portanto, esta etapa pode ser ignorada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de arquivos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos salvar e carregar cartões de tamanhos diferentes, mas sempre escreva e leia </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agora vamos adicionar suporte para arquivos diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de salvar ou carregar diretamente o mapa, usamos outro menu pop-up que fornece gerenciamento avançado de arquivos. </font><font style="vertical-align: inherit;">Crie outra tela, como no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas desta vez vamos chamá-lo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Salvar carregamento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este menu salva e carrega mapas, dependendo do botão pressionado para abri-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criaremos o design do </font><em><font style="vertical-align: inherit;">menu Salvar carregamento</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como se fosse um menu para salvar. Mais tarde, nós o transformaremos dinamicamente em um menu de inicialização. Como outro menu, ele deve ter um plano de fundo e uma barra de menus, um rótulo de menu e um botão de cancelamento. Em seguida, adicione uma exibição de rolagem ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ao menu para exibir uma lista de arquivos. Abaixo, inserimos o campo de entrada ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) para indicar os nomes dos novos cartões. Também precisamos de um botão de ação para salvar o mapa. E finalmente adicione um botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excluir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para excluir cartões desnecessários.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Salvar menu de carregamento.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por padrão, a exibição de rolagem permite rolagem horizontal e vertical, mas precisamos apenas de uma lista com rolagem vertical. Portanto, desative a rolagem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e retire o rolagem horizontal bar. Também configuramos o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de movimento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font><font style="vertical-align: inherit;">fixar </font><font style="vertical-align: inherit;">e desativar a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inércia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tornar a lista mais restritiva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opções da lista de arquivos. </font></font></i> <font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">Removeremos o</font></em></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filho </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font><em><font style="vertical-align: inherit;">Barra de Rolagem</font></em><font style="vertical-align: inherit;"> do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de Arquivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque não precisamos dele. </font><font style="vertical-align: inherit;">Em seguida, redimensione a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barra de rolagem vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ela </font><em><font style="vertical-align: inherit;">atinja o</font></em><font style="vertical-align: inherit;"> final da lista. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O texto do espaço reservado para o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de Nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser alterado em seu espaço </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reservado</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filho </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usei texto descritivo, mas você pode deixá-lo em branco e se livrar do espaço reservado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design do menu alterado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluímos o design e agora desativamos o menu para que por padrão ele fique oculto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de menu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que o menu funcione, precisamos de outro script, neste caso - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele precisa de um link para a grade, bem como métodos </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione esse componente ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e atribua um link ao objeto de grade.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um menu será aberto para salvar ou carregar. </font><font style="vertical-align: inherit;">Para simplificar o trabalho, adicione um </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parâmetro booleano </font><font style="vertical-align: inherit;">ao método </font><font style="vertical-align: inherit;">Determina se o menu deve estar no modo de salvamento. </font><font style="vertical-align: inherit;">Seguiremos esse modo no campo para saber qual ação executar posteriormente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora combinar os botões </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carregar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Editor de mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o método </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar carregar o menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verifique o parâmetro booleano apenas para o botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrindo o menu no modo de salvamento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você ainda não o fez, conecte o evento do botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao método </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agora </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar Menu de Carregamento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser aberta e fechada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mudança na aparência </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos o menu como um menu para salvar, mas seu modo é determinado pelo botão pressionado para abrir. </font><font style="vertical-align: inherit;">Precisamos alterar a aparência do menu, dependendo do modo. </font><font style="vertical-align: inherit;">Em particular, precisamos alterar o rótulo do menu e o botão do botão de ação. </font><font style="vertical-align: inherit;">Isso significa que precisaremos de links para essas tags.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexão com tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o menu é aberto no modo de salvamento, usamos os rótulos existentes, ou seja, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o menu e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o botão de ação. </font><font style="vertical-align: inherit;">Caso contrário, estamos no modo de carregamento, ou seja, usamos o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Digite o nome do cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos deixar a lista de arquivos por enquanto. </font><font style="vertical-align: inherit;">O usuário pode especificar o arquivo salvo ou baixado digitando o nome do cartão no campo de entrada. </font><font style="vertical-align: inherit;">Para obter esses dados, precisamos de uma referência ao componente </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexão ao campo de entrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O usuário não precisa ser forçado a inserir o caminho completo para o arquivo de mapa. </font><font style="vertical-align: inherit;">Basta o nome do cartão sem a extensão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos adicionar um método que aceite a entrada do usuário e crie o caminho certo para ela. </font><font style="vertical-align: inherit;">Isso não é possível quando a entrada está vazia, portanto, neste caso, retornaremos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que acontece se o usuário digitar caracteres inválidos?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando e carregando </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele estará envolvido em salvar e carregar </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, nós nos movemos os métodos </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles não precisam mais ser compartilhados e funcionarão com o parâmetro path em vez do caminho fixo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora estamos carregando arquivos arbitrários, seria bom verificar se o arquivo realmente existe e só então tentar lê-lo. </font><font style="vertical-align: inherit;">Caso contrário, lançamos um erro e encerramos a operação.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora adicione o método geral </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Começa com a obtenção do caminho selecionado pelo usuário. </font><font style="vertical-align: inherit;">Se houver um caminho, salve ou carregue-o. </font><font style="vertical-align: inherit;">Depois feche o menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao anexar um evento do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">botão de ação</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a esse método </font><font style="vertical-align: inherit;">, podemos salvar e carregar usando nomes de mapas arbitrários. </font><font style="vertical-align: inherit;">Como não redefinimos o campo de entrada, o nome selecionado permanecerá até o próximo salvamento ou carregamento. </font><font style="vertical-align: inherit;">Isso é conveniente para salvar ou carregar de um arquivo várias vezes seguidas, para que não alteremos nada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itens da lista de mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, preencheremos a lista de arquivos com todos os cartões que estão no caminho de armazenamento de dados. </font><font style="vertical-align: inherit;">Quando você clica em um dos itens da lista, ele será usado como texto na </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de Nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adicione um </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método geral para isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos de algo que é um item da lista. </font><font style="vertical-align: inherit;">O botão de sempre serve. </font><font style="vertical-align: inherit;">Crie-o e reduza a altura para 20 unidades, para que não ocupe muito espaço na vertical. </font><font style="vertical-align: inherit;">Como não deve parecer um botão, limparemos o link </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem de origem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesse caso, ele ficará completamente branco. </font><font style="vertical-align: inherit;">Além disso, garantiremos que o rótulo esteja alinhado à esquerda e que haja espaço entre o texto e o lado esquerdo do botão. </font><font style="vertical-align: inherit;">Depois de terminar com o design do botão, o transformamos em uma pré-fabricada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botão é um item da lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não podemos conectar diretamente o evento do botão ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Novo Mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque é uma pré-fabricada e ainda não existe na cena. </font><font style="vertical-align: inherit;">Portanto, um item de menu precisa de um link para o menu para que ele possa chamar um método quando clicado </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele também precisa acompanhar o nome do cartão que ele representa e definir seu texto. </font><font style="vertical-align: inherit;">Vamos criar um pequeno componente para isso </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um componente ao item de menu e faça o botão chamar seu método </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente de item.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preenchimento de lista </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para preencher a lista, você </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisa de um link para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">janela</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><em><font style="vertical-align: inherit;">exibição</font></em><font style="vertical-align: inherit;"> do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de Arquivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ele também precisa de um link para o item pré-fabricado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misture o conteúdo de uma lista e uma pré-fabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos um novo método para preencher esta lista. </font><font style="vertical-align: inherit;">A primeira etapa é identificar os arquivos de mapa existentes. </font><font style="vertical-align: inherit;">Para uma disposição de caminhos para arquivos dentro do diretório, podemos usar o método </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este método possui um segundo parâmetro que permite filtrar arquivos. </font><font style="vertical-align: inherit;">No nosso caso, apenas os arquivos correspondentes à máscara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> são necessários </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, a ordem dos arquivos não é garantida. </font><font style="vertical-align: inherit;">Para exibi-los em ordem alfabética, precisamos classificar a matriz com </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criaremos instâncias pré-fabricadas para cada elemento da matriz. </font><font style="vertical-align: inherit;">Ligue o item ao menu, defina o nome do mapa e torne-o filho do conteúdo da lista.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ele </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna os caminhos completos para os arquivos, precisamos limpá-los. </font><font style="vertical-align: inherit;">Felizmente, é exatamente isso que torna o método conveniente </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de exibir o menu, precisamos preencher uma lista. </font><font style="vertical-align: inherit;">E, como é provável que os arquivos sejam alterados, precisamos fazer isso sempre que abrirmos o menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { … FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao preencher novamente a lista, precisamos excluir todos os antigos antes de adicionar novos itens. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itens sem arranjo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disposição dos pontos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora a lista exibirá itens, mas eles se sobreporão e estarão em uma posição incorreta. Para transformá-los em uma lista vertical, adicione o </font><font style="vertical-align: inherit;">componente </font><em><font style="vertical-align: inherit;">Grupo de Layout Vertical</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Componente / Layout / Grupo de Layout Vertical</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">ao objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font><font style="vertical-align: inherit;">lista </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que a organização funcione corretamente, ative </font><em><font style="vertical-align: inherit;">Largura</font></em><font style="vertical-align: inherit;"> do </font><em><font style="vertical-align: inherit;">tamanho do controle </font></em><em><font style="vertical-align: inherit;">infantil</font></em><font style="vertical-align: inherit;"> e </font><em><font style="vertical-align: inherit;">expansão da força infantil</font></em><font style="vertical-align: inherit;"> . As duas opções de </font><em><font style="vertical-align: inherit;">altura</font></em><font style="vertical-align: inherit;"> devem estar desabilitadas.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o grupo de layout vertical. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos uma bela lista de itens. </font><font style="vertical-align: inherit;">No entanto, o tamanho do conteúdo da lista não se ajusta ao número real de itens. </font><font style="vertical-align: inherit;">Portanto, a barra de rolagem nunca altera o tamanho. </font><font style="vertical-align: inherit;">Podemos forçar o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redimensionar automaticamente adicionando um componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajustador de tamanho de conteúdo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente / Layout / Ajustador de tamanho de conteúdo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Seu modo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajuste vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser definido como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamanho preferido</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o ajuste de tamanho de conteúdo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, com um pequeno número de pontos, a barra de rolagem desaparecerá. </font><font style="vertical-align: inherit;">E quando há muitos itens na lista que não cabem na janela de exibição, a barra de rolagem é exibida e possui um tamanho apropriado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma barra de rolagem é exibida.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exclusão do cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos trabalhar convenientemente com muitos arquivos de mapa. </font><font style="vertical-align: inherit;">No entanto, às vezes é necessário se livrar de alguns cartões. </font><font style="vertical-align: inherit;">Para fazer isso, você pode usar o botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excluir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vamos criar um método para isso e fazer o botão chamá-lo. </font><font style="vertical-align: inherit;">Se houver um caminho selecionado, simplesmente exclua-o com </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui também devemos verificar se estamos trabalhando com um arquivo realmente existente. </font><font style="vertical-align: inherit;">Se não for esse o caso, não devemos tentar removê-lo, mas isso não leva a um erro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de remover o cartão, não precisamos fechar o menu. </font><font style="vertical-align: inherit;">Isso facilita a exclusão de vários arquivos por vez. </font><font style="vertical-align: inherit;">No entanto, após a remoção, precisamos limpar a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada de nome</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e atualizar a lista de arquivos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 14: texturas de relevo </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use cores de vértice para criar um mapa de splat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando um ativo de textura de matriz. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando índices de elevação a malhas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transições entre texturas de relevo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até o momento, usamos cores sólidas para colorir cartões. </font><font style="vertical-align: inherit;">Agora vamos aplicar a textura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenho de texturas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma mistura de três tipos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora as cores uniformes sejam claramente distinguíveis e bastante adequadas à tarefa, elas não parecem muito interessantes. </font><font style="vertical-align: inherit;">O uso de texturas aumentará significativamente a atratividade dos mapas. </font><font style="vertical-align: inherit;">Claro que, para isso, temos que misturar texturas, não apenas cores. </font><font style="vertical-align: inherit;">No tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3, Combining Textures,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falei sobre como misturar várias texturas usando o mapa de splat. </font><font style="vertical-align: inherit;">Em nossos mapas hexagonais, você pode usar uma abordagem semelhante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas quatro texturas são misturadas e, com um mapa splat, podemos suportar até cinco texturas. </font><font style="vertical-align: inherit;">No momento, usamos cinco cores diferentes, então isso é bastante adequado para nós. </font><font style="vertical-align: inherit;">No entanto, mais tarde, podemos adicionar outros tipos. </font><font style="vertical-align: inherit;">Portanto, é necessário suporte para um número arbitrário de tipos de alívio. </font><font style="vertical-align: inherit;">Ao usar propriedades de textura definidas explicitamente, isso não é possível; portanto, é necessário usar uma matriz de texturas. </font><font style="vertical-align: inherit;">Mais tarde vamos criá-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar matrizes de textura, precisamos, de alguma forma, dizer ao sombreador quais texturas misturar. </font><font style="vertical-align: inherit;">A mistura mais difícil é necessária para triângulos angulares, que podem estar entre três células com seu próprio tipo de terreno. </font><font style="vertical-align: inherit;">Portanto, precisamos misturar suporte entre os três tipos por triângulo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando cores de vértice como mapas do Splat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supondo que possamos dizer quais texturas misturar, podemos usar cores de vértice para criar um mapa de splat para cada triângulo. </font><font style="vertical-align: inherit;">Como em cada caso são usadas no máximo três texturas, precisamos apenas de três canais de cores. </font><font style="vertical-align: inherit;">Vermelho representará a primeira textura, verde - a segunda e azul - a terceira.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa de triângulo Splat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A soma do mapa de splat do triângulo é sempre igual a um?</font></font></b> <div class="spoiler_text">  Sim         .     . ,        (1, 0, 0)  ,  (½, ½, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se um triângulo precisa de apenas uma textura, usamos apenas o primeiro canal. </font><font style="vertical-align: inherit;">Ou seja, sua cor será completamente vermelha. </font><font style="vertical-align: inherit;">No caso de mixar entre dois tipos diferentes, usamos o primeiro e o segundo canais. </font><font style="vertical-align: inherit;">Ou seja, a cor do triângulo será uma mistura de vermelho e verde. </font><font style="vertical-align: inherit;">E quando todos os três tipos forem encontrados, haverá uma mistura de vermelho, verde e azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Três configurações de mapa splat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usaremos essas configurações de mapa splat, independentemente de quais texturas realmente se misturam. </font><font style="vertical-align: inherit;">Ou seja, o mapa splat sempre será o mesmo. </font><font style="vertical-align: inherit;">Somente as texturas serão alteradas. </font><font style="vertical-align: inherit;">Como fazer isso, descobriremos mais adiante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos mudar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar esses mapas de splat, em vez de usar cores de célula. </font><font style="vertical-align: inherit;">Como geralmente usamos três cores, criaremos campos estáticos para elas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centros celulares </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar substituindo a cor do centro das células por padrão. </font><font style="vertical-align: inherit;">Nenhuma mistura é feita aqui, então usamos apenas a primeira cor, ou seja, vermelho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centros vermelhos de células. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os centros celulares agora ficam vermelhos. </font><font style="vertical-align: inherit;">Todos eles usam a primeira das três texturas, independentemente da textura. </font><font style="vertical-align: inherit;">Seus mapas de splat são os mesmos, independentemente da cor com a qual colorimos as células.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bairro do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudamos de segmento apenas dentro das células sem rios fluindo ao longo deles. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo para os segmentos adjacentes aos rios. </font><font style="vertical-align: inherit;">No nosso caso, isso é uma tira de costela e um leque de triângulos da costela. </font><font style="vertical-align: inherit;">Aqui também apenas o vermelho é suficiente para nós.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentos vermelhos adjacentes aos rios.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos cuidar da geometria dos rios dentro das células. </font><font style="vertical-align: inherit;">Todos eles também devem ficar vermelhos. </font><font style="vertical-align: inherit;">Para começar, vamos dar uma olhada no começo e no fim dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E então a geometria que compõe as margens e o leito do rio. </font><font style="vertical-align: inherit;">Agrupei as chamadas do método de cores para facilitar a leitura do código.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios vermelhos ao longo das celas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costelas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as arestas são diferentes porque estão entre células que podem ter diferentes tipos de terreno. </font><font style="vertical-align: inherit;">Usamos a primeira cor para o tipo de célula atual e a segunda cor para o tipo vizinho. </font><font style="vertical-align: inherit;">Como resultado, o mapa de splat se tornará um gradiente vermelho-verde, mesmo se as duas células forem do mesmo tipo. </font><font style="vertical-align: inherit;">Se as duas células usarem a mesma textura, ela se tornará uma mistura da mesma textura nos dois lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costelas verde-avermelhadas, exceto bordas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A transição acentuada entre vermelho e verde não causaria problemas?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As arestas com as bordas são um pouco mais complicadas, porque possuem vértices adicionais. </font><font style="vertical-align: inherit;">Felizmente, o código de interpolação existente funciona muito bem com cores de mapa splat. </font><font style="vertical-align: inherit;">Basta usar a primeira e a segunda cores, não as cores das células do começo e do fim.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas verde-avermelhadas das costelas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ângulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os ângulos das células são os mais difíceis porque precisam misturar três texturas diferentes. </font><font style="vertical-align: inherit;">Usamos vermelho para o pico inferior, verde para a esquerda e azul para a direita. </font><font style="vertical-align: inherit;">Vamos começar com os cantos de um triângulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cantos vermelho-verde-azul, exceto para bordas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, podemos novamente usar o código de interpolação de cores existente para cantos com bordas. </font><font style="vertical-align: inherit;">Apenas a interpolação é feita entre três e não duas cores. </font><font style="vertical-align: inherit;">Primeiro, considere as bordas que não estão próximas dos penhascos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas de canto vermelho-verde-azul, exceto bordas ao longo de falésias. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando se trata de falésias, precisamos usar um método </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este método recebeu as células inicial e esquerda como parâmetros. </font><font style="vertical-align: inherit;">No entanto, agora precisamos das cores splat apropriadas, que podem variar dependendo da topologia. </font><font style="vertical-align: inherit;">Portanto, substituímos esses parâmetros por cores.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere-o </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele use as cores corretas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E faça o mesmo por </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa de relevo completo splat. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrizes de textura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que nosso terreno possui um mapa de splat, podemos passar a coleção de texturas para o shader. </font><font style="vertical-align: inherit;">Não podemos apenas atribuir um sombreador a uma matriz de texturas em C #, porque a matriz deve existir na memória da GPU como uma única entidade. </font><font style="vertical-align: inherit;">Teremos que usar um objeto especial </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que é suportado no Unity desde a versão 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as GPUs suportam matrizes de textura?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li> PlayStation 4 </li></ul></div></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mestre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, o suporte do Unity para matrizes de textura na versão 5.5 é mínimo. </font><font style="vertical-align: inherit;">Não podemos apenas criar um recurso de matriz de textura e atribuir texturas a ele. </font><font style="vertical-align: inherit;">Temos que fazer isso manualmente. </font><font style="vertical-align: inherit;">Podemos criar uma matriz de texturas no modo Reproduzir ou criar um ativo no editor. </font><font style="vertical-align: inherit;">Vamos criar um ativo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que criar um ativo?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma variedade de texturas, montaremos nosso próprio mestre. </font><font style="vertical-align: inherit;">Crie um script </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e coloque-o dentro da pasta </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em vez disso, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele deve estender o tipo </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do espaço para nome </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir o assistente através de um método estático generalizado </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seus parâmetros são os nomes da janela do assistente e seu botão de criação. </font><font style="vertical-align: inherit;">Vamos chamar esse método em um método estático </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para acessar o assistente através do editor, precisamos adicionar esse método ao menu do Unity. </font><font style="vertical-align: inherit;">Isto pode ser feito através da adição de um atributo para o método </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos adicioná-lo ao menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ativos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e mais especificamente à </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz Ativos / Criar / Textura</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso assistente personalizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o novo item de menu, você pode abrir o menu pop-up do nosso assistente personalizado. </font><font style="vertical-align: inherit;">Não é muito bonito, mas adequado para resolver o problema. </font><font style="vertical-align: inherit;">No entanto, ainda está vazio. </font><font style="vertical-align: inherit;">Para criar uma matriz de texturas, precisamos de uma matriz de texturas. </font><font style="vertical-align: inherit;">Adicione um campo geral a ele para o mestre. </font><font style="vertical-align: inherit;">A GUI padrão do assistente a exibe como um inspetor padrão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mestre com texturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos criar algo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você clica no botão </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">assistente, ele desaparece. </font><font style="vertical-align: inherit;">Além disso, a Unity reclama que não há método </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esse é o método que é chamado quando o botão de criação é clicado, portanto, precisamos adicioná-lo ao assistente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vamos criar nossa matriz de texturas. </font><font style="vertical-align: inherit;">Pelo menos se o usuário adicionasse texturas ao mestre. </font><font style="vertical-align: inherit;">Caso contrário, não há nada para criar e o trabalho precisa ser interrompido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A próxima etapa é solicitar o local para salvar o ativo da matriz de textura. </font><font style="vertical-align: inherit;">Salve o arquivo de painel pode ser aberto por </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seus parâmetros definem o nome do painel, o nome do arquivo padrão, a extensão e a descrição do arquivo. </font><font style="vertical-align: inherit;">Matrizes de textura usam a extensão de arquivo do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ativo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geral </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o caminho do arquivo selecionado pelo usuário. </font><font style="vertical-align: inherit;">Se o usuário clicar em cancelar neste painel, o caminho será uma sequência vazia. </font><font style="vertical-align: inherit;">Portanto, neste caso, devemos interromper o trabalho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando uma matriz de texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se tivermos o caminho certo, podemos seguir em frente e criar um novo objeto </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seu método construtor requer a especificação da largura e altura da textura, o comprimento da matriz, o formato das texturas e a necessidade de texturas mip. </font><font style="vertical-align: inherit;">Esses parâmetros devem ser os mesmos para todas as texturas na matriz. </font><font style="vertical-align: inherit;">Para configurar o objeto, usamos a primeira textura. </font><font style="vertical-align: inherit;">O usuário deve verificar se todas as texturas têm o mesmo formato.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a matriz de textura é um único recurso da GPU, ela usa os mesmos modos de filtragem e dobra para todas as texturas. </font><font style="vertical-align: inherit;">Aqui, novamente usamos a primeira textura para configurar tudo.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos copiar a textura de uma matriz usando o método </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O método copia dados brutos de textura, um nível mip por vez. </font><font style="vertical-align: inherit;">Portanto, precisamos percorrer todas as texturas e seus níveis de mip. </font><font style="vertical-align: inherit;">Os parâmetros do método são dois conjuntos que consistem em um recurso de textura, um índice e um nível mip. </font><font style="vertical-align: inherit;">Como as texturas originais não são matrizes, seu índice é sempre zero.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, temos na memória a matriz correta de texturas, mas ainda não é um ativo. </font><font style="vertical-align: inherit;">O passo final será chamar </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a matriz e seu caminho. </font><font style="vertical-align: inherit;">Nesse caso, os dados serão gravados em um arquivo em nosso projeto e aparecerão na janela do projeto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { … } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma variedade real de texturas, precisamos das texturas originais. Aqui estão cinco texturas que correspondem às cores que usamos até agora. Amarelo se torna areia, verde se torna grama, azul se torna terra, laranja se torna pedra e branco se torna neve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturas de areia, grama, terra, pedra e neve. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que essas texturas não são fotografias desse relevo. </font><font style="vertical-align: inherit;">Estes são os padrões pseudo-aleatórios fáceis que eu criei usando o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu me esforcei para criar tipos e detalhes de relevo reconhecíveis que não entrem em conflito com o relevo poligonal abstrato. </font><font style="vertical-align: inherit;">O fotorrealismo acabou sendo inadequado para isso. </font><font style="vertical-align: inherit;">Além disso, embora os padrões acrescentem variabilidade, existem poucos recursos distintos que tornariam as repetições imediatamente perceptíveis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione essas texturas à matriz principal, certificando-se de que a ordem delas corresponda às cores. </font><font style="vertical-align: inherit;">Ou seja, primeiro areia, depois grama, terra, pedra e finalmente neve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando uma matriz de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após criar o ativo da matriz de textura, selecione-o e examine-o no inspetor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspetor de matriz de textura.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa é a exibição mais simples de uma parte dos dados da matriz de textura. Observe que há uma opção </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É legível</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que está ativada inicialmente. Como não precisamos ler dados de pixel da matriz, desative-os. Não podemos fazer isso no assistente, porque não existem </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métodos ou propriedades para acessar esse parâmetro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(No Unity 5.6, existe um erro que estraga as matrizes de textura em montagens em várias plataformas. Você pode contorná-lo sem desabilitar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É legível</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também é importante notar que existe um campo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espaço de cor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao qual é atribuído o valor 1. Isso significa que as texturas são assumidas como estando no espaço gama, o que é verdadeiro. </font><font style="vertical-align: inherit;">Se eles deveriam estar no espaço linear, o campo precisava receber o valor 0. Na verdade, o designer </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui um parâmetro adicional para especificar o espaço de cores, mas </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não mostra se está no espaço linear ou não; portanto, em qualquer caso, é necessário definir valor manualmente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos uma variedade de texturas, precisamos ensinar ao shader como trabalhar com ele. </font><font style="vertical-align: inherit;">Por enquanto, usamos o sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para renderizar o terreno </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como agora usaremos texturas em vez de cores, renomeie-o para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em seguida, transformamos seu parâmetro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em uma matriz de texturas e atribuímos a ele um ativo.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material de alívio com uma variedade de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para habilitar matrizes de textura em todas as plataformas que as suportam, você precisa aumentar o nível de destino do shader de 3.0 para 3.5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a variável </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora se refere a uma matriz de texturas, precisamos alterar seu tipo. </font><font style="vertical-align: inherit;">O tipo depende da plataforma de destino e a macro cuidará disso </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como em outros shaders, para provar a textura do relevo, precisamos das coordenadas do mundo XZ. </font><font style="vertical-align: inherit;">Portanto, adicionaremos uma posição no mundo à estrutura de entrada do shader de superfície. </font><font style="vertical-align: inherit;">Também excluímos as coordenadas UV padrão, porque não precisamos delas.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para provar uma variedade de texturas, precisamos usar uma macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para provar uma matriz, ela precisa de três coordenadas. </font><font style="vertical-align: inherit;">Os dois primeiros são coordenadas UV regulares. </font><font style="vertical-align: inherit;">Usaremos as coordenadas do mundo XZ na escala de 0,02. </font><font style="vertical-align: inherit;">Portanto, obtemos uma boa resolução de textura com ampliação total. </font><font style="vertical-align: inherit;">As texturas serão repetidas aproximadamente a cada quatro células. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A terceira coordenada é usada como o índice da matriz de texturas, como em uma matriz regular. </font><font style="vertical-align: inherit;">Como as coordenadas são flutuantes, antes da indexação, a matriz da GPU as arredonda. </font><font style="vertical-align: inherit;">Até que saibamos que textura é necessária, vamos sempre usar a primeira. </font><font style="vertical-align: inherit;">Além disso, a cor do vértice não afetará o resultado final, porque é um mapa de splat.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo se tornou areia. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seleção de textura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos de um mapa de relevo que mistura os três tipos em um triângulo. </font><font style="vertical-align: inherit;">Temos uma variedade de texturas com uma textura para cada tipo de terreno. </font><font style="vertical-align: inherit;">Temos um shader que mostra uma variedade de texturas. </font><font style="vertical-align: inherit;">Mas, por enquanto, não temos como dizer ao sombreador quais texturas escolher para cada triângulo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como cada triângulo combina até três tipos, precisamos associar três índices a cada triângulo. </font><font style="vertical-align: inherit;">Como não podemos armazenar informações para triângulos, precisamos armazenar índices para vértices. </font><font style="vertical-align: inherit;">Todos os três vértices do triângulo simplesmente armazenam os mesmos índices da cor sólida.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dados de malhas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar um dos conjuntos da malha UV para armazenar índices. </font><font style="vertical-align: inherit;">Como três índices são armazenados em cada vértice, os conjuntos de 2D UV existentes não serão suficientes. </font><font style="vertical-align: inherit;">Felizmente, os conjuntos de UV podem conter até quatro coordenadas. </font><font style="vertical-align: inherit;">Portanto, adicionamos à </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à qual nos referiremos como tipos de alívio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ative os tipos de terreno para o </font><font style="vertical-align: inherit;">filho do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da pré-fabricada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos tipos de alívio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se necessário, faremos outra lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para os tipos de relevo durante a limpeza da malha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No processo de aplicação dos dados da malha, salvamos os tipos de relevo no terceiro conjunto de UV. </font><font style="vertical-align: inherit;">Por isso, eles não entrarão em conflito com outros dois conjuntos, se decidirmos usá-los juntos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para definir os tipos de relevo do triângulo, usaremos </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como os mesmos são iguais para todo o triângulo, apenas adicionamos os mesmos dados três vezes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misturar em quad funciona da mesma maneira. </font><font style="vertical-align: inherit;">Todos os quatro vértices são do mesmo tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fãs de Triângulos de Costelas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos adicionar tipos aos dados da malha </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos começar com </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, para melhor legibilidade, vamos separar as chamadas para os métodos de vértice e cor. </font><font style="vertical-align: inherit;">Lembre-se de que a cada chamada para esse método, a passamos para ele </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que possamos usar essa cor diretamente e não aplicar o parâmetro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após as cores, adicionamos tipos de relevo. </font><font style="vertical-align: inherit;">Como os tipos no triângulo podem ser diferentes, esse deve ser um parâmetro que substitui a cor. </font><font style="vertical-align: inherit;">Use este tipo simples para criar </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas os quatro primeiros canais são importantes para nós, porque nesse caso o mapa splat é sempre vermelho. </font><font style="vertical-align: inherit;">Como todos os três componentes do vetor precisam ser atribuídos, vamos atribuir a eles um tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { … Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, precisamos alterar todas as chamadas para esse método, substituindo o argumento de cores por um índice do tipo de terreno da célula. </font><font style="vertical-align: inherit;">Vnesom esta mudança </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, quando você inicia o modo de reprodução, serão exibidos erros informando que os terceiros conjuntos de malhas UV estão fora dos limites. </font><font style="vertical-align: inherit;">Isso aconteceu porque ainda não adicionamos tipos de relevo a cada triângulo e quad. </font><font style="vertical-align: inherit;">Então, vamos continuar a mudar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listras de costela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, ao criar uma faixa de aresta, precisamos saber que tipos de terreno existem nos dois lados. </font><font style="vertical-align: inherit;">Portanto, nós os adicionamos como parâmetros e, em seguida, criamos um vetor de tipos cujos dois canais são atribuídos a esses tipos. </font><font style="vertical-align: inherit;">O terceiro canal não é importante, apenas o iguale ao primeiro. </font><font style="vertical-align: inherit;">Depois de adicionar as cores, adicione os tipos ao quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos mudar os desafios </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve usar o tipo de célula para ambos os lados da tira da costela.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, o caso mais simples de uma aresta </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve usar o tipo de célula para a aresta mais próxima e o tipo vizinho para a aresta mais distante. </font><font style="vertical-align: inherit;">Eles podem ser iguais ou diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mesmo se aplica </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">àquilo que desencadeia três vezes </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Os tipos para as bordas são os mesmos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ângulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O caso mais simples de um ângulo é um triângulo simples. </font><font style="vertical-align: inherit;">A célula inferior transfere o primeiro tipo, o esquerdo o segundo e o direito o terceiro. </font><font style="vertical-align: inherit;">Usando-os, crie um vetor de tipos e adicione-o ao triângulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos a mesma abordagem </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apenas aqui criamos um grupo de quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao misturar bordas e falésias, precisamos usar </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas dê a ele um parâmetro de vetor de tipo e adicione-o a todos os seus triângulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criação de vector com base nos tipos de células transmitidas. </font><font style="vertical-align: inherit;">Em seguida, adicione-o a um triângulo e passe </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mesmo vale para </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O último método para mudar é este </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como aqui estamos no centro da célula, estamos lidando apenas com o tipo da célula atual. </font><font style="vertical-align: inherit;">Portanto, crie um vetor para ele e adicione-o a triângulos e quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo de mistura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, as malhas contêm os índices de elevação necessários. </font><font style="vertical-align: inherit;">Tudo o que resta para nós é forçar o shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font><font style="vertical-align: inherit;">usá-los. </font><font style="vertical-align: inherit;">Para que os índices caiam no shader de fragmento, primeiro precisamos passá-los pelo shader de vértice. </font><font style="vertical-align: inherit;">Podemos fazer isso em nossa própria função de vértice, como fizemos no sombreador do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estuário</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesse caso, adicionamos um campo à estrutura de entrada </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e copiamos para ela </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos amostrar a matriz de textura três vezes por fragmento. </font><font style="vertical-align: inherit;">Portanto, vamos criar uma função conveniente para criar coordenadas de textura, amostrar uma matriz e modular uma amostra com um mapa de splat para um índice.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos trabalhar com um vetor como uma matriz?</font></font></b> <div class="spoiler_text">  Sim   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando esta função, podemos simplesmente amostrar a matriz de textura três vezes e combinar os resultados. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relevo texturizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos pintar o relevo com texturas. </font><font style="vertical-align: inherit;">Eles se misturam como cores sólidas. </font><font style="vertical-align: inherit;">Como usamos as coordenadas mundiais como coordenadas UV, elas não mudam com a altura. </font><font style="vertical-align: inherit;">Como resultado, ao longo de penhascos afiados, as texturas são esticadas. </font><font style="vertical-align: inherit;">Se as texturas forem bastante neutras e muito variáveis, os resultados serão aceitáveis. </font><font style="vertical-align: inherit;">Caso contrário, temos grandes estrias feias. </font><font style="vertical-align: inherit;">Você pode tentar ocultá-lo com geometria ou textura adicional de falésias, mas no tutorial não faremos isso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando usarmos texturas em vez de cores, será lógico alterar o painel do editor. </font><font style="vertical-align: inherit;">Podemos criar uma interface bonita que pode até exibir texturas de relevo, mas vou me concentrar nas abreviações que correspondem ao estilo do esquema existente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opções de alívio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, a </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade color não é mais necessária, portanto exclua-a.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também pode remover uma matriz de cores e código associado.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } … … void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, também não é necessário um conjunto de cores </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 15: distâncias </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exiba as linhas da grade. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterne entre os modos de edição e navegação. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calcule a distância entre as células. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nós encontramos maneiras de contornar obstáculos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Levamos em conta os custos variáveis ​​da mudança. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tendo criado mapas de alta qualidade, iniciaremos a navegação. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O caminho mais curto nem sempre é reto.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grade de exibição </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A navegação no mapa é realizada movendo de célula para célula. </font><font style="vertical-align: inherit;">Para chegar a algum lugar, você precisa passar por uma série de células. </font><font style="vertical-align: inherit;">Para facilitar a estimativa de distâncias, vamos adicionar a opção de exibir a grade hexagonal na qual nosso mapa se baseia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textura de malha </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar das irregularidades da malha do mapa, a malha subjacente é perfeitamente plana. </font><font style="vertical-align: inherit;">Podemos mostrar isso projetando um padrão de grade em um mapa. </font><font style="vertical-align: inherit;">Isso pode ser conseguido usando uma textura de malha repetida.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetindo a textura da malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A textura mostrada acima contém uma pequena parte da grade hexagonal cobrindo 2 por 2 células. </font><font style="vertical-align: inherit;">Esta área é retangular, não quadrada. </font><font style="vertical-align: inherit;">Como a textura em si é um quadrado, o padrão parece esticado. </font><font style="vertical-align: inherit;">Ao amostrar, precisamos compensar isso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projeção em grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para projetar um padrão de malha, precisamos adicionar </font><font style="vertical-align: inherit;">uma propriedade de textura ao </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material de alívio com textura de malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prove a textura usando as coordenadas XZ do mundo e multiplique-a por albedo. </font><font style="vertical-align: inherit;">Como as linhas de grade da textura são cinza, isso entrelaça o padrão no relevo.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo multiplicado por malha fina. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos escalar o padrão para que ele corresponda às células no mapa. </font><font style="vertical-align: inherit;">A distância entre os centros das células vizinhas é 15, ela precisa ser dobrada para subir duas células. </font><font style="vertical-align: inherit;">Ou seja, precisamos dividir as coordenadas da grade V por 30. O raio interno das células é 5√3 e, para mover duas células para a direita, precisamos de quatro vezes mais. </font><font style="vertical-align: inherit;">Portanto, é necessário dividir as coordenadas da grade U por 20√3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tamanho de malha correto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora as linhas da grade correspondem às células do mapa. </font><font style="vertical-align: inherit;">Como texturas de relevo, eles ignoram a altura, de modo que as linhas serão esticadas ao longo dos penhascos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projeção em células com altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A deformação da malha geralmente não é tão ruim, especialmente quando se olha para um mapa a longa distância.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malha à distância.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclusão de grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora exibir uma grade seja conveniente, nem sempre é necessário. </font><font style="vertical-align: inherit;">Por exemplo, você deve desativá-lo quando tirar uma captura de tela. </font><font style="vertical-align: inherit;">Além disso, nem todo mundo prefere ver a grade constantemente. </font><font style="vertical-align: inherit;">Então, vamos torná-lo opcional. </font><font style="vertical-align: inherit;">Adicionaremos a diretiva multi_compile ao shader para criar opções com e sem uma grade. </font><font style="vertical-align: inherit;">Para fazer isso, usamos a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A compilação condicional de sombreador é descrita no tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5, Multiple Lights</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao declarar uma variável, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro atribuímos a ela um valor 1. Como resultado, a grade será desativada. </font><font style="vertical-align: inherit;">Em seguida, amostraremos a textura da grade apenas para a variante com uma palavra-chave específica </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não </font><font style="vertical-align: inherit;">está </font><font style="vertical-align: inherit;">incluída no sombreador de terreno, a grade desaparecerá. </font><font style="vertical-align: inherit;">Para habilitá-lo novamente, adicionaremos uma opção à interface do usuário do editor de mapas. </font><font style="vertical-align: inherit;">Para tornar isso possível, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preciso obter um link para o material do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e um método para ativar ou desativar a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de hexágonos de março com referência ao material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um comutador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grade</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à interface do usuário </font><font style="vertical-align: inherit;">e conecte-o ao método </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor de grade.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvar estado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no modo Play, podemos mudar a exibição da grade. </font><font style="vertical-align: inherit;">No primeiro teste, a grade é inicialmente desligada e fica visível quando ligamos o interruptor. </font><font style="vertical-align: inherit;">Quando você o desliga, a grade desaparece novamente. </font><font style="vertical-align: inherit;">No entanto, se sairmos do modo de reprodução quando a grade estiver visível, na próxima vez que você iniciar o modo de reprodução, ele será ativado novamente, embora o interruptor esteja desligado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso ocorre porque estamos alterando a palavra-chave para o material geral do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como estamos editando o ativo do material, a alteração é salva no editor do Unity. </font><font style="vertical-align: inherit;">Não será salvo na montagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para sempre iniciar o jogo sem uma grade, desabilitaremos a palavra-chave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desperta </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modo de edição </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se queremos controlar o movimento no mapa, precisamos interagir com ele. </font><font style="vertical-align: inherit;">No mínimo, precisamos selecionar a célula como o ponto de partida do caminho. </font><font style="vertical-align: inherit;">Mas quando você clica em uma célula, ela será editada. </font><font style="vertical-align: inherit;">Podemos desativar todas as opções de edição manualmente, mas isso é inconveniente. </font><font style="vertical-align: inherit;">Além disso, não queremos que os cálculos de deslocamento sejam executados durante a edição do mapa. </font><font style="vertical-align: inherit;">Então, vamos adicionar uma opção que determina se estamos no modo de edição.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interruptor de edição </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo booleano </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bem como o método que o define. </font><font style="vertical-align: inherit;">Em seguida, adicione outra opção à interface do usuário para controlá-la. </font><font style="vertical-align: inherit;">Vamos começar com o modo de navegação, ou seja, o modo de edição será desativado por padrão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor do modo de edição. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realmente desativar a edição, faça a chamada </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depender </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etiquetas de depuração </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até o momento, não temos unidades para percorrer o mapa. </font><font style="vertical-align: inherit;">Em vez disso, visualizamos as distâncias de movimento. </font><font style="vertical-align: inherit;">Para fazer isso, você pode usar rótulos de células existentes. </font><font style="vertical-align: inherit;">Portanto, os tornaremos visíveis quando o modo de edição estiver desativado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como começamos com o modo de navegação, os rótulos padrão devem estar ativados. </font><font style="vertical-align: inherit;">Atualmente os </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desativa, mas ele não deve mais fazer isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rótulos de coordenadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As coordenadas das células agora ficam visíveis imediatamente após o início do modo Play. </font><font style="vertical-align: inherit;">Mas não precisamos de coordenadas, usamos rótulos para exibir distâncias. </font><font style="vertical-align: inherit;">Como isso requer apenas um número por célula, você pode aumentar o tamanho da fonte para que eles possam ser lidos melhor. </font><font style="vertical-align: inherit;">Altere a pré-fabricada do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ele use fonte em negrito com tamanho 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags com tamanho de fonte em negrito 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, depois de iniciar o modo Play, veremos tags grandes. </font><font style="vertical-align: inherit;">Somente as primeiras coordenadas da célula são visíveis, o restante não é colocado no rótulo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags grandes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como não precisamos mais das coordenadas, excluiremos o </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font><font style="vertical-align: inherit;">na </font><font style="vertical-align: inherit;">atribuição </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também pode remover a opção </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seu método associado </font><font style="vertical-align: inherit;">da interface do usuário </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mudança de método não existe mais. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrando distâncias </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos o modo de navegação marcado, podemos começar a exibir distâncias. </font><font style="vertical-align: inherit;">Selecionaremos uma célula e, em seguida, exibiremos a distância dessa célula para todas as células no mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibição distância </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para rastrear a distância até a célula, adicione ao </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo inteiro </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso indicará a distância entre esta célula e a selecionada. </font><font style="vertical-align: inherit;">Portanto, para a célula selecionada em si, será zero, para o vizinho imediato é 1 e assim por diante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a distância é definida, devemos atualizar o rótulo da célula para exibir seu valor. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem uma referência ao </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto de interface </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">usuário. </font><font style="vertical-align: inherit;">Precisamos ligar </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">ele </font><font style="vertical-align: inherit;">para chegar ao celular. </font><font style="vertical-align: inherit;">Considere o que </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está no espaço </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">nome </font><font style="vertical-align: inherit;">, portanto, use-o no início do script.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não devemos manter um link direto para o componente Texto?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos definir a propriedade geral para receber e definir a distância para a célula, além de atualizar seu rótulo. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método geral </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o parâmetro cell. </font><font style="vertical-align: inherit;">Por enquanto, simplesmente definiremos a distância zero para cada célula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o modo de edição não estiver ativado, </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamaremos um novo método com a célula atual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distâncias entre coordenadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no modo de navegação, depois de tocar em um deles, todas as células exibem zero. </font><font style="vertical-align: inherit;">Mas, é claro, eles devem exibir a verdadeira distância da célula. </font><font style="vertical-align: inherit;">Para calcular a distância até eles, podemos usar as coordenadas da célula. </font><font style="vertical-align: inherit;">Portanto, suponha que ele </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenha um método </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e use-o </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora adicione ao </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele deve comparar suas próprias coordenadas com as de outro conjunto. </font><font style="vertical-align: inherit;">Vamos começar apenas medindo X e subtrairemos as coordenadas X uma da outra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtemos um deslocamento ao longo de X em relação à célula selecionada. </font><font style="vertical-align: inherit;">Como as distâncias não podem ser negativas, é necessário retornar a diferença de coordenadas X módulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distâncias ao longo de X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portanto, só obtemos as distâncias corretas se considerarmos apenas uma dimensão. </font><font style="vertical-align: inherit;">Mas existem três dimensões em uma grade de hexágonos. </font><font style="vertical-align: inherit;">Então, vamos somar as distâncias para todas as três dimensões e ver o que isso nos dá.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soma das distâncias XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que temos o dobro da distância. </font><font style="vertical-align: inherit;">Ou seja, para obter a distância correta, esse valor deve ser dividido pela metade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distâncias reais.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a soma é igual ao dobro da distância?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, −3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trabalhe com obstáculos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As distâncias calculadas por nós correspondem aos caminhos mais curtos da célula selecionada para a outra célula. </font><font style="vertical-align: inherit;">Não podemos encontrar um caminho mais curto. </font><font style="vertical-align: inherit;">Mas é garantido que esses caminhos estejam corretos se a rota não bloquear nada. </font><font style="vertical-align: inherit;">Falésias, água e outros obstáculos podem nos fazer girar. </font><font style="vertical-align: inherit;">Talvez algumas células não possam ser alcançadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar uma maneira de contornar obstáculos, precisamos usar uma abordagem diferente em vez de simplesmente calcular a distância entre as coordenadas. </font><font style="vertical-align: inherit;">Não podemos mais examinar cada célula individualmente. </font><font style="vertical-align: inherit;">Teremos que procurar no mapa até encontrar todas as células que podem ser alcançadas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualização de pesquisa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesquisa de mapa é um processo iterativo. </font><font style="vertical-align: inherit;">Para entender o que estamos fazendo, seria útil ver cada estágio da pesquisa. </font><font style="vertical-align: inherit;">Podemos fazer isso transformando o algoritmo de pesquisa em uma rotina, para a qual precisamos de um espaço de pesquisa </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A taxa de atualização de 60 iterações por segundo é pequena o suficiente para vermos o que está acontecendo, e a pesquisa em um pequeno mapa não demorou muito tempo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos garantir que apenas uma pesquisa esteja ativa a qualquer momento. </font><font style="vertical-align: inherit;">Portanto, antes de iniciar uma nova pesquisa, paramos todas as corotinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Além disso, precisamos concluir a pesquisa ao carregar um novo mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primeira pesquisa de largura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo antes de iniciar a pesquisa, sabemos que a distância para a célula selecionada é zero. E, é claro, a distância para todos os seus vizinhos é 1, se puderem ser alcançados. Então podemos dar uma olhada em um desses vizinhos. Essa célula provavelmente tem seus próprios vizinhos que podem ser alcançados e para os quais a distância ainda não foi calculada. Nesse caso, a distância para esses vizinhos deve ser 2. Podemos repetir esse processo para todos os vizinhos a uma distância de 1. Depois disso, repetimos para todos os vizinhos a uma distância de 2. E assim por diante, até atingirmos todas as células.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, primeiro encontramos todas as células a uma distância de 1, depois encontramos tudo a uma distância de 2, depois a uma distância de 3 e assim por diante, até terminarmos. </font><font style="vertical-align: inherit;">Isso garante que encontramos a menor distância para cada célula acessível. </font><font style="vertical-align: inherit;">Esse algoritmo é chamado de busca pela primeira vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que funcione, precisamos saber se já determinamos a distância da célula. </font><font style="vertical-align: inherit;">Muitas vezes, para isso, as células são colocadas em uma coleção chamada conjunto pronto ou fechado. </font><font style="vertical-align: inherit;">Mas podemos definir a distância da célula </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar que ainda não a visitamos. </font><font style="vertical-align: inherit;">Precisamos fazer isso para todas as células antes de realizar uma pesquisa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também pode usar isso para ocultar todas as células não visitadas, alterando </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Depois disso, iniciaremos cada pesquisa em um mapa em branco.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos rastrear as células que precisam ser visitadas e a ordem em que elas são visitadas. </font><font style="vertical-align: inherit;">Essa coleção geralmente é chamada de borda ou conjunto aberto. </font><font style="vertical-align: inherit;">Nós apenas precisamos processar as células na mesma ordem em que as encontramos. </font><font style="vertical-align: inherit;">Para fazer isso, você pode usar a fila </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que faz parte do espaço para nome </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A célula selecionada será a primeira a ser colocada nessa fila e terá uma distância de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir deste momento, o algoritmo executa o loop enquanto houver algo na fila. </font><font style="vertical-align: inherit;">A cada iteração, a célula da frente é recuperada da fila.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos a célula atual, que pode estar a qualquer distância. </font><font style="vertical-align: inherit;">Em seguida, precisamos adicionar todos os seus vizinhos à fila um passo além da célula selecionada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas devemos adicionar apenas as células que ainda não receberam uma distância. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa ampla.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite a água </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de garantir que a primeira pesquisa de largura encontre as distâncias corretas no mapa monótono, podemos começar a adicionar obstáculos. </font><font style="vertical-align: inherit;">Isso pode ser feito recusando-se a adicionar células à fila se determinadas condições forem atendidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, já pulamos algumas células: aquelas que não existem e aquelas para as quais já indicamos a distância. </font><font style="vertical-align: inherit;">Vamos reescrever o código para que, neste caso, pulemos explicitamente os vizinhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também vamos pular todas as células que estão debaixo d'água. </font><font style="vertical-align: inherit;">Isso significa que, ao procurar as distâncias mais curtas, consideramos apenas o movimento no solo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distâncias sem se mover pela água. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo ainda encontra as distâncias mais curtas, mas agora evita toda a água. </font><font style="vertical-align: inherit;">Portanto, as células subaquáticas nunca ganham distância, como áreas isoladas da terra. </font><font style="vertical-align: inherit;">A célula subaquática somente recebe distância se for selecionada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar falésias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, para determinar a possibilidade de visitar um vizinho, podemos usar o tipo de costela. </font><font style="vertical-align: inherit;">Por exemplo, você pode fazer falésias bloquear o caminho. </font><font style="vertical-align: inherit;">Se você permitir o movimento nas encostas, as células do outro lado do penhasco ainda poderão ser alcançadas, apenas em outros caminhos. </font><font style="vertical-align: inherit;">Portanto, eles podem estar em distâncias muito diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distâncias sem cruzar falésias. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despesas de viagem </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos evitar células e bordas, mas essas opções são binárias. </font><font style="vertical-align: inherit;">Pode-se imaginar que é mais fácil navegar em algumas direções do que em outras. </font><font style="vertical-align: inherit;">Nesse caso, a distância é medida em trabalho ou tempo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estradas rápidas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Será lógico que é mais fácil e rápido viajar nas estradas, portanto, vamos tornar a interseção das arestas com as estradas menos caras. </font><font style="vertical-align: inherit;">Como usamos valores inteiros para definir a distância, deixaremos o custo de mover-se pelas estradas igual a 1, e o custo de atravessar outras arestas, aumentaremos para 10. Essa é uma grande diferença que nos permite ver imediatamente se obtemos os resultados certos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas com distâncias erradas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classificação da borda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, verifica-se que a primeira pesquisa não pode funcionar com custos variáveis ​​de movimentação. </font><font style="vertical-align: inherit;">Ele assume que as células são adicionadas à borda na ordem crescente da distância e, para nós, isso não é mais relevante. </font><font style="vertical-align: inherit;">Precisamos de uma fila de prioridade, ou seja, uma fila que se classifique. </font><font style="vertical-align: inherit;">Não há filas de prioridade padrão, porque você não pode programá-las de maneira que elas se ajustem a todas as situações. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos criar nossa própria fila de prioridades, mas vamos otimizá-la para o futuro tutorial. </font><font style="vertical-align: inherit;">Por enquanto, simplesmente substituímos a fila por uma lista que terá um método </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não posso usar o ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que a borda esteja correta, precisamos classificá-la após adicionar uma célula a ela. </font><font style="vertical-align: inherit;">De fato, podemos adiar a classificação até que todos os vizinhos da célula sejam adicionados, mas, repito, até que as otimizações não nos interessem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queremos classificar as células por distância. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos chamar o método de classificação de lista com um link para o método que realiza essa comparação.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esse método Sort funciona?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A borda classificada ainda está incorreta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualização de fronteira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois que começamos a classificar a borda, começamos a obter melhores resultados, mas ainda existem erros. Isso ocorre porque quando uma célula é adicionada à borda, não encontramos necessariamente a menor distância para essa célula. Isso significa que agora não podemos mais ignorar os vizinhos que já receberam uma distância. Em vez disso, precisamos verificar se encontramos um caminho mais curto. Nesse caso, precisamos alterar a distância para o vizinho, em vez de adicioná-lo à borda.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As distâncias corretas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos as distâncias corretas, começaremos a considerar os custos de mudança. </font><font style="vertical-align: inherit;">Você pode perceber que as distâncias para algumas células são inicialmente muito grandes, mas são corrigidas quando removidas da borda. </font><font style="vertical-align: inherit;">Essa abordagem é chamada algoritmo de Dijkstra, e recebe o nome do primeiro inventado por Edsger Dijkstra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encostas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não queremos nos limitar a custos diferentes apenas para estradas. </font><font style="vertical-align: inherit;">Por exemplo, você pode reduzir o custo de atravessar arestas planas sem estradas para 5, deixando um valor de 10 para pistas sem estradas.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para superar as encostas, você precisa trabalhar mais e as estradas são sempre rápidas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos de alívio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos adicionar custos na presença de objetos de alívio. </font><font style="vertical-align: inherit;">Por exemplo, em muitos jogos, é mais difícil navegar pelas florestas. </font><font style="vertical-align: inherit;">Nesse caso, simplesmente adicionamos todos os níveis de objetos à distância. </font><font style="vertical-align: inherit;">E aqui novamente a estrada acelera tudo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos diminuem a velocidade se não houver estrada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, vamos levar em conta as paredes. </font><font style="vertical-align: inherit;">As paredes devem bloquear o movimento se a estrada não passar por elas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As paredes não nos deixam passar, você precisa procurar o portão. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425919/">https://habr.com/ru/post/pt425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425905/index.html">Como escrever código assembler com instruções sobrepostas (outra técnica para ofuscar bytecode)</a></li>
<li><a href="../pt425907/index.html">Estamos desenvolvendo um projeto de aprendizado de máquina em Python. Parte 2</a></li>
<li><a href="../pt425911/index.html">Transferir o CRM da nuvem para a versão em caixa</a></li>
<li><a href="../pt425915/index.html">Como as comunicações transfronteiriças podem substituir os semáforos e diminuir o caminho para o trabalho</a></li>
<li><a href="../pt425917/index.html">Lutador da justiça impede Waymo de patentear a tecnologia chave do lidar</a></li>
<li><a href="../pt425921/index.html">Reunião da comunidade .NET no CLRium # 4 + online</a></li>
<li><a href="../pt425923/index.html">Desgraça de 25 anos</a></li>
<li><a href="../pt425925/index.html">Impressão 3D na criação de layouts no exemplo do STUDIO 911</a></li>
<li><a href="../pt425927/index.html">Estação meteorológica no Arduino de A a Z. Parte 2</a></li>
<li><a href="../pt425929/index.html">Google abandonou a luta pelo bilionésimo contrato do Pentágono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>