<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèª üôè üõ£Ô∏è OpenSceneGraph: Prozedurale Animation von Geometrie- und Statusattributen ‚ö±Ô∏è ü§ì üë©üèΩ‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Als wir das letzte Mal √ºber OSG-spezifische Programmiertechniken sprachen, sprachen wir √ºber den Callback-Mechanismus und seine Implement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Prozedurale Animation von Geometrie- und Statusattributen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437724/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Als wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das letzte Mal</a> √ºber OSG-spezifische Programmiertechniken sprachen, sprachen wir √ºber den Callback-Mechanismus und seine Implementierung in der Engine.  Es ist an der Zeit, die M√∂glichkeiten zu untersuchen, die dieser Mechanismus f√ºr die Verwaltung des Inhalts einer dreidimensionalen Szene bietet. <br><br>  Wenn wir √ºber Objektanimation sprechen, bietet OSG dem Entwickler zwei Optionen f√ºr seine Implementierung: <br><br><ol><li>  Prozedurale Animation, die programmgesteuert durch die Transformation von Objekten und ihren Attributen implementiert wird </li><li>  Exportieren von Animationen aus einem 3D-Editor und Verwalten aus Anwendungscode </li></ol><br>  Betrachten Sie zun√§chst die erste M√∂glichkeit als die offensichtlichste.  Wir werden auf jeden Fall etwas sp√§ter √ºber die Sekunde sprechen. <br><a name="habracut"></a><br><h1>  1. Prozedurale Morphing-Animation </h1><br>  Beim Durchlaufen des Szenendiagramms √ºbertr√§gt OSG Daten an die OpenGL-Pipeline, die in einem separaten Thread ausgef√ºhrt wird.  Dieser Thread muss mit anderen Verarbeitungsthreads in jedem Frame synchronisiert werden.  Andernfalls kann die Methode frame () abgeschlossen werden, bevor Geometriedaten verarbeitet werden.  Dies f√ºhrt zu unvorhersehbarem Programmverhalten und Abst√ºrzen.  OSG bietet eine L√∂sung f√ºr dieses Problem in Form der setDataVariance () -Methode der osg :: Object-Klasse, die die Basis f√ºr alle Szenenobjekte darstellt.  Sie k√∂nnen drei Verarbeitungsmodi f√ºr Objekte einstellen <br><br><ol><li>  NICHT SPEZIFIZIERT (standardm√§√üig) - OSG bestimmt unabh√§ngig die Verarbeitungsreihenfolge des Objekts. <br></li><li>  STATISCH - Das Objekt ist unver√§nderlich und die Reihenfolge seiner Verarbeitung ist nicht wichtig.  Beschleunigt das Rendern erheblich. <br></li><li>  DYNAMISCH - Das Objekt muss vor dem Start des Renderns verarbeitet werden. <br></li></ol><br>  Diese Einstellung kann jederzeit per Anruf vorgenommen werden <br><br><pre><code class="cpp hljs">node-&gt;setDataVariance( osg::Object::DYNAMIC );</code> </pre> <br>  Die allgemein akzeptierte Praxis besteht darin, die Geometrie "on the fly" zu √§ndern, dh die Koordinaten von Scheitelpunkten, Farbnormalen und Texturen in jedem Rahmen dynamisch zu √§ndern, um ver√§nderbare Geometrie zu erhalten.  Diese Technik wird als Morphing-Animation bezeichnet.  In diesem Fall ist die Reihenfolge der Verarbeitung der Geometrie entscheidend - alle √Ñnderungen m√ºssen vor Beginn des Zeichnens neu berechnet werden.  Um diesen Trick zu veranschaulichen, √§ndern wir das Beispiel f√ºr farbige Quadrate geringf√ºgig und zwingen einen seiner Scheitelpunkte, sich um die X-Achse zu drehen. <br><br><div class="spoiler">  <b class="spoiler_title">Animquad Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad() { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class DynamicQuadCallback : public osg::Drawable::UpdateCallback { public: virtual void update(osg::NodeVisitor *, osg::Drawable *drawable); }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = static_cast&lt;osg::Geometry *&gt;(drawable); if (!quad) return; osg::Vec3Array *vertices = static_cast&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); if (!vertices) return; osg::Quat quat(osg::PI * 0.01, osg::X_AXIS); vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(new DynamicQuadCallback); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Wir werden ein Quadrat in einer separaten Funktion erstellen <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  Eine Beschreibung davon ist grunds√§tzlich nicht erforderlich, da wir solche Ma√ünahmen wiederholt durchgef√ºhrt haben.  Um die Eckpunkte dieses Quadrats zu √§ndern, schreiben wir die DynamicQuadCallback-Klasse und erben sie von osg :: Drawable :: UpdateCallback <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicQuadCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Drawable::UpdateCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor *, osg::Drawable *drawable)</span></span></span></span>; };</code> </pre><br>  √úberschreiben der update () -Methode darin <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!quad) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!vertices) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>; vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); }</code> </pre><br>  Hier erhalten wir einen Zeiger auf ein Geometrieobjekt <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable);</code> </pre><br>  wir lesen aus der Geometrie eine Liste von Eckpunkten (oder vielmehr einen Zeiger darauf) <br><br><pre> <code class="cpp hljs">osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray());</code> </pre><br>  Um das letzte Element (den letzten Scheitelpunkt) im Array abzurufen, stellt die Klasse osg :: Array die Methode back () bereit.  Um die Drehung des Scheitelpunkts relativ zur X-Achse durchzuf√ºhren, f√ºhren wir die Quaternion ein <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>;</code> </pre><br>  Das hei√üt, wir setzen eine Quaternion, die eine Drehung um die X-Achse um einen Winkel von 0,01 * Pi implementiert.  Drehen Sie den Scheitelpunkt, indem Sie das Quaternion mit einem Vektor multiplizieren, der die Koordinaten des Scheitelpunkts definiert <br><br><pre> <code class="cpp hljs">vertices-&gt;back() = quat * vertices-&gt;back();</code> </pre><br>  Die letzten beiden Aufrufe enthalten die Anzeigeliste und das dimensionale Parallelepiped f√ºr die ge√§nderte Geometrie <br><br><pre> <code class="cpp hljs">quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound();</code> </pre><br>  Im Hauptteil der main () -Funktion erstellen wir ein Quadrat, legen den dynamischen Zeichenmodus daf√ºr fest und f√ºgen einen R√ºckruf hinzu, der die Geometrie √§ndert <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicQuadCallback);</code> </pre><br>  Ich werde den Stammknoten wahllos erstellen und den Viewer starten, da wir dies bereits mindestens zwanzig Mal auf unterschiedliche Weise getan haben.  Als Ergebnis haben wir die einfachste Morphing-Animation <br><br><img src="https://habrastorage.org/webt/rk/oy/rf/rkoyrfpjkx_kan0puqvyj1ocxps.gif"><br><br>  Versuchen Sie nun, den Aufruf setDataVariance () zu entfernen (zu kommentieren).  Vielleicht sehen wir in diesem Fall nichts Kriminelles - standardm√§√üig versucht OSG automatisch zu bestimmen, wann Geometriedaten aktualisiert werden sollen, und versucht, mit dem Rendern zu synchronisieren.  Versuchen Sie dann, den Modus von DYNAMISCH auf STATISCH zu √§ndern, und Sie werden feststellen, dass das Bild nicht reibungslos gerendert wird und sp√ºrbare Rucke, Fehler und Warnungen wie diese in die Konsole gelangen <br><br><pre> <code class="plaintext hljs">Warning: detected OpenGL error 'invalid value' at after RenderBin::draw(..)</code> </pre><br>  Wenn Sie die Methode dirtyDisplayList () nicht ausf√ºhren, ignoriert OpenGL alle √Ñnderungen an der Geometrie und verwendet die am Anfang erstellte Anzeigeliste, um das Quadrat f√ºr das Rendern zu erstellen.  L√∂schen Sie diesen Anruf und Sie werden sehen, dass es keine Animation gibt. <br><br>  Ohne den Aufruf der Methode dirtyBound () wird der Begrenzungsrahmen nicht neu berechnet und OSG schneidet unsichtbare Fl√§chen falsch ab. <br><br><h1>  2. Das Konzept der Bewegungsinterpolation </h1><br>  Angenommen, ein Zug von Station A nach Station B ben√∂tigt 15 Minuten.  Wie k√∂nnen wir diese Situation simulieren, indem wir die Position des Zuges im R√ºckruf √§ndern?  Am einfachsten ist es, die Position von Station A mit der Zeit 0 und Station B mit 15 Minuten zu korrelieren und den Zug gleichm√§√üig zwischen diesen Zeiten zu bewegen.  Dieser einfachste Ansatz wird als lineare Interpolation bezeichnet.  Bei der linearen Interpolation wird ein Vektor, der die Position eines Zwischenpunkts angibt, durch die Formel beschrieben <br><br><pre> <code class="plaintext hljs">p = (1 - t) * p0 + t * p1</code> </pre><br>  wobei p0 der Ausgangspunkt ist;  p1 ist der Endpunkt;  t ist ein Parameter, der gleichm√§√üig von 0 bis 1 variiert. Die Bewegung des Zuges ist jedoch viel komplizierter: Er verl√§sst die Station A, beschleunigt, bewegt sich dann mit konstanter Geschwindigkeit und verlangsamt sich, stoppt an Station B. Ein solcher Prozess kann die lineare Interpolation und nicht mehr beschreiben Es sieht unnat√ºrlich aus. <br><br>  OSG stellt dem Entwickler die osgAnimation-Bibliothek zur Verf√ºgung, die eine Reihe von Standardinterpolationsalgorithmen enth√§lt, mit denen die Bewegung von Szenenobjekten reibungslos animiert werden kann.  Jede dieser Funktionen hat normalerweise zwei Argumente: den Anfangswert des Parameters (normalerweise 0) und den Endwert des Parameters (normalerweise 1).  Diese Funktionen k√∂nnen auf den Beginn der Bewegung (InMotion), auf das Ende der Bewegung (OutMotion) oder auf den Beginn und das Ende der Bewegung (InOutMotion) angewendet werden. <br><br><table><thead><tr><th>  Art der Bewegung </th><th>  in der Klasse </th><th>  aus der Klasse </th><th>  In / Out-Klasse </th></tr></thead><tbody><tr><td>  Lineare Interpolation </td><td>  LinearMotion </td><td>  - - </td><td>  - - </td></tr><tr><td>  Quadratische Interpolation </td><td>  InQuadMotion </td><td>  OutQuadMotion </td><td>  InOutQuadMotion </td></tr><tr><td>  Kubische Interpolation </td><td>  InCubicMotion </td><td>  Outcubicmotion </td><td>  InOutCubicMotion </td></tr><tr><td>  Interpolation 4-Ordnung </td><td>  InQuartMotion </td><td>  OutQuartMotion </td><td>  InOutQuartMotion </td></tr><tr><td>  Bounce-Effekt-Interpolation </td><td>  InBounceMotion </td><td>  OutBounceMotion </td><td>  InOutBounceMotion </td></tr><tr><td>  Elastische R√ºckprallinterpolation </td><td>  InElasticMotion </td><td>  OutElasticMotion </td><td>  InOutElasticMotion </td></tr><tr><td>  Sinusinterpolation </td><td>  InSineMotion </td><td>  Outsinemotion </td><td>  InOutSineMotion </td></tr><tr><td>  Inverse Interpolation </td><td>  Inbackmotion </td><td>  Outbackmotion </td><td>  InOutBackMotion </td></tr><tr><td>  Kreisinterpolation </td><td>  InCircMotion </td><td>  Outcircmotion </td><td>  InOutCircMotion </td></tr><tr><td>  Exponentielle Interpolation </td><td>  InExpoMotion </td><td>  Outexpomotion </td><td>  InOutExpoMotion </td></tr></tbody></table><br>  Um eine lineare Interpolation der Bewegung eines Objekts zu erstellen, schreiben wir einen solchen Code <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgAnimation::LinearMotion&gt; motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::LinearMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><h1>  3. Animation von Transformationsknoten </h1><br>  Trajektorienanimation ist die h√§ufigste Art von Animation in Grafikanwendungen.  Diese Technik kann verwendet werden, um die Bewegung eines Autos, den Flug eines Flugzeugs oder die Bewegung der Kamera zu animieren.  Die Flugbahn ist vordefiniert, wobei alle Positionen, Rotationen und Skalen√§nderungen zu Schl√ºsselzeitpunkten vorgenommen werden.  Wenn der Simulationszyklus beginnt, wird der Zustand des Objekts in jedem Rahmen unter Verwendung einer linearen Interpolation f√ºr Position und Skalierung und einer sph√§rischen linearen Interpolation f√ºr Rotationsquaternionen neu berechnet.  Hierf√ºr wird die interne Methode slerp () der Klasse osg :: Quat verwendet. <br><br>  OSG bietet die Klasse osg :: AnimationPath, um einen zeitlich variierenden Pfad zu beschreiben.  Die Methode dieser Klasse insert () wird verwendet, um Kontrollpunkte, die bestimmten Zeitpunkten entsprechen, zur Trajektorie hinzuzuf√ºgen.  Der Kontrollpunkt wird durch die Klasse osg :: AnimationPath :: ControlPoint beschrieben, deren Konstruktor die Position als Parameter und optional die Parameter f√ºr Objektrotation und Skalierung verwendet.  Zum Beispiel <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;insert(t1, osg::AnimationPath::ControlPoint(pos1, rot1, scale1)); path-&gt;insert(t2, ...);</code> </pre><br>  Hier sind t1, t2 Zeitpunkte in Sekunden;  rot1 ist der Rotationsparameter zum Zeitpunkt t1, der durch die Quaternion osg :: Quat beschrieben wird. <br><br>  Es ist m√∂glich, Animationsschleifen √ºber die setLoopMode () -Methode zu steuern.  Standardm√§√üig ist der LOOP-Modus aktiviert - die Animation wird kontinuierlich wiederholt.  Andere m√∂gliche Werte: NO_LOOPING - Animation einmal abspielen und SWING - Schleife der Bewegung in Vorw√§rts- und R√ºckw√§rtsrichtung. <br><br>  Nachdem alle Initialisierungen abgeschlossen sind, h√§ngen wir das Objekt osg :: AnimationPath an das integrierte Objekt osg :: AnimationPathCallback an, das von der Klasse osg :: NodeCallback abgeleitet ist. <br><br><h1>  4. Ein Beispiel f√ºr eine Animation der Bewegung entlang eines Pfades </h1><br>  Jetzt bewegen wir unsere Cessna in einem Kreis mit dem Mittelpunkt am Punkt (0,0,0).  Die Position des Flugzeugs auf der Flugbahn wird durch lineare Interpolation der Position und Ausrichtung zwischen Schl√ºsselbildern berechnet. <br><br><div class="spoiler">  <b class="spoiler_title">Animcessna Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/AnimationPath&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::AnimationPath *createAnimationPath(double radius, double time) { osg::ref_ptr&lt;osg::AnimationPath&gt; path = new osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); unsigned int numSamples = 32; double delta_yaw = 2.0 * osg::PI / (static_cast&lt;double&gt;(numSamples) - 1.0); double delta_time = time / static_cast&lt;double&gt;(numSamples); for (unsigned int i = 0; i &lt; numSamples; ++i) { double yaw = delta_yaw * i; osg::Vec3d pos(radius * sin(yaw), radius * cos(yaw), 0.0); osg::Quat rot(-yaw, osg::Z_AXIS); path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } return path.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg.0,0,90.rot"); osg::ref_ptr&lt;osg::MatrixTransform&gt; root = new osg::MatrixTransform; root-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = new osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(50.0, 6.0)); root-&gt;setUpdateCallback(apcb.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Wir beginnen mit der Erstellung der Flugbahn des Flugzeugs und nehmen diesen Code in eine separate Funktion auf <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">AnimationPath *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAnimationPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.release(); }</code> </pre><br>  Als Parameter nimmt die Funktion den Radius des Kreises, entlang dem sich die Ebene bewegt, und die Zeit, in der sie eine Umdrehung macht.  Erstellen Sie innerhalb der Funktion ein Trajektorienobjekt und aktivieren Sie den Animationsschleifenmodus <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP);</code> </pre><br>  Folgender Code <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples);</code> </pre><br>  berechnet die Approximationsparameter der Trajektorie.  Wir teilen die gesamte Trajektorie in numSamples von geraden Abschnitten und berechnen die √Ñnderung des Drehwinkels der Ebene um die vertikale Achse (Gieren) delta_yaw und die √Ñnderung der Zeit delta_time beim √úbergang von Abschnitt zu Abschnitt.  Erstellen Sie nun die erforderlichen Kontrollpunkte <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); }</code> </pre><br>  Im Zyklus werden alle Abschnitte der Flugbahn vom ersten bis zum letzten sortiert.  Jeder Kontrollpunkt ist durch einen Gierwinkel gekennzeichnet <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i;</code> </pre><br>  die Position des Massenschwerpunkts des Flugzeugs im Weltraum <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  Die Drehung des Flugzeugs zum gew√ºnschten Gierwinkel (relativ zur vertikalen Achse) wird durch das Quaternion eingestellt <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>;</code> </pre><br>  F√ºgen Sie dann die berechneten Parameter zur Liste der Kontrollpunkte des Pfads hinzu <br><br><pre> <code class="cpp hljs">path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot));</code> </pre><br>  Im Hauptprogramm achten wir auf die Nuance bei der Angabe des Namens der Flugzeugmodelldatei beim Booten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  - Dem Dateinamen wurde das Suffix ".0,0,90.rot" hinzugef√ºgt.  Mit dem Mechanismus zum Laden der Geometrie aus einer in OSG verwendeten Datei k√∂nnen Sie die Anfangsposition und Ausrichtung des Modells nach dem Laden festlegen.  In diesem Fall soll das Modell nach dem Laden um 90 Grad um die Z-Achse gedreht werden. <br><br>  Als N√§chstes wird der Stammknoten erstellt, der der Transformationsknoten ist, und das Modellobjekt wird ihm als untergeordneter Knoten hinzugef√ºgt <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; root-&gt;addChild(model.get());</code> </pre><br>  Erstellen Sie nun einen R√ºckruf f√ºr eine Trajektorienanimation und f√ºgen Sie den von der Funktion createAnimationPath () erstellten Pfad hinzu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(<span class="hljs-number"><span class="hljs-number">50.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>));</code> </pre><br>  H√§ngen Sie diesen R√ºckruf an den Transformationsknoten an <br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback(apcb.get());</code> </pre><br>  Der Viewer wird wie gewohnt initialisiert und gestartet. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Holen Sie sich eine Flugzeugbewegungsanimation <br><br><img src="https://habrastorage.org/webt/ax/01/rl/ax01rlkfna5cfkvzqk3qfao_lmq.gif"><br><br>  Denken Sie, Sie haben in diesem Beispiel nichts Seltsames gefunden?  Zuvor haben Sie beispielsweise in einem Programm beim Rendern in eine Textur die Transformationsmatrix explizit ge√§ndert, um eine √Ñnderung der Position des Modells im Raum zu erzielen.  Hier erstellen wir einfach einen Transformationsknoten und im Code gibt es nirgendwo eine explizite Matrixzuweisung. <br><br>  Das Geheimnis ist, dass die spezielle Klasse osg :: AnimationPathCallback diesen Job erledigt.  Entsprechend der aktuellen Position des Objekts auf dem Pfad berechnet es die Transformationsmatrix und wendet sie automatisch auf den Transformationsknoten an, an den es angeh√§ngt ist, wodurch der Entwickler vor einer Reihe von Routineoperationen bewahrt wird. <br><br>  Es ist zu beachten, dass das Anh√§ngen von osg :: AnimationPathCallback an andere Knotentypen nicht nur keine Auswirkungen hat, sondern auch zu undefiniertem Programmverhalten f√ºhren kann.  Es ist wichtig zu beachten, dass dieser R√ºckruf nur Transformationsknoten betrifft. <br><br><h1>  5. Software-Steuerungsanimation </h1><br>  Die osg :: AnimationPathCallback-Klasse bietet Methoden zum Steuern der Animation w√§hrend der Programmausf√ºhrung. <br><br><ol><li>  reset () - setzt die Animation zur√ºck und spielt sie zuerst ab. <br></li><li>  setPause () - Unterbricht die Animation.  Nimmt einen booleschen Wert als Parameter <br></li><li>  setTimeOffset () - Legt den Zeitversatz vor dem Start der Animation fest. <br></li><li>  setTimeMultiplier () - Legt den Zeitfaktor f√ºr die Beschleunigung / Verz√∂gerung der Animation fest. <br></li></ol><br>  Um beispielsweise die Animation aus der Pause zu entfernen und zur√ºckzusetzen, f√ºhren wir einen solchen Code aus <br><br><pre> <code class="cpp hljs">apcb-&gt;setPause(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); apcb-&gt;reset();</code> </pre><br>  und die Animation ab der vierten Sekunde nach dem Starten des Programms mit doppelter Beschleunigung zu starten, ein solcher Code <br><br><pre> <code class="cpp hljs">apcb-&gt;setTimeOffset(<span class="hljs-number"><span class="hljs-number">4.0f</span></span>); apcb-&gt;setTimeMultiplier(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>);</code> </pre><br><h1>  6. Die Reihenfolge des Renderns von Grundelementen in OpenGL </h1><br>  OpenGL speichert Scheitelpunkt- und Grunddaten in verschiedenen Puffern, z. B. einem Farbpuffer, einem Tiefenpuffer, einem Schablonenpuffer usw.  Au√üerdem √ºberschreibt er nicht die Scheitelpunkte und Dreiecksfl√§chen, die bereits an seine Pipeline gesendet wurden.  Dies bedeutet, dass OpenGL eine neue Geometrie erstellt, unabh√§ngig davon, wie die vorhandene Geometrie erstellt wurde.  Dies bedeutet, dass die Reihenfolge, in der Grundelemente an die Rendering-Pipeline gesendet werden, das auf dem Bildschirm angezeigte Endergebnis erheblich beeinflusst. <br><br>  Basierend auf den Tiefenpufferdaten zeichnet OpenGL undurchsichtige Objekte korrekt und sortiert die Pixel nach ihrem Abstand zum Beobachter.  Bei Verwendung der Farbmischtechnik, beispielsweise beim Implementieren transparenter und durchscheinender Objekte, wird jedoch eine spezielle Operation ausgef√ºhrt, um den Farbpuffer zu aktualisieren.  Die neuen und alten Pixel des Bildes werden unter Ber√ºcksichtigung des Werts des Alphakanals (vierte Farbkomponente) gemischt.  Dies f√ºhrt dazu, dass die Renderreihenfolge der durchscheinenden und undurchsichtigen Kanten das Endergebnis beeinflusst <br><br><img src="https://habrastorage.org/webt/tz/3w/o4/tz3wo4dfy14oscogqvrb1akmh5m.png"><br><br>  In der Abbildung wurden in der linken Situation zuerst undurchsichtige und dann transparente Objekte an die Pipeline gesendet, was zu einer korrekten Verschiebung des Farbpuffers und einer korrekten Anzeige der Gesichter f√ºhrte.  In der richtigen Situation wurden zuerst transparente Objekte und dann undurchsichtig gezeichnet, was zu einer falschen Anzeige f√ºhrte. <br><br>  Die Methode setRenderingHint () der Klasse osg :: StateSet gibt OSG die erforderliche Renderreihenfolge von Knoten und geometrischen Objekten an, falls dies explizit erfolgen muss.  Diese Methode gibt lediglich an, ob durchscheinende Gesichter beim Rendern ber√ºcksichtigt werden sollen oder nicht. Dadurch wird sichergestellt, dass bei durchscheinenden Gesichtern in der Szene zuerst undurchsichtige und dann transparente Gesichter gezeichnet werden, wobei der Abstand zum Betrachter ber√ºcksichtigt wird.  Um die Engine dar√ºber zu informieren, dass dieser Knoten undurchsichtig ist, verwenden wir diesen Code <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::OPAQUE_BIN);</code> </pre><br>  oder enth√§lt transparente Kanten <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><h1>  7. Ein Beispiel f√ºr die Implementierung von durchscheinenden Objekten </h1><br>  Versuchen wir, die obige theoretische Einf√ºhrung anhand eines konkreten Beispiels f√ºr die Implementierung eines durchscheinenden Objekts zu veranschaulichen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr Transparenz</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/BlendFunc&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 0.5f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = new osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); osg::StateSet *stateset = geode-&gt;getOrCreateStateSet(); stateset-&gt;setTextureAttributeAndModes(0, texture.get()); stateset-&gt;setAttributeAndModes(blendFunc); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Der hier gezeigte Code enth√§lt gr√∂√ütenteils nichts Neues: Es werden zwei geometrische Objekte erstellt - ein strukturiertes Quadrat und ein Drachen, dessen Modell aus einer Datei geladen wird.  Wir wenden jedoch eine wei√üe durchscheinende Farbe auf alle Eckpunkte des Quadrats an <br><br><pre> <code class="cpp hljs">colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre><br>  - Der Alpha-Kanal-Wert betr√§gt 0,5, was beim Mischen mit Texturfarben den Effekt eines durchscheinenden Objekts ergeben sollte.  Zus√§tzlich sollte die Farbmischfunktion f√ºr die Transparenzverarbeitung eingestellt werden. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre><br>  √úbergabe an die OpenGL-Zustandsmaschine <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(blendFunc);</code> </pre><br>  Beim Kompilieren und Ausf√ºhren dieses Programms erhalten wir das folgende Ergebnis <br><br><img src="https://habrastorage.org/webt/_m/mz/kz/_mmzkzrmxvmfll-qi0xli6wq_5g.png"><br><br>  H√∂r auf!  Und wo ist die Transparenz?  Die Sache ist, dass wir vergessen haben, der Engine mitzuteilen, dass transparente Kanten verarbeitet werden sollen, was durch Aufrufen leicht gel√∂st werden kann <br><br><pre> <code class="cpp hljs">stateset-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>  Danach erhalten wir das Ergebnis, das wir brauchen - der Drachenfl√ºgel leuchtet durch ein durchscheinendes strukturiertes Quadrat <br><br><img src="https://habrastorage.org/webt/py/bl/ta/pybltaqa6xkligouodxgunwoyvs.png"><br><br>  Die Parameter der Mischfunktionen GL_SRC_ALPHA und GL_ONE_MINUS_SRC_ALPHA bedeuten, dass das resultierende Bildschirmpixel beim Zeichnen eines durchscheinenden Gesichts Farbkomponenten aufweist, die durch die Formel berechnet werden <br><br><pre> <code class="plaintext hljs">R = srcR * srcA + dstR * (1 - srcA) G = srcG * srcA + dstG * (1 - srcA) B = srcB * srcA + dstB * (1 - srcA)</code> </pre><br>  wobei [srcR, srcG, srcB] die Farbkomponenten der quadratischen Textur sind;<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[dstR, dstG, dstB] - Farbkomponenten jedes Pixels des Bereichs, auf dem eine durchscheinende Fl√§che √ºberlagert ist, da der Hintergrund und die undurchsichtigen Kanten des Segelflugzeugfl√ºgels bereits an dieser Stelle gezeichnet sind. </font><font style="vertical-align: inherit;">Mit srcA meine ich die Alpha-Komponente der Farbe des Quadrats. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode seRenderingHint () ordnet das Rendern von Grundelementen perfekt an, ist jedoch nicht sehr effizient, da das Sortieren transparenter Objekte nach Tiefe beim Rendern eines Frames eine ziemlich ressourcenintensive Operation ist. </font><font style="vertical-align: inherit;">Daher sollte der Entwickler die Reihenfolge des Zeichnens der Gesichter selbst festlegen, wenn dies in den vorbereitenden Phasen der Szenenvorbereitung m√∂glich ist.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Animation von Zustandsattributen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe der Animation k√∂nnen Sie auch Statusattribute steuern. </font><font style="vertical-align: inherit;">Durch √Ñndern der Eigenschaften eines oder mehrerer Rendering-Attribute k√∂nnen zahlreiche visuelle Effekte generiert werden. </font><font style="vertical-align: inherit;">Diese Art von Animation, die den Status von Rendering-Attributen √§ndert, kann beim Aktualisieren der Szene einfach √ºber den R√ºckrufmechanismus implementiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassen von Standardinterpolationen k√∂nnen auch verwendet werden, um die Funktion zum √Ñndern von Attributparametern anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits Erfahrung in der Erstellung von durchscheinenden Objekten. </font><font style="vertical-align: inherit;">Wir wissen, dass wir, wenn die Alpha-Komponente der Farbe Null ist, ein vollst√§ndig transparentes Objekt mit einem Wert von 1 erhalten - vollst√§ndig undurchsichtig. </font><font style="vertical-align: inherit;">Es ist klar, dass durch zeitliches Variieren dieses Parameters von 0 bis 1 der Effekt des allm√§hlichen Auftretens oder Verschwindens eines Objekts erhalten werden kann. </font><font style="vertical-align: inherit;">Wir veranschaulichen dies anhand eines konkreten Beispiels.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einblendbeispiel</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/BlendFunc&gt; #include &lt;osg/Material&gt; #include &lt;osgAnimation/EaseMotion&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AlphaFadingCallback : public osg::StateAttributeCallback { public: AlphaFadingCallback() { _motion = new osgAnimation::InOutCubicMotion(0.0f, 1.0f); } virtual void operator() (osg::StateAttribute* , osg::NodeVisitor*); protected: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void AlphaFadingCallback::operator()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (void) nv; osg::Material *material = static_cast&lt;osg::Material *&gt;(sa); if (material) { _motion-&gt;update(0.0005f); float alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, alpha)); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(-0.5f, 0.0f, -0.5f), osg::Vec3(1.0f, 0.0f, 0.0f), osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, 0.5f)); material-&gt;setUpdateCallback(new AlphaFadingCallback); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get()); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(new osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir beginnen mit der Erstellung eines Callback-Handlers zum √Ñndern des Werts des Alphakanals im Laufe der Zeit </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlphaFadingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::StateAttributeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::StateAttribute* , osg::NodeVisitor*)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesch√ºtzte Parameter _motion bestimmt die Funktion, mit der sich der Alpha-Wert im Laufe der Zeit √§ndert. </font><font style="vertical-align: inherit;">In diesem Beispiel w√§hlen wir die kubische Spline-N√§herung und setzen sie sofort im Klassenkonstruktor</font></font><br><br><pre> <code class="cpp hljs">AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Abh√§ngigkeit kann durch eine solche Kurve veranschaulicht werden. </font></font><br><br><img src="https://habrastorage.org/webt/ej/gd/cr/ejgdcr97gkb0lru6evved46sk6q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Konstruktor des InOutCubicMotion-Objekts bestimmen wir die Grenzen des approximierten Werts von 0 bis 1. Als n√§chstes definieren wir den Operator () f√ºr diese Klasse auf diese Weise neu</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AlphaFadingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) nv; osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material) { _motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha)); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Holen Sie sich einen Zeiger auf das Material </font></font><br><br><pre> <code class="cpp hljs">osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der abstrakte Wert des Attributs wird zur√ºckgerufen. Wir werden diesen Handler jedoch an das Material anh√§ngen. Daher ist es der Zeiger auf das kommende Material. Daher k√∂nnen wir das Statusattribut sicher in den Zeiger auf das Material konvertieren. </font><font style="vertical-align: inherit;">Als n√§chstes legen wir das Aktualisierungsintervall der Approximationsfunktion fest - je gr√∂√üer es ist, desto schneller √§ndert sich der Parameter innerhalb des angegebenen Bereichs</font></font><br><br><pre> <code class="cpp hljs">_motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir lesen den Wert der Approximationsfunktion </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und geben Sie dem Material einen neuen diffusen Farbwert </font></font><br><br><pre> <code class="cpp hljs">material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns nun die Szene in der Funktion main () bilden. </font><font style="vertical-align: inherit;">Ich denke, Sie sind jedes Mal m√ºde, ein Quadrat auf den Eckpunkten zu erstellen. Deshalb vereinfachen wir die Aufgabe - wir generieren ein quadratisches Polygon mit der Standard-OSG-Funktion</font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Parameter ist der Punkt, von dem aus die untere linke Ecke des Quadrats erstellt wird. Die beiden anderen Parameter geben die Koordinaten der Diagonalen an. </font><font style="vertical-align: inherit;">Nachdem wir das Quadrat herausgefunden haben, erstellen wir Material daf√ºr</font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Material&gt; material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben die Farboptionen des Materials an. </font><font style="vertical-align: inherit;">Umgebungsfarbe ist ein Parameter, der die Farbe des Materials im schattierten Bereich kennzeichnet, auf den Farbquellen keinen Zugriff haben. </font><font style="vertical-align: inherit;">Diffuse Farbe ist die Farbe des Materials, die die F√§higkeit einer Oberfl√§che charakterisiert, die darauf fallende Farbe zu diffundieren, das hei√üt, was wir im Alltag als Farbe bezeichnen. </font><font style="vertical-align: inherit;">Der Parameter FRONT_AND_BACK gibt an, dass dieses Farbattribut sowohl der Vorder- als auch der R√ºckseite der Geometriefl√§chen zugewiesen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie dem zuvor erstellten Handler Material zu.</font></font><br><br><pre> <code class="cpp hljs">material-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlphaFadingCallback);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordnen Sie das erstellte Material dem Quadrat zu </font></font><br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und andere Attribute festlegen - die Funktion zum Mischen von Farben und zum Anzeigen, dass dieses Objekt transparente Kanten hat </font></font><br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir vervollst√§ndigen die Bildung der Szene und f√ºhren den Betrachter aus </font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/glider.osg"</span></span>)); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erhalten das Ergebnis in Form eines Quadrats, das reibungslos in der Szene erscheint </font></font><br><br><img src="https://habrastorage.org/webt/s5/jv/1h/s5jv1h_ebaecadz6owo60nnrdvg.gif"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstelle einer Schlussfolgerung: eine kleine Bemerkung zu Abh√§ngigkeiten </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherlich wird Ihr Beispiel nicht kompiliert, was zu einem Fehler in der Erstellungsphase f√ºhrt. </font><font style="vertical-align: inherit;">Dies ist kein Zufall - achten Sie auf die Zeile in der Header-Datei main.h</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgAnimation/EaseMotion&gt;</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das OSG-Header-Verzeichnis, aus dem die Header-Datei entnommen wird, verweist normalerweise auf die Bibliothek, die die Implementierung der im Header beschriebenen Funktionen und Klassen enth√§lt. </font><font style="vertical-align: inherit;">Daher sollte das Erscheinungsbild des Verzeichnisses osgAnimation / darauf hindeuten, dass eine gleichnamige Bibliothek zur Linkliste des Projekterstellungsskripts hinzugef√ºgt wird (unter Ber√ºcksichtigung der Pfade zu Bibliotheken und der Erstellungsversion).</font></font><br><br><pre> <code class="cmake hljs">LIBS += -losgAnimation</code> </pre><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437724/">https://habr.com/ru/post/de437724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437712/index.html">Raumstation Roskomnadzor</a></li>
<li><a href="../de437714/index.html">Wir zeichnen eine Cartoon-Explosion f√ºr 180 Zeilen nacktes C ++</a></li>
<li><a href="../de437716/index.html">Drei relativ ehrliche M√∂glichkeiten, ein Flutter-Projekt zu erstellen</a></li>
<li><a href="../de437720/index.html">Der Kampf um Qualit√§tsl√∂sungen bei Erlang / Elixir</a></li>
<li><a href="../de437722/index.html">Kosmische Folgen des amerikanischen Shatdown</a></li>
<li><a href="../de437726/index.html">Kotlin mit Kotlinx serialisieren. Serialisierung</a></li>
<li><a href="../de437730/index.html">Wie wir das Speicherproblem in PostgreSQL gel√∂st haben, ohne ein Byte hinzuzuf√ºgen</a></li>
<li><a href="../de437732/index.html">√úbersicht √ºber den MakeX M-One Pro 70 DLP-Drucker</a></li>
<li><a href="../de437734/index.html">Einrichten von IPTV von Rostelecom auf MikroTik-Routern</a></li>
<li><a href="../de437736/index.html">Wie wir den Start von Selentests durch Moon und OpenShift automatisiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>