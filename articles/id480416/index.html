<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 🧘🏾 👧🏿 Matematika generik tidak aman dalam C # 📏 🎥 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sayangnya, tidak mudah untuk secara memadai menerjemahkan nama keburukan yang saya mulai ke dalam bahasa Rusia. Saya terkejut menemukan bahwa dokument...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matematika generik tidak aman dalam C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Sayangnya, tidak mudah untuk secara memadai menerjemahkan nama keburukan yang saya mulai ke dalam bahasa Rusia.  Saya terkejut menemukan bahwa dokumentasi resmi <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> menyebut "generics" "templates" (mirip dengan templat <code>C++</code> , saya kira).  Dalam edisi ke-4 <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> via <code>C#</code> " yang</a> menarik perhatian saya <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , yang diterjemahkan oleh <a href="https://habr.com/en/company/piter/">Peter</a> , obat generik disebut "generalisasi," yang mencerminkan konsep itu jauh lebih baik.  Artikel ini akan berbicara tentang <em>operasi matematika umum yang tidak aman di <code>C#</code></em> .  Menimbang bahwa <code>C#</code> tidak dimaksudkan untuk komputasi berkinerja tinggi (walaupun, tentu saja, ia mampu melakukan ini, tetapi tidak dapat bersaing dengan <code>C/C++</code> ), operasi matematika di <code>BCL</code> tidak terlalu diperhatikan.  Mari kita coba untuk menyederhanakan pekerjaan dengan tipe aritmatika dasar menggunakan <code>C#</code> dan <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  <strong>Penafian</strong> : artikel ini akan berisi banyak fragmen kode, beberapa di antaranya akan saya ilustrasikan dengan tautan ke sumber daya luar biasa <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) oleh <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  Sebagian besar perhitungan dengan satu atau lain cara mengarah ke operasi dasar.  Penambahan, pengurangan (inversi, negasi), perkalian dan pembagian dapat ditambah dengan operasi perbandingan dan memeriksa kesetaraan.  Tentu saja, semua tindakan ini dapat dengan mudah dan sederhana dilakukan pada variabel tipe aritmatika dasar <code>C#</code> .  Satu-satunya masalah adalah bahwa <code>C#</code> harus <em>tahu</em> pada waktu kompilasi bahwa operasi dilakukan pada tipe tertentu, dan tampaknya menulis metode yang sama-sama efisien (dan transparan) menambahkan dua bilangan bulat dan dua angka floating-point tidak mungkin. </p><br><p>  Mari kita tentukan keinginan kita untuk metode umum hipotetis yang melakukan beberapa operasi matematika sederhana: </p><br><ol><li>  Metode harus memiliki batasan tipe umum yang melindungi kita dari upaya menambahkan (atau mengalikan, membagi) dua tipe arbitrer.  Kami membutuhkan beberapa batasan tipe generik. </li><li>  Untuk kemurnian percobaan, jenis yang diterima dan dikembalikan harus sama.  Misalnya, operator biner harus memiliki tanda tangan dari formulir <code>(T, T) =&gt; T</code> </li><li>  Metode ini setidaknya harus dioptimalkan sebagian.  Misalnya, tinju di mana-mana tidak dapat diterima. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  Dan bagaimana dengan tetangga? </h2><br><p>  Mari kita lihat <code>F#</code> .  Saya tidak kuat di <code>F#</code> , tetapi sebagian besar pembatasan <code>C#</code> ditentukan oleh batasan <code>CLR</code> , yang berarti <code>F#</code> menderita masalah yang sama.  Anda dapat mencoba mendeklarasikan metode penambahan umum yang eksplisit dan metode penambahan yang biasa dan lihat apa yang dikatakan sistem inferensi tipe <code>F#</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  Dalam <a href="https://sharplab.io/" rel="nofollow">hal ini,</a> kedua metode akan berubah menjadi non-umum, dan kode yang dihasilkan akan sama.  Dengan kekakuan sistem tipe <code>F#</code> , di mana tidak ada konversi implisit dari bentuk <code>int -&gt; double</code> , setelah panggilan pertama metode ini dengan parameter tipe <code>double</code> (dalam istilah <code>C#</code> ), metode panggilan dengan parameter jenis lain (bahkan dengan kemungkinan hilangnya akurasi karena konversi jenis) lebih lanjut akan gagal. </p><br><p>  Perlu dicatat bahwa jika Anda mengganti operator <code>+</code> dengan operator persamaan <code>=</code> , <a href="https://sharplab.io/" rel="nofollow">gambar menjadi sedikit berbeda</a> : kedua metode berubah menjadi digeneralisasi (dari sudut pandang <code>C#</code> ), dan metode pembantu khusus, tersedia dalam <code>F#</code> dipanggil untuk melakukan perbandingan. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  Bagaimana dengan <code>Java</code> ? </h3><br><p>  Sulit bagi saya untuk berbicara tentang <code>Java</code> , tetapi, sejauh yang saya tahu, tipe-tipe penting <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">tidak</a> ada dalam bentuk yang biasa bagi kita, tetapi masih ada <em>tipe-</em> tipe <em>primitif</em> .  Untuk bekerja dengan primitif di <code>Java</code> ada <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">pembungkus</a> (misalnya, referensi <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> untuk primitif oleh-nilai <code>long</code> ), yang memiliki <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> kelas basis umum.  Dengan demikian, Anda dapat menggeneralisasi sebagian operasi menggunakan <code>Number</code> , tetapi ini adalah jenis referensi, yang tidak mungkin memiliki efek positif pada kinerja. </p><br><p>  <em>Koreksi saya jika saya salah.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> adalah bahasa untuk curang. <br>  <code>C++</code> membuka jalan bagi fitur yang oleh beberapa orang dianggap ... <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">tidak alami</a> . <br>  Templat (alias templat), berbeda dengan generalisasi (generik), dalam arti harfiah, <em>templat</em> .  Saat mendeklarasikan templat, Anda dapat secara eksplisit membatasi jenis templat yang tersedia.  Karena alasan ini, dalam <code>C++</code> , misalnya, kode berikut ini valid: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , sayangnya, memungkinkan <code>char</code> dan <code>bool</code> sebagai parameter.  Di sisi lain, <code>char</code> dapat setara dengan <code>sbyte</code> dalam terminologi <code>C#</code> , meskipun ukuran sebenarnya dari tipe integer tergantung pada fase platform / kompiler / bulan. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Bahasa Pengetikan Dinamis </h3><br><p>  Akhirnya, pertimbangkan beberapa bahasa yang diketik secara dinamis (dan <em>ditafsirkan</em> ), dipertajam oleh perhitungan.  Dalam bahasa seperti itu, biasanya generalisasi perhitungan tidak menimbulkan masalah: jika jenis parameter cocok untuk dieksekusi, kondisional, penambahan, maka operasi akan dilakukan, jika tidak maka akan gagal dengan kesalahan. </p><br><p>  Dengan <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  Dalam <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Sebaliknya, di dunia C #: kami membatasi jenis fungsi matematika yang umum </h2><br><p>  Sayangnya, kami tidak dapat melakukan ini.  Di <code>C#</code> tipe primitif adalah tipe menurut nilai, mis.  struktur yang, meskipun diwarisi dari <code>System.Object</code> (dan <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), tidak memiliki banyak kesamaan.  Keterbatasan alami dan logis adalah di <code>where T : struct</code> .  Dimulai dengan <code>C# 7.3</code> kita memiliki di <code>where T : unmanaged</code> constraint, yang berarti bahwa <code>T</code> adalah <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  Selain tipe aritmatika primitif yang kita butuhkan, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>setiap</em> <code>Enum</code> dan struktur <em>apa pun</em> yang semua bidangnya memiliki tipe <code>unmanaged</code> sama memenuhi persyaratan ini.  Yaitu  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">tipe ini</a> akan lulus ujian: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Jadi, kita tidak dapat menulis fungsi umum yang hanya menerima tipe aritmatika yang diinginkan.  Karenanya <code>Unsafe</code> dalam judul artikel - kita harus bergantung pada pemrogram menggunakan kode kita.  Upaya untuk memanggil metode umum hipotetis <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> akan menyebabkan hasil yang tidak terduga jika pemrogram melewati objek dari tipe yang tidak kompatibel sebagai argumen. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  Eksperimen pertama, naif: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> adalah alat pertama dan jelas yang dapat membantu kita memecahkan masalah kita.  Tentu saja, menggunakan <code>dynamic</code> untuk perhitungan sama sekali tidak berguna - <code>dynamic</code> setara dengan <code>object</code> , dan metode yang disebut dengan variabel <code>dynamic</code> diubah menjadi refleksi mengerikan oleh kompiler.  Sebagai bonus - mengemas / membongkar jenis menurut nilai kami.  Berikut ini <a href="https://sharplab.io/" rel="nofollow">sebuah contoh</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Lihat saja <code>IL</code> metode <code>Method</code> : </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Dimuat <code>5</code> , <em>dikemas</em> , dimuat <code>6</code> , dikemas, disebut <code>object Add(object, object)</code> . <br>  Opsi jelas tidak cocok untuk kita. </p><br><h2 id="eksperiment-vtoroy-v-lob">  Percobaan kedua, "di dahi" </h2><br><p>  Ya, <code>dynamic</code> bukan untuk kita, tetapi jumlah tipe kita terbatas, dan mereka sudah diketahui sebelumnya.  Mari kita mempersenjatai diri kita dengan <s>linggis</s> cabang dan menuliskannya: jika tipe <em>kita adalah</em> , mari kita hitung sesuatu, jika tidak - inilah pengecualian. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, di sini kita menemukan masalah.  Jika Anda memahami jenis apa yang kami kerjakan, Anda masih dapat menerapkan operasi untuk mereka juga, maka <code>int</code> kondisional yang dihasilkan perlu dikonversi ke tipe <code>T</code> tidak diketahui dan ini tidak terlalu sederhana.  Opsi <code>return (T)(i32Left + i32Right)</code> tidak dapat dikompilasi - tidak ada jaminan bahwa <code>T</code> adalah <code>int</code> (walaupun kita tahu itu adalah).  Anda dapat mencoba pengembalian konversi ganda <code>return (T)(object)(i32Left + i32Right)</code> .  Pertama, jumlahnya dikemas, lalu dibongkar dalam <code>T</code>  Ini <strong>hanya</strong> akan berfungsi jika jenisnya <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">cocok</a> sebelum pengemasan dan setelah pengemasan.  Anda tidak dapat mengemas <code>int</code> , tetapi membukanya <code>double</code> , bahkan jika ada konversi implisit <code>int -&gt; double</code> .  Masalah dengan kode <a href="https://sharplab.io/" rel="nofollow">ini</a> adalah percabangan raksasa dan banyaknya paket yang dibongkar, bahkan dalam kondisi sekalipun.  Opsi ini juga tidak bagus. </p><br><h2 id="refleksiya-i-metadannye">  Refleksi dan Metadata </h2><br><p>  Nah, bermainlah dan itu sudah cukup.  Semua orang tahu bahwa ada operator di <code>C#</code> yang dapat diganti.  Di sana, ada <code>+</code> , <code>-</code> , <code>==</code> , <code>==</code> <code>!=</code> Dan seterusnya.  Yang perlu kita lakukan adalah mengeluarkan metode tipe <code>T</code> statis yang sesuai dengan operator, misalnya, penambahan - itu saja.  Ya, sekali lagi beberapa paket, tetapi tidak ada percabangan dan tidak ada masalah.  Semuanya bisa di-cache oleh tipe <code>T</code> dan umumnya mempercepat proses dengan segala cara, mengurangi satu operasi matematika untuk memanggil metode refleksi tunggal.  Nah, kira-kira seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Sayangnya ini <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">tidak berhasil</a> .  Faktanya adalah bahwa tipe aritmatika (tetapi tidak <code>decimal</code> ) <em>tidak memiliki</em> metode statis.  Semua operasi diimplementasikan melalui operasi <code>IL</code> , seperti <a href="" rel="nofollow"><code>add</code></a> .  Refleksi normal tidak menyelesaikan masalah kita. </p><br><h2 id="systemlinqexpressions">  System.Linq.Ekspresi </h2><br><p>  Solusi berbasis <code>Expressions</code> dijelaskan di blog <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> di <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">sini</a> (oleh Marc Gravell). <br>  Idenya cukup sederhana.  Misalkan kita memiliki tipe <code>T</code> yang mendukung operasi <code>+</code> .  Mari kita membuat ekspresi seperti ini: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Setelah itu, setelah di-cache, kita akan menggunakannya.  Membangun ekspresi seperti itu cukup mudah.  Kami membutuhkan dua parameter dan satu operasi.  Jadi mari kita tuliskan. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  Informasi yang berguna tentang pohon ekspresi dan delegasi diterbitkan di hub </p><br><p>  Secara teknis, ekspresi memungkinkan kita untuk menyelesaikan semua masalah kita - operasi dasar apa pun dapat direduksi menjadi memanggil metode umum.  Operasi yang lebih kompleks dapat ditulis dengan cara yang sama, menggunakan ekspresi yang lebih kompleks.  Ini <em>hampir</em> cukup. </p><br><h2 id="narushaem-vse-pravila">  Kami melanggar semua aturan </h2><br><p>  Apakah mungkin untuk mencapai sesuatu yang lain menggunakan kekuatan <code>CLR/C#</code> ?  Mari kita lihat <s>tahun berapa</s> kode dihasilkan oleh metode penambahan <a href="https://sharplab.io/" rel="nofollow">untuk berbagai jenis</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  Kode <code>IL</code> sesuai berisi serangkaian instruksi yang sama: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Ini adalah kode op sangat <a href="" rel="nofollow"><code>add</code></a> ke mana dikompilasi jenis aritmatika primitif dikompilasi.  <code>decimal</code> di tempat ini memanggil <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Tetapi bagaimana jika kita menulis metode yang akan digeneralisasi, tetapi mengandung persis kode- <code>IL</code> ini?  Yah, John Skeet memperingatkan bahwa ini <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">tidak sepadan</a> .  Dalam kasusnya, ia mempertimbangkan semua jenis (termasuk <code>decimal</code> ), serta analog yang dapat dibatalkan.  Ini akan membutuhkan operasi <code>IL</code> cukup non-trivial dan tentu akan menyebabkan kesalahan.  Tetapi kita masih dapat mencoba menerapkan operasi dasar. </p><br><p>  Yang mengejutkan saya, <code>Visual Studio</code> tidak mengandung template untuk proyek <code>IL</code> dan file <code>IL</code> .  Anda tidak bisa hanya mengambil dan menjelaskan bagian dari kode di <code>IL</code> dan memasukkannya ke dalam perakitan Anda.  Secara alami, open source membantu kami.  Proyek <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> berisi template untuk proyek <code>IL</code> , serta serangkaian instruksi yang dapat ditambahkan ke <code>*.csproj</code> untuk memasukkan kode <code>IL</code> dalam proyek.  Tentu saja, untuk menggambarkan semuanya dalam <code>IL</code> cukup sulit, sehingga penulis proyek menggunakan atribut <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> dengan bendera <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Atribut ini memungkinkan Anda untuk mendeklarasikan metode sebagai <code>extern</code> dan tidak menggambarkan tubuh metode.  Itu terlihat seperti ini: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  Langkah selanjutnya adalah menulis implementasi metode dalam file <code>*.il</code> dengan kode <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  Tidak ada tempat yang secara eksplisit merujuk pada tipe <code>!!T</code> , kami menyarankan <code>CLR</code> untuk menambahkan dua argumen dan mengembalikan hasilnya.  Tidak <strong>ada</strong> pemeriksaan tipe, dan semuanya ada di hati nurani pengembang.  Anehnya, ia bekerja, dan <em>relatif</em> cepat. </p><br><h2 id="nemnogo-benchmarka">  Sedikit patokan </h2><br><p>  Mungkin, tolok ukur yang jujur ​​akan dibangun di atas ekspresi yang agak rumit, perhitungan yang "langsung" akan dibandingkan dengan metode <code>IL</code> -berbahaya ini.  Saya menulis algoritma sederhana yang merangkum kuadrat angka yang sebelumnya dihitung dan disimpan dalam array <code>double</code> dan membagi jumlah akhir dengan jumlah angka.  Untuk melakukan operasi, saya menggunakan <code>C#</code> <code>+</code> , <code>*</code> dan <code>/</code> operator, seperti yang dilakukan orang sehat, fungsi yang dibangun dengan <code>Expressions</code> , dan fungsi <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Hasilnya kira-kira sebagai berikut:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> adalah jumlah yang menggunakan operator standar <code>+</code> , <code>*</code> dan <code>/</code> ; </li><li>  <code>BranchSum</code> menggunakan percabangan berdasarkan jenis dan melemparkan melalui <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> menggunakan percabangan berdasarkan jenis dan <code>Unsafe.As&lt;,&gt;()</code> melalui <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> menggunakan ekspresi cache untuk setiap operasi ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> menggunakan kode <code>IL</code> tidak aman yang disajikan dalam artikel </li></ul><br><p>  Tolok ukur payload - menjumlahkan kuadrat elemen dari array yang diisi secara acak tipe <code>double</code> dan ukuran <code>N</code> , diikuti dengan membagi jumlah dengan <code>N</code> dan menyimpannya;  termasuk optimasi. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  N </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th><th>  Rasio SD </th></tr></thead><tbody><tr><td>  <strong>Directum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 kami</strong> </td><td>  <strong>0,0341 us</strong> </td><td>  <strong>0,0303 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 kami </td><td>  0.4478 kami </td><td>  0.3496 kami </td><td>  26.97 </td><td>  0,46 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1000 </td><td>  72.924 kami </td><td>  0,4131 kami </td><td>  0,3864 kami </td><td>  34.28 </td><td>  0,50 </td></tr><tr><td>  ExpressionSum </td><td>  1000 </td><td>  144.555 kami </td><td>  2.5182 kita </td><td>  2.232 kita </td><td>  67,94 </td><td>  1.29 </td></tr><tr><td>  Unsafesum </td><td>  1000 </td><td>  5.054 kami </td><td>  0,0324 us </td><td>  0,0303 us </td><td>  2.37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directum</strong> </td><td>  <strong>10.000</strong> </td><td>  <strong>21.174 kami</strong> </td><td>  <strong>0.3092 kami</strong> </td><td>  <strong>0.2741 kami</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  10.000 </td><td>  573.972 kami </td><td>  2.9274 kami </td><td>  2.5951 kita </td><td>  11/27 </td><td>  0,40 </td></tr><tr><td>  UnsafeBranchSum </td><td>  10.000 </td><td>  735.031 kami </td><td>  9.1016 kami </td><td>  8.0683 kami </td><td>  34.72 </td><td>  0,53 </td></tr><tr><td>  ExpressionSum </td><td>  10.000 </td><td>  1,462.593 kami </td><td>  9.0932 kami </td><td>  8.0609 kami </td><td>  69,09 </td><td>  1,02 </td></tr><tr><td>  Unsafesum </td><td>  10.000 </td><td>  50.388 kami </td><td>  0.3956 kami </td><td>  0,3701 kami </td><td>  2.38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directum</strong> </td><td>  <strong>100.000</strong> </td><td>  <strong>210.021 kami</strong> </td><td>  <strong>1.9832 kami</strong> </td><td>  <strong>1.7581 kami</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  100.000 </td><td>  6.046.340 kami </td><td>  86.9740 kami </td><td>  77.1002 kami </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  UnsafeBranchSum </td><td>  100.000 </td><td>  7.406.489 kami </td><td>  65.7415 kami </td><td>  58.2782 kami </td><td>  35.27 </td><td>  0,27 </td></tr><tr><td>  ExpressionSum </td><td>  100.000 </td><td>  14.021.642 kami </td><td>  189.2625 kami </td><td>  167.7763 kami </td><td>  66.77 </td><td>  0,88 </td></tr><tr><td>  Unsafesum </td><td>  100.000 </td><td>  505.551 kami </td><td>  2.3662 kami </td><td>  2.2133 kami </td><td>  2.41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directum</strong> </td><td>  <strong>1.024.000</strong> </td><td>  <strong>2,306.751 kami</strong> </td><td>  <strong>22.4173 kami</strong> </td><td>  <strong>20.9692 kita</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1.024.000 </td><td>  61.643.224 us </td><td>  610.3048 kami </td><td>  570.8795 kami </td><td>  26.72 </td><td>  0,28 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1.024.000 </td><td>  75.644.639 kami </td><td>  494.4096 kami </td><td>  462.4711 kami </td><td>  32.80 </td><td>  0,39 </td></tr><tr><td>  ExpressionSum </td><td>  1.024.000 </td><td>  154.327.137 kami </td><td>  1.267.2469 kami </td><td>  1.185.3835 kami </td><td>  66.91 </td><td>  0,55 </td></tr><tr><td>  Unsafesum </td><td>  1.024.000 </td><td>  5,295.990 kami </td><td>  14.9537 kami </td><td>  12.4871 kami </td><td>  2.29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Kode tidak aman kami sekitar <code>2.5</code> kali lebih lambat (dalam satu operasi).  Ini dapat dikaitkan dengan fakta bahwa dalam kasus perhitungan "dahi", kompiler mengkompilasi <code>a + b</code> ke dalam kode <code>add</code> op, dan dalam kasus metode yang tidak aman, fungsi statis disebut, yang secara alami lebih lambat, yang secara alami lebih lambat. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  Alih-alih menyimpulkan: kapan <code>true != true</code> </h2><br><p>  Beberapa hari yang lalu, saya menemukan <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet dari</a> Jared Parsons: </p><br><blockquote>  Ada kasus-kasus di mana yang berikut ini akan mencetak "false" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  Ini adalah jawaban untuk <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">entri ini</a> , yang menunjukkan kode verifikasi <code>bool</code> untuk <code>true</code> , yang terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Cek sepertinya berlebihan, kan?  Jared memberikan contoh tandingan yang menunjukkan <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">beberapa fitur</a> perilaku <code>bool</code> .  Idenya adalah bahwa <code>bool</code> adalah <code>byte</code> ( <code>sizeof(bool) == 1</code> ), sedangkan <code>false</code> cocok dengan <code>0</code> dan <code>true</code> match <code>1</code> .  Selama Anda tidak mengayunkan pointer, <code>bool</code> berperilaku tidak ambigu dan dapat diprediksi.  Namun, seperti yang diperlihatkan Jared, Anda dapat membuat <code>bool</code> menggunakan <code>2</code> sebagai nilai awal, dan bagian dari cek akan gagal dengan benar: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Kami dapat mencapai efek yang sama menggunakan operasi matematika kami yang tidak aman (ini tidak bekerja dengan <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  Ya, ya, kami memeriksa di dalam cabang yang <code>true</code> apakah kondisinya <code>true</code> , dan kami berharap pada kenyataannya itu <em>tidak <code>true</code></em> .  Kenapa begitu?  Jika Anda mengurangi <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) tanpa tanda centang, maka untuk <code>byte</code> ini akan sama dengan <code>255</code> .  Secara alami, <code>255</code> ( <code>fakeTrue</code> kami) bukan <code>1</code> ( <code>true</code> nyata), jadi <code>true</code> dieksekusi.  Bercabang bekerja secara berbeda. </p><br><p>  <code>if</code> inversi terjadi: cabang bersyarat dimasukkan;  jika kondisinya <em>salah</em> , maka transisi ke titik terjadi setelah akhir blok <code>if</code> .  Validasi dilakukan oleh pernyataan <code>brfalse</code> / <code>brfalse_S</code> .  Ini membandingkan nilai terakhir pada stack dengan <em>nol</em> .  Jika nilainya nol, maka itu <code>false</code> , kita melangkahi blok <code>if</code> .  Dalam kasus kami, <code>fakeTrue</code> tidak sama dengan nol, jadi pemeriksaan melewati dan eksekusi berlanjut di dalam blok <code>if</code> , di mana kami membandingkan <code>fakeBool</code> dengan nilai sebenarnya dan mendapatkan hasil negatif. </p><br><p>  UPD01: <br>  Setelah membahas dalam komentar dengan <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> dan <a href="https://habr.com/en/users/shai_hulud/" class="user_link">blowin</a> , saya menambahkan metode lain ke tolok ukur yang mengimplementasikan cabang seperti <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  Terlepas dari kenyataan bahwa <code>JIT</code> harus mengoptimalkan pemeriksaan, setidaknya ketika <code>T</code> adalah sebuah <code>struct</code> , metode tersebut masih bekerja dengan urutan yang lebih lambat.  Tidak jelas apakah transformasi <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> dioptimalkan, atau apakah tinju / unboxing digunakan.  Hasil benchmark <code>MethodImpl</code> dipengaruhi secara signifikan oleh flag <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">xXxVano</a> dalam komentar menunjukkan contoh menggunakan percabangan berdasarkan jenis dan melemparkan <code>T</code> &lt;--&gt; jenis tertentu menggunakan <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Dengan analogi dengan percabangan dan kebiasaan melalui <code>object</code> , saya menulis tiga operasi (penambahan, perkalian dan pembagian) dengan percabangan untuk semua jenis aritmatika, setelah itu saya menambahkan tolok ukur lain ( <code>UnsafeBranchSum</code> ).  Terlepas dari kenyataan bahwa semua metode (kecuali ekspresi) menghasilkan kode asm yang hampir identik (sejauh pengetahuan saya tentang assembler memungkinkan saya untuk menilai), untuk beberapa alasan yang tidak diketahui, kedua metode dengan percabangan sangat lambat dibandingkan dengan penjumlahan langsung ( <code>DirectSum</code> ) dan menggunakan obat generik dan kode <code>IL</code> .  Saya tidak punya penjelasan untuk efek ini, fakta bahwa waktu yang dihabiskan tumbuh secara proporsional ke <code>N</code> menunjukkan bahwa ada semacam overhead konstan untuk <em>setiap</em> operasi, terlepas dari semua keajaiban <code>JIT</code> .  Overhead ini hilang dari versi <code>IL</code> metode.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480416/">https://habr.com/ru/post/id480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480402/index.html">Bagaimana p̶е Androidр Tв̶ы̶й̶ mitap Android kedua dari Tinkoff</a></li>
<li><a href="../id480404/index.html">Mikrotik dan Linux. Rutin dan Otomasi</a></li>
<li><a href="../id480408/index.html">52 dataset untuk proyek pelatihan</a></li>
<li><a href="../id480412/index.html">Alexei Ragozin tentang fitur baru dan lama Java Flight Recorder di OpenJDK 11 di pertemuan jug.msk.ru</a></li>
<li><a href="../id480414/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 393 (9-15 Desember 2019)</a></li>
<li><a href="../id480420/index.html">Wawancara dengan Matthew "Oki" O'Connor tentang Atherosclerosis dan Perawatannya</a></li>
<li><a href="../id480422/index.html">Panduan Gaya Google di C ++. Bagian 1</a></li>
<li><a href="../id480424/index.html">Panduan Gaya Google di C ++. Bagian 9</a></li>
<li><a href="../id480428/index.html">Metode steno paling sederhana. Alfabet dan font untuknya.</a></li>
<li><a href="../id480430/index.html">Cara kerja codec video. Bagian 2. Apa, mengapa, bagaimana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>