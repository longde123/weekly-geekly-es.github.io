<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕 👩‍🔧 👲🏽 (Statis) Pemilihan wadah optimal dalam program C ++ 🚶 😓 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Hari ini saya ingin berbicara lagi tentang analisis statis. Dan lagi tentang C ++. Hanya, tidak seperti PVS-Studio, kami tidak akan mencari kesal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Statis) Pemilihan wadah optimal dalam program C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Halo  Hari ini saya ingin berbicara lagi tentang analisis statis.  Dan lagi tentang C ++.  Hanya, tidak seperti PVS-Studio, kami tidak akan mencari kesalahan dalam program kami (meskipun mereka tidak hanya mencari kesalahan), tetapi untuk tempat-tempat yang tidak ditulis cukup optimal.  Dan salah satu tempat ini memilih wadah untuk data dalam program.  Jika saya menarik bagi Anda, selamat datang di kucing! <br><a name="habracut"></a><br><h3>  Masalah </h3><br>  Pada CoreHard 2018 Autumn (konferensi yang sangat bagus, ayo) saya berbicara tentang bagaimana kompiler C ++ tidak dioptimalkan dengan baik saat ini.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah</a> satu keluhan saya adalah bahwa penyusun tidak dapat mengoptimalkan penggunaan wadah dalam program kami.  Mari kita lihat beberapa contoh kode. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  Tampaknya dalam kasus sederhana seperti itu, kompiler harus dapat mengoptimalkan fungsi ini dan cukup membuang deklarasi variabel dari tipe std :: vector, karena mulai dengan C ++ 14 kompiler diperbolehkan untuk menghapus alokasi memori dinamis, tetapi kompiler tidak.  Alasan untuk ini adalah bahwa saat ini hanya satu kompiler C ++ mengimplementasikan optimasi untuk menghapus alokasi dinamis - Dentang.  Semua kompiler lain sejauh ini tidak tahu bagaimana melakukan ini.  Tetapi bahkan Dentang dapat melakukan ini dalam sejumlah kasus terbatas. <br><br>  Dalam hal ini, kita bisa mengganti std :: vector dengan std :: array, asalkan ukuran vektor yang dipilih tidak terlalu besar, karena kita mungkin tidak memiliki cukup tumpukan untuk penggantian seperti itu.  Penggantian seperti itu akan menghapus alokasi memori yang agak mahal ke heap, dan ditambah adalah ketika menggunakan std :: array, kompiler sudah dapat membuang std :: array dari fungsi sama sekali! <br><br>  Jika kita berbicara tentang pengoptimalan kinerja, kami mengusulkan untuk mempertimbangkan contoh berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Dalam hal ini, kita melihat penggunaan operasi yang sangat tidak efektif dalam kasus std :: vector - insertion di awal wadah.  Semua programmer C ++ tahu bahwa ini sangat buruk untuk dilakukan, karena menyebabkan semua elemen bergeser setiap waktu, yang menyebabkan biaya besar untuk menyalin / memindahkan.  Dalam kasus ini akan jauh lebih baik untuk menggantinya dengan std :: list, yang tidak peduli di mana penyisipan berlangsung, atau std :: deque (meskipun dalam hal ini Anda dapat dengan jelas melihat bahwa Anda tidak hanya perlu menggunakan insert. Tapi ini hanya sebuah contoh, tidak lebih lanjut :) <br><br>  Mari kita lihat contoh kode lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Dalam hal ini, kita dapat melihat bahwa kita dapat dengan mudah mengganti std :: list (ya, saya tahu bahwa beberapa orang menggunakannya) dengan std :: forward_list.  Dalam hal ini, dalam hal ini, kami sama sekali tidak akan kehilangan apa pun, tetapi kami akan mendapatkan penghematan memori.  Secara alami, kompiler tidak melakukan optimasi seperti itu sekarang. <br><br>  Trik serupa dapat dilakukan dalam contoh berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Di sini kita dapat melihat bahwa yang benar-benar kita butuhkan bukanlah std :: deque, tetapi std :: stack.  Ini tidak dapat disebut optimasi, karena std :: stack adalah adaptor, dan secara default menggunakan std :: deque inside (kecuali pengguna menentukan sebaliknya).  Di sini kita dapat berbicara lebih banyak tentang pengoptimalan semantik, mis.  menyederhanakan kode untuk mengerti.  Dari sudut pandang saya, ini juga penting.  Jika Anda bertanya, "Mungkin penggantian seperti itu juga memberikan peningkatan kinerja?", Saya akan menjawab "Mungkin.  Lihat detail implementasi di versi perpustakaan standar Anda. " <br><br>  Yah, saya pikir ada cukup banyak contoh.  Anda masing-masing juga dapat menghasilkan banyak dari mereka. <br><br><h3>  Alat bekas </h3><br>  Untuk mengimplementasikan analisa statis, saya menggunakan Clang Static Analzyer (CSA) dan Clang Tidy, yang merupakan bagian dari paket LLVM.  Saya memilih alat ini, karena saya menganggapnya alat yang paling menjanjikan di antara alat terbuka untuk analisis statis.  Selain itu, Clang menyediakan salah satu parser C ++ berkualitas tinggi yang tidak dapat dibanggakan oleh analisis statis lainnya (kecuali tentu saja mereka menggunakan libclang). <br><br>  Baik CSA dan Clang Tidy adalah penganalisa statis, keduanya merupakan bagian dari LLVM.  Apa bedanya?  Perbedaannya adalah bahwa Clang Tidy dirancang untuk menulis cek sederhana, yang pada dasarnya terdiri dari menemukan semacam pola pada pohon sintaksis abstrak, menampilkan semacam peringatan, dan mungkin menggantinya secara otomatis dengan yang lain.  Anda dapat mempelajari lebih lanjut tentang Clang Tidy di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  CSA dirancang untuk menulis pemeriksaan yang lebih "serius" dan intensif sumber daya (baik dari sudut pandang implementasi, dan dari sudut pandang waktu eksekusi / memori yang dihabiskan).  Di sana, misalnya, mekanisme eksekusi simbolis tersedia. <br><br>  Saya memutuskan untuk mengimplementasikan cek di CSA, karena sepertinya tidak lazim bagi saya, apalagi di masa depan akan semakin sulit.  Dan diputuskan untuk dijalankan melalui Clang Tidy, karena analisa statis ini memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> integrasi dengan berbagai IDE. <br><br><h3>  Bagaimana kita akan (mencoba) menyelesaikan masalah </h3><br>  Untuk memulainya, ada baiknya memperkenalkan beberapa pembatasan yang cukup kuat, yang terutama terkait dengan fakta bahwa ini hanyalah sebuah prototipe: <br><br><ul><li>  Analisis hanya pada tingkat fungsi;  Batasan ini berarti bahwa tidak akan ada analisis antara fungsi, serta antara unit terjemahan.  Pembatasan analisis antar fungsi diberlakukan untuk menyederhanakan implementasi analisis ini dan di masa depan dapat relatif mudah diperbaiki dengan menjalankan analisis statis untuk seluruh unit terjemahan, dan tidak hanya untuk setiap fungsi.  Pembatasan analisis antar unit terjemahan diberlakukan oleh pembatasan yang ada dalam CSA, yang akan segera diperbaiki (komitmen sudah mengalir ke hulu); </li><li>  Dukungan hanya untuk sejumlah kontainer.  Ini relatif mudah diperbaiki di masa mendatang dengan menambahkan aturan baru untuk wadah baru. </li><li>  Gunakan untuk analisis hanya pohon sintaksis abstrak.  Karena untuk membuat prototipe ini adalah jenis analisis yang paling sederhana.  Untuk hasil yang lebih akurat, tentu saja, Anda dapat mencoba menggunakan setidaknya eksekusi simbolis, tetapi metode ini memiliki kekurangan.  Anda dapat membaca lebih lanjut tentang metode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br>  Sekarang prototipe mengimplementasikan algoritma sederhana berikut: <br><br><ul><li>  Pertama, pada pohon sintaksis abstrak, kami menemukan simpul yang bertanggung jawab untuk mendeklarasikan variabel tipe wadah yang kami dukung. </li><li>  Kemudian kami menemukan operasi yang terkait dengan wadah ini, mengklasifikasikannya dan menyimpan informasi ini dalam cache sementara. </li><li>  Setelah mencapai akhir fungsi, kami menganalisis statistik yang dikumpulkan dan, berdasarkan aturan yang telah ditentukan, mengeluarkan rekomendasi tentang penggunaan wadah. </li></ul><br>  Klasifikasi operasi kontainer saat ini adalah sebagai berikut (akan diperluas di masa depan): <br><br><ul><li>  Tambahkan item ke bagian atas wadah. </li><li>  Menambahkan item ke tengah wadah. </li><li>  Menambahkan item ke ujung wadah. </li><li>  Menghapus item dari awal wadah. </li><li>  Menghapus item dari tengah wadah. </li><li>  Menghapus item dari ujung wadah. </li></ul><br>  Klasifikasi saat ini tidak lengkap dan bahkan pada daftar ini tidak berfungsi dengan benar.  Misalnya, operasi penyisipan, bahkan jika itu dilakukan di awal, penganalisis mengklasifikasikan sebagai menyisipkan ke tengah, meskipun pada kenyataannya tidak sama sekali. <br><br><h3>  Melawan positif palsu </h3><br>  Dalam analisis statis apa pun, positif palsu adalah sakit kepala utama.  Jika jumlah mereka terlalu banyak, maka pesan-pesan berguna hilang di sampah.  Oleh karena itu, dalam hal ini, Anda harus bertindak sangat konservatif dan mengeluarkan peringatan hanya dalam kasus di mana kami benar-benar yakin dengan diagnostik kami dan dapat mengatakan bahwa ada sesuatu yang salah di beberapa tempat dalam kode. <br><br>  Jika kita berbicara tentang pengoptimalan kompiler, maka itu masih lebih menyedihkan di sana - pengoptimalan yang tepat tidak dapat mengubah perilaku program menurut Standar C ++ (jika tidak, pengoptimal seperti itu tidak berharga).  Dan optimasi juga tidak boleh menimbulkan pesimisasi :) Jadi di sini Anda harus lebih berhati-hati dalam mengambil keputusan. <br><br>  Dalam penganalisa ini, perjuangan ini menghasilkan fakta bahwa jika penganalisa melihat bahwa beberapa operasi yang tidak didukung saat ini sedang dilakukan, maka analisis untuk wadah ini dimatikan. <br><br><h3>  Kekurangan dan kemungkinan solusi </h3><br>  Ada beberapa masalah dengan metode ini. <br><br>  Masalah pertama adalah bahwa untuk penganalisa saat ini semua cabang kode sama kemungkinannya.  Lebih tepatnya, dia bahkan tidak tahu tentang hal seperti cabang berbeda dari eksekusi kode. <br>  Ini diterjemahkan ke dalam masalah dengan analisis untuk sesuatu seperti kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  Kemungkinan besar, dalam aplikasi kita, cabang kode ini tidak memiliki probabilitas eksekusi yang sama, karena di dunia nyata pointer biasanya menunjukkan sesuatu yang normal, dan bukan nullptr.  Dalam LLVM yang sama ada heuristik statis pada skor ini.  Sebagai contoh, ini mempertimbangkan kasus di atas dengan membandingkan pointer dengan nullptr, dan membandingkan satu sama lain persamaan nilai dua variabel dengan floating point, dan beberapa kasus menarik lainnya.  Tapi ini lebih dan lebih mirip kruk, dan dari sudut pandang saya, solusi nyata untuk masalah ini adalah menambahkan analisis atau instrumentasi yang dinamis. <br><br>  Masalah kedua adalah kurangnya dukungan untuk wadah khusus.  Kita hidup di dunia C ++, mereka suka naik di sini (mari kita tinggalkan diskusi tentang alasan untuk fenomena tidak selalu buruk ini di luar ruang lingkup artikel ini) semuanya, termasuk wadah kami.  Contohnya termasuk LLVM yang sama, LibreOffice, dan banyak lainnya.  Dalam hal ini, muncul pertanyaan - bagaimana menganalisis wadah bukan dari perpustakaan STL?  Lagi pula, saya ingin memasukkan analisis untuk wadah sebanyak mungkin. <br><br>  Ada berbagai cara untuk menyelesaikan masalah. <br><br>  Yang pertama adalah bahwa pengguna membubuhi keterangan wadah mereka dalam beberapa cara (semacam komentar khusus, atribut C ++, sesuatu yang lain).  Masalah dengan metode ini adalah bahwa kita perlu memahami bagaimana membuat anotasi secara umum, informasi apa yang kita butuhkan untuk analisis kualitatif.  Masalah lain mungkin adalah modifikasi kode wadah itu sendiri, yang tidak selalu memungkinkan. <br><br>  Metode kedua menawarkan pengguna mekanisme untuk menulis aturan mereka sendiri.  Saat ini, aturan dalam alat analisis dijahit ke dalam kode sumber alat analisis itu sendiri, dan jika pengguna ingin menambahkan aturan mereka sendiri, maka ia perlu mengunduh kode sumber alat analisis, menyusunnya, mencari cara menulis cek, menulis, membangun kembali, dan sebagainya.  Anda dapat memberi pengguna cara untuk mengatur ceknya pada beberapa DSL, di mana pengguna hanya menulis cek untuk wadahnya, dan penganalisa terlibat dalam seluruh rutinitas.  Saya menganggap metode ini lebih menjanjikan daripada yang sebelumnya. <br><br>  Juga, penggantian wadah otomatis tidak didukung, karena fungsi ini tidak ada dalam CSA (tetapi ada di Clang Tidy).  Tetapi dalam kasus-kasus sulit, melakukan AutoCorrect tidak selalu merupakan tugas yang sepele, dan penganalisa bekerja lebih mungkin dalam mode semi-manual. <br><br><h3>  Kemungkinan aplikasi </h3><br>  Saya melihat beberapa aplikasi untuk jenis analisis ini: <br><br><ol><li>  Seperti analisa statis.  Semuanya sederhana di sini - tes analisis statis lainnya, yang Anda jalankan sesuai keinginan hati Anda (dengan tangan Anda, dalam IDE secara otomatis selama pengembangan, pada CI, dll.), Di mana Anda mungkin akan diberi petunjuk bahwa di suatu tempat Anda bisa ambil wadah dan lebih baik. </li><li>  Seperti pengoptimalan dalam kompiler.  Dalam beberapa kasus, kami dapat menjamin bahwa mengganti wadah tidak akan memengaruhi kinerja secara negatif.  Misalnya, mengganti std :: vektor untuk ukuran kecil yang diketahui pada waktu kompilasi dengan std :: array atau mengganti std :: daftar dengan std :: forward_list ketika kita tidak membutuhkan koneksi dan kita tidak mengambil ukuran dari daftar.  Kompilator dapat mengganti wadah dengan yang lebih optimal tanpa sepengetahuan kami, seperti yang telah dilakukan untuk sejumlah hal yang sangat besar. </li><li>  Seperti analisa dinamis.  Ini adalah arah yang menurut saya paling menjanjikan untuk jenis analisis ini.  Memang, dengan bantuan pengetahuan tentang profil eksekusi program, kami, misalnya, dapat memperoleh informasi penting bagi kami seperti probabilitas setiap eksekusi kode cabang.  Dan ini diperlukan untuk penilaian yang lebih akurat.  Dan dengan analisis seperti itu, Anda sudah bisa berpikir ke arah integrasi dengan PGO ... </li></ol><br>  Perlu juga dicatat bahwa metode ini berlaku tentu saja tidak hanya untuk program C ++.  Saya benar-benar ingin melihat analisis / optimasi statis semacam ini di kompiler dan untuk bahasa pemrograman lain.  Misalnya, penganalisa statis SAP untuk ABAP sudah tahu bagaimana melakukan analisis optimalitas statis pada tingkat dasar, yang merupakan kabar baik.  Jika Anda tahu proyek serupa untuk bahasa pemrograman lain - tulis di komentar dan saya akan menambah artikel! <br><br><h3>  Bekerja dalam arah yang serupa </h3><br>  Untuk dunia C ++, saya belum menemukan analisa seperti itu di mana pun.  Untuk dunia ABAP, saya menyebutkan alat analisa di atas, yang dapat menemukan operasi yang tidak efisien untuk beberapa bagian kontainer standar, tetapi sejauh yang saya tahu, analisis statis yang sangat sederhana diterapkan di sana. <br><br>  Karya yang jauh lebih menarik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chameleon</a> - penganalisis dinamis untuk Java, yang dilakukan dengan sangat cerdik.  Mereka sedikit mengubah JVM, dan selama operasi mereka mengumpulkan berbagai statistik tentang penggunaan kontainer, dan tergantung pada profil muatan saat ini, mereka memilih wadah tertentu dan menggantinya secara otomatis selama operasi.  Sayangnya, sumber ditutup dan tidak ada kesempatan untuk mendapatkannya (saya mencoba). <br><br>  Saya juga merekomendasikan melihat berbagai karya (ada banyak) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SETL</a> .  Di dalamnya, penulis juga sering mengajukan pertanyaan tentang pemilihan otomatis wadah. <br><br><h3>  Referensi </h3><br><ol><li>  Implementasi saat ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Rusia 2017: Yuri Efimochev, clang-rapi: perjalanan di dalam C ++ Abstrak Sintaksis Pohon</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bunglon: Seleksi Koleksi yang Adaptif</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bunyikan panduan analisa statis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Obrolan berbahasa Rusia</a> tentang pengembangan kompiler di Telegram.  Jika Anda tertarik, masuklah, itu sangat menarik di sana.  Berhati-hatilah dengan banjir - mereka akan segera menghukumnya :) </li></ol><br>  Alih-alih kesimpulan, saya ingin fokus pada kenyataan bahwa itu hanya prototipe sejauh ini dan memiliki terlalu banyak "lubang" dalam implementasi.  Dalam artikel ini, saya hanya ingin berbagi dengan Anda gagasan tentang analisis seperti itu dan mempopulerkannya.  Yah, mungkin seseorang akan tertarik pada topik ini dan akan ada keinginan untuk terhubung ke proyek - Saya hanya akan senang!  Selain itu, Anda selalu dapat mengumpulkan analisa ini di tempat Anda sendiri untuk mencobanya pada contoh pengujian Anda. <br><br>  Jika Anda memiliki sesuatu untuk melengkapi materi, mengalami tugas yang serupa, atau sekadar memiliki beberapa informasi yang mungkin berguna pada topik ini - jangan ragu untuk membagikan informasi ini di komentar. <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455379/">https://habr.com/ru/post/id455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455369/index.html">Sertifikasi administrator basis data dan banyak lagi di peringatan DevConfX (21-22 Juni di Moskow)</a></li>
<li><a href="../id455371/index.html">Sumber arus stabil dari 5 μA hingga 20 mA</a></li>
<li><a href="../id455373/index.html">Bagaimana cara menyesuaikan hukum Spring sehingga menjadi tinggi untuk penyedia kecil? Batalkan</a></li>
<li><a href="../id455375/index.html">Menulis UDR dalam Pascal</a></li>
<li><a href="../id455377/index.html">Arsitektur IoT</a></li>
<li><a href="../id455381/index.html">3CX merespon dukungan teknis: menangkap lalu lintas SIP di server PBX</a></li>
<li><a href="../id455387/index.html">Memahami Pembelajaran Mesin di Elastic Stack (alias Elasticsearch, alias ELK)</a></li>
<li><a href="../id455389/index.html">Haxe 4: Apa yang Baru?</a></li>
<li><a href="../id455391/index.html">Bagian 1: RISC-V / RocketChip di Habitat Tidak Alami</a></li>
<li><a href="../id455393/index.html">Tentang penggunaan metode parametrik estimasi spektral dalam radar - metode MUSIC. Penambahan artikel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>