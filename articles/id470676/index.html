<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱🏿 🆑 🤴🏽 Memecahkan masalah algoritmik: kemungkinan memesan hotel 🧑🏿‍🤝‍🧑🏻 🏬 👉🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel ini disiapkan khusus untuk siswa dari kursus "Algoritma untuk Pengembang" . 



 Artikel ini adalah bagian dari seri tentang bagaim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecahkan masalah algoritmik: kemungkinan memesan hotel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/470676/">  <i><b>Terjemahan artikel ini disiapkan khusus untuk siswa dari kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Algoritma untuk Pengembang"</a> .</b></i> <br><br><img src="https://habrastorage.org/webt/--/ea/mq/--eamqk7ybfubuntwpzpxl7wk0e.png"><br><br>  <i>Artikel ini adalah bagian dari seri tentang bagaimana menyelesaikan masalah algoritmik.</i>  <i>Berdasarkan pengalaman pribadi saya, saya menemukan bahwa sebagian besar sumber daya hanya menggambarkan solusi secara detail.</i>  <i>Penjelasan dari garis utama penalaran yang memungkinkan menemukan solusi yang efektif, sayangnya, tidak terlalu umum.</i>  <i>Oleh karena itu, tujuan dari seri ini adalah untuk menjelaskan kemungkinan cara berpikir untuk menyelesaikan masalah dari awal.</i> <br><br><hr><a name="habracut"></a><br><h3>  Tantangan </h3><br><blockquote><ul><li>  Tugas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InterviewBit</a> </li></ul><br>  Manajer hotel harus memproses pesanan reservasi N untuk musim berikutnya.  Hotelnya memiliki kamar K.  Informasi pemesanan berisi tanggal check-in dan tanggal check-out.  Manajer ingin mencari tahu apakah ada cukup kamar di hotel untuk memenuhi permintaan. <br><br>  Input data: <br><br>  - Yang pertama masuk daftar dengan informasi tentang waktu kedatangan <br>  - Kedua - daftar dengan informasi tentang waktu keberangkatan <br>  - Ketiga - K, menunjukkan jumlah kamar <br><br>  Output data: <br>  - Nilai logis yang menunjukkan kemampuan memesan kamar <br>  false berarti hotel tidak memiliki cukup kamar untuk pemesanan N <br>  benar berarti hotel ini memiliki cukup kamar untuk pemesanan N. <br><br>  <b>Contoh:</b> <br><br>  Input data: <br>  - check-in = [1, 3, 5] <br>  - keberangkatan = [2, 6, 10] <br>  - K = 1 <br><br>  Output: salah.  Pada hari = 5 hotel ini memiliki 2 tamu.  Tetapi kami hanya memiliki satu nomor. <br><br><ul><li>  Kategori: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Array</a> </li></ul><br></blockquote><br><h3>  Proses pengambilan keputusan </h3><br>  Tugas ini menarik, menurut saya, karena ada banyak cara berbeda untuk menyelesaikannya.  Mari kita lihat opsinya. <br><br>  Struktur yang menyimpan penghitung untuk setiap hari <br>  Gagasan pertama mungkin bahwa kita membutuhkan struktur untuk menyimpan jumlah pesanan untuk setiap hari.  Struktur ini dapat berupa larik dengan ukuran tetap (ditentukan oleh hari keberangkatan maksimum). <br><blockquote>  Input data: <br>  - entri = [1, 3, 5] <br>  - keberangkatan = [2, 6, 10] <br>  - k = 1 <br></blockquote><br>  Untuk contoh ini, ukuran array adalah 10 (karena keluar terakhir pada hari 10).  Untuk mengisi larik ini, kita melihat daftar entri dan keluar dan menambah atau mengurangi penghitung hari yang sesuai.  Contoh kode semu: <br><br><pre><code class="bash hljs">int[] counts = new int[maxDepartures(departures)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each arr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arrivals { counts[arr]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each dep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> departures { counts[dep]-- }</code> </pre> <br>  Hasilnya, kami mendapatkan array berikut: <br><br> <code>: 1 0 1 1 2 1 1 1 1 0 <br> : 1 2 3 4 5 6 7 8 9 10</code> <br> <br>  Setelah array penuh, Anda hanya perlu melihatnya dan memeriksa apakah semua elemen tidak melebihi <code>k</code> (jumlah kamar). <br><br>  Pada contoh sebelumnya, jumlah kamar maksimum adalah 1. Karena pada hari ke 5 kami memiliki 2 pemesanan, kami mengembalikan <code>false</code> . <br><br>  Kompleksitas waktu dari solusi ini adalah O (n), di mana n adalah jumlah pemesanan, dan spasial adalah O (m), di mana m adalah hari keberangkatan maksimum.  Tidak buruk dalam teori, tetapi kemungkinan akan mengalokasikan banyak memori untuk array besar, meskipun sebagian besar tidak akan digunakan. <br><br>  Sebagai contoh: <br><blockquote>  Input data: <br>  - entri = [1, 3, 5] <br>  - keberangkatan = [2, 10000, 10] <br>  - k = 1 </blockquote><br>  Dalam hal ini, array 10 ribu bilangan bulat akan dialokasikan. <br><br>  Mari kita lihat solusi lain. <br><br><h3>  Penyimpanan Koleksi Acara </h3><br>  Opsi apa lagi yang ada?  Mari kita lihat kembali apa yang terjadi dengan struktur sebelumnya: <br><br> <code>: 1 0 1 1 2 1 1 1 1 0 <br> : 1 2 3 4 5 6 7 8 9 10</code> <br> <br>  Kami melihat bahwa beberapa informasi digandakan.  Misalnya, antara 6 dan 9 hari jumlah pemesanan tidak berubah, karena kami tahu bahwa tidak akan terjadi apa-apa selama periode waktu ini. <br><br>  Mungkinkah lebih baik jika acara disimpan saja?  Mari kita ambil contoh yang sama lagi: <br><blockquote>  Input data: <br>  - entri = [1, 3, 5] <br>  - keberangkatan = [2, 6, 10] <br>  Hari 1: +1 pemesanan <br>  Hari 2: -1 pemesanan <br>  Hari 3: +1 pemesanan <br>  Hari 6: -1 pemesanan <br>  Hari 5: +1 pemesanan <br>  Hari 10: -1 pemesanan </blockquote><br>  Solusinya adalah dengan mengulangi peristiwa ini untuk menambah atau mengurangi penghitung.  Jika pada titik tertentu penghitung lebih besar dari <code>k</code> , kami mengembalikan <code>false</code> .  Namun, untuk mengulanginya, koleksi acara ini perlu disortir. <br><br>  Struktur apa yang lebih baik untuk digunakan di sini?  Mari kita simpulkan persyaratan kami: <br><br><ul><li>  Cari untuk memeriksa apakah hari seperti itu sudah ada </li><li>  Menambahkan hari baru, </li><li>  Lihat struktur untuk beralih setiap hari yang disortir. </li></ul><br>  Bagaimana dengan menggunakan pohon pencarian biner (BST)? <br><br>  Setiap node dapat direpresentasikan sebagai berikut: <br><br><pre> <code class="plaintext hljs">class Node { int day int count Node left Node right }</code> </pre> <br>  Penyortiran akan dilakukan di bidang <code>day</code> . <br><br>  Mari kita lihat konsekuensi dari segi kompleksitas waktu: <br><br><ul><li>  Cari untuk memeriksa apakah hari seperti itu sudah ada: O (log (n)) dalam kasus rata-rata, O (n) dalam kasus terburuk, </li><li>  Menambahkan hari baru: O (log (n)) dalam kasus rata-rata, O (n) dalam kasus terburuk, </li><li>  Lihat struktur untuk iterasi setiap hari yang diurutkan: O (n) menggunakan pencarian mendalam. </li></ul><br>  Karena kita harus mengulangi setiap elemen dan memasukkannya ke dalam pohon, kompleksitas algoritma adalah O (n log (n)) dalam kasus rata-rata, O (n²) dalam kasus terburuk. <br><br>  Pilihan lain adalah menggunakan tabel hash dan mengurutkan tombol setelah menambahkan semua acara: <br><br><ul><li>  Cari untuk memeriksa apakah hari seperti itu sudah ada: O (1) dalam kasus rata-rata, O (n) dalam kasus terburuk (probabilitas tergantung pada kapasitas array asosiatif), </li><li>  Menambahkan hari baru: O (1) dalam kasus rata-rata, O (n) dalam kasus terburuk, </li><li>  Lihat struktur untuk iterasi setiap hari yang disortir: O (n log (n)) untuk kunci penyortiran dan O (n) untuk penyortiran. </li></ul><br>  Pada akhirnya, solusinya memiliki O (n log (n)) dalam case tengah (karena operasi sortir), O (n²) dalam case terburuk.  Solusi ini tampaknya memiliki kompleksitas yang sama dengan solusi berbasis pohon. <br><br>  Mari kita lihat kemungkinan implementasi di Java menggunakan array asosiatif yang diurutkan: <br><br><pre> <code class="bash hljs">public boolean hotel(ArrayList&lt;Integer&gt; arrivals, ArrayList&lt;Integer&gt; departures, int k) { //   Map&lt;Integer, Integer&gt; events = new HashMap&lt;&gt;(); //   int n = arrivals.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = 0; i &lt; n; i++) { int arrival = arrivals.get(i); int departure = departures.get(i); //      Integer current = events.get(arrival); events.put(arrival, current == null ? 1 : current + 1); //      current = events.get(departure); events.put(departure, current == null ? -1 : current - 1); } //    Map&lt;Integer, Integer&gt; sortedEvents = new TreeMap&lt;&gt;(events); int count = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;Integer, Integer&gt; entry : sortedEvents.entrySet()) { count += entry.getValue(); //  count     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; k) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Kompleksitas spasial yang konstan </h3><br>  Jika kita ingin mengoptimalkan algoritme kita, kita perlu memikirkan apakah benar-benar perlu untuk menyimpan semua peristiwa ini?  Tidak bisakah kita memilah-milah data pengumpulan (entri dan keluar) dan memeriksa batas reservasi dalam proses? <br><br>  Sebuah solusi mungkin dilakukan, tetapi untuk ini perlu menyederhanakan data input dengan mengurutkannya terlebih dahulu. <br><br>  Jika kedua koleksi diurutkan, kita dapat dengan mudah beralih ke setiap elemen menggunakan dua pointer (satu untuk pintu masuk dan yang lainnya untuk pintu keluar), dan memeriksa batasan dengan cepat. <br><br>  Seperti yang Anda lihat, selama setiap iterasi kita masih perlu memeriksa minimum antara <code>arrivals.get(indexArrival)  departures.get(indexDeparture)</code> untuk mencari tahu pointer mana yang perlu diperbarui. <br><br>  Secara umum, algoritma memiliki kompleksitas temporal dan spasial O (n log (n)) yang konstan karena operasi penyortiran. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470676/">https://habr.com/ru/post/id470676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470664/index.html">Intel memperkenalkan jajaran prosesor Xeon baru. Mereka lebih murah daripada model sebelumnya, tetapi masih pada 14 nm</a></li>
<li><a href="../id470666/index.html">IT-Hogwarts: Sekolah Pemrogram hh.ru</a></li>
<li><a href="../id470670/index.html">Cara membuat sepeda listrik yang pintar</a></li>
<li><a href="../id470672/index.html">Implementasi Service Desk dan CRM. 13 penyebab utama kegagalan dan bagaimana cara menghindarinya?</a></li>
<li><a href="../id470674/index.html">Di dalam JeMalloc. Struktur Data Inti: Pairing Heap & Bitmap Tree</a></li>
<li><a href="../id470680/index.html">Bahasa Terbaik untuk Pelokalan Game</a></li>
<li><a href="../id470684/index.html">Apa yang harus ditulis dalam resume jika tidak ada pengalaman kerja</a></li>
<li><a href="../id470686/index.html">Teknologi untuk kota pintar. Akankah St. Petersburg menjadi kota metropolis pertama yang nyaman bagi orang buta?</a></li>
<li><a href="../id470688/index.html">Apa yang diketahui tentang VMworld 2019</a></li>
<li><a href="../id470692/index.html">Bagaimana kami membuat situs web Rosbank baru, dan apa yang terjadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>