<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👣 👋🏿 🥅 TDDx2, BDD, DDD, FDD, MDD y PDD, o lo que quieras saber sobre el desarrollo impulsado 🍋 🎱 🤚🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al revisar los artículos sobre diseño de software, me encontré constantemente con una nube de abreviaturas sin precedentes y prácticas de desarrollo m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDDx2, BDD, DDD, FDD, MDD y PDD, o lo que quieras saber sobre el desarrollo impulsado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459620/"><p>  Al revisar los artículos sobre diseño de software, me encontré constantemente con una nube de abreviaturas sin precedentes y prácticas de desarrollo mencionadas casualmente. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8v/ge/gp/8vgegpum3fifmxfni0u_ysms0to.jpeg"></div><br><ul><li>  <strong>TDD</strong> : bueno, todos lo saben, primero escribimos pruebas y luego el resto del código. </li><li>  <strong>BDD</strong> es algo familiar, algo así como pruebas también, pero especiales. </li><li>  <strong>TDD</strong> - ¿Otra vez?  Entonces, detente, aquí no se trata de pruebas en absoluto.  ¿Pero por qué se llama igual? </li><li>  <strong>DDD</strong> : contextos vinculados, lenguaje ubicuo, dominio ... </li><li>  <strong>Fdd</strong> </li><li>  <strong>MDD</strong> : ¿en serio, basado en gráficos? </li><li>  <strong>PDD</strong> - ... </li></ul><br><p>  Los enfoques de desarrollo se dividen por complejidad, áreas de aplicación y objetivos. <br>  Creo que ha llegado el momento de descubrir por qué son necesarios, por qué hay tantos y cómo pueden sernos útiles. </p><br><p>  Comenzaremos a familiarizarnos con ellos desde los más simples hasta los más complejos, considere ejemplos de uso y las ventajas y desventajas de cada uno de ellos. </p><a name="habracut"></a><br><h1 id="tdd---test-driven-development">  TDD - Desarrollo guiado por pruebas </h1><br><p>  <strong>TDD</strong> es una metodología de desarrollo de software que se basa en repetir ciclos cortos de desarrollo: inicialmente se escribe una prueba que cubre el cambio deseado, luego se escribe el código del programa que implementa el comportamiento deseado del sistema y le permite pasar la prueba escrita.  Luego, el código escrito se refactoriza con pruebas constantes de las pruebas. </p><br><p>  Suena simple y claro.  Muchos están familiarizados con este enfoque del desarrollo, e incluso el propio tío Bob lo está promoviendo activamente. </p><br><blockquote>  TDD se considera una forma de construcción de aplicación adecuada.  La filosofía de desarrollo basada en pruebas es que sus pruebas son una especificación de cómo debe comportarse su programa.  Si considera que su conjunto de pruebas es una parte obligatoria del proceso de compilación, si sus pruebas fallan, el programa no se compila porque es incorrecto.  Por supuesto, la limitación es que la exactitud de su programa solo se define como la integridad de sus pruebas.  Sin embargo, los estudios han demostrado que el desarrollo basado en pruebas puede reducir los errores en un 40-80% en la producción. </blockquote><p>  Cuando comience a usar TDD, puede sentir que está corriendo más lento de lo normal.  Esto se debe a que trabajará fuera de la "zona de confort", y esto es bastante normal. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/uc/s_/t5ucs_g6howdrtrlnmarn6zv1ag.png"></div><br><p>  Una vez que siente que escribir pruebas se ha convertido en una parte simple y natural del flujo de trabajo, que ya no necesita pensar en usar TDD cuando trabaja en un proyecto, se da cuenta de que TDD ha entrado en su trabajo. </p><br><p>  Esta metodología nos permite lograr la creación de una aplicación adecuada para las pruebas automáticas y una muy buena cobertura del código con las pruebas, ya que TK se traduce al lenguaje de las pruebas automáticas, es decir, se comprueba todo lo que el programa debe hacer.  TDD a menudo también simplifica la implementación de software: se elimina la redundancia de implementación; si un componente pasa la prueba, entonces se considera listo. </p><br><p>  La arquitectura de los productos de software desarrollados de esta manera suele ser mejor (en aplicaciones que son adecuadas para pruebas automáticas, la responsabilidad entre los componentes suele estar muy bien distribuida y los procedimientos complejos que se realizan se descomponen en muchos simples).  La estabilidad de la aplicación desarrollada a través de las pruebas es mayor debido al hecho de que todas las funcionalidades básicas del programa están cubiertas por las pruebas y su rendimiento se verifica constantemente.  El acompañamiento de proyectos en los que se prueba todo o casi todo es muy alto: los desarrolladores pueden no tener miedo de hacer cambios en el código, si algo sale mal, los resultados de las pruebas automáticas informarán sobre esto. </p><br><p>  Puede obtener más información sobre los principios de TDD leyendo el libro de Kent Beck Programación extrema Desarrollo a través de pruebas. </p><br><h2 id="tdd---type-driven-development">  TDD - Desarrollo dirigido por tipo </h2><br><p>  Type Driven Development se abrevia, así como el desarrollo a través de pruebas, por lo que generalmente se escribe el nombre completo. </p><br><p>  Cuando se desarrolla sobre la base de tipos, sus tipos de datos y firmas de tipos son una especificación del programa.  Los tipos también sirven como una forma de documentación que se garantiza que se actualizará. </p><br><p>  Los tipos son pequeños puntos de control, gracias a los cuales obtenemos muchas mini pruebas en toda nuestra aplicación.  Además, los costos de crear tipos son mínimos y no es necesario actualizarlos, ya que son parte de la base del código. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/7h/y5/ue7hy5tcox8zmj5hngev707m994.jpeg"></div><br><p>  El desarrollo por tipo es otro buen método para construir una aplicación.  Al igual que con el desarrollo basado en pruebas, el desarrollo basado en tipos puede aumentar su confianza en su código y ahorrarle tiempo al realizar cambios en una base de código grande. </p><br><p>  De las desventajas, solo la creciente complejidad de los idiomas con tipeo dinámico.  Por ejemplo, para JavaScript, este enfoque es más difícil de aplicar que para TypeScript. </p><br><p>  En un habr hay un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> sobre mecanografía. </p><br><h2 id="bdd---behaviour-driven-development">  BDD - Desarrollo impulsado por el comportamiento </h2><br><p>  Debido a algunas similitudes metodológicas, TDD (Test Driven Development) y BDD (Behavior Driven Development) a menudo se confunden incluso por profesionales.  Cual es la diferencia  Los conceptos de ambos enfoques son similares, se llevan a cabo las primeras pruebas y solo luego comienza el desarrollo, pero su propósito es completamente diferente.  TDD tiene más que ver con la programación y las pruebas en el nivel de implementación técnica del producto, cuando las pruebas son creadas por los propios desarrolladores.  <strong>BDD involucra a un probador o analista que describe scripts definidos por el usuario en un lenguaje natural</strong> , si puedo decirlo, en el lenguaje de los negocios. </p><br><blockquote>  BDD: el desarrollo basado en el comportamiento es un desarrollo basado en el comportamiento.  Cierta persona (o personas) escribe descripciones del formulario "como usuario que quiero cuando se presiona el botón de inicio y luego se muestra el menú como en la imagen" (hay palabras clave especialmente resaltadas).  Los programadores han escrito durante mucho tiempo herramientas especiales que traducen tales descripciones en pruebas (a veces completamente transparentes para el programador).  Y luego el desarrollo clásico con pruebas. </blockquote><p>  Si registra los nombres de las pruebas en forma de oraciones y utiliza el vocabulario del dominio comercial para escribir los nombres de los métodos, la documentación creada queda clara para los clientes, analistas y evaluadores. </p><br><p>  Los textos del guión se escriben en una forma específica. </p><br><blockquote>  Tener (aprox. Dado - dado) algún contexto, <br><br>  Cuando (tenga en cuenta cuándo) se produce un evento, <br><br>  Luego (aprox. Entonces) verifique el resultado. </blockquote><p>  Algo como esto podría suceder: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/dq/zd/padqzdoeivthlm1ii0qe65htcoe.png"></div><br><p>  O otro ejemplo en ruso: </p><br><blockquote>  Escenario 1: hay dinero en la cuenta + <br><br>  <strong>Tener una</strong> cuenta con dinero <br><br>  <strong>Y una</strong> tarjeta válida <br><br>  <strong>Y un</strong> cajero automático con efectivo <br><br>  <strong>Cuando un</strong> cliente solicita efectivo <br><br>  <strong>Luego,</strong> asegúrese de que la cuenta haya sido cargada <br><br>  <strong>Y</strong> asegúrese de que se emita efectivo <br><br>  <strong>Y</strong> asegúrese de devolver la tarjeta </blockquote><p>  El enfoque BDD, junto con las prácticas de ingeniería, nos permitió abandonar la documentación heredada que contiene información irrelevante y recibir nueva documentación sobre la marcha, almacenarla con el proyecto, lo que acercó a los analistas y probadores al código. </p><br><p>  BDD es más bien un proceso cuyo objetivo es reducir el costo de implementar nuevas características.  Incluso al comienzo del desarrollo, obtenemos artefactos importantes.  Por ejemplo, documentación que sea comprensible para soportar.  Esta documentación brinda una oportunidad para que todas las partes interesadas comprendan el producto y los escenarios de comportamiento del usuario que deben implementarse durante las iteraciones de desarrollo.  Con el enfoque BDD, también bajamos el umbral para que nuevos miembros ingresen al proyecto. </p><br><h3 id="v-chem-preimuschestvo-bdd">  ¿Cuál es la ventaja de BDD? </h3><br><ul><li>  Pruebas legibles para no programadores. </li><li>  Son fáciles de cambiar.  A menudo se escriben en inglés casi puro. </li><li>  Pueden ser escritos por el propietario del producto u otras partes interesadas. </li><li>  Los resultados de la prueba son más humanos. </li><li>  Las pruebas son independientes del lenguaje de programación de destino.  La migración a otro idioma se simplifica enormemente. </li></ul><br><h3 id="minusy">  Contras: </h3><br><p>  Pero este enfoque tiene sus inconvenientes: es largo y costoso.  BDD es inconveniente incluso si requiere la participación de especialistas en pruebas que ya están en la etapa de desarrollo de requisitos, y esto alarga el ciclo de desarrollo. </p><br><p>  La solución a esta situación puede ser la elección de un marco BDD adecuado y procesos de desarrollo adecuadamente construidos. </p><br><p>  Lea más sobre BDD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Muchos han entendido durante mucho tiempo que las pruebas son una especie de panacea para todas las enfermedades, pero ¿es realmente así?  Por supuesto, el código probado a fondo funciona de manera más estable y predecible, pero las pruebas no nos salvan de problemas y errores en la etapa de diseño y configuración de tareas.  Los siguientes enfoques de desarrollo pueden ayudarlo con esto. </p><br><h2 id="ddd---domain-driven-design">  DDD - Diseño impulsado por dominio </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/yv/qy/r2yvqyh9gninztlb6_k0paa6pjm.png"></div><br><p>  El diseño orientado a temas no es una tecnología o metodología específica.  DDD es un conjunto de reglas que le permiten tomar las decisiones de diseño correctas.  Este enfoque puede acelerar significativamente el proceso de diseño de software en un dominio desconocido. </p><br><blockquote>  <strong>El diseño orientado a temas</strong> (con menos frecuencia orientado a problemas, inglés. Diseño impulsado por dominios, DDD) es un conjunto de principios y esquemas destinados a crear sistemas óptimos de objetos.  El proceso de desarrollo se reduce a la creación de abstracciones de software, que se denominan modelos de dominio.  Estos modelos incluyen lógica de negocios que establece una relación entre las condiciones reales del área de aplicación del producto y el código. </blockquote><p>  El enfoque DDD es especialmente útil en situaciones donde el desarrollador no es un especialista en el campo del producto desarrollado.  Por ejemplo: un programador no puede conocer todas las áreas en las que se requiere crear software, pero con la ayuda de una representación correcta de la estructura, a través de un enfoque orientado a temas, puede diseñar fácilmente una aplicación basada en puntos clave y el conocimiento del espacio de trabajo. </p><br><p>  En este artículo, trato de transmitir la esencia de cada enfoque para el desarrollo de software, pero sobre DDD puedes escribir más de un artículo y cubrir todos los matices en varios párrafos, no funcionará para mí.  Por lo tanto, al explicar, proporcionaré enlaces explicativos a las fuentes más valiosas. </p><br><p>  El objetivo principal del diseño impulsado por dominio es combatir la complejidad de los procesos comerciales, su automatización e implementación en código.  "Dominio" se traduce como "dominio", y el desarrollo y el diseño dentro del marco de este enfoque se alejan del dominio. </p><br><p>  El concepto clave en DDD es el lenguaje ubicuo.  El lenguaje ubicuo promueve la comunicación transparente entre los participantes del proyecto.  Él no es uno en el sentido de que es uno para todas las ocasiones.  Justo lo contrario.  Todos los participantes se comunican en él, toda la discusión se lleva a cabo en términos de un solo idioma, y ​​todos los artefactos deben presentarse en términos de un solo idioma, es decir, comenzando por TK y terminando con un código. </p><br><p>  El siguiente concepto es el "modelo de dominio".  Este modelo es un glosario de términos del lenguaje ubicuo.  Tanto el modelo de dominio como el lenguaje ubicuo están limitados por el contexto que Domain-Driven Design llama contexto acotado.  Restringe el modelo de dominio de tal manera que todos los conceptos dentro de él no sean ambiguos y todos entiendan lo que está en juego. </p><br><p>  Ejemplo: tome la entidad "persona" y colóquela en el contexto de "hablar en público".  En este contexto, según DDD, se convierte en un orador o orador.  Y en el contexto de la "familia": un esposo o hermano. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fr/ol/pb/frolpb6kxzrufs8nxfspbnjbhnm.jpeg"></div><br><p>  Ahora sobre el código.  Es importante que su código se lea como un libro, que sea simple y comprensible para cualquiera que hable un lenguaje de proyecto común.  A que me refiero </p><br><p>  Si en el lenguaje del proyecto usa la expresión "el producto ha sido agregado", entonces la siguiente opción no es DDD: </p><br><blockquote>  producto var = producto nuevo ('manzana') <br><br>  product.save () </blockquote><p>  Por qué  El código dice que creamos el producto de una manera extraña y lo guardamos.  ¿Cómo agregar un producto de todos modos?  Necesito <strong>agregarlo</strong> .  Aquí está el código DDD: </p><br><blockquote>  Producto :: add ('manzana'); </blockquote><br><h3 id="arhitektura">  Arquitectura: </h3><br><p>  Desde el punto de vista del diseño impulsado por dominio, realmente no importa qué arquitectura elija.  El diseño dirigido por el dominio no se trata de eso; el diseño dirigido por el dominio se trata del lenguaje y la comunicación. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/u1/xk/yru1xky15pmztnac5w504au08rk.png"></div><br><p>  Pero DDD es casi imposible sin una arquitectura de proyecto limpia, porque al agregar una nueva funcionalidad o cambiar la antigua, debe intentar mantener la flexibilidad y la transparencia de la base del código.  Puede leer sobre puertos, adaptadores y arquitectura de cebolla en un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> .  La imagen de arriba es solo de ella. </p><br><p>  También hay artículos sobre DDD que recomiendo leer detenidamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><h3 id="chto-zhe-nam-eto-daet-v-itoge">  ¿Qué nos da esto al final? </h3><br><ul><li>  casi todos los miembros del equipo pueden leer el código del proyecto; </li><li>  la declaración de tareas se vuelve más explícita; </li><li>  los errores en la lógica de negocios se vuelven más fáciles de buscar; </li><li>  Es mucho más fácil para los especialistas en control de calidad escanear el código y encontrar errores lógicos y errores. </li></ul><br><h3 id="minusy-1">  Contras: </h3><br><ul><li>  Se requieren desarrolladores altamente calificados, especialmente al comienzo del proyecto; </li><li>  No todos los clientes están dispuestos a hacer tales costos, DDD debe ser estudiado por todos los participantes en el proceso de desarrollo. </li></ul><br><h2 id="fdd---features-driven-development">  FDD - Desarrollo dirigido por características </h2><br><p>  FDD: esta metodología (denominada brevemente FDD) fue desarrollada por Jeff De Luca y reconocido gurú en el campo de las tecnologías orientadas a objetos, Peter Coad.  FDD es un intento de combinar las técnicas más reconocidas en la industria del desarrollo de software que toman como base la importante funcionalidad (propiedades) del software desarrollado para el cliente.  El objetivo principal de esta metodología es desarrollar software real y de trabajo sistemáticamente, a tiempo. </p><br><p>  Al igual que otras metodologías adaptativas, se enfoca en iteraciones cortas, cada una de las cuales sirve para desarrollar una cierta parte de la funcionalidad del sistema.  Según el FDD, una iteración dura dos semanas.  FDD tiene cinco procesos.  Los tres primeros se relacionan con el inicio del proyecto: </p><br><ul><li>  desarrollo de un modelo común; </li><li>  compilar una lista de propiedades del sistema requeridas; </li><li>  planificación del trabajo en cada propiedad; </li><li>  diseño de cada propiedad; </li><li>  construcción de cada propiedad. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/pn/-7/ybpn-73k8zvpmk-qudlqwxg9-oa.jpeg"></div><br><p>  Los dos últimos pasos deben realizarse durante cada iteración.  Además, cada proceso se divide en tareas y tiene criterios de verificación. </p><br><p>  Detengámonos en cada artículo con más detalle. </p><br><p>  <strong>Desarrollo de un modelo común.</strong> </p><br><p>  El desarrollo comienza con un análisis de la amplitud de la gama existente de tareas y el contexto del sistema.  Además, para cada área simulada, se realiza un análisis más detallado.  Las descripciones preliminares se compilan en pequeños grupos y se envían para su posterior discusión y evaluación experta.  Después de uno de los modelos propuestos o su combinación se convierte en un modelo para un área específica.  Los modelos de cada área de tareas se combinan en un modelo final común, que puede cambiar durante el trabajo. </p><br><p>  <strong>Características de listado</strong> </p><br><p>  La información recopilada durante la construcción del modelo general se utiliza para compilar una lista de funciones.  Las funciones se combinan en los llamados "dominios" (dominio inglés) y, a su vez, se dividen en subregiones (áreas temáticas en inglés) de acuerdo con un atributo funcional. </p><br><p>  Cada subdominio corresponde a un proceso comercial específico, y sus pasos se convierten en una lista de funciones (propiedades).  Las funciones se presentan en la forma "acción - resultado - objeto", por ejemplo, "verificar contraseña de usuario".  El desarrollo de cada función no debería demorar más de 2 semanas; de lo contrario, la tarea debe descomponerse en iteraciones más pequeñas.  La lista de propiedades en FDD es la misma que la acumulación de productos en SCRUM. </p><br><p>  <strong>Plan de propiedades (funciones)</strong> </p><br><p>  La siguiente etapa es la distribución de funciones entre los principales programadores o equipos. </p><br><p>  <strong>Diseño de funciones</strong> </p><br><p>  Se crea un paquete de diseño para cada propiedad.  El programador principal describe un pequeño grupo de propiedades para el desarrollo en dos semanas.  Después de eso, quedan diagramas de secuencia detallados para cada propiedad, especificando el modelo general.  A continuación se encuentran escritos "trozos" de clases y métodos.  En este punto, debemos centrarnos en el diseño del producto de software. </p><br><p>  <strong>Implementación de funciones</strong> </p><br><p>  Escribimos el código, eliminamos los trozos, probamos. </p><br><p>  Una vez que la propiedad ha sido probada e incorporada al producto, tomamos la siguiente propiedad prioritaria y repetimos el ciclo de diseño / implementación. </p><br><p>  Total, como resultado, obtenemos: </p><br><ul><li>  documentación de propiedades del sistema; </li><li>  diseño cuidadoso; </li><li>  más fácil de evaluar tareas pequeñas; </li><li>  las pruebas se centran en tareas comerciales; </li><li>  sofisticado proceso de creación de productos; </li><li>  Los ciclos de desarrollo iterativos cortos le permiten aumentar rápidamente la funcionalidad y reducir los errores. </li></ul><br><p>  Contras: </p><br><ul><li>  FDD es más adecuado para grandes proyectos.  Los pequeños equipos de desarrollo no podrán experimentar todos los beneficios de este enfoque; </li><li>  costos significativos de implementación y capacitación. </li></ul><br><h2 id="mdd---model-driven-development">  MDD - Desarrollo guiado por modelos </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/wi/ys/-dwiysxakx7fo4tlanhlqkb4f0e.png"></div><br><p>  Recientemente, se ha prestado mucha atención en publicaciones al tema de la arquitectura y el desarrollo basados ​​en los modelos MDA (Model Driven Architecture) y MDD (Model Driven Development).  Sin entrar en detalles, destacamos solo los puntos clave. </p><br><blockquote>  El desarrollo basado en modelos es un estilo de desarrollo de software en el que los modelos se convierten en los principales artefactos de desarrollo a partir de los cuales se generan código y otros artefactos. </blockquote><p>   ,         ,        . </p><br><p>   MDD —  ,          .   -              . </p><br><p>       .            .      ,     ,       .  MDD   —     ,        ,      . </p><br><p>      «»,            .                (    ). </p><br><p>  MDD   ‑       .          ,      ,  .      MDD-,      .        Unified Modeling Language – UML 2.0. </p><br><p>   Object Management Group (OMG)      : </p><br><ul><li> c      ,     ; </li><li>       - ; </li><li> ,         . </li></ul><br><p>    MDD,    , —   .                  . </p><br><p> <strong>   :</strong> </p><br><ul><li>      (Minimum Viable Product)  ; </li><li>   :   ,  ,  ; </li><li>   ; </li><li>       . </li></ul><br><p> <strong>:</strong> </p><br><ul><li>   MMD     ,   Rational Software Architect, Simulink  Sirius; </li><li>       ; </li><li>       . </li></ul><br><h2 id="pdd---panic-driven-development"> PDD — Panic Driven Development </h2><br><p>     agile ,      PDD.    ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k8/cd/li/k8cdliqmqwpouf0q_jdktotmyqu.jpeg"></div><br><h3 id="novye-zadachi-prioritetnee-staryh">    . </h3><br><p>  ,       ,       .        . ,         ?       ,           . </p><br><h3 id="pishite-stolko-koda-skolko-nuzhno-chtoby-reshit-problemu">   ,  ,   . </h3><br><p>     .      .    UX    .        ?   ,      .   ,  . </p><br><h3 id="testy-dolzhny-pisatsya-v-konce">     . </h3><br><p>  ,   ,      ,     .  ,    .      .     ,     . </p><br><h3 id="dovertes-svoemu-instinktu">   . </h3><br><p>  —  .     .   .  .  .    . </p><br><h3 id="process-gibok">  . </h3><br><p>  ,   ,     , —      ,     .     . ,    ,     ,    . </p><br><h3 id="eto-process-upravlyaemyy-menedzherom">  ,  . </h3><br><p>    ,         .           .     ,         ,   . </p><br><h3 id="plyusy-podhoda">  : </h3><br><ul><li>   ; </li><li> ; </li><li>  ,  -   . </li></ul><br><h3 id="minusy-2"> : </h3><br><ul><li> <strong>        </strong> . </li></ul><br><p> PDD   , ,  ,      . </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  agile  .       ,      ,      . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espero que muchos de ustedes hayan aprendido algo nuevo sobre las prácticas de Desarrollo Dirigido, y ahora, al encontrarse cara a cara con las abreviaturas DDD, BDD, MDD, no experimentarán confusión, o tal vez incluso quieran probarlas en la práctica. </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459620/">https://habr.com/ru/post/459620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459610/index.html">Estos enrutadores peligrosos: el hackeo a gran escala de equipos de red recientes y métodos de protección</a></li>
<li><a href="../459612/index.html">Cómo Qualcomm estafó la industria móvil durante casi 20 años seguidos</a></li>
<li><a href="../459614/index.html">Pato robot revuelve arrozales</a></li>
<li><a href="../459616/index.html">MIPT abre el primer programa de maestría avanzada de Rusia en Informática e Ingeniería de Software</a></li>
<li><a href="../459618/index.html">Algunas características poco conocidas de docker-compose</a></li>
<li><a href="../459622/index.html">Como los juegos para Sega Saturn fueron escritos en 1995</a></li>
<li><a href="../459624/index.html">Drones militares</a></li>
<li><a href="../459626/index.html">Windows Notification Facility: la superficie de ataque más indocumentada</a></li>
<li><a href="../459628/index.html">La Red de Invención Abierta tiene más de tres mil licenciatarios, ¿qué significa para el software de código abierto?</a></li>
<li><a href="../459630/index.html">Tic Tac Toe Parte 2: Deshacer / Rehacer sin estado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>