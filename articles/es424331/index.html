<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 🍤 🆑 Kubernetes 1.12: una visión general de las principales innovaciones 👵🏻 📲 🎰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy es el 27 de septiembre, lo que significa que durante las horas de trabajo (según la zona horaria de EE. UU.) Podemos esperar el próximo lanzamient...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.12: una visión general de las principales innovaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424331/"><img src="https://habrastorage.org/files/48b/c2d/ec0/48bc2dec061e42928e98c92cbbadf968.png"><br><br>  Hoy es el 27 de septiembre, lo que <a href="">significa</a> que durante las horas de trabajo (según la zona horaria de EE. UU.) Podemos esperar el próximo lanzamiento de Kubernetes: 1.12 (sin embargo, su anuncio oficial a veces se retrasa).  En general, es hora de continuar con la gloriosa tradición y contar sobre los cambios más significativos, lo que haremos en función de la información pública del proyecto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes presenta la tabla de seguimiento</a> , <a href="">CHANGELOG-1.12</a> , numerosos problemas, solicitudes de extracción y propuestas de diseño.  Entonces, ¿qué hay de nuevo en K8s 1.12? <a name="habracut"></a><br><br><h2>  Instalaciones de almacenamiento </h2><br>  Si selecciona una cosa que se menciona con más frecuencia que cualquier otra entre todos los problemas relacionados con el lanzamiento de Kubernetes 1.12, tal vez sea la <b>Interfaz de almacenamiento de contenedores (CSI)</b> , que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escribimos</a> sobre el otro día.  Por esta razón, comencemos con los cambios en el soporte de almacenamiento. <br><br>  Como tal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, los</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complementos CSI</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">han conservado el</a> estado beta y se espera que sean estables para la próxima versión de Kubernetes (1.13).  ¿Qué hay de nuevo en el soporte de CSI? <br><br>  En febrero de este año <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, el</a> trabajo sobre <b>el concepto de topología</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comenzó</a> en la propia especificación CSI.  En resumen, la topología es información sobre la segmentación del clúster (por ejemplo, por "bastidores" para instalaciones locales o por "regiones" y "zonas" para entornos de nube), que los sistemas de orquestación deben conocer y tener en cuenta.  Por qué  Los volúmenes asignados por los proveedores de almacenamiento no serán necesariamente accesibles por igual en todo el clúster y, por lo tanto, el conocimiento de la topología es necesario para planificar recursos de manera eficiente y tomar decisiones de aprovisionamiento. <br><br>  El resultado de la aparición de topologías en CSI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adoptado</a> en la especificación el 1 de junio) fue su apoyo en Kubernetes 1.12: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte como tal</a> (registro de información de topología de volumen informada por el controlador CSI) - versión alfa; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para topologías en aprovisionamiento dinámico</a> (consulte la documentación detallada en la propuesta de diseño denominada " <a href="">Programación con reconocimiento de topología de volumen</a> "): versión beta inmediata; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de topología GCE PD</a> - versión alfa; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de topología de AWS EBS</a> - Beta. </li></ul><br>  Pero esto no termina con las actualizaciones relacionadas con CSI.  Otra innovación importante en la versión 1.12 de Kubernetes es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>compatibilidad con instantáneas</b> para CSI</a> (en estado alfa).  Las instantáneas de los volúmenes como tales aparecieron en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanzamiento de K8s 1.8</a> .  La implementación principal, que incluye el controlador y el aprovisionador (dos binarios separados), se decidió transferir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un repositorio externo</a> .  Desde entonces, se ha agregado soporte para volúmenes de GCE PD, AWS EBS, OpenStack Cinder, GlusterFS y Kubernetes <code>hostPath</code> . <br><br>  La nueva <a href="">propuesta de diseño</a> tiene como objetivo "continuar esta iniciativa agregando compatibilidad con instantáneas para controladores de volumen CSI" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> se describe la compatibilidad con instantáneas en la especificación CSI).  Dado que Kubernetes se adhiere al principio de incluir un conjunto mínimo de capacidades en la API principal, esta implementación (como para las instantáneas en el Controlador de instantáneas de volumen) usa CRD ( <code>CustomResourceDefinitions</code> ). <br><br>  Y un par de nuevas características para los controladores CSI: <br><br><ul><li>  La versión alfa de la capacidad del controlador para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registrarse</a> en la API de Kubernetes (para facilitar a los usuarios encontrar los controladores instalados en el clúster y permitir que los controladores influyan en los procesos de interacción de Kubernetes con ellos); </li><li>  La versión alfa de la capacidad del controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para recibir información sobre la unidad que</a> solicita el volumen a través de <code>NodePublish</code> . </li></ul><br>  Introducido en la última versión de Kubernetes, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanismo para limitar dinámicamente los</a> volúmenes en los nodos movidos de alfa a beta, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recibiendo</a> ... lo adivinó, soporte para CSI, así como Azure. <br><br>  Finalmente, la característica de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propagación del espacio de nombres Mount</a> , que le permite montar el volumen como <code>rshared</code> (para que todos los directorios de contenedores montados sean visibles en el host) y tenga un estado beta en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión K8s 1.10</a> , se declara estable. <br><br><h2>  Planificador </h2><br>  En el planificador, Kubernetes 1.12 mejora el rendimiento gracias a la versión alfa del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanismo de restricción de</a> búsqueda en un grupo de nodos adecuados para programar hogares <i>(nodos factibles)</i> .  Anteriormente, para cada intento de planificar cada pod, <i>kube-Scheduler</i> verificaba la disponibilidad de todos los nodos y los pasaba para su evaluación, pero ahora el planificador encontrará solo un cierto número de ellos y luego detendrá su trabajo.  Al mismo tiempo, el mecanismo proporciona la selección obligatoria de nodos de diferentes regiones y zonas, así como la necesidad de ver diferentes nodos en diferentes ciclos de planificación (no seleccione los primeros 100 nodos cada vez que comience).  La decisión de implementar este mecanismo se tomó, guiada por los resultados del análisis de datos sobre el rendimiento del programador (si el percentil 90 mostraba un tiempo de 30 ms para un hogar, entonces el percentil 99 ya tenía 60 ms). <br><br>  Además, las siguientes características del planificador han madurado hasta la versión beta: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Taint node by Condition</a> , que apareció en K8s 1.8 y permite marcar un nodo con un cierto estado (para acciones adicionales) cuando ocurren ciertos eventos: ahora el controlador del ciclo de vida del nodo crea manchas automáticamente y el programador las verifica (en lugar de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">condiciones</a> ); </li><li>  Programación de hogar en <code>DaemonSet</code> usando <i>kube-Scheduler</i> (en lugar del controlador <code>DaemonSet</code> ): también se activó por defecto; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificando una clase de prioridad</a> en <code>ResourceQuota</code> . </li></ul><br><h2>  Nodos de clúster </h2><br>  Una innovación interesante fue la aparición (en el estado de versión alfa) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code><b>RuntimeClass</b></code></a> , un nuevo recurso a nivel de clúster diseñado para servir los parámetros del <i>tiempo de ejecución</i> del <i>contenedor (tiempo de ejecución del contenedor)</i> .  <code>RuntimeClasses</code> se asignan a los pods a través del mismo campo en <code>PodSpec</code> e implementan soporte para usar múltiples entornos ejecutables dentro de un clúster o nodo.  Por qué <br><br><blockquote>  <i>“El interés en usar diferentes tiempos de ejecución en un clúster está creciendo.</i>  <i>Por el momento, el principal motivador para esto son las cajas de arena y el deseo de los contenedores Kata y gVisor de integrarse con Kubernetes.</i>  <i>Otros modelos de tiempo de ejecución, como los contenedores de Windows o incluso los entornos de tiempo de ejecución remotos, también requerirán soporte en el futuro.</i>  <i>RuntimeClass ofrece una forma de elegir entre diferentes tiempos de ejecución configurados en un clúster y cambiar sus propiedades (tanto por el clúster como por el usuario) ".</i> </blockquote><br>  Para elegir entre las configuraciones predefinidas, el <a href=""><code>RuntimeHandler</code></a> pasa a la CRI (Container Runtime Interface), que está destinada a reemplazar las anotaciones actuales del hogar: <br><br><img src="https://habrastorage.org/webt/wm/jm/yh/wmjmyh4_fivl7msyzb0ghzeqa68.png"><br><br>  Y la configuración en containerd para kata-runtime se ve así: <br><br><pre> <code class="plaintext hljs">[plugins.cri.containerd.kata-runtime] runtime_type = "io.containerd.runtime.v1.linux" runtime_engine = "/opt/kata/bin/kata-runtime" runtime_root = ""</code> </pre> <br>  El criterio <code>RuntimeClass</code> para la versión alfa es una <a href="">validación CRI</a> exitosa. <br><br>  Además, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanismo para registrar complementos locales</a> (incluido CSI) en <i>Kubelet</i> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>shareProcessNamespace</code></a> (la función se ha habilitado de forma predeterminada) ha crecido al estado de una versión beta. <br><br><h2>  Redes </h2><br>  La principal noticia en la parte de la red de Kubernetes es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión alfa del</a> <b>soporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCTP</a></b> (Stream Control Transmission Protocol).  Habiendo recibido soporte en <i>Pod</i> , <i>Service</i> , <i>Endpoint</i> y <i>NetworkPolicy</i> , este protocolo de telecomunicaciones se ha unido a las filas de TCP y UDP.  Con la nueva característica "aplicaciones que requieren SCTP como protocolo L4 para sus interfaces, será más fácil de implementar en clústeres de Kubernetes;  por ejemplo, podrán usar el descubrimiento de servicios basado en <i>kube-dns</i> , y su interacción se controlará a través de <i>NetworkPolicy</i> ".  Los detalles de implementación están disponibles en <a href="">este documento</a> . <br><br>  Dos características de red introducidas en K8s 1.8 también lograron un estado estable: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para políticas</a> para el tráfico saliente de <code>EgressRules</code> en la API de NetworkPolicy y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicación de reglas</a> CIDR para origen / destino a través de <code>ipBlockRule</code> . <br><br><h2>  Escalamiento </h2><br>  Las mejoras en el Autoscaler Horizontal Pod incluyen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo actualizado</a> para un logro más rápido del tamaño correcto (inmediatamente alfa y beta), para obtener más detalles acerca de cuál leer la <a href="">nueva sección de la documentación</a> ; </li><li>  desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">métricas personalizadas / personalizadas</a> , la segunda beta recibió una API rediseñada y soporte para selectores de etiquetas. </li></ul><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escala vertical de los hogares</a> , que antes de llegar a la versión beta carecía de pruebas de usuario, no se detiene.  Los autores lo consideraron suficiente para el lanzamiento de K8s 1.12 y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recuerdan</a> que es más probable que esta característica sea una adición a Kubernetes (no incluida en el núcleo).  Todo el desarrollo se lleva a cabo en un repositorio separado, en el que la versión beta se sincronizará con la versión de Kubernetes. <br><br><img src="https://habrastorage.org/webt/sl/0e/je/sl0ejeaihoybtqm8khj5y_tkffa.png"><br>  <i>Flujo de trabajo Vertical Pod Autoscaler (VPA) para Kubernetes</i> <br><br>  Finalmente, K8s 1.12 incluye (en forma alfa) los resultados del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo</a> sobre "simplificar la instalación usando <code>ComponentConfig</code> " (como parte del ciclo de vida sig-cluster-life), que ha estado sucediendo durante casi dos años.  Desafortunadamente, por alguna razón (¿una simple supervisión?), El acceso al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento de propuesta de diseño</a> con detalles está cerrado para usuarios anónimos. <br><br><h2>  Otros cambios </h2><br><h3>  API </h3><br>  Se implementan dos nuevas características en el grupo de api-machinery: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> dry-run</code></a> para apiserver (versión alfa), que imita la validación y el procesamiento de solicitudes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de cuota de recursos</a> (inmediatamente beta) que define los <b>recursos</b> que están <b>limitados por defecto</b> (en lugar del comportamiento actual cuando el consumo de recursos es ilimitado si no se establece una cuota). </li></ul><br><h3>  Azur </h3><br>  Estable declarado: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para</a> Azure Virtual Machine Scale Sets (VMSS); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de</a> Azure en cluster-autoscaler. </li></ul><br>  Se agregan las primeras implementaciones (versiones alfa): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compatibilidad con</a> zonas de disponibilidad de Azure </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para</a> nodos como <a href="">grupo de recursos cruzados</a> (RG) y nodos no administrados (en las instalaciones). </li></ul><br><h3>  Kubectl </h3><br><ul><li>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>ha</b></a> implementado una versión alfa del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>mecanismo de complemento actualizado</b></a> , que le permite agregar nuevos comandos o reescribir subcomandos existentes de cualquier nivel de anidamiento.  Está hecho de manera similar a Git y analiza los ejecutables que comienzan con <code>kubectl-</code> en <code>$PATH</code> del usuario.  Vea la <a href="">propuesta de diseño para</a> más detalles. </li><li>  Se implementó una versión beta de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idea de aislar el</a> <code>pkg/kubectl/genericclioptions</code> de kubectl en un repositorio independiente. </li><li>  La función de <i>impresión del lado del servidor</i> ha sido declarada estable. </li></ul><br><h3>  Otros </h3><br><ul><li>  Se presenta la versión alfa del nuevo mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>TTL después del acabado</b></a> , diseñado para limitar la vida útil de los <i>trabajos</i> y <i>pods que han</i> terminado de ejecutarse.  Una vez que caduca el TTL especificado, los objetos se limpiarán automáticamente sin necesidad de intervención del usuario. </li><li>  La generación de una clave privada y CSR (TLS Bootstrap) para firmar un certificado a nivel de clúster en <i>Kubelet se</i> declara estable. </li><li>  La rotación del certificado TLS del servidor en <i>Kubelet</i> entró en estado beta. </li></ul><br><h2>  PS </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.11: una visión general de las innovaciones clave</a> "; </li><li>  "La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integración de containerd con Kubernetes, en sustitución de Docker, está lista para la producción</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.10: Resumen de innovaciones clave</a> "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.9: una visión general de las innovaciones clave</a> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuatro versiones de CNCF 1.0 y anuncios importantes sobre Kubernetes con KubeCon 2017</a> ”; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.8: una visión general de las innovaciones clave</a> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker 17.06 y Kubernetes 1.7: Innovaciones clave</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424331/">https://habr.com/ru/post/es424331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424321/index.html">Poner NetFlow barato y enojado</a></li>
<li><a href="../es424323/index.html">Un ejemplo de trabajo con el método ICE del gerente de producto de Google y Microsoft</a></li>
<li><a href="../es424325/index.html">Training Splunk - un centro de entrenamiento ahora en Rusia</a></li>
<li><a href="../es424327/index.html">Fondos Zuckerberg: Cómo "hacer amigos" con tecnología óptica y biomedicina</a></li>
<li><a href="../es424329/index.html">Take and do: cómo impulsar la programación y el desarrollo</a></li>
<li><a href="../es424333/index.html">Mi experiencia de salir y trabajar con Robot Framework</a></li>
<li><a href="../es424335/index.html">Que haya luz</a></li>
<li><a href="../es424337/index.html">Código de estilo rubí: competente, bello y eficiente. Ejemplo para principiantes</a></li>
<li><a href="../es424339/index.html">Tándem del autor y experto: ¿cómo hacerlo efectivo?</a></li>
<li><a href="../es424341/index.html">Olmo Cómodo e incómodo. Composición</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>