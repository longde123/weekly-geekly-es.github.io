<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐒 🙇 🧚🏻 Pengembangan analisa statis baru: PVS-Studio Java 🌯 🏨 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alat analisa statis PVS-Studio dikenal di dunia C, C ++ dan C # sebagai alat untuk mendeteksi kesalahan dan kerentanan potensial. Namun, kami memiliki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan analisa statis baru: PVS-Studio Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/414669/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c9/ccb/b07/9c9ccbb070ea671cf64a42a257727397.png" alt="Gambar 3"></div><br>  Alat analisa statis PVS-Studio dikenal di dunia C, C ++ dan C # sebagai alat untuk mendeteksi kesalahan dan kerentanan potensial.  Namun, kami memiliki beberapa klien dari sektor keuangan, karena ternyata Java dan IBM RPG (!) Sekarang diminati di sana.  Tetapi kami selalu ingin lebih dekat dengan dunia Enterprise, oleh karena itu, setelah beberapa pemikiran, kami memutuskan untuk mulai membuat penganalisis Java. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Tentu saja, ada kekhawatiran.  Sangat mudah untuk mengambil pasar penganalisa dalam IBM RPG.  Saya sama sekali tidak yakin bahwa ada alat yang layak untuk analisis statis bahasa ini.  Di dunia Jawa, segalanya benar-benar berbeda.  Sudah ada sederetan alat untuk analisis statis, dan untuk maju, Anda perlu membuat analisa yang sangat kuat dan keren. <br><br>  Namun demikian, perusahaan kami telah memiliki pengalaman menggunakan beberapa alat untuk analisis statis Java, dan kami yakin bahwa kami dapat melakukan banyak hal dengan lebih baik. <br><br>  Selain itu, kami memiliki ide bagaimana menggunakan kekuatan penuh dari penganalisa C ++ kami di penganalisis Java.  Tetapi hal pertama yang pertama. <br><br><h2>  Pohon </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/0e0/546/bc10e054614c4a1e6bf2d122659ef7fe.png" alt="Gambar 6"></div><br><br>  Pertama-tama, perlu diputuskan bagaimana kita akan mendapatkan pohon sintaks dan model semantik. <br><br>  Sintaksis pohon adalah elemen dasar di sekitar mana analisa itu dibangun.  Saat melakukan pemeriksaan, penganalisis bergerak melalui pohon sintaks dan memeriksa masing-masing node.  Tanpa pohon seperti itu, analisis statis yang serius praktis tidak mungkin dilakukan.  Misalnya, mencari kesalahan menggunakan ekspresi reguler tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjanjikan</a> . <br><br>  Perlu dicatat bahwa hanya pohon sintaks saja tidak cukup.  Alat analisis juga memerlukan informasi semantik.  Sebagai contoh, kita perlu mengetahui tipe semua elemen pohon, dapat pergi ke deklarasi variabel, dll. <br><br>  Kami memeriksa beberapa opsi untuk mendapatkan pohon sintaks dan model semantik: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ANTLR</a> (dengan tata bahasa untuk Jawa) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaParser dan JavaSymbolSolver</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASTParser Eclipse dari Eclipse JDT</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sendok</a> </li></ul><br>  Kami segera meninggalkan gagasan untuk menggunakan ANTLR, karena hal ini tidak perlu menyulitkan pengembangan alat analisis (analisis semantik harus dilaksanakan sendiri).  Pada akhirnya, kami memutuskan untuk berhenti di perpustakaan Spoon: <br><br><ul><li> Ini bukan hanya pengurai, tetapi seluruh ekosistem - ia menyediakan tidak hanya pohon pengurai, tetapi juga peluang untuk analisis semantik, misalnya, memungkinkan Anda untuk mendapatkan informasi tentang jenis variabel, pergi ke deklarasi variabel, mendapatkan informasi tentang kelas induk, dan sebagainya. </li><li>  Itu didasarkan pada Eclipse JDT dan mampu mengkompilasi kode. </li><li>  Ini mendukung versi terbaru Java dan terus diperbarui. </li><li>  Dokumentasi yang baik dan API yang jelas. </li></ul><br>  Berikut adalah contoh dari metamodel yang disediakan oleh Spoon dan yang kami kerjakan saat membuat aturan diagnostik: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bd/aa0/794/2bdaa079486dd102f2734eec55221c6f.png" alt="Gambar 10"></div><br><br>  Metamodel ini sesuai dengan kode berikut: <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (a + b) * <span class="hljs-number"><span class="hljs-number">4</span></span>; System.out.println(x); } }</code> </pre> <br>  Salah satu hal yang menyenangkan tentang Spoon adalah menyederhanakan pohon sintaks (menghapus dan menambahkan node) untuk membuatnya lebih mudah untuk dikerjakan.  Pada saat yang sama, kesetaraan semantik dari metamodel yang disederhanakan dari aslinya dijamin. <br><br>  Bagi kami, ini berarti, misalnya, bahwa kita tidak perlu lagi khawatir melewatkan tanda kurung tambahan saat melintasi pohon.  Selain itu, setiap ekspresi ditempatkan di blok, impor diungkap, dan beberapa penyederhanaan serupa lainnya dibuat. <br><br>  Misalnya, kode seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = ((<span class="hljs-number"><span class="hljs-number">0</span></span>)); (i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((<span class="hljs-number"><span class="hljs-number">42</span></span>)));</code> </pre> <br>  akan disajikan sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } }</code> </pre> <br>  Berdasarkan pohon sintaks, analisis berbasis pola yang disebut dilakukan.  Ini adalah pencarian kesalahan dalam kode sumber program menggunakan pola kode kesalahan yang terkenal.  Dalam kasus paling sederhana, penganalisa mencari tempat-tempat yang terlihat seperti kesalahan di pohon sesuai dengan aturan yang dijelaskan dalam diagnostik yang sesuai.  Jumlah pola tersebut sangat besar dan kompleksitasnya dapat sangat bervariasi. <br><br>  Contoh paling sederhana dari kesalahan yang terdeteksi oleh analisis berbasis pola adalah kode berikut dari proyek jMonkeyEngine: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isConnected()) { log.log(Level.FINE, <span class="hljs-string"><span class="hljs-string">"Connection closed:{0}."</span></span>, p); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.log(Level.FINE, <span class="hljs-string"><span class="hljs-string">"Connection closed:{0}."</span></span>, p); }</code> </pre> <br>  Blok <i>pernyataan</i> <i>then</i> and <i>else</i> adalah sama, kemungkinan besar, ada kesalahan logis. <br><br>  Berikut adalah contoh serupa lainnya dari proyek Hive: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Number) { <span class="hljs-comment"><span class="hljs-comment">// widening conversion return ((Number) obj).doubleValue(); } else if (obj instanceof HiveDecimal) { // &lt;= return ((HiveDecimal) obj).doubleValue(); } else if (obj instanceof String) { return Double.valueOf(obj.toString()); } else if (obj instanceof Timestamp) { return new TimestampWritable((Timestamp)obj).getDouble(); } else if (obj instanceof HiveDecimal) { // &lt;= return ((HiveDecimal) obj).doubleValue(); } else if (obj instanceof BigDecimal) { return ((BigDecimal) obj).doubleValue(); }</span></span></code> </pre> <br>  Kode ini berisi dua kondisi identik dalam urutan bentuk <i>if (....) else if (....) else if (....)</i> .  Sebaiknya periksa bagian kode ini untuk kesalahan logis, atau hapus kode duplikat. <br><br><h2>  Analisis aliran data </h2><br>  Selain pohon sintaks dan model semantik, penganalisa membutuhkan mekanisme untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menganalisis aliran data</a> . <br><br>  Analisis aliran data memungkinkan Anda menghitung nilai variabel dan ekspresi yang valid di setiap titik dalam program dan, berkat ini, menemukan kesalahan.  Kami menyebut nilai-nilai ini sebagai nilai virtual. <br><br>  Nilai virtual dibuat untuk variabel, bidang kelas, parameter metode, dan hal-hal lain pada penyebutan pertama.  Jika ini adalah tugas, mekanisme Aliran Data menghitung nilai virtual dengan menganalisis ekspresi di sebelah kanan, jika tidak seluruh rentang nilai valid untuk jenis variabel ini diambil sebagai nilai virtual.  Sebagai contoh: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// x: [-128..127] { int y = 5; // y: [5] ... }</span></span></span></span></code> </pre> <br>  Setiap kali nilai variabel diubah, mesin Data Flow menghitung ulang nilai virtual.  Sebagai contoh: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// x: [5] x += 7; // x: [12] ... }</span></span></code> </pre> <br>  Mesin Data Flow juga memproses pernyataan kontrol: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// x: [-2147483648..2147483647] { if (x &gt; 3) { // x: [4..2147483647] if (x &lt; 10) { // x: [4..9] } } else { // x: [-2147483648..3] } ... }</span></span></span></span></code> </pre> <br>  Dalam contoh ini, ketika memasuki fungsi, tidak ada informasi tentang kisaran nilai variabel <i>x</i> , oleh karena itu diatur sesuai dengan jenis variabel (dari -2147483648 ke 2147483647).  Kemudian blok kondisional pertama memberikan batasan <i>x</i> &gt; 3, dan rentang digabungkan.  Akibatnya, dalam blok <i>kemudian</i> kisaran nilai untuk <i>x</i> adalah dari 4 hingga 2147483647, dan di blok <i>lain</i> dari -2147483648 hingga 3. Kondisi kedua <i>x</i> &lt;10 diproses dengan cara yang sama. <br><br>  Selain itu, Anda harus dapat melakukan perhitungan simbolik murni.  Contoh paling sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ a = c; b = c; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) <span class="hljs-comment"><span class="hljs-comment">// &lt;= always true .... }</span></span></code> </pre> <br>  Di sini, variabel <i>a</i> diberi nilai <i>c</i> , variabel <i>b</i> juga diberi nilai <i>c</i> , setelah itu <i>a</i> dan <i>b</i> dibandingkan.  Dalam hal ini, untuk menemukan kesalahan, ingatlah sepotong kayu yang sesuai dengan sisi kanan. <br><br>  Berikut adalah contoh yang sedikit lebih rumit dengan perhitungan karakter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; a) <span class="hljs-comment"><span class="hljs-comment">// &lt;= always false .... } } }</span></span></code> </pre> <br>  Dalam kasus seperti itu, sudah perlu untuk menyelesaikan sistem ketidaksetaraan dalam bentuk simbolis. <br><br>  Mekanisme Aliran Data membantu penganalisa menemukan kesalahan yang sangat sulit ditemukan menggunakan analisis berbasis pola. <br><br>  Kesalahan ini meliputi: <br><br><ul><li>  Meluap; </li><li>  Pergi ke luar negeri array; </li><li>  Akses dengan referensi nol atau berpotensi nol; </li><li>  Kondisi tidak berarti (selalu benar / salah); </li><li>  Kebocoran memori dan sumber daya; </li><li>  Pembagian dengan 0; </li><li>  Dan beberapa lainnya. </li></ul><br>  Analisis Aliran Data sangat penting saat mencari kerentanan.  Misalnya, jika suatu program tertentu menerima input dari pengguna, ada kemungkinan bahwa input tersebut akan digunakan untuk menyebabkan penolakan layanan, atau untuk mendapatkan kendali atas sistem.  Contohnya termasuk kesalahan yang menyebabkan buffer overflows untuk beberapa input, atau, misalnya, injeksi SQL.  Dalam kedua kasus, agar penganalisa statis untuk mendeteksi kesalahan dan kerentanan seperti itu, perlu untuk memantau aliran data dan kemungkinan nilai variabel. <br><br>  Saya harus mengatakan bahwa mekanisme analisis aliran data adalah mekanisme yang kompleks dan luas, dan dalam artikel ini saya hanya menyentuh dasar-dasarnya saja. <br><br>  Mari kita lihat beberapa contoh kesalahan yang dapat dideteksi menggunakan mekanisme Aliran Data. <br><br>  Proyek Sarang: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arg2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len1 != len2) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } if (len1 == 0) { return true; } .... if (len1 == len2) { // &lt;= .... } }</span></span></code> </pre> <br>  Kondisi <i>len1 == len2</i> selalu puas, karena pemeriksaan sebaliknya telah dilakukan di atas. <br><br>  Contoh lain dari proyek yang sama: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Set&lt;String&gt; oldKeys = new HashSet&lt;&gt;(instances.keySet()); if (oldKeys.removeAll(latestKeys)) { .... } this.instances.keySet().removeAll(oldKeys); this.instances.putAll(freshInstances); } else { this.instances.putAll(freshInstances); // &lt;= }</span></span></code> </pre> <br>  Di sini, di blok <i>else</i> , dereferencing dari null pointer dijamin akan terjadi.  Catatan: ini <i>contohnya</i> sama dengan ini. <br><br>  Contoh dari proyek JMonkeyEngine: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertNewtKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &gt;= <span class="hljs-number"><span class="hljs-number">0x10000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key - <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Di sini variabel <i>kunci</i> dibandingkan dengan angka 65536, bagaimanapun, itu adalah tipe <i>pendek</i> , dan nilai maksimum yang mungkin untuk <i>pendek</i> adalah 32767. Dengan demikian, kondisi tersebut tidak pernah terpenuhi. <br><br>  Contoh dari proyek Jenkins: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeBuildWithWorkspace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (R b = getLastBuild(); cnt &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; b ! = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; b = b.getPreviousBuild()) { FilePath ws = b.getWorkspace(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Variabel <i>cnt</i> diperkenalkan dalam kode ini untuk membatasi jumlah lintasan menjadi lima, tetapi lupa menambahkannya, sebagai hasilnya cek tersebut tidak berguna. <br><br><h2>  Mekanisme penjelasan </h2><br>  Selain itu, penganalisa membutuhkan mekanisme anotasi.  Anotasi adalah sistem markup yang memberikan informasi tambahan kepada penganalisa tentang metode dan kelas yang digunakan, selain apa yang dapat diperoleh dengan menganalisis tanda tangan mereka.  Markup dilakukan secara manual, ini adalah proses yang panjang dan memakan waktu, karena untuk mencapai hasil terbaik, perlu memberi anotasi sejumlah besar kelas standar dan metode bahasa Jawa.  Ini juga masuk akal untuk membubuhi keterangan perpustakaan populer.  Secara umum, anotasi dapat dianggap sebagai basis pengetahuan penganalisa tentang kontrak metode dan kelas standar. <br><br>  Berikut adalah contoh kecil kesalahan yang dapat dideteksi menggunakan anotasi: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.max(a, a); }</code> </pre> <br>  Dalam contoh ini, karena kesalahan ketik, variabel yang sama diteruskan sebagai argumen kedua ke metode <i>Math.max</i> sebagai argumen pertama.  Ungkapan seperti itu tidak ada artinya dan mencurigakan. <br><br>  Mengetahui bahwa argumen metode <i>Math.max</i> harus selalu berbeda, penganalisa statis akan dapat mengeluarkan peringatan untuk kode tersebut. <br><br>  Ke depan, saya akan memberikan beberapa contoh markup kelas dan metode bawaan kami (kode C ++): <br><br><pre> <code class="cpp hljs">Class(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"abs"</span></span>, Type::Int32) .Pure() .Set(FunctionClassification::NoDiscard) .Returns(Arg1, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.Abs(); }) - Function(<span class="hljs-string"><span class="hljs-string">"max"</span></span>, Type::Int32, Type::Int32) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotEquals(Arg1, Arg2) .Returns(Arg1, Arg2, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1.Max(v2); }) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.String"</span></span>, TypeClassification::String) - Function(<span class="hljs-string"><span class="hljs-string">"split"</span></span>, Type::Pointer) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotNull(Arg1)) .Returns(Ptr(NotNullPointer)) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.Object"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"equals"</span></span>, Type::Pointer) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotEquals(This, Arg1)) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.System"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"exit"</span></span>, Type::Int32) .Set(FunctionClassification::NoReturn)</code> </pre> <br>  Penjelasan: <br><br><ul><li>  <i>Kelas</i> - kelas beranotasi; </li><li>  <i>Fungsi</i> - metode kelas beranotasi; </li><li>  <i>Murni</i> - anotasi yang menunjukkan bahwa metode ini bersih, mis.  deterministik dan tanpa efek samping; </li><li>  <i>Set</i> - atur bendera sembarang untuk metode ini. </li><li>  <i>FunctionClassification :: NoDiscard</i> - flag yang berarti bahwa nilai balik metode harus digunakan; </li><li>  <i>FunctionClassification :: NoReturn</i> - flag yang menunjukkan bahwa metode tidak mengembalikan kontrol; </li><li>  <i>Arg1</i> , <i>Arg2</i> , <i>...</i> , <i>ArgN</i> - argumen untuk metode ini; </li><li>  <i>Pengembalian</i> - nilai pengembalian metode; </li><li>  <i>Membutuhkan</i> - kontrak untuk metode ini. </li></ul><br>  Perlu dicatat bahwa selain markup manual, ada pendekatan lain untuk penjelasan - output otomatis kontrak berdasarkan kode byte.  Jelas bahwa pendekatan ini memungkinkan Anda untuk hanya menampilkan jenis kontrak tertentu, tetapi memungkinkan untuk memperoleh informasi tambahan secara umum dari semua dependensi, dan tidak hanya dari yang dianotasi secara manual. <br><br>  Omong-omong, sudah ada alat yang dapat menampilkan kontrak seperti <i>@Nullable</i> , <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">NotNull</a></i> berdasarkan bytecode - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FABA</a> .  Seperti yang saya pahami, turunan FABA digunakan dalam IntelliJ IDEA. <br><br>  Sekarang kami juga mempertimbangkan untuk menambahkan analisis bytecode untuk mendapatkan kontrak untuk semua metode, karena kontrak ini dapat melengkapi anotasi manual kami. <br><br>  Aturan diagnostik di tempat kerja sering merujuk pada anotasi.  Selain diagnostik, anotasi menggunakan mekanisme Aliran Data.  Misalnya, menggunakan anotasi metode <i>java.lang.Math.abs</i> , ia dapat secara akurat menghitung nilai untuk modul angka.  Pada saat yang sama, Anda tidak perlu menulis kode tambahan - cukup tandai metode ini dengan benar. <br><br>  Pertimbangkan contoh kesalahan dari proyek Hibernate yang dapat dideteksi melalui anotasi: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Dalam kode ini, metode <i>equals ()</i> membandingkan objek <i>purchaseSequence</i> dengan dirinya sendiri.  Tentunya ini adalah kesalahan ketik dan di sebelah kanan harus itu. <i>Membeli Keadilan</i> , bukan <i>membeli</i> <i>Keadilan</i> . <br><br><h2>  Bagaimana Dr. Frankenstein Merakit Alat Analisis dari Bagian </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/a6a/e05/113a6ae05b7bd0502e1d631746c26ea0.png" alt="Gambar 2"></div><br><br>  Karena mekanisme Aliran Data dan anotasi itu sendiri tidak terlalu terikat dengan bahasa tertentu, diputuskan untuk menggunakan kembali mekanisme ini dari penganalisa C ++ kami.  Ini memungkinkan kami untuk dengan cepat mendapatkan semua kekuatan inti penganalisa C ++ di Java analyzer kami.  Selain itu, keputusan ini juga dipengaruhi oleh fakta bahwa mekanisme ini ditulis dalam C ++ modern dengan sekelompok metaprogramming dan templat magic, dan, karenanya, sangat tidak cocok untuk mentransfer ke bahasa lain. <br><br>  Untuk mengaitkan bagian Java dengan kernel C ++, kami memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SWIG (Simplified Wrapper and Interface Generator)</a> - alat untuk secara otomatis menghasilkan pembungkus dan antarmuka untuk menghubungkan program C dan C ++ dengan program yang ditulis dalam bahasa lain.  Untuk Java, SWIG menghasilkan kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JNI (Java Native Interface)</a> . <br><br>  SWIG sangat bagus untuk kasus-kasus di mana sudah ada sejumlah besar kode C ++ yang perlu diintegrasikan ke dalam proyek Java. <br><br>  Saya akan memberikan contoh minimal bekerja dengan SWIG.  Misalkan kita memiliki kelas C ++ yang ingin kita gunakan dalam proyek Java: <br><br>  CoolClass.h <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; CoolClass(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br>  CoolClass.cpp <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "CoolClass.h" CoolClass::CoolClass(int v) : val(v) {} void CoolClass::printMe() { std::cout &lt;&lt; "val: " &lt;&lt; val &lt;&lt; '\n'; }</span></span></span></span></code> </pre> <br>  Pertama, Anda perlu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file antarmuka SWIG</a> dengan deskripsi semua fungsi dan kelas yang diekspor.  Juga dalam file ini, jika perlu, pengaturan tambahan dibuat. <br><br>  Contoh.i <br><br><pre> <code class="cpp hljs">%<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> MyModule %{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoolClass.h"</span></span></span><span class="hljs-meta"> %} %</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoolClass.h"</span></span></span></span></code> </pre> <br>  Setelah itu, Anda dapat menjalankan SWIG: <br><br><pre> <code class="cpp hljs">$ swig -c++ -java Example.i</code> </pre> <br>  Ini akan menghasilkan file-file berikut: <br><br><ul><li>  CoolClass.java - kelas yang dengannya kita akan langsung bekerja dalam proyek Java; </li><li>  MyModule.java - kelas modul tempat semua fungsi dan variabel bebas ditempatkan; </li><li>  MyModuleJNI.java - pembungkus Java; </li><li>  Example_wrap.cxx - pembungkus C ++. </li></ul><br>  Sekarang Anda hanya perlu menambahkan file .java yang dihasilkan ke proyek Java dan file .cxx ke proyek C ++. <br><br>  Terakhir, Anda perlu mengkompilasi proyek C ++ sebagai pustaka dinamis dan memuatnya ke proyek Java menggunakan <i>System.loadLibary ()</i> : <br><br>  App.java <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibary(<span class="hljs-string"><span class="hljs-string">"example"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CoolClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoolClass(<span class="hljs-number"><span class="hljs-number">42</span></span>); obj.printMe(); } }</code> </pre> <br>  Secara skematis, ini dapat direpresentasikan sebagai berikut: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/35f/b36/20135fb369602791a32d405f5f1231de.png" alt="Gambar 8"></div><br><br>  Tentu saja, dalam proyek nyata semuanya tidak begitu sederhana dan Anda harus melakukan sedikit usaha: <br><br><ul><li>  Untuk menggunakan kelas dan metode templat dari C ++, mereka harus dipakai untuk semua parameter templat yang diterima menggunakan arahan <i>templat%</i> ; </li><li>  Dalam beberapa kasus, Anda mungkin perlu menangkap pengecualian yang dilemparkan dari bagian C ++ di bagian Java.  Secara default, SWIG tidak menangkap pengecualian dari C ++ (terjadi segfault), namun, dimungkinkan untuk melakukan ini menggunakan <i>% exception</i> directive; </li><li>  SWIG memungkinkan Anda untuk memperluas kode plus di sisi Java menggunakan direktif <i>%</i> extended.  Misalnya, dalam proyek kami, kami menambahkan metode <i>toString ()</i> ke nilai virtual sehingga kami dapat melihatnya di Java debugger; </li><li>  Untuk meniru perilaku RAII dari C ++, antarmuka <i>AutoClosable</i> diimplementasikan di semua kelas yang diminati; </li><li>  Mekanisme direktur memungkinkan penggunaan polimorfisme lintas-bahasa; </li><li>  Untuk jenis yang dialokasikan hanya di dalam C ++ (pada kumpulan memori mereka), konstruktor dan finalizer dihapus untuk meningkatkan kinerja.  Pengumpul sampah akan mengabaikan jenis ini. </li></ul><br>  Anda dapat membaca lebih lanjut tentang semua mekanisme ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi SWIG</a> . <br><br>  Analyzer kami dibuat menggunakan gradle, yang memanggil CMake, yang, pada gilirannya, memanggil SWIG dan mengkompilasi bagian C ++.  Untuk programmer, hal ini terjadi hampir tanpa disadari, jadi kami tidak mengalami ketidaknyamanan khusus selama pengembangan. <br><br>  Inti dari penganalisa C ++ kami dibangun di bawah Windows, Linux, macOS, sehingga penganalisis Java juga berfungsi di OS ini. <br><br><h2>  Apa itu aturan diagnostik? </h2><br>  Diagnostik itu sendiri dan kode untuk analisis ditulis dalam Java.  Ini karena interaksi yang dekat dengan Spoon.  Setiap aturan diagnostik adalah pengunjung, yang metodenya kelebihan beban, di mana elemen-elemen yang menarik bagi kami dielakkan: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a79/427/b94/a79427b9408443a75477c583be7bdd7e.png" alt="Gambar 9"></div><br>  Misalnya, kerangka kerja diagnostik V6004 terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V6004</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PvsStudioRule</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitCtIf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CtIf ifElement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// if ifElement.thenStatement statement is equivalent to // ifElement.elseStatement statement =&gt; add warning V6004 } }</span></span></code> </pre> <br><h2>  Plugin </h2><br>  Untuk integrasi termudah dari penganalisa statis ke dalam proyek, kami telah mengembangkan plugin untuk sistem perakitan Maven dan Gradle.  Pengguna hanya dapat menambahkan plugin kami ke proyek. <br><br>  Untuk Gradle: <br><br><pre> <code class="java hljs">.... apply plugin: com.pvsstudio.PvsStudioGradlePlugin pvsstudio { outputFile = <span class="hljs-string"><span class="hljs-string">'path/to/output.json'</span></span> .... }</code> </pre> <br>  Untuk Maven: <br><br><pre> <code class="java hljs">.... &lt;plugin&gt; &lt;groupId&gt;com.pvsstudio&lt;/groupId&gt; &lt;artifactId&gt;pvsstudio-maven-plugin&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">0.1</span></span>&lt;/version&gt; &lt;configuration&gt; &lt;analyzer&gt; &lt;outputFile&gt;path/to/output.json&lt;/outputFile&gt; .... &lt;/analyzer&gt; &lt;/configuration&gt; &lt;/plugin&gt;</code> </pre> <br>  Setelah itu, plugin akan secara independen menerima struktur proyek dan memulai analisis. <br><br>  Selain itu, kami telah mengembangkan plugin prototipe untuk IntelliJ IDEA. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/383/e20/908/383e209083b59831ec5cb84945704752.png" alt="Gambar 1"></div><br>  Plugin ini juga berfungsi di Android Studio. <br><br>  Sebuah plugin untuk Eclipse saat ini sedang dalam pengembangan. <br><br><h2>  Analisis tambahan </h2><br>  Kami telah menyediakan mode analisis tambahan yang memungkinkan Anda untuk memeriksa hanya file yang dimodifikasi dan dengan demikian secara signifikan mengurangi waktu yang diperlukan untuk analisis kode.  Berkat ini, pengembang akan dapat menjalankan analisis sesering yang diperlukan. <br><br>  Analisis tambahan mencakup beberapa tahapan: <br><br><ul><li>  Caching metamodel sendok; </li><li>  Membangun kembali bagian metamodel yang telah diubah; </li><li>  Analisis file yang diubah. </li></ul><br><h2>  Sistem pengujian kami </h2><br>  Untuk menguji penganalisa Java pada proyek nyata, kami menulis alat khusus yang memungkinkan Anda untuk bekerja dengan database proyek terbuka.  Itu ditulis dalam ^ W Python + Tkinter dan cross-platform. <br><br>  Ia bekerja sebagai berikut: <br><br><ul><li>  Proyek uji versi tertentu diunduh dari repositori di GitHub; </li><li>  Proyek sedang dirakit; </li><li>  Plugin kami ditambahkan ke <i>pom.xml</i> atau <i>build.gradle</i> (menggunakan git apply); </li><li>  Penganalisa statis diluncurkan menggunakan plugin; </li><li>  Laporan yang dihasilkan dibandingkan dengan tolok ukur untuk proyek ini. </li></ul><br>  Pendekatan ini memastikan bahwa tanggapan yang baik tidak hilang sebagai akibat dari mengubah kode penganalisa.  Di bawah ini adalah antarmuka utilitas pengujian kami. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/a8a/3e1/4f3a8a3e1a356cdf4df865d1e3b50417.png" alt="Gambar 11"></div><br>  Proyek-proyek dalam laporan yang memiliki perbedaan dengan standar ditandai dengan warna merah.  Tombol Approve memungkinkan Anda untuk menyimpan versi laporan saat ini sebagai referensi. <br><br><h2>  Contoh Kesalahan </h2><br>  Secara tradisional, saya akan mengutip beberapa kesalahan dari berbagai proyek terbuka yang ditemukan oleh penganalisa Java kami.  Di masa depan, direncanakan untuk menulis artikel dengan laporan yang lebih rinci pada setiap proyek. <br><br><h3>  Proyek hibernasi </h3><br>  <b>PVS-Studio Warning:</b> V6009 Function 'equals' menerima argumen aneh.  Periksa argumen: ini, 1. PurchaseRecord.java 57 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Dalam kode ini, metode <i>equals ()</i> membandingkan objek <i>purchaseSequence</i> dengan dirinya sendiri.  Kemungkinan besar, ini adalah kesalahan ketik dan di sebelah kanan seharusnya itu. <i>Pembelian Keadilan</i> , bukan <i>pembelian</i> <i>Keadilan</i> . <br><br>  <b>PVS-Studio Warning:</b> V6009 Function 'equals' menerima argumen aneh.  Periksa argumen: ini, 1. ListHashcodeChangeTest.java 232 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeBook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Iterator&lt;Book&gt; it = books.iterator(); it.hasNext(); ) { Book book = it.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( title.equals( title ) ) { it.remove(); } } }</code> </pre> <br>  <i>Operasi yang</i> mirip dengan yang sebelumnya - di sebelah kanan harus <i>book.title</i> , bukan <i>judul</i> . <br><br><h3>  Sarang proyek </h3><br>  Peringatan <b>PVS-Studio:</b> Ekspresi V6007 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java 2768 <br><br>  Peringatan <b>PVS-Studio:</b> Ekspresi V6007 'colOrScalar1.equals ("Scalar")' selalu salah.  GenVectorCode.java 2774 <br><br>  Peringatan <b>PVS-Studio:</b> Ekspresi V6007 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java 2785 <br><br><pre> <code class="java hljs">String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Scalar"</span></span>)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Scalar"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) { .... }</code> </pre> <br>  Operator jelas bingung di sini dan bukannya ' <i>||'</i>  digunakan ' <i>&amp;&amp;'</i> . <br><br><h3>  Proyek JavaParser </h3><br>  Peringatan <b>PVS-Studio:</b> V6001 Ada sub-ekspresi 'tokenRange.getBegin (). GetRange (). IsPresent ()' di sebelah kiri dan di sebelah kanan kanan operator '&amp;&amp;'.  Node.java 213 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTokenRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenRange tokenRange)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tokenRange = tokenRange; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenRange == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !(tokenRange.getBegin().getRange().isPresent() &amp;&amp; tokenRange.getBegin().getRange().isPresent())) { range = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Range( tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Penganalisa menemukan bahwa ekspresi yang sama ada di kiri dan kanan operator <i>&amp;&amp;</i> (sementara semua metode dalam rantai panggilan bersih).  Kemungkinan besar, dalam kasus kedua perlu menggunakan <i>tokenRange.getEnd ()</i> , dan bukan <i>tokenRange.getBegin ()</i> . <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6016 Akses mencurigakan ke elemen objek 'typeDeclaration.getTypeParameters ()' dengan indeks konstan di dalam satu loop. </font><font style="vertical-align: inherit;">ResolvedReferenceType.java 265</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRawType()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;typeDeclaration.getTypeParams().size(); i++) { typeParametersMap.add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(typeDeclaration.getTypeParams().get(<span class="hljs-number"><span class="hljs-number">0</span></span>), typeParametersValues().get(i))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penganalisa mendeteksi akses mencurigakan ke item koleksi pada indeks konstan di dalam loop. </font><font style="vertical-align: inherit;">Mungkin ada kesalahan dalam kode ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek Jenkins </font></font></h3><br> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan </font><b><font style="vertical-align: inherit;">PVS-Studio:</font></b><font style="vertical-align: inherit;"> Ekspresi V6007 'cnt &lt;5' selalu benar. </font><font style="vertical-align: inherit;">AbstractProject.java 557</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeBuildWithWorkspace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (R b = getLastBuild(); cnt &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; b ! = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; b = b.getPreviousBuild()) { FilePath ws = b.getWorkspace(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cnt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diperkenalkan dalam kode ini </font><font style="vertical-align: inherit;">untuk membatasi jumlah lintasan menjadi lima, tetapi lupa menambahkannya, sebagai hasilnya cek tersebut tidak berguna.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek Spark </font></font></h3><br> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan </font><b><font style="vertical-align: inherit;">PVS-Studio:</font></b><font style="vertical-align: inherit;"> Ekspresi V6007 'sparkApplications! = Null' selalu benar. </font><font style="vertical-align: inherit;">SparkFilter.java 127</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringUtils.isNotBlank(applications)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String[] sparkApplications = applications.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sparkApplications != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; sparkApplications.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memeriksa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hasil yang dikembalikan oleh metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">split</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada artinya, karena metode ini selalu mengembalikan koleksi dan tidak pernah mengembalikan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek Sendok </font></font></h3><br> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan </font><b><font style="vertical-align: inherit;">PVS-Studio:</font></b><font style="vertical-align: inherit;"> V6001 Ada sub-ekspresi yang identik '! M.getSimpleName (). Mulai dengan ("set")' di sebelah kiri dan di sebelah kanan operator '&amp;&amp;'. </font><font style="vertical-align: inherit;">SpoonTestHelpers.java 108</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m.getSimpleName().startsWith(<span class="hljs-string"><span class="hljs-string">"set"</span></span>) &amp;&amp; !m.getSimpleName().startsWith(<span class="hljs-string"><span class="hljs-string">"set"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode ini, ekspresi yang sama ada di kiri dan kanan operator &amp;&amp; (semua metode di rantai panggilan bersih). </font><font style="vertical-align: inherit;">Kemungkinan besar, kode tersebut mengandung kesalahan logis. </font><font style="vertical-align: inherit;">Peringatan </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ekspresi V6007 'idxOfScopeBoundTypeParam&gt; = 0' selalu benar. </font><font style="vertical-align: inherit;">MethodTypingContext.java 243</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSameMethodFormalTypeParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idxOfScopeBoundTypeParam = getIndexOfTypeParam(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idxOfScopeBoundTypeParam &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int idxOfSuperBoundTypeParam = getIndexOfTypeParam(....); if (idxOfScopeBoundTypeParam &gt;= 0) { // &lt;= return idxOfScopeBoundTypeParam == idxOfSuperBoundTypeParam; } } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini mereka disegel dalam kondisi kedua dan bukannya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idxOfSuperBoundTypeParam</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idxOfScopeBoundTypeParam</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek Keamanan Musim Semi </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6001 Ada sub-ekspresi yang identik ke kiri dan ke kanan '||' </font><font style="vertical-align: inherit;">operator. </font><font style="vertical-align: inherit;">Periksa baris: 38, 39. AnyRequestMatcher.java 38</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"deprecation"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AnyRequestMatcher || obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> security.web.util.matcher.AnyRequestMatcher; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi ini mirip dengan yang sebelumnya - di sini nama kelas yang sama ditulis dengan cara yang berbeda. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6006 Objek telah dibuat tetapi tidak digunakan. </font><font style="vertical-align: inherit;">Kata kunci 'lempar' bisa hilang. </font><font style="vertical-align: inherit;">DigestAuthenticationFilter.java 434</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!expectedNonceSignature.equals(nonceTokens[<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BadCredentialsException( DigestAuthenticationFilter.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.messages .getMessage(<span class="hljs-string"><span class="hljs-string">"DigestAuthenticationFilter.nonceCompromised"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] { nonceAsPlainText }, <span class="hljs-string"><span class="hljs-string">"Nonce token compromised {0}"</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode ini, mereka lupa menambahkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lemparan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebelum pengecualian. </font><font style="vertical-align: inherit;">Akibatnya, objek pengecualian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BadCredentialsException dilempar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi tidak digunakan dengan cara apa pun, mis. </font><font style="vertical-align: inherit;">pengecualian tidak dibuang. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warning:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6030 Metode yang terletak di sebelah kanan '|' </font><font style="vertical-align: inherit;">operator akan dipanggil terlepas dari nilai operan kiri. </font><font style="vertical-align: inherit;">Mungkin, lebih baik menggunakan '||'. </font><font style="vertical-align: inherit;">RedirectUrlBuilder.java 38</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setScheme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String scheme)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-string"><span class="hljs-string">"http"</span></span>.equals(scheme) | <span class="hljs-string"><span class="hljs-string">"https"</span></span>.equals(scheme))) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme = scheme; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode ini, penggunaan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat dibenarkan, karena ketika menggunakannya, sisi kanan akan dihitung bahkan jika sisi kiri sudah benar. </font><font style="vertical-align: inherit;">Dalam hal ini, ini tidak masuk akal secara praktis, oleh karena itu operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">layak diganti dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">||</font></font></i>  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek IDEA IntelliJ </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warning:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6008 Potensi null dereference dari 'editor'. </font><font style="vertical-align: inherit;">IntroduceVariableBase.java:609</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PsiElement nameSuggestionContext = editor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : file.findElementAt(...); <span class="hljs-comment"><span class="hljs-comment">// &lt;= final RefactoringSupportProvider supportProvider = LanguageRefactoringSupport.INSTANCE.forLanguage(...); final boolean isInplaceAvailableOnDataContext = supportProvider != null &amp;&amp; editor.getSettings().isVariableInplaceRenameEnabled() &amp;&amp; // &lt;= ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyzer mendeteksi bahwa dalam kode ini, dereferensi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">editor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> null pointer dapat terjadi </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Layak menambahkan cek tambahan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ekspresi V6007 selalu salah. </font><font style="vertical-align: inherit;">RefResolveServiceImpl.java:814</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull VirtualFile file)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> &amp; !myProjectFileIndex.isUnderSourceRootOfType(....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sulit bagi saya untuk mengatakan apa yang ada dalam pikiran penulis, tetapi kode seperti itu terlihat sangat mencurigakan. </font><font style="vertical-align: inherit;">Sekalipun tiba-tiba tidak ada kesalahan di sini, saya pikir ada baiknya menulis ulang tempat ini agar tidak membingungkan penganalisa dan programmer lain. </font><font style="vertical-align: inherit;">Peringatan </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ekspresi V6007 'hasil [0]' selalu salah. </font><font style="vertical-align: inherit;">CopyClassesHandler.java:98</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Runnable command = () -&gt; { PsiDirectory target; if (targetDirectory instanceof PsiDirectory) { target = (PsiDirectory)targetDirectory; } else { target = WriteAction.compute(() -&gt; ((MoveDestination)targetDirectory).getTargetDirectory( defaultTargetDirectory)); } try { Collection&lt;PsiFile&gt; files = doCopyClasses(classes, map, copyClassName, target, project); if (files != null) { if (openInEditor) { for (PsiFile file : files) { CopyHandler.updateSelectionInActiveProjectView( file, project, selectInActivePanel); } EditorHelper.openFilesInEditor( files.toArray(PsiFile.EMPTY_ARRAY)); } } } catch (IncorrectOperationException ex) { Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message("error.title"), Messages.getErrorIcon()); } }; CommandProcessor processor = CommandProcessor.getInstance(); processor.executeCommand(project, command, commandName, null); if (result[0]) { // &lt;= ToolWindowManager.getInstance(project).invokeLater(() -&gt; ToolWindowManager.getInstance(project) .activateEditorComponent()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya curiga bahwa di sini mereka lupa mengubah nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasilnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Karena itu, penganalisa melaporkan bahwa memeriksa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika (hasil [0])</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada gunanya.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arah Java sangat fleksibel - itu adalah desktop, dan android, dan web, dan banyak lagi, jadi kami memiliki banyak ruang untuk beraktifitas. </font><font style="vertical-align: inherit;">Pertama-tama, tentu saja, kami akan mengembangkan bidang-bidang yang paling diminati. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah rencana kami untuk waktu dekat:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anotasi keluaran berdasarkan bytecode; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integrasi ke dalam proyek di Ant (orang lain menggunakannya di 2018?); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plugin untuk Eclipse (dalam pengembangan); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahkan lebih banyak diagnosa dan anotasi; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meningkatkan mekanisme Aliran Data. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga menyarankan mereka yang ingin berpartisipasi dalam menguji versi alpha dari Java analyzer kami ketika tersedia. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kirim surat kepada kami </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendukung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami akan menambahkan kontak Anda ke daftar dan menulis kepada Anda ketika kami menyiapkan versi alfa pertama.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Egor Bredikhin. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembangan penganalisa statis baru:</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudahkah Anda membaca artikel dan memiliki pertanyaan?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seringkali artikel kita ditanyai pertanyaan yang sama. </font><font style="vertical-align: inherit;">Kami mengumpulkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jawaban di</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sini: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Jawaban untuk pertanyaan dari pembaca artikel tentang PVS-Studio, versi 2015</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Silakan lihat daftarnya.</font></font></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414669/">https://habr.com/ru/post/id414669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414655/index.html">Router virtual DD-WRT x86 pada VirtualBox</a></li>
<li><a href="../id414657/index.html">Protokol AMF3 Berbahaya</a></li>
<li><a href="../id414661/index.html">Kendaraan peluncuran Soyuz-5SL akan bekerja dengan mesin bergaya Soviet</a></li>
<li><a href="../id414663/index.html">Kelelahan profesional: sepatah kata untuk para ahli</a></li>
<li><a href="../id414667/index.html">[Mini fan theme] Tabel kejuaraan FIFA di terminal</a></li>
<li><a href="../id414673/index.html">Tidak lagi Abibas: keajaiban teknologi China</a></li>
<li><a href="../id414675/index.html">Karier Manajer TI: Dari Baris Perintah ke Kerja Tim</a></li>
<li><a href="../id414677/index.html">Perintah Cepat Siri</a></li>
<li><a href="../id414679/index.html">Box-shadows.css</a></li>
<li><a href="../id414683/index.html">Kisah menciptakan aplikasi seluler untuk anak-anak yang memungkinkan Anda mendapatkan uang dengan pikiran Anda. Lanjutan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>