<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óºÔ∏è ü§öüèø ü§üüèæ FP gegen OOP üë©üèø‚Äçü§ù‚Äçüë©üèº üîØ üë©üèø‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit erschienen auf dem Hub mehrere Posts, die dem Funktions- und Objektansatz gegen√ºberstanden, was in den Kommentaren eine hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FP gegen OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474518/"><p>  Vor nicht allzu langer Zeit erschienen auf dem Hub mehrere Posts, die dem Funktions- und Objektansatz gegen√ºberstanden, was in den Kommentaren eine hitzige Diskussion dar√ºber erzeugte, was es wirklich ist - objektorientierte Programmierung und wie sie sich von funktional unterscheidet.  Ich m√∂chte, wenn auch etwas sp√§t, mit anderen teilen, was Robert Martin, auch bekannt als Onkel Bob, dar√ºber denkt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cf/hd/udcfhd13y7i2zdqhnhtotltstyg.jpeg"></div><a name="habracut"></a><br><p>  In den letzten Jahren war ich wiederholt in der Lage, zusammen mit Leuten zu programmieren, die Functional Programming studierten und die voreingenommen gegen√ºber OOP waren.  Dies wurde normalerweise in Form von Aussagen ausgedr√ºckt wie: "Nun, das ist zu viel wie ein Objekt." </p><br><p>  Ich denke, das kommt von der √úberzeugung, dass sich FP und OOP gegenseitig ausschlie√üen.  Viele scheinen zu denken, dass das Programm, wenn es funktionsf√§hig ist, nicht objektorientiert ist.  Ich glaube, dass die Bildung einer solchen Meinung eine logische Folge des Studiums von etwas Neuem ist. </p><br><p>  Wenn wir uns einer neuen Technik annehmen, beginnen wir oft, die alten Techniken, die wir zuvor verwendet haben, zu meiden.  Das ist nat√ºrlich, weil wir glauben, dass die neue Technik "besser" ist und daher die alte Technik wahrscheinlich "schlechter" ist. </p><br><p>  In diesem Beitrag bin ich zu Recht der Ansicht, dass OOP und FP zwar orthogonal sind, sich jedoch nicht gegenseitig ausschlie√üen.  Dass ein gutes Funktionsprogramm objektorientiert sein kann (und sollte).  Und dass ein gutes objektorientiertes Programm funktionieren kann (und sollte).  Dazu m√ºssen wir jedoch die Bedingungen festlegen. </p><br><h2 id="chto-takoe-oop">  Was ist OOP? </h2><br><p>  Ich werde das Thema aus einer reduktionistischen Perspektive betrachten.  Es gibt viele korrekte Definitionen von OOP, die viele Konzepte, Prinzipien, Techniken, Muster und Philosophien abdecken.  Ich habe vor, sie zu ignorieren und mich auf das Salz selbst zu konzentrieren.  Hier ist Reduktionismus erforderlich, weil all diese F√ºlle von M√∂glichkeiten rund um OOP nicht wirklich etwas Spezifisches f√ºr OOP ist.  Dies ist nur ein Teil der F√ºlle von M√∂glichkeiten, die sich bei der Softwareentwicklung im Allgemeinen bieten.  Hier werde ich mich auf den Teil von OOP konzentrieren, der definiert und nicht entfernbar ist. </p><br><p>  Schauen Sie sich zwei Ausdr√ºcke an: </p><br><p>  1: f (o);  2: von (); </p><br><p>  Was ist der Unterschied? </p><br><p>  Es gibt eindeutig keinen semantischen Unterschied.  Der ganze Unterschied liegt ganz in der Syntax.  Aber einer sieht prozedural aus und der andere ist objektorientiert.  Dies liegt daran, dass wir daran gew√∂hnt sind, dass Ausdruck 2 implizit eine spezielle Verhaltenssemantik impliziert, die Ausdruck 1 nicht hat. Diese spezielle Verhaltenssemantik ist Polymorphismus. </p><br><p>  Wenn wir Ausdruck 1 sehen, sehen wir die Funktion <strong>f</strong> , die aufgerufen wird, in die das Objekt <strong>o</strong> √ºbertragen wird.  Dies impliziert, dass es nur eine Funktion mit dem Namen f gibt und nicht die Tatsache, dass sie ein Mitglied der Standardfunktionskohorte ist, die o umgibt. </p><br><p>  Wenn wir dagegen Ausdruck 2 sehen, sehen wir ein Objekt mit dem Namen <strong>o, an</strong> das eine Nachricht mit dem Namen <strong>f</strong> gesendet wird.  Wir erwarten, dass es m√∂glicherweise andere Arten von Objekten gibt, die die Nachricht f empfangen, und daher wissen wir nicht, welches spezifische Verhalten von f nach dem Aufruf zu erwarten ist.  Verhalten ist abh√§ngig vom Typ o.  das hei√üt, f ist polymorph. </p><br><p>  Diese Tatsache, die wir von polymorphen Verhaltensmethoden erwarten, ist das Wesen der objektorientierten Programmierung.  Dies ist eine reduktionistische Definition, und diese Eigenschaft kann nicht aus OOP entfernt werden.  OOP ohne Polymorphismus ist kein OOP.  Alle anderen OOP-Eigenschaften, wie die Datenkapselung und die mit diesen Daten verkn√ºpften Methoden und sogar die Vererbung, beziehen sich eher auf Ausdruck 1. als auf Ausdruck 2. </p><br><p>  Programmierer, die C und Pascal (und in gewissem Ma√üe sogar Fortran und Cobol) verwenden, haben immer Systeme mit gekapselten Funktionen und Strukturen erstellt.  Um solche Strukturen zu erstellen, ben√∂tigen Sie nicht einmal eine objektorientierte Programmiersprache.  Die Verkapselung und sogar die einfache Vererbung in solchen Sprachen ist offensichtlich und nat√ºrlich.  (In C und Pascal nat√ºrlicher als in anderen) </p><br><p>  Was OOP-Programme wirklich von Nicht-OOP-Programmen unterscheidet, ist daher Polymorphismus. </p><br><p>  Vielleicht m√∂chten Sie argumentieren, dass Polyphorismus einfach durch die Verwendung von inside f switch oder langen if / else-Ketten erreicht werden kann.  Das ist wahr, also muss ich eine andere Einschr√§nkung f√ºr OOP festlegen. </p><br><p>  Die Verwendung von Polymorphismus sollte nicht die Abh√§ngigkeit des Anrufers vom Angerufenen erzeugen. </p><br><p>  Um dies zu erkl√§ren, schauen wir uns noch einmal die Ausdr√ºcke an.  Der Ausdruck 1: f (o) scheint von der Funktion f auf Quellcodeebene abzuh√§ngen.  Wir ziehen diese Schlussfolgerung, weil wir auch annehmen, dass f nur eins ist und der Anrufer daher √ºber den Angerufenen Bescheid wissen muss. </p><br><p>  Wenn wir uns jedoch Ausdruck 2 von () ansehen, nehmen wir etwas anderes an.  Wir wissen, dass es viele Realisierungen von f geben kann und wir wissen nicht, welche dieser Funktionen f tats√§chlich aufgerufen wird.  Daher ist der Quellcode, der Ausdruck 2 enth√§lt, unabh√§ngig von der Funktion, die auf Quellcodeebene aufgerufen wird. </p><br><p>  Dies bedeutet insbesondere, dass Module (Dateien mit Quellcode), die polymorphe Funktionsaufrufe enthalten, nicht auf Module (Dateien mit Quellcode) verweisen sollten, die die Implementierung dieser Funktionen enthalten.  Es darf kein <strong>Include</strong> oder <strong>Use</strong> oder <strong>Require</strong> oder andere Schl√ºsselw√∂rter geben, die einige Quellcodedateien von anderen abh√§ngig machen. </p><br><p>  Unsere reduktionistische Definition von OOP lautet also: </p><br><blockquote>  Eine Technik, die dynamischen Polymorphismus zum Aufrufen von Funktionen verwendet und keine Abh√§ngigkeiten des Aufrufers von dem auf der Quellcodeebene aufgerufenen Programm erstellt. </blockquote><br><h2 id="chto-takoe-fp">  Was ist AF? </h2><br><p>  Und wieder werde ich den reduktionistischen Ansatz verwenden.  FP hat eine reiche Tradition und Geschichte, deren Wurzeln tiefer liegen als die Programmierung selbst.  Es gibt Prinzipien, Techniken, Theoreme, Philosophien und Konzepte, die dieses Paradigma durchdringen.  Ich werde das alles ignorieren und direkt zur Essenz gehen, zu der inh√§renten Eigenschaft, die FP von anderen Stilen unterscheidet.  Hier ist es: </p><br><p>  f (a) == f (b) wenn a == b. </p><br><p>  In einem Funktionsprogramm f√ºhrt der Aufruf einer Funktion mit demselben Argument zu demselben Ergebnis, unabh√§ngig davon, wie lange das Programm ausgef√ºhrt wurde.  Dies wird manchmal als referentielle Transparenz bezeichnet. </p><br><p>  Daraus folgt, dass f die Teile des globalen Zustands, die das Verhalten von f beeinflussen, nicht √§ndern sollte.  Wenn wir au√üerdem sagen, dass f alle Funktionen im System darstellt - das hei√üt, alle Funktionen im System m√ºssen referenziell transparent sein -, kann keine Funktion im System den globalen Zustand √§ndern.  Keine Funktion kann etwas tun, das dazu f√ºhren kann, dass eine andere Funktion vom System einen anderen Wert mit denselben Argumenten zur√ºckgibt. </p><br><p>  Dies hat eine tiefere Konsequenz - kein benannter Wert kann ge√§ndert werden.  Das hei√üt, es gibt keinen Zuweisungsoperator. </p><br><p>  Wenn Sie diese Aussage sorgf√§ltig √ºberdenken, k√∂nnen Sie zu dem Schluss kommen, dass ein Programm, das nur aus transparent transparenten Funktionen besteht, nichts kann - da jedes n√ºtzliche Verhalten des Systems den Zustand von etwas √§ndert;  auch wenn es nur der Zustand des Druckers oder der Anzeige ist.  Wenn wir jedoch Eisen von den Anforderungen f√ºr referentielle Transparenz und alle Elemente der Welt um uns herum ausschlie√üen, stellt sich heraus, dass wir sehr n√ºtzliche Systeme schaffen k√∂nnen. </p><br><p>  Der Fokus liegt nat√ºrlich auf der Rekursion.  Stellen Sie sich eine Funktion vor, die eine Struktur mit state als Argument verwendet.  Dieses Argument besteht aus allen Statusinformationen, die eine Funktion ben√∂tigt, um zu funktionieren.  Wenn die Arbeit beendet ist, erstellt die Funktion eine neue Struktur mit einem Status, dessen Inhalt sich vom vorherigen unterscheidet.  Und mit der letzten Aktion ruft sich die Funktion mit einer neuen Struktur als Argument auf. </p><br><p>  Dies ist nur einer der einfachen Tricks, mit denen ein Funktionsprogramm Status√§nderungen speichern kann, ohne den Status √§ndern zu m√ºssen [1]. </p><br><p>  Also die reduktionistische Definition der funktionalen Programmierung: </p><br><blockquote>  Referentielle Transparenz - Sie k√∂nnen keine Werte neu zuweisen. </blockquote><br><h2 id="fp-protiv-oop">  FP gegen OOP </h2><br><p>  Zu diesem Zeitpunkt schauen mich sowohl Bef√ºrworter von OOP als auch Bef√ºrworter von FI bereits durch optische Visiere an.  Reduktionismus ist nicht der beste Weg, um Freunde zu finden.  Aber manchmal ist es n√ºtzlich.  In diesem Fall halte ich es f√ºr n√ºtzlich, das unverblasste Anti-OOP-Holivar zu beleuchten. </p><br><p>  Es ist klar, dass die beiden von mir gew√§hlten reduktionistischen Definitionen v√∂llig orthogonal sind.  Polymorphismus und referentielle Transparenz haben nichts miteinander zu tun.  Sie kreuzen sich in keiner Weise. </p><br><p>  Orthogonalit√§t bedeutet jedoch keinen gegenseitigen Ausschluss (fragen Sie James Clerk Maxwell).  Es ist durchaus m√∂glich, ein System zu erstellen, das sowohl dynamischen Polymorphismus als auch referenzielle Transparenz verwendet.  Es ist nicht nur m√∂glich, es ist richtig und gut! </p><br><p>  Warum ist diese Kombination gut?  Aus genau den gleichen Gr√ºnden wie beide Komponenten!  Systeme, die auf dynamischem Polymorphismus basieren, sind gut, weil sie eine geringe Konnektivit√§t aufweisen.  Abh√§ngigkeiten k√∂nnen invertiert und auf verschiedenen Seiten der Architekturgrenzen platziert werden.  Diese Systeme k√∂nnen mit Moki und Fake und anderen Arten von Testdoppeln getestet werden.  Module k√∂nnen ge√§ndert werden, ohne √Ñnderungen an anderen Modulen vorzunehmen.  Daher sind solche Systeme leichter zu modifizieren und zu verbessern. </p><br><p>  Systeme, die auf referenzieller Transparenz basieren, sind ebenfalls gut, weil sie vorhersehbar sind.  Durch die Unver√§nderlichkeit des Zustands k√∂nnen solche Systeme leichter verstanden, ge√§ndert und verbessert werden.  Dies verringert die Wahrscheinlichkeit von Rennen und anderen Multithreading-Problemen erheblich. </p><br><p>  Die Hauptidee hier ist folgende: </p><br><blockquote>  Es gibt kein Holivar FP gegen OOP </blockquote><p>  FP und OOP arbeiten gut zusammen.  Beide sind gut und in modernen Systemen geeignet.  Das System, das auf einer Kombination der Prinzipien von OOP und FP basiert, maximiert Flexibilit√§t, Wartbarkeit, Testbarkeit, Einfachheit und Festigkeit.  Wenn Sie eine entfernen, um eine weitere hinzuzuf√ºgen, wird die Struktur des Systems nur verschlechtert. </p><br><p>  [1] Da wir Maschinen mit Von-Neumann-Architektur verwenden, gehen wir davon aus, dass sie Speicherzellen haben, deren Zustand sich tats√§chlich √§ndert.  In dem von mir beschriebenen Rekursionsmechanismus erm√∂glicht die Optimierung der Schwanzschwanzrekursion nicht die Erstellung neuer Glasrahmen, und der urspr√ºngliche Glasrahmen wird verwendet.  Diese Verletzung der referentiellen Transparenz ist (normalerweise) dem Programmierer verborgen und hat keinerlei Auswirkungen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474518/">https://habr.com/ru/post/de474518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474502/index.html">Odnoklassniki-Analyse beim Joker 2019</a></li>
<li><a href="../de474504/index.html">Orthodoxes Backend</a></li>
<li><a href="../de474508/index.html">Erfolge des 3D-Bio-Drucks von Hauttransplantaten</a></li>
<li><a href="../de474514/index.html">Wie √ºberleben chinesische Bitcoin-Bergbaumagnaten?</a></li>
<li><a href="../de474516/index.html">Sprachanwendungen: Der milliardste Markt, den Russland nicht bemerkt</a></li>
<li><a href="../de474522/index.html">Mutt Geschichte</a></li>
<li><a href="../de474526/index.html">Hewlett Packard Enterprise Webinare von November bis Januar</a></li>
<li><a href="../de474528/index.html">Das Buch "Quantum Computing f√ºr echte IT-Profis"</a></li>
<li><a href="../de474532/index.html">Radiolabor von Nischni Nowgorod und Radios mit Kristalldetektoren</a></li>
<li><a href="../de474534/index.html">Alan Turing Book und Mysterious Note - Wissenschaftsdetektiv</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>