<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◼️ 🤚🏿 🤟🏾 FP gegen OOP 👩🏿‍🤝‍👩🏼 🔯 👩🏿‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit erschienen auf dem Hub mehrere Posts, die dem Funktions- und Objektansatz gegenüberstanden, was in den Kommentaren eine hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FP gegen OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474518/"><p>  Vor nicht allzu langer Zeit erschienen auf dem Hub mehrere Posts, die dem Funktions- und Objektansatz gegenüberstanden, was in den Kommentaren eine hitzige Diskussion darüber erzeugte, was es wirklich ist - objektorientierte Programmierung und wie sie sich von funktional unterscheidet.  Ich möchte, wenn auch etwas spät, mit anderen teilen, was Robert Martin, auch bekannt als Onkel Bob, darüber denkt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cf/hd/udcfhd13y7i2zdqhnhtotltstyg.jpeg"></div><a name="habracut"></a><br><p>  In den letzten Jahren war ich wiederholt in der Lage, zusammen mit Leuten zu programmieren, die Functional Programming studierten und die voreingenommen gegenüber OOP waren.  Dies wurde normalerweise in Form von Aussagen ausgedrückt wie: "Nun, das ist zu viel wie ein Objekt." </p><br><p>  Ich denke, das kommt von der Überzeugung, dass sich FP und OOP gegenseitig ausschließen.  Viele scheinen zu denken, dass das Programm, wenn es funktionsfähig ist, nicht objektorientiert ist.  Ich glaube, dass die Bildung einer solchen Meinung eine logische Folge des Studiums von etwas Neuem ist. </p><br><p>  Wenn wir uns einer neuen Technik annehmen, beginnen wir oft, die alten Techniken, die wir zuvor verwendet haben, zu meiden.  Das ist natürlich, weil wir glauben, dass die neue Technik "besser" ist und daher die alte Technik wahrscheinlich "schlechter" ist. </p><br><p>  In diesem Beitrag bin ich zu Recht der Ansicht, dass OOP und FP zwar orthogonal sind, sich jedoch nicht gegenseitig ausschließen.  Dass ein gutes Funktionsprogramm objektorientiert sein kann (und sollte).  Und dass ein gutes objektorientiertes Programm funktionieren kann (und sollte).  Dazu müssen wir jedoch die Bedingungen festlegen. </p><br><h2 id="chto-takoe-oop">  Was ist OOP? </h2><br><p>  Ich werde das Thema aus einer reduktionistischen Perspektive betrachten.  Es gibt viele korrekte Definitionen von OOP, die viele Konzepte, Prinzipien, Techniken, Muster und Philosophien abdecken.  Ich habe vor, sie zu ignorieren und mich auf das Salz selbst zu konzentrieren.  Hier ist Reduktionismus erforderlich, weil all diese Fülle von Möglichkeiten rund um OOP nicht wirklich etwas Spezifisches für OOP ist.  Dies ist nur ein Teil der Fülle von Möglichkeiten, die sich bei der Softwareentwicklung im Allgemeinen bieten.  Hier werde ich mich auf den Teil von OOP konzentrieren, der definiert und nicht entfernbar ist. </p><br><p>  Schauen Sie sich zwei Ausdrücke an: </p><br><p>  1: f (o);  2: von (); </p><br><p>  Was ist der Unterschied? </p><br><p>  Es gibt eindeutig keinen semantischen Unterschied.  Der ganze Unterschied liegt ganz in der Syntax.  Aber einer sieht prozedural aus und der andere ist objektorientiert.  Dies liegt daran, dass wir daran gewöhnt sind, dass Ausdruck 2 implizit eine spezielle Verhaltenssemantik impliziert, die Ausdruck 1 nicht hat. Diese spezielle Verhaltenssemantik ist Polymorphismus. </p><br><p>  Wenn wir Ausdruck 1 sehen, sehen wir die Funktion <strong>f</strong> , die aufgerufen wird, in die das Objekt <strong>o</strong> übertragen wird.  Dies impliziert, dass es nur eine Funktion mit dem Namen f gibt und nicht die Tatsache, dass sie ein Mitglied der Standardfunktionskohorte ist, die o umgibt. </p><br><p>  Wenn wir dagegen Ausdruck 2 sehen, sehen wir ein Objekt mit dem Namen <strong>o, an</strong> das eine Nachricht mit dem Namen <strong>f</strong> gesendet wird.  Wir erwarten, dass es möglicherweise andere Arten von Objekten gibt, die die Nachricht f empfangen, und daher wissen wir nicht, welches spezifische Verhalten von f nach dem Aufruf zu erwarten ist.  Verhalten ist abhängig vom Typ o.  das heißt, f ist polymorph. </p><br><p>  Diese Tatsache, die wir von polymorphen Verhaltensmethoden erwarten, ist das Wesen der objektorientierten Programmierung.  Dies ist eine reduktionistische Definition, und diese Eigenschaft kann nicht aus OOP entfernt werden.  OOP ohne Polymorphismus ist kein OOP.  Alle anderen OOP-Eigenschaften, wie die Datenkapselung und die mit diesen Daten verknüpften Methoden und sogar die Vererbung, beziehen sich eher auf Ausdruck 1. als auf Ausdruck 2. </p><br><p>  Programmierer, die C und Pascal (und in gewissem Maße sogar Fortran und Cobol) verwenden, haben immer Systeme mit gekapselten Funktionen und Strukturen erstellt.  Um solche Strukturen zu erstellen, benötigen Sie nicht einmal eine objektorientierte Programmiersprache.  Die Verkapselung und sogar die einfache Vererbung in solchen Sprachen ist offensichtlich und natürlich.  (In C und Pascal natürlicher als in anderen) </p><br><p>  Was OOP-Programme wirklich von Nicht-OOP-Programmen unterscheidet, ist daher Polymorphismus. </p><br><p>  Vielleicht möchten Sie argumentieren, dass Polyphorismus einfach durch die Verwendung von inside f switch oder langen if / else-Ketten erreicht werden kann.  Das ist wahr, also muss ich eine andere Einschränkung für OOP festlegen. </p><br><p>  Die Verwendung von Polymorphismus sollte nicht die Abhängigkeit des Anrufers vom Angerufenen erzeugen. </p><br><p>  Um dies zu erklären, schauen wir uns noch einmal die Ausdrücke an.  Der Ausdruck 1: f (o) scheint von der Funktion f auf Quellcodeebene abzuhängen.  Wir ziehen diese Schlussfolgerung, weil wir auch annehmen, dass f nur eins ist und der Anrufer daher über den Angerufenen Bescheid wissen muss. </p><br><p>  Wenn wir uns jedoch Ausdruck 2 von () ansehen, nehmen wir etwas anderes an.  Wir wissen, dass es viele Realisierungen von f geben kann und wir wissen nicht, welche dieser Funktionen f tatsächlich aufgerufen wird.  Daher ist der Quellcode, der Ausdruck 2 enthält, unabhängig von der Funktion, die auf Quellcodeebene aufgerufen wird. </p><br><p>  Dies bedeutet insbesondere, dass Module (Dateien mit Quellcode), die polymorphe Funktionsaufrufe enthalten, nicht auf Module (Dateien mit Quellcode) verweisen sollten, die die Implementierung dieser Funktionen enthalten.  Es darf kein <strong>Include</strong> oder <strong>Use</strong> oder <strong>Require</strong> oder andere Schlüsselwörter geben, die einige Quellcodedateien von anderen abhängig machen. </p><br><p>  Unsere reduktionistische Definition von OOP lautet also: </p><br><blockquote>  Eine Technik, die dynamischen Polymorphismus zum Aufrufen von Funktionen verwendet und keine Abhängigkeiten des Aufrufers von dem auf der Quellcodeebene aufgerufenen Programm erstellt. </blockquote><br><h2 id="chto-takoe-fp">  Was ist AF? </h2><br><p>  Und wieder werde ich den reduktionistischen Ansatz verwenden.  FP hat eine reiche Tradition und Geschichte, deren Wurzeln tiefer liegen als die Programmierung selbst.  Es gibt Prinzipien, Techniken, Theoreme, Philosophien und Konzepte, die dieses Paradigma durchdringen.  Ich werde das alles ignorieren und direkt zur Essenz gehen, zu der inhärenten Eigenschaft, die FP von anderen Stilen unterscheidet.  Hier ist es: </p><br><p>  f (a) == f (b) wenn a == b. </p><br><p>  In einem Funktionsprogramm führt der Aufruf einer Funktion mit demselben Argument zu demselben Ergebnis, unabhängig davon, wie lange das Programm ausgeführt wurde.  Dies wird manchmal als referentielle Transparenz bezeichnet. </p><br><p>  Daraus folgt, dass f die Teile des globalen Zustands, die das Verhalten von f beeinflussen, nicht ändern sollte.  Wenn wir außerdem sagen, dass f alle Funktionen im System darstellt - das heißt, alle Funktionen im System müssen referenziell transparent sein -, kann keine Funktion im System den globalen Zustand ändern.  Keine Funktion kann etwas tun, das dazu führen kann, dass eine andere Funktion vom System einen anderen Wert mit denselben Argumenten zurückgibt. </p><br><p>  Dies hat eine tiefere Konsequenz - kein benannter Wert kann geändert werden.  Das heißt, es gibt keinen Zuweisungsoperator. </p><br><p>  Wenn Sie diese Aussage sorgfältig überdenken, können Sie zu dem Schluss kommen, dass ein Programm, das nur aus transparent transparenten Funktionen besteht, nichts kann - da jedes nützliche Verhalten des Systems den Zustand von etwas ändert;  auch wenn es nur der Zustand des Druckers oder der Anzeige ist.  Wenn wir jedoch Eisen von den Anforderungen für referentielle Transparenz und alle Elemente der Welt um uns herum ausschließen, stellt sich heraus, dass wir sehr nützliche Systeme schaffen können. </p><br><p>  Der Fokus liegt natürlich auf der Rekursion.  Stellen Sie sich eine Funktion vor, die eine Struktur mit state als Argument verwendet.  Dieses Argument besteht aus allen Statusinformationen, die eine Funktion benötigt, um zu funktionieren.  Wenn die Arbeit beendet ist, erstellt die Funktion eine neue Struktur mit einem Status, dessen Inhalt sich vom vorherigen unterscheidet.  Und mit der letzten Aktion ruft sich die Funktion mit einer neuen Struktur als Argument auf. </p><br><p>  Dies ist nur einer der einfachen Tricks, mit denen ein Funktionsprogramm Statusänderungen speichern kann, ohne den Status ändern zu müssen [1]. </p><br><p>  Also die reduktionistische Definition der funktionalen Programmierung: </p><br><blockquote>  Referentielle Transparenz - Sie können keine Werte neu zuweisen. </blockquote><br><h2 id="fp-protiv-oop">  FP gegen OOP </h2><br><p>  Zu diesem Zeitpunkt schauen mich sowohl Befürworter von OOP als auch Befürworter von FI bereits durch optische Visiere an.  Reduktionismus ist nicht der beste Weg, um Freunde zu finden.  Aber manchmal ist es nützlich.  In diesem Fall halte ich es für nützlich, das unverblasste Anti-OOP-Holivar zu beleuchten. </p><br><p>  Es ist klar, dass die beiden von mir gewählten reduktionistischen Definitionen völlig orthogonal sind.  Polymorphismus und referentielle Transparenz haben nichts miteinander zu tun.  Sie kreuzen sich in keiner Weise. </p><br><p>  Orthogonalität bedeutet jedoch keinen gegenseitigen Ausschluss (fragen Sie James Clerk Maxwell).  Es ist durchaus möglich, ein System zu erstellen, das sowohl dynamischen Polymorphismus als auch referenzielle Transparenz verwendet.  Es ist nicht nur möglich, es ist richtig und gut! </p><br><p>  Warum ist diese Kombination gut?  Aus genau den gleichen Gründen wie beide Komponenten!  Systeme, die auf dynamischem Polymorphismus basieren, sind gut, weil sie eine geringe Konnektivität aufweisen.  Abhängigkeiten können invertiert und auf verschiedenen Seiten der Architekturgrenzen platziert werden.  Diese Systeme können mit Moki und Fake und anderen Arten von Testdoppeln getestet werden.  Module können geändert werden, ohne Änderungen an anderen Modulen vorzunehmen.  Daher sind solche Systeme leichter zu modifizieren und zu verbessern. </p><br><p>  Systeme, die auf referenzieller Transparenz basieren, sind ebenfalls gut, weil sie vorhersehbar sind.  Durch die Unveränderlichkeit des Zustands können solche Systeme leichter verstanden, geändert und verbessert werden.  Dies verringert die Wahrscheinlichkeit von Rennen und anderen Multithreading-Problemen erheblich. </p><br><p>  Die Hauptidee hier ist folgende: </p><br><blockquote>  Es gibt kein Holivar FP gegen OOP </blockquote><p>  FP und OOP arbeiten gut zusammen.  Beide sind gut und in modernen Systemen geeignet.  Das System, das auf einer Kombination der Prinzipien von OOP und FP basiert, maximiert Flexibilität, Wartbarkeit, Testbarkeit, Einfachheit und Festigkeit.  Wenn Sie eine entfernen, um eine weitere hinzuzufügen, wird die Struktur des Systems nur verschlechtert. </p><br><p>  [1] Da wir Maschinen mit Von-Neumann-Architektur verwenden, gehen wir davon aus, dass sie Speicherzellen haben, deren Zustand sich tatsächlich ändert.  In dem von mir beschriebenen Rekursionsmechanismus ermöglicht die Optimierung der Schwanzschwanzrekursion nicht die Erstellung neuer Glasrahmen, und der ursprüngliche Glasrahmen wird verwendet.  Diese Verletzung der referentiellen Transparenz ist (normalerweise) dem Programmierer verborgen und hat keinerlei Auswirkungen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474518/">https://habr.com/ru/post/de474518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474502/index.html">Odnoklassniki-Analyse beim Joker 2019</a></li>
<li><a href="../de474504/index.html">Orthodoxes Backend</a></li>
<li><a href="../de474508/index.html">Erfolge des 3D-Bio-Drucks von Hauttransplantaten</a></li>
<li><a href="../de474514/index.html">Wie überleben chinesische Bitcoin-Bergbaumagnaten?</a></li>
<li><a href="../de474516/index.html">Sprachanwendungen: Der milliardste Markt, den Russland nicht bemerkt</a></li>
<li><a href="../de474522/index.html">Mutt Geschichte</a></li>
<li><a href="../de474526/index.html">Hewlett Packard Enterprise Webinare von November bis Januar</a></li>
<li><a href="../de474528/index.html">Das Buch "Quantum Computing für echte IT-Profis"</a></li>
<li><a href="../de474532/index.html">Radiolabor von Nischni Nowgorod und Radios mit Kristalldetektoren</a></li>
<li><a href="../de474534/index.html">Alan Turing Book und Mysterious Note - Wissenschaftsdetektiv</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>