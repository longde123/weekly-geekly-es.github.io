<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏻 👩🏾‍🤝‍👩🏼 👩‍💻 Que o TestMace é melhor que o Postman 🤺 🌾 👳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal, toque em TestMace ! Talvez muitas pessoas saibam sobre nós a partir de nossos artigos anteriores . Para quem acabou de se conectar: ​​est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Que o TestMace é melhor que o Postman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480734/"><p><img src="https://habrastorage.org/webt/iy/_5/c3/iy_5c3q9lbspu40fmjpvixnwkre.jpeg"></p><br><p> Olá pessoal, toque em <a href="https://testmace.com/" rel="nofollow">TestMace</a> !  Talvez muitas pessoas saibam sobre nós a partir de <a href="https://habr.com/ru/post/458372/">nossos</a> <a href="https://habr.com/ru/post/458964/">artigos</a> <a href="https://habr.com/ru/post/462585/">anteriores</a> .  Para quem acabou de se conectar: ​​estamos desenvolvendo um IDE para trabalhar com a API TestMace.  A pergunta mais frequente ao comparar o TestMace com os produtos concorrentes é "Como você é diferente do Postman?"  Decidimos que era hora de dar uma resposta detalhada a essa pergunta.  Abaixo, detalhamos nossas vantagens sobre o <a href="https://www.getpostman.com/" rel="nofollow">Postman</a> . </p><a name="habracut"></a><br><h2 id="razdelenie-na-uzly">  Subdivisão </h2><br><p>  Se você trabalha com o Postman, sabe que a interface de solicitação contém toda a funcionalidade necessária.  Existem scripts, testes e, de fato, as próprias solicitações.  Isso simplifica o trabalho para iniciantes, mas para cenários grandes essa abordagem não é flexível.  E se você quiser criar várias consultas e agregá-las?  E se você quiser executar um script sem uma solicitação ou vários scripts separados logicamente em uma linha?  No final, seria bom separar os testes de scripts utilitários comuns.  Além disso, a abordagem "adicionar todas as funcionalidades a um nó" não é escalável - a interface fica rapidamente sobrecarregada. </p><br><p>  O TestMace inicialmente divide todas as funcionalidades em diferentes tipos de nós.  Deseja fazer uma solicitação?  Aqui está um nó da <a href="https://docs-ru.testmace.com/node-types/requeststep" rel="nofollow">etapa de solicitação</a> .  Você quer escrever um script?  Aqui está um nó de <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">script</a> para você.  Precisa de testes?  Por favor - nó de <a href="https://docs-ru.testmace.com/node-types/assertion" rel="nofollow">asserção</a> .  Ah, sim, você ainda pode agrupar tudo isso em um nó de <a href="https://docs-ru.testmace.com/node-types/folder" rel="nofollow">pasta</a> .  E tudo isso é facilmente combinado entre si.  Essa abordagem não é apenas muito flexível, mas, de acordo com o princípio da exclusividade de responsabilidade, permite que você use apenas o que realmente precisa no momento.  Por que preciso de scripts e testes se apenas quero fazer uma solicitação? </p><br><h2 id="chelovekochitaemyy-format-proekta">  Formato de projeto legível por humanos </h2><br><p>  Há uma diferença conceitual na maneira como o armazenamento é entre o TestMace e o Postman.  No Postman, todas as solicitações são armazenadas em algum lugar no armazenamento local.  Se houver a necessidade de compartilhar solicitações entre vários usuários, você precisará usar a sincronização interna.  De fato, essa é uma abordagem geralmente aceita, não sem falhas.  E quanto à segurança dos dados?  De fato, a política de algumas empresas pode não permitir o armazenamento de dados de terceiros.  No entanto, acreditamos que o TestMace tem algo melhor a oferecer!  E o nome dessa melhoria é "formato de projeto legível por humanos". </p><br><p>  Para começar, o TestMace basicamente possui uma entidade de projeto.  E o aplicativo foi desenvolvido originalmente com o objetivo de armazenar projetos em sistemas de controle de versão: a árvore do projeto é projetada quase individualmente na estrutura do arquivo, o yaml é usado como formato de armazenamento (sem colchetes e vírgulas) e a representação do arquivo de cada nó é descrita em detalhes na documentação com comentários. .  Mas na maioria dos casos, você não procurará lá - todos os nomes de campos têm nomes lógicos. </p><br><p>  O que isso dá ao usuário?  Isso permite que você mude de maneira muito flexível a equipe do fluxo de trabalho, usando as abordagens usuais.  Por exemplo, os desenvolvedores podem armazenar um projeto no mesmo repositório que o back-end.  Nas filiais, além de alterar diretamente a base de código, o desenvolvedor pode corrigir scripts e testes de consulta existentes.  Após confirmar as alterações no repositório (git, svn, mercurial - o que você mais gosta), o CI (o seu favorito, não imposto a ninguém) lança nosso utilitário de console <a href="https://www.npmjs.com/package/%40testmace/cli" rel="nofollow">testmace-cli</a> e o relatório recebido após a execução (por exemplo, no formato junit, que também é suportado em testmace-cli) é enviado ao sistema apropriado.  E o problema de segurança acima mencionado não é mais um problema. </p><br><p>  Como você pode ver, o TestMace não impõe seu ecossistema e paradigma.  Em vez disso, é facilmente integrado a processos já estabelecidos. </p><br><h2 id="dinamicheskie-peremennye">  Variáveis ​​dinâmicas </h2><br><p>  O TestMace segue o conceito sem código: se o problema puder ser resolvido sem o uso do código, tentamos oferecer essa oportunidade.  Trabalhar com variáveis ​​é justamente essa funcionalidade, onde na maioria dos casos você pode fazer sem programação. </p><br><p>  Exemplo: recebemos uma resposta do servidor e queremos salvar parte da resposta em uma variável.  No Postman, escreveríamos algo assim em um script de teste (o que é estranho por si só): </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, jsonData.data);</code> </pre> <br><p>  Mas, em nossa opinião, escrever um script para um script tão simples e usado com frequência parece redundante.  Portanto, no TestMace, é possível atribuir uma resposta a uma variável usando uma interface gráfica.  Veja como é simples: </p><br><p><img src="https://habrastorage.org/webt/3z/w8/qm/3zw8qmh_a7cnwz2wqkozfw4bv8s.gif"></p><br><p>  E agora, a cada solicitação, essa variável dinâmica será atualizada.  Mas você pode argumentar, argumentando que a abordagem do carteiro é mais flexível e permite que você não apenas faça uma tarefa, mas também realize algum pré-processamento.  Veja como modificar o exemplo anterior: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, CryptoJS.MD5(jsonData.data));</code> </pre> <br><p>  Bem, para isso, o TestMace possui um nó de <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">script</a> que cobre esse script.  Para reproduzir o caso anterior, mas já na execução do TestMace, é necessário criar um nó de script após a solicitação e usar o seguinte código como script: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = tm.currentNode.prev.response.body.data; tm.currentNode.parent.setDynamicVar(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, crypto.MD5(data));</code> </pre> <br><p>  Como você pode ver, a composição dos nós também serviu um bom serviço.  E para um caso tão simples como descrito acima, você pode simplesmente atribuir a expressão <code>${crypto.MD5($response.data)}</code> variável criada através da interface gráfica! </p><br><h2 id="sozdanie-testov-cherez-gui">  Criando testes através da GUI </h2><br><p>  O Postman permite criar testes escrevendo scripts (no caso do Postman, isso é JavaScript).  Essa abordagem tem vantagens sólidas - flexibilidade quase ilimitada, disponibilidade de soluções prontas, etc. </p><br><p>  No entanto, as realidades geralmente são tão (não somos, a vida é tal) que o testador não possui habilidades de programação e eu gostaria de trazer benefícios para a equipe agora.  Nesses casos, seguindo o conceito sem código, o TestMace permite criar testes simples por meio de uma interface gráfica sem recorrer à gravação de scripts.  Aqui, por exemplo, se parece com o processo de criação de um teste que compara valores para igualdade: </p><br><p><img src="https://habrastorage.org/webt/fv/i-/k6/fvi-k6da_gymia7jfvt0kmx1aps.gif"></p><br><p>  No entanto, a criação de testes em um editor gráfico não impede a capacidade de <a href="https://docs-ru.testmace.com/node-types/assertion/script" rel="nofollow">escrever testes no código</a> .  Aqui estão todas as mesmas bibliotecas do nó de script e <a href="https://www.chaijs.com/" rel="nofollow">chai</a> para escrever testes. </p><br><h2 id="vozmozhnost-zapustit-uzhe-suschestvuyuschiy-scenariy-po-ssylke-link-uzel">  Capacidade de executar um script existente por referência (nó Link) </h2><br><p>  Tais situações geralmente surgem quando uma determinada solicitação ou mesmo um script inteiro precisa ser executado várias vezes em diferentes partes de um projeto.  Um exemplo de tais solicitações é a autorização personalizada de vários estágios, levando o ambiente ao estado desejado etc.  Em geral, falando em termos de linguagens de programação, eu gostaria de ter funções que possam ser reutilizadas em diferentes partes do aplicativo.  No TestMace, essa função é executada pelo nó do <a href="https://docs-ru.testmace.com/node-types/link" rel="nofollow">link</a> .  Usá-lo é muito simples: <br>  1) crie uma consulta ou script <br>  2) crie um nó do tipo Link <br>  3) nos parâmetros, especifique o link para o script criado na primeira etapa </p><br><p>  Em uma versão mais avançada, você pode especificar quais variáveis ​​dinâmicas do script são lançadas para um nível mais alto em relação ao link.  Parece confuso?  Suponha que tenhamos criado uma pasta chamada <strong>create-post</strong> , dentro da qual uma variável dinâmica <code>postId</code> é atribuída a esse nó.  Agora, no link do nó <strong>create-post-link</strong> , é possível especificar explicitamente que a variável <code>postId</code> designada ao ancestral <strong>create-post-link</strong> .  Este mecanismo (novamente, expresso na linguagem do programador) pode ser usado para retornar o resultado da "função".  Em geral, legal, SECO em pleno crescimento e, novamente, nenhuma linha de código foi prejudicada. </p><br><p><img src="https://habrastorage.org/webt/yo/8s/nj/yo8snjixc2ozh3vdrhprnstmess.gif"></p><br><p>  Quanto ao Postman, o pedido de recurso para reutilização está <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">suspenso desde 2015</a> e parece haver <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">algumas dicas de</a> que eles estão trabalhando nesse problema.  Em sua forma atual, o Postman, é claro, tem a capacidade de alterar o fluxo de execução, o que, em teoria, provavelmente permite que você implemente esse comportamento, mas isso é mais um truque sujo do que uma abordagem realmente funcional. </p><br><h2 id="prochie-otlichiya">  Outras diferenças </h2><br><ul><li>  Maior controle sobre o escopo das variáveis.  O menor escopo dentro do qual você pode definir uma variável no Postman é coleção.  O TestMace permite definir variáveis ​​para qualquer consulta ou pasta.  No Postman, a coleção Compartilhar permite exportar apenas coleções, enquanto no TestMace o compartilhamento funciona para qualquer nó. </li><li>  O TestMace suporta <a href="http-headers" rel="nofollow">cabeçalhos herdados</a> , que por padrão podem ser substituídos em consultas filhas.  No Postman, existe uma <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">tarefa a</a> esse respeito, e ela é fechada, mas como solução, propõe-se ... <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">usar scripts</a> .  No TestMace, tudo isso é configurado via GUI e existe a opção de desativar opcionalmente os cabeçalhos herdados em descendentes específicos </li><li>  Desfazer / Refazer.  Ele funciona não apenas ao editar nós, mas também ao mover, excluir, renomear e outras operações que alteram a estrutura do projeto </li><li>  Os arquivos anexados às solicitações tornam-se parte do projeto e são armazenados com ele, enquanto são perfeitamente sincronizados, ao contrário do Postman.  (Sim, você não precisa mais selecionar manualmente os arquivos sempre que iniciar e transferi-los para colegas nos arquivos) </li></ul><br><h2 id="fichi-kotorye-uzhe-na-podhode">  Recursos que estão a caminho </h2><br><p>  Não resistimos à tentação de abrir o véu de sigilo nos próximos lançamentos, especialmente quando a funcionalidade é muito saborosa e já está em processo de pré-lançamento.  Então, nos encontramos. </p><br><h3 id="funkcii">  Funções </h3><br><p>  Como você sabe, o Postman usa as chamadas variáveis ​​dinâmicas para gerar valores.  <a href="https://learning.getpostman.com/docs/postman/variables-and-environments/variables-list/" rel="nofollow">A lista deles é impressionante</a> e a grande maioria das funções serve para gerar valores falsos.  Por exemplo, para gerar um email aleatório, você precisa escrever: </p><br><pre> <code class="plaintext hljs">{{$randomEmail}}</code> </pre> <br><p>  No entanto, como essas são variáveis ​​(embora dinâmicas), elas não podem ser usadas como funções: elas não são parametrizáveis, portanto, não funcionará para tirar um hash de uma string. </p><br><p>  No TestMace, planejamos adicionar recursos honestos.  Dentro de $ {}, você pode acessar não apenas a variável, mas também chamar a função.  I.e.  se você precisar gerar o notório e-mail falso, basta escrever </p><br><pre> <code class="plaintext hljs">${faker.internet.email()}</code> </pre> <br><p>  Além do fato de que essa é uma função, você pode perceber que existe a possibilidade de chamar um método de objeto.  E, em vez de uma grande lista plana de variáveis ​​dinâmicas, temos um conjunto de objetos agrupados logicamente. </p><br><p>  Mas e se quisermos calcular o hash da string?  Fácil! </p><br><pre> <code class="plaintext hljs">${crypto.MD5($dynamicVar.data)}</code> </pre> <br><p>  Você pode perceber que pode até passar variáveis ​​como parâmetros!  Nesse local, um leitor curioso pode suspeitar que algo estava errado ... </p><br><h3 id="ispolzovanie-javascript-v-vyrazheniyah">  Usando JavaScript em expressões </h3><br><p>  ... E não em vão!  Quando os requisitos para as funções foram formados, subitamente chegamos à conclusão de que nas expressões você precisa permitir que javascript válido seja escrito.  Então agora você é livre para escrever expressões no espírito: </p><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> + crypto.MD5(<span class="hljs-string"><span class="hljs-string">'asdf'</span></span>)}</code> </pre> <br><p>  E tudo isso sem scripts diretamente nos campos de entrada! </p><br><p>  Quanto ao Postman, apenas variáveis ​​podem ser usadas e, ao tentar escrever uma pequena expressão, o validador jura e se recusa a calculá-la. </p><br><p><img src="https://habrastorage.org/webt/a_/ul/53/a_ul5311im7wyvy-b1_vlqqlifw.png"></p><br><h3 id="prodvinutoe-avtodopolnenie">  Preenchimento automático avançado </h3><br><p>  No momento, o TestMace possui o preenchimento automático padrão, parecido com este: </p><br><p><img src="https://habrastorage.org/webt/kl/2b/ub/kl2bubsefwlskk59_qtdijhdnn0.png"></p><br><p>  Aqui, além da linha de preenchimento automático, o que essa linha pertence é indicado.  Esse mecanismo funciona apenas em expressões enquadradas entre colchetes $ {}. </p><br><p>  Como você pode ver, foram adicionados marcadores visuais que indicam o tipo da variável (por exemplo, sequência, número, matriz, etc.).  Você também pode alterar os modos de preenchimento automático (por exemplo, você pode escolher o preenchimento automático com variáveis ​​ou cabeçalhos).  Mas mesmo isso não é a coisa mais importante! </p><br><p>  Primeiro, o preenchimento automático funciona mesmo em expressões (sempre que possível).  Aqui está o que parece: </p><br><p><img src="https://habrastorage.org/webt/vk/vg/f5/vkvgf5vtk4sjh7r1tzamrdpojcm.png"></p><br><p>  E segundo, agora o preenchimento automático também está disponível em scripts.  Veja como funciona! </p><br><p><img src="https://habrastorage.org/webt/ea/rd/2l/eard2lfj7wmtu4189xn-wy2tjjk.gif"></p><br><p>  Não faz sentido comparar essa funcionalidade com o Postman - o preenchimento automático é limitado apenas a listas estáticas de variáveis, cabeçalhos e seus valores (corrija-me se eu esqueci isso).  Os scripts não são preenchidos automaticamente :( </p><br><h1 id="zaklyuchenie">  Conclusão </h1><br><p>  Em outubro, um ano se passou desde o início do desenvolvimento de nosso produto.  Durante esse período, conseguimos fazer muitas coisas e, de alguma forma, alcançamos nossos concorrentes.  Seja como for, nosso objetivo é criar uma ferramenta realmente conveniente para trabalhar com a API.  Ainda temos muito trabalho a fazer, eis um plano aproximado de desenvolvimento para o nosso projeto para o próximo ano: <a href="https://testmace.com/roadmap/" rel="nofollow">https://testmace.com/roadmap</a> . </p><br><p>  Seu feedback nos permitirá navegar melhor em abundância de recursos, e seu apoio nos dará força e confiança de que estamos fazendo a coisa certa.  Aconteceu que hoje é um dia importante para o nosso projeto - o dia da publicação do TestMace no <a href="https://www.producthunt.com/posts/testmace" rel="nofollow">ProductHunt</a> .  Por favor, apoiem o nosso projeto, é muito importante para nós.  Além disso, hoje em nossa página de PH há uma oferta tentadora e limitada </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480734/">https://habr.com/ru/post/pt480734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480712/index.html">O vôo com um dosímetro no bolso</a></li>
<li><a href="../pt480714/index.html">Como adicionar codec ao FFmpeg</a></li>
<li><a href="../pt480716/index.html">Matlab vs. Julia vs. Python</a></li>
<li><a href="../pt480724/index.html">Idiomas transcompilados: projetos de conversão de código em código</a></li>
<li><a href="../pt480730/index.html">Desenvolvimento de Moto-Auto e Nginx</a></li>
<li><a href="../pt480736/index.html">Por que nem todos os erros precisam ser corrigidos para melhorar um produto de TI</a></li>
<li><a href="../pt480738/index.html">Experiência na criação de um produto na Rússia ou como criar um aspirador de pó sem fio “popular” PRO-EXPERT</a></li>
<li><a href="../pt480740/index.html">4 recursos legais do Numpy que eu uso constantemente</a></li>
<li><a href="../pt480744/index.html">Como um programador pode proteger seu projeto de estimação</a></li>
<li><a href="../pt480746/index.html">Pré-carregamento no php 7.4: Compositor e seleção de arquivos para pré-carregamento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>