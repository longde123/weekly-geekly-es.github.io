<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö± üë£ ü§ûüèº D√©tail dynamique: jeux cach√©s du compilateur, fuite de m√©moire, nuances de performances üë®‚Äçüëß‚Äçüëß üåÅ üë©üèø‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreplay 

 Consid√©rez le code suivant: 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©tail dynamique: jeux cach√©s du compilateur, fuite de m√©moire, nuances de performances</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2>  Foreplay </h2><br><br>  Consid√©rez le code suivant: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  La signature de la m√©thode <i>Marshal.FinalReleaseComObject</i> est la suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  Nous cr√©ons un simple objet COM, faisons un peu de travail et le lib√©rons imm√©diatement.  Il semblerait que ce qui pourrait mal tourner?  Oui, la cr√©ation d'un objet √† l'int√©rieur d'une boucle infinie n'est pas une bonne pratique, mais le <i>GC</i> prendra tout le sale boulot.  La r√©alit√© est l√©g√®rement diff√©rente: <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br>  Pour comprendre les fuites de m√©moire, vous devez comprendre le fonctionnement de la <i>dynamique</i> .  Il existe d√©j√† plusieurs articles sur ce sujet sur Habr√©, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celui-ci</a> , mais ils n'entrent pas dans les d√©tails de mise en ≈ìuvre, nous allons donc mener nos propres recherches. <br><br><a name="habracut"></a><br><br>  Tout d'abord, nous examinerons en d√©tail le m√©canisme de travail <i>dynamique</i> , puis nous r√©duirons les connaissances acquises en une seule image et √† la fin, nous discuterons des raisons de cette fuite et comment l'√©viter.  Avant de plonger dans le code, clarifions les donn√©es sources: quelle combinaison de facteurs conduit √† la fuite? <br><br><h2>  Les exp√©riences </h2><br><br>  La cr√©ation de nombreux objets <i>COM natifs</i> est peut-√™tre une mauvaise id√©e en soi?  V√©rifions: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br>  Tout va bien cette fois: <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br>  Revenons √† la version originale du code, mais changeons le type d'objet: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Et encore une fois, pas de surprise: <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br>  Essayons la troisi√®me option: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br>  Eh bien maintenant, nous devrions certainement avoir le m√™me comportement!  Hein?  Non :( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br>  Une image similaire sera si vous d√©clarez com en tant <i>qu'objet</i> ou si vous travaillez avec <i>COM g√©r√©</i> .  R√©sumez les r√©sultats exp√©rimentaux: <br><br><ol><li>  L'instanciation d'objets <i>COM natifs</i> en soi ne conduit pas √† des fuites - le <i>GC</i> r√©ussit √† faire face √† l'effacement de la m√©moire </li><li>  Lorsque vous travaillez avec une classe <i>g√©r√©e</i> , aucune fuite ne se produit </li><li>  Lors de la conversion explicite d'un objet en <i>objet</i> , tout va bien aussi </li></ol><br><br>  Pour l'avenir, au premier point, nous pouvons ajouter le fait que travailler avec <i>des</i> objets <i>dynamiques</i> (appeler des m√©thodes ou travailler avec des propri√©t√©s) ne provoque pas en soi de fuites.  La conclusion se sugg√®re: une fuite de m√©moire se produit lorsque nous passons un objet <i>dynamique</i> (sans conversion de type "manuelle") contenant <i>COM natif</i> , comme param√®tre de m√©thode. <br><br><h2>  Nous devons aller plus loin </h2><br><br>  Il est temps de se rappeler en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quoi consiste</a> cette <i>dynamique</i> : <br><br><div class="spoiler">  <b class="spoiler_title">R√©f√©rence rapide</b> <div class="spoiler_text"><blockquote>  C # 4.0 fournit un nouveau type de <b>dynamique</b> .  Ce type √©vite la v√©rification de type statique par le compilateur.  Dans la plupart des cas, il fonctionne comme un type d' <b>objet</b> .  Au moment de la compilation, il est suppos√© qu'un √©l√©ment d√©clar√© comme <b>dynamique</b> prend en charge toute op√©ration.  Cela signifie que vous n'avez pas besoin de penser √† la provenance de l'objet - √† partir de l'API COM, d'un langage dynamique comme IronPython, √† l'aide de la r√©flexion, ou d'ailleurs.  De plus, si le code n'est pas valide, des erreurs seront lanc√©es lors de l'ex√©cution. <br><br>  Par exemple, si la m√©thode <b>exampleMethod1</b> dans le code suivant a exactement un param√®tre, le compilateur reconna√Æt que le premier appel √† la <b>m√©thode ec.exampleMethod1 (10, 4)</b> n'est pas valide car il contient deux param√®tres.  Cela entra√Ænera une erreur de compilation.  Le deuxi√®me appel de m√©thode, <b>dynamic_ec.exampleMethod1 (10, 4) n'est</b> pas v√©rifi√© par le compilateur, car <b>dynamic_ec est donc</b> d√©clar√© comme <b>dynamique</b> .  il n'y aura pas d'erreurs de compilation.  N√©anmoins, l'erreur ne passera pas inaper√ßue pour toujours - elle sera d√©tect√©e lors de l'ex√©cution. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br>  Le code qui utilise <i>des</i> variables <i>dynamiques</i> subit des changements importants lors de la compilation.  Ce code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br>  Se transforme en ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br>  O√π <b>o__0</b> est la classe statique g√©n√©r√©e et <b>p__0</b> est le champ statique qu'il <b>contient</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>Remarque: pour chaque interaction avec <i>dynamique</i> , un champ CallSite est cr√©√©.</i>  <i>Ceci, comme nous le verrons plus loin, est n√©cessaire pour optimiser les performances.</i> <br><br>  Notez qu'aucune mention de <i>dynamique</i> n'est laiss√©e - notre objet est maintenant stock√© dans une variable de type <i>objet</i> .  Passons en revue le code g√©n√©r√©.  Tout d'abord, une liaison est cr√©√©e, qui d√©crit ce que nous faisons et ce que nous faisons: <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br>  Ceci est une description de notre fonctionnement dynamique.  Permettez-moi de vous rappeler que nous transmettons une variable <i>dynamique</i> √† la m√©thode <i>FinalReleaseComObject</i> . <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded - le r√©sultat de l'ex√©cution de la m√©thode n'est pas utilis√© √† l'avenir </li><li>  "FinalReleaseComObject" - le nom de la m√©thode appel√©e </li><li>  typeof (Foo) - contexte d'op√©ration;  le type d'appel </li></ul><br><br>  <b>CSharpArgumentInfo</b> - description des param√®tres de liaison.  Dans notre cas: <br><br><ul><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null) - description du premier param√®tre - la classe Marshal: elle est statique et son type doit √™tre pris en compte lors de la liaison </li><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.None, (string) null) - description du param√®tre de m√©thode, g√©n√©ralement il n'y a pas d'informations suppl√©mentaires. </li></ul><br><br>  S'il ne s'agissait pas d'appeler une m√©thode, mais d'appeler, par exemple, une propri√©t√© √† partir d'un objet <i>dynamique</i> , il n'y aurait alors qu'un seul <b>CSharpArgumentInfo</b> d√©crivant l'objet <i>dynamique</i> lui-m√™me. <br><br>  <b>CallSite</b> est un wrapper sur une expression dynamique.  Il contient deux domaines importants pour nous: <br><br><ul><li>  mise √† jour T publique </li><li>  public T Target </li></ul><br><br>  D'apr√®s le code g√©n√©r√©, il est clair que lorsqu'une op√©ration est effectu√©e, <b>Target</b> est appel√© avec des param√®tres le d√©crivant: <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br>  En combinaison avec <b>CSharpArgumentInfo</b> d√©crit ci-dessus <b>,</b> ce code signifie ce qui suit: vous devez appeler la m√©thode FinalReleaseComObject sur la classe Marshal statique avec le param√®tre d'instance.  Au moment du premier appel, le m√™me d√©l√©gu√© est stock√© dans <b>Target</b> comme dans <b>Update</b> .  Le d√©l√©gu√© de <b>mise √† jour</b> est responsable de deux t√¢ches importantes: <br><br><ol><li>  Lier une op√©ration dynamique √† une op√©ration statique (le m√©canisme d'ench√®re lui-m√™me d√©passe le cadre de cet article) </li><li>  Formation de cache </li></ol><br><br>  Nous nous int√©ressons au deuxi√®me point.  Il convient de noter ici que lorsque vous travaillez avec un objet dynamique, nous devons v√©rifier la validit√© de l'op√©ration √† chaque fois.  Il s'agit d'une t√¢che plut√¥t gourmande en ressources, je souhaite donc mettre en cache les r√©sultats de ces v√©rifications.  En ce qui concerne l'appel d'une m√©thode avec un param√®tre, nous devons nous rappeler ce qui suit: <br><br><ol><li>  Le type sur lequel la m√©thode est appel√©e </li><li>  Le type d'objet transmis par le param√®tre (pour √™tre s√ªr qu'il peut √™tre converti en type de param√®tre) </li><li>  L'op√©ration est-elle valide </li></ol><br><br>  Ensuite, lorsque vous appelez √† nouveau <b>Target</b> , nous n'avons pas besoin d'effectuer des liaisons relativement co√ªteuses: il suffit de comparer les types et, s'ils correspondent, d'appeler la fonction objectif.  Pour r√©soudre ce probl√®me, un <i>ExpressionTree</i> est cr√©√© pour chaque op√©ration dynamique, qui stocke les <i>contraintes</i> et la <i>fonction objectif</i> √† laquelle l'expression dynamique √©tait li√©e. <br><br>  Cette fonction peut √™tre de deux types: <br><br><ul><li>  <i>Erreur de liaison</i> : par exemple, une m√©thode est appel√©e sur un objet <i>dynamique</i> qui n'existe pas ou un objet <i>dynamique</i> ne peut pas √™tre converti dans le type du param√®tre auquel il est transmis: vous devez alors <i>lever</i> une exception comme <i>Microsoft.CSharp.RuntimeBinderException: 'NoSuchMember'</i> </li><li>  Le d√©fi est l√©gal: il suffit alors d'effectuer l'action requise </li></ul><br><br>  Cet <i>ExpressionTree</i> est form√© lors de l'ex√©cution du d√©l√©gu√© de <b>mise √† jour</b> et stock√© dans <b>Target</b> .  <b>Cible</b> - Cache <i>L0</i> , nous parlerons plus en d√©tail du cache plus tard. <br><br>  Ainsi, <b>Target</b> stocke le dernier <i>ExpressionTree</i> g√©n√©r√© via le d√©l√©gu√© de <b>mise √† jour</b> .  Voyons √† quoi ressemble cette <i>r√®gle</i> comme un exemple de type <i>Managed</i> pass√© √† la m√©thode <i>Boo</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Le bloc le plus important pour nous: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i> et <i>$$ arg1</i> sont les param√®tres avec lesquels <b>Target</b> est appel√©: <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br>  Traduit en humain, cela signifie ce qui suit: <br><br>  Nous avons d√©j√† v√©rifi√© que si le premier param√®tre est de type <i>Foo</i> et le second est <i>Int32</i> , alors vous pouvez appeler <i>Boo en</i> toute s√©curit√© <i>((object) $$ arg1)</i> . <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>Remarque: en cas d'erreur de liaison, le bloc Label1 ressemble √† ceci:</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br>  Ces v√©rifications sont appel√©es <b>contraintes</b> .  <b>Il</b> existe deux types de <b>restrictions</b> : par type d'objet et par instance sp√©cifique de l'objet (l'objet doit √™tre exactement le m√™me).  Si au moins une des restrictions √©choue, nous devrons rev√©rifier la validit√© de l'expression dynamique, pour cela nous appellerons le d√©l√©gu√© de <b>mise √† jour</b> .  Selon le sch√©ma que nous connaissons d√©j√†, il effectuera la liaison avec de nouveaux types et enregistrera le nouvel <i>ExpressionTree</i> dans <b>Target</b> . <br><br><h2>  Cache </h2><br><br>  Nous avons d√©j√† d√©couvert que <b>Target</b> est un <b>cache L0</b> .  Chaque fois que <b>Target</b> est appel√©, la premi√®re chose que nous ferons est de passer par les restrictions qui y sont d√©j√† stock√©es.  Si les restrictions √©chouent et qu'une nouvelle liaison est g√©n√©r√©e, l'ancienne r√®gle passe simultan√©ment √† <b>L1</b> et <b>L2</b> .  √Ä l'avenir, lorsque vous <i>manquerez le</i> cache <i>L0</i> , les r√®gles de <i>L1</i> et <i>L2</i> seront recherch√©es jusqu'√† ce que celle qui convient soit trouv√©e. <br><br><ul><li>  <i>L1</i> : Les dix derni√®res r√®gles qui ont quitt√© <i>L0</i> (stock√©es directement dans <i>CallSite</i> ) </li><li>  <i>L2</i> : Les 128 derni√®res r√®gles cr√©√©es √† l'aide d'une instance de classeur sp√©cifique (qui est <i>CallSiteBinder</i> , unique √† chaque <i>CallSite</i> ) </li></ul><br><br>  Maintenant, nous pouvons enfin ajouter ces d√©tails dans un seul ensemble et d√©crire sous la forme d'un algorithme ce qui se passe lorsque <i>Foo.Bar (someDynamicObject) est appel√©</i> : <br><br>  1. Un classeur est cr√©√© qui se souvient du contexte et de la m√©thode appel√©e au niveau de leurs signatures <br><br>  2. La premi√®re fois que l'op√©ration est appel√©e, <i>ExpressionTree</i> est cr√©√©, qui stocke: <br>  2.1 <b>Limitations</b> .  Dans ce cas, il s'agira de deux restrictions sur le type de param√®tres de liaison actuels <br>  2.2 <b>Fonction objective</b> : soit <i>lever une exception</i> (dans ce cas c'est impossible, car toute <i>dynamique</i> aboutira avec succ√®s √† l'objet) soit un appel √† la m√©thode <i>Bar</i> <br><br>  3. Compilez et ex√©cutez le ExpressionTree r√©sultant <br><br>  4. Lorsque vous rappelez l'op√©ration, deux options sont possibles: <br>  4.1 <b>Limitations fonctionnelles</b> : appelez simplement <i>Bar</i> <br>  4.2 Les <b>limitations n'ont pas fonctionn√©</b> : r√©p√©tez l'√©tape 2 pour les nouveaux param√®tres de liaison <br><br>  Ainsi, avec l'exemple du type <i>G√©r√©</i> , il est devenu √† peu pr√®s clair comment la <i>dynamique</i> fonctionne de l'int√©rieur.  Dans le cas d√©crit, nous ne manquerons jamais le cache, car les types sont toujours les m√™mes *, donc <b>Update sera</b> appel√© exactement une fois lorsque <i>CallSite est</i> initialis√©.  Ensuite, pour chaque appel, seules les restrictions seront v√©rifi√©es et la fonction objectif sera appel√©e imm√©diatement.  Ceci est en excellent accord avec nos observations de m√©moire: pas de calcul - pas de fuites. <br><br>  <i>* Pour cette raison, le compilateur g√©n√®re ses CallSites pour chacun: la probabilit√© de manquer le cache L0 est extr√™mement r√©duite</i> <br><br>  Il est temps de d√©couvrir en quoi ce sch√©ma diff√®re dans le cas des objets <i>COM natifs</i> .  Jetons un coup d'≈ìil √† <i>ExpressionTree</i> : <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  On peut voir que la diff√©rence ne concerne que la deuxi√®me restriction: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br>  Si dans le cas du code <i>manag√©</i> , nous avions deux restrictions sur le type d'objets, alors nous voyons ici que la deuxi√®me restriction v√©rifie l'√©quivalence des instances via <i>WeakReference</i> . <br><br>  <i>Remarque: La restriction d'instance en plus des objets COM est √©galement utilis√©e pour TransparentProxy</i> <br><br>  En pratique, sur la base de notre connaissance du fonctionnement du cache, cela signifie que chaque fois que nous recr√©ons un objet <i>COM</i> dans une boucle, nous manquerons le cache <i>L0</i> (et <i>L1 / L2</i> aussi, car les anciennes r√®gles avec liens y seront stock√©es aux anciennes instances).  La premi√®re hypoth√®se qui vous demande dans la t√™te est que le cache de r√®gles coule.  Mais le code y est assez simple et tout va bien: les anciennes r√®gles sont supprim√©es correctement.  Dans le m√™me temps, l'utilisation de <i>WeakReference</i> dans <i>ExpressionTree</i> n'emp√™che pas le <i>GC</i> de collecter des objets inutiles. <br><br>  <i>Le m√©canisme d'enregistrement des r√®gles dans le cache L1:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br>  Alors, quel est le probl√®me?  Essayons de clarifier l'hypoth√®se: une fuite de m√©moire se produit quelque part lors de la liaison d'un objet <i>COM</i> . <br><br><h2>  Exp√©riences, partie 2 </h2><br><br>  Encore une fois, passons des conclusions sp√©culatives aux exp√©riences.  Tout d'abord, r√©p√©tons ce que le compilateur fait pour nous: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br>  Nous v√©rifions: <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br>  La fuite a √©t√© conserv√©e.  Juste.  Mais quelle en est la raison?  Apr√®s avoir √©tudi√© le code des classeurs (que nous laissons derri√®re les crochets), il est clair que la seule chose qui affecte le type de notre objet est l'option de restriction.  Peut-√™tre que ce n'est pas une question d'objets <i>COM</i> , mais un liant?  Il n'y a pas beaucoup de choix, provoquons plusieurs liaisons pour le type <i>G√©r√©</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br>  Ouah!  Il semble que nous l'avons attrap√©.  Le probl√®me n'est pas du tout avec l' <i>objet COM</i> , comme il nous a sembl√© au d√©part, juste en raison des limitations de l'instance, c'est le seul cas o√π la liaison se produit plusieurs fois √† l'int√©rieur de notre boucle.  Dans tous les autres cas, j'ai r√©cup√©r√© le <i>cache L0</i> et effectu√© une liaison. <br><br><h2>  Conclusions </h2><br><br><h3>  Fuite de m√©moire </h3><br><br>  Si vous travaillez avec <i>des</i> variables <i>dynamiques</i> qui contiennent <i>COM natif</i> ou <i>TransparentProxy</i> , ne les passez jamais en tant que param√®tres de m√©thode.  Si vous devez toujours le faire, utilisez la conversion explicite en <i>objet</i> , puis le compilateur sera en retard sur vous. <br><br>  <b>Mauvais</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>Correctement</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br>  Par mesure de pr√©caution suppl√©mentaire, essayez d'instancier ces objets aussi rarement que possible.  R√©el pour toutes les versions du <i>.NET Framework</i> .  (Pour l'instant) n'est pas tr√®s pertinent pour.  <i>NET Core</i> , car il n'y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas de prise en charge pour</a> <i>les</i> objets <i>COM dynamiques</i> . <br><br><h3>  Performances </h3><br><br>  Il est dans votre int√©r√™t que les √©checs de cache se produisent aussi rarement que possible, car dans ce cas, il n'est pas n√©cessaire de trouver une r√®gle appropri√©e dans les caches de haut niveau.  Des √©checs dans le cache <i>L0</i> se produiront principalement en cas de non-concordance du type de l'objet <i>dynamique</i> avec les restrictions pr√©serv√©es. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br>  Cependant, dans la pratique, vous ne remarquerez probablement pas la diff√©rence de performances sauf si le nombre d'appels √† cette fonction est mesur√© en millions ou si la variabilit√© des types n'est pas inhabituellement grande.  Les co√ªts en cas de manque sur le cache <i>L0</i> sont tels, <i>N</i> est le nombre de types: <br><br><ul><li>  <i>N</i> &lt;10.  Si vous manquez, parcourez uniquement les r√®gles de cache <i>L1</i> existantes </li><li>  10 &lt; <i>N &lt;128</i> .  √ânum√©ration du cache <i>L1</i> et <i>L2</i> (maximum 10 et <i>N</i> it√©rations).  Cr√©ation et remplissage d'un tableau de 10 √©l√©ments </li><li>  <i>N</i> &gt; 128.  It√©rer sur le cache <i>L1</i> et <i>L2</i> .  Cr√©ez et remplissez des tableaux de 10 et 128 √©l√©ments.  Si vous manquez le cache <i>L2,</i> reliez √† nouveau </li></ul><br><br>  Dans les deuxi√®me et troisi√®me cas, la charge sur le CPG augmentera. <br><br><h2>  Conclusion </h2><br><br>  Malheureusement, nous n'avons pas trouv√© de v√©ritable raison de la fuite de m√©moire, cela n√©cessitera une √©tude s√©par√©e du liant.  Heureusement, <i>WinDbg</i> fournit un indice pour une enqu√™te plus approfondie: quelque chose de mauvais se produit dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DLR</a> .  La premi√®re colonne est le nombre d'objets <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2>  Bonus </h2><br><br>  <b>Pourquoi la conversion en <i>objet</i> emp√™che-t-elle explicitement une fuite?</b> <br>  N'importe quel type peut √™tre converti en <i>objet</i> , de sorte que l'op√©ration cesse d'√™tre dynamique. <br><br>  <b>Pourquoi n'y a-t-il pas de fuites lors de l'utilisation des champs et des m√©thodes d'un objet COM?</b> <br>  Voici √† quoi ressemble <i>ExpressionTree</i> pour l'acc√®s aux champs: <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466657/">https://habr.com/ru/post/fr466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466643/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 314 (du 2 au 8 septembre)</a></li>
<li><a href="../fr466647/index.html">T√©l√©phone pour cheval et orchestre sans pianiste. Comment proposer des t√¢ches sportives en premi√®re ligne</a></li>
<li><a href="../fr466649/index.html">Week-end en voiture √©lectrique</a></li>
<li><a href="../fr466651/index.html">Choisir entre XML et SQL pour lancer des scripts LiquiBase en utilisant Java / Spring / H2 comme exemple</a></li>
<li><a href="../fr466653/index.html">D√©bogage de jeux pour NES: comment √ßa se passe aujourd'hui</a></li>
<li><a href="../fr466659/index.html">Examen de Kubecost pour √©conomiser de l'argent sur Kubernetes dans les nuages</a></li>
<li><a href="../fr466661/index.html">Master √† distance √† l'√©tranger: notes avant la th√®se</a></li>
<li><a href="../fr466663/index.html">Exp√©riences simples avec le microcontr√¥leur STM32F103 (Blue Tablet)</a></li>
<li><a href="../fr466665/index.html">D√©bordement CSS et perte de donn√©es</a></li>
<li><a href="../fr466667/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 379 (2 - 8 septembre 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>