<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 🧝 🕒 Expérience de l'utilisation de «coordinateurs» dans un véritable projet «iOS» 🌎 💳 🏇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le monde de la programmation moderne est riche en tendances, et cela est doublement vrai pour le monde de la programmation des applications "iOS" . J'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Expérience de l'utilisation de «coordinateurs» dans un véritable projet «iOS»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444038/">  Le monde de la programmation moderne est riche en tendances, et cela est doublement vrai pour le monde de la programmation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applications "iOS"</a> .  J'espère que je ne me trompe pas beaucoup en affirmant que l'un des modèles architecturaux les plus «à la mode» de ces dernières années est le «coordinateur».  Notre équipe a donc réalisé il y a quelque temps une irrésistible envie d'essayer cette technique par elle-même.  De plus, un très bon cas s'est présenté - un changement significatif dans la logique et une re-planification totale de la navigation dans l'application. <br><a name="habracut"></a><br><h2>  Le problème </h2><br>  Il arrive souvent que les contrôleurs commencent à en prendre trop: «donner des commandes» directement au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UINavigationController</code></a> , «communiquer» avec leurs contrôleurs «frères» (même les initialiser et les transmettre à la pile de navigation) - en général, il y a beaucoup à faire qu'ils ne devraient même pas soupçonner. <br><br>  Un des moyens possibles pour éviter cela est précisément le «coordinateur».  De plus, comme il s’est avéré, il est assez pratique de travailler et très flexible: le modèle est capable de gérer les événements de navigation des deux petits modules (représentant, peut-être, un seul écran) et de l’application entière (en lançant son «flux», relativement parlant, directement depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UIApplicationDelegate</code></a> ). <br><br><h2>  L'histoire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Martin Fowler,</a> dans son livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Patterns of Enterprise Application Architecture, a</a> appelé ce modèle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application Controller</a> .  Et son premier vulgarisateur dans l'environnement "iOS" est considéré comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sorush Khanlu</a> : tout a commencé avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son reportage sur "NSSpain"</a> en 2015.  Puis un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de revue</a> est apparu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur son site Web</a> , qui avait plusieurs suites (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceci</a> ). <br><br>  Et puis de nombreuses critiques ont suivi (la requête «coordinateurs ios» donne des dizaines de résultats de qualité et de degré de détail différents), y compris même un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide sur Ray Wenderlich</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Paul Hudson sur son «Hacking with Swift»</a> dans le cadre d'une série de documents sur la façon de se débarrasser du problème Contrôleur "massif". <br><br>  Pour l'avenir, le sujet de discussion le plus notable est le problème du bouton de retour dans <code>UINavigationController</code> , dont le clic n'est pas traité par notre code, mais nous ne pouvons obtenir qu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rappel</a> . <br><br>  En fait, pourquoi est-ce un problème?  Les coordinateurs, comme tous les objets, pour exister en mémoire, ont besoin d'un autre objet pour les «posséder».  En règle générale, lors de la construction d'un système de navigation à l'aide de coordinateurs, certains coordinateurs en génèrent d'autres et gardent un lien fort avec eux.  En «quittant la zone de responsabilité» du coordinateur d'origine, le contrôle revient au coordinateur d'origine et la mémoire occupée par le coordinateur doit être libérée. <br><br>  Sorush a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa propre vision pour résoudre ce problème</a> , et note également quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approches</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dignes</a> .  Mais nous y reviendrons. <br><br><h2>  Première approche </h2><br>  <i>Avant de commencer à montrer le vrai code, je tiens à préciser que bien que les principes soient pleinement cohérents avec ceux que nous avons élaborés dans le projet, des extraits du code et des exemples de son utilisation sont simplifiés et réduits partout où cela n'interfère pas avec leur perception.</i> <br><br>  Lorsque nous avons commencé à expérimenter avec les coordinateurs de l'équipe, nous n'avions pas beaucoup de temps et de liberté d'action pour cela: il fallait tenir compte des principes existants et de l'appareil de navigation.  La première option d'implémentation pour les coordinateurs était basée sur un «routeur» commun, qui est détenu et exploité par l' <code>UINavigationController</code> .  Il sait comment faire avec les instances de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UIViewController</code></a> tout ce qui est nécessaire en matière de navigation - push / pop, present / disable plus les manipulations avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le contrôleur racine</a> .  Un exemple de l'interface d'un tel routeur: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol Router { func present(_ module: UIViewController, animated: Bool) func dismissModule(animated: Bool, completion: (() -&gt; Void)?) func push(_ module: UIViewController, animated: Bool, completion: (() -&gt; Void)?) func popModule(animated: Bool) func setAsRoot(_ module: UIViewController) func popToRootModule(animated: Bool) }</code> </pre> <br>  Une implémentation spécifique est initialisée avec une instance de <code>UINavigationController</code> et ne contient rien de particulièrement délicat en soi.  La seule limitation: vous ne pouvez pas passer d'autres instances de <code>UINavigationController</code> comme arguments aux méthodes d'interface (pour des raisons évidentes: <code>UINavigationController</code> ne peut pas contenir <code>UINavigationController</code> dans sa pile - il s'agit d'une restriction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UIKit</code></a> ). <br><br>  Le coordinateur, comme tout objet, a besoin d'un propriétaire - un autre objet qui stockera un lien vers celui-ci.  Un lien vers la racine peut être stocké par l'objet qui le génère, mais chaque coordinateur peut également générer d'autres coordinateurs.  Par conséquent, une interface de base a été écrite pour fournir un mécanisme de gestion pour les coordinateurs générés: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> childCoordinators = [<span class="hljs-type"><span class="hljs-type">Coordinator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } func remove(dependency coordinator: Coordinator) { // ... } }</span></span></code> </pre> <br>  L'un des avantages implicites des coordinateurs est l'encapsulation des connaissances sur des sous-classes spécifiques de l' <code>UIViewController</code> .  Pour assurer l'interaction du routeur et des coordinateurs, nous avons introduit l'interface suivante: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presented</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> }</code> </pre> <br>  Ensuite, chaque coordinateur spécifique devrait hériter du <code>Coordinator</code> et implémenter l'interface <code>Presentable</code> , et l'interface du routeur devrait prendre la forme suivante: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> module: Presentable, animated: Bool)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dismissModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animated: Bool, completion: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> module: Presentable, animated: Bool, completion: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animated: Bool)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAsRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> module: Presentable)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popToRootModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animated: Bool)</span></span></span></span> }</code> </pre> <br>  (L'approche avec <code>Presentable</code> vous permet également d'utiliser des coordinateurs à l'intérieur de modules écrits pour interagir directement avec les instances de <code>UIViewController</code> , sans les soumettre (modules) à un traitement radical.) <br><br>  Un bref exemple de tout cela en action: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presented</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presented</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nc = <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">RouterImpl</span></span>(navigationController: nc) <span class="hljs-comment"><span class="hljs-comment">// Router implementation. router.setAsRoot(FirstCoordinator()) router.push(SecondCoordinator(), animated: true, completion: nil) router.popToRootModule(animated: true)</span></span></code> </pre> <br><h2>  Prochaine approximation </h2><br>  Et puis, un jour, le moment est venu de modifier totalement la navigation et la liberté d'expression absolue!  Le moment où rien ne nous a empêché d'essayer d'implémenter la navigation sur les coordinateurs en utilisant la méthode convoitée <code>start()</code> - une version qui captivait à l'origine par sa simplicité et sa concision. <br><br>  Les fonctionnalités de <code>Coordinator</code> mentionnées ci-dessus ne seront évidemment pas superflues.  Mais la même méthode doit être ajoutée à l'interface générale: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> childCoordinators = [<span class="hljs-type"><span class="hljs-type">Coordinator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } func remove(dependency coordinator: Coordinator) { // ... } func start() { } }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Swift"</a> n'offre pas la possibilité de déclarer des classes abstraites (car il est plus orienté vers une approche orientée protocole que vers une approche plus classique, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">orientée objet</a> ), donc la méthode <code>start()</code> peut être laissée avec une implémentation ou une poussée vide il quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>fatalError(_:file:line:)</code></a> (forçant à remplacer cette méthode par les héritiers).  Personnellement, je préfère la première option. <br><br>  Mais Swift a une excellente occasion d'ajouter des méthodes d'implémentation par défaut aux méthodes de protocole, donc la première pensée, bien sûr, n'était pas de déclarer une classe de base, mais de faire quelque chose comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } func remove(dependency coordinator: Coordinator) { // ... } }</span></span></code> </pre> <br>  Mais les extensions de protocole ne peuvent pas déclarer de champs stockés, et les implémentations de ces deux méthodes doivent évidemment être basées sur une propriété de type stockée privée. <br><br>  La base de tout coordinateur particulier ressemblera à ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseCoordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Toutes les dépendances nécessaires au fonctionnement du coordinateur peuvent être ajoutées à l'initialiseur.  Comme cas typique, une instance de <code>UINavigationController</code> . <br><br>  S'il s'agit du coordinateur racine dont la responsabilité est de mapper le <code>UIViewController</code> racine, le coordinateur peut, par exemple, accepter une nouvelle instance du <code>UINavigationController</code> avec une pile vide. <br><br>  Lors du traitement des événements (plus à ce sujet plus tard), le coordinateur peut transmettre ce <code>UINavigationController</code> plus loin aux autres coordinateurs qu'il génère.  Et ils peuvent également faire avec l'état actuel de la navigation ce dont ils ont besoin: «pousser», «présenter», et au moins remplacer la pile de navigation entière. <br><br><h3>  Améliorations possibles de l'interface </h3><br>  Comme il s'est avéré plus tard, tous les coordinateurs ne généreront pas d'autres coordinateurs, donc tous ne devraient pas dépendre d'une telle classe de base.  Par conséquent, l'un des collègues de l'équipe connexe a suggéré de se débarrasser de l'héritage et d'introduire l'interface du gestionnaire de dépendances en tant que dépendance externe: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoordinatorDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultCoordinatorDependencies</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoordinatorDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dependencies = [<span class="hljs-type"><span class="hljs-type">Coordinator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency coordinator: Coordinator)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } func remove(dependency coordinator: Coordinator) { // ... } } final class SomeCoordinator: Coordinator { private let dependencies: CoordinatorDependencies init(dependenciesManager: CoordinatorDependencies = DefaultCoordinatorDependencies()) { dependencies = dependenciesManager } func start() { // ... } }</span></span></code> </pre> <br><h3>  Gestion des événements générés par l'utilisateur </h3><br>  Eh bien, le coordinateur a créé et lancé une nouvelle cartographie.  Très probablement, l'utilisateur regarde l'écran et voit un certain ensemble d'éléments visuels avec lesquels il peut interagir: boutons, champs de texte, etc. Certains d'entre eux provoquent des événements de navigation, et ils doivent être contrôlés par le coordinateur qui a généré ce contrôleur.  Pour résoudre ce problème, nous utilisons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">délégation</a> traditionnelle. <br><br>  Supposons qu'il existe une sous-classe de <code>UIViewController</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Et le coordinateur qui l'ajoute à la pile: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dependencies: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, dependenciesManager: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> = <span class="hljs-type"><span class="hljs-type">DefaultCoordinatorDependencies</span></span>()) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController = navigationController dependencies = dependenciesManager } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">SomeViewController</span></span>() navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br>  Nous déléguons le traitement des événements de contrôleur correspondants au même coordinateur.  Ici, en fait, le schéma classique est utilisé: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewControllerRoute</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSomeEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> route: <span class="hljs-type"><span class="hljs-type">SomeViewControllerRoute?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(route: <span class="hljs-type"><span class="hljs-type">SomeViewControllerRoute</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.route = route <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { route?.onSomeEvent() } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dependencies: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, dependenciesManager: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> = <span class="hljs-type"><span class="hljs-type">DefaultCoordinatorDependencies</span></span>()) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController = navigationController dependencies = dependenciesManager } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">SomeViewController</span></span>(route: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewControllerRoute</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSomeEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><h3>  Manipulation du bouton de retour </h3><br>  Un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon examen du modèle architectural discuté a été publié par Paul Hudson sur son site Web «Hacking with Swift»,</a> on pourrait même dire un guide.  Il contient également une explication simple et directe de l'une de leurs solutions possibles au problème du bouton de retour susmentionné: le coordinateur (si nécessaire) se déclare délégué de l'instance <code>UINavigationController</code> qui lui a été transmise et surveille l'événement qui nous intéresse. <br><br>  Cette approche présente un petit inconvénient: seul le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>NSObject</code></a> peut être un délégué <code>UINavigationController</code> . <br><br>  Donc, il y a un coordinateur qui engendre un autre coordinateur.  Cet autre, en appelant <code>start()</code> ajoute une sorte de <code>UIViewController</code> à la pile <code>UINavigationController</code> .  En cliquant sur le bouton de retour sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UINavigationBar</code></a> tout ce que vous avez à faire est de faire savoir au coordinateur d'origine que le coordinateur généré a terminé son travail («flux»).  Pour ce faire, nous avons introduit un autre outil de délégation: un délégué est alloué à chaque coordinateur généré, dont l'interface est implémentée par le coordinateur générateur: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoordinatorFlowListener</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFlowFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coordinator: Coordinator)</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dependencies: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(navigationController: <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, dependenciesManager: <span class="hljs-type"><span class="hljs-type">CoordinatorDependencies</span></span> = <span class="hljs-type"><span class="hljs-type">DefaultCoordinatorDependencies</span></span>()) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController = navigationController dependencies = dependenciesManager <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someCoordinator = <span class="hljs-type"><span class="hljs-type">SomeCoordinator</span></span>(navigationController: navigationController, flowListener: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) dependencies.add(someCoordinator) someCoordinator.start() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoordinatorFlowListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFlowFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coordinator: Coordinator)</span></span></span></span> { dependencies.remove(coordinator) <span class="hljs-comment"><span class="hljs-comment">// ... } } final class SomeCoordinator: NSObject, Coordinator { private weak var flowListener: CoordinatorFlowListener? private weak var navigationController: UINavigationController? init(navigationController: UINavigationController, flowListener: CoordinatorFlowListener) { self.navigationController = navigationController self.flowListener = flowListener } func start() { // ... } } extension SomeCoordinator: UINavigationControllerDelegate { func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) { guard let fromVC = navigationController.transitionCoordinator?.viewController(forKey: .from) else { return } if navigationController.viewControllers.contains(fromVC) { return } if fromVC is SomeViewController { flowListener?.onFlowFinished(coordinator: self) } } }</span></span></code> </pre> <br>  Dans l'exemple ci-dessus, le <code>MainCoordinator</code> ne fait rien: il lance simplement le flux d'un autre coordinateur - dans la vraie vie, bien sûr, il est inutile.  Dans notre application, le <code>MainCoordinator</code> reçoit des données de l'extérieur, selon lesquelles il détermine l'état dans lequel l'application est - autorisée, non autorisée, etc.  - et quel écran doit être affiché.  En fonction de cela, il lance un flux du coordinateur correspondant.  Si le coordinateur d'origine a terminé son travail, le coordinateur principal reçoit un signal à ce sujet via le <code>CoordinatorFlowListener</code> et, par exemple, lance le flux d'un autre coordinateur. <br><br><h2>  Conclusion </h2><br>  Bien entendu, la solution habituelle présente un certain nombre d'inconvénients (comme toute solution à tout problème). <br><br>  Oui, vous devez utiliser beaucoup de délégation, mais c'est simple et a une seule direction: du généré au généré (du contrôleur au coordinateur, du coordinateur généré au généré). <br><br>  Oui, pour échapper aux fuites de mémoire, vous devez ajouter une méthode déléguée <code>UINavigationController</code> avec une implémentation presque identique à chaque coordinateur.  (La première approche n'a pas cet inconvénient, mais partage plutôt plus généreusement ses connaissances internes sur la nomination d'un coordinateur spécifique.) <br><br>  Mais le plus gros inconvénient de cette approche est que, dans la vraie vie, les coordinateurs, malheureusement, en savent un peu plus sur le monde qui les entoure que nous ne le souhaiterions.  Plus précisément, ils devront ajouter des éléments logiques qui dépendent des conditions externes, dont le coordinateur n'a pas directement connaissance.  Fondamentalement, c'est en fait ce qui se passe lorsque la méthode <code>start()</code> est <code>onFlowFinished(coordinator:)</code> ou que le <code>onFlowFinished(coordinator:)</code> est <code>onFlowFinished(coordinator:)</code> .  Et tout peut arriver à ces endroits, et ce sera toujours un comportement "codé en dur": ajouter un contrôleur à la pile, remplacer la pile, retourner au contrôleur racine - peu importe.  Et tout cela ne dépend pas des compétences du contrôleur actuel, mais des conditions externes. <br><br>  Néanmoins, le code est «joli» et concis, il est vraiment agréable de travailler avec lui et la navigation dans le code est beaucoup plus facile.  Il nous a semblé qu'avec les lacunes mentionnées, en étant conscients, il est tout à fait possible d'exister. <br><blockquote>  Merci d'avoir lu cet endroit!  J'espère qu'ils ont appris quelque chose d'utile pour eux-mêmes.  Et si vous voulez tout à coup "plus que moi", voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers mon Twitter</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444038/">https://habr.com/ru/post/fr444038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444028/index.html">Présentation de Microsoft Game Stack</a></li>
<li><a href="../fr444030/index.html">Le détaillant en ligne chinois Gearbest a laissé ouverte une base de données contenant des millions de données personnelles sur les clients</a></li>
<li><a href="../fr444032/index.html">Pourquoi une imprimante 3D n'est pas une imprimante</a></li>
<li><a href="../fr444034/index.html">7 péchés capitaux d'un manager</a></li>
<li><a href="../fr444036/index.html">Accélérer les E / S des fichiers C / C ++ sans vraiment forcer</a></li>
<li><a href="../fr444040/index.html">Classement autocentrique. Rapport Yandex sur la recherche d'audiences pertinentes pour les auteurs zen</a></li>
<li><a href="../fr444044/index.html">L'Europe va recycler le fer du centre de données</a></li>
<li><a href="../fr444048/index.html">Trucs et astuces de Digital Forensics: comment détecter les modifications de stratégie de groupe induites par un intrus</a></li>
<li><a href="../fr444050/index.html">Discussion: le stockage d'ADN deviendra-t-il massif</a></li>
<li><a href="../fr444052/index.html">Comment nous à IntelliJ IDEA recherchons les expressions lambda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>