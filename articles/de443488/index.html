<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèΩ ‚û∞ üèùÔ∏è Funktionskomponenten mit React Hooks. Warum sind sie besser? üë®üèª üìä üö£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor relativ kurzer Zeit wurde React.js Version 16.8 ver√∂ffentlicht, mit der uns Hooks zur Verf√ºgung standen. Das Konzept der Hooks erm√∂glicht es Ihnen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionskomponenten mit React Hooks. Warum sind sie besser?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443488/"><p>  Vor relativ kurzer Zeit wurde React.js Version 16.8 ver√∂ffentlicht, mit der uns Hooks zur Verf√ºgung standen.  Das Konzept der Hooks erm√∂glicht es Ihnen, vollwertige Funktionskomponenten mit allen Funktionen von React zu schreiben, und dies auf viele Arten bequemer als mit Klassen. </p><br><p>  Viele haben das Auftreten von Haken mit Kritik wahrgenommen, und in diesem Artikel m√∂chte ich √ºber einige wichtige Vorteile sprechen, die funktionale Komponenten mit Haken uns bieten, und warum wir zu ihnen wechseln sollten. </p><br><p>  Ich werde nicht absichtlich auf die Details der Verwendung von Haken eingehen.  Dies ist nicht sehr wichtig f√ºr das Verst√§ndnis der Beispiele in diesem Artikel. Ein ziemlich allgemeines Verst√§ndnis der Arbeit von React ist ausreichend.  Wenn Sie genau zu diesem Thema lesen m√∂chten, finden Sie Informationen zu Hooks in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . Wenn dieses Thema interessant ist, werde ich einen Artikel ausf√ºhrlicher dar√ºber schreiben, wann, welche und wie Hooks richtig verwendet werden. </p><a name="habracut"></a><br><h2 id="huki-delayut-pereispolzovanie-koda-udobnee">  Hooks erleichtern die Wiederverwendung von Code </h2><br><p>  Stellen wir uns eine Komponente vor, die eine einfache Form wiedergibt.  Etwas, das einfach ein paar Eingaben ausgibt und es uns erm√∂glicht, sie zu bearbeiten. </p><br><p>  So etwas w√ºrde, wenn es stark vereinfacht w√§re, wie eine Klasse aussehen: </p><br><pre><code class="plaintext hljs">class Form extends React.Component { state = { //   fields: {}, }; render() { return ( &lt;form&gt; {/*    */} &lt;/form&gt; ); }; }</code> </pre> <br><p>  Stellen Sie sich nun vor, wir m√∂chten Feldwerte automatisch speichern, wenn sie sich √§ndern.  Ich schlage vor, Deklarationen zus√§tzlicher Funktionen wie <code>shallowEqual</code> und <code>debounce</code> . </p><br><pre> <code class="plaintext hljs">class Form extends React.Component { constructor(props) { super(props); this.saveToDraft = debounce(500, this.saveToDraft); }; state = { //   fields: {}, // ,       draft: { isSaving: false, lastSaved: null, }, }; saveToDraft = (data) =&gt; { if (this.state.isSaving) { return; } this.setState({ isSaving: true, }); makeSomeAPICall().then(() =&gt; { this.setState({ isSaving: false, lastSaved: new Date(), }) }); } componentDidUpdate(prevProps, prevState) { if (!shallowEqual(prevState.fields, this.state.fields)) { this.saveToDraft(this.state.fields); } } render() { return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }; }</code> </pre> <br><p>  Gleiches Beispiel, aber mit Haken: </p><br><pre> <code class="plaintext hljs">const Form = () =&gt; { //     const [fields, setFields] = useState({}); const [draftIsSaving, setDraftIsSaving] = useState(false); const [draftLastSaved, setDraftLastSaved] = useState(false); useEffect(() =&gt; { const id = setTimeout(() =&gt; { if (draftIsSaving) { return; } setDraftIsSaving(true); makeSomeAPICall().then(() =&gt; { setDraftIsSaving(false); setDraftLastSaved(new Date()); }); }, 500); return () =&gt; clearTimeout(id); }, [fields]); return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }</code> </pre> <br><p>  Wie wir sehen, ist der Unterschied noch nicht sehr gro√ü.  Wir haben den <code>useState</code> Hook ge√§ndert und das Speichern nicht in <code>componentDidUpdate</code> , sondern nach dem Rendern der Komponente mit dem <code>useEffect</code> Hook erstellt. </p><br><p>  Der Unterschied, den ich hier zeigen m√∂chte (es gibt andere, die wir unten diskutieren werden): Wir k√∂nnen diesen Code herausholen und an einer anderen Stelle verwenden: </p><br><pre> <code class="plaintext hljs">//  useDraft       const useDraft = (fields) =&gt; { const [draftIsSaving, setDraftIsSaving] = useState(false); const [draftLastSaved, setDraftLastSaved] = useState(false); useEffect(() =&gt; { const id = setTimeout(() =&gt; { if (draftIsSaving) { return; } setDraftIsSaving(true); makeSomeAPICall().then(() =&gt; { setDraftIsSaving(false); setDraftLastSaved(new Date()); }); }, 500); return () =&gt; clearTimeout(id); }, [fields]); return [draftIsSaving, draftLastSaved]; } const Form = () =&gt; { //     const [fields, setFields] = useState({}); const [draftIsSaving, draftLastSaved] = useDraft(fields); return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }</code> </pre> <br><p>  Jetzt k√∂nnen wir den <code>useDraft</code> Hook verwenden, den wir gerade in anderen Komponenten geschrieben haben!  Dies ist nat√ºrlich ein sehr vereinfachtes Beispiel, aber die Wiederverwendung derselben Funktionalit√§t ist eine sehr n√ºtzliche Funktion. </p><br><h2 id="huki-pozvolyayut-pisat-bolee-intuitivno-ponyatnyy-kod">  Mit Hooks k√∂nnen Sie intuitiveren Code schreiben. </h2><br><p>  Stellen Sie sich eine Komponente vor (vorerst in Form einer Klasse), die beispielsweise das aktuelle Chatfenster, eine Liste m√∂glicher Empf√§nger und ein Formular zum Senden einer Nachricht anzeigt.  So etwas wie das: </p><br><pre> <code class="plaintext hljs">class ChatApp extends React.Component { state = { currentChat: null, }; handleSubmit = (messageData) =&gt; { makeSomeAPICall(SEND_URL, messageData) .then(() =&gt; { alert(`   ${this.state.currentChat} `); }); }; render() { return ( &lt;Fragment&gt; &lt;ChatsList changeChat={currentChat =&gt; { this.setState({ currentChat }); }} /&gt; &lt;CurrentChat id={currentChat} /&gt; &lt;MessageForm onSubmit={this.handleSubmit} /&gt; &lt;/Fragment&gt; ); }; }</code> </pre> <br><p>  Das Beispiel ist sehr bedingt, eignet sich jedoch gut zur Demonstration.  Stellen Sie sich diese Benutzeraktionen vor: </p><br><ul><li>  Chat √∂ffnen 1 </li><li>  Senden Sie eine Nachricht (stellen Sie sich vor, dass die Anfrage lange dauert) </li><li>  Chat √∂ffnen 2 </li><li>  Nachricht √ºber erfolgreiches Senden erhalten: <br><ul><li>  "Chat-Nachricht gesendet 2" </li></ul></li></ul><br><p>  Aber die Nachricht wurde an Chat 1 gesendet?  Dies geschah aufgrund der Tatsache, dass die Klassenmethode nicht mit dem Wert zum Zeitpunkt des Sendens funktionierte, sondern mit dem Wert, der zum Zeitpunkt des Abschlusses der Anforderung bereits vorhanden war.  Dies w√§re in einem so einfachen Fall kein Problem, aber die Korrektur eines solchen Verhaltens erfordert in erster Linie zus√§tzliche Sorgfalt und zus√§tzliche Verarbeitung, und zweitens kann es eine Fehlerquelle sein. </p><br><p>  Bei einer Funktionskomponente ist das Verhalten anders: </p><br><pre> <code class="plaintext hljs">const ChatApp = () =&gt; { const [currentChat, setCurrentChat] = useState(null); const handleSubmit = useCallback( (messageData) =&gt; { makeSomeAPICall(SEND_URL, messageData) .then(() =&gt; { alert(`   ${currentChat} `); }); }, [currentChat] ); render() { return ( &lt;Fragment&gt; &lt;ChatsList changeChat={setCurrentChat} /&gt; &lt;CurrentChat id={currentChat} /&gt; &lt;MessageForm onSubmit={handleSubmit} /&gt; &lt;/Fragment&gt; ); }; }</code> </pre> <br><p>  Stellen Sie sich dieselben Benutzeraktionen vor: </p><br><ul><li>  Chat √∂ffnen 1 </li><li>  Senden Sie eine Nachricht (die Anfrage wird erneut ausgef√ºhrt) </li><li>  Chat √∂ffnen 2 </li><li>  Nachricht √ºber erfolgreiches Senden erhalten: <br><ul><li>  "Chat-Nachricht gesendet 1" </li></ul></li></ul><br><p>  Was hat sich also ge√§ndert?  Was sich ge√§ndert hat, ist, dass wir jetzt f√ºr jedes Rendering, f√ºr das <code>currentChat</code> anders ist, eine neue Methode erstellen.  So k√∂nnen wir √ºberhaupt nicht dar√ºber nachdenken, ob sich in Zukunft etwas √§ndern wird - wir arbeiten mit dem, was wir <strong>jetzt haben</strong> .  <em>Jede Renderkomponente schlie√üt in sich alles, was sich darauf bezieht</em> . </p><br><h2 id="huki-izbavlyayut-nas-ot-zhiznennogo-cikla">  Haken retten uns vor dem Lebenszyklus </h2><br><p>  Dieser Punkt √ºberschneidet sich mit dem vorherigen.  React ist eine Bibliothek zur deklarativen Beschreibung einer Schnittstelle.  Die Deklarierbarkeit erleichtert das Schreiben und Unterst√ºtzen von Komponenten erheblich und erm√∂glicht es Ihnen, weniger dar√ºber nachzudenken, was unbedingt getan werden m√ºsste, wenn wir React nicht verwendet h√§tten. </p><br><p>  Trotzdem sind wir bei der Verwendung von Klassen mit dem Lebenszyklus von Komponenten konfrontiert.  Wenn Sie nicht tiefer gehen, sieht es so aus: </p><br><ul><li>  Komponentenmontage </li><li>  Komponentenaktualisierung (beim √Ñndern des <code>state</code> oder der <code>props</code> ) </li><li>  Entfernen von Komponenten </li></ul><br><p>  Es scheint bequem, aber ich bin √ºberzeugt, dass es nur aus Gewohnheit bequem ist.  Dieser Ansatz ist nicht wie Reagieren. </p><br><p>  Stattdessen k√∂nnen wir mit funktionalen Komponenten mit Hooks Komponenten schreiben, wobei wir nicht an den Lebenszyklus, sondern an die <em>Synchronisation</em> denken.  Wir schreiben die Funktion so, dass ihr Ergebnis den Zustand der Schnittstelle in Abh√§ngigkeit von den externen Parametern und dem internen Zustand eindeutig widerspiegelt. </p><br><p>  Der <code>useEffect</code> , den viele als direkten Ersatz f√ºr <code>componentDidMount</code> , <code>componentDidUpdate</code> usw. betrachten, ist eigentlich f√ºr einen anderen bestimmt.  Wenn wir es verwenden, sagen wir die Reaktion: "Nachdem Sie dies gerendert haben, f√ºhren Sie bitte diese Effekte aus." </p><br><p>  Hier ist ein gutes Beispiel daf√ºr, wie die Komponente mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klickz√§hler</a> aus einem gro√üen Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">useEffect funktioniert</a> : </p><br><ul><li>  <strong>Reaktion:</strong> Sagen Sie mir, was ich mit diesem Status rendern soll. </li><li>  <strong>Ihre Komponente:</strong> <br><ul><li>  Hier ist das Renderergebnis: <code>&lt;p&gt;  0 &lt;/p&gt;</code> . </li><li>  F√ºhren Sie diesen Effekt aus, wenn Sie fertig sind: <code>() =&gt; { document.title = '  0 ' }</code> . </li></ul></li><li>  <strong>Reaktion:</strong> Okay.  Aktualisieren der Schnittstelle.  Hey, Browser, ich aktualisiere das DOM </li><li>  <strong>Browser:</strong> Gro√üartig, ich habe gezeichnet. </li><li>  <strong>Reaktion:</strong> Super, jetzt rufe ich den Effekt auf, den ich von der Komponente erhalten habe. <br><ul><li>  Es beginnt <code>() =&gt; { document.title = '  0 ' }</code> </li></ul></li></ul><br><p>  Viel aussagekr√§ftiger, nicht wahr? </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>  Mit React Hooks k√∂nnen wir einige Probleme beseitigen und das Verst√§ndnis und die Codierung von Komponenten erleichtern.  Sie m√ºssen nur das mentale Modell √§ndern, das wir auf sie anwenden.  Funktionskomponenten sind im Wesentlichen Schnittstellenfunktionen von Parametern.  Sie beschreiben alles so, wie es zu einem bestimmten Zeitpunkt sein sollte, und helfen dabei, nicht dar√ºber nachzudenken, wie auf √Ñnderungen reagiert werden soll. </p><br><p>  Ja, manchmal m√ºssen Sie lernen, wie man sie <em>richtig verwendet</em> , aber auf die gleiche Weise haben wir nicht sofort gelernt, wie man Komponenten in Form von Klassen verwendet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443488/">https://habr.com/ru/post/de443488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443478/index.html">Synthetische und reale Testdaten: Vor- und Nachteile, Fallstricke</a></li>
<li><a href="../de443480/index.html">Kryptografische Token von PKCS # 11: Anzeigen und Exportieren von Zertifikaten, √úberpr√ºfen ihrer G√ºltigkeit</a></li>
<li><a href="../de443482/index.html">AIOps in der Praxis - was kann Huawei FabricInsight</a></li>
<li><a href="../de443484/index.html">6 unerwartete M√§nner von Julia</a></li>
<li><a href="../de443486/index.html">ReLEx SMILE: Wie man keine Fehler in Prognosen macht</a></li>
<li><a href="../de443492/index.html">Ein Spiel f√ºr Liebhaber und Experten unter Linux</a></li>
<li><a href="../de443494/index.html">Anleitung: Starten des SaaS-Produkts unter AppSumo - Erfolge und einige Fehler</a></li>
<li><a href="../de443498/index.html">Flightradar24 - wie geht das? Teil 2, ADS-B-Protokoll</a></li>
<li><a href="../de443500/index.html">Funktionskomponenten mit React Hooks. Warum ist es besser?</a></li>
<li><a href="../de443502/index.html">Warum genau vor 4 Jahren hat die NASA mit der Atlas V-Rakete den Nachthimmel von Cape Canaveral abgeschossen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>