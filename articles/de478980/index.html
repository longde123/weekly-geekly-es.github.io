<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ ‚óºÔ∏è ü§¶üèø Azure SDK f√ºr .NET: Die Geschichte eines schwierigen Fehlersuchers üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üòû üö∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als wir uns entschieden, nach Fehlern im Azure SDK f√ºr .NET-Projekt zu suchen, waren wir angenehm √ºberrascht von seiner Gr√∂√üe. "Dreieinhalb Millionen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Azure SDK f√ºr .NET: Die Geschichte eines schwierigen Fehlersuchers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/478980/"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/893/6e4/1d18936e4455beb69c69b410bbfd10f6.png" alt="Bild 2" align="left"></p>  Als wir uns entschieden, nach Fehlern im Azure SDK f√ºr .NET-Projekt zu suchen, waren wir angenehm √ºberrascht von seiner Gr√∂√üe.  "Dreieinhalb Millionen Codezeilen", sagten wir und studierten die Statistiken des Projekts.  So viel kannst du dort finden.  Aber leider, ah.  Das Projekt erwies sich als geheim.  Was ist die Besonderheit des Projekts und wie es getestet wurde - lesen Sie diesen Artikel. <br><a name="habracut"></a><br><h2>  √úber das Projekt </h2><br>  Ich schreibe diesen Artikel in einer Fortsetzung meines vorherigen Artikels, in dem es auch um ein Projekt im Zusammenhang mit Microsoft Azure ging: <a href="https://www.viva64.com/ru/b/0678/">Azure PowerShell: "Im Grunde genommen harmlos".</a>  Diesmal rechnete ich also mit einer soliden Anzahl von abwechslungsreichen und interessanten Fehlern.  In der Tat ist f√ºr eine statische Analyse in der Regel die Gr√∂√üe des Projekts wichtig, insbesondere bei einmaligen √úberpr√ºfungen des gesamten Projekts.  Ja, in der Praxis machen sie das normalerweise nicht.  Und wenn doch, dann erst in der Phase der Implementierung des Analysators.  Gleichzeitig versteht niemand sofort die gro√üe Anzahl von Vorg√§ngen (eine betr√§chtliche Anzahl von Warnungen ist die Norm, wenn der Analysator in diesem Modus startet), sondern verschuldet sie einfach mit Hilfe von Nachrichtenunterdr√ºckungsmechanismen und deren Speicherung in speziellen Datenbanken (Massenunterdr√ºckung).  Wir f√ºhren einmalige Inspektionen zu Forschungszwecken durch.  Daher sind gro√üe Studienprojekte immer kleinen vorzuziehen. <br><br>  Das Azure SDK f√ºr .NET-Projekt zeigte jedoch sofort, dass es als Testumgebung fehlgeschlagen ist.  Auch seine beeindruckende Gr√∂√üe hat nicht geholfen, sondern die Arbeit sogar kompliziert.  Der Grund ist in der folgenden Projektstatistik angegeben: <br><br><ul><li>  Quelldateien .cs (ohne Tests): 16.500 </li><li>  Visual Studio-L√∂sungen (.sln): 163 </li><li>  Nicht leere Codezeilen: 3.462.000 </li><li>  Davon automatisch generiert: rund 3,3 Millionen </li><li>  Das Projekt-Repository ist auf <a href="https://github.com/Azure/azure-sdk-for-net">GitHub</a> verf√ºgbar. </li></ul><br>  Etwa 95% des Codes werden automatisch generiert, ein wesentlicher Teil dieses Codes wird mehrmals wiederholt.  Das √úberpr√ºfen solcher Projekte mit einem statischen Analysator ist normalerweise zeitaufw√§ndig und nutzlos, da viel gearbeitet wird, aber unlogischer (auf den ersten Blick) und redundanter Code.  Dies f√ºhrt zu einer Vielzahl von Fehlalarmen. <br><br>  Eine gro√üe Anzahl von Visual Studio-L√∂sungen (163) wurden als Kirschen auf dem Kuchen verwendet, wonach diese Codemasse "verschmiert" wurde.  Um den verbleibenden Code zu √ºberpr√ºfen (nicht automatisch generiert), musste ich einige Anstrengungen unternehmen.  Es hat geholfen, dass sich der gesamte automatisch generierte Code in den L√∂sungsunterordnern entlang des relativen Pfads "&lt;L√∂sungsordner&gt; \ src \ Generated" befindet.  Au√üerdem enth√§lt jede .cs-Datei eines solchen Codes einen speziellen Kommentar im <i>&lt;auto-generated&gt; -Tag</i> : <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;auto-generated&gt; // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See License.txt in the project root for // license information. // // Code generated by Microsoft (R) AutoRest Code Generator. // Changes may cause incorrect behavior and will be lost if the code is // regenerated. // &lt;/auto-generated&gt;</span></span></code> </pre> <br>  F√ºr die Reinheit des Experiments √ºberpr√ºfte ich zuf√§llig ungef√§hr zehn zuf√§llig ausgew√§hlte L√∂sungen mit automatisch erzeugtem Code.  Die Ergebnisse werden niedriger sein. <br><br>  Trotz der geringen Menge des verbleibenden "ehrlichen" Codes konnte ich dort dennoch eine bestimmte Anzahl von Fehlern finden.  Dieses Mal werde ich keine Ausl√∂sungen in der Reihenfolge der Nummern der PVS-Studio-Diagnose geben.  Stattdessen werde ich die Antworten nach den L√∂sungen gruppieren, in denen sie erkannt wurden. <br><br>  Mal sehen, was ich im Azure SDK f√ºr .NET-Code gefunden habe. <br><br><h2>  Microsoft.Azure.Management.Advisor </h2><br>  Dies ist nur eine von vielen L√∂sungen, die automatisch generierten Code enthalten.  Wie ich oben sagte, wurden ungef√§hr ein Dutzend solcher L√∂sungen selektiv getestet.  Und √ºberall waren die Nachrichten gleich und erwartungsgem√§√ü nutzlos.  Lassen Sie mich einige Beispiele f√ºr solche Antworten nennen. <br><br>  <a href="https://www.viva64.com/ru/w/v3022/">V3022 Der</a> Ausdruck 'Credentials! = Null' ist immer wahr.  AdvisorManagementClient.cs 204 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public ServiceClientCredentials Credentials { get; private set; } .... public AdvisorManagementClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers) { if (credentials == null) { throw new System.ArgumentNullException("credentials"); } Credentials = credentials; if (Credentials != null) // &lt;= { Credentials.InitializeServiceClient(this); } }</span></span></code> </pre> <br>  Offensichtlich ist der Code redundant und die √úberpr√ºfung der <i>Berechtigungsnachweise! = Null ist</i> nutzlos.  Aber der Code funktioniert.  Und automatisch generiert.  Daher - keine Beschwerden. <br><br>  <a href="https://www.viva64.com/ru/w/v3022/">V3022 Der</a> Ausdruck '_queryParameters.Count&gt; 0' ist immer falsch.  ConfigurationsOperations.cs 871 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public async Task&lt;AzureOperationResponse&lt;IPage&lt;ConfigData&gt;&gt;&gt; ListBySubscriptionNextWithHttpMessagesAsync(....) { .... List&lt;string&gt; _queryParameters = new List&lt;string&gt;(); if (_queryParameters.Count &gt; 0) { .... } .... }</span></span></code> </pre> <br>  Und wieder ein scheinbar logikloses Design.  Aus irgendeinem Grund √ºberpr√ºfen sie die Gr√∂√üe der gerade erstellten <i>leeren</i> Liste.  In der Tat - alles ist in Ordnung.  Diese Pr√ºfung ist jetzt sinnlos, aber wenn der Generator die Erstellung einer Liste z. B. auf der Grundlage einer anderen Sammlung aufbaut, ist die Pr√ºfung bereits sinnvoll.  Auch hier gibt es nat√ºrlich keine Beschwerden gegen den Code, da er seinen Ursprung hat. <br><br>  F√ºr jede L√∂sung mit automatisch generiertem Code wurden Hunderte √§hnlicher Warnungen empfangen.  In Anbetracht ihrer Sinnlosigkeit halte ich eine weitere Er√∂rterung derartiger positiver Aspekte f√ºr sinnlos.  Im Folgenden werden nur echte Fehler im ‚Äûnormalen‚Äú Code ber√ºcksichtigt. <br><br><h2>  Azure.Core </h2><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a> Es gibt identische Unterausdr√ºcke 'buffer.Length' links und rechts vom Operator '&lt;'.  AzureBaseBuffersExtensions.cs 30 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...., ReadOnlyMemory&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]? array = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || buffer.Length &lt; buffer.Length) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (array != null) ArrayPool&lt;byte&gt;.Shared.Return(array); array = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length); } if (!buffer.TryCopyTo(array)) throw new Exception("could not rent large enough buffer."); .... }</span></span></code> </pre> <br>  Es wurde ein Fehler in der Bedingung gemacht, wahrscheinlich aufgrund der Verwendung von Copy-Paste.  Gemessen an der Tatsache, dass weiter im Codepuffer in das <i>Array</i> kopiert <i>wird</i> , sollte die Pr√ºfung wie <i>folgt</i> aussehen: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || array.Length &lt; buffer.Length)</code> </pre> <br>  Aber, wie ich immer sage, sollte der Autor des Codes solche Fehler beheben. <br><br>  <a href="https://www.viva64.com/ru/w/v3083/">V3083</a> Unsicherer Aufruf des Ereignisses '_onChange', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  ClientOptionsMonitor.cs 44 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TOptions, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _onChange; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_onChange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _onChange.Invoke(options, name); } }</code> </pre> <br>  Unkritisch, aber ein Fehler.  Zwischen der √úberpr√ºfung des Ereignisses auf <i>Null</i> und seinem Aufruf kann das Ereignis abgemeldet werden.  Dann wird die Variable <i>_onChange</i> auf <i>null gesetzt</i> und eine Ausnahme ausgel√∂st.  Code muss sicherer umgeschrieben werden.  Zum Beispiel so: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... _onChange?.Invoke(options, name); }</code> </pre> <br><h2>  Azure.Messaging.EventHubs </h2><br>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'eventPropertyValue' an.  AmqpMessageConverter.cs 650 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryCreateEventPropertyForAmqpProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amqpPropertyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventPropertyValue</span></span></span><span class="hljs-function">)</span></span> { eventPropertyValue = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetTypeIdentifier(amqpPropertyValue)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.Byte: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.String: eventPropertyValue = amqpPropertyValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (amqpPropertyValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpSymbol symbol: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment when segment.Count == segment.Array.Length: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment: .... eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> DescribedType described </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">described.Descriptor </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AmqpSymbol</span></span></span><span class="hljs-function">): eventPropertyValue</span></span> = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(...., eventPropertyValue.GetType().FullName)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return (eventPropertyValue != null); }</span></span></code> </pre> <br>  Verfolgen wir, was mit dem Wert der Variablen <i>eventPropertyValue</i> im obigen <i>Codeausschnitt</i> geschieht.  Zu Beginn der Methode ist die Variable <i>null</i> .  Ferner wird in einer der Bedingungen des ersten <i>Schalters</i> die Variable initialisiert, wonach das Verfahren beendet wird.  Der zweite <i>Schalterblock</i> enth√§lt viele Bedingungen, in denen die Variable auch einen neuen Wert erh√§lt.  Im <i>Standardblock</i> wird die Variable <i>eventPropertyValue jedoch</i> einfach ohne √úberpr√ºfung verwendet. <i>Dies</i> ist ein Fehler, da die Variable derzeit <i>null ist</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der Argumente, die an den Konstruktor 'EventHubConsumer' √ºbergeben wurden: 'partitionId' und 'consumerGroup'.  TrackOneEventHubClient.cs 394 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> EventHubConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHubConsumer ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TrackOneEventHubConsumer(....), TrackOneClient.EventHubName, partitionId, <span class="hljs-comment"><span class="hljs-comment">// &lt;= 3 consumerGroup, // &lt;= 4 eventPosition, consumerOptions, initialRetryPolicy ); }</span></span></code> </pre> <br>  Der Analysator vermutete, dass beim Aufrufen des Konstruktors der <i>EventHubConsumer-</i> Klasse die Reihenfolge der dritten und vierten Argumente <i>vertauscht</i> wurde.  Schauen wir uns die Konstruktordeklaration an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Die Argumente sind wirklich durcheinander.  Ich vermute, wie dieser Fehler gemacht wurde.  Der Fehler ist wahrscheinlich die schlechte Formatierung des Codes.  Schauen Sie sich die <i>EventHubConsumer-</i> Konstruktordeklaration noch einmal an.  Aufgrund der Tatsache, dass sich der erste <i>transportConsumer-</i> Parameter in der gleichen Zeile wie der Klassenname befindet, scheint der <i>partitionId-</i> Parameter bei einer kurzen Betrachtung des Codes an dritter und nicht an vierter Stelle zu stehen (meine Kommentare mit den Seriennummern der Parameter sind im Originalcode nicht enthalten) ) <br><br>  Dies ist nur eine Vermutung, aber ich w√ºrde die Formatierung des Konstruktordeklarationscodes folgenderma√üen √§ndern: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br><h2>  Azure.Storage </h2><br>  <a href="https://www.viva64.com/ru/w/v3112/">V3112</a> Eine Abnormalit√§t in √§hnlichen Vergleichen.  Es ist m√∂glich, dass der Ausdruck 'ContentLanguage == other.ContentEncoding' einen Tippfehler enth√§lt.  BlobSasBuilder.cs 410 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlobSasBuilder : IEquatable&lt;BlobSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlobSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; BlobName == other.BlobName &amp;&amp; CacheControl == other.CacheControl &amp;&amp; BlobContainerName == other.BlobContainerName &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= ContentLanguage == other.ContentEncoding &amp;&amp; // &lt;= ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version; }</span></span></code> </pre> <br>  Ein Fehler, der durch Unaufmerksamkeit begangen wurde.  Einen √§hnlichen Fehler bei der Code√ºberpr√ºfung zu finden, ist ziemlich schwierig.  Die richtige Pr√ºfoption: <br><br><pre> <code class="cs hljs"> .... ContentEncoding == other.ContentEncoding &amp;&amp; ContentLanguage == other.ContentLanguage &amp;&amp; ....</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3112/">V3112</a> Eine Abnormalit√§t in √§hnlichen Vergleichen.  Es ist m√∂glich, dass der Ausdruck 'ContentLanguage == other.ContentEncoding' einen Tippfehler enth√§lt.  FileSasBuilder.cs 265 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FileSasBuilder : IEquatable&lt;FileSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; CacheControl == other.CacheControl &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding <span class="hljs-comment"><span class="hljs-comment">// &lt;= &amp;&amp; ContentLanguage == other.ContentEncoding // &lt;= &amp;&amp; ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; FilePath == other.FilePath &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; ShareName == other.ShareName &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version ;</span></span></code> </pre> <br>  Genau derselbe Fehler in einem sehr √§hnlichen Code.  Der Code wurde wahrscheinlich kopiert und teilweise ge√§ndert.  Der Fehler blieb jedoch bestehen. <br><br><h2>  Microsoft.Azure.Batch </h2><br>  <a href="https://www.viva64.com/ru/w/v3053/">V3053</a> Ein √ºberm√§√üiger Ausdruck.  Untersuchen Sie die Teilzeichenfolgen 'IList' und 'List'.  PropertyData.cs 157 <br><br>  <a href="https://www.viva64.com/ru/w/v3053/">V3053</a> Ein √ºberm√§√üiger Ausdruck.  Untersuchen Sie die Teilzeichenfolgen 'List' und 'IReadOnlyList'.  PropertyData.cs 158 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PropertyData</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsTypeCollection =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IEnumerable"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.Type.Contains("IReadOnlyList"); // &lt;= }</span></span></code> </pre> <br>  Der Analysator gab zwei Warnungen √ºber sinnlose oder fehlerhafte √úberpr√ºfungen aus.  Im ersten Fall erscheint die Suche nach der Teilzeichenfolge "Liste" nach der Suche nach "IList" redundant.  In der Tat ist die Bedingung: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  kann dadurch ersetzt werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  Im zweiten Fall ist die Suche nach dem Teilstring "IReadOnlyList" bedeutungslos, da zuvor die Suche nach dem k√ºrzeren Teilstring "List" durchgef√ºhrt wurde. <br><br>  Es besteht auch die M√∂glichkeit, dass die Teilzeichenfolgen selbst f√ºr die Suche Fehler gemacht haben und es etwas anderes geben sollte.  In jedem Fall kann die korrekte Version der Bedingungskorrektur unter Ber√ºcksichtigung beider Bemerkungen nur vom Autor des Codes angeboten werden. <br><br>  <a href="https://www.viva64.com/ru/w/v3095/">V3095</a> Das Objekt 'httpRequest.Content.Headers' wurde verwendet, bevor es gegen null verifiziert wurde.  Zeilen √ºberpr√ºfen: 76, 79. BatchSharedKeyCredential.cs 76 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... signature.Append(httpRequest.Content != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; httpRequest.Content.Headers.Contains(<span class="hljs-string"><span class="hljs-string">"Content-Language"</span></span>) ? .... : ....; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>? contentLength = httpRequest.Content?.Headers?.ContentLength; .... }</code> </pre> <br>  Zuerst wird die Variable <i>httpRequest.Content.Headers</i> ohne Pr√ºfung verwendet, aber sp√§ter im Code wird auf diese Variable mit dem Operator f√ºr bedingten Zugriff zugegriffen. <br><br>  <a href="https://www.viva64.com/ru/w/v3125/">V3125</a> Das Objekt 'omPropertyData' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 156, 148. CodeGenerationUtilities.cs 156 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProtocolCollectionToObjectModelCollectionString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ...., PropertyData omPropertyData, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMappedEnumPair(omPropertyData?.GenericTypeParameter, ....)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsTypeComplex(omPropertyData.GenericTypeParameter)) .... }</code> </pre> <br>  Die umgekehrte Situation.  Ein Codeblock enth√§lt eine sichere Zugriffsoption auf den m√∂glicherweise Null- <i>omPropertyData-</i> Link.  Weiter im Code mit dem gleichen Link funktionieren sie ohne Pr√ºfung. <br><br>  <a href="https://www.viva64.com/ru/w/v3146/">V3146</a> M√∂gliche Null-Dereferenzierung von 'Wert'.  Der 'FirstOrDefault' kann einen Standard-Nullwert zur√ºckgeben.  BatchSharedKeyCredential.cs 127 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... } .... }</code> </pre> <br>  Als Ergebnis der <i>FirstOrDefault-</i> Methode wird, wenn die Suche fehlschl√§gt, der Standardwert f√ºr den <i>Zeichenfolgentyp</i> zur√ºckgegeben, <i>dh</i> <i>null</i> .  Der Wert wird der Variablen value zugewiesen, die sp√§ter im Code mit der Methode <i>Replace</i> ohne Pr√ºfung verwendet wird.  Code sollte sicherer gemacht werden.  Zum Beispiel so: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>?.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... }</code> </pre> <br><h2>  Microsoft.Azure.ServiceBus </h2><br>  <a href="https://www.viva64.com/ru/w/v3121/">V3121</a> Eine Aufz√§hlung 'BlocksUsing' wurde mit dem Attribut 'Flags' deklariert, setzt jedoch keine Initialisierer, um Standardwerte zu √ºberschreiben.  Fx.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Fx</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tag</span></span> { .... [Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter, MonitorWait, ManualResetEvent, AutoResetEvent, AsyncResult, IAsyncResult, PInvoke, InputQueue, ThreadNeutralSemaphore, PrivatePrimitive, OtherInternalPrimitive, OtherFrameworkPrimitive, OtherInterop, Other, NonBlocking, } .... } .... }</code> </pre> <br>  Eine Aufz√§hlung wird mit dem Attribut <i>Flags</i> deklariert.  In diesem Fall bleiben die Werte der Konstanten standardm√§√üig erhalten ( <i>MonitorEnter = 0</i> , <i>MonitorWait = 1</i> , <i>ManualResetEvent = 2</i> usw.).  Dies kann dazu f√ºhren, dass beim Versuch, eine <i>Kombination von</i> Flags zu verwenden, beispielsweise die zweite und dritte Konstante <i>MonitorWait (= 1)</i> |  <i>ManualResetEvent (= 2)</i> , es wird kein eindeutiger Wert empfangen, sondern standardm√§√üig eine Konstante mit dem Wert 3 ( <i>AutoResetEvent</i> ).  Dies kann den aufrufenden Code √ºberraschen.  Wenn die <i>BlocksUsing-</i> Enumeration wirklich zum <i>Angeben von</i> Flag-Kombinationen (Bitfeld) verwendet werden soll, sollten Sie die Konstantenwerte mit Zweierpotenzen angeben: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Flags</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter = <span class="hljs-number"><span class="hljs-number">1</span></span>, MonitorWait = <span class="hljs-number"><span class="hljs-number">2</span></span>, ManualResetEvent = <span class="hljs-number"><span class="hljs-number">4</span></span>, AutoResetEvent = <span class="hljs-number"><span class="hljs-number">8</span></span>, AsyncResult = <span class="hljs-number"><span class="hljs-number">16</span></span>, IAsyncResult = <span class="hljs-number"><span class="hljs-number">32</span></span>, PInvoke = <span class="hljs-number"><span class="hljs-number">64</span></span>, InputQueue = <span class="hljs-number"><span class="hljs-number">128</span></span>, ThreadNeutralSemaphore = <span class="hljs-number"><span class="hljs-number">256</span></span>, PrivatePrimitive = <span class="hljs-number"><span class="hljs-number">512</span></span>, OtherInternalPrimitive = <span class="hljs-number"><span class="hljs-number">1024</span></span>, OtherFrameworkPrimitive = <span class="hljs-number"><span class="hljs-number">2048</span></span>, OtherInterop = <span class="hljs-number"><span class="hljs-number">4096</span></span>, Other = <span class="hljs-number"><span class="hljs-number">8192</span></span>, NonBlocking = <span class="hljs-number"><span class="hljs-number">16384</span></span>, }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3125/">V3125</a> Das Objekt 'session' wurde verwendet, nachdem es gegen null gepr√ºft wurde.  √úberpr√ºfen Sie die Zeilen: 69, 68. AmqpLinkCreator.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br>  Achten Sie auf die Arbeit mit der <i>Sitzungsvariablen</i> im <i>catch-Block</i> .  Die <i>Abort-</i> Methode wird sicher √ºber die Conditional Access-Anweisung <i>aufgerufen</i> .  Dann rufen sie die <i>GetInnerException-</i> Methode unsicher auf.  In diesem Fall wird m√∂glicherweise eine <i>NullReferenceException</i> ausgel√∂st, anstatt eine Ausnahme des erwarteten Typs <i>auszul√∂sen</i> .  Der Code muss repariert werden.  Die <i>AmqpExceptionHelper.GetClientException-</i> Methode unterst√ºtzt die √úbergabe eines <i>Nullwerts</i> f√ºr den <i>innerException-</i> Parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetClientException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Exception exception, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> referenceId = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Exception innerException = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionError = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Daher ist es ausreichend, den Operator f√ºr den bedingten Zugriff beim Aufrufen von <i>session.GetInnerException () zu verwenden</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session?.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br><h2>  Fazit </h2><br>  Wie Sie sehen, garantiert eine gro√üe Projektgr√∂√üe nicht immer eine gro√üe Anzahl von Fehlern.  Aber keine Notwendigkeit, sich zu entspannen - Sie k√∂nnen immer etwas finden.  Auch in solch einem komplexen Projekt wie Azure SDK f√ºr .NET.  Ja, dies erfordert zus√§tzliche Anstrengungen, aber je angenehmer das Ergebnis sein wird.  Und damit Sie sich nicht zu sehr anstrengen m√ºssen, empfehlen wir die Verwendung einer statischen Analyse und die Arbeit der Entwickler beim Schreiben von neuem Code.  Dies ist der effektivste Ansatz.  <a href="https://www.viva64.com/ru/pvs-studio-download/">Laden Sie PVS-Studio herunter und testen Sie es</a> in Aktion.  Viel Gl√ºck im Kampf gegen Bugs! <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/478978/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Khrenov.  <a href="https://habr.com/en/company/pvs-studio/blog/478978/">Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478980/">https://habr.com/ru/post/de478980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478968/index.html">SpaceX bringt Nanoracks auf den Markt, um Weltraumm√ºll-Orbitalstationen zu bauen</a></li>
<li><a href="../de478970/index.html">DIY Ruftaste Teil 2. Bildtelefon von Raspberry Pi</a></li>
<li><a href="../de478972/index.html">Gewinner des Miro-Plattformwettbewerbs</a></li>
<li><a href="../de478974/index.html">Modul Autoload mit dynamischem Import</a></li>
<li><a href="../de478978/index.html">Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche</a></li>
<li><a href="../de478986/index.html">Yandex hat eine popul√§re Abstimmung f√ºr Retro-Spiele gestartet. Finalisten der Retro Games Battle 2019</a></li>
<li><a href="../de478988/index.html">Venedig: wilder Gewinn auf ein paar nackten Steinen</a></li>
<li><a href="../de478990/index.html">Installation eines verteilten ausfallsicheren LeoFS-Speichers, der mit Clients kompatibel ist, die S3, NFS verwenden</a></li>
<li><a href="../de478992/index.html">Mangel an Angst und Lebensfreude in der IT</a></li>
<li><a href="../de478994/index.html">Die Deutsche Post will am Montag langsamer arbeiten und sich ausruhen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>