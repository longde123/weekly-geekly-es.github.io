<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏫 😪 🙆🏻 Android如何支持Java 8 🦅 👨‍✈️ 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我提请您注意， 臭名昭著的杰克·沃顿（Jake Worton）撰写的一系列精彩文章的翻译，内容涉及Java如何支持Android 8。 



 原始文章在这里 

 我在家工作了几年，经常听到同事抱怨Android支持不同版本的Java。 

 这是一个相当复杂的话题。 首先，您需要确定...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android如何支持Java 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/478692/"> 哈Ha！ 我提请您注意， <a href="https://twitter.com/JakeWharton%3Flang%3Den">臭名昭著的杰克·沃顿（Jake Worton）</a>撰写的一系列精彩文章的翻译，内容涉及Java如何支持Android 8。 <br><br><img src="https://habrastorage.org/webt/ho/ap/qe/hoapqe-nhkwts3ekeettjbuiao8.png"><br><br>  <font color="#0000ff"><a href="https://jakewharton.com/androids-java-8-support/">原始文章在这里</a></font> <br><a name="habracut"></a><br> 我在家工作了几年，经常听到同事抱怨Android支持不同版本的Java。 <br><br> 这是一个相当复杂的话题。 首先，您需要确定“ Android中的Java支持”的含义，因为在该语言的一个版本中，可能有很多东西：功能（例如，lambda），字节码，工具，API，JVM等。 <br><br> 当他们谈论Android中对Java 8的支持时，通常是指语言功能的支持。 因此，让我们从它们开始。 <br><br><h2>  Lambdas </h2><br>  lambda是Java 8的主要创新之一。 <br> 代码变得更加简洁明了，lambda使我们不再需要使用带有单个方法的接口编写庞大的匿名类。 <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br> 使用javac和legacy <code>dx tool</code>对此进行编译后，会出现以下错误： <br><br><pre> <code class="plaintext hljs">$ javac *.java $ ls Java8.java Java8.class Java8$Logger.class $ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br> 发生此错误是由于lambda使用Java 7中添加的字节码<code>invokedynamic</code>的新指令这一事实。从错误文本中，您可以看到Android仅从26 API（Android 8）开始支持它。 <br><br> 听起来不太好，因为几乎没有人会发布具有26 minApi的应用程序。 为了解决这个问题，使用了所谓的<i>desugaring</i>流程，该流程使lambda支持在所有版本的API上都可以实现。 <br><br><h2> 糖化历史 </h2><br> 她在Android世界中非常丰富多彩。 脱糖的目标始终是相同的-允许新的语言功能在所有设备上都能使用。 <br><br> 最初，例如，为了在Android中支持lambda，开发人员连接了<a href="https://github.com/evant/gradle-retrolambda">Retrolambda</a>插件。 他使用了与JVM相同的内置机制，将lambda转换为类，但是他是在运行时而不是在编译时执行的。 就方法的数量而言，生成的类非常昂贵，但是随着时间的流逝，经过不断的改进和改进，该指标或多或少地变得合理。 <br><br> 然后，Android团队<a href="https://android-developers.googleblog.com/2014/12/hello-world-meet-our-new-experimental.html">宣布了一个</a>支持所有Java 8功能且生产率更高<a href="https://android-developers.googleblog.com/2014/12/hello-world-meet-our-new-experimental.html">的新编译器</a> 。 它建立在Eclipse Java编译器的基础上，但是没有生成Java字节码，而是生成了Dalvik字节码。 但是，其性能仍然有很多不足之处。 <br><br> 幸运的是，当新的编译器被放弃时，负责处理的Java字节码中的Java字节码转换器已从Google的构建系统<a href="https://docs.bazel.build/versions/master/bazel-and-android.html">Bazel</a> <a href="https://android-developers.googleblog.com/2017/04/java-8-language-features-support-update.html">集成到Android Gradle插件中</a> 。 而且它的性能仍然很低，因此并行寻求更好的解决方案。 <br><br> 现在我们看到<a href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html"><code>  dexer</code></a> - <i>D8</i> ，它应该可以代替<code>dx tool</code> 。 现在，在将已编译的JAR文件转换为<code>.dex</code> （dexing）的过程中执行了脱糖操作。 与<code>dx</code>相比，D8的性能要好得多，并且由于Android Gradle Plugin 3.1，它已成为默认的dexer。 <br><br><h2>  D8 </h2><br> 现在，使用D8，我们可以编译上面的代码。 <br><br><pre> <code class="plaintext hljs">$ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class $ ls Java8.java Java8.class Java8$Logger.class classes.dex</code> </pre> <br> 要查看D8如何转换lambda，您可以使用Android SDK中随附的<code>dexdump tool</code> 。 它会显示很多东西，但是我们将只关注于此： <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dexdump -d classes.dex [0002d8] Java8.main:([Ljava/lang/String;)V 0000: sget-object v0, LJava8$1;.INSTANCE:LJava8$1; 0002: invoke-static {v0}, LJava8;.sayHi:(LJava8$Logger;)V 0005: return-void [0002a8] Java8.sayHi:(LJava8$Logger;)V 0000: const-string v0, "Hello" 0002: invoke-interface {v1, v0}, LJava8$Logger;.log:(Ljava/lang/String;)V 0005: return-void …</code> </pre> <br> 如果您还没有阅读字节码，请不要担心：这里写的大部分内容都可以直观地理解。 <br><br> 在第一个块中，索引为<code>0000</code> <code>main</code>方法从<code>INSTANCE</code>字段获取对<code>INSTANCE</code>类<code>Java8$1</code>的引用。 该类是在<code></code>过程中生成的。  main方法字节码也没有包含我们的lambda的任何内容，因此，很可能与<code>Java8$1</code>类相关联。 索引<code>0002</code>然后使用到<code>INSTANCE</code>的链接调用<code>sayHi</code>静态方法。  <code>sayHi</code>需要<code>Java8$Logger</code> ，因此似乎<code>Java8$1</code>实现了此接口。 我们可以在这里验证： <br><br><pre> <code class="plaintext hljs">Class #2 - Class descriptor : 'LJava8$1;' Access flags : 0x1011 (PUBLIC FINAL SYNTHETIC) Superclass : 'Ljava/lang/Object;' Interfaces - #0 : 'LJava8$Logger;'</code> </pre> <br>  <code>SYNTHETIC</code>标志意味着已经生成<code>Java8$1</code>类，并且它包含的接口列表包含<code>Java8$Logger</code> 。 <br> 此类表示我们的lambda。 如果查看<code>log</code>方法的实现，您将看不到lambda的主体。 <br><br><pre> <code class="plaintext hljs">… [00026c] Java8$1.log:(Ljava/lang/String;)V 0000: invoke-static {v1}, LJava8;.lambda$main$0:(Ljava/lang/String;)V 0003: return-void …</code> </pre> <br> 相反， <code>Java8</code>类的<code>static</code>方法<code>Java8</code> <code>lambda$main$0</code> 。 我重复一遍，此方法仅以字节码表示。 <br><br><pre> <code class="plaintext hljs">… #1 : (in LJava8;) name : 'lambda$main$0' type : '(Ljava/lang/String;)V' access : 0x1008 (STATIC SYNTHETIC) [0002a0] Java8.lambda$main$0:(Ljava/lang/String;)V 0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  <code>SYNTHETIC</code>标志再次告诉我们该方法已生成，其字节码仅包含lambda主体：对<code>System.out.println</code>的调用。  lambda主体位于<i>Java8.class</i>内的<i>原因</i>很简单-它可能需要访问该类的<code>private</code>成员，生成的类将无法访问该<code>private</code>成员。 <br><br> 上面介绍了了<i>解脱糖</i>工作原理所需的所有内容。 但是，在Dalvik字节码中查看它，您会发现一切都变得更加复杂和令人恐惧。 <br><br><h2> 源转换 </h2><br> 为了更好地了解如何进行<i>糖化</i> ，让我们逐步尝试将类转换为可在所有版本的API上使用的类。 <br><br> 让我们以lambda为基础来讨论同一类： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br> 首先，将lambda主体移至<code>package private</code>方法。 <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(s -&gt; lambda$main$0(s)); } + + static void lambda$main$0(String s) { + System.out.println(s); + }</code> </pre> <br> 然后，实现一个实现<code>Logger</code>接口的类，在其中执行来自lambda主体的代码块。 <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; lambda$main$0(s)); + sayHi(new Java8$1()); } @@ } + +class Java8$1 implements Java8.Logger { + @Override public void log(String s) { + Java8.lambda$main$0(s); + } +}</code> </pre> <br> 接下来， <code>Java8$1</code>的单例实例，该实例存储在<code>static</code>变量<code>INSTANCE</code> 。 <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(new Java8$1()); + sayHi(Java8$1.INSTANCE); } @@ class Java8$1 implements Java8.Logger { + static final Java8$1 INSTANCE = new Java8$1(); + @Override public void log(String s) {</code> </pre> <br> 这是可以在所有版本的API上使用的最终<i>配音</i>类： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>.INSTANCE); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(String s) { System.out.println(s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span> INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ Java8.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(s); } }</code> </pre> <br> 如果您在Dalvik字节码中查看生成的类，将不会找到类似Java8 $ 1的名称-会有类似<code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> 。 为该类生成此类命名的原因及其优点是吸引到单独的文章中。 <br><br><h2> 本机Lambda支持 </h2><br> 当我们使用<code>dx tool</code>编译包含lambda的类时，出现一条错误消息，指出仅适用于26个API。 <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br> 因此，如果我们尝试使用<code>—min-api 26</code>标志进行编译，这似乎是合乎逻辑的，则不会发生脱糖作用。 <br><br><pre> <code class="bash hljs">$ java -jar d8.jar \ --lib <span class="hljs-variable"><span class="hljs-variable">$ANDROID_HOME</span></span>/platforms/android-28/android.jar \ --release \ --min-api 26 \ --output . \ *.class</code> </pre> <br> 但是，如果转储<code>.dex</code>文件，则仍可以在其中找到它<code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> 。 为什么这样 这是D8错误吗？ <br><br> 为了回答这个问题，以及为什么<i>总是发生</i>脱糖<i>作用</i> ，我们需要查看<code>Java8</code>类的Java字节码。 <br><br><pre> <code class="bash hljs">$ javap -v Java8.class class Java8 { public static void main(java.lang.String...); Code: 0: invokedynamic <span class="hljs-comment"><span class="hljs-comment">#2, 0 // InvokeDynamic #0:log:()LJava8$Logger; 5: invokestatic #3 // Method sayHi:(LJava8$Logger;)V 8: return } …</span></span></code> </pre> <br> 在<code>main</code>方法内部，我们再次在索引<code>0</code>处看到<i>invokedynamic</i> 。 调用中的第二个参数为<code>0</code>与之关联的<a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method">引导</a>方法的索引。 <br><br> 这是<i>引导</i>方法的列表： <br><br><pre> <code class="plaintext hljs">… BootstrapMethods: 0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:( Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String; Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType; Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;) Ljava/lang/invoke/CallSite; Method arguments: #28 (Ljava/lang/String;)V #29 invokestatic Java8.lambda$main$0:(Ljava/lang/String;)V #28 (Ljava/lang/String;)V</code> </pre> <br> 这里的<i>bootstrap</i>方法在<code>java.lang.invoke.LambdaMetafactory</code>类中称为<code>metafactory</code> 。 他<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">住在JDK中，</a>并在运行时为lambda创建匿名的即时类，就像D8在计算时生成它们一样。 <br><br> 如果您查看<a href="https://developer.android.com/reference/java/lang/invoke/package-summary"><code> Android  java.lang.invoke</code></a>的<a href="https://developer.android.com/reference/java/lang/invoke/package-summary"><code> Android  java.lang.invoke</code></a> <br> 或<a href="https://android.googlesource.com/platform/libcore/%2B/master/ojluni/src/main/java/java/lang/invoke/"><code> AOSP  java.lang.invoke</code></a>的<a href="https://android.googlesource.com/platform/libcore/%2B/master/ojluni/src/main/java/java/lang/invoke/"><code> AOSP  java.lang.invoke</code></a> ，我们看到此类不在运行时中。 这就是为什么无论您拥有什么minApi，都总是在编译时进行去杂耍。  VM支持类似于<code>invokedynamic</code>字节码指令，但是JDK内置的<code>invokedynamic</code>无法使用。 <br><br><h2> 方法参考 </h2><br>  Java 8与lambda一起添加了方法引用-这是创建其lambda主体引用现有方法的有效方法。 <br><br> 我们的<code>Logger</code>界面就是这样一个例子。  lambda主体引用到<code>System.out.println</code> 。 让我们将lambda转换为引用方法： <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(System.out::println); }</code> </pre> <br> 当我们编译它并查看字节码时，我们将看到与先前版本的不同之处： <br><br><pre> <code class="plaintext hljs">[000268] -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM.log:(Ljava/lang/String;)V 0000: iget-object v0, v1, L-$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM;.f$0:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v2}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br> 而不是调用生成的<code>Java8.lambda$main$0</code> （其中包含对<code>System.out.println</code>的调用），现在直接调用<code>System.out.println</code> 。 <br><br> 具有lambda的类不再是<code>static</code>单例，而是通过字节码中的索引<code>0000</code> ，我们看到我们获得了指向<code>PrintStream</code> - <code>System.out</code>的链接，该链接随后用于对其调用<code>println</code> 。 <br><br> 结果，我们的班级变成了这样： <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(System.out::println); + sayHi(new -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(System.out)); } @@ } + +class -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM implements Java8.Logger { + private final PrintStream ps; + + -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(PrintStream ps) { + this.ps = ps; + } + + @Override public void log(String s) { + ps.println(s); + } +}</code> </pre> <br><h2> 接口中的<code>Default</code>方法和<code>static</code>方法 </h2><br>  Java 8带来的另一个重要而重要的变化是能够在接口中声明<code>default</code>方法和<code>static</code>方法。 <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String tag, String s)</span></span></span><span class="hljs-function"> </span></span>{ log(tag + <span class="hljs-string"><span class="hljs-string">": "</span></span> + s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Logger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.out::println; } }</code> </pre> <br>  D8也支持所有这些。 使用与以前相同的工具，很容易看到具有<code>default</code>方法和<code>static</code>方法的Logger的登录版本。  lambda和<code>method references</code>的区别之一是，默认方法和静态方法是在Android VM中实现的，并且从24个API开始，D8不会<i>将</i>它们<i>解耦</i> 。 <br><br><h2> 也许只用Kotlin？ </h2><br> 阅读本文时，大多数人可能会想到Kotlin。 是的，它支持所有Java 8功能，但是除了一些细节外，它们由<code>kotlinc</code>以与D8相同的方式实现。 <br><br> 因此，即使您的项目是100％用Kotlin编写的，Android对Java新版本的支持仍然非常重要。 <br><br> 将来Kotlin可能会停止支持Java 6和Java 7字节码， <a href="https://blog.jetbrains.com/idea/2015/12/intellij-idea-16-eap-144-2608-is-out/">IntelliJ IDEA</a>将从Gradle 5.0切换到Java8。运行在较早JVM上的平台数量正在减少。 <br><br><h2> 脱糖API </h2><br> 一直以来，我都在谈论Java 8功能，但没有对新的API进行任何说明-流， <code>CompletableFuture</code> ，日期/时间等。 <br><br> 回到Logger示例，我们可以使用新的日期/时间API来查找发送消息的时间。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime time, String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi((time, s) -&gt; System.out.println(time + <span class="hljs-string"><span class="hljs-string">" "</span></span> + s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(LocalDateTime.now(), <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br> 再次使用<code>javac</code>对其进行<code>javac</code>并使用D8将其转换为Dalvik字节码，从而<i>将</i>其<i>解耦</i>以支持所有版本的API。 <br><br><pre> <code class="plaintext hljs">$ javac *.java $ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class</code> </pre> <br> 您甚至可以在设备上运行此程序以确保其正常运行。 <br><br><pre> <code class="plaintext hljs">$ adb push classes.dex /sdcard classes.dex: 1 file pushed. 0.5 MB/s (1620 bytes in 0.003s) $ adb shell dalvikvm -cp /sdcard/classes.dex Java8 2018-11-19T21:38:23.761 Hello</code> </pre> <br> 如果此设备上使用API​​ 26及更高版本，则会显示Hello消息。 如果没有，我们将看到以下内容： <br><br><pre> <code class="plaintext hljs">java.lang.NoClassDefFoundError: Failed resolution of: Ljava/time/LocalDateTime; at Java8.sayHi(Java8.java:13) at Java8.main(Java8.java:9)</code> </pre> <br>  D8处理了lambdas（一种参考方法），但与<code>LocalDateTime</code>无关，这很可悲。 <br><br> 开发人员必须在日期/时间api上使用自己的实现或包装器，或者使用<code>ThreeTenBP</code>类的<code>ThreeTenBP</code>来处理时间，但是为什么不能用自己的双手做D8？ <br><br><h2> 结语 </h2><br> 缺少对所有新Java 8 API的支持仍然是Android生态系统中的一个大问题。 毕竟，我们每个人不太可能允许我们在项目中指定26分钟的API。 同时支持Android和JVM的库无法使用5年前引入的API！ <br><br> 即使现在Java 8支持已成为D8的一部分，每个开发人员仍应在Java 8中明确指定源和目标兼容性。如果编写自己的库，则可以通过布局使用Java 8字节码的库来加强这种趋势。 （即使您没有使用新的语言功能）。 <br><br> 在D8上正在进行许多工作，因此在支持语言功能的情况下，似乎以后一切都会好起来的。 即使您仅在Kotlin上编写代码，强制Android开发团队支持所有新版本的Java，改进字节码和新的API也非常重要。 <br><br> 这篇文章是我的演讲“ <a href="https://jakewharton.com/digging-into-d8-and-r8/">深入研究D8和R8”</a>的书面版本。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN478692/">https://habr.com/ru/post/zh-CN478692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN478666/index.html">YM3812上的USB声卡</a></li>
<li><a href="../zh-CN478672/index.html">人工智能测试和启动：Adam Carmi访谈（Applitools）</a></li>
<li><a href="../zh-CN478684/index.html">SSD简介。 第2部分。界面</a></li>
<li><a href="../zh-CN478688/index.html">2019年学习数据科学的感觉</a></li>
<li><a href="../zh-CN478690/index.html">使用版本化文档的示例站点使用werf动态组装和部署Docker映像</a></li>
<li><a href="../zh-CN478694/index.html">正如我们在ivi在线电影院中推荐的最新目录（+ Python代码）</a></li>
<li><a href="../zh-CN478696/index.html">我如何参观Urban Tech2019。活动报告</a></li>
<li><a href="../zh-CN478698/index.html">我们在15分钟内制定了互动地形图</a></li>
<li><a href="../zh-CN478702/index.html">Kapacitor中的度量处理技巧</a></li>
<li><a href="../zh-CN478704/index.html">如果邮件已经到达垃圾邮件该怎么办：5个实际步骤</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>