<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 ✌🏻 📊 Eintauchen in die Entwicklung auf Ethereum. Teil 5: Oraclize ⛪️ 🤛🏼 📺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zugriff auf große Dateien und verschiedene externe dynamische Daten ist häufig ein sehr wichtiger Bestandteil einer dezentralen Anwendung. Gleichz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eintauchen in die Entwicklung auf Ethereum. Teil 5: Oraclize</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417681/">  Der Zugriff auf große Dateien und verschiedene externe dynamische Daten ist häufig ein sehr wichtiger Bestandteil einer dezentralen Anwendung.  Gleichzeitig bietet Ethereum selbst keinen Mechanismus, um sich nach außen zu wenden - intelligente Verträge können nur innerhalb der Blockchain selbst gelesen und geschrieben werden.  In diesem Artikel werden wir Oraclize betrachten, das es nur ermöglicht, mit der Außenwelt zu interagieren, indem fast alle Internetressourcen abgefragt werden.  Ein verwandtes Thema ist IPFS, und erwähnen Sie es kurz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/_k/1m/sp_k1m_ob9-qh3_yiiyhmtecypu.jpeg"></div><br><a name="habracut"></a><br><h2>  IPFS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPFS</a> ist ein verteiltes Dateisystem mit Inhaltsadressierung.  Dies bedeutet, dass für den Inhalt einer dort hinzugefügten Datei ein eindeutiger Hash berücksichtigt wird.  Der gleiche Hash wird dann verwendet, um diesen Inhalt zu suchen und aus dem Netzwerk abzurufen. <br>  Die grundlegenden Informationen wurden bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> und mehreren anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln</a> beschrieben, sodass wir keinen Grund sehen, sie zu wiederholen. <br><br><h3>  Warum IPFS in Verbindung mit Ethereum verwenden? </h3><br>  Das Speichern von Volumeninhalten in der Blockchain ist zu teuer und schädlich für das Netzwerk.  Daher ist es am besten, eine Art Link zu der Datei zu speichern, die sich im Off-Chain-Speicher befindet, nicht unbedingt IPFS.  IPFS bietet jedoch eine Reihe von Vorteilen: <br><br><ul><li>  Ein Dateilink ist ein Hash, der für den spezifischen Inhalt der Datei eindeutig ist. Wenn wir diesen Hash also in die Blockchain einfügen, können wir sicher sein, dass die von ihm empfangene Datei die ursprünglich hinzugefügte ist und die Datei nicht ersetzt werden kann </li><li>  Das verteilte System versichert gegen die Nichtverfügbarkeit eines bestimmten Servers (aufgrund von Blockierungen oder anderen Gründen) </li><li>  Der Link zur Datei und die Hash-Bestätigung werden in einer Zeile zusammengefasst, was bedeutet, dass Sie weniger in die Blockchain schreiben und Gas sparen können </li></ul><br>  Unter den Mängeln kann man erwähnen, dass es für den Zugriff auf Dateien notwendig ist, dass mindestens eine Datei „verteilt“ ist, da es keinen zentralen Server gibt.  Wenn Sie jedoch eine bestimmte Datei haben, ist die Verbindung zu den Distributoren einfach. Starten Sie Ihren ipfs-Daemon und fügen Sie die Datei über <code>ipfs add</code> . <br><br>  Die Technologie eignet sich sehr gut für die Ideologie der Dezentralisierung. Wenn wir Oraclize jetzt betrachten, werden wir häufig auf die Verwendung von IPFS in verschiedenen Orakelmechanismen stoßen. <br><br><h2>  Oraclize </h2><br>  Um fast jede nützliche Arbeit ausführen zu können, muss ein intelligenter Vertrag neue Daten erhalten.  Es gibt jedoch keine eingebaute Fähigkeit, eine Anfrage von der Blockchain an die Außenwelt zu erfüllen.  Natürlich können Sie alles, was für Transaktionen erforderlich ist, manuell hinzufügen, aber es ist unmöglich zu überprüfen, woher diese Daten stammen und wie zuverlässig sie sind.  Außerdem müssen Sie möglicherweise eine zusätzliche Infrastruktur organisieren, um dynamische Daten wie Wechselkurse schnell zu aktualisieren.  Und Aktualisierungen mit einem festen Intervall führen zu Gasüberschreitungen. <br><br>  Daher ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oraclize</a> bereitgestellte Dienst praktisch: In einem Smart-Vertrag können Sie eine Anfrage an nahezu jede API oder Ressource im Internet senden, sicherstellen, dass die von der angegebenen Ressource empfangenen Daten unverändert sind, und das Ergebnis in demselben Smart-Vertrag verwenden. <br><br>  Oraclize ist nicht nur ein Ethereum-Dienst, ähnliche Funktionen werden auch für andere Blockchains bereitgestellt, sondern wir werden nur das Bundle mit Ethereum beschreiben. <br><br><h3>  Erste Schritte </h3><br>  Um loszulegen, müssen Sie lediglich eine der oraclizeAPI-Dateien aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> zum Projekt hinzufügen.  Sie müssen nur die für Ihre Version des Compilers (solc) geeignete auswählen: oraclizeAPI_0.5.sol für Versionen ab 0.4.18, oraclizeAPI_0.4.sol für Versionen ab 0.4.1, oraclizeAPI_pre0.4.sol für alles Ältere, Unterstützung Diese Version wurde bereits eingestellt.  Wenn Sie Trüffel verwenden, vergessen Sie nicht, die Datei in usingOraclize umzubenennen. Dazu müssen der Name der Datei und der Vertrag übereinstimmen. <br><br>  Indem Sie die entsprechende Datei in Ihr Projekt aufnehmen, erben Sie den Vertrag von <code>usingOraclize</code> .  Sie können Oracle verwenden, das sich auf zwei <code>oraclize_query</code> : Senden einer Anforderung mit dem Helfer <code>oraclize_query</code> und anschließendes Verarbeiten des Ergebnisses in der Funktion <code>__callback</code> .  Der einfachste Smart-Vertrag (um den aktuellen Sendezeitpreis in US-Dollar zu erhalten) könnte folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">pragma solidity <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./usingOraclize.sol"</span></span>; contract ExampleContract is usingOraclize { string public ETHUSD; event updatedPrice(string price); event newOraclizeQuery(string description); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ updatePrice(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (msg.sender == oraclize_cbAddress()); ETHUSD = result; updatedPrice(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oraclize_getPrice(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>) &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance) { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was sent, standing by for the answer.."</span></span>); oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>); } } }</code> </pre> <br>  Die Funktion, die die Anfrage sendet, ist <code>updatePrice</code> .  Sie können sehen, dass zuerst überprüft wird, <code>oraclize_getPrice(“URL”)</code> größer ist als der aktuelle Kontostand.  Dies liegt daran, dass der Anruf <code>oraclize_query</code> bezahlt werden muss. Der Preis wird als Summe der festen Provision und der <code>oraclize_query</code> für den Rückruf berechnet.  <code>“URL”</code> ist eine Bezeichnung für eine der Arten von Datenquellen. In diesem Fall handelt es sich um eine einfache Anfrage über https. Anschließend werden andere Optionen in Betracht gezogen.  Antworten auf Anfrage können im Voraus als json (wie im Beispiel) und auf verschiedene andere Arten (wir werden weiter darauf eingehen) analysiert werden.  Eine <code>__callback</code> wird in <code>__callback</code> .  Zu Beginn wird überprüft, ob der Anruf von der vertrauenswürdigen Adresse oraclize weitergeleitet wurde <br><br>  Alle Optionen für die Verwendung von oraclize basieren auf einem Schema. Nur Datenquellen und die Möglichkeit, <code>__callback</code> eine Authentifizierung <code>__callback</code> .  Daher werden wir in zukünftigen Beispielen nur signifikante Unterschiede anführen. <br><br><h3>  Preis verwenden </h3><br>  Wie bereits erwähnt, wird für oraclize-Anfragen zusätzlicher Äther bezahlt und aus dem Kontostand und nicht aus der anrufenden Adresse entfernt.  Eine Ausnahme ist nur die erste Anfrage aus jedem neuen Vertrag, sie wird kostenlos zur Verfügung gestellt.  Es ist auch interessant, dass die gleiche Mechanik in Testnetzwerken erhalten bleibt, die Zahlung jedoch durch Senden des entsprechenden Netzwerks erfolgt, dh in Testnetzanforderungen sind sie praktisch kostenlos. <br><br>  Es wurde bereits erwähnt, dass der Anforderungspreis aus zwei Werten besteht: einer festen Provision und der Zahlung für einen Gasrückruf.  Eine feste Provision wird in Dollar definiert, und die Äthermenge wird aus dem aktuellen Satz berechnet.  Die Provision hängt von der Datenquelle und zusätzlichen unterstützenden Mechanismen ab, auf die wir noch eingehen werden.  Die aktuelle Preistabelle sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/w2/xv/d9w2xvqkoi2laplioqc377xydxm.png"></div><br>  Wie Sie sehen können, beträgt der Preis pro URL-Anfrage mehrere Cent.  Ist es viel oder wenig?  Betrachten wir dazu, wie viel der zweite Teil kostet - die Rückrufgasgebühr. <br>  Dies funktioniert nach folgendem Schema: Die Menge an Äther, die zur Zahlung einer festen Menge Gas zu einem festen Preis benötigt wird, wird im Voraus mit der Anfrage aus dem Vertrag übertragen.  Dieser Betrag sollte ausreichen, um einen Rückruf zu tätigen, und der Preis sollte dem Markt angemessen sein, da sonst die Transaktion nicht durchgeführt wird oder sehr lange anhält.  Gleichzeitig ist klar, dass es nicht immer möglich ist, die Gasmenge im Voraus zu kennen, daher muss die Tafel auch in Reserve sein (die Reserve wird nicht zurückgegeben).  Die Standardwerte sind ein Limit von 200.000 Gas zu einem Preis von 20 gwei.  Dies reicht für einen durchschnittlichen Rückruf mit mehreren Einträgen und einer Art Logik.  Und der Preis von 20 Gwei mag zwar im Moment zu hoch erscheinen (zum Zeitpunkt des Schreibens liegt der Durchschnitt bei 4 Gwei), aber zum Zeitpunkt des Zuflusses von Transaktionen kann der Marktpreis plötzlich springen und sogar noch höher sein, sodass diese Werte im Allgemeinen nahe an den tatsächlich verwendeten Werten liegen.  Bei solchen Werten und einem Luftpreis in der Größenordnung von 500 US-Dollar werden sich die Gaszahlungen 2 US-Dollar nähern, sodass wir sagen können, dass eine feste Provision einen kleinen Teil ausmacht. <br><br>  Wenn Sie wissen, was Sie tun, besteht die Möglichkeit, das Limit und den Gaspreis zu ändern und so bei Anfragen erheblich zu sparen. <br><br>  Der Gaspreis kann durch eine separate Funktion festgelegt werden - <code>oraclize_setCustomGasPrice(&lt;  wei&gt;)</code> .  Nach dem Anruf wird der Preis gespeichert und in allen nachfolgenden Anfragen verwendet. <br>  Das Limit kann in der Abfrage <code>oraclize_query</code> , indem es mit dem letzten Argument angegeben wird, beispielsweise wie <code>oraclize_query</code> : <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>);</code> </pre> <br>  Wenn Sie eine komplexe Logik in <code>__callback</code> und mehr als 200.000 Gas verbraucht werden, müssen Sie auf jeden Fall einen Grenzwert festlegen, der den schlimmsten Fall des Gasverbrauchs abdeckt.  Andernfalls wird <code>__callback</code> einfach zurückgesetzt, wenn das Limit überschritten <code>__callback</code> . <br><br>  Übrigens hat oraclize kürzlich Informationen erhalten, die Sie für Anfragen außerhalb der Blockchain bezahlen können, sodass Sie nicht das gesamte Limit ausgeben oder den Restbetrag zurückgeben können (und die Zahlung nicht aus dem Vertrag stammt).  Wir mussten dies noch nicht verwenden, aber oraclize bietet an, sie unter info@oraclize.it zu kontaktieren, wenn diese Option interessant ist.  Denken Sie deshalb daran. <br><br><h3>  Wie funktioniert es? </h3><br>  Warum erhalten wir nach dem Erben eines regulären Smart-Vertrags Funktionen, die ursprünglich nicht von Blockchain-Mechanismen unterstützt wurden?  Tatsächlich besteht der Orakelservice nicht nur aus Verträgen mit Hilfsfunktionen.  Die Hauptarbeit zum Abrufen von Daten wird von einem externen Dienst erledigt.  Intelligente Verträge bilden Anwendungen für den Zugriff auf externe Daten und fügen sie in die Blockchain ein.  Externer Dienst - überwacht neue Blöcke der Blockchain und führt sie aus, wenn sie eine Anwendung erkennt.  Schematisch kann dies wie folgt dargestellt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/b0/ka/thb0kan1hwm75ijixmdrqtiwvum.png"></div><br><h3>  Datenquellen </h3><br>  Zusätzlich zu der berücksichtigten URL bietet oraclize 4 weitere Optionen (die Sie im Abschnitt über die Preisgestaltung gesehen haben): <code>WolframAlpha</code> , <code>IPFS</code> , <code>random</code> und <code>computation</code> .  Betrachten wir jeden von ihnen. <br><br><h4>  1. URL </h4><br>  Das bereits besprochene Beispiel verwendet diese Datenquelle.  Dies ist die Quelle für HTTP-Anforderungen an verschiedene APIs.  Das Beispiel war wie folgt: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>);</code> </pre> <br>  Dies ist der Preis für Ether, und da API eine JSON-Zeichenfolge mit einem Datensatz bereitstellt, wird die Anforderung in einen JSON-Parser eingeschlossen und gibt nur das Feld zurück, das wir benötigen.  In diesem Fall ist es GET, aber die Quell-URL unterstützt auch POST-Anforderungen.  Die Art der Anforderung wird automatisch durch ein zusätzliches Argument bestimmt.  Wenn es einen gültigen JSON wie in diesem Beispiel gibt: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://shapeshift.io/sendamount).success.deposit"</span></span>, <span class="hljs-string"><span class="hljs-string">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span></span>)</code> </pre> <br>  dann wird die Anfrage als POST verarbeitet (die verwendete API wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> bei Interesse beschrieben) <br><br><h4>  2. WolframAlpha </h4><br>  Über diese Datenquelle können Sie auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WolframAlpha-</a> Dienst zugreifen, der beispielsweise Antworten auf verschiedene Anfragen nach Fakten oder Berechnungen bietet <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “president <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Russia”)</code> </pre> <br>  wird <code>Vladimir Putin</code> und darum bitten <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “solve x^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>”)</code> </pre> <br>  gibt <code>x = 2</code> . <br>  Wie Sie sehen können, war das Ergebnis unvollständig, da das Symbol ± verloren ging.  Bevor Sie diese Quelle verwenden, müssen Sie daher überprüfen, ob der Wert einer bestimmten Anforderung in einem Smart-Vertrag verwendet werden kann.  Darüber hinaus wird die Authentifizierung für Antworten nicht unterstützt. Daher empfehlen oraclize selbst, diese Quelle nur zum Testen zu verwenden. <br><br><h4>  3. IPFS </h4><br>  Wie Sie vielleicht erraten haben, können Sie den Inhalt einer Datei in IPFS mithilfe eines Multi-Hash abrufen.  Das Zeitlimit für den Empfang von Inhalten beträgt 20 Sekunden. <br><br><pre> <code class="javascript hljs">oraclize_query(“IPFS”, “QmTL5xNq9PPmwvM1RhxuhiYqoTJcmnaztMz6PQpGxmALkP”)</code> </pre> <br>  wird zurückkehren <code>Hello, Habr!</code>  (wenn die Datei mit diesem Inhalt noch verfügbar ist) <br><br><h4>  4. zufällig </h4><br>  Die Generierung von Zufallszahlen funktioniert genauso wie andere Quellen. Wenn Sie jedoch <code>oraclize_query</code> , ist die Vorbereitung der Argumente zeitaufwändig.  Um dies zu vermeiden, können Sie die <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> und nur die Ausführungsverzögerung (in Sekunden), die Anzahl der generierten Bytes und das <code>__callback</code> für den Aufruf von <code>__callback</code> . <br>  Die Verwendung von <code>random</code> hat einige Dinge zu beachten: <br><br><ul><li>  Um zu bestätigen, dass die Zahl tatsächlich zufällig ist, wird eine spezielle Art der Überprüfung verwendet - Ledger, die in der Blockchain ausgeführt werden kann (im Gegensatz zu allen anderen, aber dazu später mehr).  Dies bedeutet, dass Sie im Konstruktor des Smart-Vertrags diese Überprüfungsmethode durch die folgende Funktion festlegen müssen: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_Ledger);</code> </pre> <br>  Und zu Beginn des Rückrufs sollte es eine Überprüfung selbst geben: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 _queryId, string _result, bytes _proof</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == <span class="hljs-number"><span class="hljs-number">0</span></span>) ); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  Diese Überprüfung erfordert ein echtes Netzwerk und funktioniert nicht mit Ganache. Für lokale Tests können Sie diese Zeile vorübergehend entfernen.  Das dritte Argument für <code>__callback</code> ist <code>_proof</code> der optionale Parameter <code>_proof</code> .  Es ist immer erforderlich, wenn einer der Bestätigungstypen verwendet wird. </li><li>  Wenn Sie eine Zufallszahl für kritische Momente verwenden, um beispielsweise den Gewinner der Lotterie zu ermitteln, erfassen Sie Benutzereingaben, bevor Sie newRandomDSQuery senden.  Andernfalls kann folgende Situation auftreten: oraclize ruft _callback auf und die Transaktion ist für alle in der ausstehenden Liste sichtbar.  Gleichzeitig ist die Zufallszahl selbst sichtbar.  Wenn Benutzer grob gesagt weiterhin Wetten abschließen können, können sie einen höheren Gaspreis angeben und ihre Rate verschieben, bevor _callback ausgeführt wird, wobei sie im Voraus wissen, dass sie gewinnen werden. </li></ul><br><br><h4>  5. Berechnung </h4><br>  Dies ist die flexibelste der Quellen.  Sie können damit Ihre eigenen Skripte schreiben und als Datenquelle verwenden.  Die Berechnung erfolgt auf AWS.  Zur Ausführung müssen Sie die Docker-Datei beschreiben, sie mit beliebigen zusätzlichen Dateien in einem Zip-Archiv zusammenstellen und das Archiv in IPFS herunterladen.  Die Implementierung muss die folgenden Bedingungen erfüllen: <br><br><ul><li>  Schreiben Sie die Antwort, die Sie zurückgeben möchten, mit der letzten Zeile in stdout </li><li>  Die Antwort darf nicht mehr als 2500 Zeichen umfassen </li><li>  Die Initialisierung und Ausführung sollte insgesamt nicht länger als 5 Minuten dauern </li></ul><br>  Als Beispiel dafür betrachten wir, wie die einfachste Vereinigung der übertragenen Zeilen durchgeführt und das Ergebnis zurückgegeben werden kann. <br><br>  Dockerfile: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 MAINTAINER <span class="hljs-string"><span class="hljs-string">"info@rubyruby.ru"</span></span> CMD <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG0</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG1</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG2</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG3</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Umgebungsvariablen <code>ARG0</code> , <code>ARG1</code> usw.  - Dies sind die Parameter, die zusammen mit der Anfrage übergeben werden. <br>  Fügen Sie die Docker-Datei zum Archiv hinzu, starten Sie den ipfs-Server und fügen Sie dieses Archiv dort hinzu <br><br><pre> <code class="bash hljs">$ zip concatenation.zip Dockerfile $ ipfs daemon &amp; $ ipfs add concatenation.zip QmWbnw4BBFDsh7yTXhZaTGQnPVCNY9ZDuPBoSwB9A4JNJD</code> </pre> <br>  Wir verwenden den resultierenden Hash, um die Anfrage über <code>oraclize_query</code> im Smart-Vertrag zu senden: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"computation"</span></span>, [<span class="hljs-string"><span class="hljs-string">"QmVAS9TNKGqV49WTEWv55aMCTNyfd4qcGFFfgyz7BYHLdD"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s2"</span></span>, <span class="hljs-string"><span class="hljs-string">"s3"</span></span>, <span class="hljs-string"><span class="hljs-string">"s4"</span></span>]);</code> </pre> <br>  Als Argument wird ein Array verwendet, bei dem das erste Element der Archiv-Multihash ist und der Rest die Parameter sind, die in die Umgebungsvariablen fallen. <br><br>  Wenn Sie auf den Abschluss der Anforderung warten, gibt <code>__callback</code> Ergebnis <code>s1 s2 s3 s4</code> . <br><br><h3>  Parser-Helfer und Unterabfragen </h3><br>  Aus der von einer beliebigen Quelle zurückgegebenen Antwort können Sie nur die erforderlichen Informationen mit einer Reihe von Hilfsprogrammen vorab auswählen, z. <br><br><h4>  1. JSON-Parser </h4><br>  Sie haben diese Methode im allerersten Beispiel gesehen, in dem nur der Preis aus dem Ergebnis von coinmarketcap zurückgegeben wurde: <br><br><pre> <code class="bash hljs">json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd</code> </pre> <br>  Der Anwendungsfall ist ziemlich offensichtlich und kehrt zum Beispiel zurück: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"symbol"</span></span>: <span class="hljs-string"><span class="hljs-string">"ETH"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rank"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"462.857"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_btc"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0621573"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"24h_volume_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"1993200000.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"market_cap_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"46656433775.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"available_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"total_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_supply"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_1h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-0.5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_24h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-3.02"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_7d"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.93"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"1532064934"</span></span> } ]</code> </pre> <br>  Da dies ein Array ist, nehmen wir das Element <code>0</code> und daraus das Feld <code>price_usd</code> <br><br><h4>  2. XML </h4><br>  Die Verwendung ähnelt JSON, zum Beispiel: <br><br><pre> <code class="bash hljs">xml(https://informer.kovalut.ru/webmaster/getxml.php?kod=7701).Exchange_Rates.Central_Bank_RF.USD.New.Exch_Rate</code> </pre> <br><h4>  3. HTML </h4><br>  Sie können XHTML mit XPath analysieren.  Holen Sie sich zum Beispiel eine Marktkapitalisierung mit Etherscan: <br><br><pre> <code class="bash hljs">html(https://etherscan.io/).xpath(string(//*[contains(@href, <span class="hljs-string"><span class="hljs-string">'/stat/supply'</span></span>)]/font))</code> </pre> <br>  <code>MARKET CAP OF $46.148 BillionB</code> <br><br><h4>  4. Binärer Helfer </h4><br>  Ermöglicht das Ausschneiden von Stücken aus Rohdaten mithilfe der Slice-Funktion (Versatz, Länge).  Das heißt, wir haben zum Beispiel eine Datei mit dem Inhalt von "abc": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> &gt; example.bin</code> </pre> <br>  Stellen Sie es auf IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add example.bin added Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE</code> </pre> <br>  Schneiden Sie nun 1 Zeichen aus der Mitte: <br><br><pre> <code class="javascript hljs">binary(Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE).slice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  In der Antwort erhalten wir <code>b</code> <br><br>  Wie Sie vielleicht bemerkt haben, wurde im Fall des binären Helfers nicht die IP-Quelle verwendet, sondern IPFS.  In der Tat können Parser auf alle Quellen angewendet werden. Nehmen wir an, es ist nicht erforderlich, JSON auf das anzuwenden, was die URL zurückgibt. Sie können der Datei solchen Inhalt hinzufügen: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"one"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"two"</span></span>:<span class="hljs-string"><span class="hljs-string">"2"</span></span> }</code> </pre> <br>  Fügen Sie es zu IPFS hinzu: <br><br><pre> <code class="bash hljs">$ ipfs add test.json added QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp</code> </pre> <br>  Und dann so zerlegen: <br><br><pre> <code class="bash hljs">json(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one</code> </pre> <br>  Wir bekommen <code>1</code> <br><br>  Ein besonders interessanter Anwendungsfall ist die Kombination von Datenquellen und Parsern in einer Anfrage.  Dies ist mithilfe einer separaten <code>nested</code> Datenquelle möglich.  Wir verwenden die gerade erstellte Datei in einer komplexeren Anforderung (Hinzufügen von Werten in zwei Feldern): <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">WolframAlpha</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one} to <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).two}</code> </pre> <br>  Wir bekommen <code>3</code> <br>  Die Anforderung wird wie folgt gebildet: Geben Sie die <code>nested</code> Datenquelle an, fügen Sie dann für jede Anforderung den Namen der Quelle davor in eckigen Klammern hinzu und rahmen Sie zusätzlich alle Unterabfragen in <code>${..}</code> . <br><br><h3>  Testen </h3><br>  Oraclize bietet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nützlichen Service</a> zur Validierung von Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> ohne dass intelligente Verträge erforderlich sind.  Gehen Sie einfach hinein, wählen Sie eine Datenquelle, eine Überprüfungsmethode und Sie können sehen, dass sie zu __callback zurückkehrt, wenn Sie die entsprechenden Anforderungen senden <br><br>  Für die lokale Überprüfung in Verbindung mit einem Smart-Vertrag können Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezielle Version der Remix-IDE verwenden</a> , die oraclize-Anforderungen unterstützt. <br><br>  Und um lokal mit Ganache zu prüfen, benötigen Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum-Brücke</a> , die intelligente Verträge für Ihr Testnetz bereitstellt oder aktiviert.  Fügen Sie zum Testen zunächst die folgende Zeile zum Konstruktor Ihres Vertrags hinzu: <br><br><pre> <code class="javascript hljs">OAR = OraclizeAddrResolverI(<span class="hljs-number"><span class="hljs-number">0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475</span></span>);</code> </pre> <br>  laufen <br><br><pre> <code class="bash hljs">ganache-cli</code> </pre> <br>  Dann <br><br><pre> <code class="bash hljs">node bridge --dev</code> </pre> <br>  Warten Sie, bis die Verträge tot sind und Sie testen können.  In der Ausgabe der <code>node bridge</code> sehen Sie die gesendeten Anforderungen und die empfangenen Antworten. <br><br>  Eine weitere Hilfe nicht nur beim Testen, sondern auch beim tatsächlichen Gebrauch ist die Möglichkeit, Anfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu überwachen.  Wenn Sie in einem öffentlichen Netzwerk anfordern, können Sie den Hash der Transaktion verwenden, in der die Anforderung ausgeführt wird.  Wenn Sie die Authentifizierung verwenden, beachten Sie, dass diese garantiert nur an das Hauptnetz gesendet werden. In anderen Netzwerken kann 0 zurückgegeben werden. Wenn sich die Anforderung im lokalen Netzwerk befand, können Sie die Anforderungs-ID verwenden, die <code>oraclize_query</code> .  Übrigens wird empfohlen, diese ID immer in einer ähnlichen Zuordnung zu belassen: <br><br><pre> <code class="javascript hljs">mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32</span></span></span><span class="hljs-function">=&gt;</span></span>bool) validIds;</code> </pre> <br>  Markieren Sie zum Zeitpunkt der Anforderung die gesendete ID als <code>true</code> : <br><br><pre> <code class="javascript hljs">bytes32 queryId = oraclize_query(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">); validIds[queryId] = true;</span></span></code> </pre><br>  Überprüfen Sie anschließend in <code>__callback</code> , ob die Anforderung mit dieser ID noch nicht verarbeitet wurde: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(validIds[myid] != bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(msg.sender == oraclize_cbAddress()); validIds[myid] = bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Dies ist erforderlich, da <code>__callback</code> bei einer Anforderung aufgrund der Besonderheiten der Oraclize-Mechanismen mehrmals aufgerufen werden kann. <br><br><h3>  Authentifizierung </h3><br>  In der Tabelle mit den Quellen konnten Sie sehen, dass verschiedene Quellen verschiedene Arten von Bestätigungen unterstützen können und unterschiedliche Gebühren erhoben werden können.  Dies ist ein sehr wichtiger Teil von oraclize, aber eine detaillierte Beschreibung dieser Mechanismen ist ein separates Thema. <br><br>  Der zumindest von uns am häufigsten verwendete Mechanismus ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLSNotary</a> mit Speicher in IPFS.  Die Speicherung in IPFS ist effizienter, da <code>__callback</code> die Beweise selbst nicht <code>__callback</code> (möglicherweise im Bereich von <code>__callback</code> 5 Kilobyte), sondern einen viel kleineren Multi-Hash.  Um diesen Typ anzugeben, fügen Sie im Konstruktor eine Zeile hinzu: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</code> </pre> <br>  Wir können nur sagen, dass dieser Typ uns grob gesagt vor der Ungenauigkeit der von Oraclize empfangenen Daten schützt.  Oraclize verwendet jedoch Amazon-Server, die als Prüfer fungieren, sodass sie nur vertrauen müssen. <br><br>  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr. <br><br><h2>  Fazit </h2><br>  Oraclize bietet Tools, die die Anzahl der Anwendungsfälle für intelligente Verträge erheblich erhöhen, sowie IPFS, das in mehreren Versionen von Oracle-Abfragen angezeigt wird.  Das Hauptproblem besteht darin, dass wir wieder externe Daten verwenden, die den Bedrohungen ausgesetzt sind, vor denen die Blockchain geschützt sein sollte: Zentralisierung, Blockierungsfunktionen, Codeänderungen, Spoofing.  Obwohl dies alles unvermeidlich ist und die Möglichkeit, Daten abzurufen, sehr nützlich und praktikabel ist, müssen Sie sich nur darüber im Klaren sein, warum die Verwendung von Blockchain in das Projekt eingeführt wurde und ob die Verwendung externer unzuverlässiger Quellen den Nutzen auf Null reduziert. <br><br>  Wenn Sie an einigen Entwicklungsthemen zu Ethereum interessiert sind, die in diesen Artikeln noch nicht veröffentlicht wurden - schreiben Sie in die Kommentare, vielleicht werden wir sie im Folgenden behandeln. <br><br>  Eintauchen in die Entwicklung von Ethereum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Web3.js und Gas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Benutzeranwendung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Bereitstellen und Debuggen in Trüffel, Ganache, Infura</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417681/">https://habr.com/ru/post/de417681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417671/index.html">Neue Funktionen der Programmiersprache ABAP in Webinaren von SAP</a></li>
<li><a href="../de417673/index.html">Die Untersuchung führt zu Solar Dozor: 5 nicht standardisierte Fälle, die DLP enthüllte</a></li>
<li><a href="../de417675/index.html">Lokalisierung von Spielen und Anwendungen in Unity. Schnell und einfach</a></li>
<li><a href="../de417677/index.html">Migrieren eines Projekts von yii1 nach yii2 durch einen einmaligen Job</a></li>
<li><a href="../de417679/index.html">Das schwere Erbe der Vergangenheit. Windows-Befehlszeilenprobleme</a></li>
<li><a href="../de417683/index.html">Veralteter Code - Code von Drittanbietern</a></li>
<li><a href="../de417685/index.html">Skillbox Friday Webinars: Kostenloses Weiterlernen</a></li>
<li><a href="../de417687/index.html">Asymmetrie des Lebens</a></li>
<li><a href="../de417689/index.html">Mobio spricht mit Appnext CEO über CPI-Markt und Trends bei mobilen Anwendungen</a></li>
<li><a href="../de417691/index.html">Unser Bücherregal ist ein C # -Programmierer. Was ist mit dir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>