<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèª ‚úåüèª üìä Eintauchen in die Entwicklung auf Ethereum. Teil 5: Oraclize ‚õ™Ô∏è ü§õüèº üì∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zugriff auf gro√üe Dateien und verschiedene externe dynamische Daten ist h√§ufig ein sehr wichtiger Bestandteil einer dezentralen Anwendung. Gleichz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eintauchen in die Entwicklung auf Ethereum. Teil 5: Oraclize</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417681/">  Der Zugriff auf gro√üe Dateien und verschiedene externe dynamische Daten ist h√§ufig ein sehr wichtiger Bestandteil einer dezentralen Anwendung.  Gleichzeitig bietet Ethereum selbst keinen Mechanismus, um sich nach au√üen zu wenden - intelligente Vertr√§ge k√∂nnen nur innerhalb der Blockchain selbst gelesen und geschrieben werden.  In diesem Artikel werden wir Oraclize betrachten, das es nur erm√∂glicht, mit der Au√üenwelt zu interagieren, indem fast alle Internetressourcen abgefragt werden.  Ein verwandtes Thema ist IPFS, und erw√§hnen Sie es kurz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/_k/1m/sp_k1m_ob9-qh3_yiiyhmtecypu.jpeg"></div><br><a name="habracut"></a><br><h2>  IPFS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPFS</a> ist ein verteiltes Dateisystem mit Inhaltsadressierung.  Dies bedeutet, dass f√ºr den Inhalt einer dort hinzugef√ºgten Datei ein eindeutiger Hash ber√ºcksichtigt wird.  Der gleiche Hash wird dann verwendet, um diesen Inhalt zu suchen und aus dem Netzwerk abzurufen. <br>  Die grundlegenden Informationen wurden bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> und mehreren anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln</a> beschrieben, sodass wir keinen Grund sehen, sie zu wiederholen. <br><br><h3>  Warum IPFS in Verbindung mit Ethereum verwenden? </h3><br>  Das Speichern von Volumeninhalten in der Blockchain ist zu teuer und sch√§dlich f√ºr das Netzwerk.  Daher ist es am besten, eine Art Link zu der Datei zu speichern, die sich im Off-Chain-Speicher befindet, nicht unbedingt IPFS.  IPFS bietet jedoch eine Reihe von Vorteilen: <br><br><ul><li>  Ein Dateilink ist ein Hash, der f√ºr den spezifischen Inhalt der Datei eindeutig ist. Wenn wir diesen Hash also in die Blockchain einf√ºgen, k√∂nnen wir sicher sein, dass die von ihm empfangene Datei die urspr√ºnglich hinzugef√ºgte ist und die Datei nicht ersetzt werden kann </li><li>  Das verteilte System versichert gegen die Nichtverf√ºgbarkeit eines bestimmten Servers (aufgrund von Blockierungen oder anderen Gr√ºnden) </li><li>  Der Link zur Datei und die Hash-Best√§tigung werden in einer Zeile zusammengefasst, was bedeutet, dass Sie weniger in die Blockchain schreiben und Gas sparen k√∂nnen </li></ul><br>  Unter den M√§ngeln kann man erw√§hnen, dass es f√ºr den Zugriff auf Dateien notwendig ist, dass mindestens eine Datei ‚Äûverteilt‚Äú ist, da es keinen zentralen Server gibt.  Wenn Sie jedoch eine bestimmte Datei haben, ist die Verbindung zu den Distributoren einfach. Starten Sie Ihren ipfs-Daemon und f√ºgen Sie die Datei √ºber <code>ipfs add</code> . <br><br>  Die Technologie eignet sich sehr gut f√ºr die Ideologie der Dezentralisierung. Wenn wir Oraclize jetzt betrachten, werden wir h√§ufig auf die Verwendung von IPFS in verschiedenen Orakelmechanismen sto√üen. <br><br><h2>  Oraclize </h2><br>  Um fast jede n√ºtzliche Arbeit ausf√ºhren zu k√∂nnen, muss ein intelligenter Vertrag neue Daten erhalten.  Es gibt jedoch keine eingebaute F√§higkeit, eine Anfrage von der Blockchain an die Au√üenwelt zu erf√ºllen.  Nat√ºrlich k√∂nnen Sie alles, was f√ºr Transaktionen erforderlich ist, manuell hinzuf√ºgen, aber es ist unm√∂glich zu √ºberpr√ºfen, woher diese Daten stammen und wie zuverl√§ssig sie sind.  Au√üerdem m√ºssen Sie m√∂glicherweise eine zus√§tzliche Infrastruktur organisieren, um dynamische Daten wie Wechselkurse schnell zu aktualisieren.  Und Aktualisierungen mit einem festen Intervall f√ºhren zu Gas√ºberschreitungen. <br><br>  Daher ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oraclize</a> bereitgestellte Dienst praktisch: In einem Smart-Vertrag k√∂nnen Sie eine Anfrage an nahezu jede API oder Ressource im Internet senden, sicherstellen, dass die von der angegebenen Ressource empfangenen Daten unver√§ndert sind, und das Ergebnis in demselben Smart-Vertrag verwenden. <br><br>  Oraclize ist nicht nur ein Ethereum-Dienst, √§hnliche Funktionen werden auch f√ºr andere Blockchains bereitgestellt, sondern wir werden nur das Bundle mit Ethereum beschreiben. <br><br><h3>  Erste Schritte </h3><br>  Um loszulegen, m√ºssen Sie lediglich eine der oraclizeAPI-Dateien aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> zum Projekt hinzuf√ºgen.  Sie m√ºssen nur die f√ºr Ihre Version des Compilers (solc) geeignete ausw√§hlen: oraclizeAPI_0.5.sol f√ºr Versionen ab 0.4.18, oraclizeAPI_0.4.sol f√ºr Versionen ab 0.4.1, oraclizeAPI_pre0.4.sol f√ºr alles √Ñltere, Unterst√ºtzung Diese Version wurde bereits eingestellt.  Wenn Sie Tr√ºffel verwenden, vergessen Sie nicht, die Datei in usingOraclize umzubenennen. Dazu m√ºssen der Name der Datei und der Vertrag √ºbereinstimmen. <br><br>  Indem Sie die entsprechende Datei in Ihr Projekt aufnehmen, erben Sie den Vertrag von <code>usingOraclize</code> .  Sie k√∂nnen Oracle verwenden, das sich auf zwei <code>oraclize_query</code> : Senden einer Anforderung mit dem Helfer <code>oraclize_query</code> und anschlie√üendes Verarbeiten des Ergebnisses in der Funktion <code>__callback</code> .  Der einfachste Smart-Vertrag (um den aktuellen Sendezeitpreis in US-Dollar zu erhalten) k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs">pragma solidity <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./usingOraclize.sol"</span></span>; contract ExampleContract is usingOraclize { string public ETHUSD; event updatedPrice(string price); event newOraclizeQuery(string description); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ updatePrice(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (msg.sender == oraclize_cbAddress()); ETHUSD = result; updatedPrice(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oraclize_getPrice(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>) &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance) { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was sent, standing by for the answer.."</span></span>); oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>); } } }</code> </pre> <br>  Die Funktion, die die Anfrage sendet, ist <code>updatePrice</code> .  Sie k√∂nnen sehen, dass zuerst √ºberpr√ºft wird, <code>oraclize_getPrice(‚ÄúURL‚Äù)</code> gr√∂√üer ist als der aktuelle Kontostand.  Dies liegt daran, dass der Anruf <code>oraclize_query</code> bezahlt werden muss. Der Preis wird als Summe der festen Provision und der <code>oraclize_query</code> f√ºr den R√ºckruf berechnet.  <code>‚ÄúURL‚Äù</code> ist eine Bezeichnung f√ºr eine der Arten von Datenquellen. In diesem Fall handelt es sich um eine einfache Anfrage √ºber https. Anschlie√üend werden andere Optionen in Betracht gezogen.  Antworten auf Anfrage k√∂nnen im Voraus als json (wie im Beispiel) und auf verschiedene andere Arten (wir werden weiter darauf eingehen) analysiert werden.  Eine <code>__callback</code> wird in <code>__callback</code> .  Zu Beginn wird √ºberpr√ºft, ob der Anruf von der vertrauensw√ºrdigen Adresse oraclize weitergeleitet wurde <br><br>  Alle Optionen f√ºr die Verwendung von oraclize basieren auf einem Schema. Nur Datenquellen und die M√∂glichkeit, <code>__callback</code> eine Authentifizierung <code>__callback</code> .  Daher werden wir in zuk√ºnftigen Beispielen nur signifikante Unterschiede anf√ºhren. <br><br><h3>  Preis verwenden </h3><br>  Wie bereits erw√§hnt, wird f√ºr oraclize-Anfragen zus√§tzlicher √Ñther bezahlt und aus dem Kontostand und nicht aus der anrufenden Adresse entfernt.  Eine Ausnahme ist nur die erste Anfrage aus jedem neuen Vertrag, sie wird kostenlos zur Verf√ºgung gestellt.  Es ist auch interessant, dass die gleiche Mechanik in Testnetzwerken erhalten bleibt, die Zahlung jedoch durch Senden des entsprechenden Netzwerks erfolgt, dh in Testnetzanforderungen sind sie praktisch kostenlos. <br><br>  Es wurde bereits erw√§hnt, dass der Anforderungspreis aus zwei Werten besteht: einer festen Provision und der Zahlung f√ºr einen Gasr√ºckruf.  Eine feste Provision wird in Dollar definiert, und die √Ñthermenge wird aus dem aktuellen Satz berechnet.  Die Provision h√§ngt von der Datenquelle und zus√§tzlichen unterst√ºtzenden Mechanismen ab, auf die wir noch eingehen werden.  Die aktuelle Preistabelle sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/w2/xv/d9w2xvqkoi2laplioqc377xydxm.png"></div><br>  Wie Sie sehen k√∂nnen, betr√§gt der Preis pro URL-Anfrage mehrere Cent.  Ist es viel oder wenig?  Betrachten wir dazu, wie viel der zweite Teil kostet - die R√ºckrufgasgeb√ºhr. <br>  Dies funktioniert nach folgendem Schema: Die Menge an √Ñther, die zur Zahlung einer festen Menge Gas zu einem festen Preis ben√∂tigt wird, wird im Voraus mit der Anfrage aus dem Vertrag √ºbertragen.  Dieser Betrag sollte ausreichen, um einen R√ºckruf zu t√§tigen, und der Preis sollte dem Markt angemessen sein, da sonst die Transaktion nicht durchgef√ºhrt wird oder sehr lange anh√§lt.  Gleichzeitig ist klar, dass es nicht immer m√∂glich ist, die Gasmenge im Voraus zu kennen, daher muss die Tafel auch in Reserve sein (die Reserve wird nicht zur√ºckgegeben).  Die Standardwerte sind ein Limit von 200.000 Gas zu einem Preis von 20 gwei.  Dies reicht f√ºr einen durchschnittlichen R√ºckruf mit mehreren Eintr√§gen und einer Art Logik.  Und der Preis von 20 Gwei mag zwar im Moment zu hoch erscheinen (zum Zeitpunkt des Schreibens liegt der Durchschnitt bei 4 Gwei), aber zum Zeitpunkt des Zuflusses von Transaktionen kann der Marktpreis pl√∂tzlich springen und sogar noch h√∂her sein, sodass diese Werte im Allgemeinen nahe an den tats√§chlich verwendeten Werten liegen.  Bei solchen Werten und einem Luftpreis in der Gr√∂√üenordnung von 500 US-Dollar werden sich die Gaszahlungen 2 US-Dollar n√§hern, sodass wir sagen k√∂nnen, dass eine feste Provision einen kleinen Teil ausmacht. <br><br>  Wenn Sie wissen, was Sie tun, besteht die M√∂glichkeit, das Limit und den Gaspreis zu √§ndern und so bei Anfragen erheblich zu sparen. <br><br>  Der Gaspreis kann durch eine separate Funktion festgelegt werden - <code>oraclize_setCustomGasPrice(&lt;  wei&gt;)</code> .  Nach dem Anruf wird der Preis gespeichert und in allen nachfolgenden Anfragen verwendet. <br>  Das Limit kann in der Abfrage <code>oraclize_query</code> , indem es mit dem letzten Argument angegeben wird, beispielsweise wie <code>oraclize_query</code> : <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>);</code> </pre> <br>  Wenn Sie eine komplexe Logik in <code>__callback</code> und mehr als 200.000 Gas verbraucht werden, m√ºssen Sie auf jeden Fall einen Grenzwert festlegen, der den schlimmsten Fall des Gasverbrauchs abdeckt.  Andernfalls wird <code>__callback</code> einfach zur√ºckgesetzt, wenn das Limit √ºberschritten <code>__callback</code> . <br><br>  √úbrigens hat oraclize k√ºrzlich Informationen erhalten, die Sie f√ºr Anfragen au√üerhalb der Blockchain bezahlen k√∂nnen, sodass Sie nicht das gesamte Limit ausgeben oder den Restbetrag zur√ºckgeben k√∂nnen (und die Zahlung nicht aus dem Vertrag stammt).  Wir mussten dies noch nicht verwenden, aber oraclize bietet an, sie unter info@oraclize.it zu kontaktieren, wenn diese Option interessant ist.  Denken Sie deshalb daran. <br><br><h3>  Wie funktioniert es? </h3><br>  Warum erhalten wir nach dem Erben eines regul√§ren Smart-Vertrags Funktionen, die urspr√ºnglich nicht von Blockchain-Mechanismen unterst√ºtzt wurden?  Tats√§chlich besteht der Orakelservice nicht nur aus Vertr√§gen mit Hilfsfunktionen.  Die Hauptarbeit zum Abrufen von Daten wird von einem externen Dienst erledigt.  Intelligente Vertr√§ge bilden Anwendungen f√ºr den Zugriff auf externe Daten und f√ºgen sie in die Blockchain ein.  Externer Dienst - √ºberwacht neue Bl√∂cke der Blockchain und f√ºhrt sie aus, wenn sie eine Anwendung erkennt.  Schematisch kann dies wie folgt dargestellt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/b0/ka/thb0kan1hwm75ijixmdrqtiwvum.png"></div><br><h3>  Datenquellen </h3><br>  Zus√§tzlich zu der ber√ºcksichtigten URL bietet oraclize 4 weitere Optionen (die Sie im Abschnitt √ºber die Preisgestaltung gesehen haben): <code>WolframAlpha</code> , <code>IPFS</code> , <code>random</code> und <code>computation</code> .  Betrachten wir jeden von ihnen. <br><br><h4>  1. URL </h4><br>  Das bereits besprochene Beispiel verwendet diese Datenquelle.  Dies ist die Quelle f√ºr HTTP-Anforderungen an verschiedene APIs.  Das Beispiel war wie folgt: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>);</code> </pre> <br>  Dies ist der Preis f√ºr Ether, und da API eine JSON-Zeichenfolge mit einem Datensatz bereitstellt, wird die Anforderung in einen JSON-Parser eingeschlossen und gibt nur das Feld zur√ºck, das wir ben√∂tigen.  In diesem Fall ist es GET, aber die Quell-URL unterst√ºtzt auch POST-Anforderungen.  Die Art der Anforderung wird automatisch durch ein zus√§tzliches Argument bestimmt.  Wenn es einen g√ºltigen JSON wie in diesem Beispiel gibt: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://shapeshift.io/sendamount).success.deposit"</span></span>, <span class="hljs-string"><span class="hljs-string">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span></span>)</code> </pre> <br>  dann wird die Anfrage als POST verarbeitet (die verwendete API wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> bei Interesse beschrieben) <br><br><h4>  2. WolframAlpha </h4><br>  √úber diese Datenquelle k√∂nnen Sie auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WolframAlpha-</a> Dienst zugreifen, der beispielsweise Antworten auf verschiedene Anfragen nach Fakten oder Berechnungen bietet <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúWolframAlpha‚Äù, ‚Äúpresident <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Russia‚Äù)</code> </pre> <br>  wird <code>Vladimir Putin</code> und darum bitten <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúWolframAlpha‚Äù, ‚Äúsolve x^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>‚Äù)</code> </pre> <br>  gibt <code>x = 2</code> . <br>  Wie Sie sehen k√∂nnen, war das Ergebnis unvollst√§ndig, da das Symbol ¬± verloren ging.  Bevor Sie diese Quelle verwenden, m√ºssen Sie daher √ºberpr√ºfen, ob der Wert einer bestimmten Anforderung in einem Smart-Vertrag verwendet werden kann.  Dar√ºber hinaus wird die Authentifizierung f√ºr Antworten nicht unterst√ºtzt. Daher empfehlen oraclize selbst, diese Quelle nur zum Testen zu verwenden. <br><br><h4>  3. IPFS </h4><br>  Wie Sie vielleicht erraten haben, k√∂nnen Sie den Inhalt einer Datei in IPFS mithilfe eines Multi-Hash abrufen.  Das Zeitlimit f√ºr den Empfang von Inhalten betr√§gt 20 Sekunden. <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúIPFS‚Äù, ‚ÄúQmTL5xNq9PPmwvM1RhxuhiYqoTJcmnaztMz6PQpGxmALkP‚Äù)</code> </pre> <br>  wird zur√ºckkehren <code>Hello, Habr!</code>  (wenn die Datei mit diesem Inhalt noch verf√ºgbar ist) <br><br><h4>  4. zuf√§llig </h4><br>  Die Generierung von Zufallszahlen funktioniert genauso wie andere Quellen. Wenn Sie jedoch <code>oraclize_query</code> , ist die Vorbereitung der Argumente zeitaufw√§ndig.  Um dies zu vermeiden, k√∂nnen Sie die <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> und nur die Ausf√ºhrungsverz√∂gerung (in Sekunden), die Anzahl der generierten Bytes und das <code>__callback</code> f√ºr den Aufruf von <code>__callback</code> . <br>  Die Verwendung von <code>random</code> hat einige Dinge zu beachten: <br><br><ul><li>  Um zu best√§tigen, dass die Zahl tats√§chlich zuf√§llig ist, wird eine spezielle Art der √úberpr√ºfung verwendet - Ledger, die in der Blockchain ausgef√ºhrt werden kann (im Gegensatz zu allen anderen, aber dazu sp√§ter mehr).  Dies bedeutet, dass Sie im Konstruktor des Smart-Vertrags diese √úberpr√ºfungsmethode durch die folgende Funktion festlegen m√ºssen: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_Ledger);</code> </pre> <br>  Und zu Beginn des R√ºckrufs sollte es eine √úberpr√ºfung selbst geben: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 _queryId, string _result, bytes _proof</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == <span class="hljs-number"><span class="hljs-number">0</span></span>) ); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  Diese √úberpr√ºfung erfordert ein echtes Netzwerk und funktioniert nicht mit Ganache. F√ºr lokale Tests k√∂nnen Sie diese Zeile vor√ºbergehend entfernen.  Das dritte Argument f√ºr <code>__callback</code> ist <code>_proof</code> der optionale Parameter <code>_proof</code> .  Es ist immer erforderlich, wenn einer der Best√§tigungstypen verwendet wird. </li><li>  Wenn Sie eine Zufallszahl f√ºr kritische Momente verwenden, um beispielsweise den Gewinner der Lotterie zu ermitteln, erfassen Sie Benutzereingaben, bevor Sie newRandomDSQuery senden.  Andernfalls kann folgende Situation auftreten: oraclize ruft _callback auf und die Transaktion ist f√ºr alle in der ausstehenden Liste sichtbar.  Gleichzeitig ist die Zufallszahl selbst sichtbar.  Wenn Benutzer grob gesagt weiterhin Wetten abschlie√üen k√∂nnen, k√∂nnen sie einen h√∂heren Gaspreis angeben und ihre Rate verschieben, bevor _callback ausgef√ºhrt wird, wobei sie im Voraus wissen, dass sie gewinnen werden. </li></ul><br><br><h4>  5. Berechnung </h4><br>  Dies ist die flexibelste der Quellen.  Sie k√∂nnen damit Ihre eigenen Skripte schreiben und als Datenquelle verwenden.  Die Berechnung erfolgt auf AWS.  Zur Ausf√ºhrung m√ºssen Sie die Docker-Datei beschreiben, sie mit beliebigen zus√§tzlichen Dateien in einem Zip-Archiv zusammenstellen und das Archiv in IPFS herunterladen.  Die Implementierung muss die folgenden Bedingungen erf√ºllen: <br><br><ul><li>  Schreiben Sie die Antwort, die Sie zur√ºckgeben m√∂chten, mit der letzten Zeile in stdout </li><li>  Die Antwort darf nicht mehr als 2500 Zeichen umfassen </li><li>  Die Initialisierung und Ausf√ºhrung sollte insgesamt nicht l√§nger als 5 Minuten dauern </li></ul><br>  Als Beispiel daf√ºr betrachten wir, wie die einfachste Vereinigung der √ºbertragenen Zeilen durchgef√ºhrt und das Ergebnis zur√ºckgegeben werden kann. <br><br>  Dockerfile: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 MAINTAINER <span class="hljs-string"><span class="hljs-string">"info@rubyruby.ru"</span></span> CMD <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG0</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG1</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG2</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG3</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Umgebungsvariablen <code>ARG0</code> , <code>ARG1</code> usw.  - Dies sind die Parameter, die zusammen mit der Anfrage √ºbergeben werden. <br>  F√ºgen Sie die Docker-Datei zum Archiv hinzu, starten Sie den ipfs-Server und f√ºgen Sie dieses Archiv dort hinzu <br><br><pre> <code class="bash hljs">$ zip concatenation.zip Dockerfile $ ipfs daemon &amp; $ ipfs add concatenation.zip QmWbnw4BBFDsh7yTXhZaTGQnPVCNY9ZDuPBoSwB9A4JNJD</code> </pre> <br>  Wir verwenden den resultierenden Hash, um die Anfrage √ºber <code>oraclize_query</code> im Smart-Vertrag zu senden: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"computation"</span></span>, [<span class="hljs-string"><span class="hljs-string">"QmVAS9TNKGqV49WTEWv55aMCTNyfd4qcGFFfgyz7BYHLdD"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s2"</span></span>, <span class="hljs-string"><span class="hljs-string">"s3"</span></span>, <span class="hljs-string"><span class="hljs-string">"s4"</span></span>]);</code> </pre> <br>  Als Argument wird ein Array verwendet, bei dem das erste Element der Archiv-Multihash ist und der Rest die Parameter sind, die in die Umgebungsvariablen fallen. <br><br>  Wenn Sie auf den Abschluss der Anforderung warten, gibt <code>__callback</code> Ergebnis <code>s1 s2 s3 s4</code> . <br><br><h3>  Parser-Helfer und Unterabfragen </h3><br>  Aus der von einer beliebigen Quelle zur√ºckgegebenen Antwort k√∂nnen Sie nur die erforderlichen Informationen mit einer Reihe von Hilfsprogrammen vorab ausw√§hlen, z. <br><br><h4>  1. JSON-Parser </h4><br>  Sie haben diese Methode im allerersten Beispiel gesehen, in dem nur der Preis aus dem Ergebnis von coinmarketcap zur√ºckgegeben wurde: <br><br><pre> <code class="bash hljs">json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd</code> </pre> <br>  Der Anwendungsfall ist ziemlich offensichtlich und kehrt zum Beispiel zur√ºck: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"symbol"</span></span>: <span class="hljs-string"><span class="hljs-string">"ETH"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rank"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"462.857"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_btc"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0621573"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"24h_volume_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"1993200000.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"market_cap_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"46656433775.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"available_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"total_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_supply"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_1h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-0.5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_24h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-3.02"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_7d"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.93"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"1532064934"</span></span> } ]</code> </pre> <br>  Da dies ein Array ist, nehmen wir das Element <code>0</code> und daraus das Feld <code>price_usd</code> <br><br><h4>  2. XML </h4><br>  Die Verwendung √§hnelt JSON, zum Beispiel: <br><br><pre> <code class="bash hljs">xml(https://informer.kovalut.ru/webmaster/getxml.php?kod=7701).Exchange_Rates.Central_Bank_RF.USD.New.Exch_Rate</code> </pre> <br><h4>  3. HTML </h4><br>  Sie k√∂nnen XHTML mit XPath analysieren.  Holen Sie sich zum Beispiel eine Marktkapitalisierung mit Etherscan: <br><br><pre> <code class="bash hljs">html(https://etherscan.io/).xpath(string(//*[contains(@href, <span class="hljs-string"><span class="hljs-string">'/stat/supply'</span></span>)]/font))</code> </pre> <br>  <code>MARKET CAP OF $46.148 BillionB</code> <br><br><h4>  4. Bin√§rer Helfer </h4><br>  Erm√∂glicht das Ausschneiden von St√ºcken aus Rohdaten mithilfe der Slice-Funktion (Versatz, L√§nge).  Das hei√üt, wir haben zum Beispiel eine Datei mit dem Inhalt von "abc": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> &gt; example.bin</code> </pre> <br>  Stellen Sie es auf IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add example.bin added Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE</code> </pre> <br>  Schneiden Sie nun 1 Zeichen aus der Mitte: <br><br><pre> <code class="javascript hljs">binary(Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE).slice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  In der Antwort erhalten wir <code>b</code> <br><br>  Wie Sie vielleicht bemerkt haben, wurde im Fall des bin√§ren Helfers nicht die IP-Quelle verwendet, sondern IPFS.  In der Tat k√∂nnen Parser auf alle Quellen angewendet werden. Nehmen wir an, es ist nicht erforderlich, JSON auf das anzuwenden, was die URL zur√ºckgibt. Sie k√∂nnen der Datei solchen Inhalt hinzuf√ºgen: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"one"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"two"</span></span>:<span class="hljs-string"><span class="hljs-string">"2"</span></span> }</code> </pre> <br>  F√ºgen Sie es zu IPFS hinzu: <br><br><pre> <code class="bash hljs">$ ipfs add test.json added QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp</code> </pre> <br>  Und dann so zerlegen: <br><br><pre> <code class="bash hljs">json(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one</code> </pre> <br>  Wir bekommen <code>1</code> <br><br>  Ein besonders interessanter Anwendungsfall ist die Kombination von Datenquellen und Parsern in einer Anfrage.  Dies ist mithilfe einer separaten <code>nested</code> Datenquelle m√∂glich.  Wir verwenden die gerade erstellte Datei in einer komplexeren Anforderung (Hinzuf√ºgen von Werten in zwei Feldern): <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">WolframAlpha</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one} to <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).two}</code> </pre> <br>  Wir bekommen <code>3</code> <br>  Die Anforderung wird wie folgt gebildet: Geben Sie die <code>nested</code> Datenquelle an, f√ºgen Sie dann f√ºr jede Anforderung den Namen der Quelle davor in eckigen Klammern hinzu und rahmen Sie zus√§tzlich alle Unterabfragen in <code>${..}</code> . <br><br><h3>  Testen </h3><br>  Oraclize bietet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√ºtzlichen Service</a> zur Validierung von Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> ohne dass intelligente Vertr√§ge erforderlich sind.  Gehen Sie einfach hinein, w√§hlen Sie eine Datenquelle, eine √úberpr√ºfungsmethode und Sie k√∂nnen sehen, dass sie zu __callback zur√ºckkehrt, wenn Sie die entsprechenden Anforderungen senden <br><br>  F√ºr die lokale √úberpr√ºfung in Verbindung mit einem Smart-Vertrag k√∂nnen Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezielle Version der Remix-IDE verwenden</a> , die oraclize-Anforderungen unterst√ºtzt. <br><br>  Und um lokal mit Ganache zu pr√ºfen, ben√∂tigen Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum-Br√ºcke</a> , die intelligente Vertr√§ge f√ºr Ihr Testnetz bereitstellt oder aktiviert.  F√ºgen Sie zum Testen zun√§chst die folgende Zeile zum Konstruktor Ihres Vertrags hinzu: <br><br><pre> <code class="javascript hljs">OAR = OraclizeAddrResolverI(<span class="hljs-number"><span class="hljs-number">0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475</span></span>);</code> </pre> <br>  laufen <br><br><pre> <code class="bash hljs">ganache-cli</code> </pre> <br>  Dann <br><br><pre> <code class="bash hljs">node bridge --dev</code> </pre> <br>  Warten Sie, bis die Vertr√§ge tot sind und Sie testen k√∂nnen.  In der Ausgabe der <code>node bridge</code> sehen Sie die gesendeten Anforderungen und die empfangenen Antworten. <br><br>  Eine weitere Hilfe nicht nur beim Testen, sondern auch beim tats√§chlichen Gebrauch ist die M√∂glichkeit, Anfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu √ºberwachen.  Wenn Sie in einem √∂ffentlichen Netzwerk anfordern, k√∂nnen Sie den Hash der Transaktion verwenden, in der die Anforderung ausgef√ºhrt wird.  Wenn Sie die Authentifizierung verwenden, beachten Sie, dass diese garantiert nur an das Hauptnetz gesendet werden. In anderen Netzwerken kann 0 zur√ºckgegeben werden. Wenn sich die Anforderung im lokalen Netzwerk befand, k√∂nnen Sie die Anforderungs-ID verwenden, die <code>oraclize_query</code> .  √úbrigens wird empfohlen, diese ID immer in einer √§hnlichen Zuordnung zu belassen: <br><br><pre> <code class="javascript hljs">mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32</span></span></span><span class="hljs-function">=&gt;</span></span>bool) validIds;</code> </pre> <br>  Markieren Sie zum Zeitpunkt der Anforderung die gesendete ID als <code>true</code> : <br><br><pre> <code class="javascript hljs">bytes32 queryId = oraclize_query(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">); validIds[queryId] = true;</span></span></code> </pre><br>  √úberpr√ºfen Sie anschlie√üend in <code>__callback</code> , ob die Anforderung mit dieser ID noch nicht verarbeitet wurde: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(validIds[myid] != bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(msg.sender == oraclize_cbAddress()); validIds[myid] = bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Dies ist erforderlich, da <code>__callback</code> bei einer Anforderung aufgrund der Besonderheiten der Oraclize-Mechanismen mehrmals aufgerufen werden kann. <br><br><h3>  Authentifizierung </h3><br>  In der Tabelle mit den Quellen konnten Sie sehen, dass verschiedene Quellen verschiedene Arten von Best√§tigungen unterst√ºtzen k√∂nnen und unterschiedliche Geb√ºhren erhoben werden k√∂nnen.  Dies ist ein sehr wichtiger Teil von oraclize, aber eine detaillierte Beschreibung dieser Mechanismen ist ein separates Thema. <br><br>  Der zumindest von uns am h√§ufigsten verwendete Mechanismus ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLSNotary</a> mit Speicher in IPFS.  Die Speicherung in IPFS ist effizienter, da <code>__callback</code> die Beweise selbst nicht <code>__callback</code> (m√∂glicherweise im Bereich von <code>__callback</code> 5 Kilobyte), sondern einen viel kleineren Multi-Hash.  Um diesen Typ anzugeben, f√ºgen Sie im Konstruktor eine Zeile hinzu: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</code> </pre> <br>  Wir k√∂nnen nur sagen, dass dieser Typ uns grob gesagt vor der Ungenauigkeit der von Oraclize empfangenen Daten sch√ºtzt.  Oraclize verwendet jedoch Amazon-Server, die als Pr√ºfer fungieren, sodass sie nur vertrauen m√ºssen. <br><br>  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr. <br><br><h2>  Fazit </h2><br>  Oraclize bietet Tools, die die Anzahl der Anwendungsf√§lle f√ºr intelligente Vertr√§ge erheblich erh√∂hen, sowie IPFS, das in mehreren Versionen von Oracle-Abfragen angezeigt wird.  Das Hauptproblem besteht darin, dass wir wieder externe Daten verwenden, die den Bedrohungen ausgesetzt sind, vor denen die Blockchain gesch√ºtzt sein sollte: Zentralisierung, Blockierungsfunktionen, Code√§nderungen, Spoofing.  Obwohl dies alles unvermeidlich ist und die M√∂glichkeit, Daten abzurufen, sehr n√ºtzlich und praktikabel ist, m√ºssen Sie sich nur dar√ºber im Klaren sein, warum die Verwendung von Blockchain in das Projekt eingef√ºhrt wurde und ob die Verwendung externer unzuverl√§ssiger Quellen den Nutzen auf Null reduziert. <br><br>  Wenn Sie an einigen Entwicklungsthemen zu Ethereum interessiert sind, die in diesen Artikeln noch nicht ver√∂ffentlicht wurden - schreiben Sie in die Kommentare, vielleicht werden wir sie im Folgenden behandeln. <br><br>  Eintauchen in die Entwicklung von Ethereum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Web3.js und Gas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Benutzeranwendung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Bereitstellen und Debuggen in Tr√ºffel, Ganache, Infura</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417681/">https://habr.com/ru/post/de417681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417671/index.html">Neue Funktionen der Programmiersprache ABAP in Webinaren von SAP</a></li>
<li><a href="../de417673/index.html">Die Untersuchung f√ºhrt zu Solar Dozor: 5 nicht standardisierte F√§lle, die DLP enth√ºllte</a></li>
<li><a href="../de417675/index.html">Lokalisierung von Spielen und Anwendungen in Unity. Schnell und einfach</a></li>
<li><a href="../de417677/index.html">Migrieren eines Projekts von yii1 nach yii2 durch einen einmaligen Job</a></li>
<li><a href="../de417679/index.html">Das schwere Erbe der Vergangenheit. Windows-Befehlszeilenprobleme</a></li>
<li><a href="../de417683/index.html">Veralteter Code - Code von Drittanbietern</a></li>
<li><a href="../de417685/index.html">Skillbox Friday Webinars: Kostenloses Weiterlernen</a></li>
<li><a href="../de417687/index.html">Asymmetrie des Lebens</a></li>
<li><a href="../de417689/index.html">Mobio spricht mit Appnext CEO √ºber CPI-Markt und Trends bei mobilen Anwendungen</a></li>
<li><a href="../de417691/index.html">Unser B√ºcherregal ist ein C # -Programmierer. Was ist mit dir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>