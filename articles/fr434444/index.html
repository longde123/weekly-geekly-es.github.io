<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐖 👩‍🏫 👩🏾‍🎤 Le problème avec les variables liées: comment transformer l'optimiseur d'ennemi en ami 👨🏽‍🚀 👩🏾‍🏭 🚳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article est Victor Varlamov ( varlamovVp18 ), OCP. 
 L'article original a été publié le 07/07/2017. 
 Remerciements particuliers à l'aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le problème avec les variables liées: comment transformer l'optimiseur d'ennemi en ami</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rdtex/blog/434444/">  L'auteur de l'article est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Varlamov</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">varlamovVp18</a> ), OCP. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article original a été</a> publié le 07/07/2017. <br>  Remerciements particuliers à l'auteur de la traduction - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">brutaltag</a> . <br><br>  Notre système de rapports exécute généralement des centaines de longues demandes qui sont déclenchées par divers événements.  Les paramètres de requête sont une liste de clients et un intervalle de temps (quotidien, hebdomadaire, mensuel).  En raison des données inégales dans les tables, une requête peut produire à la fois une ligne et un million de lignes, selon les paramètres du rapport (différents clients ont différents nombres de lignes dans les tables de faits).  Chaque rapport est réalisé sous la forme d'un package avec une fonction principale qui prend les paramètres d'entrée, effectue des transformations supplémentaires, puis ouvre un curseur statique avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des variables associées</a> et renvoie finalement ce curseur ouvert.  Le paramètre DB CURSOR_SHARING est défini sur FORCE. <br>  Dans une telle situation, il faut faire face à de mauvaises performances, à la fois dans le cas de la réutilisation du plan de requête par l'optimiseur, et lorsque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la</a> requête est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complètement analysée</a> avec des paramètres sous forme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">littéraux</a> .  Les variables liées peuvent provoquer un plan de requête sous-optimal. <br><a name="habracut"></a><br>  Dans son livre «Oracle Expert Practices», Alex Gorbachev raconte une histoire intéressante racontée par Tom Kite.  Chaque lundi pluvieux, les utilisateurs devaient faire face à un plan de requête modifié.  C'est difficile à croire, mais c'était: <br><blockquote>  «Selon les observations des utilisateurs finaux, lorsqu'il a beaucoup plu lundi, les performances de la base de données étaient terribles.  Tous les autres jours de la semaine ou le lundi, il n'y a eu aucun problème sans pluie.  Lors d'une conversation avec le DBA, Tom Kite a appris que les difficultés persistaient jusqu'à ce que la base de données soit forcée de redémarrer, après quoi les performances devenaient normales.  C'était une telle solution: lundi pluvieux - redémarrage. » </blockquote><br>  Il s'agit d'un cas réel, et le problème a été résolu complètement sans aucune magie, uniquement grâce à une excellente connaissance du fonctionnement d'Oracle.  Je montrerai la solution à la fin de l'article. <br>  Voici un petit exemple du fonctionnement des variables liées. <br>  Créez un tableau avec des données inégales. <br><br><pre><code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> VVP_HARD_PARSE_TEST(C1 <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, C2 <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, C3 VARCHAR2(<span class="hljs-number"><span class="hljs-number">300</span></span>)); TABLE created. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> VVP_HARD_PARSE_TEST <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> C1, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> &lt; <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MOD</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)=<span class="hljs-number"><span class="hljs-number">99</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">99</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> C2, RPAD(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>) C3 <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DUAL <span class="hljs-keyword"><span class="hljs-keyword">CONNECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IND_VVP_HARD_PARSE_TEST_C2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> VVP_HARD_PARSE_TEST(C2); INDEX created. SQL&gt; EXEC DBMS_STATS.GATHER_TABLE_STATS(OWNNAME =&gt; USER, TABNAME =&gt; 'VVP_HARD_PARSE_TEST', CASCADE =&gt; TRUE, METHOD_OPT=&gt;'FOR ALL INDEXED COLUMNS SIZE 254'); PL/SQL PROCEDURE successfully completed. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> histogram <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> user_tab_columns <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> table_name = <span class="hljs-string"><span class="hljs-string">'VVP_HARD_PARSE_TEST'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> column_name = <span class="hljs-string"><span class="hljs-string">'C2'</span></span>; HISTOGRAM <span class="hljs-comment"><span class="hljs-comment">--------- FREQUENCY SQL&gt; SELECT c2, COUNT(*) FROM VVP_HARD_PARSE_TEST GROUP BY c2 ORDER BY 1; C2 COUNT(*) ----------------------- 1 8 99 10000 1000000 989992</span></span></code> </pre> <br><br>  En d'autres termes, nous avons une table VVP_HARD_PARSE_TEST avec un million de lignes, où dans 10 000 cas le champ est C2 = 99, 8 enregistrements avec C2 = 1 et le reste avec C2 = 1 000 000. L'histogramme à travers le champ C2 indique l'optimiseur Oracle sur cette distribution de données.  Cette situation est connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">répartition inégale des données</a> , et un histogramme peut vous aider à choisir le bon plan de requête en fonction des données demandées. <br><br>  Nous observons des requêtes simples sur ce tableau.  Evidemment pour la demande <br><br> <code>SELECT * FROM VVP_HARD_PARSE_TEST WHERE c2 = :p</code> <br> <br>  si p = 1, alors INDEX RANGE SCAN est le meilleur choix, pour le cas p = 1000000, il est préférable d'utiliser FULL TABLE SCAN.  Les requêtes Query1 et Query1000000 sont identiques, à l'exception du texte dans les commentaires, cela est fait pour obtenir différents identificateurs de plan de requête. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> p <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>; v NUMBER; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> V := <span class="hljs-number"><span class="hljs-number">0</span></span>; p := 1000000; FOR rec IN (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*+query1000000*/</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> VVP_HARD_PARSE_TEST <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c2 = p) <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> V := v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; dbms_output.put_line(v); v : =0; p := 1; FOR rec IN (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*+query1000000*/</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> VVP_HARD_PARSE_TEST <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c2 = p) <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> V := v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; dbms_output.put_line(v); <span class="hljs-comment"><span class="hljs-comment">----------------- V := 0; p := 1; FOR rec IN (SELECT /*+query1*/ * FROM VVP_HARD_PARSE_TEST WHERE c2 = p) LOOP V := v + 1; END LOOP; dbms_output.put_line(v); v := 0; p := 1000000; FOR rec IN (SELECT /*+query1*/ * FROM VVP_HARD_PARSE_TEST WHERE c2 = p) LOOP V := v + 1; END LOOP; dbms_output.put_line(v); END;</span></span></code> </pre><br>  Examinons maintenant les plans de requête: <br><br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sql_id, child_number, executions, plan_hash_value, sql_text <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> v$<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> sql_text <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'SELECT % * FROM VVP_HARD_PARSE_TEST WHERE C2%'</span></span>; SQL_ID CHILD_NUMBER EXECUTIONS PLAN_HASH_VALUE SQL_TEXT <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------- 7rqnhhp6pahw2 0 2 2782757451 SELECT /*+query1000000*/ * FROM VVP_HARD_PARSE_TEST WHERE C2 = :B1 7xwt28hvw3u9s 0 2 2463783749 SELECT /*+query1*/ * FROM VVP_HARD_PARSE_TEST WHERE C2 = :B1 SQL&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '7rqnhhp6pahw2', format =&gt; 'basic +peeked_binds')); SELECT /*+query1000000*/ * FROM VVP_HARD_PARSE_TEST WHERE C2 = :B1 PLAN hash VALUE: 2782757451 ------------------------------------------------- | Id | Operation | Name | ------------------------------------------------- | 0 | SELECT STATEMENT | | | 1 | TABLE ACCESS FULL| VVP_HARD_PARSE_TEST | ------------------------------------------------- Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1000000 SQl&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '7xwt28hvw3u9s', format =&gt; 'basic +peeked_binds')); SELECT /*+query1*/ * FROM VVP_HARD_PARSE_TEST WHERE C2 = :B1 PLAN hash VALUE: 2463783749 ------------------------------------------------------------------ | Id | Operation | Name | ------------------------------------------------------------------ | 0 | SELECT STATEMENT | | | 1 | TABLE ACCESS BY INDEX ROWID| VVP_HARD_PARSE_TEST | | 2 | INDEX RANGE SCAN | IND_VVP_HARD_PARSE_TEST_C2 | ------------------------------------------------------------------ Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1</span></span></code> </pre><br>  Comme vous pouvez le voir, un plan pour différentes demandes n'est créé qu'une seule fois, au moment de la première exécution (un seul curseur enfant avec CHILD_NUMBER = 0 existe pour chaque demande).  Chaque requête est exécutée deux fois (EXECUTION = 2).  Lors d'une analyse matérielle, Oracle récupère les valeurs des variables associées et sélectionne un plan en fonction de ces valeurs.  Mais il utilise le même plan pour la prochaine exécution, même si les variables associées ont changé lors de la deuxième exécution.  Des plans non optimaux sont utilisés - Query1000000 avec la variable C2 = 1 utilise FULL TABLE SCAN au lieu de INDEX RANGE SCAN, et vice versa. <br><br>  Il est clair que corriger l'application et utiliser des paramètres comme littéraux dans la requête est le moyen le plus approprié pour résoudre le problème, mais cela conduit à du SQL dynamique avec ses lacunes connues.  Une autre façon consiste à désactiver la requête pour les variables liées ( <code>ALTER SESSION SET "_OPTIM_PEEK_USER_BINDS" = FALSE</code> ) ou à supprimer les histogrammes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ). <br><br>  L'une des solutions possibles est une utilisation alternative des politiques d'accès aux données, également connues sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base de données privée virtuelle</a> (contrôle d'accès détaillé, contrôle d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">accès fin</a> , contrôle au niveau des lignes).  Cela vous permet de modifier les demandes à la volée et peut donc entraîner une analyse complète du plan de demande chaque fois que la demande utilise un contrôle d'accès détaillé.  Cette technique est décrite en détail dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Randalph Geist</a> .  L'inconvénient de cette méthode est le nombre croissant d'analyses complètes et l'incapacité à manipuler les plans de requête. <br><br>  Voyez ce que nous allons faire maintenant.  Après analyse de nos données, nous décidons de diviser les clients en trois catégories - Grand, Moyen et Petit (LMS ou 9-5-1) - en fonction du nombre de transactions ou de transactions au cours de l'année.  De plus, le nombre de lignes dans le rapport dépend strictement de la période: mensuelle - grande, hebdomadaire - moyenne, quotidienne - petite ou 9-5-1.  De plus, la solution est simple - nous allons faire dépendre le prédicat de la politique de sécurité de chaque catégorie et de chaque période.  Ainsi, pour chaque demande, nous obtenons 9 curseurs enfants possibles.  De plus, les requêtes avec des politiques différentes nous mèneront aux mêmes identifiants de requête, ce qui permet d'implémenter SQL PLAN MANAGEMENT (sql plan baseline). <br><br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> HARD_PARSE_TABLE <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dual; TABLE created. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> CLIENTS_HP_STATISTICS (client_seqno <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, client_id VARCHAR2(<span class="hljs-number"><span class="hljs-number">255</span></span>), cnt_year <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>); TABLE created. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> CLIENTS_HP_STATISTICS (client_seqno, client_id, cnt_year) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'SMALL CLIENT'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); 1 ROW inserted. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> CLIENTS_HP_STATISTICS (client_seqno, client_id, cnt_year) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-string"><span class="hljs-string">'MIDDLE CLIENT'</span></span>, <span class="hljs-number"><span class="hljs-number">50001</span></span>); 1 ROW inserted. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> CLIENTS_HP_STATISTICS (client_seqno, client_id, cnt_year) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1000000</span></span>,<span class="hljs-string"><span class="hljs-string">'LARGE CLIENT'</span></span>, <span class="hljs-number"><span class="hljs-number">989992</span></span>); 1 ROW inserted. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> FORCE_HARD_PARSE_PKG <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> gc_small <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span> := <span class="hljs-number"><span class="hljs-number">1</span></span>; gc_middle CONSTANT NUMBER := 5; gc_large CONSTANT NUMBER := 9; gc_client_middle CONSTANT NUMBER := 50000; gc_client_large CONSTANT NUMBER := 500000; gc_daterange_middle CONSTANT NUMBER := 10; gc_daterange_large CONSTANT NUMBER := 50; FUNCTION FORCE_HARD_PARSE(in_schema VARCHAR2, in_object VARCHAR2) RETURN VARCHAR2; PROCEDURE SET_PREDICATE (n NUMBER); PROCEDURE SET_PREDICATES (p_daterange NUMBER DEFAULT NULL, p_clientrange NUMBER DEFAULT NULL); PROCEDURE CALC_PREDICATE; PROCEDURE CALC_PREDICATES(p_date_interval NUMBER DEFAULT 1, p_client_seqno NUMBER DEFAULT NULL, p_client_id VARCHAR2 DEFAULT NULL, p_client_seqno_list VARCHAR2 DEFAULT NULL ); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> FORCE_HARD_PARSE_PKG; PACKAGE created. SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> FORCE_HARD_PARSE_PKG <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> g_predicate <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- g_daterange || 0 || g_clientrange g_daterange NUMBER; -- 1 - small, 5 - middle, 9 - large g_clientrange NUMBER; -- 1 - small, 5 - middle, 9 - large -- FUNCTION FORCE_HARD_PARSE(in_schema VARCHAR2, in_object VARCHAR2) RETURN VARCHAR2 IS BEGIN IF NVL(g_predicate, 0) = 0 THEN RETURN NULL; ELSE RETURN TO_CHAR(g_predicate, 'TM') || ' = ' || TO_CHAR(g_predicate, 'TM'); END IF; END FORCE_HARD_PARSE; -- PROCEDURE SET_PREDICATE (n NUMBER) IS BEGIN g_predicate := n; END; PROCEDURE SET_PREDICATES (p_daterange NUMBER DEFAULT NULL, p_clientrange NUMBER DEFAULT NULL) IS BEGIN IF p_daterange IS NOT NULL THEN g_daterange := p_daterange; CALC_PREDICATE; END IF; IF p_clientrange IS NOT NULL THEN g_clientrange := p_clientrange; CALC_PREDICATE; END IF; END SET_PREDICATES; PROCEDURE CALC_PREDICATE IS BEGIN g_predicate := NVL(g_daterange, 0) * 100 + NVL(g_clientrange, 0); END CALC_PREDICATE; PROCEDURE CALC_PREDICATES (p_date_interval NUMBER DEFAULT 1, p_client_seqno NUMBER DEFAULT NULL, p_client_id VARCHAR2 DEFAULT NULL, p_client_seqno_list VARCHAR2 DEFAULT NULL) IS v_cnt NUMBER; BEGIN IF p_date_interval IS NOT NULL THEN g_daterange := CASE WHEN p_date_interval &lt; gc_daterange_middle THEN gc_small WHEN p_date_interval &lt; gc_daterange_large THEN gc_middle ELSE gc_large END; CALC_PREDICATE; END IF; IF COALESCE(p_client_seqno, p_client_id, p_client_seqno_list) IS NOT NULL THEN SELECT NVL(SUM(cnt_year), 0) AS cnt INTO v_cnt FROM CLIENTS_HP_STATISTICS t WHERE 1=1 AND (p_client_seqno IS NULL OR p_client_seqno = t.client_seqno) AND (p_client_id IS NULL OR p_client_id = t.client_id) AND (p_client_seqno_list IS NULL OR t.client_seqno IN (SELECT SUBSTR(s, CASE WHEN LEVEL &gt; 1 THEN INSTR(s, ',', 1, LEVEL - 1 ) + 1 ELSE 1 END, INSTR(s, ',', 1, LEVEL) – CASE WHEN LEVEL &gt; 1 THEN INSTR(s, ',', 1, LEVEL – 1) + 1 ELSE 1 END) FROM (SELECT p_client_seqno_list||',' AS s FROM DUAL) CONNECT BY INSTR(s, ',', 1, LEVEL) &gt; 0)); g_clientrange := CASE WHEN v_cnt &gt; gc_client_large THEN gc_large WHEN v_cnt &gt; gc_client_middle THEN gc_middle ELSE gc_small END; CALC_PREDICATE; END IF; END CALC_PREDICATES; END FORCE_HARD_PARSE_PKG; PACKAGE BODY created. SQL&gt; EXEC DBMS_RLS.ADD_POLICY (USER, 'HARD_PARSE_TABLE', 'HARD_PARSE_POLICY', USER, 'FORCE_HARD_PARSE_PKG.FORCE_HARD_PARSE', 'select'); PL/SQL PROCEDURE successfully completed.</span></span></code> </pre><br>  Maintenant, si nous voulons intégrer une telle technologie dans le rapport, nous devons ajouter HARD_PARSE_TABLE à la requête (cela ne la gâchera pas un peu) et appeler CALC_PREDICATES avant l'exécution de la requête principale. <br><br>  Voyons comment cette technique peut transformer l'exemple précédent: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> p <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>; v NUMBER; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> V := <span class="hljs-number"><span class="hljs-number">0</span></span>; p := 1000000; FORCE_HARD_PARSE_PKG.SET_PREDICATE(1000000); FOR rec IN (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*+query_hp1000000*/</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c2 = p) <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> V := v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; dbms_output.put_line(v); v := 0; p := 1; FORCE_HARD_PARSE_PKG.SET_PREDICATE(1); FOR rec IN (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*+query_hp1000000*/</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c2 = p) <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> V := v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; dbms_output.put_line(v); <span class="hljs-comment"><span class="hljs-comment">----------------- V := 0; p := 1; FORCE_HARD_PARSE_PKG.SET_PREDICATE(1); FOR rec IN (SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE c2 = p) LOOP V := v + 1; END LOOP; dbms_output.put_line(v); v := 0; p := 1000000; FORCE_HARD_PARSE_PKG.SET_PREDICATE(1000000); FOR rec IN (SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE c2 = p) LOOP V := v + 1; END LOOP; dbms_output.put_line(v); END;</span></span></code> </pre><br>  Regardons les plans d'exécution: <br><br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sql_id, child_number, executions, plan_hash_value, sql_text, s.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> v$<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> sql_text <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'SELECT % * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE c2%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>; SQL_ID CHILD_NUMBER EXECUTIONS PLAN_HASH_VALUE SQL_TEXT <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- 7wva3uqbgh4qf 0 1 1136240498 SELECT /*+query_hp1000000*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 7wva3uqbgh4qf 1 1 3246475190 SELECT /*+query_hp1000000*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 8cju3tfjvwm1p 0 1 3246475190 SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 8cju3tfjvwm1p 1 1 1136240498 SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 -- SQL&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '7wva3uqbgh4qf', cursor_child_no =&gt; 0, format =&gt; 'basic +peeked_binds')); SELECT /*+query_hp1000000*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 PLAN hash VALUE: 1136240498 ---------------------------------------------------- | Id | Operation | Name | ---------------------------------------------------- | 0 | SELECT STATEMENT | | | 1 | MERGE JOIN CARTESIAN| | | 2 | TABLE ACCESS FULL | HARD_PARSE_TABLE | | 3 | BUFFER SORT | | | 4 | TABLE ACCESS FULL | VVP_HARD_PARSE_TEST | ---------------------------------------------------- Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1000000 -- SQL&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '7wva3uqbgh4qf', cursor_child_no =&gt; 1, format =&gt; 'basic +peeked_binds')); SELECT /*+query_hp1000000*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 PLAN hash VALUE: 3246475190 -------------------------------------------------------------------- | Id | Operation | Name | -------------------------------------------------------------------- | 0 | SELECT STATEMENT | | | 1 | MERGE JOIN CARTESIAN | | | 2 | TABLE ACCESS FULL | HARD_PARSE_TABLE | | 3 | BUFFER SORT | | | 4 | TABLE ACCESS BY INDEX ROWID| VVP_HARD_PARSE_TEST | | 5 | INDEX RANGE SCAN | IND_VVP_HARD_PARSE_TEST_C2 | -------------------------------------------------------------------- Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1 -- SQl&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '8cju3tfjvwm1p', cursor_child_no =&gt; 0, format =&gt; 'basic +peeked_binds')); SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 PLAN hash VALUE: 3246475190 -------------------------------------------------------------------- | Id | Operation | Name | -------------------------------------------------------------------- | 0 | SELECT STATEMENT | | | 1 | MERGE JOIN CARTESIAN | | | 2 | TABLE ACCESS FULL | HARD_PARSE_TABLE | | 3 | BUFFER SORT | | | 4 | TABLE ACCESS BY INDEX ROWID| VVP_HARD_PARSE_TEST | | 5 | INDEX RANGE SCAN | IND_VVP_HARD_PARSE_TEST_C2 | -------------------------------------------------------------------- Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1 -- SQL&gt; SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id =&gt; '8cju3tfjvwm1p', cursor_child_no =&gt; 1, format =&gt; 'basic +peeked_binds')); SELECT /*+query_hp1*/ * FROM VVP_HARD_PARSE_TEST, HARD_PARSE_TABLE WHERE C2 = :B1 PLAN hash VALUE: 1136240498 ---------------------------------------------------- | Id | Operation | Name | ---------------------------------------------------- | 0 | SELECT STATEMENT | | | 1 | MERGE JOIN CARTESIAN| | | 2 | TABLE ACCESS FULL | HARD_PARSE_TABLE | | 3 | BUFFER SORT | | | 4 | TABLE ACCESS FULL | VVP_HARD_PARSE_TEST | ---------------------------------------------------- Peeked Binds (IDENTIFIED BY position): -------------------------------------- 1 - :B1 (NUMBER): 1000000</span></span></code> </pre><br>  Ça a l'air super!  Chaque requête est exécutée deux fois, avec différents curseurs enfants et différents plans.  Pour le paramètre C2 = 1 000 000, nous voyons FULL TABLE SCAN dans les deux requêtes, et pour le paramètre C1 = 1, nous voyons toujours INDEX RANGE SCAN. <br><br>  Au final, je donne une solution au cas des lundis pluvieux: <br><br><blockquote>  «Il s'avère que chaque week-end du dimanche, il y avait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sauvegarde à froid</a> , de sorte que tous les plans de requête ont été régénérés lors de la première exécution lundi matin.  L'un des employés a généralement commencé son travail plus tôt que les autres, et son plan de demande a été bien exécuté pour les autres utilisateurs au cours de la semaine.  Cependant, s'il pleuvait, cet utilisateur était en retard au début de la journée de travail en raison de problèmes avec son itinéraire du matin.  Ensuite, le calcul par lots des rapports a été le premier à démarrer, mais le plan de requête était complètement mauvais pour les cas restants en raison de valeurs inappropriées des variables associées. » </blockquote><br>  Et quelques vues système utiles: <br>  • <code>dba_tab_histograms, all_tab_histograms, user_tab_histograms</code> <br>  • <code>v$vpd_policy</code> <br>  • <code>v$sql_bind_capture</code> <br>  • <code>dba_hist_sqlbind</code> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434444/">https://habr.com/ru/post/fr434444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434426/index.html">Liste de contrôle: comment soumettre des rapports sur le régime fiscal simplifié pour 2018</a></li>
<li><a href="../fr434428/index.html">Nous assemblons, réparons et portons une montre numérique vintage</a></li>
<li><a href="../fr434430/index.html">IBM a montré une puce de mémoire analogique à changement de phase de 8 bits</a></li>
<li><a href="../fr434440/index.html">[Vidéo] Navires de guerre, bots et tir d'argent sur des serveurs</a></li>
<li><a href="../fr434442/index.html">Cosmonautique 2018 - résultats de l'année</a></li>
<li><a href="../fr434446/index.html">Pourquoi je n'aime pas y aller</a></li>
<li><a href="../fr434448/index.html">Nous couvrons les tests A / B avec des tests UI. Comment ne pas se perdre dans le code natif</a></li>
<li><a href="../fr434450/index.html">TeamLead Conf: «Le MBA numérique n'est pas un camarade»</a></li>
<li><a href="../fr434452/index.html">AXIS vs IDIS - la bataille des fabricants de vidéosurveillance</a></li>
<li><a href="../fr434456/index.html">Où avons-nous obtenu la bouteille?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>