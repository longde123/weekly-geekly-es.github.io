<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèΩ ‚öúÔ∏è üòª R√©soudre un Crackme simple pour Sega Mega Drive üîü üî™ üëèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous 





 Malgr√© ma grande exp√©rience dans les jeux invers√©s pour Sega Mega Drive , je n'ai jamais d√©cid√© de craquer pour cela, et ils ne ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©soudre un Crackme simple pour Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Bonjour √† tous </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Malgr√© ma grande exp√©rience dans les jeux invers√©s pour <code>Sega Mega Drive</code> , je n'ai jamais d√©cid√© de craquer pour cela, et ils ne m'ont pas √©t√© rencontr√©s sur Internet.  Mais, l'autre jour, il y avait un dr√¥le de crackie qui voulait r√©soudre.  Je partage avec vous la d√©cision ... <a name="habracut"></a></p><br><h2 id="opisanie">  La description </h2><br><p>  La description de la t√¢che et le rhum lui-m√™me peuvent √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">t√©l√©charg√©s ici</a> . </p><br><p>  Malgr√© le fait que la liste des ressources indique Hydra, le standard de facto parmi les outils pour le d√©bogage et l'inversion de jeux sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Sega</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Smd Ida Tools</a> .  Il a tout ce dont vous avez besoin pour r√©soudre cette cr√®me: </p><br><ul><li>  Chargeur de rhum pour Ida </li><li>  D√©bogueur </li><li>  Afficher et modifier la m√©moire RAM / VDP </li><li>  Afficher des informations presque compl√®tes sur VDP </li></ul><br><p>  Nous d√©posons la derni√®re version dans les plugins pour Ide et commen√ßons √† regarder ce que nous avons. </p><br><h2 id="reshenie">  Solution </h2><br><p>  Le lancement de tout jeu Shogi commence par l'ex√©cution du vecteur <code>Reset</code> .  Un pointeur peut √™tre trouv√© dans le deuxi√®me DWORD depuis le d√©but du rhum. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Nous voyons quelques fonctions non identifi√©es commen√ßant √† l'adresse <code>0x27A</code> .  Voyons ce qu'il y a. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  D'apr√®s ma propre exp√©rience, je dirai que cela ressemble g√©n√©ralement √† la fonction d'attente de la <code>VBLANK</code> interruption <code>VBLANK</code> .  Voyons o√π il y a d'autres appels √† la variable <code>byte_FF0026</code> : </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Nous voyons que le bit z√©ro est juste d√©fini dans l'interruption <code>VBLANK</code> .  Nous appelons donc la variable <code>vblank_ready</code> , et la fonction o√π elle est v√©rifi√©e est <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Ensuite, la fonction <code>sub_60E</code> est appel√©e par code.  Voyons ce qu'il y a: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  Ce que la premi√®re commande √©crit dans le <code>VDP_CTRL</code> est la commande de contr√¥le <code>VDP</code> .  Pour savoir ce qu'elle fait, nous maintenons cette commande et appuyons sur la touche <code>J</code> : </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Nous voyons que l'entr√©e dans <code>CRAM</code> (l'endroit o√π les palettes sont stock√©es) est initialis√©e.  Cela signifie que tout le code de fonction suivant d√©finit simplement une sorte de palette initiale.  Par cons√©quent, la fonction peut √™tre appel√©e <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Nous voyons que certaines commandes sont √† nouveau transf√©r√©es vers <code>VDP_CTRL</code> , puis appuyez √† nouveau sur <code>J</code> et d√©couvrez que cette commande initialise l'enregistrement dans la m√©moire vid√©o: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  De plus, pour comprendre ce qui y est transf√©r√© dans la m√©moire vid√©o, cela n'a aucun sens.  Par cons√©quent, nous appelons simplement la fonction <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Presque la m√™me chose se produit ici que dans la fonction pr√©c√©dente, donc sans entrer dans les d√©tails, nous appelons simplement la fonction <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  Il y a d√©j√† plus de code.  Et d'ailleurs, une autre fonction est appel√©e dans cette fonction.  Regardons juste l√† - dans <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Nous voyons que dans le registre <code>D0</code> commande pour <code>VDP_CTRL</code> , dans <code>D1</code> - la valeur que <code>VRAM</code> remplira, et dans <code>D2</code> et <code>D3</code> - la largeur et la hauteur du remplissage (car il s'av√®re que deux cycles: interne et externe).  Appelez la fonction fill_vram_by_addr. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Nous revenons √† la fonction pr√©c√©dente.  Une fois la valeur du registre <code>D0</code> transmise sous forme de commande pour <code>VDP_CTRL</code> , appuyez sur la touche <code>J</code> de la valeur.  Nous obtenons: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Encore une fois, de l'exp√©rience de l'inversion de jeux √† Sega, je peux dire que cette commande initialise l'enregistrement des tuiles de mappage.  Les adresses qui commencent sur <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> dans 90% des cas seront des adresses de r√©gions avec ces m√™mes mappages.  Que sont les mappages: <br>  ce sont les valeurs avec lesquelles vous pouvez sp√©cifier o√π afficher telle ou telle tuile √† l'√©cran (une tuile est un carr√© de <code>8x8</code> pixels). </p><br><p>  La fonction peut donc √™tre appel√©e en tant que <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  La premi√®re commande initialise l'enregistrement √† l'adresse <code>$F000</code> .  Une remarque: parmi les adresses du " <em>mapping</em> ", il y a encore une r√©gion o√π est stock√©e la table des sprites (ce sont leurs positions, les tuiles vers lesquelles elles pointent, etc.) D√©couvrez quelle r√©gion est responsable de ce qui peut √™tre d√©bogu√©.  Mais pour l'instant, nous n'en avons pas besoin, appelons donc la fonction <code>init_other_mappings</code> . </p><br><p>  De plus, nous voyons que dans cette fonction deux variables sont initialis√©es: <code>word_FF000A</code> et <code>word_FF000C</code> .  D'apr√®s ma propre exp√©rience (oui, il d√©cide), je dirai que si deux variables sont proches dans l'espace d'adressage et sont associ√©es au mappage, alors dans la plupart des cas, ce seront les coordonn√©es d'un objet (par exemple, un sprite).  Par cons√©quent, je sugg√®re de les appeler <code>sprite_pos_x</code> et <code>sprite_pos_y</code> .  L'erreur en <code>x</code> et <code>y</code> admissible car  plus loin sous le d√©bogage, il sera facile √† corriger. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Puisque la boucle va plus loin dans le code, nous pouvons supposer que nous avons termin√© l'initialisation de base.  Vous pouvez maintenant regarder l'interruption <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  On voit que deux variables s'incr√©mentent (ce qui est √©trange, dans la liste des liens vers chacune d'elles, elle est absolument vide).  Mais, puisqu'ils sont mis √† jour une fois par trame, vous pouvez les appeler <code>timer2</code> et <code>timer2</code> . </p><br><p>  Ensuite, la fonction <code>sub_2FE</code> est <code>sub_2FE</code> .  Voyons ce qu'il y a: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  Et l√† - travaillez avec le port <code>IO_CT1_DATA</code> (responsable du premier joystick).  L'adresse du port est charg√©e dans le registre <code>A0</code> et transmise √† la fonction <code>sub_310</code> .  On y va: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Mon exp√©rience m'aide √† nouveau.  Si vous voyez le code qui fonctionne avec le joystick et deux variables en m√©moire, alors l'une stocke <code>pressed keys</code> et la seconde contient les <code>held keys</code> , c.-√†-d.  touches enfonc√©es et maintenues.  <code>pressed_keys</code> ces variables: <code>pressed_keys</code> et <code>held_keys</code> .  Et puis la fonction peut √™tre appel√©e en tant que <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Appelez la fonction en tant que <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Boucle de gestionnaire </h2><br><p>  Maintenant, tout semble beaucoup plus clair: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Ce cycle r√©pond donc aux touches enfonc√©es et effectue les actions correspondantes.  Passons en revue chacune des fonctions appel√©es dans la boucle. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  Il y a beaucoup de code.  Commen√ßons par la premi√®re fonction appel√©e: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Elle ne fait rien - cela peut sembler ainsi au premier abord.  Le retour de la fonction actuelle est <code>rts</code> .  Mais, parce que  seuls des sauts ( <code>bsr</code> ) s'y produisent, ce qui signifie que <code>rts</code> nous ram√®nera √† la boucle du gestionnaire.  J'appellerais cette fonction comme <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Ensuite, nous voyons l'appel √† la variable <code>word_FF000E</code> .  Il n'est utilis√© nulle part sauf pour la fonction actuelle et, au d√©but, son objectif n'√©tait pas clair pour moi.  Mais, si vous regardez de plus pr√®s, nous pouvons supposer que cette variable n'est n√©cessaire que pour un petit d√©lai entre le traitement des frappes.  ( <em>Il est d√©j√† mal impl√©ment√© dans ce rhum, mais je pense que sans cette variable ce serait bien pire</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  Ensuite, nous avons une grande quantit√© de code qui traite en quelque sorte les <code>sprite_pos_y</code> <code>sprite_pos_x</code> et <code>sprite_pos_y</code> , qui ne peuvent dire qu'une chose - cela est n√©cessaire pour afficher le sprite de s√©lection autour du caract√®re s√©lectionn√© dans l'alphabet. </p><br><p>  Vous pouvez donc d√©sormais nommer la fonction en toute s√©curit√© <code>update_selection</code> .  Continuons. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  Le code v√©rifie si les bits de certaines touches enfonc√©es sont d√©finis et appelle certaines fonctions.  Regardons-les. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Une sorte de magie chamanique.  Tout d'abord, le <code>WORD</code> est tir√© de la variable <code>word_FF0018</code> , puis une instruction int√©ressante est ex√©cut√©e: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Cette commande passe simplement √† l'instruction qui la suit. </p><br><p>  Vient ensuite une autre magie: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  La valeur du registre <code>D0</code> est plac√©e en haut de la pile.  Il convient de noter que, pour Shogi, ainsi que pour certains <code>x86</code> , l'adresse de retour de la fonction lorsqu'elle est appel√©e est plac√©e en haut de la pile.  Par cons√©quent, la premi√®re instruction place une adresse en haut et la seconde la soul√®ve de la pile et effectue une transition le long de celle-ci.  <u>Bon tour</u> . </p><br><p>  Vous devez maintenant comprendre quelle est cette valeur dans la variable, qui passe ensuite.  Mais d'abord, appelons cette variable <code>jmp_addr</code> . </p><br><p>  Et les fonctions seront appel√©es ceci: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  D√©couvrez o√π cette variable est remplie.  Nous regardons la liste des r√©f√©rences: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  Il n'y a qu'un seul endroit pour √©crire dans cette variable.  Regardons-le. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Ici, en fonction des coordonn√©es du sprite (rappelez-vous qu'il s'agit tr√®s probablement de l'adresse du caract√®re s√©lectionn√©), telle ou telle valeur est saisie.  Nous voyons la section de code suivante: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  La valeur existante est d√©cal√©e vers la droite de 4 bits, une nouvelle valeur est plac√©e dans l'octet de poids faible et le r√©sultat est √† nouveau entr√© dans la variable.  En th√©orie, notre variable <code>jmp_addr</code> stocke les caract√®res que nous pouvons saisir sur l'√©cran de saisie des touches.  Notez √©galement que la taille de la variable est <code>WORD</code> . </p><br><p>  En fait, la fonction <code>sub_3A4</code> peut √™tre appel√©e <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Il ne nous reste plus qu'une fonction dans la boucle, qui n'est pas reconnue.  Et cela s'appelle <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Son code ressemble au code de la fonction <code>update_jmp_addr</code> , seulement √† la fin nous avons un <code>sub_45E</code> fonction <code>sub_45E</code> .  Regardons l√†-bas. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Nous voyons que le num√©ro <code>#$4B1E2003</code> entr√© dans le registre <code>D0</code> , qui est ensuite envoy√© √† <code>VDP_CTRL</code> , ce qui signifie que nous avons affaire √† une autre commande de contr√¥le <code>VDP</code> .  Nous <code>$Cxxx</code> sur <code>J</code> , nous recevons une commande d'enregistrement dans la r√©gion avec le mappage <code>$Cxxx</code> . </p><br><p>  Ensuite, le code fonctionne avec la variable <code>byte_FF0014</code> , qui n'est utilis√©e nulle part sauf la fonction actuelle.  Si vous regardez attentivement comment il est utilis√©, vous remarquerez que le nombre maximum pouvant y √™tre install√© est de <code>4</code> .  J'ai l'hypoth√®se que c'est la longueur actuelle de la cl√© entr√©e.  Voyons √ßa. </p><br><h4 id="zapuskaem-otladchik">  Ex√©cutez le d√©bogueur </h4><br><p>  J'utiliserai le d√©bogueur de <code>Smd Ida Tools</code> , mais, en fait, quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Gens KMod</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Gens ReRecording</a> suffiront.  L'essentiel est qu'il existe une fonctionnalit√© avec l'affichage des adresses en m√©moire. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Ma th√©orie a √©t√© confirm√©e.  Ainsi, la variable <code>byte_FF0014</code> peut maintenant √™tre <code>key_length</code> . </p><br><p>  Il existe une autre variable: <code>dword_FF0010</code> , qui est √©galement utilis√© uniquement dans la fonction actuelle, et son contenu, apr√®s avoir √©t√© ajout√© √† la commande initiale dans <code>D0</code> (rappel, c'√©tait le num√©ro <code>#$4B1E2003</code> ), est envoy√© √† <code>VDP_CTRL</code> .  Sans y r√©fl√©chir √† <code>add_to_vdp_cmd</code> , j'ai nomm√© la variable <code>add_to_vdp_cmd</code> . </p><br><p>  Alors, que fait cette fonction?  Je suppose qu'elle dessine le caract√®re entr√©.  La v√©rification est simple - en lan√ßant le d√©bogueur et en comparant l'√©tat avant d'appeler la fonction <code>sub_45E</code> et apr√®s: </p><br><p>  √Ä: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Apr√®s: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  J'avais raison - cette fonction dessine le caract√®re entr√©.  Nous l'appelons <code>do_draw_input_char</code> , et la fonction qui l'appelle ( <code>sub_414</code> ) est <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Et maintenant </h2><br><p>  V√©rifions maintenant que la variable que nous avons appel√©e <code>jmp_addr</code> stocke vraiment la cl√© entr√©e.  Nous utiliserons la m√™me <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Comme vous pouvez le voir, la conjecture √©tait vraie.  Qu'est-ce que cela nous donne?  Nous pouvons sauter √† n'importe quelle adresse.  Mais lequel?  Dans la liste des fonctions, toutes sont tri√©es apr√®s tout: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Ensuite, j'ai commenc√© √† faire d√©filer le code jusqu'√† ce que je trouve ceci: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  L'≈ìil entra√Æn√© a vu la s√©quence de <code>$4E, $75</code> √† la fin des octets non allou√©s.  Il s'agit de l'opcode de l'instruction <code>rts</code> , c'est-√†-dire  retour de fonction.  Ces octets non allou√©s peuvent donc √™tre le code d'une fonction.  Essayons de les d√©signer comme un code, appuyez sur <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  √âvidemment, c'est un code de fonction.  Vous pouvez √©galement appuyer sur <code>P</code> pour faire du code une fonction.  Rappelez-vous ce nom: <code>sub_D3C</code> . </p><br><p>  Puis la pens√©e surgit: et si vous sautez sur <code>sub_D3C</code> ?  Cela semble bien, m√™me si un seul saut ici ne sera √©videmment pas suffisant, car  il n'y avait plus de lien vers la variable <code>word_FF0020</code> . </p><br><p>  Puis une autre pens√©e m'est venue: et si nous cherchions un autre code non allou√©?  Ouvrez la bo√Æte de dialogue de <code>Binary search</code> (Alt + B), entrez-y la s√©quence <code>4E 75</code> , cochez la case <code>Find all occurrences</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Cliquez sur <code></code> pour lancer la recherche, nous obtenons les r√©sultats suivants. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Au moins deux autres emplacements dans le rhum peuvent contenir un code de fonction, vous devez les v√©rifier.  Nous cliquons sur la premi√®re des options, faisons d√©filer un peu vers le haut et nous voyons √† nouveau une s√©quence d'octets non d√©finis.  Les d√©noter en fonction?  Oui!  Appuyez sur <code>P</code> o√π les octets commencent: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Cool!  Nous avons <code>sub_34C</code> fonction <code>sub_34C</code> .  Nous essayons de r√©p√©ter la m√™me chose avec la derni√®re des options trouv√©es, et ... nous obtenons une d√©ception.  Il y a tellement d'octets avant <code>4E 75</code> qu'il n'est pas clair o√π la fonction d√©marre.  Et, √©videmment, tous ces octets ci-dessus ne sont pas du code, car  beaucoup d'octets en double. </p><br><h3 id="opredelyaem-nachalo-funkcii">  D√©terminer le d√©but de la fonction </h3><br><p>  Il nous sera plus facile de trouver le d√©but de la fonction si nous trouvons o√π se terminent les donn√©es.  Comment faire  En fait pas du tout compliqu√©: </p><br><ol><li>  On se tord avant le d√©but des donn√©es (il y aura un lien vers elles depuis le code) </li><li>  Nous suivons le lien et recherchons un cycle dans lequel la taille de ces donn√©es devrait appara√Ætre </li><li>  Marquer le tableau </li></ol><br><p>  Donc, nous effectuons le premier paragraphe ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... et nous voyons imm√©diatement que dans un cycle de notre tableau 4 octets de donn√©es sont copi√©s √† la fois (parce que <code>move.l</code> ) vers <code>VDP_DATA</code> .  Ensuite, nous voyons le nombre <code>2047</code> .  Au d√©but, il peut sembler que la taille finale du tableau est <code>2047 * 4</code> , mais la boucle bas√©e sur <code>dbf</code> ex√©cute <code>+1</code> it√©ration de plus, car  La derni√®re valeur compar√©e n'est pas <code>0</code> , mais <code>-1</code> . </p><br><p>  Total: la taille du tableau est de <code>2048 * 4 = 8192</code> .  Indique les octets sous forme de tableau.  Pour ce faire, cliquez sur <code>*</code> et sp√©cifiez la taille: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Nous tournons jusqu'√† la fin du tableau, et nous y voyons des octets, qui sont exactement les octets du code: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Nous avons <code>sub_2D86</code> fonction <code>sub_2D86</code> , et nous avons tout pour r√©soudre cette fissure!  Voyons ce que fait la fonction nouvellement cr√©√©e. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  Et il met simplement la valeur <code>#$4147</code> dans le registre <code>D1</code> et appelle la fonction <code>sub_34C</code> .  Regardez-la. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  On voit qu'ici la valeur de la variable <code>word_FF0020</code> est <code>word_FF0020</code> .  Si vous regardez les liens vers celui-ci, nous verrons un autre endroit o√π l'enregistrement dans cette variable a lieu, et ce sera exactement l'endroit o√π je voulais sauter √† travers la variable <code>jmp_addr</code> .  Cela confirme l'intuition dont <code>sub_D3C</code> absolument besoin pour passer √† <code>sub_D3C</code> . </p><br><p>  Mais ce qui s'est pass√© ensuite √©tait trop paresseux pour que je puisse comprendre, alors j'ai jet√© le rhum dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GHIDRA</a> , trouv√© cette fonction et regard√© le code d√©compil√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  On voit que la variable avec le nom √©trange <code>in_D1w</code> , ainsi que la variable <code>DAT_00ff0020</code> , qui avec son adresse ressemble au <code>word_FF0020</code> mentionn√© <code>word_FF0020</code> - <code>word_FF0020</code> . </p><br><p>  <code>in_D1w</code> nous indique que cette valeur est tir√©e du registre <code>D1</code> , ou plut√¥t de sa moiti√© WORD plus jeune, et d√©finit le registre <code>D1</code> fonction qui le transmet.  Rappelez-vous <code>#$4147</code> ?  Vous devez donc d√©signer ce registre comme argument d'entr√©e de la fonction. </p><br><p>  Pour ce faire, dans la fen√™tre avec le code d√©compil√©, cliquez avec le bouton droit sur le nom de la fonction et s√©lectionnez l'√©l√©ment de menu <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Afin d'indiquer que la fonction prend un argument √† travers un registre sp√©cifique, √† savoir, pas par la m√©thode standard pour la convention d'appel actuelle, vous devez cocher la <code>Use Custom Storage</code> et cliquer sur l'ic√¥ne avec un <u>plus vert</u> : </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Une position pour le nouvel argument d'entr√©e appara√Æt.  On double-clique dessus et on obtient une bo√Æte de dialogue indiquant le type et le support de l'argument: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  Dans le code d√©compil√©, nous voyons que <code>in_D1w</code> est de type <code>ushort</code> , ce qui signifie que nous le sp√©cifierons dans le champ type.  Cliquez ensuite sur le bouton <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Une position appara√Ætra pour indiquer le support de l'argument, nous devons sp√©cifier le registre <code>D1w</code> dans <code>Location</code> , puis cliquez sur <code>OK</code> : </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  Le code d√©compil√© prendra la forme: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Nous <code>param_1</code> que notre valeur <code>param_1</code> est constante, transmise par la fonction appelante et est √©gale √† <code>#$4147</code> .  Alors quelle devrait √™tre la valeur de <code>DAT_00ff0020</code> ?  Nous consid√©rons: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Parce que  <code>xor</code> - l'op√©ration est r√©versible, tous les nombres constants peuvent √™tre disput√©s entre eux et obtenir la valeur souhait√©e de la variable <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Il s'av√®re que la valeur de la variable doit √™tre <code>0x4553</code> .  Il semble que j'ai d√©j√† vu un endroit o√π une telle valeur est d√©finie ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Conclusions et d√©cision </h2><br><p>  Nous arrivons aux r√©sultats suivants: </p><br><ol><li>  Vous devez d'abord passer √† l'adresse <code>0x0D3C</code> , pour cela, vous devez entrer le code <code>0D3C</code> </li><li>  <code>0x2D86</code> √† la fonction √† <code>0x2D86</code> , qui d√©finit la valeur de <code>D1</code> pour enregistrer <code>#$4147</code> , pour cela, vous devez entrer le code <code>2D86</code> </li></ol><br><p>  Exp√©rimentalement, nous trouvons la touche qui doit √™tre press√©e pour v√©rifier la touche entr√©e: <code>B</code>  Nous essayons: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Je vous remercie! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448500/">https://habr.com/ru/post/fr448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448488/index.html">DevSecOps craint et d√©teste</a></li>
<li><a href="../fr448490/index.html">Comment d√©marrer la transformation DevOps</a></li>
<li><a href="../fr448492/index.html">Qu'est-ce que DevOps</a></li>
<li><a href="../fr448496/index.html">.NET Core sous Linux, DevOps √† cheval</a></li>
<li><a href="../fr448498/index.html">"Russia 404": combien d'Internet gratuit reste √† vivre</a></li>
<li><a href="../fr448504/index.html">Ils ont collect√© pour tout le monde "Habrom" le livre de r√©f√©rence "Par qui il a √©t√© d√©livr√© ..." pour les passeports. T√©l√©charger sur la sant√©</a></li>
<li><a href="../fr448506/index.html">The Matrix a 20 ans: comment Wachowski a fait du cyberpunk, qui a d√©termin√© l'agenda de toute une g√©n√©ration</a></li>
<li><a href="../fr448510/index.html">Acer en 2019: que faire si vous supprimez toutes les mouches des ordinateurs portables de jeu</a></li>
<li><a href="../fr448516/index.html">√âvoluez ou cr√©ez une base pour les robots sur la plateforme ARDUINO, et nous pilotons des capteurs et de la vid√©o vers un ordinateur via un smartphone</a></li>
<li><a href="../fr448518/index.html">Comment voir un trou noir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>