<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏿 ⏱️ 👘 Tempat Kedua Sejarah di Piala AI Rusia 2018: CodeBall 🥒 🏴󠁧󠁢󠁥󠁮󠁧󠁿 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Saya seorang siswa tahun ketiga, dan pada awal studi saya di universitas saya belajar tentang Piala Ai Rusia , dan kemudian Piala Mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tempat Kedua Sejarah di Piala AI Rusia 2018: CodeBall</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/440924/"><img src="https://habrastorage.org/webt/af/ae/ow/afaeownubljxqa1m35toussj7si.jpeg" align="left" width="220">  Halo semuanya! <br><br>  Saya seorang siswa tahun ketiga, dan pada awal studi saya di universitas saya belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piala Ai Rusia</a> , dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piala Mini Ai</a> , kompetisi dalam kecerdasan buatan, dan mulai aktif berpartisipasi di dalamnya, menunjukkan hasil yang baik.  Kali ini, RAIC masuk tepat ke sesi, jadi tidak ada yang bisa menghentikan saya :) Dan hari ini saya ingin memberi tahu Anda bagaimana saya berhasil mengambil tempat kedua. <br><br>  Aturan kompetisi dapat ditemukan di situs web kompetisi, serta dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini.  Tautan ke profil saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">russianaicup.ru/profile/TonyK</a> . <br><a name="habracut"></a><br>  Di satu sisi, tugas tahun ini mirip dengan tugas tahun-tahun sebelumnya, dan tampaknya solusi ideologis akan sangat mirip dengan yang sebelumnya (Agar IO dan Mobil Gila);  setelah sekitar satu minggu saya akan bosan dan bosan berpartisipasi. <br><br>  Di sisi lain, saya mengerti bahwa saya telah belajar banyak dalam kompetisi sebelumnya dengan fisika dan sekarang saya bisa menerapkan pengalaman ini, tidak menginjak penggaruk lama dan, pada akhirnya, menunjukkan hasil yang lebih baik. <br><br>  Adapun visualisasi, saya memutuskan bahwa saya akan memiliki cukup proyeksi pada sumbu yang berbeda, atau ditampilkan pada sudut tertentu.  Tetapi saya sangat keliru, dan jika bukan karena visualizer ajaib yang dibangun di dalam Local Runner, yang kemudian ditambahkan oleh penyelenggara, saya harus meminjam visualisator 3D dari para peserta yang menghabiskan fase pengujian beta menulisnya dan meletakkannya di domain publik. <br><br>  Kali ini pseudo-code dari simulator tersedia, yang menyamakan kemungkinan mereka yang tahu cara membalik fisika dan menulis bot yang keren, dan mereka yang tidak bisa membalik fisika, tetapi yang juga bisa menulis bot yang kuat.  Saya pikir ini adalah keputusan yang baik oleh panitia. <br><br>  Hal pertama yang saya lakukan adalah menulis ulang kode simulator dari dokumentasi di C ++, dan kemudian mengukur waktu simulator di komputer lama saya dan di server.  Dalam kasus kedua, ternyata dua kali lebih cepat, meskipun ini diharapkan.  Saya membayangkan berapa kali dan seberapa dalam saya bisa mensimulasikan.  Segera menjadi jelas bahwa kita harus melupakan simulasi jujur ​​100 mikrotik (di server satu tik fisika dibagi menjadi 100 "mikrotik"), dan akan perlu untuk menyelesaikan masalah dengan akurasi dalam cara bundaran. <br><br>  Karena fakta bahwa shell diatur sedemikian rupa sehingga permintaan tindakan untuk setiap robot dipanggil secara terpisah pada setiap centang, saya menerapkan logika sederhana: pada saat robot pertama diminta melakukan suatu tindakan, program menemukan tindakan untuk semua robot, mengingat dan memberikan aksi yang pertama, dan ketika aksi diminta dari robot yang lain, ia mengembalikan apa yang diingatnya. <br><br>  Saya tidak sabar untuk mengirim bot ke pertempuran segera.  Saya memutuskan untuk membuat lintasan acak dan memilih yang terbaik.  Pada saat yang sama, ia ingin set yang dihasilkan memungkinkan untuk melakukan beberapa tindakan kompleks, misalnya, mengitari bola dari sisi kanan, dan kemudian memukul. <br><br>  Sebuah lintasan adalah rencana aksi.  Awalnya, lintasannya adalah ini: <br><br><ul><li>  atur aksi pada sudut acak; </li><li>  pada centang acak lintasan, ubah sudut ke sudut acak lainnya; </li><li>  melompat sekali ke tanda centang acak lintasan. </li></ul><br>  Ruang lintasan seperti itu sangat cocok untuk pencarian acak dengan jumlah simulasi yang saya (dan, mungkin, semua orang pada saat itu) mampu lakukan dengan simulator mentah dari dokumentasi.  Lintasan yang baik sering ditebak, dan karena lintasan terbaik dari kutu sebelumnya dipertahankan, pencarian ternyata membentang dalam waktu. <br><br>  Semua objek ditempatkan di simulator: robot saya, robot lawan dan bola.  Penilaian adalah yang paling sederhana: jumlah jarak dari bola ke gawang musuh di semua titik lintasan dan nilai-nilai besar untuk gawang kepada seseorang.  Simulasi kedalaman 200 ticks.  Musuh diprediksi pada kecepatan terakhir mereka. <br><br><img src="https://habrastorage.org/webt/6p/n1/-f/6pn1-ft3htl0ohqjsqkcb3dvcfm.png"><br><br>  Saya segera menambahkan aksi terpisah untuk robot kedua, serta pembatalan paksa melompat, jika selama penerbangan tidak ada kontak dengan bola, sehingga tidak melompat sia-sia.  Pada saat yang sama, robot saya mendapatkan lebih dari separuh waktu dan tahu lintasan terbaik satu sama lain.  Sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gol</a> pertama telah dimulai untuk lawan yang kuat, yang sudah memiliki kiper dan beberapa logika yang lebih rumit. <br><br>  Ternyata lebih jauh bahwa saya tidak mempertimbangkan jarak ke gerbang musuh, tetapi ke titik di sisi tengah lapangan (bercampur <code>x</code> dan <code>z</code> ), tetapi ini tidak mempengaruhi strategi dengan cara apa pun.  Bagus bahwa setelah koreksi itu tidak menjadi lebih buruk.  Ini sering terjadi ketika Anda menulis bot. <br><br>  Kemudian dia menambahkan kiper dengan mengubah skor: dia menjatuhkan penalti untuk bola di bagian saya di lapangan dan untuk gol kepada saya, dan juga memperkirakan jarak dari penjaga gawang ke tujuan saya.  Sekarang kiper berdiri di depan gawang dan menendang bola.  Optimasi penting adalah bahwa jika bola tidak berada di setengah lapangan saya, maka 90% dari waktu diberikan kepada penyerang dan 10% dari kiper, jika tidak 50%. <br><br>  Penilaian lintasan robot di setiap titik dikalikan dengan 0,9 ^ kedalaman, saya menurunkan koefisien ini secara empiris, seperti seluruh penilaian.  Nilai-nilai koefisien tidak berubah untuk waktu yang sangat lama pada prinsip "itu bekerja, oke." <br><br>  Dia mulai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memenangkan</a> puncak dan dengan cepat naik peringkat.  Fase beta telah berakhir. <br><br>  Untuk waktu yang lama saya tidak punya ide tentang strategi, versi terkenal untuk pengeditan kecil, perbaikan bug (ternyata saya menganggap kekuatan bouncing rata-rata <code>(MAX_HIT_E - MIN_HIT_E) / 2</code> ), dan juga mengoptimalkan simulator.  Peran penting dimainkan oleh jumlah lintasan yang berhasil saya atur per tick, jadi saya fokus pada optimasi.  Sinus dan akar kuadrat yang dihapus.  Menambahkan kecepatan nol yang tidak mungkin pada lintasan sebelum atau setelah mengubah sudut.  Skor sedikit berubah. <br><br>  Versi 16 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disimpan untuk waktu yang</a> lama di puncak tabel, tetapi seminggu setelah akhir pengujian beta, seperti yang diharapkan, banyak yang mulai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menang</a> . <br><br><img src="https://habrastorage.org/webt/nd/mi/1v/ndmi1vn6qa2rshoih_ufarabuj0.jpeg" align="left">  Saya mencoba memperhalus lintasan dengan jumlah jarak terdekat dari musuh ke bola, dan saya mendapat perilaku yang sangat menarik.  Robot saya, ketika mereka tidak bisa mengenai untung, sering mulai memblokir musuh, menghancurkan lintasan mereka dan mencegah mereka berlari ke bola, kadang-kadang ternyata sangat berhasil dan diam-diam. <br><br>  Selanjutnya, saya memperbaiki akurasi sambil melompat.  Jika seseorang melompat pada centang saat ini, maka pertama kita lakukan 1 microtik dua kali, dan kemudian 98 microtics, dan kemudian saya mencoba koefisien heuristik untuk mengkompensasi hilangnya akurasi dalam kasus ketika di beberapa mikrotik kecepatan maksimum tercapai.  Perbaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat</a> membantu dan ada lebih akurat, hit pra-dihitung. <br><br>  Juga pada saat ini saya mulai menampilkan di situs di antara informasi debugging jumlah iterasi yang berhasil saya selesaikan.  Ada 250 dari mereka pada 200 kutu, secara total saya memiliki 50.000 kutu simulasi selama waktu yang dialokasikan untuk strategi saya per kutu. <br><br>  Kemudian saya menyalakan lintasan mutasi.  Ini sangat meningkatkan strategi.  Di sekitar setengah dari semua iterasi, itu bukan lintasan baru yang digunakan, tetapi yang terbaik dengan nilai yang sedikit berubah, yang memungkinkan untuk berkumpul di suatu tempat, misalnya, ke maksimum lokal.  Itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ternyata</a> menjadi strategi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuat</a> pada waktu itu, yang saya putuskan untuk hengkang sampai putaran pertama, walaupun itu masih dua minggu sebelum itu.  Tetapi setelah beberapa hari dia tidak lagi mendominasi puncak. <br><br>  Saya menghabiskan beberapa waktu menjauh dari keacakan lengkap, misalnya, saya mencoba dengan pencarian ternary untuk menemukan sudut di mana robot perlu mempercepat untuk memukul bola.  Tetapi ini tidak selalu berhasil, dan saya tidak tahu bagaimana mengembangkan ide ini lebih jauh. <br><br>  Robot saya tahu bagaimana cara melompat hanya sekali per lintasan, tetapi ketika mereka berada di tanah dan ingin melompat, dan kemudian memukul bola di udara, mereka tidak tahu bahwa ketika Anda menyentuh bola Anda bisa melompat kedua kalinya, sehingga memukul bola dengan keras, dan bukan hanya mendorongnya. <br><br>  Ini sudah diperbaiki, dan sekarang simulator, ketika dia memperhatikan bahwa seseorang dapat memukul bola dengan kutu saat ini, memutar mundur satu kutu dan memaksa robot untuk melompat dengan kekuatan maksimum.  Sekarang, berdiri di tanah, robot itu tahu bahwa itu akan mendorong tanah dan tidak hanya mendorong, tetapi memukul bola dengan lompatan kedua. <br><br>  Saya mengerti bahwa ketika nitro dan robot lain ditambahkan, semuanya akan bengkok karena kurangnya iterasi.  Juga di tempat yang berbeda saya punya masalah besar dengan akurasi, yang saya tidak tahu bagaimana menyelesaikannya.  Saya tidak melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi analitis</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara manajemen yang cerdas</a> . <br><br>  Saya membutuhkan strategi yang sama sekali baru, atau simulator ajaib yang menggabungkan akurasi dan kecepatan, dan pada tahap akhir akan memberi saya lintasan yang cukup untuk beralih.  Saya tidak menemukan strategi baru (secara mengejutkan), dan mulai mengerjakan simulator. <br><br><h2>  "Simulator cerdas" </h2><br>  Hal pertama yang saya inginkan adalah ketepatan. <br><br>  Saya mensimulasikan 100 Mikrotik pada suatu waktu, meskipun tabrakan - atau peristiwa lain - terjadi pada salah satu dari seratus Mikrotik ini.  Jika Anda mengabaikan ini, objek bertabrakan lebih lambat dari kenyataan (selalu pada mikrotik ke-100), dan karenanya memantul secara berbeda.  Menjelang akhir lintasan, kesalahan kecil ini dapat berubah menjadi ketidakakuratan besar.  Sebagai contoh, kami berpikir bahwa bola mengenai gawang musuh, tetapi pada kenyataannya itu akan memantul <s>ke</s> gawang <s>kami</s> dari pos. <br><br>  Sangat mudah untuk melihat bahwa dalam situasi di mana tabrakan terjadi pada mikrotik ke-i, daripada menghitung semua 100 mikrotik, cukup untuk menghitung mikrotik <code>i - 1</code> pertama pada suatu waktu (pada kenyataannya, langkah fisika dipertimbangkan untuk waktu tertentu <code>dt</code> , dan sekarang waktu ini akan menjadi <code>t * (i - 1)</code> , di mana <code>t</code> adalah waktu yang sesuai dengan satu Mikrotik).  Sekarang Anda perlu mensimulasikan 1 mikrotik ( <code>dt = t</code> ) dan <code>100 - i</code> mikrotik yang tersisa.  Kami mendapatkan hasil yang persis sama hanya dalam tiga simulasi, bukan seratus.  Satu-satunya masalah adalah bahwa kita tidak tahu di mana mikrotik tabrakan akan terjadi. <br><br>  Berada di beberapa centang tetap simulasi, kita dapat membuat sejumlah mikrotik dari 1 hingga 100 dalam satu simulasi dan melihat apakah ada tabrakan atau tidak.  Dalam hal ini, gambar akan menjadi seperti ini: pada awalnya tidak ada sentuhan, tetapi mulai dari sejumlah mikrotik dan hingga seratus ada sentuhan.  Kecuali dalam kasus yang sangat jarang, ketika tidak ada kontak pada awalnya, maka ada sentuhan pada beberapa segmen mikrotik, dan sekali lagi tidak ada sentuhan lagi. <br><br>  Oleh karena itu, dimungkinkan untuk menemukan Mikrotik di mana tabrakan terjadi menggunakan pencarian biner untuk 10 simulasi dalam kasus terburuk.  Dan seperti yang dijelaskan sebelumnya, untuk tiga simulasi, Anda bisa mendapatkan keadaan dunia melalui 100 mikrotik dengan akurasi sempurna. <br><br>  Bahkan, ada beberapa jenis peristiwa lain selain tabrakan, dan beberapa bisa terjadi dalam satu centang, jadi hanya acara pertama yang terletak dalam satu dikotomi, kemudian acara kedua terletak pada akhiran sisa dari dikotomi centang, dan seterusnya.  Dengan demikian, kutu dianggap sebagai segmen dari beberapa mikrotik per simulasi, sampai semua peristiwa dihitung. <br><br>  Jadi masalah diselesaikan dengan akurasi.  Tetapi karena kenyataan bahwa ada 5 objek dalam simulasi, dan oleh aturan final seharusnya ada 7, dan semuanya sering crash, dikotomi rata-rata dipanggil terlalu sering, dan ini bekerja sangat lama.  Oleh karena itu, saya melanjutkan ke tahap kedua pengembangan simulator - optimasi. <br><br>  Tentunya, ketika lintasan salah satu robot berhasil melaluinya, semua benda lain yang tidak dapat dihantam robot ini bergerak sama setiap saat.  Jelas bahwa menghitung ulang keadaan mereka dengan simulator - misalnya, menghitung tabrakan berat dengan arena - tidak perlu. <br><br>  Sebelum memilah lintasan untuk robot tertentu, cukup untuk mensimulasikan dan mengingat dengan jujur ​​objek-objek yang tersisa dari status mereka di semua waktu, dan kemudian ambil status ini dari memori.  Kami menyebutnya objek statis, dan robot yang lintasannya diurutkan adalah dinamis. <br><br>  Jika tiba-tiba beberapa objek dinamis memengaruhi (bertabrakan) dengan objek statis, kami menambahkan objek statis ini ke objek dinamis hingga akhir simulasi lintasan saat ini.  Bahkan, pada tahap penyimpanan keadaan untuk objek statis, grafik pengaruh satu sama lain dibangun, dan kemudian digunakan untuk mentransfer objek statis dengan benar ke objek dinamis.  Sebagai contoh, robot musuh menabrak bola, dan kami membuat jalur tempat kami merobohkan robot musuh sebelum menabrak bola.  Sekarang bola akan terbang lebih jauh, dan selama simulasi, ketika robot musuh ditambahkan ke objek dinamis, perlu dicatat bahwa bola harus ditambahkan ke objek dinamis sedikit kemudian, pada centang di mana robot musuh akan mengenai bola jika kita tidak mengganggunya .  Dalam kasus umum, ini dilakukan secara rekursif sesuai dengan grafik pengaruh. <br><br><img src="https://habrastorage.org/webt/ey/fr/cj/eyfrcjzg0s28o3fjqgberru64bm.jpeg"><br><br>  Sekarang simulator tidak menghitung semua objek, tetapi hanya yang dinamis, dan ini, rata-rata, adalah satu setengah objek, bukan tujuh, dan dikotomi yang panjang lebih jarang digunakan.  Ternyata sangat cepat, dan tidak lagi harus menderita di final dengan robot tambahan - keren! <br><br>  Versi 26 dengan simulator baru dan kedalaman simulasi berkurang dari 200 menjadi 100 dikirim untuk dimainkan di babak pertama.  Tapi itu mengandung beberapa bug, dan tidak ada keuntungan yang jelas. <br><br>  Masalah terakhir dengan akurasi tetap: gerakan di sepanjang arena.  Dalam hal ini, untuk mencapai akurasi absolut, perlu menghitung secara jujur ​​100 mikrotik.  Solusinya sangat sederhana: selalu melompat dari semua permukaan kecuali lantai.  Tidak ada pembulatan - tidak ada masalah. <br><br>  Selanjutnya, untuk beberapa waktu saya dioptimalkan, debazed dan, melihat permainan dengan strategi yang lebih cerdas, saya mengambil konstanta penilaian baru.  Itu menjadi jauh lebih baik, strateginya naik tinggi di peringkat dan versi ke-37 telah mencapai hasil terbaik dari semua strategi saya di kotak pasir sepanjang waktu sebelum final. <br><br>  Mulai saat ini, saya menyewa mesin 32-core di layanan cloud untuk menjalankan strategi saya satu sama lain, dan mulai banyak bereksperimen dengan segala sesuatu dalam satu baris.  Mengubah konstanta.  Saya mencoba menggunakan strategi saya sendiri untuk memprediksi tindakan musuh, tetapi ini tidak membantu bahkan dalam permainan melawan strategi saya. <br><br>  Dengan memecahkan persamaan, ia belajar menghitung aksi terakhir musuh dan mulai memprediksi perilakunya lebih lanjut.  Dukungan tambahan untuk nitro: titik acak pada permukaan bola dipilih untuk tindakan.  Melakukan banyak pengeditan kecil.  Tetapi tidak ada banyak kemajuan.  Pada awal babak kedua, 4-5 atasan terus memenangkan saya <br><br>  Meski begitu, saya tidak putus asa.  Saya memiliki dua perbaikan yang saya rencanakan untuk dilaksanakan sebelum final, dan saya berharap mereka akan sangat meningkatkan strategi.  Saya memutuskan untuk tidak menangani mereka sampai kotak pasir mulai sesuai dengan aturan terakhir, dan sebagai gantinya menghabiskan waktu men-debug dan mengoptimalkan apa yang sudah dilakukan untuk meminimalkan kemungkinan bug jahat dalam minggu terakhir, ketika setiap menit diperhitungkan. <br><br>  Minggu terakhir sebelum final dimulai. <br><br>  Perbaikan pertama yang saya buat adalah ini.  Dalam pertandingan, dalam kasus umum, sebagian besar masalah saya, dan strategi lainnya muncul ketika lawan menguasai bola.  Dia entah bagaimana memukulnya, melewati, secara umum - kontrol.  Memprediksi lintasan bola dan merencanakan lebih lanjut beberapa tindakan menguntungkan dalam kasus ini tidak mungkin, tetap melakukan "apa pun" sampai lawan membuat kesalahan dan mentransfer kendali bola ke robot saya.  Dan setelah ini, Anda harus mencoba untuk tidak melakukan tindakan seperti itu yang bisa mengarah pada fakta bahwa bola akan kembali bersama musuh. <br><br>  Dengan kata lain, pada saat merencanakan lintasan, saya ingin memperhitungkan kemungkinan posisi lawan dan mencoba untuk tidak memukul bola di sana.  Saya memutuskan untuk menggunakan bidang potensial empat dimensi (tiga dimensi pertama adalah koordinat, sisi kubus sama dengan diameter robot, dan dimensi keempat adalah waktunya), yang akan saya isi, menghasilkan lintasan musuh acak. <br><br>  Kemudian, ketika mengevaluasi lintasan untuk robot saya, saya menghitung jumlah di semua kubus yang melintasi bola pada titik waktu yang sesuai, dan dikalikan dengan koefisien yang melebihi semua nilai lain dalam penilaian.  Artinya, bidang potensial diperhitungkan dengan prioritas tertinggi setelah tujuan.  Itu juga memungkinkan menghilangkan musuh dari simulasi setelah 30 tick pertama (musuh bisa melakukan apa saja selama waktu ini saat berada di tanah, dan ramalan jauh yang tidak akurat seperti itu hanya mengganggu) jika mereka tidak ada di udara (sepertinya tidak ada yang akan berada di dalam udara untuk mengubah lintasan dengan cara yang kompleks menggunakan nitro). <br><br>  Dengan membuat lintasan acak untuk musuh, adalah mungkin untuk mengetahui waktu minimum yang diperlukan baginya untuk memukul bola.  Nilai ini berguna untuk menyelesaikan masalah dengan lompatan awal kiper saya keluar dari gerbang.  Banyak gol yang dicetak untuk saya karena kiper saya melompat lebih awal dan menjadi tidak terkendali di udara.  Setelah itu, musuh dengan mudah memperkirakan bagaimana penjaga gawang saya akan terbang dan, jika ia bisa, mengubah lintasan bola sebelum kiper saya mencapainya.  Sekarang saya membatalkan lompatan penjaga gawang jika musuh dapat mengenai bola lebih awal dari rencana penjaga gawang saya. <br><br><img src="https://habrastorage.org/webt/00/p5/e5/00p5e59dlcqljg9ags7vttdyohy.jpeg"><br><br>  Ternyata, tanpa kerusakan signifikan pada strategi, adalah mungkin untuk menghitung lintasan tidak setiap kutu, tetapi melalui satu.  Dengan mengurangi separuh waktu berjalan, saya menggandakan jumlah rata-rata iterasi.  Beberapa keajaiban terjadi di sini.  Tampaknya jika kita menghitung lintasan setiap detik dan menggandakan jumlah iterasi, maka jumlah rata-rata iterasi tidak akan berubah.  Namun pada kenyataannya, simulator akan menghitung dua kutu (200 mikrotik) per simulasi, bukan satu.  Dan lintasannya akan menjadi 50, tidak dalam 100. Itu sebabnya jumlah rata-rata iterasi akan berlipat ganda. <br><br>  Tetap beberapa hari sebelum final.  Meskipun strategi saya mulai kebobolan lebih sedikit gol karena kontrol bola yang baik, saya tidak mulai mencetak lebih baik.  Karena itu, saya harus memotivasi dia dengan koefisien ketika segera untuk tujuan lawan.  Semakin cepat suatu gol dicetak, semakin besar rasionya.  Dan koefisien ini tumbuh sangat banyak untuk melebihi sisa skor dan tidak takut pada bidang potensial, ketika, misalnya, 10 tick tersisa sebelum skor. <br><br>  Menambahkan perhitungan di mana musuh mengirim nitro.  Ini dilakukan dengan menggunakan brute force dengan langkah tertentu.  Juga, kiper mulai mengisi cadangan nitro, ketika tidak ada yang mengancam tujuan saya. <br><br>  Peningkatan besar kedua adalah menggunakan minimax.  Jika penggunaan kekuatan dampak yang berbeda untuk musuh selama pembangunan lintasan statis mempengaruhi penerbangan bola, maka selama pencarian kedua opsi dipertimbangkan, dengan kekuatan dampak maksimum dan minimum musuh, dan minimum perkiraan diambil. <br><br>  Di final, saya punya 7 opsi untuk lintasan ketika robot berada di tanah: <br><br><ul><li>  2 sudut tanpa lompatan; </li><li>  2 sudut dengan lompatan; </li><li>  2 sudut dengan lompatan dan nitro codirectional speed; </li><li>  2 sudut dengan lompatan dan nitro mengimbangi gravitasi; </li><li>  1 sudut dengan lompatan; </li><li>  1 sudut dengan kecepatan codirectional lompat dan nitro; </li><li>  1 sudut dengan lompatan dan nitro mengkompensasi gravitasi (tidak digunakan karena bug, diperhatikan saat menulis artikel). </li></ul><br>  dan dua opsi saat robot ada di udara: <br><br><ul><li>  nitro ke titik acak pada permukaan bola dan gaya impak acak; </li><li>  kekuatan dampak acak. </li></ul><br>  Ada kompetisi beberapa jam sebelum final, tetapi strategi saya jelas lebih baik.  Sepertinya semuanya sudah dilakukan, saya belum tidur lebih dari sehari, dan tidak ada yang bergantung pada saya.  Tetap menonton.  Dua jam sebelum final, Andrei mengirim grail yang baru dipanggang dan berhasil memenangkan tempat pertama.  Sejarah partisipasinya dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/440398</a> . <br><br>  Di interval antara tahap-tahap final, saya menambahkan bidang potensial mendorong bola menjauh dari tujuan saya, terlepas dari segala sesuatu yang lain, dan ini, sepertinya bagi saya, menyamai saya dengan Andrei.  Tapi itu sudah terlambat, karena saya kehilangan 7 poin di babak pertama, dan bahkan 3/3 kemenangan di babak kedua tidak cukup. <br><br>  RAIC adalah kompetisi yang sulit dan hadiah diberikan kepada peserta sangat, sangat sulit.  Ketika seorang peserta berada di puncak tabel, baginya ini bukan hanya hiburan - itu adalah perjuangan.  Ada banyak hal kecil yang perlu dipertimbangkan ketika menulis strategi yang kuat.  Setiap keputusan yang dibuat dapat secara signifikan mempengaruhi hasil. <br><br>  Kode sumber untuk strategi akan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440924/">https://habr.com/ru/post/id440924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440914/index.html">Saya kehilangan kepercayaan pada industri, terbakar, tetapi kultus alat menyelamatkan saya</a></li>
<li><a href="../id440916/index.html">Radiasi: unit</a></li>
<li><a href="../id440918/index.html">Minggu Keamanan 08: meretas VFEMail langsung</a></li>
<li><a href="../id440920/index.html">Menerapkan UI di iOS: Lebih baik, lebih cepat, dan skala</a></li>
<li><a href="../id440922/index.html">Bagaimana Level Flow bekerja di Uncharted 4 dan The Last Of Us</a></li>
<li><a href="../id440928/index.html">Tentukan bio-age Anda di profil</a></li>
<li><a href="../id440930/index.html">Saya melakukan ratusan wawancara, menolak ratusan orang - dan baru setelah itu saya belajar untuk mewawancarai</a></li>
<li><a href="../id440932/index.html">Sedikit tentang intelijen bisnis TI</a></li>
<li><a href="../id440938/index.html">Mengapa Google membutuhkan grafik pengetahuan?</a></li>
<li><a href="../id440940/index.html">Redux - merevisi logika dan tindakan peredam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>