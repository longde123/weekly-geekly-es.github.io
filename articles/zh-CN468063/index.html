<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😛 🍈 🔇 角效应 👌🏽 ✌🏾 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我有问题 该应用程序是用Angular编写的，而组件库是用React编写的。 复制库太昂贵。 因此，您需要以最小的成本在Angular应用程序中使用React组件。 我们找出方法。 
 免责声明 


 我根本不是Angular的专家。 我在2017年尝试了第一个版本，然后稍微看了看AngularD...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>角效应</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468063/"><p> 我有问题 该应用程序是用Angular编写的，而组件库是用React编写的。 复制库太昂贵。 因此，您需要以最小的成本在Angular应用程序中使用React组件。 我们找出方法。 </p><a name="habracut"></a><br><h1 id="diskleymer"> 免责声明 </h1><br><p> 我根本不是Angular的专家。 我在2017年尝试了第一个版本，然后稍微看了看AngularDart，现在遇到了现代版本框架的应用程序支持。 如果您觉得这些决定很奇怪，或者是“来自另一个世界”，那么在您看来，这似乎并没有。 </p><br><p> 本文提供的解决方案尚未在实际项目中进行测试，仅是一个概念。 使用它需要您自担风险。 </p><br><h1 id="problema"> 问题 </h1><br><p> 我现在在Angular 8上支持并开发了一个相当大的应用程序。此外，React上有几个小型应用程序，并计划构建更多（也基于React）的应用程序。 所有应用程序均用于公司的内部需求，并且应采用相同的样式。 唯一的逻辑方法是创建一个组件库，在此基础上您可以快速构建任何应用程序。 </p><br><p> 但是在当前情况下，您不能仅仅在React上使用并编写一个库。 您不能在最大的应用程序中使用它-它是用Angular编写的。 我不是第一个遇到这个问题的人。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微软</a>在Google上首先要进行“角度反应”。 不幸的是，该解决方案根本没有文档。 另外，在项目的自述文件中，可以清楚地知道该软件包是由Microsoft内部使用的，团队没有明显的开发计划，使用该风险由您自己承担。 我还没有准备好将这样一个模棱两可的包拖入生产环境，所以我决定写我的自行车。 </p><br><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/829e9e3b-1673-4067-9278-982f01e95d52/__2019-09-18__20.15.04.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45FTZDIACS%2F20190919%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190919T122008Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjENv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCwuWc5hbwOjFa2gBX2qSa%2BrPvZmF79lBk8yc%2FXnhR5OgIgVv7r%2B%2FVK4eHtMZ4VXucxi3NFCVA8KGyzNOFcqsvvb0gq4wMIpP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDIQt1CA3IZ1diLWvKSq3A%2F7R4EFxWqz0ZQ3cWqbpSl7qAIZE6%2BRc8fFwpNm25pdxvEdKJXJAPDdmXjAfCd0QSedX2LOyOJ9aBjD1QXuPFe1EbMLho%2FztYBqFQyGw10VbM46reb9hex75UyV9W%2F4n%2Fx9A112LY%2FcYImpbCNz7C03aCnSybewd8uI6CbFQxR2T%2FttEuN%2BM7MINO3IiyviPzfxQH1%2FOh6%2BXJ%2FXnn7Hqy1cl07wbV9etV2Ul%2Bp71IAlE4sBaP2ZLCasQEwCbMS7dqxuQBD2vIaoW6xePr5UnIirdOwoTHmyCgkUvJbcMC159%2Bo2MXfWmwyYq3Zfv%2B%2FVoJAwiaSewM1LSls%2FUkj4TF0ILK58Isc2qFD9%2F07VV%2BoA9i0ppr%2BZhyxhLr02OftacApW638RhHUT2I%2B0DqSRdtLpRA0%2FJzJKfUvTuWY0P5sA7ulAEzvCZe3MuavIxQY9mAGyRJja%2BfRx6l3W49Gfk2Fdzv7054xQ0nJaaoaOrM7jR7taTU8HzoGnH1M3Ap0UXLu%2FVXYWFot78zsa0aDta2RIREzoL%2FDb7i8Sm6Ec5gPeTu7udP%2F2Zrgyidr0wPy1FEir0wGZJYj4wpLCN7AU6tAGdmaM%2F3OTcKirVsB97LangLG7SvqYaEZ0QCtZjQ1ismZ2d0epUNHq8J%2FbnEpM4DugcaKiXTKgLERS6nk61%2Bz3BEKh3GGUVz%2FS%2BYpHJEAo5QsoHBXiwvWlxEfnDVvYkyob2qghv0NjLp9ljkrHLnzgFGLAasNIDiPZT69zfBffDJwBhDVp6p7s3LefdevJiv5lMaMm3P272igMJjgxTiSCHiJrUVMvSgZ9PLY9ZICyyJCc2z60%3D&amp;X-Amz-Signature=5102f76091725ed13505a80485bbb95a0bcf5fc1ec2205aad9525c46ad70b09e&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22__2019-09-18__20.15.04.png%22" alt="图片"></p><br><p> 官方网站@角反应/核心 </p><br><h1 id="reshenie"> 解决方案 </h1><br><p>  React是一个旨在解决一个特定问题的库-管理文档的DOM树。 我们可以将任何React元素放在任意DOM节点中。 </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hello = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;p&gt;Hello, React!<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Hello</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('#hello'));</span></span></code> </pre> <br><p> 此外，对重复调用<code>render</code>函数没有任何限制。 也就是说，可以在DOM中分别渲染每个组件。 而这正是有助于迈出集成第一步的原因。 </p><br><h2 id="podgotovka"> 准备工作 </h2><br><p> 首先，重要的是要了解，默认情况下，React在组装过程中不需要任何特殊条件。 如果您不使用JSX，而只限于调用<code>createElement</code> ，那么您将不必采取任何步骤，一切都将立即可用。 </p><br><p> 但是，当然，我们习惯于使用JSX，并且不想丢失它。 幸运的是，Angular默认使用TypeScript，它可以将JSX转换为函数调用。 您只需要添加编译器标志<code>--jsx=react</code>或在<code>tsconfig.json</code>部分的<code>tsconfig.json</code>中添加行<code>"jsx": "react"</code> 。 </p><br><h2 id="integraciya-otobrazheniya"> 显示整合 </h2><br><p> 首先，我们需要确保React组件显示在Angular应用程序中。 也就是说，从库工作中得到的DOM元素将在元素树中占据正确的位置。 </p><br><p> 每次使用React组件时，考虑正确调用<code>render</code>函数都太困难了。 另外，将来我们将需要在数据级别和事件处理程序上集成组件。 在这种情况下，创建一个Angular组件是有意义的，该组件将封装创建和控制React元素的整个逻辑。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = () =&gt; &lt;p&gt;Hello, React!&lt;/p&gt;; // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = {}; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p>  Angular组件的代码非常简单。 它本身仅呈现一个空容器并获得指向它的链接。 在这种情况下，在初始化时，将调用React元素的渲染。 它是使用<code>createElement</code>函数创建的，并传递给<code>render</code>函数，该函数将其放置在从Angular创建的DOM节点中。 您可以像其他任何Angulat组件一样使用此类组件，没有特殊条件。 </p><br><h2 id="integraciya-vhodnyh-dannyh"> 输入整合 </h2><br><p> 通常，在显示界面元素时，您需要向其传输数据。 这里的一切也很平淡-调用<code>createElement</code>您可以将所有数据通过道具传递到组件。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = ({ name }) =&gt; &lt;p&gt;Hello, {name}!&lt;/p&gt;; // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; @Input() name: string; ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = { name: this.name, }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p> 现在，您可以将<code>name</code>字符串传递给Angular组件，它将落入React组件并进行渲染。 但是，如果由于某些外部原因导致行更改，React将不知道该行，并且我们将获得过时的显示。  Angular具有<code>ngOnChanges</code>生命周期<code>ngOnChanges</code> ，可让您跟踪组件参数的变化以及对其的反应。 我们实现<code>OnChanges</code>接口并添加一个方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... ngOnChanges(_: SimpleChanges) { this.renderReactElement(); } // ...</span></span></code> </pre> <br><p> 只需使用从新道具创建的元素再次调用<code>render</code>函数就足够了，并且库本身将确定应渲染树的哪些部分。 组件内部的本地状态也将保留。 </p><br><p> 完成这些操作后，可以按通常的方式使用Angular组件并将数据传递给它。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Angular"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 为了更好地使用更新组件，您可以考虑使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">变更检测策略</a> 。 我不会详细考虑这一点。 </p><br><h2 id="integraciya-vyhodnyh-dannyh"> 输出整合 </h2><br><p> 另一个问题仍然存在-应用程序对React组件内部事件的反应。 让我们<code>@Output</code>装饰器，并通过<code>@Output</code>将回调传递给组件。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = ({ name, onClick }) =&gt; ( &lt;div&gt; &lt;p&gt;Hello, {name}!&lt;/p&gt; &lt;button onClick={onClick}&gt;Say "hello"&lt;/button&gt; &lt;/div&gt; ); // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; @Input() name: string; @Output() click = new EventEmitter&lt;string&gt;(); ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = { name: this.name, onClick: () =&gt; this.lick.emit(`Hello, ${this.name}!`), }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p> 做完了 使用组件时，您可以注册事件处理程序并对其进行响应。 </p><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sayHello($event)"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 结果是在Angular应用程序中使用的React组件的全功能包装器。 它可以传输数据并响应其中的事件。 </p><br><h2 id="one-more-thing"> 还有一件事... </h2><br><p> 对我来说，Angular最方便的事情是双向数据绑定<code>ngModel</code> 。 它方便，简单，只需要很少的代码。 但是在当前的实现中，集成是不可能的。 这可以解决。 老实说，从内部设备的角度来看，我并不真正了解此机制的工作原理。 因此，我承认我的解决方案是超次优的，如果您在注释中写出一种更漂亮的方法来支持<code>ngModel</code> ，我将感到高兴。 </p><br><p> 首先，您需要实现<code>ControlValueAccessor</code>接口（从<code>@angular/forms</code>包中实现，并将新的提供者添加到组件中。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NG_VALUE_ACCESSOR, ControlValueAccessor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/forms'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> REACT_VALUE_ACCESSOR: any = { <span class="hljs-attr"><span class="hljs-attr">provide</span></span>: NG_VALUE_ACCESSOR, <span class="hljs-attr"><span class="hljs-attr">useExisting</span></span>: forwardRef(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> HelloComponent), <span class="hljs-attr"><span class="hljs-attr">multi</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-hello'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div #react&gt;&lt;/div&gt;`</span></span>, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [PREACT_VALUE_ACCESSOR], }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreactComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChanges</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlValueAccessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 该接口要求实现<code>onBlur</code> ， <code>writeValue</code> ， <code>registerOnChange</code> ， <code>registerOnTouched</code> 。 所有这些都在文档中进行了详细描述。 我们意识到他们。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const noop = () =&gt; {}; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, providers: [PREACT_VALUE_ACCESSOR], }) export class PreactComponent implements OnInit, OnChanges, ControlValueAccessor { // ... private innerValue: string; //      ngModel private onTouchedCallback: Callback = noop; private onChangeCallback: Callback = noop; //       //       get value(): string { return this.innerValue; } set value(v: string) { if (v !== this.innerValue) { this.innerValue = v; //    ,   this.onChangeCallback(v); } } writeValue(value: string) { if (value !== this.innerValue) { this.innerValue = value; //        this.renderReactElement(); } } //   registerOnChange(fn: Callback) { this.onChangeCallback = fn; } registerOnTouched(fn: Callback) { this.onTouchedCallback = fn; } //    onBlur() { this.onTouchedCallback(); } }</span></span></code> </pre> <br><p> 之后，您需要确保所有这些都传递给React组件。 不幸的是，React无法使用双向数据绑定，因此我们将为其赋予一个值和一个回调以对其进行更改。  <code>renderReactElement</code>方法。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... private renderReactElement() { const props = { name: this.name, onClick: () =&gt; this.lick.emit(`Hello, ${this.name}!`), model: { value: this.value, onChange: v =&gt; { this.value = v; } }, }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } // ...</span></span></code> </pre> <br><p> 在React组件中，我们将使用此值和回调。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hello = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, onClick, model }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello, {name}!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Say "hello"</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{model.value}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> model.onChange(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> );</span></span></code> </pre> <br><p> 现在，我们确实将React集成到Angular中。 您可以根据需要使用生成的组件。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sayHello($event)"</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h1 id="itog"> 总结 </h1><br><p>  React是一个非常简单的库，很容易与任何东西集成。 使用所示的方法，您不仅可以持续使用Angular应用程序内的任何React组件，还可以逐步迁移整个应用程序。 </p><br><p> 在本文中，我根本没有涉及样式问题。 如果您使用经典的CSS-in-JS解决方案（样式化组件，情感，JSS），则无需执行任何其他操作。 但是，如果该项目需要更有效的解决方案（astroturf，linaria，CSS模块），则需要进行webpack配置。 专题报道- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Angular应用程序中自定义Webpack配置</a> 。 </p><br><p> 要将应用程序从Angular完全迁移到React，您仍然需要解决在React-components中实现服务的问题。 一种简单的方法是将服务获取到包装器组件中，并将其通过props传递。 困难的方法是编写一个将通过令牌从注入器获取服务的层。 对这个问题的考虑超出了本文的范围。 </p><br><h1 id="bonus"> 红利 </h1><br><p> 重要的是要了解，通过这种对85KB Angular的方法，几乎​​添加了40KB的<code>react</code>和<code>react-dom</code>代码。 这可能会对应用程序的速度产生重大影响。 我建议考虑使用微型Preact，它只有3KB。 它的集成几乎没有什么不同。 </p><br><ol><li> 在<code>tsconfig.json</code>添加了一个新的编译选项- <code>"jsxFactory": "h"</code> ，这表明您需要使用<code>h</code>函数来转换JSX。 现在，在每个带有JSX代码的文件中- <code>import { h } from 'preact'</code> 。 </li><li> 对<code>React.createElement</code>所有调用<code>React.createElement</code>被<code>Preact.h</code>替换。 </li><li> 对<code>ReactDOM.render</code>所有调用<code>ReactDOM.render</code>被<code>Preact.render</code>替换。 </li></ol><br><p> 做完了！ 阅读有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从React迁移到Preact的说明</a> 。 实际上没有区别。 </p><br><h1 id="upd-19919-1649">  UPD 19.9.19 16.49 </h1><br><p> 评论中的主题链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Micro Frontends</a> </p><br><h1 id="upd-20919-1430">  UPD 20.9.19 14.30 </h1><br><p> 评论中的另一个主题链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Micro Frontends</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468063/">https://habr.com/ru/post/zh-CN468063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468047/index.html">在lsFusion中使用层次结构</a></li>
<li><a href="../zh-CN468053/index.html">机器学习助您一臂之力。 第一部分</a></li>
<li><a href="../zh-CN468057/index.html">类似于Unix的OS开发-多任务处理和系统调用（7）</a></li>
<li><a href="../zh-CN468059/index.html">我与Hai句的第二个星期：很多隐藏的钻石和令人惊喜的惊喜，以及一些问题</a></li>
<li><a href="../zh-CN468061/index.html">Linux上的Cron：历史记录，用法和设备</a></li>
<li><a href="../zh-CN468065/index.html">面向所有人的心理产品管理模型</a></li>
<li><a href="../zh-CN468067/index.html">Alpha合成如何工作</a></li>
<li><a href="../zh-CN468071/index.html">Tungsten Labs首席技术官Eduard Medvedev：“我们已经发展到技术可能造成巨大伤害的地步”</a></li>
<li><a href="../zh-CN468073/index.html">安德烈·捷列霍夫（Andrei Terekhov）：“您可以随心所欲地说美国人更好，但我们的汽车永远不会抛锚”</a></li>
<li><a href="../zh-CN468075/index.html">暹罗神经网络在搜索中的使用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>