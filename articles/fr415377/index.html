<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 🤷🏻 😤 Fonctionnement de JS: classes et héritage, transpilation dans Babel et TypeScript 👨🏻‍🔧 💯 👨🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les cours sont l'un des moyens les plus populaires de structurer des projets logiciels de nos jours. Cette approche de programmation est également uti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de JS: classes et héritage, transpilation dans Babel et TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/">  Les cours sont l'un des moyens les plus populaires de structurer des projets logiciels de nos jours.  Cette approche de programmation est également utilisée en JavaScript.  Aujourd'hui, nous publions une traduction de la partie 15 de la série d'écosystèmes JS.  Cet article abordera différentes approches pour implémenter des classes en JavaScript, les mécanismes d'héritage et la transpiration.  Nous allons commencer par vous expliquer le fonctionnement des prototypes et analyser différentes façons de simuler l'héritage basé sur les classes dans les bibliothèques populaires.  Ensuite, nous verrons comment, grâce à la transpilation, vous pouvez écrire des programmes JS qui utilisent des fonctionnalités qui ne sont pas disponibles dans la langue ou, bien qu'ils existent sous la forme de nouvelles normes ou propositions qui sont à différents stades d'approbation, ne sont pas encore implémentés dans JS- moteurs.  En particulier, nous parlerons de Babel et TypeScript et des classes ECMAScript 2015. Après cela, nous examinerons quelques exemples qui démontrent les caractéristiques de l'implémentation interne des classes dans le moteur J8 V8. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="image"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Conseiller la lecture] Les 19 autres parties du cycle</b> <div class="spoiler_text"> Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation du moteur, des mécanismes d'exécution, de la pile d'appels</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À propos des internes V8 et de l'optimisation du code</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gérer la mémoire, quatre types de fuites de mémoire et y faire face</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boucle d'événement, asynchrone et cinq façons d'améliorer votre code avec async / wait</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocket et HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que choisir?</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caractéristiques et portée de WebAssembly</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs Web et cinq scénarios d'utilisation</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs des services</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notifications push Web</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivre les changements dans le DOM avec MutationObserver</a> <br>  Partie 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs de rendu de page Web et conseils pour optimiser leurs performances</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-système réseau des navigateurs, optimisant ses performances et sa sécurité</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-système réseau des navigateurs, optimisant ses performances et sa sécurité</a> <br>  Partie 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Animation avec CSS et JavaScript</a> <br>  Partie 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a> <br>  Partie 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: classes et héritage, transpilation dans Babel et TypeScript</a> <br>  Partie 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: stockage</a> <br>  Partie 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: technologie Shadow DOM et composants Web</a> <br>  Partie 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: mécanismes de communication WebRTC et P2P</a> <br>  Partie 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: éléments personnalisés</a> </div></div><br><h2>  <font color="#3AC1EF">Revue</font> </h2><br>  En JavaScript, nous sommes constamment confrontés à des objets, même s'il semblerait que nous travaillons avec des types de données primitifs.  Par exemple, créez un littéral de chaîne: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br>  Après cela, nous pouvons immédiatement nous tourner vers <code>name</code> pour appeler diverses méthodes d'un objet de type <code>String</code> , dans lesquelles le littéral de chaîne que nous avons créé sera automatiquement converti. <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br>  Contrairement à d'autres langages, en JavaScript, après avoir créé une variable contenant par exemple une chaîne ou un nombre, on peut, sans effectuer de conversion explicite, travailler avec cette variable comme si elle avait été initialement créée à l'aide du <code>new</code> mot-clé et du constructeur correspondant.  Par conséquent, en raison de la création automatique d'objets encapsulant des valeurs primitives, vous pouvez travailler avec de telles valeurs comme s'il s'agissait d'objets, en particulier, faire référence à leurs méthodes et propriétés. <br><br>  Un autre fait notable concernant le système de type JavaScript est que, par exemple, les tableaux sont également des objets.  Si vous regardez la sortie de la commande <code>typeof</code> pour le tableau, vous pouvez voir qu'elle signale que l'entité sous enquête a le type de données <code>object</code> .  En conséquence, il s'avère que les indices des éléments du tableau ne sont que des propriétés d'un objet particulier.  Par conséquent, lorsque nous accédons à un élément d'un tableau par index, cela revient à travailler avec une propriété d'un objet de type <code>Array</code> et à obtenir la valeur de cette propriété.  Si nous parlons de la façon dont les données sont stockées à l'intérieur d'objets et de tableaux ordinaires, les deux constructions suivantes conduisent à la création de structures de données presque identiques: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  En conséquence, l'accès aux éléments du tableau et aux propriétés de l'objet s'effectue à la même vitesse.  L'auteur de cet article dit qu'il l'a découvert en résolvant un problème complexe.  À savoir, une fois qu'il avait besoin de procéder à une optimisation sérieuse d'un morceau de code très important dans le projet.  Après avoir essayé de nombreuses approches simples, il a décidé de remplacer tous les objets utilisés dans ce code par des tableaux.  En théorie, l'accès aux éléments du tableau est plus rapide que de travailler avec des clés de table de hachage.  À sa grande surprise, ce remplacement n'a eu aucune incidence sur les performances, car travailler avec des tableaux et travailler avec des objets en JavaScript revient à interagir avec les clés de la table de hachage, ce qui, dans les deux cas, nécessite le même temps. <br><br><h2>  <font color="#3AC1EF">Simuler des classes à l'aide de prototypes</font> </h2><br>  Quand on pense aux objets, la première chose qui me vient à l'esprit, ce sont les classes.  Peut-être que chacun de ceux qui se consacrent à la programmation aujourd'hui a créé des applications dont la structure est basée sur les classes et sur les relations entre elles.  Bien que les objets en JavaScript puissent être trouvés littéralement partout, le langage n'utilise pas un système d'héritage traditionnel basé sur les classes.  JavaScript utilise des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prototypes</a> pour résoudre des problèmes similaires. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">Objet et son prototype</font></i> <br><br>  En JavaScript, chaque objet est associé à un autre objet - avec son propre prototype.  Lorsque vous essayez d'accéder à une propriété ou une méthode d'un objet, la recherche de ce dont vous avez besoin est d'abord effectuée dans l'objet lui-même.  Si la recherche échoue, elle se poursuit dans le prototype de l'objet. <br><br>  Prenons un exemple simple qui décrit une fonction constructeur pour la classe de base <code>Component</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br>  Ici, nous affectons la fonction <code>render()</code> à la méthode prototype, car nous avons besoin de chaque instance de la classe <code>Component</code> pour utiliser cette méthode.  Lorsque, dans n'importe quelle instance de <code>Component</code> , la méthode de <code>render</code> est appelée, sa recherche commence dans l'objet lui-même pour lequel elle est appelée.  Ensuite, la recherche se poursuit dans le prototype, où le système trouve cette méthode. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">Prototype et deux instances de la classe Component</font></i> <br><br>  Essayons maintenant d'étendre la classe <code>Component</code> .  Créons un constructeur pour une nouvelle classe - <code>InputField</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br>  Si nous avons besoin de la classe <code>InputField</code> étendre les fonctionnalités de la classe <code>Component</code> et pouvoir appeler sa méthode de <code>render</code> , nous devons changer son prototype.  Lorsqu'une méthode est appelée sur une instance d'une classe enfant, cela n'a aucun sens de la rechercher dans un prototype vide.  Nous devons, dans la recherche de cette méthode, être trouvés dans la classe <code>Component</code> .  Par conséquent, nous devons procéder comme suit: <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br>  Désormais, lorsque vous travaillez avec une instance de la classe <code>InputField</code> et que vous appelez la méthode de la classe <code>Component</code> , cette méthode se trouve dans le prototype de la classe <code>Component</code> .  Pour implémenter le système d'héritage, vous devez connecter le prototype <code>InputField</code> à une instance de la classe <code>Component</code> .  De nombreuses bibliothèques utilisent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Object.setPrototypeOf ()</a> pour résoudre ce problème. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">Extension de la classe de composants avec la classe InputField</font></i> <br><br>  Cependant, les actions ci-dessus ne suffisent pas à mettre en œuvre un mécanisme similaire à l'héritage traditionnel.  Chaque fois que nous étendons la classe, nous devons effectuer les actions suivantes: <br><br><ul><li>  Faites du prototype de la classe descendante une instance de la classe parente. </li><li>  Appelez, dans le constructeur de la classe descendante, le constructeur de la classe parente pour vous assurer que la classe parente est correctement initialisée. </li><li>  Fournir un mécanisme pour appeler les méthodes de la classe parent dans les situations où la classe descendante remplace la méthode parent, mais il est nécessaire d'appeler l'implémentation d'origine de cette méthode à partir de la classe parent. </li></ul><br>  Comme vous pouvez le voir, si un développeur JS souhaite utiliser les capacités de l'héritage basé sur une classe, il devra constamment effectuer les étapes ci-dessus.  Dans le cas où vous avez besoin de créer de nombreuses classes, tout cela peut être réalisé sous forme de fonctions adaptées à la réutilisation. <br><br>  En fait, la tâche d'organiser l'héritage en fonction des classes a été initialement résolue dans la pratique du développement JS de cette manière.  En particulier, en utilisant diverses bibliothèques.  Ces solutions sont devenues très populaires, ce qui indique clairement que quelque chose manquait clairement dans JavaScript.  C'est pourquoi ECMAScript 2015 a introduit de nouvelles constructions syntaxiques visant à soutenir le travail avec les classes et à implémenter les mécanismes d'héritage correspondants. <br><br><h2>  <font color="#3AC1EF">Transpilation en classe</font> </h2><br>  Après que les nouvelles fonctionnalités d'ECMAScript 2015 (ES6) ont été proposées, la communauté JS a voulu en profiter dès que possible, sans attendre l'achèvement du long processus d'ajout de la prise en charge de ces fonctionnalités dans les moteurs et navigateurs JS.  Pour résoudre de tels problèmes, la transpilation est bonne.  Dans ce cas, la compilation se réduit à transformer le code JS écrit selon les règles d'ES6 en une vue compréhensible pour les navigateurs qui jusqu'à présent ne prennent pas en charge les capacités ES6.  Par conséquent, par exemple, il devient possible de déclarer des classes et d'implémenter des mécanismes d'héritage basés sur les classes selon les règles ES6 et de convertir ces constructions en code qui fonctionne dans n'importe quel navigateur.  Schématiquement, ce processus, en utilisant l'exemple du traitement d'une fonction flèche par un transpilateur (une autre nouvelle fonctionnalité de langage qui a besoin de temps pour être prise en charge), peut être représenté comme illustré dans la figure ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">Transpilation</font></i> <br><br>  Babel.js est l'un des transpilers JavaScript les plus populaires.  Voyons comment cela fonctionne en effectuant une compilation du code de déclaration de classe <code>Component</code> , dont nous avons parlé ci-dessus.  Voici donc le code ES6: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br>  Et voici ce que ce code se transforme après la transpilation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br>  Comme vous pouvez le voir, le code ECMAScript 5 est obtenu à la sortie du transpilateur, qui peut être exécuté dans n'importe quel environnement.  De plus, les appels à certaines fonctions qui font partie de la bibliothèque standard Babel sont ajoutés ici. <br><br>  Nous parlons des fonctions <code>_classCallCheck()</code> et <code>_createClass()</code> incluses dans le code transpilé.  La première fonction, <code>_classCallCheck()</code> , est conçue pour empêcher la fonction constructeur d'être appelée comme une fonction régulière.  Pour ce faire, il vérifie si le contexte dans lequel la fonction est appelée est le contexte d'instance de la classe <code>Component</code> .  Le code vérifie si le mot-clé this pointe vers une instance similaire.  La deuxième fonction, <code>_createClass()</code> , crée des propriétés d'objet qui lui sont transmises sous la forme d'un tableau d'objets contenant des clés et leurs valeurs. <br><br>  Afin de comprendre le fonctionnement de l'héritage, nous analysons la classe <code>InputField</code> , qui est la descendante de la classe <code>Component</code> .  Voici comment les relations de classe se rejoignent dans ES6: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Voici le résultat de la transposition de ce code à l'aide de Babel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br>  Dans cet exemple, la logique des mécanismes d'héritage est encapsulée dans un appel à la fonction <code>_inherits()</code> .  Il effectue les mêmes actions que celles décrites ci-dessus, associées notamment à l'écriture dans le prototype de la classe descendante d'une instance de la classe parente. <br><br>  Afin de transposer le code, Babel effectue plusieurs de ses transformations.  Premièrement, le code ES6 est analysé et converti en une représentation intermédiaire appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre de syntaxe abstraite</a> .  L'arbre de syntaxe abstraite résultant est ensuite converti en un autre arbre, dont chaque nœud est transformé en son équivalent ES5.  En conséquence, cet arbre est converti en code JS. <br><br><h2>  <font color="#3AC1EF">Arbre de syntaxe abstraite à Babel</font> </h2><br>  Un arbre de syntaxe abstraite contient des nœuds, dont chacun n'a qu'un seul nœud parent.  Babel a un type de base pour les nœuds.  Il contient des informations sur ce qu'est le nœud et où il peut être trouvé dans le code.  Il existe différents types de nœuds, par exemple, des nœuds pour représenter des littéraux, tels que des chaînes, des nombres, <code>null</code> valeurs <code>null</code> , etc.  De plus, il existe des nœuds pour représenter les expressions utilisées pour contrôler le flux d'exécution du programme ( <code>if</code> construction) et des nœuds pour les boucles ( <code>for</code> , <code>while</code> ).  Il existe également un type spécial de nœud pour représenter les classes.  Il s'agit d'un descendant de la classe de base <code>Node</code> .  Il étend cette classe en ajoutant des champs pour stocker des références à la classe de base et au corps de la classe en tant que nœud distinct. <br>  Convertissez le fragment de code suivant en une arborescence de syntaxe abstraite: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br>  Voici à quoi ressemblera sa représentation schématique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">Arbre de syntaxe abstraite</font></i> <br><br>  Après avoir créé une arborescence, chacun de ses nœuds est transformé en son nœud ES5 correspondant, après quoi cette nouvelle arborescence est convertie en code conforme à la norme ECMAScript 5. Au cours du processus de conversion, recherchez d'abord le nœud le plus éloigné du nœud racine, après quoi ce nœud est converti en code à l'aide d'extraits générés pour chaque nœud.  Après cela, le processus est répété.  Cette technique est appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche approfondie</a> . <br><br>  Dans l'exemple ci-dessus, le code pour les deux nœuds <code>MethodDefinition</code> sera généré en premier, après quoi le code pour le nœud <code>ClassBody</code> sera généré, et enfin, le code pour le nœud <code>ClassDeclaration</code> . <br><br><h2>  <font color="#3AC1EF">Transpilation TypeScript</font> </h2><br>  Un autre système populaire qui utilise la transpilation est TypeScript.  Il s'agit d'un langage de programmation dont le code est transformé en code ECMAScript 5 compréhensible par tout moteur JS.  Il offre une nouvelle syntaxe pour l'écriture d'applications JS.  Voici comment implémenter la classe <code>Component</code> sur TypeScript: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br>  Voici l'arbre de syntaxe abstrait de ce code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">Arbre de syntaxe abstraite</font></i> <br><br>  TypeScript prend en charge l'héritage. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Voici le résultat de la transpilation de ce code: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br>  Comme vous pouvez le voir, il s'agit là encore d'un code ES5, dans lequel, en plus des constructions standard, il y a des appels à certaines fonctions de la bibliothèque TypeScript.  Les capacités de la fonction <code>__extends()</code> similaires à celles dont nous avons parlé au tout début de ce document. <br><br>  Grâce à l'adoption généralisée de Babel et de TypeScript, les mécanismes de déclaration des classes et d'organisation de l'héritage basé sur les classes sont devenus des outils standard pour structurer les applications JS.  Cela a contribué à l'ajout de la prise en charge de ces mécanismes dans les navigateurs. <br><br><h2>  <font color="#3AC1EF">Prise en charge des classes de navigateur</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La prise</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge des cours</a> est apparue dans le navigateur Chrome en 2014.  Cela permet au navigateur de travailler avec les déclarations de classe sans utiliser de transpilation ou de bibliothèques auxiliaires. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">Travailler avec des classes dans la console Chrome JS</font></i> <br><br>  En fait, la prise en charge du navigateur pour ces mécanismes n'est rien d'autre que du sucre syntaxique.  Ces constructions sont converties dans les mêmes structures de base qui sont déjà prises en charge par le langage.  Par conséquent, même si vous utilisez la nouvelle syntaxe, à un niveau inférieur, tout ressemblera à la création de constructeurs et à la manipulation de prototypes d'objets: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">Le support de classe est le sucre syntaxique</font></i> <br><br><h2>  <font color="#3AC1EF">Support de classe dans V8</font> </h2><br>  Parlons du fonctionnement de la prise en charge de la classe ES6 dans le moteur V8 JS.  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matériel précédent</a> consacré aux arbres de syntaxe abstraite, nous avons parlé du fait que lors de la préparation du code JS pour l'exécution, le système le parse et forme un arbre de syntaxe abstraite sur sa base.  Lors de l'analyse des constructions de déclarations de classe, les nœuds de type <a href="">ClassLiteral</a> tombent dans l'arbre de syntaxe abstrait. <br><br>  Ces nœuds stockent quelques éléments intéressants.  Premièrement, c'est un constructeur en tant que fonction distincte, et deuxièmement, c'est une liste de propriétés de classe.  Il peut s'agir de méthodes, de getters, de setters, de domaines publics ou privés.  Un tel nœud, en outre, stocke une référence à la classe parent, qui étend la classe pour laquelle le nœud est formé, qui, encore une fois, stocke le constructeur, la liste des propriétés et un lien vers sa propre classe parent. <br><br>  Une fois le nouveau nœud <code>ClassLiteral</code> <a href="">transformé en code</a> , il est converti en constructions composées de fonctions et de prototypes. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  L'auteur de ce document dit que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SessionStack</a> s'efforce d'optimiser le code de sa bibliothèque aussi complètement que possible, car il doit résoudre des tâches difficiles de collecte d'informations sur tout ce qui se passe sur les pages Web.  Au cours de la résolution de ces problèmes, la bibliothèque ne doit pas ralentir le travail de la page analysée.  L'optimisation de ce niveau nécessite de prendre en compte les moindres détails de l'écosystème JavaScript qui affectent les performances, en particulier, en tenant compte des caractéristiques de la façon dont les classes et les mécanismes d'héritage sont organisés dans ES6. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous des constructions de syntaxe ES6 pour travailler avec des classes en JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415377/">https://habr.com/ru/post/fr415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415367/index.html">Et si les extraterrestres s'avéraient être des machines à intelligence artificielle?</a></li>
<li><a href="../fr415369/index.html">Refactoring Prix</a></li>
<li><a href="../fr415371/index.html">Confidentialité des crypto-monnaies</a></li>
<li><a href="../fr415373/index.html">NumPy en Python. Partie 4</a></li>
<li><a href="../fr415375/index.html">Mouton caché et archéologie typographique</a></li>
<li><a href="../fr415381/index.html">Jouer avec Kubernetes - service pour une connaissance pratique des K8</a></li>
<li><a href="../fr415383/index.html">Le commerçant novice a conclu un accord de 5,5 milliards d'euros en raison d'une erreur dans le système du courtier britannique</a></li>
<li><a href="../fr415385/index.html">La situation DCIM: comment la gestion de l'infrastructure des centres de données a changé ces dernières années</a></li>
<li><a href="../fr415387/index.html">Chaque développeur veut savoir comment se lancer dans le phishing.</a></li>
<li><a href="../fr415389/index.html">Aujourd'hui, le système de paiement "VKontakte"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>