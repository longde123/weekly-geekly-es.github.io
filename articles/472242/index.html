<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêî üõÄ üôèüèø Hemos acelerado el planificador de Tokio diez veces üë®üèª‚Äçüî¨ üßìüèΩ üíù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estamos en el proceso de preparar la pr√≥xima versi√≥n principal de Tokio, un entorno de tiempo de ejecuci√≥n as√≠ncrono para Rust. El 13 de octubre, se e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hemos acelerado el planificador de Tokio diez veces</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472242/"> Estamos en el proceso de preparar la pr√≥xima versi√≥n principal de Tokio, un entorno de tiempo de ejecuci√≥n as√≠ncrono para Rust.  El 13 de octubre, se emiti√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud de grupo</a> con un planificador de tareas completamente reescrito para fusionarse en una rama.  El resultado ser√°n grandes mejoras de rendimiento y una latencia reducida.  ¬°Algunas pruebas registraron una aceleraci√≥n de diez veces!  Como de costumbre, las pruebas sint√©ticas no reflejan los beneficios reales en la realidad.  Por lo tanto, tambi√©n verificamos c√≥mo los cambios en el planificador afectaron tareas reales, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hyper</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tonic</a> (spoiler: el resultado es maravilloso). <br><br>  Prepar√°ndome para trabajar en un nuevo planificador, pas√© tiempo buscando recursos tem√°ticos.  Aparte de las implementaciones reales, no se encontr√≥ nada especial.  Tambi√©n descubr√≠ que el c√≥digo fuente de las implementaciones existentes es dif√≠cil de navegar.  Para solucionar esto, tratamos de escribir el programador de Tokio lo m√°s limpio posible.  Espero que este art√≠culo detallado sobre la implementaci√≥n del programador ayude a aquellos que est√°n en la misma posici√≥n y buscan sin √©xito informaci√≥n sobre este tema. <br><br>  El art√≠culo comienza con una revisi√≥n de alto nivel del dise√±o, incluidas las pol√≠ticas de captura de trabajo.  Luego sum√©rgete en los detalles de optimizaciones espec√≠ficas en el nuevo planificador de Tokio. <br><a name="habracut"></a><br>  Optimizaciones consideradas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuevo std :: sistema de tareas futuras</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elegir el mejor algoritmo de cola</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simplifique las plantillas de mensajes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Captura del acelerador</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reduce la sincronizaci√≥n entre hilos</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reduce la asignaci√≥n de memoria</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conteo de enlaces at√≥micos reducido</a> </li></ul><br>  Como puede ver, el tema principal es "reducci√≥n".  Despu√©s de todo, ¬°el c√≥digo m√°s r√°pido es su falta! <br><br>  Tambi√©n hablaremos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">probar el nuevo planificador</a> .  Es muy dif√≠cil escribir el c√≥digo paralelo correcto sin bloqueos.  Es mejor trabajar lentamente, pero correctamente, que r√°pidamente, pero con fallas, especialmente si los errores est√°n relacionados con la seguridad de la memoria.  La mejor opci√≥n, sin embargo, deber√≠a funcionar r√°pidamente y sin errores, por lo que escribimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Loom</a> , una herramienta de prueba de concurrencia. <br><br>  Antes de sumergirme en el tema, quiero agradecer a: <br><br><ul><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@withoutboats</a></b> y otros que trabajaron en la funci√≥n <code>async / await</code> en Rust.  Hiciste un gran trabajo.  Esta es una caracter√≠stica asesina. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@cramertj</a></b> y otros que desarrollaron <code>std::task</code> .  Esta es una gran mejora sobre lo que era antes.  Y gran c√≥digo. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boyante</a></b> , el creador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linkerd,</a> y lo m√°s importante, mi empleador.  Gracias por dejarme pasar tanto tiempo en este trabajo.  Si alguien est√° interesado en la malla de servicios, eche un vistazo a Linkerd.  Pronto incluir√° todos los beneficios discutidos en este art√≠culo. <br></li><li>  <b><a href="">Ve</a></b> por una implementaci√≥n tan buena del planificador. </li></ul><br>  Toma una taza de caf√© y si√©ntate.  Este ser√° un art√≠culo largo. <br><br><h1>  ¬øC√≥mo funcionan los planificadores? </h1><br>  La tarea del planificador es planificar el trabajo.  La aplicaci√≥n se divide en unidades de trabajo, que llamaremos <i>tareas</i> .  Una tarea se considera ejecutable cuando puede avanzar en su ejecuci√≥n, pero ya no se realiza o en modo inactivo, cuando est√° bloqueada en un recurso externo.  Las tareas son independientes en el sentido de que cualquier cantidad de tareas se pueden realizar simult√°neamente.  El planificador es responsable de ejecutar tareas en un estado de ejecuci√≥n hasta que regresen al modo de espera.  La ejecuci√≥n de la tarea implica asignar tiempo de procesador a la tarea, un recurso global. <br><br>  El art√≠culo analiza los planificadores de espacio de usuario, es decir, trabajar sobre los hilos del sistema operativo (que, a su vez, est√°n controlados por un programador de nivel de n√∫cleo).  El programador de Tokio ejecuta futuros de Rust, que pueden considerarse como "hilos verdes as√≠ncronos".  Este es un patr√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transmisi√≥n mixta M: N</a> en el que muchas tareas de la interfaz de usuario se multiplexan en m√∫ltiples subprocesos del sistema operativo. <br><br>  Hay muchas formas diferentes de simular un programador, cada una con sus propios pros y contras.  En el nivel m√°s b√°sico, el planificador se puede modelar como una <i>cola de ejecuci√≥n</i> y un <i>procesador</i> que lo separa.  Un procesador es una pieza de c√≥digo que se ejecuta en un hilo.  En pseudoc√≥digo, hace lo siguiente: <br><br><pre> <code class="plaintext hljs">while let Some(task) = self.queue.pop() { task.run(); }</code> </pre> <br>  Cuando una tarea se vuelve factible, se inserta en la cola de ejecuci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff6/1f4/18f/ff61f418f73f08c62b5e9eaeacaeb8ed.png"><br><br>  Aunque puede dise√±ar un sistema en el que existan recursos, tareas y un procesador en el mismo hilo, Tokio prefiere usar m√∫ltiples hilos.  Vivimos en un mundo donde una computadora tiene muchos procesadores.  El desarrollo de un planificador de un solo subproceso conducir√° a una carga insuficiente de hierro.  Queremos usar todas las CPU.  Hay varias formas de hacer esto: <br><br><ul><li>  Una cola de ejecuci√≥n global, muchos procesadores. <br></li><li>  Muchos procesadores, cada uno con su propia cola de ejecuci√≥n. </li></ul><br><h3>  Una vuelta, muchos procesadores </h3><br>  Este modelo tiene una cola de ejecuci√≥n global.  Cuando las tareas se completan, se colocan en la cola de la cola.  Hay varios procesadores, cada uno en un hilo separado.  Cada procesador toma una tarea del jefe de la cola o bloquea el hilo si no hay tareas disponibles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85c/8d0/23d/85c8d023dfeba249bba01234e0e8783a.png"><br><br>  La l√≠nea de ejecuci√≥n debe ser apoyada por muchos fabricantes y consumidores.  Por lo general, se utiliza una lista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intrusiva</a> , en la que la estructura de cada tarea incluye un puntero a la siguiente tarea en la cola (en lugar de envolver las tareas en una lista vinculada).  Por lo tanto, se puede evitar la asignaci√≥n de memoria para operaciones push y pop.  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la operaci√≥n de inserci√≥n sin bloqueo</a> , pero para coordinar a los consumidores, se requiere el mutex para la operaci√≥n emergente (es t√©cnicamente posible implementar una cola multiusuario sin bloqueo). <br><br>  Sin embargo, en la pr√°ctica, la sobrecarga para una protecci√≥n adecuada contra bloqueos es m√°s que simplemente usar un mutex. <br><br>  Este enfoque se usa a menudo para un grupo de subprocesos de uso general, porque tiene varias ventajas: <br><br><ul><li>  Las tareas est√°n bastante planificadas. <br></li><li>  Implementaci√≥n relativamente simple.  Una cola m√°s o menos est√°ndar se interconecta con el ciclo del procesador descrito anteriormente. </li></ul><br>  Una breve nota sobre la planificaci√≥n justa (equitativa).  Significa que las tareas se llevan a cabo honestamente: quien vino antes es el que se fue antes.  Los planificadores de prop√≥sito general intentan ser justos, pero hay excepciones, como la paralelizaci√≥n a trav√©s de la uni√≥n de la bifurcaci√≥n, donde la velocidad de c√°lculo del resultado, en lugar de la justicia para cada subtarea individual, es un factor importante. <br><br>  Este modelo tiene un inconveniente.  Todos los procesadores solicitan tareas desde la cabecera de la cola.  Para hilos de prop√≥sito general, esto generalmente no es un problema.  El tiempo para completar una tarea supera con creces el tiempo para recuperarla de la cola.  Cuando las tareas se realizan durante un largo per√≠odo de tiempo, se reduce la competencia en la cola.  Sin embargo, se espera que las tareas de Rust asincr√≥nicas se completen muy r√°pidamente.  En este caso, los costos generales para la pelea en la cola aumentan significativamente. <br><br><h3>  Concurrencia y simpat√≠a mec√°nica. </h3><br>  Para lograr el m√°ximo rendimiento, debemos aprovechar al m√°ximo las caracter√≠sticas del hardware.  El t√©rmino "simpat√≠a mec√°nica" para el software fue utilizado por primera vez por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Martin Thompson</a> (cuyo blog ya no se actualiza, pero sigue siendo muy informativo). <br><br>  Una discusi√≥n detallada de la implementaci√≥n del paralelismo en equipos modernos est√° m√°s all√° del alcance de este art√≠culo.  En t√©rminos generales, el hierro aumenta la productividad no debido a la aceleraci√≥n, sino a la introducci√≥n de una mayor cantidad de n√∫cleos de CPU (¬°incluso mi computadora port√°til tiene seis!) Cada n√∫cleo puede realizar grandes cantidades de c√≥mputo en peque√±os intervalos de tiempo.  Las acciones como acceder a la memoria cach√© y la memoria requieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucho m√°s tiempo en</a> relaci√≥n con el tiempo de ejecuci√≥n en la CPU.  Por lo tanto, para acelerar las aplicaciones, debe maximizar el n√∫mero de instrucciones de la CPU para cada acceso a la memoria.  Aunque el compilador ayuda mucho, a√∫n tenemos que pensar en cosas como la alineaci√≥n y los patrones de acceso a la memoria. <br><br>  Los subprocesos separados funcionan de manera muy parecida a un subproceso √∫nico aislado, <b>hasta que</b> varios subprocesos modifiquen simult√°neamente la misma l√≠nea de cach√© (mutaciones concurrentes) o se requiera una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coherencia constante</a> .  En este caso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> activa el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo de coherencia de cach√© de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CPU</a> .  Garantiza la relevancia de la memoria cach√© de cada CPU. <br><br>  La conclusi√≥n es obvia: en la medida de lo posible, evite la sincronizaci√≥n entre hilos, porque es lenta. <br><br><h3>  Muchos procesadores, cada uno con su propia cola de ejecuci√≥n </h3><br>  Otro modelo son varios planificadores de subproceso √∫nico.  Cada procesador recibe su propia cola de ejecuci√≥n y las tareas se fijan en un procesador espec√≠fico.  Esto evita completamente el problema de sincronizaci√≥n.  Dado que el modelo de tarea Rust requiere la capacidad de poner en cola una tarea desde cualquier subproceso, todav√≠a debe haber una forma segura de subprocesos para ingresar tareas en el planificador.  La cola de ejecuci√≥n de cada procesador admite la operaci√≥n de inserci√≥n segura para subprocesos (MPSC) o cada procesador tiene <b>dos</b> colas de ejecuci√≥n: no sincronizada y segura para subprocesos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/a3c/35e/c6da3c35e7f6fb28b63fdb3ff6417882.png"><br><br>  Esta estrategia utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seastar</a> .  Como evitamos casi por completo la sincronizaci√≥n, esta estrategia ofrece muy buena velocidad.  Pero ella no resuelve todos los problemas.  Si la carga de trabajo no es completamente homog√©nea, algunos procesadores est√°n bajo carga, mientras que otros est√°n inactivos, lo que conduce a un uso no √≥ptimo de los recursos.  Esto sucede porque las tareas se arreglan en un procesador espec√≠fico.  Cuando se planifica un grupo de tareas en un paquete en un procesador, solo alcanza la carga m√°xima, incluso si otras est√°n inactivas. <br><br>  La mayor√≠a de las cargas de trabajo "reales" no son homog√©neas.  Por lo tanto, los planificadores de prop√≥sito general generalmente evitan este modelo. <br><br><h3>  Programador de captura de trabajo </h3><br>  El planificador con planificadores de robo de trabajo se basa en el modelo de planificador fragmentado y resuelve el problema de la carga incompleta de recursos de hardware.  Cada procesador admite su propia cola de ejecuci√≥n.  Las tareas que se realizan se colocan en la cola de ejecuci√≥n del procesador actual y funciona en √©l.  Pero cuando el procesador est√° inactivo, comprueba las colas del procesador hermano e intenta tomar algo de all√≠.  El procesador pasa al modo de suspensi√≥n solo despu√©s de que no puede encontrar trabajo en las colas de ejecuci√≥n de igual a igual. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/561/9a9/02c/5619a902c1d95252d20ac7db1273e57f.png"><br><br>  A nivel de modelo, este es el enfoque de "lo mejor de ambos mundos".  Bajo carga, los procesadores funcionan de forma independiente, evitando la sincronizaci√≥n de sobrecarga.  En los casos en que la carga entre los procesadores se distribuye de manera desigual, el planificador puede redistribuirla.  Es por eso que tales planificadores se usan en <a href="">Go</a> , <a href="">Erlang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> y otros idiomas. <br><br>  La desventaja es que este enfoque es mucho m√°s complicado.  El algoritmo de la cola debe admitir la captura de trabajos, y para una ejecuci√≥n fluida se requiere <b>cierta</b> sincronizaci√≥n entre los procesadores.  Si no se implementa correctamente, la sobrecarga para la captura puede ser m√°s que la ganancia. <br><br>  Considere esta situaci√≥n: el procesador A est√° ejecutando actualmente una tarea y tiene una cola de ejecuci√≥n vac√≠a.  El procesador B est√° inactivo;  intenta capturar alguna tarea, pero falla, por lo que pasa al modo de suspensi√≥n.  Luego se generan 20 tareas de la tarea del procesador A.  Idealmente, el procesador B deber√≠a despertarse y tomar algunos de ellos.  Para esto, es necesario implementar ciertas heur√≠sticas en el planificador, donde los procesadores se√±alan a los procesadores pares inactivos sobre la aparici√≥n de nuevas tareas en su cola.  Por supuesto, esto requiere sincronizaci√≥n adicional, por lo que estas operaciones se minimizan mejor. <br><br>  En resumen: <br><br><ul><li>  Cuanto menos sincronizaci√≥n, mejor. <br></li><li>  La captura de trabajos es el algoritmo √≥ptimo para los planificadores de prop√≥sito general. <br></li><li>  Cada procesador funciona independientemente de los dem√°s, pero se requiere cierta sincronizaci√≥n para capturar el trabajo. </li></ul><br><h1>  Tokio 0.1 Scheduler </h1><br>  El primer planificador de trabajo para Tokio se lanz√≥ en marzo de 2018.  Este fue el primer intento, basado en algunas suposiciones que resultaron estar equivocadas. <br><br>  En primer lugar, el programador Tokio 0.1 sugiri√≥ que los hilos del procesador deber√≠an cerrarse si estaban inactivos durante un cierto per√≠odo de tiempo.  El planificador se cre√≥ originalmente como un sistema de "prop√≥sito general" para el grupo de subprocesos Rust.  En ese momento, el tiempo de ejecuci√≥n de Tokio todav√≠a estaba en una etapa temprana de desarrollo.  Luego, el modelo asumi√≥ que las tareas de E / S se realizar√≠an en el mismo hilo que el selector de E / S (epoll, kqueue, iocp ...).  Se podr√≠an dirigir m√°s tareas computacionales al grupo de subprocesos.  En este contexto, se supone una configuraci√≥n flexible del n√∫mero de subprocesos activos, por lo que tiene m√°s sentido deshabilitar los subprocesos inactivos.  Sin embargo, en el planificador con captura de trabajo, el modelo cambi√≥ para realizar <i>todas</i> las tareas asincr√≥nicas, y en este caso tiene sentido mantener siempre un peque√±o n√∫mero de subprocesos en el estado activo. <br><br>  En segundo lugar, se implement√≥ una l√≠nea de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">viga transversal de</a> dos v√≠as.  Esta implementaci√≥n se basa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠nea de Chase-Lev bidireccional</a> , y no es adecuada para planificar tareas asincr√≥nicas independientes por los motivos que se describen a continuaci√≥n. <br><br>  En tercer lugar, la implementaci√≥n result√≥ ser demasiado complicada.  Esto se debe en parte al hecho de que este fue mi primer programador de tareas.  Adem√°s, estaba demasiado impaciente cuando usaba at√≥mica en las ramas, donde el mutex hubiera funcionado bien.  Una lecci√≥n importante es que muy a menudo son los mutexes los que funcionan mejor. <br><br>  Finalmente, hubo muchos defectos menores en la implementaci√≥n inicial.  En los primeros a√±os, los detalles de implementaci√≥n del modelo Rust as√≠ncrono evolucionaron significativamente, pero las bibliotecas mantuvieron la API estable todo el tiempo.  Esto condujo a la acumulaci√≥n de alguna deuda t√©cnica. <br><br>  Ahora Tokio se acerca al primer lanzamiento importante, y podemos pagar toda esta deuda, as√≠ como aprender de la experiencia adquirida durante los a√±os de desarrollo.  Este es un momento emocionante! <br><br><h1>  Programador de Tokio de pr√≥xima generaci√≥n </h1><br>  Ahora es el momento de mirar m√°s de cerca lo que ha cambiado en el nuevo programador. <br><br><a name="1"></a><h3>  Nuevo sistema de tareas </h3><br>  Primero, es importante resaltar lo que <b>no</b> es parte de Tokio, pero es crucial en t√©rminos de mejorar la eficiencia: este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuevo sistema de tareas</a> <code>std</code> , desarrollado originalmente por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Taylor Kramer</a> .  Este sistema proporciona los ganchos que el planificador debe implementar para realizar tareas de Rust asincr√≥nicas, y el sistema est√° verdaderamente excelentemente dise√±ado e implementado.  Es mucho m√°s ligero y m√°s flexible que la iteraci√≥n anterior. <br><br>  La estructura de <code>Waker</code> de los recursos indica que hay una tarea <i>factible</i> que debe colocarse en la cola del planificador.  En el nuevo sistema de tareas, esta es una estructura de dos punteros, mientras que antes era mucho m√°s grande.  Reducir el tama√±o es importante para minimizar la sobrecarga de copiar el valor de <code>Waker</code> en diferentes lugares, y ocupa menos espacio en las estructuras, lo que le permite exprimir datos m√°s importantes en la l√≠nea de cach√©.  El dise√±o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vtable</a> hizo una serie de optimizaciones, que discutiremos m√°s adelante. <br><br><a name="2"></a><h3>  Elegir el mejor algoritmo de cola </h3><br>  La cola de ejecuci√≥n est√° en el centro del planificador.  Por lo tanto, este es el componente m√°s importante para arreglar.  El programador original de Tokio utiliz√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cola de</a> dos v√≠as: una implementaci√≥n de fuente √∫nica (productor) y muchos consumidores.  Una tarea se coloca en un extremo y los valores se recuperan del otro.  La mayor√≠a de las veces, el hilo "empuja" los valores desde el final de la cola, pero a veces otros hilos interceptan el trabajo, realizando la misma operaci√≥n.  La cola bidireccional es compatible con una matriz y un conjunto de √≠ndices que siguen la cabeza y la cola.  Cuando la cola est√° llena, su introducci√≥n dar√° lugar a un aumento en el espacio de almacenamiento.  Se asigna una nueva matriz m√°s grande y los valores se mueven al nuevo almacenamiento. <br><br>  La capacidad de crecer se logra a trav√©s de la complejidad y los gastos generales.  Las operaciones push / pop deber√≠an tener en cuenta este crecimiento.  Adem√°s, liberar la matriz original est√° lleno de dificultades adicionales.  En un lenguaje de recolecci√≥n de basura (GC), la matriz anterior quedar√° fuera de alcance y eventualmente el GC la borrar√°.  Sin embargo, Rust se env√≠a sin un GC.  Esto significa que nosotros mismos somos responsables de liberar la matriz, pero los hilos pueden intentar acceder a la memoria al mismo tiempo.  Para resolver este problema, crossbeam utiliza una estrategia de recuperaci√≥n basada en la √©poca.  Aunque no requiere muchos recursos, agrega una sobrecarga no trivial a la ruta principal (ruta activa).  Cada operaci√≥n ahora debe realizar operaciones at√≥micas de RMW (lectura-modificaci√≥n-escritura) en la entrada y salida de secciones cr√≠ticas para indicar a otros hilos que la memoria est√° en uso y no se puede borrar. <br><br>  Debido a la sobrecarga para el crecimiento de la cola de ejecuci√≥n, tiene sentido pensar: ¬øes realmente necesario el apoyo para este crecimiento?  Esta pregunta finalmente me llev√≥ a reescribir el planificador.  La nueva estrategia es tener un tama√±o de cola fijo para cada proceso.  Cuando la cola est√° llena, en lugar de aumentar la cola local, la tarea pasa a la cola global con varios consumidores y varios productores.  Los procesadores verificar√°n peri√≥dicamente esta cola global, pero a una frecuencia mucho menor que la local. <br><br>  Como parte de uno de los primeros experimentos, reemplazamos la viga transversal con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mpmc</a> .  Esto no condujo a una mejora significativa debido a la cantidad de sincronizaci√≥n para push y pop.  La clave para capturar el trabajo es que casi no hay competencia en las colas bajo carga, ya que cada procesador solo accede a su propia cola. <br><br>  En esta etapa, decid√≠ estudiar cuidadosamente las fuentes de Go, y descubr√≠ que usan un tama√±o de cola fijo con un fabricante y varios consumidores, con una sincronizaci√≥n m√≠nima, lo cual es muy impresionante.  Para adaptar el algoritmo al planificador de Tokio, hice algunos cambios.  Es de destacar que la implementaci√≥n de Go utiliza operaciones at√≥micas secuenciales (seg√∫n tengo entendido).  La versi√≥n de Tokio tambi√©n reduce el n√∫mero de algunas operaciones de copia en ramas de c√≥digo m√°s raras. <br><br>  Una implementaci√≥n de cola es un b√∫fer circular que almacena valores en una matriz.  La cabeza y la cola de la cola son rastreadas por operaciones at√≥micas con valores enteros. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// Concurrently updated by many threads. head: AtomicU32, /// Only updated by producer thread but read by many threads. tail: AtomicU32, /// Masks the head / tail position value to obtain the index in the buffer. mask: usize, /// Stores the tasks. buffer: Box&lt;[MaybeUninit&lt;Task&gt;]&gt;, }</span></span></code> </pre> <br>  La cola se realiza mediante un solo hilo: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if tail.wrapping_sub(head) &lt; self.buffer.len() as u32 { // Map the position to a slot index. let idx = tail as usize &amp; self.mask; // Don't drop the previous value in `buffer[idx]` because // it is uninitialized memory. self.buffer[idx].as_mut_ptr().write(task); // Make the task available self.tail.store(tail.wrapping_add(1), Release); return; } // The local buffer is full. Push a batch of work to the global // queue. match self.push_overflow(task, head, tail, global) { Ok(_) =&gt; return, // Lost the race, try again Err(v) =&gt; task = v, } }</span></span></code> </pre> <br>  Tenga en cuenta que en esta funci√≥n de <code>push</code> , las √∫nicas operaciones at√≥micas son cargar con la <code>Acquire</code> pedidos y guardar con la <code>Release</code> pedidos.  No hay operaciones RMW ( <code>compare_and_swap</code> , <code>fetch_and</code> ...) u orden secuencial como antes.  Esto es importante porque en los chips x86 todas las descargas / guardados ya son "at√≥micos".  Por lo tanto, a nivel de CPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta funci√≥n no se sincronizar√°</a> .  Las operaciones at√≥micas evitar√°n ciertas optimizaciones en el compilador, pero eso es todo.  Lo m√°s probable es que la primera operaci√≥n de <code>load</code> pueda realizar de forma segura con un pedido <code>Relaxed</code> , pero el reemplazo no conlleva ninguna sobrecarga notable. <br><br>  Cuando la cola est√° llena, se <code>push_overflow</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta funci√≥n mueve la mitad de las tareas de la cola local a la cola global. La cola global es una lista intrusiva protegida por un mutex. Al pasar a la cola global, las tareas primero se vinculan entre s√≠, luego se crea un mutex y todas las tareas se insertan actualizando el puntero a la cola de la cola global. Esto ahorra un peque√±o tama√±o de secci√≥n cr√≠tica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si est√° familiarizado con los detalles del ordenamiento de la memoria at√≥mica, puede notar un "problema" potencial con la funci√≥n que se muestra arriba </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La operaci√≥n de </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordenamiento </font><font style="vertical-align: inherit;">at√≥mico es </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bastante d√©bil. Puede devolver valores obsoletos, es decir, una operaci√≥n de captura paralela ya puede aumentar el valor </font></font><code>self.head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero en la memoria cach√© de flujo</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el valor anterior permanecer√°, por lo que no notar√° la operaci√≥n de captura. Esto no es un problema con la correcci√≥n del algoritmo. En la forma principal (r√°pida), </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo nos importa si la cola local est√° llena o no. Dado que solo el hilo actual puede empujar la cola, una operaci√≥n desactualizada </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente har√° que la cola se vea m√°s llena de lo que realmente es. Puede determinar incorrectamente que la cola est√° llena y causar </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero esta funci√≥n incluye una operaci√≥n at√≥mica m√°s fuerte. Si </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determina que la cola no est√° llena, devuelve w / </font></font><code>Err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la operaci√≥n </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comienza nuevamente. Esta es otra raz√≥n por la cual</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mueve la mitad de la cola de ejecuci√≥n a la cola global. </font><font style="vertical-align: inherit;">Despu√©s de este movimiento, estos falsos positivos ocurren con mucha menos frecuencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(desde el procesador al que pertenece la cola) tambi√©n se implementa simplemente:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if head == tail { // queue is empty return None; } // Map the head position to a slot index. let idx = head as usize &amp; self.mask; let task = self.buffer[idx].as_ptr().read(); // Attempt to claim the task read above. let actual = self .head .compare_and_swap(head, head.wrapping_add(1), Release); if actual == head { return Some(task.assume_init()); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta funci√≥n, uno at√≥mico </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y otro </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La sobrecarga principal proviene de </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es similar a </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero la </font></font><code>self.tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carga at√≥mica debe transferirse </font><font style="vertical-align: inherit;">desde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adem√°s, de manera similar </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la operaci√≥n </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intenta pretender ser la mitad de la cola en lugar de una sola tarea. </font><font style="vertical-align: inherit;">Esto tiene un buen efecto en el rendimiento, que discutiremos m√°s adelante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima parte que falta es el an√°lisis de la cola global, que recibe tareas que desbordan las colas locales, as√≠ como para transferir tareas al planificador desde subprocesos que no son del procesador. </font><font style="vertical-align: inherit;">Si el procesador est√° bajo carga, es decir, hay tareas en la cola local, el procesador intentar√° sacar las tareas de la cola global despu√©s de cada 60 tareas en la cola local. </font><font style="vertical-align: inherit;">Tambi√©n comprueba la cola global cuando est√° en el estado de "b√∫squeda" que se describe a continuaci√≥n.</font></font><br><br><a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifique las plantillas de mensajes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las aplicaciones de Tokio generalmente consisten en muchas tareas peque√±as e independientes. Interact√∫an entre s√≠ a trav√©s de mensajes. Dicha plantilla es similar a otros idiomas como Go y Erlang. Dado lo com√∫n que es la plantilla, tiene sentido que el planificador la optimice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponga que se dan las tareas A y B. La tarea A ahora se est√° ejecutando y env√≠a un mensaje a la tarea B a trav√©s del canal de transmisi√≥n. Un canal es un recurso en el que la tarea B est√° bloqueada actualmente, por lo que la acci√≥n de enviar un mensaje har√° que la tarea B pase a un estado ejecutable, y se colocar√° en la cola de ejecuci√≥n del procesador actual. Luego, el procesador deducir√° la siguiente tarea de la cola de ejecuci√≥n, la ejecutar√° y repetir√° este ciclo hasta que alcance la tarea B.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es que puede haber un retraso significativo entre enviar un mensaje y completar la tarea B. </font><font style="vertical-align: inherit;">Adem√°s, los datos activos, como un mensaje, se almacenan en la memoria cach√© de la CPU, pero para cuando se complete la tarea, es probable que se borren las memorias cach√© correspondientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver este problema, el nuevo planificador de Tokio implementa la optimizaci√≥n (como en los planificadores Go y Kotlin). </font><font style="vertical-align: inherit;">Cuando una tarea entra en un estado ejecutable, no se coloca al final de la cola, sino que se almacena en un espacio especial de "siguiente tarea". </font><font style="vertical-align: inherit;">El procesador siempre verifica esta ranura antes de verificar la cola. </font><font style="vertical-align: inherit;">Si ya hay una tarea anterior al insertar en la ranura, se elimina de la ranura y se mueve al final de la cola. </font><font style="vertical-align: inherit;">Por lo tanto, la tarea de transmitir un mensaje se realizar√° pr√°cticamente sin demora.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/12f/e12/a32/12fe12a324d1855a6c62cacd56cb4f70.png"><br><br><a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Captura del acelerador </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un planificador de captura de trabajos, si la cola de ejecuci√≥n del procesador est√° vac√≠a, el procesador intenta capturar tareas de las CPU pares. Primero, se selecciona una CPU par aleatoria, si no se encuentran tareas para ella, se busca la siguiente, y as√≠ sucesivamente, hasta que se encuentren las tareas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la pr√°ctica, varios procesadores a menudo terminan de procesar la cola de ejecuci√≥n aproximadamente al mismo tiempo. Esto sucede cuando llega un paquete de trabajo (por ejemplo, cuando</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sondeado para la disponibilidad del z√≥calo). Los procesadores se despiertan, reciben tareas, las inician y las completan. Esto lleva al hecho de que todos los procesadores est√°n tratando simult√°neamente de capturar las tareas de otras personas, es decir, muchos hilos est√°n tratando de acceder a las mismas colas. Hay un conflicto Una elecci√≥n aleatoria del punto de partida ayuda a reducir la competencia, pero la situaci√≥n a√∫n no es muy buena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para solucionar este problema, el nuevo planificador limita el n√∫mero de procesadores paralelos que realizan operaciones de captura. Llamamos al estado del procesador en el que est√° tratando de capturar las tareas de otras personas "b√∫squeda de empleo" o "b√∫squeda" para abreviar (m√°s sobre eso m√°s adelante). Dicha optimizaci√≥n se realiza utilizando el valor at√≥mico.</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que el procesador aumenta antes de comenzar la b√∫squeda y disminuye al salir del estado de b√∫squeda. </font><font style="vertical-align: inherit;">Tanto como sea posible en un estado de b√∫squeda puede ser la mitad del n√∫mero total de procesadores. </font><font style="vertical-align: inherit;">Es decir, se establece el l√≠mite aproximado, y esto es normal. </font><font style="vertical-align: inherit;">No necesitamos un l√≠mite estricto en la cantidad de CPU en la b√∫squeda, solo aceleraci√≥n. </font><font style="vertical-align: inherit;">Sacrificamos la precisi√≥n en aras de la eficiencia del algoritmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de ingresar al estado de b√∫squeda, el procesador intenta capturar el trabajo de las CPU pares y verifica la cola global.</font></font><br><br><a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disminuya la sincronizaci√≥n entre hilos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra parte importante del planificador es notificar a las CPU pares de nuevas tareas. Si el "hermano" est√° dormido, se despierta y captura tareas. Las notificaciones juegan otro papel importante. Recuerde que el algoritmo de la cola utiliza un orden at√≥mico d√©bil ( </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Debido a la asignaci√≥n at√≥mica de la memoria, no hay garant√≠a de que un procesador hom√≥logo vea tareas en la cola sin sincronizaci√≥n adicional. Por lo tanto, las notificaciones tambi√©n son responsables de ello. Por esta raz√≥n, las notificaciones se vuelven caras. El objetivo es minimizar su n√∫mero para no utilizar los recursos de la CPU, es decir, el procesador tiene tareas y el hermano no puede robarlas. Un n√∫mero excesivo de notificaciones conduce a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un problema de reba√±o de truenos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El planificador original de Tokio adopt√≥ un enfoque ingenuo para las notificaciones. Cada vez que se colocaba una nueva tarea en la cola de ejecuci√≥n, el procesador recib√≠a una notificaci√≥n. Cada vez que se notific√≥ a la CPU y vio la tarea despu√©s de despertarse, notific√≥ a otra CPU. Esta l√≥gica condujo muy r√°pidamente a que todos los procesadores se despertaran y buscaran trabajo (causando un conflicto). A menudo, la mayor√≠a de los procesadores no encontraron trabajo y se quedaron dormidos nuevamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo planificador mejor√≥ enormemente este patr√≥n, similar al planificador Go. Las notificaciones se env√≠an como antes, pero solo si no hay CPU en el estado de b√∫squeda (consulte la secci√≥n anterior). Cuando el procesador recibe una notificaci√≥n, ingresa inmediatamente al estado de b√∫squeda. Cuando el procesador en el estado de b√∫squeda encuentra nuevas tareas, primero abandona el estado de b√∫squeda y luego notifica al otro procesador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta l√≥gica limita la velocidad a la que los procesadores se activan. Si un paquete de tareas completo se planifica de inmediato (por ejemplo, cuando</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sondeado para la disponibilidad del z√≥calo), entonces la primera tarea dar√° como resultado una notificaci√≥n al procesador. </font><font style="vertical-align: inherit;">Ahora est√° en un estado de b√∫squeda. </font><font style="vertical-align: inherit;">Las tareas programadas restantes en el paquete no notificar√°n al procesador, ya que hay al menos una CPU en el estado de b√∫squeda. </font><font style="vertical-align: inherit;">Este procesador notificado capturar√° la mitad de las tareas en el lote y, a su vez, notificar√° al otro procesador. </font><font style="vertical-align: inherit;">Un tercer procesador se activa, encuentra las tareas de uno de los dos primeros procesadores y captura la mitad de ellos. </font><font style="vertical-align: inherit;">Esto conduce a un aumento suave en el n√∫mero de CPU en funcionamiento, as√≠ como a un r√°pido equilibrio de carga.</font></font><br><br><a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce la asignaci√≥n de memoria </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo planificador de Tokio requiere solo una asignaci√≥n de memoria para cada tarea generada, mientras que el anterior requer√≠a dos. </font><font style="vertical-align: inherit;">Anteriormente, la estructura de tareas se parec√≠a a esto:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// All state needed to manage the task state: TaskState, /// The logic to run is represented as a future trait object. future: Box&lt;dyn Future&lt;Output = ()&gt;&gt;, }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La estructura </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n se resaltar√° en </font></font><code>Box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Durante mucho tiempo quise arreglar esta articulaci√≥n (lo intent√© por primera vez en 2014). Dos cosas han cambiado desde el viejo planificador de Tokio. Primero, estabilizado </font></font><code>std::alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En segundo lugar, el futuro sistema de tareas ha cambiado a una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrategia vtable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expl√≠cita </font><font style="vertical-align: inherit;">. Eran estas dos cosas las que faltaban, finalmente, para deshacerse de la ineficiente asignaci√≥n de doble memoria para cada tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la estructura </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se presenta de la siguiente forma:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span>&lt;T&gt; { header: Header, future: T, trailer: Trailer, }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para las tareas necesarias y </font></font><code>Header</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Trailer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero que se dividen entre los datos "calientes" (cabeza) y "fr√≠o" (cola), m. E. Aproximadamente entre datos de acceso frecuente y los que se utilizan en raras ocasiones. </font><font style="vertical-align: inherit;">Los datos "activos" se colocan en la cabecera de la estructura y se almacenan lo menos posible. </font><font style="vertical-align: inherit;">Cuando el procesador desreferencia el puntero de la tarea, carga inmediatamente la l√≠nea de cach√© (de 64 a 128 bytes). </font><font style="vertical-align: inherit;">Queremos que estos datos sean lo m√°s relevantes posible.</font></font><br><br><a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conteo de enlaces at√≥micos reducido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima optimizaci√≥n que discutimos en este art√≠culo es reducir el n√∫mero de enlaces at√≥micos. Hay muchas referencias a la estructura de la tarea, incluso desde el planificador y desde cada waker. La estrategia general para administrar esta memoria es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el conteo de enlaces at√≥micos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta estrategia requiere una operaci√≥n at√≥mica cada vez que se clona un enlace y cada vez que se elimina un enlace. Cuando el √∫ltimo enlace queda fuera de alcance, la memoria se libera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el antiguo planificador de Tokio, tanto el planificador como todos los wakers conten√≠an un enlace a un descriptor de tareas, aproximadamente:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waker</span></span></span></span> { task: Arc&lt;Task&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la tarea se activa, el enlace se clona (se produce un incremento at√≥mico). </font><font style="vertical-align: inherit;">Luego, el enlace se coloca en la cola de ejecuci√≥n. </font><font style="vertical-align: inherit;">Cuando el procesador recibe la tarea y completa su ejecuci√≥n, descarta el enlace, lo que conduce a la reducci√≥n at√≥mica. </font><font style="vertical-align: inherit;">Estas operaciones at√≥micas (incremento y disminuci√≥n) se suman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este problema fue identificado previamente por los desarrolladores del sistema de tareas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se dieron cuenta de que al llamar, el </font></font><code>Waker::wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace original a </font></font><code>waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menudo ya no es necesario. </font><font style="vertical-align: inherit;">Esto le permite reutilizar el contador de enlace at√≥mico al mover una tarea a la cola de ejecuci√≥n. </font><font style="vertical-align: inherit;">El sistema de tareas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora incluye dos llamadas API para "despertar":</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>wake</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que acepta </font></font><code>self</code> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>wake_by_ref</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que acepta </font></font><code>&amp;self</code> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal construcci√≥n de API nos hace usarlo cuando llamamos </font></font><code>wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, evitando el incremento at√≥mico. </font><font style="vertical-align: inherit;">La implementaci√≥n se convierte as√≠:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { task.scheduler.schedule(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_by_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto evita la sobrecarga de recuentos de enlaces adicionales </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si puede asumir la responsabilidad de despertarse. En mi experiencia, en cambio, casi siempre es recomendable despertarse </font></font><code>&amp;self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El despertar </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evita la reutilizaci√≥n de waker (√∫til en casos en los que el recurso env√≠a muchos valores, es decir, canales, enchufes, ...). Adem√°s, en el caso es </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s dif√≠cil implementar un despertador seguro para subprocesos (dejaremos los detalles para otro art√≠culo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo planificador resuelve el problema de "despertar </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" evitando el incremento at√≥mico </font></font><code>wake_by_ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que lo hace tan efectivo como</font></font><code>wake(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para hacer esto, el planificador mantiene una lista de todas las tareas que est√°n actualmente activas (a√∫n no completadas). </font><font style="vertical-align: inherit;">La lista representa el contador de referencia necesario para enviar la tarea a la cola de ejecuci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La complejidad de esta optimizaci√≥n radica en el hecho de que el planificador no eliminar√° tareas de su lista hasta que reciba una garant√≠a de que la tarea se colocar√° nuevamente en la cola de ejecuci√≥n. </font><font style="vertical-align: inherit;">Los detalles de la implementaci√≥n de este esquema est√°n m√°s all√° del alcance de este art√≠culo, pero le recomiendo que consulte la fuente.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concurrencia (insegura) audaz con Loom </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es muy dif√≠cil escribir el c√≥digo paralelo correcto sin bloqueos. Es mejor trabajar lentamente, pero correctamente, que r√°pidamente, pero con fallas, especialmente si los errores est√°n relacionados con la seguridad de la memoria. La mejor opci√≥n, sin embargo, deber√≠a funcionar r√°pidamente y sin errores. El nuevo planificador realiz√≥ algunas optimizaciones bastante agresivas y evita la mayor√≠a de los tipos </font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por especializaci√≥n. En general, hay bastante c√≥digo inseguro en √©l </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay varias formas de probar el c√≥digo paralelo. Una de ellas es que los usuarios prueben y depuren en lugar de usted (una opci√≥n atractiva, eso es seguro). Otra es escribir pruebas unitarias que se ejecutan en un bucle y pueden detectar un error. Tal vez incluso use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSAN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por supuesto, si encuentra un error, no puede reproducirse f√°cilmente sin reiniciar el ciclo de prueba. Adem√°s, ¬øcu√°nto dura este ciclo? Diez segundos? Diez minutos? Diez dias? Anteriormente, ten√≠a que probar el c√≥digo paralelo en Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontramos esta situaci√≥n inaceptable. Cuando lanzamos el c√≥digo, queremos sentirnos seguros (tanto como sea posible), especialmente en el caso de c√≥digo paralelo sin bloqueos. Los usuarios de Tokio necesitan confiabilidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, desarrollamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una herramienta para la prueba de permutaci√≥n de c√≥digo paralelo. Las pruebas se escriben como de costumbre, pero</font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los ejecutar√° muchas veces, reorganizando todas las opciones posibles de ejecuci√≥n y comportamiento que la prueba puede encontrar en un entorno de transmisi√≥n. Tambi√©n verifica el acceso correcto a la memoria, la liberaci√≥n de memoria, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ejemplo, aqu√≠ est√° la prueba de telar para el nuevo planificador:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multi_spawn</span></span></span></span>() { loom::model(|| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pool = ThreadPool::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c1 = Arc::new(AtomicUsize::new(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (tx, rx) = oneshot::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx1 = Arc::new(Mutex::new(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(tx))); <span class="hljs-comment"><span class="hljs-comment">// Spawn a task let c2 = c1.clone(); let tx2 = tx1.clone(); pool.spawn(async move { spawn(async move { if 1 == c1.fetch_add(1, Relaxed) { tx1.lock().unwrap().take().unwrap().send(()); } }); }); // Spawn a second task pool.spawn(async move { spawn(async move { if 1 == c2.fetch_add(1, Relaxed) { tx2.lock().unwrap().take().unwrap().send(()); } }); }); rx.recv(); }); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece bastante normal, pero un fragmento de c√≥digo en un bloque se </font></font><code>loom::model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecuta miles de veces (posiblemente millones), cada vez con un ligero cambio en el comportamiento. Cada ejecuci√≥n cambia el orden exacto de los hilos. Adem√°s, para cada operaci√≥n at√≥mica, loom prueba todos los diferentes comportamientos permitidos en el modelo de memoria C ++ 11. Recuerde que la carga at√≥mica con </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">era bastante d√©bil y pod√≠a devolver valores obsoletos. La prueba </font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">probar√° todos los valores posibles que se pueden cargar. </font></font><br><br> <code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se convirti√≥ en una herramienta invaluable para desarrollar un nuevo planificador. Capt√≥ m√°s de diez errores que pasaron todas las pruebas unitarias, pruebas manuales y pruebas de carga.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un lector exigente puede dudar de que el telar verifique "todas las permutaciones posibles", y tendr√° raz√≥n. Las permutaciones ingenuas conducir√°n a una explosi√≥n combinatoria. Cualquier prueba no trivial nunca terminar√°. Este problema se ha estudiado durante muchos a√±os y se han desarrollado varios algoritmos para evitar una explosi√≥n combinatoria. Loom b√°sica algoritmo basado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la reducci√≥n din√°mica con ordenaci√≥n parcial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (reducci√≥n de orden parcial din√°mica). Este algoritmo elimina las permutaciones que conducen al mismo resultado. Pero el espacio de estado todav√≠a puede crecer hasta tal tama√±o que no se procesar√° en un per√≠odo de tiempo razonable (varios minutos). Loom le permite limitarlo a√∫n m√°s mediante la reducci√≥n din√°mica con pedidos parciales.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, gracias a las extensas pruebas con Loom, ahora tengo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucha</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s confianza en la correcci√≥n del programador.</font></font><br><br><h1>  Resultados </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, analizamos qu√© son los planificadores y c√≥mo el nuevo planificador de Tokio logr√≥ un gran aumento de rendimiento ... pero ¬øqu√© tipo de crecimiento? </font><font style="vertical-align: inherit;">Dado que el nuevo planificador solo se ha desarrollado, en el mundo real a√∫n no se ha probado por completo. </font><font style="vertical-align: inherit;">Aqu√≠ est√° lo que sabemos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, el nuevo planificador es mucho m√°s r√°pido en micro benchmarks:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viejo planificador </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> test chained_spawn ... banco: 2,019,796 ns / iter (+/- 302,168)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prueba ping_pong ... banco: 1,279,948 ns / iter (+/- 154,365)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prueba spawn_many ... banco: 10,283,608 ns / iter (+/- 1,284,275)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test yield_many ... bench: 21,450,748 ns / iter (+/- 1,201,337) </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuevo planificador </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> test chained_spawn ... banco: 168,854 ns / iter (+/- 8,339)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prueba ping_pong ... banco: 562,659 ns / iter (+/- 34,410)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prueba spawn_many ... banco: 7,320,737 ns / iter (+/- 264,620)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prueba de rendimiento_mucho ... banco: 14,638,563 ns / iter (+/- 1,573,678) </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este punto de referencia incluye lo siguiente: </font></font><br><br><ul><li> <code>chained_spawn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> genera nuevas tareas de forma recursiva, es decir, genera una tarea que genera otra tarea, que tambi√©n genera una tarea, etc. </font></font><br></li><li> <code>ping_pong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selecciona un canal </font></font><code>oneshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y genera una tarea que env√≠a un mensaje en ese canal. </font><font style="vertical-align: inherit;">La tarea original est√° esperando un mensaje. </font><font style="vertical-align: inherit;">Esta es la prueba m√°s cercana al "mundo real".</font></font><br></li><li> <code>spawn_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comprueba la implementaci√≥n de tareas en el planificador, es decir, genera tareas desde fuera de su contexto. </font></font><br></li><li> <code>yield_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comprueba el despertar de tareas independientes. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La diferencia en los puntos de referencia es muy impresionante. </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo se reflejar√° esto en el "mundo real"? </font><font style="vertical-align: inherit;">Es dif√≠cil decirlo con certeza, pero intent√© ejecutar los puntos de referencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√° el servidor Hyper m√°s simple, cuyo rendimiento se mide con </font></font><code>wrk -t1 -c50 -d10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viejo planificador </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecutando 10s test @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 hilos y 50 conexiones</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Thread Stats Avg Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Latencia 371.53us 99.05us 1.97ms 60.53%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 114.61k 8.45k 133.85k 67.00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1139307 solicitudes en 10.00s, lectura de 95.61MB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solicitudes / seg: 113923.19</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transferencia / seg: 9.56MB </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuevo planificador </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecutando 10s test @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 hilos y 50 conexiones</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Thread Stats Avg Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Latencia 275.05us 69.81us 1.09ms 73.57%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 153.17k 10.68k 171.51k 71.00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1522671 solicitudes en 10.00s, 127.79MB de lectura</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solicitudes / seg: 152258.70</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transferencia / seg: 12.78MB </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Vemos un aumento del 34% en las solicitudes por segundo justo despu√©s del cambio de planificador! La primera vez que vi esto, me sent√≠ muy feliz, porque esperaba un aumento de un m√°ximo del 5-10%. Pero luego me sent√≠ triste, porque este resultado tambi√©n mostr√≥ que el viejo programador de Tokio no es tan bueno. Entonces record√© que Hyper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es l√≠der en calificaciones de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">TechEmpower</font></a><font style="vertical-align: inherit;"> . Es interesante ver c√≥mo el nuevo planificador afectar√° las calificaciones. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el cliente y servidor gRPC, con el nuevo planificador acelerado en aproximadamente un 10%, lo cual es bastante impresionante teniendo en cuenta que Tonic a√∫n no est√° completamente optimizado.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estoy realmente muy feliz de finalmente completar este proyecto despu√©s de varios meses de trabajo. </font><font style="vertical-align: inherit;">Esta es una mejora importante para la E / S as√≠ncrona de Rust. </font><font style="vertical-align: inherit;">Estoy muy satisfecho con las mejoras realizadas. </font><font style="vertical-align: inherit;">Todav√≠a hay mucho espacio para la optimizaci√≥n en el c√≥digo de Tokio, por lo que a√∫n no hemos terminado con la mejora del rendimiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que el material del art√≠culo sea √∫til para los colegas que intentan escribir su programador de tareas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472242/">https://habr.com/ru/post/472242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472228/index.html">9 trucos para trabajar con c√≥digo de Visual Studio</a></li>
<li><a href="../472230/index.html">Chips for ML - habla sobre nuevos productos</a></li>
<li><a href="../472232/index.html">Desde "Color Extender para ZX-Spectrum" hasta ZX-Poly</a></li>
<li><a href="../472234/index.html">Criptomoneda: ¬øsigue siendo un cargador gratuito o un socio?</a></li>
<li><a href="../472240/index.html">Sobre la gamificaci√≥n. ¬øQu√© es, por qu√© y c√≥mo hacerlo? Look de desarrollador</a></li>
<li><a href="../472246/index.html">React + IndexDb + auto-update = casi AsyncRedux</a></li>
<li><a href="../472248/index.html">C√≥mo fusionamos la programaci√≥n IT-Planet final</a></li>
<li><a href="../472252/index.html">Eventos digitales en Mosc√∫ del 21 al 28 de octubre.</a></li>
<li><a href="../472254/index.html">Eventos digitales en San Petersburgo del 21 al 28 de octubre.</a></li>
<li><a href="../472258/index.html">C√≥mo "aprender a aprender" - mejorar la atenci√≥n plena</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>