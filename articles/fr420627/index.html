<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèä üî≤ üõ∞Ô∏è Programmation asynchrone C #: Comment faites-vous avec les performances? üíâ ‚ôìÔ∏è üåÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Plus r√©cemment, nous avons d√©j√† parl√© de la n√©cessit√© de remplacer Equals et GetHashCode lors de la programmation en C #. Aujourd'hui, nous allons tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation asynchrone C #: Comment faites-vous avec les performances?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/">  Plus r√©cemment, nous avons d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parl√©</a> de la n√©cessit√© de remplacer Equals et GetHashCode lors de la programmation en C #.  Aujourd'hui, nous allons traiter des param√®tres de performance des m√©thodes asynchrones.  Rejoignez-nous maintenant! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  Dans les deux derniers articles du blog msdn, nous avons examin√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure interne des m√©thodes asynchrones en C #</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les points d'extension</a> que le compilateur C # fournit pour contr√¥ler le comportement des m√©thodes asynchrones. <br><br>  Sur la base des informations du premier article, le compilateur effectue de nombreuses transformations pour rendre la programmation asynchrone aussi similaire √† synchrone que possible.  Pour ce faire, il cr√©e une instance de la machine d'√©tat, la transmet au g√©n√©rateur de la m√©thode asynchrone, qui appelle l'objet attendant pour la t√¢che, etc. Bien s√ªr, une telle logique a un prix, mais combien cela nous co√ªte-t-il? <br><br>  Jusqu'√† l'apparition de la biblioth√®que TPL, les op√©rations asynchrones n'√©taient pas utilis√©es en si grande quantit√©, par cons√©quent, les co√ªts n'√©taient pas √©lev√©s.  Mais aujourd'hui, m√™me une application relativement simple peut effectuer des centaines, voire des milliers, d'op√©rations asynchrones par seconde.  La biblioth√®que de t√¢ches parall√®les TPL a √©t√© cr√©√©e avec une telle charge de travail √† l'esprit, mais il n'y a pas de magie ici et vous devez payer pour tout. <br><br>  Pour estimer les co√ªts des m√©thodes asynchrones, nous utiliserons un exemple l√©g√®rement modifi√© du premier article. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  La classe <code>StockPrices</code> en <code>StockPrices</code> les cours des actions √† partir d'une source externe et vous permet de les demander via l'API.  La principale diff√©rence avec l'exemple du premier article est le passage d'un dictionnaire √† une liste de prix.  Afin d'estimer les co√ªts des diff√©rentes m√©thodes asynchrones par rapport aux m√©thodes synchrones, l'op√©ration elle-m√™me doit faire un certain travail, dans notre cas, c'est une recherche lin√©aire des cours boursiers. <br><br>  La m√©thode <code>GetPricesFromCache</code> intentionnellement construite autour d'une boucle simple pour √©viter l'allocation de ressources. <br><br><h2>  Comparaison des m√©thodes synchrones et des m√©thodes asynchrones bas√©es sur les t√¢ches </h2><br>  Dans le premier test de performances, nous comparons la m√©thode asynchrone qui appelle la m√©thode d'initialisation asynchrone ( <code>GetStockPriceForAsync</code> ), la m√©thode synchrone qui appelle la m√©thode d'initialisation asynchrone ( <code>GetStockPriceFor</code> ) et la m√©thode synchrone qui appelle la m√©thode d'initialisation synchrone. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  Les r√©sultats sont pr√©sent√©s ci-dessous: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  D√©j√† √† ce stade, nous avons re√ßu des donn√©es assez int√©ressantes: <br><br><ul><li>  La m√©thode asynchrone est assez rapide.  <code>GetPricesForAsync</code> s'ex√©cute de mani√®re synchrone dans ce test et est environ 15% (*) plus lent que la m√©thode purement synchrone. </li><li>  La m√©thode <code>GetPricesFor</code> synchrone, qui appelle la m√©thode asynchrone <code>InitializeMapIfNeededAsync</code> , a des co√ªts encore plus bas, mais le plus surprenant, elle n'alloue pas de ressources du tout (dans la colonne allou√©e du tableau ci-dessus, elle co√ªte 0 pour <code>GetPricesDirectlyFromCache</code> et <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Bien s√ªr, on ne peut pas dire que les co√ªts d'ex√©cution synchrone de la m√©thode asynchrone sont de 15% pour tous les cas possibles.</i>  <i>Cette valeur d√©pend directement de la charge de travail effectu√©e par la m√©thode.</i>  <i>La diff√©rence entre les frais g√©n√©raux d'une invocation pure d'une m√©thode asynchrone (qui ne fait rien) et d'une m√©thode synchrone (qui ne fait rien) sera √©norme.</i>  <i>L'id√©e de ce test comparatif est de montrer que les co√ªts de la m√©thode asynchrone, qui effectue un travail relativement faible, sont relativement faibles.</i> <br><br>  Comment se fait-il que lorsque vous appelez <code>InitializeMapIfNeededAsync</code> , les ressources ne soient pas allou√©es du tout?  Dans le premier article de cette s√©rie, j'ai mentionn√© qu'une m√©thode asynchrone devait allouer au moins un objet dans l'en-t√™te g√©r√© - l'instance de t√¢che elle-m√™me.  Discutons ce point plus en d√©tail. <br><br><h2>  Optimisation n ¬∞ 1: mise en cache des instances de t√¢che lorsque cela est possible </h2><br>  La r√©ponse √† la question ci-dessus est tr√®s simple: <code>AsyncMethodBuilder</code> <b>utilise une instance de la t√¢che pour chaque op√©ration asynchrone termin√©e avec succ√®s</b> .  La m√©thode asynchrone <code>AsyncMethodBuilder</code> par <code>Task</code> utilise <code>AsyncMethodBuilder</code> avec la logique suivante dans la m√©thode <code>SetResult</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  La m√©thode <code>SetResult</code> appel√©e uniquement pour les m√©thodes asynchrones termin√©es avec succ√®s et un <b>r√©sultat r√©ussi pour chaque m√©thode bas√©e sur les <code>Task</code> peut √™tre librement utilis√© ensemble</b> .  Nous pouvons m√™me retracer ce comportement avec le test suivant: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  Mais ce n'est pas la seule optimisation possible.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> optimise le travail d'une mani√®re similaire: il met en cache les t√¢ches pour <code>Task&lt;bool&gt;</code> et certains autres types simples.  Par exemple, il met en cache toutes les valeurs par d√©faut pour un groupe de types entiers et utilise un cache sp√©cial pour la <code>Task&lt;int&gt;</code> , en pla√ßant des valeurs de la plage [-1;  9] (pour plus de d√©tails, voir <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  Ceci est confirm√© par le test suivant: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>Ne vous fiez pas trop √† un tel comportement</b> , mais il est toujours agr√©able de se rendre compte que les cr√©ateurs du langage et de la plateforme font tout leur possible pour augmenter la productivit√© de toutes les mani√®res disponibles.  La mise en cache des t√¢ches est une m√©thode d'optimisation populaire qui est √©galement utilis√©e dans d'autres domaines.  Par exemple, une nouvelle impl√©mentation de <code>Socket</code> dans le r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">corefx repo utilise</a> largement cette m√©thode et applique <a href="">les t√¢ches mises en cache dans la</a> mesure du possible. <br><br><h2>  Optimisation n ¬∞ 2: utilisation de <code>ValueTask</code> </h2><br>  La m√©thode d'optimisation d√©crite ci-dessus ne fonctionne que dans quelques cas.  Par cons√©quent, au lieu de cela, nous pouvons utiliser <code>ValueTask&lt;T&gt;</code> (**), un type sp√©cial de valeur similaire √† la t√¢che;  il n'allouera pas de ressources si la m√©thode s'ex√©cute de mani√®re synchrone. <br><br>  <code>ValueTask&lt;T&gt;</code> est une combinaison distincte de <code>T</code> et <code>Task&lt;T&gt;</code> : si la "valeur-t√¢che" est termin√©e, alors la valeur de base sera utilis√©e.  Si l'allocation de base n'a pas encore √©t√© √©puis√©e, des ressources seront allou√©es √† la t√¢che. <br><br>  Ce type sp√©cial permet d'√©viter un provisionnement de segment de m√©moire excessif lors de l'ex√©cution d'une op√©ration de mani√®re synchrone.  Pour utiliser <code>ValueTask&lt;T&gt;</code> , vous devez modifier le type de retour pour <code>GetStockPriceForAsync</code> : au lieu de <code>Task&lt;decimal&gt;</code> sp√©cifier <code>ValueTask&lt;decimal&gt;</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Nous pouvons maintenant √©valuer la diff√©rence √† l'aide d'un test comparatif suppl√©mentaire: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  Comme vous pouvez le voir, la version avec <code>ValueTask</code> n'est que l√©g√®rement plus rapide que la version avec Task.  La principale diff√©rence est que l'allocation de segments de m√©moire est emp√™ch√©e.  Dans une minute, nous discuterons de la faisabilit√© d'une telle transition, mais avant cela, je voudrais parler d'une optimisation d√©licate. <br><br><h2>  Optimisation n ¬∞ 3: abandonner les m√©thodes asynchrones dans un chemin commun </h2><br>  Si vous utilisez tr√®s souvent une m√©thode asynchrone et souhaitez r√©duire les co√ªts encore plus, je vous sugg√®re l'optimisation suivante: supprimez le modificateur async, puis v√©rifiez l'√©tat de la t√¢che √† l'int√©rieur de la m√©thode et effectuez l'op√©ration enti√®re de mani√®re synchrone, abandonnant compl√®tement les approches asynchrones. <br><br>  √áa a l'air compliqu√©?  Prenons un exemple. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  Dans ce cas, le modificateur <code>async</code> n'est pas utilis√© dans la m√©thode <code>GetStockPriceWithValueTaskAsync_Optimized</code> , donc lorsqu'il re√ßoit une t√¢che de la m√©thode <code>InitializeMapIfNeededAsync</code> , il v√©rifie son √©tat d'ex√©cution.  Si la t√¢che est termin√©e, la m√©thode utilise simplement <code>DoGetPriceFromCache</code> pour obtenir imm√©diatement le r√©sultat.  Si la t√¢che d'initialisation est toujours en cours, la m√©thode appelle une fonction locale et attend les r√©sultats. <br><br>  L'utilisation d'une fonction locale n'est pas la seule, mais l'un des moyens les plus simples.  Mais il y a une mise en garde.  Lors de l'impl√©mentation la plus naturelle, la fonction locale recevra un √©tat externe (variable locale et argument): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  Mais, malheureusement, en raison d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une erreur de compilation,</a> ce code g√©n√©rera une fermeture, m√™me si la m√©thode est ex√©cut√©e dans le chemin commun.  Voici √† quoi ressemble cette m√©thode de l'int√©rieur: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  Comme indiqu√© dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dissection des fonctions locales en C #</a> , le compilateur utilise une instance commune de fermeture pour toutes les variables et arguments locaux dans une zone sp√©cifique.  Par cons√©quent, il y a un certain sens dans une telle g√©n√©ration de code, mais cela rend toute la lutte avec l'allocation de tas inutile. <br><br>  <b>CONSEIL</b> .  Une telle optimisation est une chose tr√®s insidieuse.  Les avantages sont n√©gligeables et m√™me si vous √©crivez la fonction locale d'origine <b>correcte</b> , vous pouvez accidentellement obtenir un √©tat externe qui provoque l'allocation du tas.  Vous pouvez toujours recourir √† l'optimisation si vous travaillez avec une biblioth√®que couramment utilis√©e (par exemple, BCL) dans une m√©thode qui sera certainement utilis√©e sur une section de code charg√©e. <br><br><h4>  Co√ªts associ√©s √† l'attente d'une t√¢che </h4><br>  Pour le moment, nous n'avons consid√©r√© qu'un seul cas sp√©cifique: la surcharge d'une m√©thode asynchrone qui s'ex√©cute de mani√®re synchrone.  Cela se fait expr√®s.  Plus la m√©thode asynchrone est petite, plus les co√ªts de ses performances globales sont visibles.  En r√®gle g√©n√©rale, les m√©thodes asynchrones plus d√©taill√©es s'ex√©cutent de mani√®re synchrone et effectuent une charge de travail plus petite.  Et nous les appelons g√©n√©ralement plus souvent. <br><br>  Mais il faut √™tre conscient des co√ªts du m√©canisme asynchrone lorsque la m√©thode ¬´attend¬ª l'ach√®vement d'une t√¢che en suspens.  Pour estimer ces co√ªts, nous apporterons des modifications √† <code>InitializeMapIfNeededAsync</code> et appellerons <code>Task.Yield()</code> m√™me lorsque le cache est initialis√©: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Nous ajoutons les m√©thodes suivantes √† notre package de r√©f√©rence pour les tests comparatifs: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  Comme vous pouvez le voir, la diff√©rence est palpable - √† la fois en termes de vitesse et en termes d'utilisation de la m√©moire.  Expliquez bri√®vement les r√©sultats. <br><br><ul><li>  Chaque op√©ration d'attente pour une t√¢che inachev√©e prend environ 4 microsecondes et alloue pr√®s de 300 octets (**) pour chaque appel.  C'est pourquoi GetStockPriceFor s'ex√©cute presque deux fois plus vite que GetStockPriceForAsync et alloue moins de m√©moire. </li><li>  Une m√©thode asynchrone bas√©e sur ValueTask prend un peu plus de temps que la variante avec Task, lorsque cette m√©thode n'est pas ex√©cut√©e de mani√®re synchrone.  Une machine d'√©tat d'une m√©thode bas√©e sur ValueTask &lt;T&gt; doit stocker plus de donn√©es qu'une machine d'√©tat d'une m√©thode bas√©e sur Task &lt;T&gt;. </li></ul><br>  <i>(**) Cela d√©pend de la plateforme (x64 ou x86) et d'un certain nombre de variables et d'arguments locaux de la m√©thode asynchrone.</i> <br><br><h4>  Performances de la m√©thode asynchrone 101 </h4><br><ul><li>  Si la m√©thode asynchrone s'ex√©cute de mani√®re synchrone, la surcharge est assez petite. </li><li>  Si la m√©thode asynchrone est ex√©cut√©e de mani√®re synchrone, la surcharge de m√©moire suivante se produit: pour les m√©thodes de t√¢che asynchrone, il n'y a pas de surcharge et pour les m√©thodes de t√¢che async &lt;T&gt;, le d√©passement est de 88 octets par op√©ration (pour les plates-formes x64). </li><li>  ValueTask &lt;T&gt; √©limine la surcharge susmentionn√©e pour les m√©thodes asynchrones ex√©cut√©es de mani√®re synchrone. </li><li>  Lorsqu'une m√©thode asynchrone bas√©e sur ValueTask &lt;T&gt; est ex√©cut√©e de mani√®re synchrone, cela prend un peu moins de temps que la m√©thode avec Task &lt;T&gt;, sinon il y a de l√©g√®res diff√©rences en faveur de la deuxi√®me option. </li><li>  La surcharge de performances pour les m√©thodes asynchrones en attente de terminer une t√¢che inachev√©e est nettement plus √©lev√©e (environ 300 octets par op√©ration pour les plates-formes x64). </li></ul><br>  Bien s√ªr, les mesures sont notre tout.  Si vous voyez qu'une op√©ration asynchrone cause des probl√®mes de performances, vous pouvez basculer de la <code>Task&lt;T&gt;</code> vers <code>ValueTask&lt;T&gt;</code> , mettre en cache la t√¢che ou rendre le chemin d'ex√©cution global synchrone, si possible.  Vous pouvez √©galement essayer d'agr√©ger vos op√©rations asynchrones.  Cela permettra d'am√©liorer les performances, de simplifier le d√©bogage et l'analyse de code en g√©n√©ral.  <b>Tous les petits morceaux de code ne doivent pas √™tre asynchrones.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420627/">https://habr.com/ru/post/fr420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420615/index.html">JavaScript: explorer des objets</a></li>
<li><a href="../fr420617/index.html">Guide de conception Web pour les d√©veloppeurs</a></li>
<li><a href="../fr420619/index.html">Images r√©actives: astuces CSS qui font gagner du temps</a></li>
<li><a href="../fr420623/index.html">Applications C ++ distribu√©es avec un minimum d'effort</a></li>
<li><a href="../fr420625/index.html">KDD 2018, Day One, tutoriels</a></li>
<li><a href="../fr420629/index.html">PHP Digest n ¬∞ 137 (6-20 ao√ªt 2018)</a></li>
<li><a href="../fr420631/index.html">Nous n'avons pas peur des "nuages"</a></li>
<li><a href="../fr420633/index.html">√âcrire un exportateur GeoIP pour Prometheus avec des visualisations dans Grafana en 15 minutes</a></li>
<li><a href="../fr420635/index.html">AI, cours pratique. Le mod√®le de base pour reconna√Ætre les √©motions dans les images</a></li>
<li><a href="../fr420637/index.html">Test de l'imprimante 3D WANHAO D9 / 300: Vid√©o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>