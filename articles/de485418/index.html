<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó°Ô∏è ‚è±Ô∏è üë≠ PHPUnit. "Wie teste ich meinen verdammten Controller?" üßëüèæ‚Äçü§ù‚Äçüßëüèª ü•ñ üî±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 



 Ja, dies ist ein weiterer Beitrag zum Thema Testen. Es scheint, dass es hier bereits m√∂glich ist, zu diskutieren? Alle, die es brauch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Wie teste ich meinen verdammten Controller?"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Hallo Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="Bild"><br><br>  Ja, dies ist ein weiterer Beitrag zum Thema Testen.  Es scheint, dass es hier bereits m√∂glich ist, zu diskutieren?  Alle, die es brauchen - sie schreiben Tests, die es nicht brauchen - sie schreiben nicht, alle sind gl√ºcklich!  Tatsache ist, dass die meisten Posts √ºber Unit-Tests ... wie man niemanden beleidigt ... idiotische Beispiele haben!  Nein, wirklich!  Heute werde ich versuchen, es zu beheben.  Ich bitte um katze <br><a name="habracut"></a><br>  Wenn Sie also schnell zum Thema Tests googeln, finden Sie nur viele Artikel, die in ihrer Masse in zwei Kategorien unterteilt sind: <br><br>  1) Das Gl√ºck eines Texters.  Zuerst sehen wir eine lange Einf√ºhrung, dann die Geschichte der Unit-Tests im alten Russland, dann zehn Life-Hacks mit Tests und am Ende ein Beispiel.  Mit Code wie folgt testen: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Und ich scherze gerade nicht.  Ich habe wirklich Artikel mit einem ‚ÄûTaschenrechner‚Äú als Studienf√ºhrer gesehen.  Ja, ja, ich verstehe, dass es zun√§chst einmal notwendig ist, alles, Abstraktionen, hin und her zu vereinfachen ... Aber hier endet alles!  Und dann mach die Eule fertig, wie sie sagen <br><br>  2) √úberaus ausgefeilte Beispiele.  Schreiben wir einen Test und packen ihn in Gitlab CI. Wenn der Test erfolgreich ist, werden wir ihn automatisch reparieren und PHP Infection auf die Tests anwenden, aber wir werden alles mit Hudson verbinden.  Und so weiter in diesem Stil.  Es scheint n√ºtzlich zu sein, aber es scheint nicht das zu sein, wonach Sie suchen.  Sie m√∂chten die Stabilit√§t Ihres Projekts jedoch nur geringf√ºgig erh√∂hen.  Und all diese Kontinuit√§ten - na ja, nicht alle auf einmal. <br><br>  Infolgedessen bezweifeln die Leute: "Aber brauche ich das?"  Ich m√∂chte versuchen, das Testen klarer zu erkl√§ren.  Und reservieren Sie gleich - ich bin ein Entwickler, ich bin kein Tester.  Ich bin mir sicher, dass ich selbst nicht viel wei√ü und mein erstes Wort in meinem Leben war nicht das Wort "Mok".  Ich habe noch nie an TDD gearbeitet!  Aber ich wei√ü mit Sicherheit, dass ich mit meinem derzeitigen Kenntnisstand mehrere Projekte mit Tests abdecken konnte, und genau diese Tests haben bereits ein Dutzend Fehler aufgedeckt.  Und wenn es mir helfen w√ºrde, k√∂nnte es jemand anderem helfen.  Einige gefangene Bugs lassen sich nur schwer manuell fangen. <br><br>  Zun√§chst ein kurzes Bildungsprogramm im Frage-Antwort-Format: <br><br>  F: Muss ich ein Framework verwenden?  Was ist, wenn ich Yii habe?  Was ist, wenn Kohana?  Was ist, wenn% one_more_framework_name%? <br>  A: Nein, PHPUnit ist ein unabh√§ngiges Testframework. Sie k√∂nnen es sogar auf einem selbst erstellten Framework mit dem Legacy-Code verschrauben. <br><br>  F: Und jetzt gehe ich schnell mit meinen H√§nden durch die Website, und es ist normal.  Warum brauche ich das? <br>  A: Ein Durchlauf von mehreren Dutzend Tests dauert mehrere Sekunden.  Das automatische Testen ist immer schneller als das manuelle Testen, und mit hochwertigen Tests ist es auch zuverl√§ssiger, da es alle Szenarien abdeckt. <br><br>  F: Ich habe einen Legacy-Code mit 2000 Zeilenfunktionen.  Kann ich das testen? <br>  A: Ja und nein.  Theoretisch kann jeder Code mit einem Test abgedeckt werden.  In der Praxis sollte der Code mit einer Grundlage f√ºr zuk√ºnftige Tests geschrieben werden.  Eine 2000-Zeilen-Funktion weist zu viele Abh√§ngigkeiten, Verzweigungen und Grenzf√§lle auf.  Es mag sich am Ende herausstellen, dass es alles abdeckt, aber h√∂chstwahrscheinlich wird es eine unannehmbar lange Zeit dauern.  Je besser der Code, desto einfacher ist es, ihn zu testen.  Je besser die Einzelverantwortung respektiert wird, desto einfacher werden die Tests.  Um alte Projekte am h√§ufigsten zu testen, m√ºssen Sie sie zun√§chst k√ºhl umgestalten. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="Bild"><br><br>  F: Ich habe sehr einfache Methoden (Funktionen), was gibt es zu testen?  Dort ist alles zuverl√§ssig, es gibt keinen Raum f√ºr Fehler! <br>  A: Es sollte klar sein, dass Sie die korrekte Implementierung der Funktion nicht testen (wenn Sie kein TDD haben), sondern lediglich den aktuellen Status der Funktion "korrigieren".  Wenn Sie es in Zukunft √§ndern m√ºssen, k√∂nnen Sie mithilfe des Tests schnell feststellen, ob Sie das Verhalten gest√∂rt haben.  Beispiel: Es gibt eine Funktion, die E-Mails √ºberpr√ºft.  Sie macht es regelm√§√üig. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Ihr gesamter Code geht davon aus, dass eine g√ºltige E-Mail an diese Funktion den Wert true zur√ºckgibt.  Eine Reihe von g√ºltigen E-Mails ist auch wahr.  Ein Array mit mindestens einer ung√ºltigen E-Mail-Adresse ist falsch.  Nun und so weiter, der Code ist klar.  Aber der Tag kam und Sie entschieden sich, die monstr√∂se regul√§re Saison durch eine externe API zu ersetzen.  Aber wie kann man sicherstellen, dass die neu geschriebene Funktion das Funktionsprinzip nicht ver√§ndert hat?  Pl√∂tzlich kommt es nicht mehr gut mit dem Array klar?  Oder wird es nicht boolean zur√ºckkehren?  Und Tests k√∂nnen dies unter Kontrolle halten.  Ein gut geschriebener Test zeigt sofort ein anderes als das erwartete Funktionsverhalten an. <br><br>  F: Wann werde ich anfangen, Sinn aus Tests zu ziehen? <br>  A: Erstens, sobald Sie einen wesentlichen Teil des Codes abdecken.  Je n√§her die Abdeckung an 100% liegt, desto zuverl√§ssiger ist die Pr√ºfung.  Zweitens, sobald Sie globale √Ñnderungen oder √Ñnderungen im komplexen Teil des Codes vornehmen m√ºssen.  Tests k√∂nnen Probleme aufdecken, die leicht manuell √ºbersehen werden k√∂nnen (Grenzf√§lle).  Drittens beim Schreiben der Tests selbst!  Oft kommt es vor, dass das Schreiben eines Tests Codefehler aufzeigt, die auf den ersten Blick nicht sichtbar sind. <br><br>  F: Nun, ich habe eine Website auf Laravel.  Die Seite ist keine Funktion, die Seite ist ein beschissener Berg von Code.  Wie kann man hier testen? <br>  A: Dies wird sp√§ter besprochen.  Kurzum: Wir testen getrennt die Methoden der Controller, getrennt die Middleware, getrennt die Dienste usw. <br><br>  Eine der Ideen beim Unit-Testen ist es, den getesteten Codeabschnitt zu isolieren.  Je weniger Code Sie mit einem Test testen, desto besser.  Schauen wir uns ein Beispiel an, das dem wirklichen Leben so nahe wie m√∂glich kommt: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Dies ist eine sehr typische Methode, um sich bei kleinen Projekten im System anzumelden.  Wir erwarten nur die richtigen Fehlermeldungen und die versendete E-Mail bei erfolgreicher Anmeldung.  Wie teste ich diese Methode?  Zun√§chst m√ºssen Sie externe Abh√§ngigkeiten identifizieren.  In unserem Fall gibt es zwei davon - $ userService und $ emailService.  Sie werden durch den Klassenkonstruktor geleitet, was unsere Aufgabe erheblich erleichtert.  Aber wie bereits erw√§hnt, ist es umso besser, je weniger Code wir in einem Durchgang testen. <br><br>  Emulation, Substitution von Objekten hei√üt mokanem (aus dem Englischen. Mock object, w√∂rtlich: "Objekt-Parodie").  Niemand hat die M√ºhe, solche Objekte manuell zu schreiben, aber alles wurde bereits vor uns erfunden, so dass eine so wunderbare Bibliothek wie <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> zur Rettung kommt.  Lassen Sie uns Mokas f√ºr Services erstellen. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Erstellen Sie nun das $ request-Objekt.  Zun√§chst testen wir die Logik des √úberpr√ºfens der Anmelde- und Kennwortfelder.  Wir m√∂chten sicherstellen, dass unsere Methode diesen Fall korrekt verarbeitet und die gew√ºnschte (!) Nachricht zur√ºckgibt, wenn keine vorhanden ist. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Nichts kompliziertes, oder?  Wir haben Stubs f√ºr die erforderlichen Klassenparameter erstellt, eine Instanz der gew√ºnschten Klasse erstellt und die gew√ºnschte Methode "gezogen", wobei eine absichtlich falsche Anforderung √ºbergeben wurde.  Habe eine Antwort bekommen.  Aber wie kann man das jetzt √ºberpr√ºfen?  Dies ist der wichtigste Teil des Tests - die sogenannte Behauptung.  PHPUnit verf√ºgt √ºber Dutzende von vorgefertigten <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">Behauptungen</a> .  Verwenden Sie einfach einen von ihnen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Dieser Test garantiert Folgendes: Wenn das Login-Argument bei dem Methodenobjekt ankommt, das kein Login- oder Passwortfeld hat, gibt die Methode die Zeichenfolge "Auth error" zur√ºck.  Das ist im Allgemeinen alles.  So einfach - aber so n√ºtzlich, denn jetzt k√∂nnen wir die Anmeldemethode bearbeiten, ohne bef√ºrchten zu m√ºssen, etwas zu besch√§digen.  Unser Frontend kann sicher sein, dass er einen solchen Fehler bekommt, wenn etwas passiert.  Und wenn jemand gegen dieses Verhalten verst√∂√üt (z. B. den Fehlertext √§ndern m√∂chte), zeigt der Test dies sofort an!  Die verbleibenden Pr√ºfungen werden hinzugef√ºgt, um m√∂glichst viele Szenarien abzudecken. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Beachten Sie die Methoden shouldReceive und andReturn?  Sie erm√∂glichen uns, Methoden in Stubs zu erstellen, die nur das zur√ºckgeben, was wir ben√∂tigen.  M√ºssen Sie den falschen Passwortfehler testen?  Wir schreiben einen stub $ userService, der immer das falsche Passwort zur√ºckgibt.  Und alle. <br><br>  Und was ist mit Abh√§ngigkeiten, fragen Sie.  Wir haben sie dann ‚Äûertr√§nkt‚Äú, und was ist, wenn sie brechen?  Genau daf√ºr ist die maximale Codeabdeckung bei Tests gedacht.  Wir werden den Betrieb dieser Dienste im Rahmen der Anmeldung nicht √ºberpr√ºfen - wir werden die Anmeldung in der Hoffnung auf den korrekten Betrieb der Dienste testen.  Und dann schreiben wir die gleichen, isolierten Tests f√ºr diese Dienste.  Und testet dann auf ihre Abh√§ngigkeiten.  Usw.  Infolgedessen garantiert jeder einzelne Test <b>nur die</b> korrekte Funktion eines kleinen Codeteils, sofern alle Abh√§ngigkeiten korrekt funktionieren.  Und da alle Abh√§ngigkeiten auch durch Tests abgedeckt werden, ist auch deren einwandfreie Funktion gew√§hrleistet.  Infolgedessen wird jede √Ñnderung am System, die die Logik der Arbeit selbst des kleinsten Codeteils verletzt, sofort in einem bestimmten Test angezeigt.  Wie man den Testlauf konkret durchf√ºhrt - ich werde nicht sagen, die Dokumentation bei PHPUnit ist ziemlich gut.  In Laravel reicht es beispielsweise aus, vendor / bin / phpunit im Stammverzeichnis des Projekts auszuf√ºhren, um eine Meldung wie diese anzuzeigen <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="Bild">  - Alle Tests waren erfolgreich.  Oder so √§hnlich <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="Bild">  Eine der sieben Behauptungen ist fehlgeschlagen. <br><br>  "Das ist nat√ºrlich cool, aber woran komme ich nicht ran?", Fragst du.  Und stellen wir uns dazu den folgenden Code vor <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Wir sehen ein vereinfachtes Modell f√ºr die Arbeit mit einer externen API.  Die Funktion verwendet eine Klasse, um mit der API zu arbeiten, und gibt im Fehlerfall null zur√ºck.  Wenn wir bei Verwendung dieser Funktion null erhalten, sollten wir "Panik ausl√∂sen" (eine Nachricht an die Slack senden oder dem Entwickler eine E-Mail senden oder einen Fehler in die Kibana werfen. Ja, eine Reihe von Optionen).  Alles scheint einfach zu sein, oder?  Stellen Sie sich jedoch vor, dass sich ein anderer Entwickler nach einiger Zeit entschlossen hat, diese Funktion zu "reparieren".  Er entschied, dass das Zur√ºckgeben von null das letzte Jahrhundert ist und er sollte eine Ausnahme ausl√∂sen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  Und er hat sogar alle Abschnitte des Codes neu geschrieben, in denen diese Funktion aufgerufen wurde!  Alle bis auf einen.  Er vermisste ihn.  Abgelenkt, m√ºde, einfach falsch - aber man wei√ü es nie.  Fakt ist, dass ein Teil des Codes noch auf das alte Funktionsverhalten wartet.  Und PHP ist f√ºr uns kein Java - wir erhalten keinen Kompilierungsfehler, weil die Funktion throwable nicht in try-catch eingeschlossen ist.  In einem der 100 Szenarien f√ºr die Verwendung der Site erhalten wir im Falle eines API-Absturzes keine Nachricht vom System.  Dar√ºber hinaus werden wir mit manuellen Tests diese Version des Ereignisses wahrscheinlich nicht erfassen.  Die API ist extern, es h√§ngt nicht von uns ab, sie funktioniert gut - und h√∂chstwahrscheinlich werden wir sie bei einem API-Fehler und einer falschen Ausnahmebehandlung nicht in den Griff bekommen.  Wenn wir jedoch Tests haben, werden sie diesen Fall sehr gut auffangen, da die ExternalApi-Klasse in einer Reihe von Tests "ged√§mpft" ist und sowohl normales Verhalten als auch Absturz emuliert.  Und der n√§chste Test wird fallen <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Diese Information ist eigentlich genug.  Wenn Sie keine Legacy-Nudeln haben, k√∂nnen Sie nach 20 bis 30 Minuten Ihren ersten Test schreiben.  Und ein paar Wochen sp√§ter - um etwas Neues, Cooles zu lernen, kehren Sie zu den Kommentaren unter diesem Beitrag zur√ºck und schreiben Sie, welcher Autor der Govnokoder nicht √ºber% framework_name% wei√ü und schlechte Tests schreibt, aber Sie m√ºssen% this_way% ausf√ºhren.  Und ich werde in diesem Fall sehr gl√ºcklich sein.  Damit ist mein Ziel erreicht: Jemand hat das Testen f√ºr sich entdeckt und die allgemeine Professionalit√§t in unserem Bereich ein wenig gesteigert! <br><br>  Begr√ºndete Kritik ist willkommen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485418/">https://habr.com/ru/post/de485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485394/index.html">Wie die Internetinfrastruktur entstand</a></li>
<li><a href="../de485396/index.html">Squad Health Check: Messung der Team-Gesundheit</a></li>
<li><a href="../de485398/index.html">PostgreSQL Antipatterns: Hit Dictionary auf Heavy JOIN</a></li>
<li><a href="../de485404/index.html">Wir realisieren den visuellen Effekt aus dem Film "The Matrix"</a></li>
<li><a href="../de485416/index.html">Praktische M√∂glichkeiten zum Kartieren von Daten in Kotlin</a></li>
<li><a href="../de485424/index.html">Wie ich Kindern Python beibringe</a></li>
<li><a href="../de485426/index.html">Autos in den Niederlanden: Statistiken und Informationen f√ºr 2019</a></li>
<li><a href="../de485428/index.html">Das mysteri√∂se LyX-Programm. Teil 5</a></li>
<li><a href="../de485430/index.html">Einfacher Mehrbenutzer-Texteditor mit End-to-End-Verschl√ºsselung</a></li>
<li><a href="../de485438/index.html">Testen der Komponenten der Reaktionsoberfl√§che</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>