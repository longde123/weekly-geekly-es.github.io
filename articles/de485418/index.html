<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗡️ ⏱️ 👭 PHPUnit. "Wie teste ich meinen verdammten Controller?" 🧑🏾‍🤝‍🧑🏻 🥖 🔱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 



 Ja, dies ist ein weiterer Beitrag zum Thema Testen. Es scheint, dass es hier bereits möglich ist, zu diskutieren? Alle, die es brauch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Wie teste ich meinen verdammten Controller?"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Hallo Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="Bild"><br><br>  Ja, dies ist ein weiterer Beitrag zum Thema Testen.  Es scheint, dass es hier bereits möglich ist, zu diskutieren?  Alle, die es brauchen - sie schreiben Tests, die es nicht brauchen - sie schreiben nicht, alle sind glücklich!  Tatsache ist, dass die meisten Posts über Unit-Tests ... wie man niemanden beleidigt ... idiotische Beispiele haben!  Nein, wirklich!  Heute werde ich versuchen, es zu beheben.  Ich bitte um katze <br><a name="habracut"></a><br>  Wenn Sie also schnell zum Thema Tests googeln, finden Sie nur viele Artikel, die in ihrer Masse in zwei Kategorien unterteilt sind: <br><br>  1) Das Glück eines Texters.  Zuerst sehen wir eine lange Einführung, dann die Geschichte der Unit-Tests im alten Russland, dann zehn Life-Hacks mit Tests und am Ende ein Beispiel.  Mit Code wie folgt testen: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Und ich scherze gerade nicht.  Ich habe wirklich Artikel mit einem „Taschenrechner“ als Studienführer gesehen.  Ja, ja, ich verstehe, dass es zunächst einmal notwendig ist, alles, Abstraktionen, hin und her zu vereinfachen ... Aber hier endet alles!  Und dann mach die Eule fertig, wie sie sagen <br><br>  2) Überaus ausgefeilte Beispiele.  Schreiben wir einen Test und packen ihn in Gitlab CI. Wenn der Test erfolgreich ist, werden wir ihn automatisch reparieren und PHP Infection auf die Tests anwenden, aber wir werden alles mit Hudson verbinden.  Und so weiter in diesem Stil.  Es scheint nützlich zu sein, aber es scheint nicht das zu sein, wonach Sie suchen.  Sie möchten die Stabilität Ihres Projekts jedoch nur geringfügig erhöhen.  Und all diese Kontinuitäten - na ja, nicht alle auf einmal. <br><br>  Infolgedessen bezweifeln die Leute: "Aber brauche ich das?"  Ich möchte versuchen, das Testen klarer zu erklären.  Und reservieren Sie gleich - ich bin ein Entwickler, ich bin kein Tester.  Ich bin mir sicher, dass ich selbst nicht viel weiß und mein erstes Wort in meinem Leben war nicht das Wort "Mok".  Ich habe noch nie an TDD gearbeitet!  Aber ich weiß mit Sicherheit, dass ich mit meinem derzeitigen Kenntnisstand mehrere Projekte mit Tests abdecken konnte, und genau diese Tests haben bereits ein Dutzend Fehler aufgedeckt.  Und wenn es mir helfen würde, könnte es jemand anderem helfen.  Einige gefangene Bugs lassen sich nur schwer manuell fangen. <br><br>  Zunächst ein kurzes Bildungsprogramm im Frage-Antwort-Format: <br><br>  F: Muss ich ein Framework verwenden?  Was ist, wenn ich Yii habe?  Was ist, wenn Kohana?  Was ist, wenn% one_more_framework_name%? <br>  A: Nein, PHPUnit ist ein unabhängiges Testframework. Sie können es sogar auf einem selbst erstellten Framework mit dem Legacy-Code verschrauben. <br><br>  F: Und jetzt gehe ich schnell mit meinen Händen durch die Website, und es ist normal.  Warum brauche ich das? <br>  A: Ein Durchlauf von mehreren Dutzend Tests dauert mehrere Sekunden.  Das automatische Testen ist immer schneller als das manuelle Testen, und mit hochwertigen Tests ist es auch zuverlässiger, da es alle Szenarien abdeckt. <br><br>  F: Ich habe einen Legacy-Code mit 2000 Zeilenfunktionen.  Kann ich das testen? <br>  A: Ja und nein.  Theoretisch kann jeder Code mit einem Test abgedeckt werden.  In der Praxis sollte der Code mit einer Grundlage für zukünftige Tests geschrieben werden.  Eine 2000-Zeilen-Funktion weist zu viele Abhängigkeiten, Verzweigungen und Grenzfälle auf.  Es mag sich am Ende herausstellen, dass es alles abdeckt, aber höchstwahrscheinlich wird es eine unannehmbar lange Zeit dauern.  Je besser der Code, desto einfacher ist es, ihn zu testen.  Je besser die Einzelverantwortung respektiert wird, desto einfacher werden die Tests.  Um alte Projekte am häufigsten zu testen, müssen Sie sie zunächst kühl umgestalten. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="Bild"><br><br>  F: Ich habe sehr einfache Methoden (Funktionen), was gibt es zu testen?  Dort ist alles zuverlässig, es gibt keinen Raum für Fehler! <br>  A: Es sollte klar sein, dass Sie die korrekte Implementierung der Funktion nicht testen (wenn Sie kein TDD haben), sondern lediglich den aktuellen Status der Funktion "korrigieren".  Wenn Sie es in Zukunft ändern müssen, können Sie mithilfe des Tests schnell feststellen, ob Sie das Verhalten gestört haben.  Beispiel: Es gibt eine Funktion, die E-Mails überprüft.  Sie macht es regelmäßig. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Ihr gesamter Code geht davon aus, dass eine gültige E-Mail an diese Funktion den Wert true zurückgibt.  Eine Reihe von gültigen E-Mails ist auch wahr.  Ein Array mit mindestens einer ungültigen E-Mail-Adresse ist falsch.  Nun und so weiter, der Code ist klar.  Aber der Tag kam und Sie entschieden sich, die monströse reguläre Saison durch eine externe API zu ersetzen.  Aber wie kann man sicherstellen, dass die neu geschriebene Funktion das Funktionsprinzip nicht verändert hat?  Plötzlich kommt es nicht mehr gut mit dem Array klar?  Oder wird es nicht boolean zurückkehren?  Und Tests können dies unter Kontrolle halten.  Ein gut geschriebener Test zeigt sofort ein anderes als das erwartete Funktionsverhalten an. <br><br>  F: Wann werde ich anfangen, Sinn aus Tests zu ziehen? <br>  A: Erstens, sobald Sie einen wesentlichen Teil des Codes abdecken.  Je näher die Abdeckung an 100% liegt, desto zuverlässiger ist die Prüfung.  Zweitens, sobald Sie globale Änderungen oder Änderungen im komplexen Teil des Codes vornehmen müssen.  Tests können Probleme aufdecken, die leicht manuell übersehen werden können (Grenzfälle).  Drittens beim Schreiben der Tests selbst!  Oft kommt es vor, dass das Schreiben eines Tests Codefehler aufzeigt, die auf den ersten Blick nicht sichtbar sind. <br><br>  F: Nun, ich habe eine Website auf Laravel.  Die Seite ist keine Funktion, die Seite ist ein beschissener Berg von Code.  Wie kann man hier testen? <br>  A: Dies wird später besprochen.  Kurzum: Wir testen getrennt die Methoden der Controller, getrennt die Middleware, getrennt die Dienste usw. <br><br>  Eine der Ideen beim Unit-Testen ist es, den getesteten Codeabschnitt zu isolieren.  Je weniger Code Sie mit einem Test testen, desto besser.  Schauen wir uns ein Beispiel an, das dem wirklichen Leben so nahe wie möglich kommt: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Dies ist eine sehr typische Methode, um sich bei kleinen Projekten im System anzumelden.  Wir erwarten nur die richtigen Fehlermeldungen und die versendete E-Mail bei erfolgreicher Anmeldung.  Wie teste ich diese Methode?  Zunächst müssen Sie externe Abhängigkeiten identifizieren.  In unserem Fall gibt es zwei davon - $ userService und $ emailService.  Sie werden durch den Klassenkonstruktor geleitet, was unsere Aufgabe erheblich erleichtert.  Aber wie bereits erwähnt, ist es umso besser, je weniger Code wir in einem Durchgang testen. <br><br>  Emulation, Substitution von Objekten heißt mokanem (aus dem Englischen. Mock object, wörtlich: "Objekt-Parodie").  Niemand hat die Mühe, solche Objekte manuell zu schreiben, aber alles wurde bereits vor uns erfunden, so dass eine so wunderbare Bibliothek wie <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> zur Rettung kommt.  Lassen Sie uns Mokas für Services erstellen. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Erstellen Sie nun das $ request-Objekt.  Zunächst testen wir die Logik des Überprüfens der Anmelde- und Kennwortfelder.  Wir möchten sicherstellen, dass unsere Methode diesen Fall korrekt verarbeitet und die gewünschte (!) Nachricht zurückgibt, wenn keine vorhanden ist. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Nichts kompliziertes, oder?  Wir haben Stubs für die erforderlichen Klassenparameter erstellt, eine Instanz der gewünschten Klasse erstellt und die gewünschte Methode "gezogen", wobei eine absichtlich falsche Anforderung übergeben wurde.  Habe eine Antwort bekommen.  Aber wie kann man das jetzt überprüfen?  Dies ist der wichtigste Teil des Tests - die sogenannte Behauptung.  PHPUnit verfügt über Dutzende von vorgefertigten <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">Behauptungen</a> .  Verwenden Sie einfach einen von ihnen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Dieser Test garantiert Folgendes: Wenn das Login-Argument bei dem Methodenobjekt ankommt, das kein Login- oder Passwortfeld hat, gibt die Methode die Zeichenfolge "Auth error" zurück.  Das ist im Allgemeinen alles.  So einfach - aber so nützlich, denn jetzt können wir die Anmeldemethode bearbeiten, ohne befürchten zu müssen, etwas zu beschädigen.  Unser Frontend kann sicher sein, dass er einen solchen Fehler bekommt, wenn etwas passiert.  Und wenn jemand gegen dieses Verhalten verstößt (z. B. den Fehlertext ändern möchte), zeigt der Test dies sofort an!  Die verbleibenden Prüfungen werden hinzugefügt, um möglichst viele Szenarien abzudecken. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Beachten Sie die Methoden shouldReceive und andReturn?  Sie ermöglichen uns, Methoden in Stubs zu erstellen, die nur das zurückgeben, was wir benötigen.  Müssen Sie den falschen Passwortfehler testen?  Wir schreiben einen stub $ userService, der immer das falsche Passwort zurückgibt.  Und alle. <br><br>  Und was ist mit Abhängigkeiten, fragen Sie.  Wir haben sie dann „ertränkt“, und was ist, wenn sie brechen?  Genau dafür ist die maximale Codeabdeckung bei Tests gedacht.  Wir werden den Betrieb dieser Dienste im Rahmen der Anmeldung nicht überprüfen - wir werden die Anmeldung in der Hoffnung auf den korrekten Betrieb der Dienste testen.  Und dann schreiben wir die gleichen, isolierten Tests für diese Dienste.  Und testet dann auf ihre Abhängigkeiten.  Usw.  Infolgedessen garantiert jeder einzelne Test <b>nur die</b> korrekte Funktion eines kleinen Codeteils, sofern alle Abhängigkeiten korrekt funktionieren.  Und da alle Abhängigkeiten auch durch Tests abgedeckt werden, ist auch deren einwandfreie Funktion gewährleistet.  Infolgedessen wird jede Änderung am System, die die Logik der Arbeit selbst des kleinsten Codeteils verletzt, sofort in einem bestimmten Test angezeigt.  Wie man den Testlauf konkret durchführt - ich werde nicht sagen, die Dokumentation bei PHPUnit ist ziemlich gut.  In Laravel reicht es beispielsweise aus, vendor / bin / phpunit im Stammverzeichnis des Projekts auszuführen, um eine Meldung wie diese anzuzeigen <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="Bild">  - Alle Tests waren erfolgreich.  Oder so ähnlich <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="Bild">  Eine der sieben Behauptungen ist fehlgeschlagen. <br><br>  "Das ist natürlich cool, aber woran komme ich nicht ran?", Fragst du.  Und stellen wir uns dazu den folgenden Code vor <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Wir sehen ein vereinfachtes Modell für die Arbeit mit einer externen API.  Die Funktion verwendet eine Klasse, um mit der API zu arbeiten, und gibt im Fehlerfall null zurück.  Wenn wir bei Verwendung dieser Funktion null erhalten, sollten wir "Panik auslösen" (eine Nachricht an die Slack senden oder dem Entwickler eine E-Mail senden oder einen Fehler in die Kibana werfen. Ja, eine Reihe von Optionen).  Alles scheint einfach zu sein, oder?  Stellen Sie sich jedoch vor, dass sich ein anderer Entwickler nach einiger Zeit entschlossen hat, diese Funktion zu "reparieren".  Er entschied, dass das Zurückgeben von null das letzte Jahrhundert ist und er sollte eine Ausnahme auslösen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  Und er hat sogar alle Abschnitte des Codes neu geschrieben, in denen diese Funktion aufgerufen wurde!  Alle bis auf einen.  Er vermisste ihn.  Abgelenkt, müde, einfach falsch - aber man weiß es nie.  Fakt ist, dass ein Teil des Codes noch auf das alte Funktionsverhalten wartet.  Und PHP ist für uns kein Java - wir erhalten keinen Kompilierungsfehler, weil die Funktion throwable nicht in try-catch eingeschlossen ist.  In einem der 100 Szenarien für die Verwendung der Site erhalten wir im Falle eines API-Absturzes keine Nachricht vom System.  Darüber hinaus werden wir mit manuellen Tests diese Version des Ereignisses wahrscheinlich nicht erfassen.  Die API ist extern, es hängt nicht von uns ab, sie funktioniert gut - und höchstwahrscheinlich werden wir sie bei einem API-Fehler und einer falschen Ausnahmebehandlung nicht in den Griff bekommen.  Wenn wir jedoch Tests haben, werden sie diesen Fall sehr gut auffangen, da die ExternalApi-Klasse in einer Reihe von Tests "gedämpft" ist und sowohl normales Verhalten als auch Absturz emuliert.  Und der nächste Test wird fallen <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Diese Information ist eigentlich genug.  Wenn Sie keine Legacy-Nudeln haben, können Sie nach 20 bis 30 Minuten Ihren ersten Test schreiben.  Und ein paar Wochen später - um etwas Neues, Cooles zu lernen, kehren Sie zu den Kommentaren unter diesem Beitrag zurück und schreiben Sie, welcher Autor der Govnokoder nicht über% framework_name% weiß und schlechte Tests schreibt, aber Sie müssen% this_way% ausführen.  Und ich werde in diesem Fall sehr glücklich sein.  Damit ist mein Ziel erreicht: Jemand hat das Testen für sich entdeckt und die allgemeine Professionalität in unserem Bereich ein wenig gesteigert! <br><br>  Begründete Kritik ist willkommen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485418/">https://habr.com/ru/post/de485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485394/index.html">Wie die Internetinfrastruktur entstand</a></li>
<li><a href="../de485396/index.html">Squad Health Check: Messung der Team-Gesundheit</a></li>
<li><a href="../de485398/index.html">PostgreSQL Antipatterns: Hit Dictionary auf Heavy JOIN</a></li>
<li><a href="../de485404/index.html">Wir realisieren den visuellen Effekt aus dem Film "The Matrix"</a></li>
<li><a href="../de485416/index.html">Praktische Möglichkeiten zum Kartieren von Daten in Kotlin</a></li>
<li><a href="../de485424/index.html">Wie ich Kindern Python beibringe</a></li>
<li><a href="../de485426/index.html">Autos in den Niederlanden: Statistiken und Informationen für 2019</a></li>
<li><a href="../de485428/index.html">Das mysteriöse LyX-Programm. Teil 5</a></li>
<li><a href="../de485430/index.html">Einfacher Mehrbenutzer-Texteditor mit End-to-End-Verschlüsselung</a></li>
<li><a href="../de485438/index.html">Testen der Komponenten der Reaktionsoberfläche</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>