<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍍 🧚🏽 🦀 Courier: ترحيل Dropbox إلى gRPC 🔠 🎓 👨🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ملاحظة المترجم 
 معظم منتجات البرمجيات الحديثة ليست متجانسة ، ولكنها تتكون من العديد من الأجزاء التي تتفاعل مع بعضها البعض. في هذه الحالة ، من الضروري...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Courier: ترحيل Dropbox إلى gRPC</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1 style=";text-align:right;direction:rtl">  ملاحظة المترجم </h1><br>  معظم منتجات البرمجيات الحديثة ليست متجانسة ، ولكنها تتكون من العديد من الأجزاء التي تتفاعل مع بعضها البعض.  في هذه الحالة ، من الضروري أن يتم التواصل بين الأجزاء المتفاعلة من النظام بلغة واحدة (على الرغم من أن هذه الأجزاء نفسها يمكن كتابتها بلغات برمجة مختلفة وتشغيلها على أجهزة مختلفة).  لتبسيط حل هذه المشكلة ، يساعد gRPC - إطار عمل مفتوح المصدر من Google ، صدر في عام 2015.  انه يحل على الفور عددا من المشاكل ، والسماح: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  استخدام لغة Protocol Buffers لوصف تفاعل الخدمات ؛ <br></li><li style=";text-align:right;direction:rtl">  إنشاء رمز البرنامج استنادًا إلى البروتوكول الموضح لـ 11 لغة مختلفة لكل من جزء العميل وجزء الخادم ؛ <br></li><li style=";text-align:right;direction:rtl">  تنفيذ إذن بين المكونات المتفاعلة ؛ <br></li><li style=";text-align:right;direction:rtl">  استخدام كل من التفاعل متزامن وغير متزامن. <br></li></ul><br>  بدا لي gRPC إطارًا ممتعًا للغاية ، وكنت مهتمًا بالتعرف على تجربة Dropbox الحقيقية في بناء نظام قائم عليه.  تحتوي المقالة على الكثير من التفاصيل المتعلقة باستخدام التشفير ، وإنشاء نظام موثوق ومُلاحظ ومنتج ، وعملية الترحيل من حل RPC القديم إلى الحل الجديد. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">إخلاء المسؤولية</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  لا تحتوي المقالة الأصلية على وصف gRPC ، وقد لا تبدو بعض النقاط واضحة لك.  إذا لم تكن معتادًا على gRPC أو الأُطُر المشابهة الأخرى (على سبيل المثال ، Apache Thrift) ، فإنني أوصيك أولاً بالتعرف على الأفكار الرئيسية (ستكون كافية لقراءة مقالتين صغيرتين من الموقع الرسمي: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"ما هي gRPC؟"</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"مفاهيم gRPC"</a> ). <br><br>  بفضل أليكسي إيفانوف الملقب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">SaveTheRbtz</a> لكتابة المقال الأصلي والمساعدة في ترجمة الأماكن الصعبة. <br></div></div><a name="habracut"></a><br>  تقوم Dropbox بإدارة العديد من الخدمات المكتوبة بلغات مختلفة وتخدم ملايين الطلبات في الثانية.  في مركز الهندسة المعمارية الموجهة نحو الخدمات لدينا ، Courier ، إطار عمل قائم على تكلفة النقرة.  في عملية تطويره ، تعلمنا الكثير عن القابلية للتوسعة gRPC وتحسين الأداء والانتقال من نظام RPC السابق. <br><br>  <i>ملاحظة: يحتوي المنشور على مقتطفات برمجية لـ Python و Go.</i>  <i>نحن نستخدم أيضا الصدأ وجافا.</i> <br><br><h1 style=";text-align:right;direction:rtl">  الطريق إلى gRPC </h1><br>  Courier ليس إطار Dropbox RPC الأول.  حتى قبل أن نبدأ في تقسيم نظام Python المتجانس إلى خدمات منفصلة ، كنا بحاجة إلى أساس موثوق لتبادل البيانات بين الخدمات - خاصة وأن اختيار إطار عمل سيكون له عواقب طويلة الأجل. <br><br>  قبل ذلك ، جربت Dropbox أطر عمل RPC مختلفة.  أولاً ، كان لدينا بروتوكول فردي للتسلسل اليدوي وإلغاء التسلسل.  تستخدم بعض الخدمات ، مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التسجيل المستند إلى Scribe</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Apache Thrift</a> .  في الوقت نفسه ، كان إطار عمل RPC الرئيسي هو بروتوكول HTTP / 1.1 مع تسلسل الرسائل باستخدام Protobuf. <br><br>  إنشاء إطار عمل ، اخترنا من بين عدة خيارات.  يمكننا تقديم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Swagger</a> (المعروف الآن باسم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">OpenAPI</a> ) في إطار عمل RPC القديم ، أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تقديم معيار جديد ،</a> أو إنشاء إطار عمل يستند إلى Thrift أو gRPC.  كانت الحجة الرئيسية لصالح gRPC هي إمكانية استخدام protobufs الموجودة مسبقًا.  أيضًا ، كان تعدد إرسال HTTP / 2 ونقل البيانات في اتجاهين مفيدًا لمهامنا. <br><br>  <i>ملاحظة: إذا كانت fbthrift موجودة في تلك اللحظة ، فربما نلقي نظرة فاحصة على حلول Thrift.</i> <br><br><h1 style=";text-align:right;direction:rtl">  ما يجلب الساعي إلى gRPC </h1><br>  Courier ليس بروتوكول RPC؛  إنها وسيلة لدمج gRPC في البنية التحتية الحالية.  كان من المفترض أن يكون الإطار متوافقًا مع أدوات الاستيقان والترخيص واكتشاف الخدمة ، بالإضافة إلى جمع الإحصاءات وتسجيلها وتتبعها.  لذلك أنشأنا Courier. <br><br>  <i>رغم أننا في بعض الحالات نستخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Bandaid</a> كوكيل gRPC ، فإن معظم خدماتنا تتواصل مباشرة مع بعضها البعض لتقليل تأثير RPC على الكمون.</i> <br><br>  كان من المهم بالنسبة لنا تقليل مقدار الشفرة الروتينية التي يجب كتابتها.  نظرًا لأن Courier بمثابة إطار عام لتطوير الخدمات ، فإنه يحتوي على ميزات يحتاجها الجميع.  يتم تمكين معظمها افتراضيًا ويمكن التحكم فيها بواسطة وسيطات سطر الأوامر ، ويتم التحقق من بعضها باستخدام مربع اختيار. <br><br><h2 style=";text-align:right;direction:rtl">  الأمان: هوية الخدمة ومصادقة TLS المتبادلة </h2><br>  تنفذ شركة Courier آلية تحديد الخدمة القياسية الخاصة بنا.  يتم تعيين شهادة TLS فردية لكل خادم وعميل صادرة عن سلطة إصدار الشهادات الخاصة بنا.  الشهادة المعرف الشخصي المشفر ، والتي يتم استخدامها للمصادقة المتبادلة - يتحقق الخادم من العميل ، يتحقق العميل من الخادم. <br><br>  في TLS ، حيث نتحكم في كلا جانبي الاتصال ، أدخلنا قيودًا صارمة.  تتطلب جميع RPCs الداخلية تشفير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PFS</a> .  الإصدار المطلوب من TLS هو 1.2 وما فوق.  حددنا أيضًا عدد الخوارزميات المتماثلة وغير المتماثلة ، مفضلين <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  بعد اجتياز تحديد وفك تشفير الطلب ، يتحقق الخادم مما إذا كان العميل لديه الأذونات اللازمة.  يمكن تكوين قوائم التحكم في الوصول (ACL) وحدود السرعة لكل من الخدمات بشكل عام وللأساليب الفردية.  يمكن أيضًا تغيير معلماتها من خلال نظام الملفات الموزع (AFS).  بفضل هذا ، يمكن لأصحاب الخدمة إسقاط الحمل في ثوانٍ ، حتى دون إعادة تشغيل العمليات.  سوف تتولى Courier الاشتراك في الإعلامات وتحديث التكوين. <br><br>  <i>خدمة الهوية هي معرّف عمومي لـ ACL ، وحدود السرعة ، والإحصاءات ، إلخ. بالإضافة إلى ذلك ، فهي آمنة بشكل تشفير.</i> <br><br>  فيما يلي مثال لتكوين ACL والحد الأقصى للسرعة المستخدم في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">خدمة التعرف على الأنماط البصرية</a> : <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>نحن نفكر في إمكانية التبديل إلى تنسيق SVID (المستند الذي تم التحقق منه بشكل تشفير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SPIFFE</a> ) ، والذي سيساعد على دمج <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إطارنا</a> مع العديد من المشاريع مفتوحة المصدر.</i> <br><br><h2 style=";text-align:right;direction:rtl">  الملاحظة: الإحصاءات والتتبع </h2><br>  باستخدام معرف واحد فقط ، يمكنك بسهولة العثور على السجلات والإحصائيات وملفات التتبع والبيانات الأخرى حول Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  أثناء إنشاء التعليمات البرمجية ، تتم إضافة مجموعة الإحصائيات لكل خدمة ولكل طريقة من جانب العميل ومن جانب الخادم.  يتم تقسيم إحصائيات جانب الخادم بواسطة معرف العميل.  في التكوين القياسي ، سوف تتلقى بيانات مفصلة عن الحمل والأخطاء ووقت التأخير لكل خدمة باستخدام Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  تتضمن إحصائيات Courier بيانات حول التوفر والكمون من جانب العميل ، وكذلك عن عدد الطلبات وحجم قائمة الانتظار على جانب الخادم.  هناك رسوم بيانية أخرى مفيدة ، ولا سيما الرسوم البيانية لوقت الاستجابة لكل طريقة ووقت مصافحة TLS لكل عميل. <br><br>  <i>تتمثل إحدى مزايا إنشاء الكود لدينا في إمكانية التهيئة الثابتة لهياكل البيانات ، مثل الرسوم البيانية والرسوم البيانية التتبعية.</i>  <i>هذا يقلل من تأثير الأداء.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  قام نظام RPC القديم بتوزيع <i>request_id</i> فقط على واجهة برمجة التطبيقات.  هذا جعل من الممكن الجمع بين البيانات من سجلات الخدمات المختلفة.  في Courier ، قدمنا ​​API بناءً على مجموعة فرعية من مواصفات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">OpenTracing</a> .  لقد كتبنا مكتباتنا الخاصة من جانب العميل ، وعلى جانب الخادم ، قمنا بتطبيق حل قائم على Cassandra و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  يتيح لنا التتبع إنشاء مخططات تبعية للخدمة في وقت التشغيل.  هذا يساعد المهندسين على رؤية كل التبعيات العابرة لخدمة معينة.  بالإضافة إلى ذلك ، تكون الوظيفة مفيدة لتتبع التبعيات غير المرغوب فيها بعد النشر. <br><br><h2 style=";text-align:right;direction:rtl">  الموثوقية: المواعيد النهائية وانقطاع الاتصال </h2><br>  يوفر Courier مكانًا مركزيًا لتنفيذ وظائف العميل الشائعة (على سبيل المثال ، المهلات) بلغات مختلفة.  لقد قمنا تدريجياً بإضافة العديد من الميزات ، استنادًا إلى نتائج تحليل "بعد وفاته" للمشاكل الناشئة. <br><br><h3 style=";text-align:right;direction:rtl">  المواعيد النهائية </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كل طلب gRPC له موعد نهائي</a> للإشارة إلى مهلة العميل.  نظرًا لأن روتين Courier يقوم تلقائيًا بتوزيع البيانات التعريفية المعروفة ، يتم نقل الموعد النهائي للطلب خارج API.  ضمن هذه العملية ، تتلقى المواعيد النهائية عرضًا أصليًا.  على سبيل المثال ، في Go ، يتم تمثيلهم بنتيجة <i>السياق .Context من</i> أسلوب <i>WithDeadline</i> . <br><br>  في الواقع ، تمكنا من إصلاح فئات كاملة من مشاكل الموثوقية من خلال إجبار المهندسين على تحديد مواعيد نهائية في تحديد الخدمات المناسبة. <br><br>  هذا النهج يتجاوز حتى RPC.  على سبيل المثال ، يقوم ORM MySQL لدينا بتسلسل سياق RPC مع الموعد النهائي في تعليق استعلام SQL.  وكيل SQL لدينا يمكن تحليل التعليقات و "قتل" الاستعلامات عند حدوث الموعد النهائي.  وكعلاوة عند تصحيح أخطاء مكالمات قاعدة البيانات ، لدينا استعلام SQL ملزم لاستعلام RPC معين. <br><br><h3 style=";text-align:right;direction:rtl">  قطع الاتصال </h3><br>  هناك مشكلة شائعة أخرى واجهها عملاء نظام RPC السابق وهي تنفيذ خوارزمية التأخير الفردي والتقلبات عند الطلب المتكرر. <br><br>  لقد حاولنا إيجاد حل ذكي لمشكلة الانفصال في Courier ، بدءًا من تنفيذ المخزن المؤقت LIFO (الأخير في الخروج أولاً) بين الخدمة ومجموعة المهام. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  في حالة وجود حمل زائد ، سيتم قطع LIFO تلقائيًا.  قائمة الانتظار ، وهو أمر مهم ، يقتصر ليس فقط من حيث الحجم ، ولكن أيضا <b>حسب الوقت</b> (يمكن أن يقضي الطلب في قائمة الانتظار فقط وقت معين). <br><br>  <i>ناقص LIFO - تغيير ترتيب معالجة الطلبات.</i>  <i>إذا كنت تريد الاحتفاظ بالترتيب الأصلي ، استخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CoDel</a> .</i>  <i>هناك ، أيضًا ، إمكانية قطع الاتصال ، وسيظل ترتيب معالجة الطلبات كما هو.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2 style=";text-align:right;direction:rtl">  الاستبطان: تصحيح نقاط النهاية </h2><br>  على الرغم من أن نقاط النهاية لتصحيح الأخطاء ليست جزءًا من Courier مباشرة ، إلا أنها تستخدم على نطاق واسع في جميع أنحاء Dropbox وهي مفيدة جدًا بحيث لا يمكن ذكرها. <br><br>  <i>لأسباب أمنية ، يمكنك فتحها على منفذ منفصل أو على مقبس Unix (للتحكم في الوصول باستخدام أذونات الملفات).</i>  <i>يجب أيضًا مراعاة مصادقة TLS المتبادلة ، والتي سيتعين على المطورين تقديم شهاداتهم للوصول إلى نقاط النهاية (لا يقتصر الأمر على القراءة فقط).</i> <br><br><h3 style=";text-align:right;direction:rtl">  التنفيذ </h3><br>  تعد القدرة على تحليل حالة الخدمة أثناء تشغيلها مفيدة للغاية لتصحيح الأخطاء.  على سبيل المثال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://golang.org/pkg/net/">يمكن الوصول إلى ملفات تعريف الذاكرة الديناميكية ووحدة المعالجة المركزية من خلال نقاط النهاية HTTP أو gRPC</a> . <br><br>  <i>نحن نخطط لاستخدام هذه الفرصة في إجراء التحقق من الكناري - لأتمتة البحث عن الفرق بين الإصدارات القديمة والجديدة من الشفرة.</i> <br><br>  تتيح نقاط النهاية تعديل حالة الخدمة في وقت التشغيل.  على وجه الخصوص ، يمكن للخدمات المستندة إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Golang</a> تكوين <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">GCPercent</a> بشكل حيوي. <br><br><h3 style=";text-align:right;direction:rtl">  المكتبة </h3><br>  قد يكون التصدير التلقائي للبيانات الخاصة بالمكتبة كنقطة نهاية RPC مفيدًا لمطوري المكتبة.  على سبيل المثال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">يمكن</a> لمكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">malloc تفريغ الإحصاءات الداخلية في ملف تفريغ</a> .  مثال آخر: يمكن لنقطة النهاية لتصحيح الأخطاء تغيير مستوى تسجيل الخدمة على الطاير. <br><br><h3 style=";text-align:right;direction:rtl">  RPC </h3><br>  بالطبع ، استكشاف الأخطاء وإصلاحها في البروتوكولات المشفرة والمشفرة ليس بالأمر السهل.  لذلك ، يعد تقديم أكبر عدد ممكن من الأدوات على مستوى RPC فكرة جيدة.  أحد الأمثلة على API الاستبطاني <a href="">هو حل Channelz</a> . <br><br><h3 style=";text-align:right;direction:rtl">  مستوى التطبيق </h3><br>  القدرة على تعلم خيارات مستوى التطبيق يمكن أن تكون مفيدة أيضًا.  مثال جيد هو نقطة النهاية مع معلومات عامة حول التطبيق (مع تجزئة لملفات المصدر أو التجميع ، سطر الأوامر ، وما إلى ذلك).  يمكن استخدامه بواسطة نظام تزامن للتحقق من السلامة عند نشر الخدمة. <br><br><h1 style=";text-align:right;direction:rtl">  تحسين الأداء </h1><br>  من خلال توسيع إطار gRPC الخاص بنا إلى النطاق المطلوب ، وجدنا العديد من الاختناقات الخاصة بـ Dropbox. <br><br><h3 style=";text-align:right;direction:rtl">  استهلاك الموارد لمصادقة TLS </h3><br>  في الخدمات التي تخدم العديد من العلاقات ، نتيجة لمصادقة TLS ، يمكن أن يكون حمل وحدة المعالجة المركزية المدمجة خطيرًا للغاية (خاصة عند إعادة تشغيل خدمة شائعة). <br><br>  لتحسين الأداء عند التوقيع ، استبدلنا أزواج المفاتيح RSA-2048 بـ ECDSA P-256.  فيما يلي أمثلة على أدائها (ملاحظة: مع RSA ، يكون التحقق من التوقيع أسرع). <br><br>  <b>RSA:</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  نظرًا لأن التحقق باستخدام RSA-2048 أسرع بثلاث مرات تقريبًا من ECDSA P-256 ، يمكنك اختيار RSA لشهادات الجذر والنهاية لزيادة سرعة التشغيل.  ولكن من وجهة نظر الأمان ، ليس كل شيء بهذه البساطة: ستقوم ببناء سلاسل من بدائل التشفير المختلفة ، وبالتالي ، سيكون مستوى معلمات الأمان الناتجة هو الأدنى.  وإذا كنت ترغب في تحسين الأداء ، فإننا لا نوصي باستخدام شهادات الإصدار RSA-4096 (والإصدارات الأحدث) كشهادات الجذر والنهاية. <br><br>  لقد وجدنا أيضًا أن اختيار مكتبة TLS (وأعلام الترجمة) له تأثير كبير على كل من الأداء والأمان.  قارن ، على سبيل المثال ، بناء LibreSSL على نظام MacOS X Mojave مع OpenSSL المكتوب ذاتيًا على نفس الجهاز. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  ومع ذلك ، فإن أسرع طريقة لإنشاء مصافحة TLS هي عدم إنشائها على الإطلاق!  لقد قمنا بتضمين دعم لاستئناف الجلسة في gRPC-core و gRPC-python ، وبالتالي تقليل الحمل على وحدة المعالجة المركزية أثناء النشر. <br><br><h3 style=";text-align:right;direction:rtl">  التشفير غير مكلفة </h3><br>  يعتقد الكثيرون خطأ أن التشفير مكلف.  في الواقع ، حتى أبسط أجهزة الكمبيوتر الحديثة تؤدي تشفيرًا متماثلًا على الفور تقريبًا.  يستطيع المعالج القياسي تشفير البيانات والمصادقة عليها بسرعة 40 جيجابت / ثانية لكل قلب: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  ومع ذلك ، لا يزال يتعين علينا تهيئة gRPC لكتل ​​الذاكرة الخاصة بنا ، والتي تعمل بسرعة 50 جيجابت / ثانية.  وجدنا أنه إذا كانت سرعة التشفير مساوية تقريبًا لسرعة النسخ ، فمن المهم تقليل عدد عمليات <i>memcpy.</i>  بالإضافة إلى ذلك ، لقد أجرينا بعض التغييرات على gRPC نفسها. <br><br>  <i>تجنبت البروتوكولات المصادقة والمشفرة العديد من المشكلات غير السارة (على سبيل المثال ، تلف البيانات من قبل المعالج أو DMA أو على الشبكة).</i>  <i>حتى إذا كنت لا تستخدم gRPC ، فإننا نوصي باستخدام TLS لجهات الاتصال الداخلية.</i> <br><br><h2 style=";text-align:right;direction:rtl">  قنوات بيانات عالية الكمون (BDP) </h2><br>  ملاحظة المترجم: يستخدم العنوان الفرعي الأصلي مصطلح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"تأخير عرض النطاق الترددي"</a> ، والذي لا يحتوي على ترجمة ثابتة إلى اللغة الروسية. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تتضمن شبكة العمود الفقري Dropbox العديد من مراكز البيانات</a> .  في بعض الأحيان ، يجب على العقد الموجودة في مناطق مختلفة الاتصال عبر RPC ، على سبيل المثال ، للنسخ المتماثل.  عند استخدام TCP ، تكون نواة النظام مسؤولة عن الحد من كمية البيانات المرسلة في اتصال معين (داخل / <i>proc / sys / net / ipv4 / tcp_ {r، w} mem</i> ) ، على الرغم من أن gRPC المستندة إلى HTTP / 2 لها أداة خاصة بها التحكم في التدفق.  يقتصر الحد الأقصى لـ BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في grpc-go بدقة على 16 ميغابايت</a> ، مما قد يؤدي إلى اختناق. <br><br><h2 style=";text-align:right;direction:rtl">  net.erver Golang أو grpc.Server </h2><br>  في البداية ، في Go Go ، دعمنا HTTP / 1.1 و gRPC مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://golang.org/pkg/net/">net.Server</a> واحد.  كان الحل منطقيًا فيما يتعلق بالحفاظ على رمز البرنامج ، لكنه لم ينجح تمامًا على الإطلاق.  يؤدي توزيع HTTP / 1.1 و gRPC عبر الخوادم وترحيل gRPC إلى grpc.Server إلى تحسين عرض النطاق الترددي Courier واستخدام الذاكرة بشكل ملحوظ. <br><br><h2 style=";text-align:right;direction:rtl">  golang / protobuf أو gogo / protobuf </h2><br>  يمكن أن يؤدي التبديل إلى gRPC إلى زيادة تكلفة التنظيم والتنظيم.  بالنسبة إلى Go code ، تمكنا من تقليل حمل وحدة المعالجة المركزية (CPU) على خوادم Courier بشكل كبير عن طريق التبديل إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">gogo / protobuf</a> . <br><br>  <i>كما هو الحال دائمًا ، كان <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الانتقال إلى gogo / protobuf مصحوبًا ببعض المخاوف</a> ، ولكن إذا قمت بتحديد الوظائف بشكل معقول ، فلا ينبغي أن تكون هناك مشاكل.</i> <br><br><h1 style=";text-align:right;direction:rtl">  تفاصيل التنفيذ </h1><br>  في هذا القسم ، سنخترق أعمق في جهاز Courier ، وسننظر في مخططات protobuf وأمثلة من الرذائل من لغات مختلفة.  جميع الأمثلة مأخوذة من خدمة الاختبار ، والتي استخدمناها أثناء اختبار تكامل Courier. <br><br><h2 style=";text-align:right;direction:rtl">  وصف الخدمة </h2><br>  ألقِ نظرة على مقتطف من تعريف خدمة الاختبار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  كما ذكر أعلاه ، مطلوب موعد نهائي لجميع أساليب Courier.  باستخدام الخيار التالي ، يمكنك تعيين الموعد النهائي للخدمة بأكملها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  في الوقت نفسه ، يمكن ضبط كل طريقة على الموعد النهائي الخاص بها ، وإلغاء الموعد النهائي للخدمة بأكملها (إن وجد): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  في حالات نادرة عندما لا يكون الموعد النهائي منطقيًا (على سبيل المثال ، عند تتبع أحد الموارد) ، يمكن للمطور تعطيله: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  بالإضافة إلى ذلك ، يجب أن يحتوي وصف الخدمة على وثائق API مفصلة ، وربما مع أمثلة الاستخدام. <br><br><h2 style=";text-align:right;direction:rtl">  كعب الجيل </h2><br>  لتوفير قدر أكبر من المرونة ، يولد Courier كعب الروتين الخاص به دون الاعتماد على وظيفة الاعتراض التي توفرها gRPC (باستثناء Java ، حيث تتمتع API المعترضة بقدرة كافية).  دعونا نقارن بذراتنا مع بذرات Golang القياسية. <br><br>  هذا هو ما يبدو عليه كعب روتين خادم gRPC الافتراضي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  تتم جميع عمليات المعالجة في الداخل: فك تشفير protobuf ، وإطلاق interceptors (انظر متغير <code>interceptor</code> في الكود) ، وإطلاق معالج UnaryUnary. <br><br>  الآن نلقي نظرة على بذرة ساعي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  يوجد الكثير من التعليمات البرمجية هنا ، لذلك دعونا نحللها. <br><br>  أولاً ، نؤجل الدعوة إلى معالج الذعر ، المسؤول عن جمع الأخطاء تلقائيًا.  سيسمح لنا ذلك بجمع جميع الاستثناءات غير المعلنة في المستودع المركزي للتجميع والإبلاغ اللاحقين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  سبب آخر لتشغيل معالج الذعر الخاص بنا هو التأكد من تعطل التطبيق في حالة حدوث خطأ.  سيتجاهل معالج HTTP golang / net القياسي في هذه الحالة المشكلة ويستمر في تقديم الطلبات الجديدة (حتى التالفة وغير المتسقة). <br><br>  بعد ذلك نقوم بتمرير السياق ، ونعيد تحديد القيم بناءً على البيانات الأولية للطلب الوارد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  نقوم أيضًا بإنشاء (وذاكرة التخزين المؤقت لمزيد من الكفاءة) إحصائيات العميل من جانب الخادم لتجميع أكثر تفصيلاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  ينشئ هذا السطر إحصائيات لكل عميل (أي معرف TLS) أثناء التنفيذ.  لدينا أيضا إحصاءات عن جميع الأساليب لكل خدمة.  نظرًا لأن مولد كعب الروتين لديه إمكانية الوصول إلى جميع الطرق أثناء إنشاء الشفرة ، يمكننا إنشاءها بشكل ثابت مسبقًا ، وبالتالي تجنب إبطاء البرنامج. <br><br>  بعد ذلك ، نقوم بإنشاء هيكل طلب ، ونقله إلى تجمع المهام وانتظار التنفيذ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  يرجى ملاحظة أننا في هذه المرحلة لم نقم بفك تشفير protobuf ، ولم نطلق أداة الاعتراض.  قبل ذلك ، يجب أن يمر تجمع الوصول وتحديد الأولويات والحد من عدد الطلبات المنفذة من خلال تجمع المهام. <br><br>  <i>لاحظ أن مكتبة gRPC تدعم واجهة TAP ، التي تسمح لك باعتراض الطلبات بسرعة هائلة.</i>  <i>توفر الواجهة البنية التحتية لبناء محددات السرعة الفعالة بأقل استهلاك للموارد.</i> <br><br><h2 style=";text-align:right;direction:rtl">  رموز خطأ محددة للتطبيقات المختلفة </h2><br>  يتيح مولد أداة كعب الروتين للمطورين أيضًا تعيين رموز خطأ خاصة بالتطبيق باستخدام خيارات خاصة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  يتم نشر كل من أخطاء gRPC والتطبيق داخل الخدمة ، وعند حدود واجهة برمجة التطبيقات ، يتم استبدال جميع الأخطاء بـ UNKNOWN.  بفضل هذا ، يمكننا تجنب نقل المشكلة إلى خدمات أخرى ، مما قد يؤدي إلى تغيير في دلالاتها. <br><br><h2 style=";text-align:right;direction:rtl">  بيثون التغييرات </h2><br>  تضيف عناصر كعب بايثون معلمة سياق صريحة لجميع معالجات Courier: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  في البداية بدا الأمر غريبًا ، ولكن مع مرور الوقت ، اعتاد المطورون على <i>التعبير عن ctx</i> تمامًا مثلما اعتادوا على <i>الذات</i> . <br><br>  يرجى ملاحظة أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كعب</a> الروتين يتم كتابته بالكامل من أجل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">mypy</a> ، والذي يتم تعويضه أثناء إعادة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التوطين</a> الرئيسية.  بالإضافة إلى ذلك ، يتم تبسيط التكامل مع بعض IDEs (مثل PyCharm). <br><br>  متابعة لمتابعة اتجاه الكتابة الثابتة ، نضيف التعليقات التوضيحية غير الصحيحة إلى البروتوكولات نفسها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  ستتجنب هذه التعليقات التوضيحية العديد من الأخطاء الشائعة ، مثل تعيين قيمة بلا <i>إلى</i> حقل نوع <i>السلسلة</i> ، على سبيل المثال <i>.</i> <br><br>  هذا الرمز <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">متاح هنا</a> . <br><br><h1 style=";text-align:right;direction:rtl">  عملية الهجرة </h1><br>  إن إنشاء مكدس RPC جديد ليس بالمهمة السهلة ، لكنه لا يقف بجوار عملية الانتقال الكامل إليها ، إذا نظرت من وجهة نظر تعقيد التشغيل.  لذلك ، حاولنا أن نجعل من السهل على المطورين التبديل من RPC القديم إلى Courier.  نظرًا لأن الهجرة غالباً ما تكون مصحوبة بأخطاء ، فقد قررنا تنفيذها على مراحل. <br><br><h2 style=";text-align:right;direction:rtl">  الخطوة 0: تجميد RPC القديم </h2><br>  بادئ ذي بدء ، جمدنا RPC القديم حتى لا نطلق النار على هدف متحرك.  كما دفع الناس للتبديل إلى Courier ، لأن جميع الميزات الجديدة مثل التتبع كانت متاحة فقط في الخدمات على Courier. <br><br><h2 style=";text-align:right;direction:rtl">  الخطوة 1: واجهة مشتركة ل RPC القديمة والساعي </h2><br>  بدأنا بتحديد واجهة مشتركة لـ RPC و Courier القديمة.  كان من المفترض أن يكون توليد الشفرة الخاص بنا للتأكد من أن كلا إصداري الروتين يتوافق مع هذه الواجهة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2 style=";text-align:right;direction:rtl">  الخطوة 2: الترحيل إلى الواجهة الجديدة </h2><br>  بعد ذلك ، بدأنا في تحويل كل خدمة إلى واجهة جديدة ، مع الاستمرار في استخدام RPC القديم.  في كثير من الأحيان ، كانت التغييرات في التعليمات البرمجية فرقًا كبيرًا ، حيث أثرت على جميع أساليب الخدمة وعملائها.  نظرًا لأن هذه المرحلة هي الأكثر إشكالية ، فقد أردنا التخلص تمامًا من الخطر عن طريق تغيير شيء واحد فقط في كل مرة. <br><br>  <i>يمكن ترحيل الخدمات البسيطة مع عدد قليل من الطرق <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والحق في ارتكاب الأخطاء في</a> وقت واحد ، دون الانتباه إلى تحذيراتنا.</i> <br><br><h2 style=";text-align:right;direction:rtl">  الخطوة 3: ترحيل العملاء إلى RPC Courier </h2><br>  أثناء عملية الترحيل ، بدأنا في وقت واحد في إطلاق الخوادم القديمة والجديدة على منافذ مختلفة من نفس الجهاز.  تم تبديل تطبيق RPC من جانب العميل عن طريق تغيير سطر واحد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  يرجى ملاحظة أنه باستخدام هذا النموذج ، يمكنك نقل عميل واحد في كل مرة ، بدءًا من العملاء ذوي المستوى الأدنى من اتفاقية مستوى الخدمة. <br><br><h2 style=";text-align:right;direction:rtl">  الخطوة 4: التنظيف </h2><br>       ,   ,   RPC    (               ).       —   . <br><br><h1 style=";text-align:right;direction:rtl">  الاستنتاجات </h1><br> , Courier —  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  —  .           . <br></li><li style=";text-align:right;direction:rtl">      —    ,     . <br></li><li style=";text-align:right;direction:rtl">     ,  .     Codegen. <br></li><li style=";text-align:right;direction:rtl">    . ,    ,   .  , :       . <br></li><li style=";text-align:right;direction:rtl">  RPC-       —  ,     . .           . <br></li></ol><br><h1 style=";text-align:right;direction:rtl">   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar438474/">https://habr.com/ru/post/ar438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar438464/index.html">SciPy ، خوارزميات الرسم البياني</a></li>
<li><a href="../ar438466/index.html">عكاز لليزر الصيني</a></li>
<li><a href="../ar438468/index.html">مستعمرة. الفصل 23: اختبار القيادة</a></li>
<li><a href="../ar438470/index.html">المبيعات العالمية في ديسمبر و 2018: تم بيع مليوني سيارة كهربائية إضافية</a></li>
<li><a href="../ar438472/index.html">البيئة المعمارية وحدات متطورة في UE4</a></li>
<li><a href="../ar438476/index.html">إلى مسألة مخازن (حلقة)</a></li>
<li><a href="../ar438478/index.html">صدر GitLab 11.7 مع الإصدارات ، والملاحم المتداخلة متعددة المستويات وتسجيل حزم NPM</a></li>
<li><a href="../ar438480/index.html">ضعها في مكانها الصحيح: 7 أماكن مثالية لوضع محتوى الفيديو</a></li>
<li><a href="../ar438482/index.html">السمعة والعمل والهجرة: كيفية استخدام أدوات الترويج للشركة لحل المشكلات الشخصية</a></li>
<li><a href="../ar438486/index.html">بطاقة ذاكرة لا يمكن اختراقها - يغرق ويجمد ويشعل النار في جهاز Kingston microSD High Endurance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>