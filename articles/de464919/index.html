<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíì üÜí üõí Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung üè≥Ô∏è üë®üèæ‚ÄçüöÄ üßòüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung 

 Beschreibt ein relativ einfaches Software-Implementierungstool zur Steuerung d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464919/"><h1>  Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung </h1><br><img src="https://habrastorage.org/webt/ez/cg/lk/ezcglkhvp9ztri9vr5euj3-wwoa.jpeg" width="300" align="right"><br>  <i>Beschreibt ein relativ einfaches Software-Implementierungstool zur Steuerung der verwendeten RAM-Ressourcen w√§hrend der Anwendungsausf√ºhrung.</i>  <i>Die Basis der Implementierung ist das Abfangen und Registrieren von Anforderungen f√ºr die Zuweisung, Freigabe und Wiederverwendung von Speicherressourcen, die von der Anwendung √ºber die Aufrufe <i>malloc (), calloc (), realloc (), free ()</i> an das Betriebssystem gesendet werden.</i>  <i>Alle Speicheranforderungen werden in einem speziellen Protokoll aufgezeichnet und am Ende der Anwendung werden die gesammelten Informationen in Form eines Berichts auf der Konsole angezeigt oder in eine Textdatei geschrieben.</i>  <i>Durch die Analyse des Berichts k√∂nnen Sie F√§lle von ineffizienter RAM-Nutzung in der Anwendung identifizieren.</i>  <i>Dazu geh√∂ren "Speicherlecks", wenn die angeforderten Speicherressourcen nicht freigegeben werden und von der Anwendung nicht beansprucht werden, Fragmentierung, wenn die Gr√∂√üe kontaminierter und freigegebener zusammenh√§ngender Speicherabschnitte nicht ausreicht, um neue Anforderungen zu erf√ºllen, was zur Zuweisung zus√§tzlicher Ressourcen f√ºhrt.</i> <i><br><br></i>  <i>Das integrierte Speichersteuerungswerkzeug kann ein- oder ausgeschaltet sein (zum Registrieren von Speicheranforderungen), und die M√∂glichkeit der programmierten Zustandsumschaltung erm√∂glicht es Ihnen, die f√ºr die zugewiesenen Speicherressourcen empfangene Datenmenge zu steuern und zu optimieren.</i> <i><br></i> <a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Ein erheblicher Teil der modernen Softwaresysteme wird unter Verwendung der Programmiersprachen <i>C #, Java</i> und dergleichen entwickelt, wobei die Verwaltung der RAM-Ressourcen auf Systemebene erfolgt, wobei die Verantwortung der Softwareentwickler minimiert wird.  Ein Beispiel f√ºr solche Softwaresysteme ist das <b><i>durchg√§ngige</i></b> automatisierte computergest√ºtzte Entwurfssystem <b><i>Delta Design</i></b> , das in <i>C #</i> in einer <i>.net-</i> Umgebung implementiert ist.  Andererseits haben die Softwaretools des Automatisierungssystems eine ziemlich lange ‚ÄûLebensdauer‚Äú (bis zu mehreren zehn Jahren), was dazu f√ºhrt, dass ‚Äûveraltete‚Äú RAM-Speicherverwaltungstechnologien beibehalten werden m√ºssen, insbesondere wenn die beiden genannten Systemklassen in ein gemeinsames Steuerungsschema integriert werden. <br><br>  Aus diesem Grund besteht das dringende Problem bei der Erstellung, Entwicklung und Wartung funktional komplexer Softwareanwendungen bislang darin, die Verwaltung der darin enthaltenen RAM-Ressourcen zu optimieren.  Neben effizienten Methoden (Smart Pointer, Garbage Collectors) wird weiterhin Software verwendet, die Anforderungen f√ºr Speicherressourcen √ºber Aufrufe <i>malloc, calloc, realloc, free</i> ausf√ºhrt <i>.</i> <br>  Dieser Ansatz bietet Entwicklern die volle Kontrolle √ºber die Verwaltung des Arbeitsspeichers in der Anwendung und √ºbertr√§gt ihr gleichzeitig ein hohes Ma√ü an Verantwortung f√ºr die rechtzeitige Freigabe dieser Ressourcen, um "Lecks" zu vermeiden. <br><br>  In der Anfangsphase der Softwareentwicklung hat die Ermittlung der Fakten zur ineffizienten Nutzung von Speicherressourcen in der Regel keine Priorit√§t, da die Struktur der Anwendung recht transparent ist.  Es treten jedoch Probleme auf, wenn verschiedene strukturelle und funktionale Komponenten des Systems in komplexe Schemata der verteilten Steuerung von RAM-Ressourcen und des Informationsaustauschs zwischen ihnen integriert werden.  Der Generationswechsel von Systementwicklern wirkt sich auch auf die L√∂sung von Problemen bei der Optimierung der Verwaltung von RAM-Ressourcen aus.  Infolgedessen erscheinen die folgenden negativen Eigenschaften in der Anwendung: <br><br><ul><li>  Es besteht eine erhebliche L√ºcke zwischen der tats√§chlichen Gr√∂√üe des verbrauchten Arbeitsspeichers und den Sch√§tzungen der Entwickler. </li><li>  W√§hrend der Anwendungsausf√ºhrung steigt der verwendete dynamische Speicher linear an. </li></ul><br>  Die Gr√ºnde f√ºr die ineffiziente Verwendung von RAM in der Anwendung sind verschiedene Faktoren, die sich aus den folgenden elementaren Ereignissen zusammensetzen: <br><br><ul><li>  Nicht√ºbereinstimmung von Anforderungen f√ºr die Platzierung und Freigabe von RAM ("Leck"); </li><li>  Geringe Wiederverwendung freigegebener RAM-Bereiche, was zu Anfragen nach neuen Bereichen f√ºhrt (Fragmentierung). </li></ul><br>  Die Praxis der Entwicklung und Wartung von Softwareanwendungen mit einer komplexen Architektur und entwickelten Funktionen zeigt, dass die Kontrolle √ºber die Verwendung der darin enthaltenen RAM-Ressourcen so fr√ºh wie m√∂glich begonnen werden sollte, um die Kontrolle √ºber diesen Prozess zu behalten.  Sie k√∂nnen die Speicherressourcen der Anwendung steuern, indem Sie geeignete Softwareprodukte (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><i>valgrind</i></b></a> ) erwerben und verwenden oder Mittel zum Abfangen und Registrieren von Anforderungen f√ºr RAM-Ressourcen im Anwendungsprogrammcode implementieren und einbetten. <br><br>  Nachfolgend finden Sie ein Beispiel f√ºr eine der m√∂glichen Implementierungen dieses Ansatzes. <br><br><h3>  Embedded Control Software </h3><br>  Die Basis der vorgestellten L√∂sung ist das Abfangen mittels der eingebauten Steuerung aller Anforderungen an die RAM-Ressourcen, die die Anwendung w√§hrend ihrer Ausf√ºhrung an das Betriebssystem sendet.  Die gesamte Vielfalt solcher Abfragen wird durch Aufrufe von <i>malloc (), realloc ()</i> oder <i>free ()</i> implementiert.  Ein Beispiel f√ºr eine Folge von Ereignissen bei der Verarbeitung einer Anforderung zum Zuweisen von malloc () RAM, wenn die integrierten Steuerelemente aus- und eingeschaltet werden, ist in der folgenden Abbildung dargestellt (√§hnliche Diagramme k√∂nnen f√ºr <i>realloc () -</i> oder <i>free ()</i> -Aufrufe erstellt werden).  Das Band " <b>A</b> " enth√§lt eine Folge von Ereignissen w√§hrend der Zuweisung von Speicher, die im ausgeschalteten Zustand des eingebauten Steuermodus auftreten.  Die Anwendung sendet eine Anforderung an das Betriebssystem, um die erforderliche Speichergr√∂√üe zuzuweisen, und empf√§ngt einen Zeiger auf die Startadresse des ausgew√§hlten Fragments.  Wenn die angeforderte Speichergr√∂√üe nicht verf√ºgbar ist, wird ein Zeiger mit einer Nulladresse zur√ºckgegeben, der von der anfordernden Anwendung entsprechend behandelt werden sollte. <br><br><img src="https://habrastorage.org/webt/cy/xx/j0/cyxxj0fffcok3htqqilut1v97mm.jpeg"><br><br>  Das Band ‚Äû <b>B</b> ‚Äú enth√§lt eine Folge von Ereignissen beim Zuweisen von Speicher, die auftreten, wenn der integrierte Steuermodus aktiviert ist.  Diese Sequenz stimmt vollst√§ndig mit der zuvor beschriebenen √ºberein, mit der Ausnahme, dass nach dem Zuweisen des angeforderten Speichers die Steuerung an die Funktion register_request () √ºbergeben wird, die Informationen √ºber die Adresse und Gr√∂√üe des zugewiesenen Speichers gem√§√ü der gestellten Anforderung speichert. <br><br>  Das Abfangen und Registrieren von Anforderungen an RAM-Ressourcen erfolgt durch das memSupervisor-Objekt, das in einer einzelnen Instanz durch Aufrufen von init_memSupervisor () erstellt wird und dann √ºber Aufrufe von enable_memSupervisor () bzw. disable_ memSupervisor () ein- oder ausgeschaltet werden kann. <br>  Die Technik zum Abfangen von Anforderungen f√ºr RAM-Ressourcen basiert auf der Verwendung statischer Variablen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><i>GNU-Bibliothek,</i></b></a> wie in den folgenden Codefragmenten gezeigt. <br><br><img src="https://habrastorage.org/webt/en/st/or/enstorymb_mjykcnzbgqxsm3-vu.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/nj/dx/8ynjdx8cksaikaajfmreemkfwfg.jpeg"><br><br>  Alle verarbeiteten Anforderungen f√ºr RAM-Ressourcen werden in einer speziellen Datensatztabelle registriert, deren Inhalt im Attribut memSupervisor.memRegister gespeichert ist.  Jeder Eintrag enth√§lt folgende Informationen: <br><br><img src="https://habrastorage.org/webt/jl/4n/rx/jl4nrxvw_frtmywye0gyn087tkg.jpeg"><br><br>  Jeder Datensatz in der Tabelle ist einem Kontrollpunkt des Programmcodes zugeordnet, nach dessen Durchlauf der Speicher zugewiesen und die Anforderung registriert wird. <br><br>  Der <i>Textberichtsgenerator</i> ( <i>memSupervisor.genReport (Dateiname)</i> ) generiert einen Bericht unter Verwendung der Tabellendaten und schreibt Informationen in die angegebene Textdatei (oder gibt sie an die Anwendungskonsole aus).  Durch Herunterladen der Berichtsdaten in die MS Excel-Tabelle und die entsprechende Einstellung der letzteren erhalten Sie eine grafische Darstellung der Berichtsdaten zur Verwendung von RAM-Ressourcen. <br><br><h3>  Schnittstelle zu eingebauten Steuerelementen </h3><br>  Die Erfassung von Informationen zu Anwendungsanforderungen f√ºr RAM-Ressourcen kann implementiert werden, indem Makros kompiliert und in den Quellcode der Anwendung eingef√ºgt werden, die nur kompiliert werden, wenn die entsprechende Umgebungsvariable festgelegt ist. <br><br><img src="https://habrastorage.org/webt/nb/6c/ie/nb6ciegyancwouzp4dpof6xze60.jpeg"><br><br>  Im Folgenden finden Sie einen Programmcode, der die Verwendung integrierter Steuerelemente demonstriert. <br><br><img src="https://habrastorage.org/webt/sm/rr/yf/smrryftloedlfg34d8xk5prxmdq.jpeg"><br><br><img src="https://habrastorage.org/webt/17/mi/gx/17migxgt1yry9lfuzsgv_w3aqzg.jpeg"><br><br><img src="https://habrastorage.org/webt/7o/b_/4u/7ob_4upu0l2-we8lgy7cmrh7-la.jpeg"><br><br>  Das Folgende ist eine Darstellung der Anwendung der beschriebenen Mittel zur integrierten Steuerung der RAM-Ressourcen, die von der <i>"foo"</i> -Anwendung angefordert werden, die eine automatische Verfolgung von Verbindungen auf Leiterplatten durchf√ºhrt.  F√ºr die Analyse wurde ein ausreichend klares und bequemes Modell des M√§anders ausgew√§hlt, das die Abmessungen des dynamischen Direktzugriffsspeichers anzeigt, der von der Anwendung beim Verlegen der Verbindungen auf der Leiterplatte angefordert wird. <br><br><img src="https://habrastorage.org/webt/av/nk/eq/avnkeqdztb8c3qvdsrxu4jbsmjc.jpeg"><br><br>  Dieses Modell hilft bei der Identifizierung der folgenden Probleme bei der Verwaltung von RAM-Ressourcen: <br><br><ul><li>  an den Punkten <b><i>"A"</i></b> und <b><i>"D"</i></b> sollte ungef√§hr die gleiche Gr√∂√üe des verwendeten RAM sein </li><li>  Die Vergr√∂√üerung des angeforderten Speichers in der Phase der Verbindungsverlegung sollte reibungslos sein.  Falls erforderlich, sollten die Hauptschritte dieser Stufe durch Setzen von Haltepunkten in den entsprechenden Codefragmenten gesteuert werden.  Das erzwungene L√∂schen aller Daten auf verlegten Verbindungen sollte an den Punkten <b><i>"B"</i></b> und <b><i>"C"</i></b> zu der gleichen Gr√∂√üe des verbrauchten Speichers f√ºhren. </li></ul><br>  Das folgende Diagramm zeigt die Speicherverwaltungsprobleme in der genannten <i>'foo'-</i> Anwendung. <br><br><img src="https://habrastorage.org/webt/ks/nb/s8/ksnbs8r9h4d9ndyk6gi8nmcoafi.jpeg"><br><br><h3>  Kurze Schlussfolgerungen </h3><br>  Das beschriebene Mittel zur integrierten Steuerung von RAM-Ressourcen kann in F√§llen verwendet werden, in denen die entsprechenden Softwareprodukte nicht verf√ºgbar sind und aus irgendeinem Grund nicht anwendbar sind. <br><br><ul><li>  Eingebaute Steuerungswerkzeuge registrieren und sammeln Informationen √ºber die Ressourcen des angeforderten Speichers mit jedem Grad an Genauigkeit und Detailgenauigkeit. </li><li>  Durch die M√∂glichkeit, integrierte Steuerelemente zwischen aktivem und inaktivem Modus umzuschalten, k√∂nnen Sie sie so konfigurieren, dass Daten in ausgew√§hlten Fragmenten des Anwendungsprogrammcodes extrahiert und analysiert werden. </li><li>  Integrierte Steuerelemente erm√∂glichen den vollst√§ndigen Ausschluss aus der Anwendung, wenn diese zusammengesetzt werden, ohne dass der entsprechende Kompilierungsparameter festgelegt wird. </li><li>  Die Implementierung einer Programmanalyse des Inhalts von Berichten √ºber die Anwendung von RAM-Ressourcen, die w√§hrend der Anwendungsausf√ºhrung verwendet werden, und die √úberpr√ºfung dieser Berichte anhand von Referenzkopien erm√∂glicht die Entwicklung von Regressionstestverfahren f√ºr Anwendungen, um eine Verschlechterung der RAM-Nutzung festzustellen. </li><li>  Der Programmcode dieser Art von integrierter RAM-Steuerung ist offen, um seine F√§higkeiten zu erweitern und sich an die besonderen Verwendungsbedingungen anzupassen. </li><li>  Der Hauptnachteil der beschriebenen Tools ist die Notwendigkeit, den eingebauten Speichersteuercode in den Code der √ºberwachten Anwendung aufzunehmen. </li></ul><br>  Zusammenfassend ist anzumerken, dass der beschriebene Ansatz zur Implementierung der integrierten Steuerung von RAM-Ressourcen in Softwareanwendungen keine radikal neuen L√∂sungen enth√§lt.  Der Nutzen des Ansatzes liegt in der Einfachheit der Implementierung und der relativ hohen Effizienz der praktischen Anwendung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464919/">https://habr.com/ru/post/de464919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464901/index.html">Helpdesk-Entwicklung</a></li>
<li><a href="../de464909/index.html">"Sie beobachten uns": Was kann in einem unauff√§lligen Minivan direkt unter Ihrem Fenster passieren?</a></li>
<li><a href="../de464913/index.html">"Know kaizen": Was ist diese Philosophie zur Verbesserung der Produktionsprozesse?</a></li>
<li><a href="../de464915/index.html">Optimierung der JavaScript-Schwanzrekursion</a></li>
<li><a href="../de464917/index.html">Nach dem Cyberpunk: Was Sie √ºber aktuelle Genres der modernen Science-Fiction wissen m√ºssen</a></li>
<li><a href="../de464921/index.html">System.IO.Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterst√ºtzung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, √úberpr√ºfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464931/index.html">Assembler-Einf√ºgungen ... in C #?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>