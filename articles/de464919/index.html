<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💓 🆒 🛒 Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung 🏳️ 👨🏾‍🚀 🧘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung 

 Beschreibt ein relativ einfaches Software-Implementierungstool zur Steuerung d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464919/"><h1>  Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung </h1><br><img src="https://habrastorage.org/webt/ez/cg/lk/ezcglkhvp9ztri9vr5euj3-wwoa.jpeg" width="300" align="right"><br>  <i>Beschreibt ein relativ einfaches Software-Implementierungstool zur Steuerung der verwendeten RAM-Ressourcen während der Anwendungsausführung.</i>  <i>Die Basis der Implementierung ist das Abfangen und Registrieren von Anforderungen für die Zuweisung, Freigabe und Wiederverwendung von Speicherressourcen, die von der Anwendung über die Aufrufe <i>malloc (), calloc (), realloc (), free ()</i> an das Betriebssystem gesendet werden.</i>  <i>Alle Speicheranforderungen werden in einem speziellen Protokoll aufgezeichnet und am Ende der Anwendung werden die gesammelten Informationen in Form eines Berichts auf der Konsole angezeigt oder in eine Textdatei geschrieben.</i>  <i>Durch die Analyse des Berichts können Sie Fälle von ineffizienter RAM-Nutzung in der Anwendung identifizieren.</i>  <i>Dazu gehören "Speicherlecks", wenn die angeforderten Speicherressourcen nicht freigegeben werden und von der Anwendung nicht beansprucht werden, Fragmentierung, wenn die Größe kontaminierter und freigegebener zusammenhängender Speicherabschnitte nicht ausreicht, um neue Anforderungen zu erfüllen, was zur Zuweisung zusätzlicher Ressourcen führt.</i> <i><br><br></i>  <i>Das integrierte Speichersteuerungswerkzeug kann ein- oder ausgeschaltet sein (zum Registrieren von Speicheranforderungen), und die Möglichkeit der programmierten Zustandsumschaltung ermöglicht es Ihnen, die für die zugewiesenen Speicherressourcen empfangene Datenmenge zu steuern und zu optimieren.</i> <i><br></i> <a name="habracut"></a><br><h3>  Einführung </h3><br>  Ein erheblicher Teil der modernen Softwaresysteme wird unter Verwendung der Programmiersprachen <i>C #, Java</i> und dergleichen entwickelt, wobei die Verwaltung der RAM-Ressourcen auf Systemebene erfolgt, wobei die Verantwortung der Softwareentwickler minimiert wird.  Ein Beispiel für solche Softwaresysteme ist das <b><i>durchgängige</i></b> automatisierte computergestützte Entwurfssystem <b><i>Delta Design</i></b> , das in <i>C #</i> in einer <i>.net-</i> Umgebung implementiert ist.  Andererseits haben die Softwaretools des Automatisierungssystems eine ziemlich lange „Lebensdauer“ (bis zu mehreren zehn Jahren), was dazu führt, dass „veraltete“ RAM-Speicherverwaltungstechnologien beibehalten werden müssen, insbesondere wenn die beiden genannten Systemklassen in ein gemeinsames Steuerungsschema integriert werden. <br><br>  Aus diesem Grund besteht das dringende Problem bei der Erstellung, Entwicklung und Wartung funktional komplexer Softwareanwendungen bislang darin, die Verwaltung der darin enthaltenen RAM-Ressourcen zu optimieren.  Neben effizienten Methoden (Smart Pointer, Garbage Collectors) wird weiterhin Software verwendet, die Anforderungen für Speicherressourcen über Aufrufe <i>malloc, calloc, realloc, free</i> ausführt <i>.</i> <br>  Dieser Ansatz bietet Entwicklern die volle Kontrolle über die Verwaltung des Arbeitsspeichers in der Anwendung und überträgt ihr gleichzeitig ein hohes Maß an Verantwortung für die rechtzeitige Freigabe dieser Ressourcen, um "Lecks" zu vermeiden. <br><br>  In der Anfangsphase der Softwareentwicklung hat die Ermittlung der Fakten zur ineffizienten Nutzung von Speicherressourcen in der Regel keine Priorität, da die Struktur der Anwendung recht transparent ist.  Es treten jedoch Probleme auf, wenn verschiedene strukturelle und funktionale Komponenten des Systems in komplexe Schemata der verteilten Steuerung von RAM-Ressourcen und des Informationsaustauschs zwischen ihnen integriert werden.  Der Generationswechsel von Systementwicklern wirkt sich auch auf die Lösung von Problemen bei der Optimierung der Verwaltung von RAM-Ressourcen aus.  Infolgedessen erscheinen die folgenden negativen Eigenschaften in der Anwendung: <br><br><ul><li>  Es besteht eine erhebliche Lücke zwischen der tatsächlichen Größe des verbrauchten Arbeitsspeichers und den Schätzungen der Entwickler. </li><li>  Während der Anwendungsausführung steigt der verwendete dynamische Speicher linear an. </li></ul><br>  Die Gründe für die ineffiziente Verwendung von RAM in der Anwendung sind verschiedene Faktoren, die sich aus den folgenden elementaren Ereignissen zusammensetzen: <br><br><ul><li>  Nichtübereinstimmung von Anforderungen für die Platzierung und Freigabe von RAM ("Leck"); </li><li>  Geringe Wiederverwendung freigegebener RAM-Bereiche, was zu Anfragen nach neuen Bereichen führt (Fragmentierung). </li></ul><br>  Die Praxis der Entwicklung und Wartung von Softwareanwendungen mit einer komplexen Architektur und entwickelten Funktionen zeigt, dass die Kontrolle über die Verwendung der darin enthaltenen RAM-Ressourcen so früh wie möglich begonnen werden sollte, um die Kontrolle über diesen Prozess zu behalten.  Sie können die Speicherressourcen der Anwendung steuern, indem Sie geeignete Softwareprodukte (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><i>valgrind</i></b></a> ) erwerben und verwenden oder Mittel zum Abfangen und Registrieren von Anforderungen für RAM-Ressourcen im Anwendungsprogrammcode implementieren und einbetten. <br><br>  Nachfolgend finden Sie ein Beispiel für eine der möglichen Implementierungen dieses Ansatzes. <br><br><h3>  Embedded Control Software </h3><br>  Die Basis der vorgestellten Lösung ist das Abfangen mittels der eingebauten Steuerung aller Anforderungen an die RAM-Ressourcen, die die Anwendung während ihrer Ausführung an das Betriebssystem sendet.  Die gesamte Vielfalt solcher Abfragen wird durch Aufrufe von <i>malloc (), realloc ()</i> oder <i>free ()</i> implementiert.  Ein Beispiel für eine Folge von Ereignissen bei der Verarbeitung einer Anforderung zum Zuweisen von malloc () RAM, wenn die integrierten Steuerelemente aus- und eingeschaltet werden, ist in der folgenden Abbildung dargestellt (ähnliche Diagramme können für <i>realloc () -</i> oder <i>free ()</i> -Aufrufe erstellt werden).  Das Band " <b>A</b> " enthält eine Folge von Ereignissen während der Zuweisung von Speicher, die im ausgeschalteten Zustand des eingebauten Steuermodus auftreten.  Die Anwendung sendet eine Anforderung an das Betriebssystem, um die erforderliche Speichergröße zuzuweisen, und empfängt einen Zeiger auf die Startadresse des ausgewählten Fragments.  Wenn die angeforderte Speichergröße nicht verfügbar ist, wird ein Zeiger mit einer Nulladresse zurückgegeben, der von der anfordernden Anwendung entsprechend behandelt werden sollte. <br><br><img src="https://habrastorage.org/webt/cy/xx/j0/cyxxj0fffcok3htqqilut1v97mm.jpeg"><br><br>  Das Band „ <b>B</b> “ enthält eine Folge von Ereignissen beim Zuweisen von Speicher, die auftreten, wenn der integrierte Steuermodus aktiviert ist.  Diese Sequenz stimmt vollständig mit der zuvor beschriebenen überein, mit der Ausnahme, dass nach dem Zuweisen des angeforderten Speichers die Steuerung an die Funktion register_request () übergeben wird, die Informationen über die Adresse und Größe des zugewiesenen Speichers gemäß der gestellten Anforderung speichert. <br><br>  Das Abfangen und Registrieren von Anforderungen an RAM-Ressourcen erfolgt durch das memSupervisor-Objekt, das in einer einzelnen Instanz durch Aufrufen von init_memSupervisor () erstellt wird und dann über Aufrufe von enable_memSupervisor () bzw. disable_ memSupervisor () ein- oder ausgeschaltet werden kann. <br>  Die Technik zum Abfangen von Anforderungen für RAM-Ressourcen basiert auf der Verwendung statischer Variablen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><i>GNU-Bibliothek,</i></b></a> wie in den folgenden Codefragmenten gezeigt. <br><br><img src="https://habrastorage.org/webt/en/st/or/enstorymb_mjykcnzbgqxsm3-vu.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/nj/dx/8ynjdx8cksaikaajfmreemkfwfg.jpeg"><br><br>  Alle verarbeiteten Anforderungen für RAM-Ressourcen werden in einer speziellen Datensatztabelle registriert, deren Inhalt im Attribut memSupervisor.memRegister gespeichert ist.  Jeder Eintrag enthält folgende Informationen: <br><br><img src="https://habrastorage.org/webt/jl/4n/rx/jl4nrxvw_frtmywye0gyn087tkg.jpeg"><br><br>  Jeder Datensatz in der Tabelle ist einem Kontrollpunkt des Programmcodes zugeordnet, nach dessen Durchlauf der Speicher zugewiesen und die Anforderung registriert wird. <br><br>  Der <i>Textberichtsgenerator</i> ( <i>memSupervisor.genReport (Dateiname)</i> ) generiert einen Bericht unter Verwendung der Tabellendaten und schreibt Informationen in die angegebene Textdatei (oder gibt sie an die Anwendungskonsole aus).  Durch Herunterladen der Berichtsdaten in die MS Excel-Tabelle und die entsprechende Einstellung der letzteren erhalten Sie eine grafische Darstellung der Berichtsdaten zur Verwendung von RAM-Ressourcen. <br><br><h3>  Schnittstelle zu eingebauten Steuerelementen </h3><br>  Die Erfassung von Informationen zu Anwendungsanforderungen für RAM-Ressourcen kann implementiert werden, indem Makros kompiliert und in den Quellcode der Anwendung eingefügt werden, die nur kompiliert werden, wenn die entsprechende Umgebungsvariable festgelegt ist. <br><br><img src="https://habrastorage.org/webt/nb/6c/ie/nb6ciegyancwouzp4dpof6xze60.jpeg"><br><br>  Im Folgenden finden Sie einen Programmcode, der die Verwendung integrierter Steuerelemente demonstriert. <br><br><img src="https://habrastorage.org/webt/sm/rr/yf/smrryftloedlfg34d8xk5prxmdq.jpeg"><br><br><img src="https://habrastorage.org/webt/17/mi/gx/17migxgt1yry9lfuzsgv_w3aqzg.jpeg"><br><br><img src="https://habrastorage.org/webt/7o/b_/4u/7ob_4upu0l2-we8lgy7cmrh7-la.jpeg"><br><br>  Das Folgende ist eine Darstellung der Anwendung der beschriebenen Mittel zur integrierten Steuerung der RAM-Ressourcen, die von der <i>"foo"</i> -Anwendung angefordert werden, die eine automatische Verfolgung von Verbindungen auf Leiterplatten durchführt.  Für die Analyse wurde ein ausreichend klares und bequemes Modell des Mäanders ausgewählt, das die Abmessungen des dynamischen Direktzugriffsspeichers anzeigt, der von der Anwendung beim Verlegen der Verbindungen auf der Leiterplatte angefordert wird. <br><br><img src="https://habrastorage.org/webt/av/nk/eq/avnkeqdztb8c3qvdsrxu4jbsmjc.jpeg"><br><br>  Dieses Modell hilft bei der Identifizierung der folgenden Probleme bei der Verwaltung von RAM-Ressourcen: <br><br><ul><li>  an den Punkten <b><i>"A"</i></b> und <b><i>"D"</i></b> sollte ungefähr die gleiche Größe des verwendeten RAM sein </li><li>  Die Vergrößerung des angeforderten Speichers in der Phase der Verbindungsverlegung sollte reibungslos sein.  Falls erforderlich, sollten die Hauptschritte dieser Stufe durch Setzen von Haltepunkten in den entsprechenden Codefragmenten gesteuert werden.  Das erzwungene Löschen aller Daten auf verlegten Verbindungen sollte an den Punkten <b><i>"B"</i></b> und <b><i>"C"</i></b> zu der gleichen Größe des verbrauchten Speichers führen. </li></ul><br>  Das folgende Diagramm zeigt die Speicherverwaltungsprobleme in der genannten <i>'foo'-</i> Anwendung. <br><br><img src="https://habrastorage.org/webt/ks/nb/s8/ksnbs8r9h4d9ndyk6gi8nmcoafi.jpeg"><br><br><h3>  Kurze Schlussfolgerungen </h3><br>  Das beschriebene Mittel zur integrierten Steuerung von RAM-Ressourcen kann in Fällen verwendet werden, in denen die entsprechenden Softwareprodukte nicht verfügbar sind und aus irgendeinem Grund nicht anwendbar sind. <br><br><ul><li>  Eingebaute Steuerungswerkzeuge registrieren und sammeln Informationen über die Ressourcen des angeforderten Speichers mit jedem Grad an Genauigkeit und Detailgenauigkeit. </li><li>  Durch die Möglichkeit, integrierte Steuerelemente zwischen aktivem und inaktivem Modus umzuschalten, können Sie sie so konfigurieren, dass Daten in ausgewählten Fragmenten des Anwendungsprogrammcodes extrahiert und analysiert werden. </li><li>  Integrierte Steuerelemente ermöglichen den vollständigen Ausschluss aus der Anwendung, wenn diese zusammengesetzt werden, ohne dass der entsprechende Kompilierungsparameter festgelegt wird. </li><li>  Die Implementierung einer Programmanalyse des Inhalts von Berichten über die Anwendung von RAM-Ressourcen, die während der Anwendungsausführung verwendet werden, und die Überprüfung dieser Berichte anhand von Referenzkopien ermöglicht die Entwicklung von Regressionstestverfahren für Anwendungen, um eine Verschlechterung der RAM-Nutzung festzustellen. </li><li>  Der Programmcode dieser Art von integrierter RAM-Steuerung ist offen, um seine Fähigkeiten zu erweitern und sich an die besonderen Verwendungsbedingungen anzupassen. </li><li>  Der Hauptnachteil der beschriebenen Tools ist die Notwendigkeit, den eingebauten Speichersteuercode in den Code der überwachten Anwendung aufzunehmen. </li></ul><br>  Zusammenfassend ist anzumerken, dass der beschriebene Ansatz zur Implementierung der integrierten Steuerung von RAM-Ressourcen in Softwareanwendungen keine radikal neuen Lösungen enthält.  Der Nutzen des Ansatzes liegt in der Einfachheit der Implementierung und der relativ hohen Effizienz der praktischen Anwendung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464919/">https://habr.com/ru/post/de464919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464901/index.html">Helpdesk-Entwicklung</a></li>
<li><a href="../de464909/index.html">"Sie beobachten uns": Was kann in einem unauffälligen Minivan direkt unter Ihrem Fenster passieren?</a></li>
<li><a href="../de464913/index.html">"Know kaizen": Was ist diese Philosophie zur Verbesserung der Produktionsprozesse?</a></li>
<li><a href="../de464915/index.html">Optimierung der JavaScript-Schwanzrekursion</a></li>
<li><a href="../de464917/index.html">Nach dem Cyberpunk: Was Sie über aktuelle Genres der modernen Science-Fiction wissen müssen</a></li>
<li><a href="../de464921/index.html">System.IO.Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterstützung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, Überprüfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464931/index.html">Assembler-Einfügungen ... in C #?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>