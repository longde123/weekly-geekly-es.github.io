<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚒️ 🏧 💓 Bien, mal, mal: pruebas en un proyecto para principiantes 🎈 🚑 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefacio: la universidad recibió una tarea: reunir un equipo scrum, seleccionar un proyecto y trabajar en él durante un semestre. Nuestro equipo eligi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bien, mal, mal: pruebas en un proyecto para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450290/"><p>  <strong>Prefacio:</strong> la universidad recibió una tarea: reunir un equipo scrum, seleccionar un proyecto y trabajar en él durante un semestre.  Nuestro equipo eligió el desarrollo de aplicaciones web (reaccionar + matraz).  En este artículo trataré de decirle qué pruebas deberían haber sido y analizar lo que hicimos en el backend. </p><br><p><img src="https://habrastorage.org/webt/fb/z-/yc/fbz-ycgf0ewrp0logvj9mrosebi.png"></p><a name="habracut"></a><br><h1 id="ozhidaniya">  Las expectativas </h1><br><p>  Las pruebas son necesarias, en primer lugar, para convencer a todos (incluidos nosotros mismos) de que el programa se comporta como debería <em>en situaciones de prueba</em> .  En segundo lugar, aseguran el rendimiento <em>del</em> código <em>cubierto por las pruebas</em> en el futuro.  Escribir pruebas es un proceso útil, porque en su proceso a menudo puede tropezar con áreas problemáticas, recordar algunos casos extremos, ver problemas con las interfaces, etc. </p><br><p> Al desarrollar cualquier sistema, debe recordar al menos tres tipos de pruebas: </p><br><ul><li>  <em>Las pruebas unitarias</em> son pruebas que verifican que las funciones hacen lo que necesitan. </li><li>  <em>Las pruebas de integración</em> son pruebas que verifican que varias funciones juntas hacen lo correcto. </li><li>  <em>Las pruebas del sistema</em> son pruebas que verifican que todo el sistema hace lo que necesita. </li></ul><br><p>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una de las publicaciones</a> de google, se publicó una tabla con una descripción de tres tipos de pruebas.  "Pequeño", "Medio" y "Grande". </p><br><p><img src="https://habrastorage.org/webt/sy/ho/zj/syhozj8ytslkmlaxxnockcwv3b4.png"></p><br><h2 id="modulnye-testy">  Pruebas unitarias </h2><br><p>  Las pruebas unitarias corresponden a pruebas pequeñas: deben ser rápidas y solo verificar la corrección de partes específicas del programa.  No deberían acceder a la base de datos, no deberían funcionar en entornos complejos de subprocesos múltiples.  Controlan el cumplimiento de las especificaciones / estándares, a menudo tienen el papel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regresión</a> . </p><br><h2 id="integracionnye-testy">  Pruebas de integración </h2><br><p>  Las pruebas de integración son aquellas que pueden afectar varios módulos y funciones.  Dichas pruebas requieren más tiempo y pueden requerir entornos especiales.  Son necesarios para asegurarse de que los módulos y las funciones individuales puedan funcionar entre sí.  Es decir  las pruebas unitarias verifican la conformidad de las interfaces reales con las esperadas, y las pruebas de integración, que las funciones y los módulos interactúan correctamente entre sí. </p><br><h2 id="sistemnye-testy">  Pruebas del sistema </h2><br><p>  Este es el nivel más alto de pruebas automáticas.  Las pruebas del sistema verifican que todo el sistema funciona, que sus partes realizan sus tareas y pueden interactuar correctamente. </p><br><h2 id="zachem-sledit-za-tipami">  ¿Por qué hacer un seguimiento de los tipos? </h2><br><p>  Por lo general, con el crecimiento del proyecto, la base del código también crecerá.  La duración de las verificaciones automáticas aumentará; admitir una gran cantidad de pruebas de integración y del sistema será cada vez más difícil.  Por lo tanto, el desafío para los desarrolladores es minimizar las pruebas necesarias.  Para hacer esto, intente usar pruebas unitarias cuando sea posible y reduzca la integración usando "simulacros" (simulacros). </p><br><h1 id="realnost">  Realidad </h1><br><h2 id="tipichnyy-test-api">  Prueba típica de API </h2><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_user_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.loads( client.post(url, json=data, content_type=<span class="hljs-string"><span class="hljs-string">'application/json'</span></span>).data ) response = client.post(<span class="hljs-string"><span class="hljs-string">'api/user.reg'</span></span>, json={ <span class="hljs-string"><span class="hljs-string">'email'</span></span>: <span class="hljs-string"><span class="hljs-string">'name@mail.ru'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>: <span class="hljs-string"><span class="hljs-string">'password1'</span></span>, <span class="hljs-string"><span class="hljs-string">'first_name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Name'</span></span>, <span class="hljs-string"><span class="hljs-string">'last_name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Last Name'</span></span> }) data = json.loads(response.data) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data[<span class="hljs-string"><span class="hljs-string">'code'</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  De la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial del matraz,</a> obtenemos una receta preparada para inicializar la aplicación y crear la base de datos.  Aquí está el trabajo con la base de datos.  Esta no es una prueba unitaria, pero no es una prueba del sistema.  Esta es una prueba de integración que utiliza una aplicación de prueba de base de datos. </p><br><p>  ¿Por qué integración en lugar de modular?  Porque en el procesamiento de consultas, la interacción se realiza con el matraz, con ORM, con nuestra lógica de negocios.  Los controladores actúan como un enlace unificador de otras partes del proyecto, por lo que escribir pruebas unitarias para ellos no es demasiado fácil (necesita reemplazar la base de datos con simulacros, lógica interna) y no es demasiado práctico (las pruebas de integración verifican aspectos similares: "¿se llamaron las funciones necesarias?", " ¿Se recibieron correctamente los datos? ", Etc.). </p><br><h2 id="nazvaniya-i-gruppirovka-testov">  Nombres y agrupación de pruebas. </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_not_empty_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_not_empty(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_not_empty(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_email_format(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_password_format(<span class="hljs-string"><span class="hljs-string">'pass'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'pass is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is empty'</span></span>,)</code> </pre> <br><p>  En esta prueba, se cumplen todas las condiciones para las pruebas "pequeñas": se verifica que el comportamiento de la función sin dependencias cumpla con lo esperado.  Pero el diseño plantea preguntas. </p><br><p>  Es una buena práctica escribir pruebas que se centren en un aspecto específico del programa.  En este ejemplo, hay diferentes funciones: <code>validate_password_format</code> , <code>validate_password_format</code> , <code>validate_datetime</code> .  Las comprobaciones de agrupamiento no se basan en el resultado, sino en los objetos de prueba. </p><br><p>  El nombre de la prueba ( <code>test_not_empty_errors</code> ) no describe el objeto de prueba (qué método se está probando), solo describe el resultado (los errores no están vacíos).  Este método debe llamarse <code>test__validate_not_empty__error_on_empty</code> .  Este nombre describe lo que se está probando y qué resultado se espera.  Esto se aplica a casi todos los nombres de prueba en el proyecto debido al hecho de que no se tomó tiempo para discutir las convenciones de nombres de prueba. </p><br><h2 id="regressionnye-testy">  Pruebas de regresión </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_datetime_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'0123-24-31T;431'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-10-18T20:21:21+-23:1'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-13-20T20:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-02-29T20:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T25:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:61:20+22:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:61+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:20+25:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:20+20:61'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-13-35T25:61:61+61:61'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,)</code> </pre> <br><p>  Esta prueba originalmente consistió en las dos primeras <code>assert</code> .  Después de eso, se descubrió un "error": en lugar de verificar la fecha, solo se verificó la expresión regular, es decir  <code>9999-99-99</code> se consideró una fecha normal.  El desarrollador lo arregló.  Naturalmente, después de corregir el error, debe agregar pruebas para evitar una regresión futura.  En lugar de agregar una nueva prueba en la que escribir <em>por qué</em> existe esta prueba, se agregaron cheques a esta prueba. </p><br><p>  ¿Cómo debería llamarse una nueva prueba para agregar la verificación?  Probablemente <code>test__validate_datetime__error_on_bad_datetime</code> . </p><br><h2 id="ignorirovanie-instrumentov">  Ignorando las herramientas </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_get_providers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tmp</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id_external, token, username)</span></span></span><span class="hljs-function">:</span></span> self.id_external = id_external self.token = token self.username = username ...</code> </pre> <br><p>  <code>Tmp</code> ?  Esta es una sustitución de un objeto que no se usa en esta prueba.  El desarrollador no parece saber sobre la existencia de <code>@patch</code> y <code>MagicMock</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>unittest.mock</code></a> .  No es necesario complicar el código resolviendo problemas ingenuamente cuando hay herramientas más adecuadas. </p><br><p>  Existe una prueba que inicializa los servicios (en la base de datos) y utiliza el contexto de la aplicación. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_get_posts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [one, two] handler = VKServiceHandler() handler.request = fake_request services_init() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> app.app_context(): posts = handler.get_posts(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(posts) == <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><p>  Puede excluir la base de datos y el contexto de la prueba simplemente agregando un <code>@patch</code> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@patch("mobius.services.service_vk.Service") def test_get_posts(mock): def fake_request(*args, **kwargs): return [one, two] handler = VKServiceHandler() handler.request = fake_request posts = handler.get_posts(None) assert len(posts) == 2</span></span></code> </pre> <br><h1 id="itogi">  Resumen </h1><br><ul><li>  Para desarrollar software de calidad, debe escribir pruebas.  Como mínimo, para asegurarse de escribir lo que necesita. </li><li>  Para sistemas de información grandes, las pruebas son aún más importantes: le permiten evitar cambios de interfaz no deseados o errores de retorno. </li><li>  Para que las pruebas escritas no se conviertan en muchos métodos extraños con el tiempo, debe prestar atención a la convención de nomenclatura de las pruebas, cumplir con las buenas prácticas y minimizar las pruebas. </li><li>  Las pruebas unitarias pueden ser una gran herramienta durante el desarrollo.  Se pueden ejecutar después de cada pequeño cambio para asegurarse de que no se rompa nada. </li></ul><br><p>  Un punto muy importante es que las pruebas no garantizan la disponibilidad o ausencia de errores.  Las pruebas aseguran que se espera el resultado real del programa (o parte de él).  En este caso, la verificación solo ocurre para aquellos aspectos para los cuales se escribieron las pruebas.  Por lo tanto, al crear un producto de calidad, no debemos olvidarnos de otros tipos de pruebas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450290/">https://habr.com/ru/post/450290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450272/index.html">Frenesí físico</a></li>
<li><a href="../450274/index.html">IntelliSense para C ++ en Visual Studio ahora funciona en base a ejemplos en su código</a></li>
<li><a href="../450278/index.html">Redes de TV por cable para los más pequeños. Parte 5: Red de distribución coaxial</a></li>
<li><a href="../450282/index.html">Cómo funcionan las aplicaciones web</a></li>
<li><a href="../450288/index.html">UML y Enterprise Architect: diseño del proceso objetivo para crear un sistema automatizado</a></li>
<li><a href="../450292/index.html">Lo nuevo en el nodo 12</a></li>
<li><a href="../450294/index.html">Los venenos mas espantosos</a></li>
<li><a href="../450298/index.html">Futuro Cuántico (continuación)</a></li>
<li><a href="../450300/index.html">Deja de discutir sobre programación funcional y POO</a></li>
<li><a href="../450302/index.html">Tecnología de radioaficionados: prototipo de fabricación de placas de circuito en una fábrica china</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>