<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🍕 🧖🏻 Os dez mandamentos dos componentes de reação 🦎 🍟 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escrito por Kristofer Selbekk , em colaboração com Caroline Odden . Com base em uma palestra com o mesmo nome e com as mesmas pessoas na reunião React...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os dez mandamentos dos componentes de reação</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460559/"><p><img src="https://habrastorage.org/getpro/habr/post_images/adf/1cf/5da/adf1cf5da0c04102046e8b6e8c12322e.jpg" alt="os mandamentos de 10 componentes"></p><br><blockquote>  Escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Kristofer Selbekk</a> , em colaboração com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Caroline Odden</a> .  Com base em uma palestra com o mesmo nome e com as mesmas pessoas na reunião ReactJS em Oslo em junho de 2019. </blockquote><p>  <em>Do tradutor - o nome original de <strong>Os 10 Mandamentos dos Componentes</strong> não menciona React, mas a maioria dos exemplos e recomendações se relaciona especificamente à reação. Além disso, o artigo é apresentado sob a tag react e os desenvolvedores escreveram a reação</em> . </p><br><p>  Não é fácil criar componentes que muitos desenvolvedores usarão.  Você deve considerar cuidadosamente quais objetos usar se esses objetos fizerem parte da API pública. </p><br><p> Neste artigo, faremos uma breve introdução a algumas das melhores práticas para o desenvolvimento da API como um todo, além de formar <strong>dez mandamentos</strong> que você pode usar para criar componentes que seus colegas desenvolvedores terão prazer em usar. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eb9/35b/750/eb935b750f7a08ad9116ecd5a115f81e.jpg" alt="api"></p><br><h2 id="chto-takoe-api">  O que é uma API? </h2><br><p>  Uma API - ou interface de programação de aplicativos - é onde dois pedaços de código se encontram.  Essa é a superfície de contato entre <em>seu código</em> e o resto do mundo.  Chamamos essa superfície de interface.  Este é um conjunto específico de ações ou pontos de dados com os quais você pode interagir. </p><br><p>  A interface entre a classe e o código que chama essa classe também é uma API.  Você pode chamar os métodos da classe para receber dados ou executar as funções incluídas nele. </p><br><p>  Seguindo o mesmo princípio, os <strong>props que seu componente aceita, essa é sua API</strong> .  É assim que os desenvolvedores interagem com seu componente. </p><br><h2 id="nekotorye-luchshie-praktiki-proektirovaniya-api">  Algumas práticas recomendadas de design de API </h2><br><p>  Então, quais regras e considerações se aplicam ao desenvolver uma API?  Bem, fizemos uma pequena pesquisa e constatamos que existem muitos recursos excelentes sobre esse assunto.  Escolhemos dois - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Josh Tauberer</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">"O que faz uma boa API?"</a>  e um artigo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ron Kurir com o mesmo título</a> - e chegou a essas quatro práticas. </p><br><h3 id="stabilnye-versii">  Versões estáveis </h3><br><p>  Uma das coisas mais importantes a considerar ao criar uma API é mantê-la o mais estável possível.  O número de mudanças críticas deve ser mínimo.  Se você precisar fazer alterações críticas, escreva guias de atualização detalhados e, se possível, escreva um código mod que automatize esse processo para os desenvolvedores. </p><br><h3 id="opisatelnye-soobscheniya-ob-oshibkah">  Mensagens de erro descritivas </h3><br><p>  Sempre que ocorrer um erro ao chamar sua API, você deve fazer todo o possível para explicar o que deu errado e como corrigi-lo.  Se você censurar o usuário com mensagens como "uso indevido" e não fornecer nenhuma explicação, sua API deixará uma má impressão. </p><br><p>  Em vez disso, escreva erros descritivos que ajudam o usuário a corrigir como eles usam sua API. </p><br><h3 id="minimizirovat-syurprizy-dlya-razrabotchikov">  Minimize surpresas para desenvolvedores </h3><br><p>  Os desenvolvedores são criaturas frágeis e você não deve assustá-los quando usarem sua API.  Em outras palavras, torne sua API o mais intuitiva possível.  Você conseguirá isso se seguir as práticas recomendadas e as convenções de nomenclatura existentes. </p><br><p> Além disso, seu código deve sempre ser consistente.  Se você usar os nomes lógicos das propriedades com <code>is</code> ou <code>has</code> em um local, mas ignorá-los ainda mais, isso confundirá as pessoas. </p><br><h3 id="minimizirovat-poverhnost-api">  Minimizar a superfície da API </h3><br><p>  Sua API também precisa ser minimizada.  Muitos recursos são ótimos, mas quanto menor a superfície da sua API (superfície da API), menos desenvolvedores precisarão estudá-la para começar a trabalhar produtivamente com ela.  Graças a isso, sua API será percebida como fácil de usar! </p><br><p>  Sempre existe uma maneira de controlar o tamanho das suas APIs.  Um deles é refatorar a nova API da antiga. </p><br><h2 id="desyat-zapovedey-dlya-veb-komponentov">  Os dez mandamentos para componentes da Web </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/2c7/33c/15e2c733cf1d3b5e5916c17692a6df5a.jpg" alt="Os 10 mandamentos componentes"></p><br><p>  Portanto, essas quatro regras de ouro funcionam bem para a API REST e para as antigas partes processuais do Pascal - mas como transferi-las para o mundo moderno do React? </p><br><p>  Como dissemos anteriormente, os componentes têm sua própria API.  Nós os chamamos de <code>props</code> e é com a ajuda deles que os dados são transferidos para os componentes.  Como estruturamos adereços para não violar nenhuma das regras acima? </p><br><p>  Criamos esta lista de <strong>dez regras de ouro</strong> que são melhor seguidas ao criar seus componentes.  Esperamos que eles sejam úteis para você. </p><br><h3 id="1-dokumentiruyte-ispolzovanie-komponentov">  1. Documente o uso de componentes </h3><br><p>  Se a maneira como você deseja usar seu componente não estiver documentada, esse componente será inútil.  Bem, quase inútil, você sempre pode olhar para sua implementação, mas poucas pessoas gostam de fazer isso. </p><br><p>  Existem várias maneiras de documentar seus componentes, mas recomendamos que você preste atenção a estes três: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Livro de histórias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Styleguidist</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Docz</a> </li></ul><br><p>  Os dois primeiros oferecem um local para você trabalhar no desenvolvimento de seus componentes, e o terceiro permite que você escreva a documentação de forma livre usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">MDX</a> </p><br><p>  Não importa o que você escolher, sempre documente a API em si e <strong>como e quando seus componentes devem ser usados</strong> .  A última parte é crítica nas bibliotecas de uso geral - para as pessoas usarem corretamente um botão ou grade de layout em um determinado contexto. </p><br><h3 id="2-razreshite-kontekstnuyu-semantiku">  2. Ativar semântica contextual </h3><br><p>  HTML é uma linguagem para estruturar informações de maneira semântica.  Somente aqui, a maioria dos nossos componentes consiste em tags <code>&lt;div /&gt;</code> .  Isso faz sentido - componentes universais não podem saber antecipadamente o que serão, talvez <code>&lt;article /&gt;</code> , ou <code>&lt;section /&gt;</code> ou <code>&lt;aside /&gt;</code> - mas essa situação está longe de ser ideal. </p><br><p>  Há outra opção: deixe seus componentes aceitarem prop <code>as</code> e, assim, determine qual elemento DOM será renderizado.  Aqui está um exemplo de como implementar isso: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ as: Element, ...props }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Element</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"grid"</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml"> } Grid.defaultProps = { as: 'div', };</span></span></code> </pre> <br><p>  Renomeamos prop <code>as</code> à variável <code>Element</code> e a usamos em nosso JSX.  Fornecemos um valor <code>div</code> padrão comum se não tivermos uma tag HTML mais semântica para passar. </p><br><p>  Quando chegar a hora de usar o componente <code>&lt;Grid /&gt;</code> , você pode simplesmente passar a tag correta: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MoreContent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Isso também funciona com os componentes React.  Por exemplo, se você deseja que o componente <code>&lt;Button /&gt;</code> renderize o <code>&lt;Link /&gt;</code> do React Router: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{Link}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/profile"</span></span></span><span class="hljs-tag">&gt;</span></span> Go to Profile <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3 id="3-izbegayte-logicheskih-boolean-propsov">  3. Evite adereços booleanos </h3><br><p>  Adereços lógicos são uma boa ideia.  Eles podem ser usados ​​sem valor, por isso parece muito elegante: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">large</span></span></span><span class="hljs-tag">&gt;</span></span>BUY NOW!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Mas, embora pareça bom, as propriedades lógicas permitem apenas duas possibilidades.  Ativado ou desativado  Visível ou oculto.  1 ou 0. </p><br><p>  Sempre que você começa a introduzir propriedades lógicas para itens como tamanho, opções, cores ou qualquer outra coisa que não seja uma opção binária, você tem problemas. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">large</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">small</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">primary</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">secondary</span></span></span><span class="hljs-tag">&gt;</span></span>   ?? <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Em outras palavras, as propriedades lógicas geralmente não se adaptam às mudanças nos requisitos.  Em vez disso, para valores que podem se tornar algo diferente de uma seleção binária, é melhor usar valores enumerados, como seqüências de caracteres. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">variant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primary"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"large"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Isso não significa que propriedades lógicas não possam ser usadas.  Você pode!  O suporte <code>disabled</code> , que listei acima, ainda deve ser lógico - porque não há estado intermediário entre ativado e desativado.  Apenas deixe as propriedades booleanas apenas para uma escolha verdadeiramente binária. </p><br><h3 id="4-ispolzuyte-propschildren">  4. Use <code>props.children</code> </h3><br><p>  O React possui algumas propriedades especiais que são tratadas de maneira diferente das outras.  Uma dessas <code>key</code> é necessária para rastrear a ordem dos itens da lista.  E outro desses objetos especiais são as <code>children</code> . </p><br><p>  Tudo o que você coloca entre a tag de abertura e fechamento do componente é colocado dentro do <code>props.children</code> .  E você deve usar isso o mais rápido possível. </p><br><p>  Porque  Porque é muito mais fácil do que ter <code>content</code> prop para conteúdo ou algo parecido que normalmente usa apenas valores simples, como texto. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Some text"</span></span></span><span class="hljs-tag"> /&gt;</span></span> //  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span>Some text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Existem várias vantagens em usar <code>props.children</code> .  Em primeiro lugar, isso é semelhante ao funcionamento do HTML comum.  Em segundo lugar, você pode transferir livremente o que quiser!  Em vez de adicionar adereços como <code>leftIcon</code> e <code>rightIcon</code> ao seu componente - apenas passe-os como parte do <code>props.children</code> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ImportantIcon</span></span></span><span class="hljs-tag"> /&gt;</span></span> Some text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Você pode argumentar que seu componente só precisa renderizar texto sem formatação e, em alguns casos, é.  Até algum ponto.  Usando <code>props.children</code> , você garante que sua API estará pronta para alterar os requisitos. </p><br><h3 id="5-pozvolte-roditelyu-ceplyatsya-za-vnutrennyuyu-logiku">  5. Deixe o pai se apegar à lógica interna </h3><br><p>  Às vezes, criamos componentes com muita lógica e estados internos - por exemplo, diagramas de preenchimento automático ou interativo. </p><br><p>  Esses componentes geralmente sofrem de APIs excessivas, uma das razões para isso é o grande número de casos de uso diferentes que se acumulam com o desenvolvimento do projeto. </p><br><p>  Mas e se pudéssemos fornecer um suporte único e padronizado que permita ao desenvolvedor controlar, responder ou simplesmente alterar o comportamento padrão do componente? </p><br><p>  Kent Dodds escreveu um excelente artigo sobre o conceito de redutores de estado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Aqui está um artigo sobre o próprio conceito</a> e também um artigo sobre como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">implementar isso para ganchos do React</a> . </p><br><p>  Em resumo, esse é um padrão de transferência de função de redutor de estado para o seu componente, o que permitirá ao desenvolvedor acessar todas as ações executadas dentro do seu componente.  Você pode mudar de estado ou até causar efeitos colaterais.  Essa é uma ótima maneira de fornecer um <strong>alto nível de personalização, sem adereços</strong> . </p><br><p>  Aqui está o que pode parecer: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCustomDropdown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stateReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === Dropdown.actions.CLOSE) { buttonRef.current.focus(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Dropdown stateReducer={stateReducer} {...props} /&gt; &lt;Button ref={buttonRef}&gt;Open&lt;/Button&gt; &lt;/&gt; }</code> </pre> <br><p>  A propósito, você pode criar maneiras mais simples de responder a eventos.  O uso do <code>onClose</code> no exemplo anterior provavelmente tornará o uso do componente mais conveniente.  Use o padrão "redutor de estado" quando necessário. </p><br><h3 id="6-ispolzuyte-operator-troetochie-spread-dlya-ostavshihsya-propsov">  6. Use o operador de propagação para os demais adereços </h3><br><p>  Cada vez que você cria um novo componente, aplique as reticências aos objetos restantes e envie-as ao elemento para o qual isso faz sentido. </p><br><p>  Você não precisa continuar adicionando acessórios ao seu componente, que simplesmente será passado para o componente ou elemento base.  Isso tornará sua API mais estável, eliminando a necessidade de muitos erros de versão pequena quando o próximo desenvolvedor precisar de um novo ouvinte de evento ou tag ARIA. </p><br><p>  Você pode fazer assim: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ isVisible, ...rest }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isVisible ? <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"tooltip"</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...rest</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml"> : null; }</span></span></code> </pre> <br><p>  Sempre que seu componente passa prop para sua implementação, como um nome de classe ou manipulador <code>onClick</code> , verifique se outro desenvolvedor pode fazer o mesmo.  No caso de uma classe, você pode simplesmente adicionar a classe prop usando a conveniente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">biblioteca de nomes de classe npm</a> (ou apenas concatenação de cadeias): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> classNames <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'classnames'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{classNames(</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tooltip</span></span></span></span><span class="xml"><span class="hljs-tag">', </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.tooltip</span></span></span></span><span class="xml"><span class="hljs-tag">)} /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  No caso de manipuladores de clique e outros retornos de chamada, você pode combiná-los em uma função usando um pequeno utilitário.  Aqui está uma maneira de fazer isso: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...functions</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> functions .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> func === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function"> =&gt;</span></span> func(...args)); }</code> </pre> <br><p>  Aqui, criamos uma função que aceita uma lista de funções para combiná-las.  Ele retorna um novo retorno de chamada, que chama todos eles por sua vez, com os mesmos argumentos. </p><br><p>  Esta função pode ser usada desta maneira: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isVisible, setVisible] = React.useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;span {...props} className={classNames(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'tooltip'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, props.className</span></span></span><span class="hljs-function">)} </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onMouseIn</span></span></span><span class="hljs-function">={</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> setVisible(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), props.onMouseIn)} onMouseOut={combine(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> setVisible(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), props.onMouseOut)} /&gt; ); }</code> </pre> <br><h3 id="7-ispolzuyte-znacheniya-po-umolchaniyu">  7. Use os valores padrão </h3><br><p>  Certifique-se de fornecer padrões suficientes (padrões) aos seus acessórios.  Assim, você reduzirá o número de adereços obrigatórios.  Isso simplificará bastante sua API. </p><br><p>  Pegue, por exemplo, o manipulador <code>onClick</code> .  Se o seu código não precisar desse manipulador, use a função vazia (função noop) como o suporte padrão.  Dessa forma, você pode chamá-lo em seu código como se sempre fosse passado. </p><br><p>  Outro exemplo pode ser a entrada do usuário.  Suponha que a sequência de entrada seja uma sequência vazia, a menos que especificado de outra forma.  Isso permitirá que você sempre lide com um objeto string, não com algo indefinido ou nulo. </p><br><h3 id="8-ne-nado-pereimenovyvat-atributy-html">  8. Não há necessidade de renomear atributos HTML </h3><br><p>  O HTML como idioma possui seus próprios props - ou atributos, e ele próprio é uma API para elementos HTML.  Então, por que não continuar usando esta API? </p><br><p>  Como mencionamos anteriormente, minimizar a superfície da API e sua intuitividade são métodos úteis para melhorar a API de seus componentes.  Então, em vez de criar seu próprio suporte <code>screenReaderLabel</code> , por que não usar apenas um <code>aria-label</code> existente? </p><br><p>  <strong>Evite renomear quaisquer atributos HTML existentes</strong> para sua própria "facilidade de uso".  Você nem substitui a API existente - basta adicionar a sua própria sobre ela.  As pessoas ainda podem passar o <code>aria-label</code> da <code>aria-label</code> junto com o <code>screenReaderLabel</code> screenReaderLabel - e qual deve ser o valor final? </p><br><p>  Além disso, nunca substitua os atributos HTML em seus componentes.  Um ótimo exemplo é o atributo <code>type</code> do elemento <code>&lt;button /&gt;</code> .  Pode ser <code>submit</code> (padrão), <code>button</code> ou <code>reset</code> .  No entanto, muitos desenvolvedores redefinem esse suporte para indicar o tipo visual do botão ( <code>primary</code> , <code>cta</code> etc.). </p><br><p>  Se você usar esse suporte, precisará adicionar uma substituição para o atributo true <code>type</code> .  Isso levará a confusão, dúvida e aborrecimento por parte dos desenvolvedores. </p><br><p>  Acredite em mim - cometi esse erro repetidamente - se você o cometer, terá que desembaraçá-lo por um longo tempo. </p><br><h3 id="9-pishite-tipy-propsov-ili-prosto-tipy">  9. Escreva os tipos de adereços (ou apenas os tipos) </h3><br><p>  Nenhuma documentação será tão boa quanto a documentação que está dentro do seu código.  O React vem com uma ótima maneira de declarar suas APIs usando o pacote <code>prop-types</code> .  Use-o. </p><br><p>  Você pode especificar quaisquer requisitos de formato para seus acessórios obrigatórios e opcionais e pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aprimorá-</a> los com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">comentários do JSDoc</a> . </p><br><p>  Se você não especificar um suporte obrigatório ou passar um valor inválido ou inesperado, em tempo de execução, você receberá um aviso no console.  Isso ajuda muito durante o desenvolvimento e pode ser removido da produção. </p><br><p>  Se você escreve seus aplicativos React no TypeScript ou usa o Flow, obtém a documentação da API como uma função de linguagem.  Isso aprimora ainda mais o suporte das ferramentas de desenvolvimento e simplifica o trabalho. </p><br><p>  Se você mesmo não usar JavaScript digitado, considere fornecer definições de tipo para os desenvolvedores que o usam.  Então será muito mais fácil eles usarem seus componentes. </p><br><h3 id="10-proektiruyte-dlya-razrabotchikov">  10. Design para desenvolvedores </h3><br><p>  Finalmente, a regra mais importante a seguir.  Verifique se sua API e o trabalho com seus componentes estão otimizados para desenvolvedores que a usarão. </p><br><p>  Uma maneira de simplificar o trabalho de um desenvolvedor é fornecer feedback sobre o uso inadequado.  Faça isso com mensagens de erro e também, mas apenas durante o desenvolvimento, com avisos de que existem maneiras mais eficientes de usar seu componente. </p><br><p>  Ao escrever erros e avisos, forneça links para sua documentação ou mostre exemplos simples de código.  Quanto mais rápido o desenvolvedor entender qual é o problema e como corrigi-lo, mais conveniente será o seu componente para o trabalho. </p><br><p>  Incrivelmente, mas, como se viu, a presença de todos esses avisos de erro longos não afeta o tamanho do pacote final.  Graças aos milagres de eliminar o código morto, todo esse texto e código de erro podem ser removidos durante a montagem na produção. </p><br><p>  Uma das bibliotecas que fornece um feedback incrivelmente bom é o próprio React.  Não importa se você esqueceu de especificar a chave para os itens da lista, ou se escreveu o método do ciclo de vida incorretamente, ou se esqueceu de estender a classe base ou chamou o gancho de maneira incerta - em qualquer caso, você receberá grandes e grossas mensagens de erro no console.  Por que os desenvolvedores que usam seus componentes esperam menos de você? </p><br><p>  Então, crie para seus futuros usuários.  Projete para si mesmo a partir do futuro.  Projete para os infelizes que terão que manter seu código quando você sair!  Design para desenvolvedores. </p><br><h3 id="itogo">  Total </h3><br><p>  Podemos aprender muito com a abordagem clássica da API.  Seguindo as dicas, truques, regras e mandamentos deste artigo, você pode criar componentes fáceis de usar, fáceis de manter, intuitivos e, se necessário, muito flexíveis. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460559/">https://habr.com/ru/post/pt460559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460547/index.html">Antiguidades: Psion 5MX e Vida Aposentada</a></li>
<li><a href="../pt460551/index.html">Portugal As melhores praias e mil startups por ano</a></li>
<li><a href="../pt460553/index.html">Tecnologia, terceirização e mentalidade: como implementamos o Microsoft Dynamics 365 no escritório alemão da Lamoda</a></li>
<li><a href="../pt460555/index.html">Relatório do PyDaCon meetup no Mail.ru Group, 22 de junho</a></li>
<li><a href="../pt460557/index.html">Uma seleção de exemplos de trabalho de processamento de dados</a></li>
<li><a href="../pt460561/index.html">Como desenvolver outro jogo de plataformas usando o Unity. Outro tutorial, parte 2</a></li>
<li><a href="../pt460565/index.html">Batalha pela conta. Fundador da rede Jeffrey's Coffee processa a VKontakte</a></li>
<li><a href="../pt460567/index.html">React Native: faça uma lista arrastável e deslizável</a></li>
<li><a href="../pt460569/index.html">Software de gravação com a funcionalidade dos utilitários cliente-servidor Windows, parte 01</a></li>
<li><a href="../pt460573/index.html">O Google afirma que "reCAPTCHA" não abuse dos dados do usuário. Vale a pena acreditar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>