<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçê üë©‚Äçüëß üõï Haxe 4: ¬øQu√© hay de nuevo? üéñÔ∏è ‚öíÔ∏è üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les traigo a su atenci√≥n una traducci√≥n del informe de Alexander Kuzmenko (desde abril de este a√±o trabaja oficialmente como desarrollador del compila...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haxe 4: ¬øQu√© hay de nuevo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455389/"><p>  Les traigo a su atenci√≥n una traducci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Alexander Kuzmenko</a> (desde abril de este a√±o trabaja oficialmente como desarrollador del compilador Haxe) sobre los cambios en el lenguaje Haxe que se han producido desde el lanzamiento de Haxe 3.4. </p><br><img src="https://habrastorage.org/webt/0m/0e/mw/0m0emw609dcl9ycql2oa069lzfu.jpeg" alt="imagen"><br><p>  Han pasado m√°s de dos a√±os y medio desde el lanzamiento de Haxe 3.4.  Durante este tiempo, se lanzaron 7 lanzamientos de parches, 5 lanzamientos preliminares de Haxe 4 y 2 candidatos de lanzamiento de Haxe 4. Era un largo camino hacia la nueva versi√≥n y est√° casi listo (quedan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unos 20 problemas</a> por resolver). </p><a name="habracut"></a><br><img src="https://habrastorage.org/webt/jh/wp/7_/jhwp7_vztjntd_31hhmpqqreabe.png" alt="Hace mucho tiempo ..."><br><p>  Alexander agradeci√≥ a la comunidad Haxe por informar de errores, por su deseo de participar en el desarrollo del lenguaje.  Gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">al proyecto haxe-evolution</a> , cosas como las siguientes aparecer√°n en Haxe 4: </p><br><ul><li>  marcado en l√≠nea </li><li>  funciones en l√≠nea en la ubicaci√≥n de la llamada </li><li>  funciones de flecha </li></ul><br><img src="https://habrastorage.org/webt/kn/qf/fu/knqffu_thrc2godjucb5t4izbt0.png" alt="imagen"><br><p>  Adem√°s, en el marco de este proyecto, se est√°n celebrando debates sobre posibles innovaciones tales como: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">promesas</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto polim√≥rfico</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos</a> predeterminados (par√°metros de tipo predeterminados). </p><br><p>  Luego, Alexander habl√≥ <b>sobre los cambios en la sintaxis del lenguaje</b> . </p><br><img src="https://habrastorage.org/webt/pg/jn/sy/pgjnsymvkyhlespf0rcj-dw6j8s.png" alt="Nueva sintaxis para describir tipos de funciones"><br><p> La primera es la nueva sintaxis para describir la sintaxis de los tipos de funci√≥n.  La vieja sintaxis era un poco extra√±a. <br>  Haxe es un lenguaje de programaci√≥n multi-paradigm√°tico, siempre tuvo soporte para funciones de primera clase, pero la sintaxis para describir los tipos de funciones fue heredada de un lenguaje funcional (y difiere del adoptado en otros paradigmas).  Y los programadores familiarizados con la programaci√≥n funcional esperan que las funciones con esta sintaxis admitan el curry autom√°tico.  Pero en Haxe esto no es as√≠. <br>  El principal inconveniente de la sintaxis anterior, seg√∫n Alexander, es la incapacidad para determinar los nombres de los argumentos, por lo que debe escribir comentarios de anotaci√≥n largos con una descripci√≥n de los argumentos. <br>  Pero ahora tenemos una nueva sintaxis para describir los tipos de funci√≥n (que, por cierto, se agreg√≥ al lenguaje como parte de la iniciativa haxe-evolution), donde existe esa oportunidad (aunque esto es opcional, pero recomendado).  La nueva sintaxis es m√°s f√°cil de leer e incluso puede considerarse parte de la documentaci√≥n del c√≥digo. <br>  Otro inconveniente de la sintaxis anterior para describir los tipos de funci√≥n era su inconsistencia: la necesidad de especificar el tipo de argumentos de la funci√≥n incluso cuando la funci√≥n no acepta ning√∫n argumento: <code>Void-&gt;Void</code> (esta funci√≥n no toma argumentos y no devuelve nada). <br>  En la nueva sintaxis, esto se implementa con m√°s elegancia: <code>()-&gt;Void</code> </p><br><img src="https://habrastorage.org/webt/xv/nr/fq/xvnrfqcbcxakqrci6y_p1hibh_4.png" alt="Funciones de flecha"><br><p>  El segundo es funciones de flecha o expresiones lambda, una forma corta para describir funciones an√≥nimas.  La comunidad ha estado pidiendo durante mucho tiempo agregarlos al idioma, ¬°y finalmente sucedi√≥! <br>  En tales funciones, en lugar de la palabra clave <code>return</code> , <code>-&gt;</code> la secuencia de caracteres <code>-&gt;</code> (de ah√≠ que el nombre de sintaxis sea "funci√≥n de flecha"). <br>  En la nueva sintaxis, sigue siendo posible establecer los tipos de argumentos (ya que el sistema autom√°tico de inferencia de tipos no siempre puede hacerlo de la manera que el programador quiere, por ejemplo, el compilador puede decidir usar <code>Float</code> lugar de <code>Int</code> ). <br>  La √∫nica limitaci√≥n de la nueva sintaxis es la incapacidad de establecer expl√≠citamente el tipo de retorno.  Si es necesario, tiene la opci√≥n de usar la sintaxis anterior o la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sintaxis de tipo de verificaci√≥n</a> en el cuerpo de la funci√≥n, que le indicar√° al compilador el tipo de retorno. </p><br><img src="https://habrastorage.org/webt/wh/ri/-8/whri-8d5u0nvjgkiybnrjp1vrag.png" alt="Las funciones de flecha no tienen una representaci√≥n especial en el √°rbol de sintaxis"><br><p>  Las funciones de flecha no tienen una representaci√≥n especial en el √°rbol de sintaxis; se procesan de la misma manera que las funciones an√≥nimas normales.  La secuencia <code>-&gt;</code> se reemplaza por la palabra clave <code>return</code> . </p><br><img src="https://habrastorage.org/webt/nd/8c/kt/nd8cktem7lhra7ll-qao6hdatva.png" alt="final: ahora es una palabra clave"><br><p>  El tercer cambio: <code>final</code> ahora se <code>final</code> convertido en una palabra clave (en Haxe 3 <code>final</code> fue una de las metaetiquetas integradas en el compilador). <br>  Si lo aplica a una clase, prohibir√° su herencia, lo mismo se aplica a las interfaces.  Aplicar el calificador <code>final</code> a un m√©todo de clase evitar√° que se anule en las clases secundarias. <br>  Sin embargo, en Haxe, hab√≠a una manera de sortear las restricciones impuestas por la palabra clave <code>final</code> : puede usar la metaetiqueta <code>@:hack</code> para esto (pero solo debe hacerlo si es absolutamente necesario). </p><br><img src="https://habrastorage.org/webt/ec/v3/mp/ecv3mpajsnrn6kxkrwx3rwkqlwe.png" alt="Declarando campos opcionales en estructuras an√≥nimas"><br><p>  El cuarto cambio es una forma de declarar campos opcionales en estructuras an√≥nimas.  Anteriormente, se usaba la metaetiqueta <code>@:optional</code> para esto, ahora solo agregue un signo de interrogaci√≥n delante del nombre del campo. </p><br><img src="https://habrastorage.org/webt/r8/i3/qb/r8i3qbo2r2seeqtyns2yhsbr5r8.png" alt="Listado de res√∫menes"><br><p>  Quinto, las enumeraciones abstractas se han convertido en un miembro completo de la familia de tipos Haxe, y en lugar de la metaetiqueta <code>@:enum</code> palabra clave <code>@:enum</code> ahora se usa para declararlas. </p><br><img src="https://habrastorage.org/webt/ew/b3/xt/ewb3xtnkjr_fdk4jtcdj-ezboao.png" alt="Palabra clave externa"><br><p>  Un cambio similar afect√≥ a la metaetiqueta <code>@:extern</code> . </p><br><img src="https://habrastorage.org/webt/pb/g3/ip/pbg3ipuxlefguxcw5m-2qybtuqq.png" alt="Nueva sintaxis para la uni√≥n de tipos (intersecci√≥n de tipos)"><br><p>  El s√©ptimo es un nuevo tipo de sintaxis de intersecci√≥n que refleja mejor la esencia de las estructuras en expansi√≥n. <br>  La misma sintaxis nueva se usa para limitar las restricciones de los par√°metros de tipo; transmite con mayor precisi√≥n las restricciones impuestas a un tipo.  Para una persona que no est√° familiarizada con Haxe, la sintaxis anterior <code>MyClass&lt;T:(Type1, Type2)&gt;</code> podr√≠a percibirse como un requisito para que el tipo del par√°metro <code>T</code> sea <code>Type1</code> o <code>Type2</code> .  La nueva sintaxis nos dice expl√≠citamente que <code>T</code> debe ser <code>Type1</code> y <code>Type2</code> al mismo tiempo. </p><br><img src="https://habrastorage.org/webt/e9/un/cj/e9uncj0a6tk4uh0keuuopuwokgy.png" alt="Sintaxis simplificada para declarar un diccionario vac√≠o"><br><p>  La octava es la capacidad de usar <code>[]</code> para declarar un contenedor <code>Map</code> vac√≠o (sin embargo, si no especifica expl√≠citamente el tipo de la variable, el compilador generar√° el tipo como una matriz para este caso). </p><br><p>  Habiendo hablado sobre los cambios en la sintaxis, pasemos a la descripci√≥n de <b>nuevas funciones en el lenguaje</b> . <br>  Comencemos con los nuevos iteradores clave-valor </p><br><img src="https://habrastorage.org/webt/gw/sg/3v/gwsg3vpv6qco2n61v4zxh0dfzvw.png" alt="Iteradores de valor clave"><br><p>  Se ha agregado una nueva sintaxis para su uso. <br>  Para admitir dichos iteradores, el tipo debe implementar el m√©todo <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> o los m√©todos <code>hasNext():Bool</code> y <code>next():{key:K, value:V}</code> .  Al mismo tiempo, el tipo <code>KeyValueIterator&lt;K, V&gt;</code> es sin√≥nimo de un iterador regular en la estructura an√≥nima <code>Iterator&lt;{key:K, value:V}&gt;</code> . <br>  Los iteradores de valores clave se implementan para algunos tipos de la biblioteca est√°ndar de Haxe ( <code>String</code> , <code>Map</code> , <code>DynamicAccess</code> ), y tambi√©n se est√° trabajando para implementarlos en matrices. </p><br><img src="https://habrastorage.org/webt/67/-f/g0/67-fg0qimh9gu7b8qvkaazjf4ti.png" alt="Soporte para nuevos iteradores para tipos incorporados"><br><p>  Para las cadenas, el √≠ndice de caracteres en la cadena se usa como la clave, y el c√≥digo de caracteres en el √≠ndice dado se usa como el valor (si se necesita el propio car√°cter, se puede usar el m√©todo <code>String.fromCharCode()</code> ). <br>  Para el contenedor <code>Map</code> , el nuevo iterador funciona igual que el m√©todo de iteraci√≥n anterior, es decir, recibe una matriz de claves en el contenedor y lo atraviesa, solicitando valores para cada una de las claves. <br>  Para <code>DynamicAccess</code> (un contenedor para objetos an√≥nimos), el iterador funciona usando la reflexi√≥n (para obtener una lista de campos de un objeto usando el m√©todo <code>Reflect.fields()</code> y para obtener valores de campo por sus nombres usando el m√©todo <code>Reflect.field()</code> ). </p><br><img src="https://habrastorage.org/webt/ml/u7/qj/mlu7qjpnq86muxduteld_riofzu.png" alt="Nuevo int√©rprete de macros"><br><p>  Haxe 4 usa un int√©rprete de macros completamente nuevo, "eval".  Simon Krajewski, el autor del int√©rprete, lo describi√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con</a> cierto detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el blog oficial de Haxe</a> , as√≠ como en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de progreso del a√±o pasado</a> . <br>  Los principales cambios en el trabajo del int√©rprete: </p><br><ul><li>  es varias veces m√°s r√°pido que el antiguo int√©rprete de macros (4 veces en promedio) </li><li>  admite depuraci√≥n interactiva (anteriormente, para macros, solo se pod√≠a usar la salida de la consola) </li><li>  se usa para ejecutar el compilador en modo int√©rprete (anteriormente se usaba neko para esto. Por cierto, eval tambi√©n supera a neko en velocidad). </li></ul><br><img src="https://habrastorage.org/webt/f3/ef/e8/f3efe8ko9czu8tdyo5kzjswkfto.png" alt="Soporte unicode"><br><p>  El soporte Unicode para todas las plataformas (con la excepci√≥n de neko) es uno de los mayores cambios en Haxe 4. Simon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habl√≥ sobre esto en</a> detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el a√±o pasado</a> .  Pero aqu√≠ hay una breve descripci√≥n del estado actual del soporte de cadenas Unicode en Haxe: </p><br><ul><li>  para Lua, PHP, Python y eval (int√©rprete de macros) se implementa soporte completo Unicode (codificaci√≥n UTF8) </li><li>  Para otras plataformas (JavaScript, C #, Java, Flash, HashLink y C ++), se utiliza la codificaci√≥n UTF16. </li></ul><br><p>  Por lo tanto, las l√≠neas en Haxe funcionan de la misma manera para los caracteres incluidos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plano multiling√ºe principal</a> , pero para los caracteres fuera de este plano (por ejemplo, para emoji), el c√≥digo para trabajar con l√≠neas puede producir diferentes resultados dependiendo de la plataforma (pero esto es a√∫n mejor, que la situaci√≥n que tenemos en Haxe 3, cuando cada plataforma ten√≠a su propio comportamiento). </p><br><img src="https://habrastorage.org/webt/5o/o2/fp/5oo2fp2s4h2t9rpqnvfyrbwb7gs.png" alt="Nuevos iteradores de cadena"><br><p>  Para cadenas codificadas en Unicode (tanto en UTF8 como en UTF16), se han agregado iteradores especiales a la biblioteca est√°ndar de Haxe que funcionan igualmente en TODAS las plataformas para todos los caracteres (tanto dentro del plano multiling√ºe principal como m√°s all√°): </p><br><pre> <code class="plaintext hljs">haxe.iterators.StringIteratorUnicode haxe.iterators.StringKeyValueIteratorUnicode</code> </pre> <br><img src="https://habrastorage.org/webt/3k/zv/xu/3kzvxup9p5crewap3u76tnfqhlg.png" alt="Caracter√≠sticas para soporte unicode"><br><p>  Debido al hecho de que la implementaci√≥n de cadenas var√≠a de una plataforma a otra, es necesario tener en cuenta algunos de los matices de su trabajo.  En UTF16, cada car√°cter toma 2 bytes, por lo que acceder a un car√°cter en una cadena por √≠ndice es r√°pido, pero solo dentro del plano multiling√ºe principal.  Por otro lado, en UTF8 todos los caracteres son compatibles, pero esto se logra a costa de una b√∫squeda lenta de un car√°cter en una cadena (dado que los caracteres pueden ocupar diferentes n√∫meros de bytes en la memoria, acceder a un car√°cter por √≠ndice requiere iterar a trav√©s de la l√≠nea cada vez desde el principio).  Por lo tanto, cuando trabaje con cadenas grandes en Lua y PHP, debe tener en cuenta que el acceso a un car√°cter arbitrario funciona bastante lento (tambi√©n en estas plataformas, la longitud de la cadena se calcula nuevamente cada vez). <br>  Sin embargo, aunque se declara el soporte completo de Unicode para Python, esta restricci√≥n no se aplica porque las l√≠neas se implementan de una manera ligeramente diferente: para los caracteres dentro del plano multiling√ºe principal, utiliza la codificaci√≥n UTF16 y para caracteres m√°s anchos (3 y m√°s bytes) Python usa UTF32. <br>  Se implementan optimizaciones adicionales para el int√©rprete de macros eval: la cadena "sabe" si contiene caracteres Unicode.  En el caso de que no contenga tales caracteres, la cadena se interpreta como compuesta por caracteres ASCII (donde cada car√°cter toma 1 byte).  El acceso secuencial por √≠ndice en eval tambi√©n est√° optimizado: la posici√≥n del √∫ltimo car√°cter al que se accede se almacena en cach√© en la l√≠nea.  Entonces, si primero pasa al d√©cimo car√°cter de la cadena, luego, cuando vuelva al pr√≥ximo vig√©simo car√°cter, eval lo buscar√° no desde el comienzo de la l√≠nea, sino a partir del d√©cimo.  Adem√°s, la longitud de la cadena en eval se almacena en cach√©, es decir, se calcula solo en la primera solicitud. </p><br><img src="https://habrastorage.org/webt/je/gi/ne/jegineguad8fp4dlqyhfbboxy8c.png" alt="Soporte de espacio de nombres para banderas de compilaci√≥n"><br><p>  Haxe 4 presenta soporte para espacios de nombres para indicadores de compilaci√≥n, que pueden ser √∫tiles, por ejemplo, para organizar c√≥digo al escribir bibliotecas personalizadas. <br>  Adem√°s, apareci√≥ un espacio de nombres reservado para los indicadores de compilaci√≥n: <code>target</code> , que el compilador utiliza para describir la plataforma de destino y su comportamiento: </p><br><ul><li>  <code>target.name</code> : nombre de la plataforma (js, cpp, php, etc.) </li><li>  <code>target.utf16</code> : dice que el soporte Unicode se implementa usando UTF16 </li><li>  <code>target.sys</code> : indica si las clases del paquete sys est√°n disponibles (por ejemplo, para trabajar con el sistema de archivos) </li><li>  <code>target.static</code> : indica si la plataforma es est√°tica (en plataformas est√°ticas, los tipos base <code>Int</code> , <code>Float</code> y <code>Bool</code> no pueden tener un valor <code>null</code> ) </li><li>  <code>target.threaded</code> : indica si la plataforma admite subprocesos <code>target.threaded</code> </li></ul><br><img src="https://habrastorage.org/webt/qt/ue/c_/qtuec_vbswkwgylwnidy9xuaeou.png" alt="Soporte de espacio de nombres para metaetiquetas"><br><p>  Del mismo modo, ha aparecido el espacio de nombres para metaetiquetas.  Hasta ahora no hay espacios de nombres reservados para metaetiquetas en el idioma, pero la situaci√≥n puede cambiar en el futuro. </p><br><img src="https://habrastorage.org/webt/cc/yj/ye/ccyjyemwz1ti9vgddvccyu4iqeq.png" alt="Nuevo tipo: ReadOnlyArray"><br><p>  El tipo <code>ReadOnlyArray</code> agrega a la biblioteca est√°ndar de Haxe, una abstracci√≥n sobre una matriz regular, en la que los m√©todos solo est√°n disponibles para leer datos de la matriz. </p><br><img src="https://habrastorage.org/webt/jr/ia/2o/jria2ovebta0bwm-lezr7jvv7ao.png" alt="Campos finales y variables locales"><br><p>  Otra innovaci√≥n en el lenguaje son los campos finales y las variables locales. <br>  Si <code>final</code> usa <code>final</code> lugar de la palabra clave <code>var</code> al declarar un campo de clase o una variable local, esto significar√° que el campo o la variable dados no se pueden reasignar (si el compilador intenta hacer esto, arrojar√° un error).  Pero al mismo tiempo, su estado se puede cambiar, por lo que el campo o variable final no es una constante. </p><br><img src="https://habrastorage.org/webt/j-/8u/f9/j-8uf9asp_ivqbxn8kypatexma0.png" alt="El compilador controla la inicializaci√≥n de los campos finales."><br><p>  Los valores de los campos finales deben inicializarse cuando se declaran o en el constructor, de lo contrario, el compilador arrojar√° un error. </p><br><img src="https://habrastorage.org/webt/2h/yd/wi/2hydwitcbuwstefblzdr09sxqzk.png" alt="Hashlink"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HashLink</a> es una nueva plataforma con su propia m√°quina virtual, creada espec√≠ficamente para Haxe.  HashLink admite la llamada "compilaci√≥n dual": el c√≥digo se puede compilar en bytecode (que es muy r√°pido, acelera el proceso de depuraci√≥n de las aplicaciones desarrolladas) o en c√≥digo C (que se caracteriza por un mayor rendimiento).  Nicholas dedic√≥ HashLink a varias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaciones en el blog de Haxe</a> y tambi√©n habl√≥ sobre √©l <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia de</a> Seattle del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a√±o pasado</a> .  La tecnolog√≠a HashLink se usa en juegos populares como Dead Cells y Northgard. </p><br><img src="https://habrastorage.org/webt/zy/a4/eh/zya4eh5l7t3zqihviw5qvtcrsfc.png" alt="Seguridad nula"><br><p>  Otra nueva caracter√≠stica interesante de Haxe 4 es la seguridad nula, que a√∫n se encuentra en la etapa experimental (debido a falsos positivos y controles de seguridad de c√≥digo insuficientes). <br>  ¬øQu√© es la seguridad nula?  Si su funci√≥n no declara expl√≠citamente que puede aceptar valores <code>null</code> como valores de par√°metros, cuando intente pasarle valores <code>null</code> , el compilador arrojar√° el error correspondiente.  Adem√°s, para los par√°metros de funci√≥n que pueden tomar <code>null</code> como valor, el compilador requerir√° que escriba c√≥digo adicional para verificar y manejar tales casos. <br>  Esta funcionalidad est√° deshabilitada de manera predeterminada, pero no afecta la velocidad de ejecuci√≥n del c√≥digo (si lo habilita, sin embargo), ya que las comprobaciones descritas se realizan solo en la etapa de compilaci√≥n.  Se puede habilitar para todo el c√≥digo, as√≠ como gradualmente para campos, clases y paquetes individuales (lo que proporciona una transici√≥n gradual a un c√≥digo m√°s seguro).  Puede usar metaetiquetas y macros especiales para esto. <br>  Los modos en los que puede funcionar la seguridad nula son: <code>Strict</code> (el m√°s estricto), <code>Loose</code> (el modo predeterminado) y <code>Off</code> (utilizado para deshabilitar las comprobaciones de paquetes y tipos individuales). </p><br><img src="https://habrastorage.org/webt/mn/9l/jh/mn9ljhu2_wwwonpjo7qhcoiasyw.png" alt="Modo de verificaci√≥n de seguridad nulo est√°ndar"><br><p>  Para la funci√≥n que se muestra en la diapositiva, la comprobaci√≥n de seguridad nula est√° habilitada.  Vemos que esta funci√≥n tiene un par√°metro opcional <code>s</code> , es decir, podemos pasar <code>null</code> como un valor de par√°metro.  Al intentar compilar c√≥digo con dicha funci√≥n, el compilador producir√° una serie de errores: </p><br><ul><li>  al intentar acceder a alg√∫n campo del objeto <code>s</code> (ya que puede ser <code>null</code> ) </li><li>  al intentar asignar una variable str, que, como vemos, no deber√≠a ser <code>null</code> (de lo contrario, deber√≠amos haberla declarado no como <code>String</code> , sino como <code>Null&lt;String&gt;</code> ) </li><li>  al intentar devolver un objeto <code>s</code> de una funci√≥n (ya que la funci√≥n no debe devolver <code>null</code> ) </li></ul><br><p>  ¬øC√≥mo arreglar estos errores? </p><br><img src="https://habrastorage.org/webt/ku/w-/l8/kuw-l8prqna5xq7c21ushemgtqs.png" alt="Arreglar errores de seguridad nulos"><br><p>  Solo necesitamos agregar una verificaci√≥n <code>null</code> al c√≥digo (dentro del bloque con verificaci√≥n <code>null</code> , el compilador "sabe" que <code>s</code> no puede ser <code>null</code> y puede usarse con seguridad con √©l), ¬°y tambi√©n asegurarse de que la funci√≥n no devuelva <code>null</code> ! </p><br><img src="https://habrastorage.org/webt/x1/xj/jp/x1xjjpwn8ikrulbtulxj_iixlq4.png" alt="Al realizar comprobaciones de seguridad nula, el compilador tiene en cuenta el orden de ejecuci√≥n del programa"><br><p>  Adem√°s, al realizar comprobaciones de seguridad nula, el compilador tiene en cuenta el orden en que se ejecutan los programas.  Por ejemplo, si despu√©s de verificar el valor del par√°metro <code>s</code> como nulo para terminar la funci√≥n (o lanzar una excepci√≥n), el compilador "sabr√°" que despu√©s de tal verificaci√≥n, el par√°metro <code>s</code> ya no puede ser <code>null</code> , y que puede usarse de manera segura. </p><br><img src="https://habrastorage.org/webt/6f/vq/cj/6fvqcjbu-dixmrxcfuwtd8mskvk.png" alt="Modo estricto para realizar comprobaciones de seguridad nulas"><br><p>  Si el compilador habilita el modo estricto de comprobaciones para la seguridad nula, requerir√° comprobaciones adicionales para <code>null</code> en los casos en que entre la comprobaci√≥n inicial del valor <code>null</code> y un intento de acceder al campo del objeto se ejecut√≥ cualquier c√≥digo que pudiera establecerlo como <code>null</code> . </p><br><img src="https://habrastorage.org/webt/ci/6m/u4/ci6mu4zsvkdjf33vvbetz30mf2m.png" alt="Modo suelto para realizar comprobaciones de seguridad nulas"><br><p>  En el modo Loose (usado por defecto), el compilador no requerir√° tales verificaciones (por cierto, este comportamiento tambi√©n se usa por defecto en TypeScript). </p><br><img src="https://habrastorage.org/webt/je/wo/5q/jewo5qwzmavidsf-jss4bwug79i.png" alt="Comprobaci√≥n de inicializaci√≥n de campos al realizar comprobaciones de seguridad nula"><br><p>  Adem√°s, cuando se activan las comprobaciones de seguridad nula, el compilador comprueba si los campos de las clases se inicializan (directamente cuando se declaran o en el constructor).  De lo contrario, el compilador arrojar√° errores al intentar pasar un objeto de dicha clase, as√≠ como al intentar llamar a m√©todos en dichos objetos, hasta que se inicialicen todos los campos del objeto.  Dichas comprobaciones pueden desactivarse para campos individuales de la clase marc√°ndolos con la metaetiqueta <code>@:nullSafety(Off)</code> <br>  Alexander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habl√≥</a> m√°s sobre la seguridad nula en Haxe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octubre pasado</a> . </p><br><img src="https://habrastorage.org/webt/ui/f3/za/uif3zavird4vri76gqfiaukfsxo.png" alt="Generando clases ES6 para JavaScript"><br><p>  Haxe 4 introdujo la capacidad de generar clases ES6 para JavaScript; se habilita utilizando el indicador de compilaci√≥n <code>js-es=6</code> . </p><br><img src="https://habrastorage.org/webt/z7/5c/ow/z75cowptrmqn5bxfa7oerxkxsro.png" alt="Funcionalidad en el lugar"><br><p>  Las funciones de incrustaci√≥n en el lugar de una llamada (en l√≠nea del sitio de la llamada) proporcionan m√°s opciones para controlar el equilibrio entre el rendimiento y el tama√±o del c√≥digo.  Esta funcionalidad tambi√©n se usa en la biblioteca est√°ndar de Haxe. <br>  Como es ella  Le permite incrustar el cuerpo de la funci√≥n (usando la <code>inline</code> ) solo en aquellos lugares donde es necesario para garantizar un alto rendimiento (por ejemplo, si es necesario, llame a un m√©todo suficientemente voluminoso en el bucle), mientras que en otros lugares el cuerpo de la funci√≥n no est√° incrustado.  Como resultado, el tama√±o del c√≥digo generado aumentar√° ligeramente. </p><br><img src="https://habrastorage.org/webt/ke/0y/wf/ke0ywfco0j5pbynruiqr4mgqhxw.png" alt="Extensiones autom√°ticas para tipos"><br><p>  El uso autom√°tico (extensiones autom√°ticas para tipos) significa que ahora para los tipos puede declarar extensiones est√°ticas en el lugar de la declaraci√≥n de tipo.  Esto elimina la necesidad de utilizar el <code>using type;</code> construcci√≥n cada vez <code>using type;</code>  en cada m√≥dulo donde se utilizan los m√©todos de tipo y extensi√≥n.  Por el momento, este tipo de extensi√≥n se implementa solo para transferencias, pero en la versi√≥n final (y en versiones nocturnas) puede usarse no solo para transferencias. </p><br><img src="https://habrastorage.org/webt/ru/ts/6s/ruts6snzqmgjdbx1g0kmjc92oxw.png" alt="Anular el operador para acceder a los campos de un objeto"><br><p>  En Haxe 4, ser√° posible redefinir el operador para acceder a los campos de un objeto para tipos abstractos (solo para campos que no existen en el tipo).  Para hacer esto, use los m√©todos marcados con la metaetiqueta <code>@:op(ab)</code> . </p><br><img src="https://habrastorage.org/webt/qv/fu/fj/qvfufjhriheejf1q6i0epu82pw8.png" alt="Marcado incorporado"><br><p>  El marcado incorporado es otra caracter√≠stica experimental en Haxe.  El compilador no procesa el c√≥digo de marcado incorporado como un documento xml: el compilador lo ve como una cadena envuelta en la metaetiqueta de <code>@:markup</code>           . </p><br><img src="https://habrastorage.org/webt/ms/an/zi/msanzicye9bpsmkbw55m6zcs34a.png" alt="   "><br><p>    -,   - <code>@:markup</code>    ,     . </p><br><img src="https://habrastorage.org/webt/pg/ek/2w/pgek2wa4v-ocjxauyq6e9oopvfc.png" alt="      untyped-"><br><p>               (  <code>untyped</code> ).           . ,   ,  <code>Js.build()</code>     - <code>@:markup</code>     ,        <code>&lt;js&gt;</code> ,     js-. </p><br><img src="https://habrastorage.org/webt/gk/vd/1f/gkvd1f3duuldpzde1zmmgvwbkza.png" alt=" -  - "><br><p>  Haxe 4     -  - ,    ‚Äî       . </p><br><img src="https://habrastorage.org/webt/br/gp/0c/brgp0cim1eozg7jjcopjmtx1xys.png" alt="Generaci√≥n autom√°tica de valor para enumeraciones abstractas."><br><p>       .  ,        .   ,   <code>Int</code> ,      ,    C. </p><br><img src="https://habrastorage.org/webt/cj/3g/lf/cj3glfbn9l5owjjunjtrsn2jzvw.png" alt="Generaci√≥n autom√°tica de valor para enumeraciones abstractas."><br><p>         ‚Äî       . </p><br><p> <b>     :</b> </p><br><img src="https://habrastorage.org/webt/y4/hl/fw/y4hlfwwz_db02rgmsj4f1jgw6r8.png" alt="Generar bytecode JVM directamente"><br><p>    JVM-   JDK,            Java-.    .         . </p><br><img src="https://habrastorage.org/webt/wj/ut/_z/wjut_zypg87r1f508zovsks2dio.png" alt="Corutinas"><br><p>      ,     <code>async</code> / <code>await</code>  <code>yield</code> .       (   C#,       ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>     Haxe    github. </p><br><img src="https://habrastorage.org/webt/ou/7r/gh/ou7rghzmynbwwvah6l7rumqpl8i.png" alt="Caracter√≠sticas disponibles a nivel de m√≥dulo"><br><p>  Haxe  <a href="">,    </a> .     ( )     .        ,    . </p><br><img src="https://habrastorage.org/webt/ty/y4/xw/tyy4xwdn9olejstawrdlqbux_tu.png" alt="API asincr√≥nica para trabajar con recursos del sistema"><br><p>       API     .     ,   ,    API    . </p><br><p>      Haxe 4  ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455389/">https://habr.com/ru/post/455389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455375/index.html">Escribiendo UDR en Pascal</a></li>
<li><a href="../455377/index.html">Arquitectura IoT</a></li>
<li><a href="../455379/index.html">(Est√°tica) Selecci√≥n de contenedores √≥ptimos en programas C ++</a></li>
<li><a href="../455381/index.html">El soporte t√©cnico de 3CX responde: captura el tr√°fico SIP en el servidor PBX</a></li>
<li><a href="../455387/index.html">Comprensi√≥n del aprendizaje autom√°tico en Elastic Stack (tambi√©n conocido como Elasticsearch, tambi√©n conocido como ELK)</a></li>
<li><a href="../455391/index.html">Parte 1: RISC-V / RocketChip en un h√°bitat antinatural</a></li>
<li><a href="../455393/index.html">Sobre el uso de m√©todos param√©tricos de estimaci√≥n espectral en radar: el m√©todo MUSIC. Adici√≥n al art√≠culo.</a></li>
<li><a href="../455397/index.html">C√≥mo dise√±amos e implementamos la nueva red en Huawei en la oficina de Mosc√∫, parte 1</a></li>
<li><a href="../455401/index.html">Tcl para Cisco IOS en ejemplos simples</a></li>
<li><a href="../455403/index.html">De cinco centavos al juego de las deidades</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>