<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÑÔ∏è üõë üìÅ M√©thodes num√©riques pour r√©soudre des syst√®mes d'√©quations non lin√©aires üëâüèª ü•´ üéÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 De nombreux probl√®mes appliqu√©s obligent √† trouver une solution g√©n√©rale √† un syst√®me d'√©quations non lin√©aires. Aucune solution analyt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©thodes num√©riques pour r√©soudre des syst√®mes d'√©quations non lin√©aires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419453/"><h3>  Pr√©sentation </h3><br>  De nombreux probl√®mes appliqu√©s obligent √† trouver une solution g√©n√©rale √† un syst√®me d'√©quations non lin√©aires.  Aucune solution analytique g√©n√©rale du syst√®me d'√©quations non lin√©aires n'a √©t√© trouv√©e.  Il n'y a que des m√©thodes num√©riques. <br><br>  Il convient de noter un fait int√©ressant que tout syst√®me d'√©quations sur des nombres r√©els peut √™tre repr√©sent√© par une √©quation √©quivalente, si nous prenons toutes les √©quations sous la forme <img src="https://habrastorage.org/webt/_q/09/hw/_q09hw6d1qeqerbgr7qhzfdcdfy.png">  , placez-les et pliez-les. <br><br>  Pour la solution num√©rique, des m√©thodes it√©ratives d'approximations successives (it√©ration simple) et la m√©thode de Newton dans diverses modifications sont utilis√©es.  Les processus it√©ratifs sont naturellement g√©n√©ralis√©s au cas d'un syst√®me d'√©quations non lin√©aires de la forme: <br><br><img src="https://habrastorage.org/webt/zf/ut/do/zfutdol9bhx0jy5lbge4jnfdjyk.png">  (1) <br><br>  D√©signer par <img src="https://habrastorage.org/webt/4b/fu/a_/4bfua_k_3kyr5w5cfxvmgxeat_y.png">  vecteur d'inconnues et d√©finir une fonction vectorielle <img src="https://habrastorage.org/webt/im/cc/m2/imccm2nlbj0rocyhlqidmboiwps.png">  Le syst√®me (1) s'√©crit alors sous la forme de l'√©quation: <br><br><img src="https://habrastorage.org/webt/5q/py/ph/5qpyphhrxupuofyzbeoxk8jviti.png">  (2) <br><br>  Maintenant, revenons √† notre Python bien-aim√© et notons sa primaut√© parmi les langages de programmation qui veulent apprendre [1]. <br><br><img src="https://habrastorage.org/webt/bx/x7/vz/bxx7vzxbfwqa-iaa5buw36pvvim.png"><br><br>  Ce fait est une incitation suppl√©mentaire √† consid√©rer les m√©thodes num√©riques en Python.  Cependant, les amateurs de Python estiment que les fonctions de biblioth√®que sp√©ciales, telles que <b>scipy.optimize.root, spsolve_trianular, newton_krylov</b> , sont le meilleur choix pour r√©soudre les probl√®mes par des m√©thodes num√©riques. <br><br>  Il est difficile d'√™tre en d√©saccord avec cela, ne serait-ce que parce que la vari√©t√© des modules a √©galement √©lev√© Python au sommet de la popularit√©.  Cependant, il existe des cas o√π, m√™me avec un examen superficiel, l'utilisation de m√©thodes connues directes sans utiliser les fonctions sp√©ciales de la biblioth√®que SciPy donne √©galement de bons r√©sultats.  En d'autres termes, le nouveau est l'ancien bien oubli√©. <br><a name="habracut"></a><br>  Ainsi, dans la publication [2], bas√©e sur les exp√©riences de calcul effectu√©es, il a √©t√© prouv√© que la fonction de biblioth√®que newton_krylov, con√ßue pour r√©soudre de grands syst√®mes d'√©quations non lin√©aires, a la moiti√© de la vitesse que l'algorithme TSLS + WD <br>  (moindres carr√©s en deux √©tapes) impl√©ment√© par la biblioth√®que NumPy. <br><br>  <b>Le but de cette publication</b> est de comparer le nombre d'it√©rations, la vitesse et, surtout, le r√©sultat de la r√©solution d'un probl√®me de mod√®le sous la forme d'un syst√®me de cent √©quations alg√©briques non lin√©aires √† l'aide de la fonction de biblioth√®que scipy.optimize.root et de la m√©thode de Newton impl√©ment√©e √† l'aide de la biblioth√®que NumPy. <br><br><h3>  Capacit√©s du solveur Scipy.optimize.root pour la r√©solution num√©rique de syst√®mes d'√©quations non lin√©aires alg√©briques </h3><br>  La fonction de biblioth√®que scipy.optimize.root a √©t√© choisie comme base de comparaison car elle poss√®de une vaste biblioth√®que de m√©thodes adapt√©es √† l'analyse comparative. <br><br>  <b>scipy.optimize.root</b> ( <i>fun, x0, args = (), method = 'hybr', jac = None, tol = None, callback = None, ptions = None</i> ) <br>  <i>fun</i> - Une fonction vectorielle pour trouver la racine. <br>  <i>x0</i> est la condition initiale de la recherche de racines <br><br>  <b>m√©thode:</b> <br>  <i>hybr -</i> modification Powell de la m√©thode hybride est utilis√©e; <br>  <i>lm</i> - r√©sout des syst√®mes d'√©quations non lin√©aires en utilisant la m√©thode des moindres carr√©s. <br>  Comme il ressort de la documentation [3], les m√©thodes <b>broyden1, broyden2, anderson, linearmixing, diagbroyden, passionmixing, krylov</b> sont les m√©thodes exactes de Newton.  Les param√®tres restants sont ¬´facultatifs¬ª et peuvent √™tre trouv√©s dans la documentation. <br><br><h3>  M√©thodes de r√©solution de syst√®mes d'√©quations non lin√©aires </h3><br>  Le mat√©riel donn√© ci-dessous peut en effet √™tre lu dans la litt√©rature, par exemple, dans [4], mais je respecte mon lecteur et, pour sa commodit√©, je pr√©sente la d√©rivation de la m√©thode sous une forme abr√©g√©e, si possible.  Ceux qui <b>n'aiment pas les formules</b> sautent cette section. <br><br>  Dans la m√©thode de Newton, une nouvelle approximation pour r√©soudre le syst√®me d'√©quations (2) est d√©termin√©e √† partir de la solution du <b>syst√®me d'√©quations lin√©aires</b> : <br><br><img src="https://habrastorage.org/webt/oc/q3/_y/ocq3_yonljteqeoun-ep0euxsai.png">  (3) <br><br>  D√©finissez la matrice de Jacobi: <br><br><img src="https://habrastorage.org/webt/iu/60/s-/iu60s-ro-taedqwb3fltgypmspu.png">  (4) <br><br>  Nous √©crivons (3) sous la forme: <br><br><img src="https://habrastorage.org/webt/gj/be/vm/gjbevmxcuhihbxakq57qfxsok6w.png">  (5) <br><br>  De nombreuses m√©thodes en une √©tape pour une solution approximative de (2) par analogie avec des m√©thodes it√©ratives √† deux couches pour r√©soudre des syst√®mes d'√©quations alg√©briques lin√©aires peuvent √™tre √©crites sous la forme: <br><br><img src="https://habrastorage.org/webt/sl/fu/fq/slfufq8wc4qnfmmeclx64qpubjw.png">  (6) <br><br>  o√π <img src="https://habrastorage.org/webt/pa/t0/0a/pat00a2ixfo34e_vfqtlgf_gchg.png">  Les param√®tres it√©ratifs sont-ils <img src="https://habrastorage.org/webt/ta/xt/2z/taxt2zyydbeigde-xcqhry0wrtq.png">  - une matrice carr√©e n x n ayant l'inverse. <br><br>  Lors de l'utilisation de l'enregistrement (6), la m√©thode de Newton (5) correspond au choix: <br><br><img src="https://habrastorage.org/webt/n5/ii/zu/n5iizujlep0bnryijprpz8-bary.png"><br><br>  Le syst√®me d'√©quations lin√©aires (5) pour trouver une nouvelle approximation <img src="https://habrastorage.org/webt/so/88/h5/so88h5-fmrzbs-aplenlaar3oo4.png">  peut √™tre r√©solu de mani√®re it√©rative.  Dans ce cas, nous avons un processus it√©ratif en deux √©tapes avec des it√©rations externes et internes.  Par exemple, un processus it√©ratif externe peut √™tre effectu√© selon la m√©thode de Newton, et des it√©rations internes peuvent √™tre effectu√©es sur la <b>base de la m√©thode it√©rative Seidel.</b> <br><br>  Lors de la r√©solution de syst√®mes d'√©quations non lin√©aires, on peut utiliser des analogues directs des m√©thodes it√©ratives standard utilis√©es pour r√©soudre des syst√®mes d'√©quations lin√©aires.  La m√©thode non lin√©aire de Seidel appliqu√©e √† la solution (2) donne: <br><br><img src="https://habrastorage.org/webt/hx/lf/wk/hxlfwknytaf-n4yc3njkqjjx6lo.png">  (7) <br><br>  Dans ce cas, chaque composante de la nouvelle approximation √† partir de la solution de l'√©quation non lin√©aire peut √™tre obtenue sur la base de la m√©thode d'it√©ration simple et de la m√©thode de Newton dans diverses modifications.  Ainsi, nous arrivons √† nouveau √† une m√©thode it√©rative en deux √©tapes dans laquelle les it√©rations externes sont effectu√©es conform√©ment √† la m√©thode Seidel, et les it√©rations internes sont effectu√©es en utilisant la m√©thode Newton. <br><br>  Les principales difficult√©s de calcul dans l'application de la m√©thode de Newton pour la solution approximative de syst√®mes d'√©quations non lin√©aires <b>sont li√©es √† la n√©cessit√© de r√©soudre un syst√®me d'√©quations lin√©aire avec une matrice de Jacobi √† chaque it√©ration</b> , et cette matrice change d'it√©ration en it√©ration.  Dans la m√©thode de Newton modifi√©e, la matrice de Jacobi n'est invers√©e qu'une seule fois: <br><br><img src="https://habrastorage.org/webt/y-/0p/tv/y-0ptvinni3bzhzirltojgjxkxc.png">  (8) <br><br><h3>  S√©lection de la fonction du mod√®le </h3><br>  Un tel choix n'est pas une t√¢che simple, car avec une augmentation du nombre d'√©quations dans le syst√®me en fonction d'une augmentation du nombre de variables, le r√©sultat de la solution ne devrait pas changer, car sinon il est impossible de suivre l'exactitude de la solution du syst√®me d'√©quations lors de la comparaison de deux m√©thodes.  J'apporte la solution suivante pour la fonction mod√®le: <br><br><pre><code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  <b>La fonction f cr√©e un syst√®me de n √©quations non lin√©aires, dont la solution ne d√©pend pas du nombre d'√©quations et est √©gale √† l'unit√© pour chacune des n variables.</b> <br><br><h3>  Un programme pour tester une fonction de mod√®le avec les r√©sultats de la r√©solution d'un syst√®me d'√©quations non lin√©aires alg√©briques en utilisant la fonction de biblioth√®que Optimize.root pour diff√©rentes m√©thodes de recherche de racines </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) sol = optimize.root(f,x0, method=<span class="hljs-string"><span class="hljs-string">'krylov'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, sol.x) print(<span class="hljs-string"><span class="hljs-string">'Krylov method iteration = '</span></span>,sol.nit) print(<span class="hljs-string"><span class="hljs-string">'Optimize root time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br>  Seule l' une des m√©thodes d√©crites dans les documents [3] a pass√© le <b>test par le r√©sultat de la fonction de mod√®le de d√©cision, cette m√©thode 'Krylov.</b> <br><br>  Solution pour n = 100: <br><br>  Solution: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  It√©ration de la m√©thode de Krylov = 4219 <br>  Optimiser le temps root 7,239 secondes: <br><br><div class="spoiler">  <b class="spoiler_title">Solution pour n = 200</b> <div class="spoiler_text">  Solution: <br>  [1,00000018 0,99999972 0,99999985 1,00000001 0,99999992 1,00000049 <br>  0,99999998 0,99999992 0,99999991 1,00000001 1,00000013 1,00000002 <br>  0,9999997 0,99999987 1,00000005 0,99999978 1,0000002 1,00000012 <br>  1,00000023 1,00000017 0,99999979 1,00000012 1,00000026 0,99999987 <br>  1,00000014 0,99999979 0,99999988 1,00000046 1,00000064 1,00000007 <br>  1.00000049 1.00000005 1.00000032 1.00000031 1.00000028 0.99999992 <br>  1.0000003 1.0000001 0.99999971 1.00000023 1.00000039 1.0000003 <br>  1,00000013 0,9999999 0,99999993 0,99999996 1,00000008 1,00000016 <br>  1,00000034 1,00000004 0,99999993 0,99999987 0,99999969 0,99999985 <br>  0,99999981 1,00000051 1,0000004 1,00000035 0,9999998 1,00000065 <br>  1.00000061 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.00000059 1.00000056 <br>  1,00000047 1,00000016 1,00000018 0,99999988 1,00000061 1,00000002 <br>  1.00000033 1.00000034 1.0000004 1.00000046 1.00000009 1.00000024 <br>  1,00000017 1,00000014 1,00000054 1,00000006 0,99999964 0,99999968 <br>  1.00000005 1.00000049 1.0000005 1.00000028 1.00000029 1.00000027 <br>  1,00000027 0,9999998 1,00000005 0,99999974 0,99999978 0,99999988 <br>  1,00000015 1,00000007 1,00000005 0,99999973 1,00000006 0,99999995 <br>  1.00000021 1.00000031 1.00000058 1.00000023 1.00000023 1.00000044 <br>  0,99999985 0,99999948 0,99999977 0,99999991 0,99999974 0,99999978 <br>  0,99999983 1,0000002 1,00000016 1,00000008 1,00000013 1,00000007 <br>  0,99999989 0,99999959 1,00000029 1,0000003 0,99999972 1,00000003 <br>  0,99999967 0,99999977 1,00000017 1,00000005 1,00000029 1,00000034 <br>  0,99999997 0,99999989 0,99999945 0,99999985 0,99999994 0,99999972 <br>  1.00000029 1.00000016] <br>  It√©ration de la m√©thode de Krylov = 9178 <br>  Optimiser le temps root 23,397 secondes <br></div></div><br>  <b>Conclusion:</b> Avec une augmentation du nombre d'√©quations de moiti√©, l'apparition d'erreurs dans la solution est perceptible.  Avec une nouvelle augmentation de n, la solution devient inacceptable, ce qui est possible du fait de l'adaptation automatique √† l'√©tape, m√™me raison d'une forte baisse des performances.  Mais c'est juste ma supposition. <br><br><h3>  Un programme pour tester une fonction de mod√®le avec les r√©sultats de la r√©solution d'un syst√®me d'√©quations alg√©briques non lin√©aires en utilisant un programme √©crit en Python 3 en tenant compte des relations (1) - (8) pour trouver les racines en utilisant la m√©thode de Newton modifi√©e </h3><br><div class="spoiler">  <b class="spoiler_title">Le programme de recherche de racines selon la m√©thode de Newton modifi√©e</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jacobian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x)</span></span></span><span class="hljs-function">:</span></span> h = <span class="hljs-number"><span class="hljs-number">1.0e-4</span></span> n = len(x) Jac = zeros([n,n]) f0 = f(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n,<span class="hljs-number"><span class="hljs-number">1</span></span>): tt = x[i] x[i] = tt + h f1= f(x) x[i] = tt Jac [:,i] = (f1 - f0)/h <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Jac, f0 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x, tol=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0e-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> iterMax = <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(iterMax): Jac, fO = jacobian(f, x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sqrt(dot(fO, fO) / len(x)) &lt; tol: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x, i dx = linalg.solve(Jac, fO) x = x - dx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"Too many iterations for the Newton method"</span></span>) n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) x, iter = newton(f, x0) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, x) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Newton iteration = '</span></span>, iter) print(<span class="hljs-string"><span class="hljs-string">'Newton method time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br></div></div><br>  Solution pour n = 100: <br><br>  Solution: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  It√©ration de Newton = 13 <br>  Temps de la m√©thode de Newton 0,496 seconde <br><br>  Solution pour n = 200: <br><br>  Solution: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  It√©ration de Newton = 14 <br>  Temps de la m√©thode de Newton 1.869 secondes <br><br>  Pour vous assurer que le programme r√©sout vraiment le syst√®me, nous r√©√©crivons la fonction mod√®le pour √©viter la racine avec une valeur de 1 sous la forme: <br><br><pre> <code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i]*sin([i]) - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>+e**-x[i] f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  Nous obtenons: <br>  Solution: <br>  [0,96472166 0,87777036 0,48175823 -0,26190496 -0,63693762 0,49232062 <br>  -1,31649896 0,6865098 0,89609091 0,98509235] <br>  It√©ration de Newton = 16 <br>  Temps de la m√©thode de Newton 0,046 seconde <br><br>  Conclusion: <b>Le programme fonctionne √©galement lorsque la fonction de mod√®le change.</b> <br><br>  Maintenant, nous revenons √† la fonction de mod√®le initiale et v√©rifions une plage plus large pour n, par exemple, √† 2 et 500. <br>  n = 2 <br>  Solution: <br>  [1.  1.] <br>  It√©ration de Newton = 6 <br>  Temps de la m√©thode de Newton 0,048 seconde <br>  n = 500 <br><div class="spoiler">  <b class="spoiler_title">n = 500</b> <div class="spoiler_text">  Solution: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  It√©ration de Newton = 15 <br>  Temps de la m√©thode de Newton 11,754 secondes <br></div></div><br><h3>  Conclusions: </h3><br>  Un programme √©crit en Python utilisant la m√©thode de Newton modifi√©e, lors de la r√©solution de syst√®mes d'√©quations non lin√©aires √† partir de la fonction de mod√®le donn√©e, a plus de stabilit√© de solution que lors de la r√©solution en utilisant la fonction de biblioth√®que Optimize.root (f, x0, method = 'krylov') pour la m√©thode Krylov.  En ce qui concerne la vitesse de la conclusion finale, il est impossible de tirer en raison de l'approche diff√©rente du contr√¥le de pas. <br><br>  R√©f√©rences: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âvaluation des langages de programmation 2018.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cooper I.V., Faleychik B.V.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Processus it√©ratifs non matriciels avec suppression d'erreur quadratique moyenne pour les grands syst√®mes d'√©quations non lin√©aires.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scipy.optimize.root.</a> </li><li>  Vabishchevich P.N.  M√©thodes num√©riques: Atelier informatique.  - M.: Maison du livre "LIBROCOM", 2010. - 320 p. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419453/">https://habr.com/ru/post/fr419453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419441/index.html">SpaceX r√©utilise la premi√®re fus√©e Falcon 9 Block 5 aujourd'hui</a></li>
<li><a href="../fr419443/index.html">La NASA s'envolera √† nouveau vers la lune, rendant tous les √©l√©ments de l'avion</a></li>
<li><a href="../fr419445/index.html">Tests unitaires pour les projets Arduino</a></li>
<li><a href="../fr419449/index.html">API de contexte Redux vs React</a></li>
<li><a href="../fr419451/index.html">Cr√©ez pas √† pas un bundle pour Symfony 4</a></li>
<li><a href="../fr419457/index.html">RabbitMQ - SQL Server</a></li>
<li><a href="../fr419459/index.html">Batteries au plomb: alphabet de charge d'impulsion</a></li>
<li><a href="../fr419461/index.html">Ventilation des toilettes</a></li>
<li><a href="../fr419467/index.html">De l'ampoule √† l'aspirateur et au drone - comment nous avons appris √† Alice √† g√©rer des centaines d'appareils</a></li>
<li><a href="../fr419469/index.html">UE4 | Le cycle du jour et de la nuit | Modification de SkySphere</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>