<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🏭 👨🏻‍🍳 🏆 使用Python中的Tensorflow对卫星图像进行分类的神经网络 ✖️ 🤴🏾 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是对Landsat 5卫星的多光谱图像进行分类的分步说明，如今，在许多领域，深度学习已成为解决复杂问题（包括地理空间问题）的主要工具。 希望您熟悉卫星数据集，尤其是Landsat 5 TM。 如果您对机器学习算法有点熟悉，这将帮助您快速学习本手册。 对于那些不了解的人，只要知道机器学习实际上就是在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Python中的Tensorflow对卫星图像进行分类的神经网络</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/468973/"><img src="https://habrastorage.org/webt/uq/qc/uz/uqqcuz2dhxwps1cueikg6ceigja.jpeg"><br><br> 这是对Landsat 5卫星的多光谱图像进行分类的分步说明，如今，在许多领域，深度学习已成为解决复杂问题（包括地理空间问题）的主要工具。 希望您熟悉卫星数据集，尤其是Landsat 5 TM。 如果您对机器学习算法有点熟悉，这将帮助您快速学习本手册。 对于那些不了解的人，只要知道机器学习实际上就是在对象的几个特征（一组属性X）与其其他属性（值或标签，目标变量Y）之间建立关系就足够了。 我们为模型提供许多对象，这些对象的特征和目标指标/类别（标记数据）的值是已知的，并对其进行训练，以便它可以预测新数据（未标记）的目标变量Y的值。 <br><a name="habracut"></a><br> 卫星图像的主要问题是什么？ <br><br> 卫星图像中的两类或更多类对象（例如，建筑物，空地和基坑）可以具有相同的光谱值特征，因此，在过去的20年中，对其进行分类一直是一项艰巨的任务。 <br><br> 因此，可以在有老师和没有老师的情况下使用经典的机器学习模型，但是它们的质量将远远不够理想。 他们总是有相同的缺点。 考虑一个例子： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/16c/5b7/15b16c5b76906f81f27374daa8558806.jpg"><br><br> 如果使用垂直线作为分类器并沿X轴移动，则对房屋图像进行分类将不容易。 数据是分布式的，因此不可能使用一条垂直线将它们分为几类（在这种情况下，据说“不同类的对象不能线性分离”）。 但这并不意味着根本不能对房屋进行分类！ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/ea7/7a0/cc4ea77a0f9f4713ea6a49b7885d31c2.gif"><br><br> 让我们用红线将这两个类分开。 在这种情况下，分类器识别了大多数房屋，但是没有将一所房屋分配给其类别，并且另外三棵树被错误地分配给了“房屋”。 为了不错过一所房子，您可以使用蓝线形式的分类器。 然后，所有内容都会在家中覆盖，也就是说，召回率指标（丰满度）很高。 但是，并非所有分类值都证明是房屋，也就是说，与此同时，我们获得的精度指标值较低。 如果使用绿线，则所有分类为房屋的图像实际上都是房屋，也就是说，分类器将显示较高的准确性。 在这种情况下，丰满度会降低，因为这三座房屋将无法计算。 在大多数情况下，我们必须在准确性和完整性之间找到折衷方案。 <br><br> 房屋和树木的问题类似于建筑物，空地和坑的问题。 卫星图像分类指标的优先级可能因任务而异。 例如，如果您需要确保所有建成区都无一例外地被分类为建筑物，并且准备好接受具有相似签名的其他类别的像素（它们也将被分类为建筑物），那么您将需要一个具有高度完整性的模型。 而且，如果不对建筑物进行分类而又不添加其他类别的像素，这对您而言更为重要，并且您准备放弃对混合领土的分类，那么请选择具有较高准确性的分类器。 对于房屋和树木，通常的模型将使用红线，以保持准确性和完整性之间的平衡。 <br><br><h2> 使用数据 </h2><br> 作为标志，我们将使用Landsat 5 TM的图像的六个范围（波段2-波段7）的值，并尝试预测二进制显影类别。 为了进行培训和测试，将使用班加罗尔2011年Landsat 5的多光谱数据（图像和具有二进制建筑等级的图层）。 为了进行预测，将使用2005年在海得拉巴获得的多光谱Landsat 5数据。 <br> 由于我们将标记的数据用于教学，因此称为与老师一起教学。 <br><br><img src="https://habrastorage.org/webt/c4/nx/71/c4nx71fzbix6rhp4fb1-ofdupjm.jpeg"><br><br>  <i>多光谱训练数据和相应的二进制层一起发展。</i> <br><br> 为了创建神经网络，我们将使用Python – Google Tensorflow库。 我们还将需要以下库： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>pyrsgis-</i></a>用于读写GeoTIFF。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>scikit-learn-</i></a>用于数据预处理和准确性评估。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>numpy-</i></a>用于数组的基本操作。 <br></li></ol><br> 现在，不用多说，让我们来编写代码。 <br><br> 将所有三个文件放在目录中，在脚本中输入输入文件的路径和名称，然后读取GeoTIFF文件。 <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> raster os.chdir(<span class="hljs-string"><span class="hljs-string">"E:\\yourDirectoryName"</span></span>) mxBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_raw.tif'</span></span> builtupBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_builtup.tif'</span></span> mxHyderabad = <span class="hljs-string"><span class="hljs-string">'l5_Hyderabad2011_raw.tif'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read the rasters as array ds1, featuresBangalore = raster.read(mxBangalore, bands='all') ds2, labelBangalore = raster.read(builtupBangalore, bands=1) ds3, featuresHyderabad = raster.read(mxHyderabad, bands='all')</span></span></code> </pre> <br>  <code>pyrsgis</code>软件包中的<code>raster</code>模块读取GeoTIFF地理位置数据和数字编号（DN）值作为单独的NumPy数组。 如果您对细节感兴趣，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 <br><br> 现在，我们显示读取数据的大小。 <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br> 结果： <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1318</span></span>, <span class="hljs-number"><span class="hljs-number">1056</span></span></code> </pre> <br> 如您所见，班加罗尔的图像具有与二元图层（对应于建筑物）相同的行数和列数。 班加罗尔和海得拉巴的多光谱图像中的层数也重合。 模型将学习基于所有6个光谱的对应值来确定哪些像素属于建筑物，哪些像素不属于建筑物。 因此，多光谱图像必须具有以相同顺序列出的相同数量的特征（范围）。 <br><br> 现在，我们将数组变成二维的，其中每一行代表一个单独的像素，因为这对于大多数机器学习算法的操作都是必需的。 我们将使用<code>pyrsgis</code>软件包中的<code>convert</code>模块执行此操作。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/176/b91/d69176b91e9758291e1faae6c25486e5.jpg"><br>  <i>数据重组方案。</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis.convert <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> changeDimension featuresBangalore = changeDimension(featuresBangalore) labelBangalore = changeDimension (labelBangalore) featuresHyderabad = changeDimension(featuresHyderabad) nBands = featuresBangalore.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] labelBangalore = (labelBangalore == <span class="hljs-number"><span class="hljs-number">1</span></span>).astype(int) print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br> 结果： <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br> 在第七行中，我们提取了所有值为1的像素。这有助于避免没有信息的像素（NoData）出现问题，这些信息通常具有极高或极低的值。 <br> 现在，我们将数据分为训练样本和验证样本。 这是必要的，这样模型就不会看到测试数据，并且在新信息下也能很好地工作。 否则，将对模型进行重新训练，并且仅在训练数据上才能很好地工作。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split xTrain, xTest, yTrain, yTest = train_test_split(featuresBangalore, labelBangalore, test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>) print(xTrain.shape) print(yTrain.shape) print(xTest.shape) print(yTest.shape)</code> </pre> <br> 结果： <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">2519025</span></span>,) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>,) test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span></code> </pre> <br> 表示将数据按60/40的比例分为训练和验证。 <br> 许多机器学习算法，包括神经网络，都需要规范化的数据。 这意味着它们必须在给定范围内分配（在这种情况下，从0到1）。 因此，为了满足此要求，我们将症状标准化。 可以通过提取最小值，然后将其除以价差（最大值和最小值之间的差）来完成。 由于Landsat数据集是八位的，因此最小值和最大值将分别为0和255（ <sup>2⁸</sup> = 256个值）。 <br><br> 请注意，为了进行标准化，总是最好根据数据计算最小值和最大值。 为了简化任务，默认情况下，我们将遵循八位范围。 <br><br> 初步处理的另一个阶段是将符号矩阵从二维转换为三维，以便模型将每一行视为一个单独的像素（一个单独的学习对象）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/d0f/aa8/965d0faa8e8c7b4787c10823cf038d20.jpg"><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Normalise the data xTrain = xTrain / 255.0 xTest = xTest / 255.0 featuresHyderabad = featuresHyderabad / 255.0 # Reshape the data xTrain = xTrain.reshape((xTrain.shape[0], 1, xTrain.shape[1])) xTest = xTest.reshape((xTest.shape[0], 1, xTest.shape[1])) featuresHyderabad = featuresHyderabad.reshape((featuresHyderabad.shape[0], 1, featuresHyderabad.shape[1])) # Print the shape of reshaped data print(xTrain.shape, xTest.shape, featuresHyderabad.shape)</span></span></code> </pre> <br> 结果： <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br> 一切准备就绪，让我们与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">keras</a>组装模型。 首先，让我们使用顺序模型，一个接一个地添加图层。 我们将有一个输入层，其节点数等于范围数（ <code>nBands</code> ）-在我们的示例中为6。我们还将使用一个包含14个节点和<code>ReLu</code>激活<code>ReLu</code>隐藏层。 最后一层由两个节点组成，这些节点用于使用<code>softmax</code>激活<code>softmax</code>定义一个二进制建筑类，适用于显示分类结果。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关激活功能的更多信息。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-comment"><span class="hljs-comment"># Define the parameters of the model model = keras.Sequential([ keras.layers.Flatten(input_shape=(1, nBands)), keras.layers.Dense(14, activation='relu'), keras.layers.Dense(2, activation='softmax')]) # Define the accuracy metrics and parameters model.compile(optimizer="adam", loss="sparse_categorical_crossentropy", metrics=["accuracy"]) # Run the model model.fit(xTrain, yTrain, epochs=2)</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/9cd/5ec/d8a9cd5ec53c57d671d77b0c46bfb17e.png"><br>  <i>神经网络架构</i> <br><br> 如第10行所述，我们将<code>adam</code>指定为模型优化器（还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他</a>几个）。 在这种情况下，我们将交叉熵用作损失函数（例如， <code>categorical-sparse-crossentropy</code>交叉熵-有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>内容，请<code>categorical-sparse-crossentropy</code> ）。 为了评估模型的质量，我们将使用<code>accuracy</code>指标。 <br><br> 最后，我们将开始在<code>xTrain</code>和<code>yTrain</code>上训练两个时代（或迭代）的<code>yTrain</code> 。 这将需要一些时间，具体取决于数据的大小和处理能力。 编译后将显示以下内容： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/3fc/c47/dfa3fcc47572b2fd20c5252ba4da1e50.png"><br><br> 让我们预测分别存储的验证数据的值，并计算各种准确性指标。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusion_matrix, precision_score, recall_score <span class="hljs-comment"><span class="hljs-comment"># Predict for test data yTestPredicted = model.predict(xTest) yTestPredicted = yTestPredicted[:,1] # Calculate and display the error metrics yTestPredicted = (yTestPredicted&gt;0.5).astype(int) cMatrix = confusion_matrix(yTest, yTestPredicted) pScore = precision_score(yTest, yTestPredicted) rScore = recall_score(yTest, yTestPredicted) print("Confusion matrix: for 14 nodes\n", cMatrix) print("\nP-Score: %.3f, R-Score: %.3f" % (pScore, rScore))</span></span></code> </pre> <br>  <code>softmax</code>函数为每个类别的概率值生成单独的列。 从上面代码的第六行可以看出，我们仅使用第一类的值（“有建筑物”）。 与其他经典的机器学习问题不同，评估地理空间分析模型的工作并不那么简单。 依靠广义的总误差将是不公平的。 成功的模型的关键是空间布局。 因此，混淆矩阵，准确性和完整性可以对模型的质量给出更正确的想法。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/3d8/bf3/3993d8bf36a5f4165b60f39e36e5c566.jpg"><br>  <i>因此，控制台将显示错误矩阵，准确性和完整性。</i> <br><br> 从混淆矩阵中可以看到，有成千上万个与建筑物相关的像素，但分类不同，反之亦然。 但是，它们在总数据量中所占的份额并不太大。 测试数据的准确性和完整性超过了阈值0.8。 <br><br> 您可以花费更多时间并执行几次迭代，以找到最佳的隐藏层数，每个隐藏层中的节点数，以及达到所需精度的时代数。 根据需要，可以将诸如NDBI或NDWI之类的遥感指数用作特征。 当达到所需的精度时，可使用该模型根据新数据预测开发并将结果导出到GeoTIFF。 对于此类任务，您可以使用具有较小更改的类似模型。 <br><br><pre> <code class="python hljs">predicted = model.predict(feature2005) predicted = predicted[:,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">#Export raster prediction = np.reshape(predicted, (ds.RasterYSize, ds.RasterXSize)) outFile = 'Hyderabad_2011_BuiltupNN_predicted.tif' raster.export(prediction, ds3, filename=outFile, dtype='float')</span></span></code> </pre> <br> 请注意，我们导出的GeoTIFF具有预测的概率值，而不是其阈值二值化版本。 稍后在GIS环境中，我们可以设置float类型的图层的阈值，如下图所示。 <br><br><img src="https://habrastorage.org/webt/sk/ka/kz/skkakzxokrbkvrgulcvm0vkuwua.jpeg"><br>  <i>该模型基于多光谱数据对海得拉巴的堆积层进行了预测。</i> <br><br> 模型的准确性已经通过精确度和召回率进行了测量。 您还可以在新的预测图层上执行传统检查（例如，使用kappa系数）。 除了上述的卫星图像分类困难之外，其他明显的局限性还包括不可能基于一年中不同时间和不同区域拍摄的图像进行预测，因为它们将具有不同的光谱特征。 <br><br> 本文中描述的模型具有用于神经网络的最简单的体系结构。 使用更复杂的模型（包括卷积神经网络）可以获得更好的结果。 这种分类的主要优点是训练模型后的可伸缩性（适用性）。 <br><br> 使用的数据和所有代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468973/">https://habr.com/ru/post/zh-CN468973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468961/index.html">如何摆脱560美元的生活习惯？ 或如何生活，而不是生活</a></li>
<li><a href="../zh-CN468963/index.html">备份，应读者要求提供一部分：UrBackup概述，BackupPC，AMANDA</a></li>
<li><a href="../zh-CN468967/index.html">获得TAU动力学方程的“技术”。 以及为什么系统识别很烂，并且“诚实的物理学”规则</a></li>
<li><a href="../zh-CN468969/index.html">通过API从PowerShell创建Google用户</a></li>
<li><a href="../zh-CN468971/index.html">用Java为Nintendo DS编写</a></li>
<li><a href="../zh-CN468989/index.html">UEBA市场消失-UEBA万岁</a></li>
<li><a href="../zh-CN468991/index.html">模块化精灵字符及其动画</a></li>
<li><a href="../zh-CN468993/index.html">Oculus Quest连接到PC并看到手</a></li>
<li><a href="../zh-CN468995/index.html">开放性政策：用户如何影响项目</a></li>
<li><a href="../zh-CN468997/index.html">指导-必须获得还是不错的奖励？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>