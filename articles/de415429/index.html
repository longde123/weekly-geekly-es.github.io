<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèæ üë®üèø‚Äçüé® üöÄ Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 5. Aufgabeninteraktion und Synchronisation üë≠ üìº üëô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln haben wir das Multitasking-Modell untersucht und festgestellt, dass jede Aufgabe ein quasi unabh√§ngiges Programm ist. Obwohl Aufg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 5. Aufgabeninteraktion und Synchronisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415429/"><img src="https://habrastorage.org/webt/b6/2h/cm/b62hcmzcfpnzqg0tz4pzveimzmw.jpeg"><br><br>  In fr√ºheren Artikeln haben wir das Multitasking-Modell untersucht und festgestellt, dass jede Aufgabe ein quasi unabh√§ngiges Programm ist.  Obwohl Aufgaben in eingebetteten Systemen ein gewisses Ma√ü an Unabh√§ngigkeit aufweisen, bedeutet dies nicht, dass sie sich nicht ‚Äûkennen‚Äú.  Einige Aufgaben sind wirklich von anderen isoliert, aber Interaktion und Synchronisation zwischen ihnen sind eine h√§ufige Anforderung.  Dieser Mechanismus ist eine der Schl√ºsselfunktionen des RTOS.  Der Funktionsumfang kann je nach RTOS variieren. In diesem Artikel werden daher √∂ffentlich verf√ºgbare Optionen betrachtet. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h3>  <b>Funktionsbereich</b> </h3><br>  Es gibt drei Modelle f√ºr die Interaktion und Synchronisation zwischen Aufgaben: <br><br><ul><li>  Dienste sind an Aufgaben gebunden: RTOS stellt Aufgaben mit Attributen bereit, die eine Interaktion zwischen ihnen erm√∂glichen.  Betrachten Sie Signale als Beispiel. </li><li>  Kernelobjekte sind autonome Kommunikations- oder Synchronisationsmittel.  Beispiele: Ereignisflags, Postf√§cher, Warteschlangen / Kan√§le, Semaphoren und Mutexe. </li><li>  Messaging ist ein optimiertes Schema, mit dem Sie mit dem RTOS Nachrichtenobjekte erstellen und von einer Aufgabe auf eine andere oder mehrere √ºbertragen k√∂nnen.  Dies ist f√ºr die Architektur des Kernels von grundlegender Bedeutung, und daher wird ein solches System als "Messaging-RTOS" bezeichnet. </li></ul><br>  Die Mechanismen, die f√ºr verschiedene Prozesse ideal sind, variieren.  Ihre Funktionen k√∂nnen sich √ºberschneiden. Es lohnt sich daher, die Skalierbarkeit dieser Modelle zu ber√ºcksichtigen.  Wenn f√ºr eine Anwendung beispielsweise mehrere Warteschlangen, jedoch nur ein Postfach erforderlich sind, k√∂nnen Sie ein Postfach mit einer Warteschlange f√ºr ein Element implementieren.  Dieses Objekt ist nicht vollst√§ndig optimal, aber der gesamte Code des Postfachs wird nicht in die Anwendung aufgenommen, und daher verringert die Skalierbarkeit die vom RTOS verwendete Speichermenge. <br><br><h3>  <b>Gemeinsame Variablen oder Speicherbereiche</b> </h3><br>  Ein vereinfachter Ansatz f√ºr die Interaktion zwischen Aufgaben ist das Vorhandensein von Variablen oder Speicherbereichen im System, die f√ºr alle Aufgaben verf√ºgbar sind.  Dieser Ansatz kann trotz seiner Einfachheit auf mehrere Prozesse angewendet werden.  Der Zugang muss kontrolliert werden.  Wenn die Variable nur ein Byte ist, ist das Schreiben oder Lesen wahrscheinlich eine atomare Operation (d. H. Kontinuierlich), aber es muss vorsichtig vorgegangen werden, wenn der Prozessor andere Operationen an Speicherbytes zul√§sst, da diese unterbrechbar sein und auftreten k√∂nnen Synchronisationsproblem.  Eine M√∂glichkeit, das Sperren / Entsperren zu implementieren, besteht darin, Interrupts f√ºr kurze Zeit zu deaktivieren. <br><br>  Wenn Sie einen Speicherbereich verwenden, ben√∂tigen Sie noch eine Sperre.  Sie k√∂nnen das erste Byte als Blockierungsflag verwenden, da die Speicherarchitektur atomaren Zugriff auf dieses Byte bietet.  Eine Aufgabe l√§dt Daten in einen Speicherbereich, setzt ein Flag und wartet darauf, dass sie zur√ºckgesetzt werden.  Eine andere Aufgabe besteht darin, auf das Setzen des Flags zu warten, Daten zu lesen und das Flag zur√ºckzusetzen.  Die Verwendung der Interrupt-Deaktivierung als Sperre ist weniger sinnvoll, da das Verschieben des gesamten Datenpuffers einige Zeit dauern kann. <br><br>  Diese Verwendung von gemeinsam genutztem Speicher √§hnelt der Implementierung vieler Interprozessorkommunikationen in Mehrkernsystemen.  In einigen F√§llen sind Hardware-Sperren und / oder Unterbrechungen in die Interprozessor-Schnittstelle des gemeinsam genutzten Speichers integriert. <br><br><h3>  <b>Signale</b> </h3><br>  Signale sind einer der einfachsten Mechanismen f√ºr die Interaktion zwischen Aufgaben, die von herk√∂mmlichen RTOS angeboten werden.  Sie enthalten eine Reihe von Bit-Flags (8, 16 oder 32, je nach Anwendung), die einer bestimmten Aufgabe zugeordnet sind. <br>  Das Signalflag (oder mehrere Flags) kann von jeder Task mit der logischen Operation "OR" gesetzt werden.  Flag (s) k√∂nnen nur von einer Aufgabe gelesen werden, die ein Signal enth√§lt.  Der Lesevorgang ist normalerweise destruktiv, dh die Flags werden ebenfalls zur√ºckgesetzt. <br>  In einigen Systemen werden Signale auf komplexere Weise implementiert, so dass eine vom Task-Eigent√ºmer des Signals zugewiesene Sonderfunktion automatisch ausgef√ºhrt wird, wenn Signalflags gesetzt werden.  Dadurch muss die Aufgabe die Flags selbst nicht mehr steuern.  Dies √§hnelt in gewisser Weise einem Interrupt-Handler. <br><br><h3>  <b>Ereignisflag-Gruppen</b> </h3><br>  Gruppen von Ereignisflags √§hneln Signalen darin, dass sie ein bitorientiertes Werkzeug f√ºr die Interaktion zwischen Aufgaben sind.  Ebenso k√∂nnen sie 8, 16 oder 32 Bit enthalten.  Im Gegensatz zu Signalen sind sie unabh√§ngige Kernobjekte und geh√∂ren keiner bestimmten Aufgabe an.  Jede Aufgabe kann Ereignisflags mit den logischen Operationen "ODER" und "UND" setzen und zur√ºcksetzen.  Ebenso kann jede Aufgabe Ereignisflags mit denselben Operationen √ºberpr√ºfen.  In vielen RTOS k√∂nnen Sie einen blockierenden API-Aufruf f√ºr eine Kombination von Ereignisflags ausf√ºhren.  Das hei√üt, die Aufgabe kann angehalten werden, bis eine bestimmte Kombination von Ereignisflags gesetzt ist.  Die Option "verbrauchen" ist m√∂glicherweise auch verf√ºgbar, wenn Ereignisflags √ºberpr√ºft werden, wodurch alle Flags zur√ºckgesetzt werden. <br><br><h3>  <b>Semaphoren</b> </h3><br>  Semaphoren sind unabh√§ngige Kernelobjekte, die f√ºr die Ressourcenabrechnung verwendet werden.  Es gibt zwei Arten von Semaphoren: bin√§r (kann nur zwei Werte haben) und allgemein (unbegrenzte Anzahl von Werten).  Einige Prozessoren unterst√ºtzen (atomare) Anweisungen, die die schnelle Implementierung von bin√§ren Semaphoren erleichtern.  Bin√§re Semaphore k√∂nnen als allgemeine Semaphoren mit dem Wert 1 implementiert werden. <br><br>  Jede Aufgabe kann versuchen, ein Semaphor zuzuweisen, um Zugriff auf die Ressource zu erhalten.  Wenn der aktuelle Wert des Semaphors gr√∂√üer als 0 ist (das Semaphor ist frei), wird der Z√§hlerwert um 1 reduziert, daher ist die Zuweisung erfolgreich.  In vielen Betriebssystemen kann ein Sperrmechanismus verwendet werden, um ein Semaphor zuzuweisen.  Dies bedeutet, dass sich die Aufgabe in einem Wartezustand befinden kann, bis das Semaphor von einer anderen Aufgabe freigegeben wird.  Jede Aufgabe kann das Semaphor freigeben, und dann erh√∂ht sich der Wert des Semaphors. <br><br><h3>  <b>Postf√§cher</b> </h3><br>  Postf√§cher sind unabh√§ngige Kernelobjekte, mit denen Nachrichten gesendet werden k√∂nnen.  Die Gr√∂√üe der Nachricht h√§ngt von der Implementierung ab, ist jedoch normalerweise festgelegt.  Typische Nachrichtengr√∂√üen sind ein bis vier Elemente von der Gr√∂√üe eines Zeigers.  In der Regel wird ein Zeiger auf komplexere Daten √ºber das Postfach gesendet.  Einige Kernel implementieren Postf√§cher so, dass Daten einfach in einer regul√§ren Variablen gespeichert werden und der Kernel den Zugriff darauf steuert.  Postf√§cher k√∂nnen auch als "Austausch" bezeichnet werden, obwohl dieser Name heute nur noch selten vorkommt. <br><br>  Jede Aufgabe kann Nachrichten an ein Postfach senden, das dann ausgef√ºllt wird.  Wenn eine Aufgabe versucht, eine Nachricht an ein vollst√§ndiges Postfach zu senden, erh√§lt sie eine Fehlerantwort.  In vielen RTOS k√∂nnen Sie einen Blockierungsmechanismus verwenden, um an die Mailbox zu senden.  Dies bedeutet, dass die Aufgabe angehalten wird, bis die Nachricht in der Mailbox gelesen wird.  Jede Aufgabe kann Nachrichten aus der Mailbox lesen, danach ist sie leer.  Wenn eine Aufgabe versucht, aus einem leeren Postfach zu lesen, erh√§lt sie eine Fehlerantwort.  In vielen RTOS k√∂nnen Sie einen blockierenden Aufruf zum Lesen aus einer Mailbox verwenden.  Dies bedeutet, dass die Aufgabe angehalten wird, bis eine neue Nachricht im Postfach angezeigt wird. <br><br>  Einige RTOS unterst√ºtzen die Broadcast-Funktion.  Auf diese Weise k√∂nnen Sie Nachrichten an alle Aufgaben senden, die derzeit beim Lesen eines bestimmten Postfachs angehalten werden. <br><br>  Einige RTOS unterst√ºtzen Postf√§cher √ºberhaupt nicht.  Stattdessen wird empfohlen, eine Warteschlange mit nur einem Element zu verwenden.  Dies ist funktional √§quivalent, bringt jedoch zus√§tzlichen Aufwand f√ºr Speicher und Laufzeit mit sich. <br><br><h3>  <b>Warteschlangen</b> </h3><br>  Warteschlangen sind unabh√§ngige Kernelobjekte, die einen Mechanismus zum Senden von Nachrichten bereitstellen.  Sie sind etwas flexibler und komplexer als Postf√§cher.  Die Gr√∂√üe der Nachricht h√§ngt von der Implementierung ab, ist jedoch normalerweise fest und auf das Wort / den Zeiger ausgerichtet. <br><br>  Jede Aufgabe kann Nachrichten an die Warteschlange senden. Dies kann wiederholt werden, bis die Warteschlange voll ist. Danach f√ºhrt jeder Sendeversuch zu einem Fehler.  Die L√§nge der Warteschlange wird normalerweise vom Benutzer beim Erstellen oder Konfigurieren des Systems festgelegt.  In vielen RTOS k√∂nnen Sie einen Blockierungsmechanismus auf die Warteschlange anwenden.  Das hei√üt, wenn die Warteschlange voll ist, kann die Aufgabe angehalten werden, bis die Nachricht in der Warteschlange von einer anderen Aufgabe gelesen wird.  Jede Aufgabe kann Nachrichten aus der Warteschlange lesen.  Nachrichten werden in derselben Reihenfolge gelesen, in der sie gesendet wurden (First In - First Out, FIFO).  Wenn eine Aufgabe versucht, aus einer leeren Warteschlange zu lesen, erh√§lt sie eine Fehlerantwort.  In vielen RTOS kann ein Blockierungsmechanismus verwendet werden, um aus einer leeren Warteschlange zu lesen.  Wenn die Warteschlange leer ist, kann die Aufgabe angehalten werden, bis die Nachricht von einer anderen Aufgabe an die Warteschlange gesendet wird. <br><br>  H√∂chstwahrscheinlich gibt es im RTOS einen Mechanismus zum Senden einer Nachricht an die Vorderseite der Warteschlange, der als Jamming bezeichnet wird.  Einige RTOS unterst√ºtzen auch die Broadcast-Funktion.  Auf diese Weise k√∂nnen Sie Nachrichten an alle Aufgaben senden, die beim Lesen der Warteschlange angehalten wurden. <br><br>  Dar√ºber hinaus kann das RTOS das Senden und Lesen von Nachrichten variabler L√§nge unterst√ºtzen.  Dies bietet mehr Flexibilit√§t, bringt jedoch zus√§tzlichen Aufwand mit sich. <br><br>  Viele RTOSs unterst√ºtzen eine andere Art von Kernelobjekt, die "Pipes".  Im Wesentlichen √§hnelt ein Kanal einer Warteschlange, verarbeitet jedoch byteorientierte Daten. <br><br>  Die Funktionalit√§t der Warteschlangen ist nicht von Interesse, aber es versteht sich, dass sie mehr Speicher- und Laufzeitaufwand haben als Postf√§cher, vor allem, weil zwei Zeiger gespeichert werden m√ºssen: der Anfang und das Ende der Warteschlange. <br><br><h3>  <b>Mutexe</b> </h3><br>  Mutexe (sich gegenseitig ausschlie√üende Semaphoren) sind unabh√§ngige Kernelobjekte, die sich sehr √§hnlich wie normale bin√§re Semaphoren verhalten.  Sie sind etwas komplizierter als Semaphore und beinhalten das Konzept des tempor√§ren Eigentums (eine Ressource, f√ºr die der Zugriff kontrolliert wird).  Wenn eine Aufgabe einen Mutex zuweist, kann nur dieselbe Aufgabe ihn wieder freigeben: Der Mutex (und damit die Ressource) geh√∂rt vor√ºbergehend zur Aufgabe. <br><br>  Mutexe werden nicht von allen RTOS bereitgestellt, aber das regul√§re bin√§re Semaphor ist ziemlich einfach anzupassen.  Sie m√ºssen eine Mutex-Abruffunktion schreiben, die ein Semaphor und eine Aufgabenkennung zuweist.  Die Zusatzfunktion ‚ÄûMutex Release‚Äú √ºberpr√ºft dann die Kennung der aufrufenden Task und gibt das Semaphor nur frei, wenn es mit dem gespeicherten Wert √ºbereinstimmt. Andernfalls wird ein Fehler zur√ºckgegeben. <br><br>  <i>Als wir an unserem eigenen Echtzeit-Betriebssystem OSRV MAX arbeiteten (zuvor ver√∂ffentlichte Artikel dar√ºber), stie√ü unser Team auf den Blog von Colin Walls, einem Experten f√ºr Mikroelektronik und Firmware bei Mentor Graphics.</i>  <i>Artikel schienen interessant, √ºbersetzten sie f√ºr sich selbst, aber um nicht "an den Tisch zu schreiben", beschlossen sie, sie zu ver√∂ffentlichen.</i>  <i>Ich hoffe, sie werden Ihnen auch n√ºtzlich sein.</i>  <i>Wenn ja, planen wir, alle √ºbersetzten Artikel in der Reihe zu ver√∂ffentlichen.</i> <i><br><br></i>  <i>√úber den Autor: Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.</i>  <i>Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).</i>  <i>Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.</i>  <i>Lebt in Gro√übritannien.</i>  <i>Colins professionelles Blog: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blogs.mentor.com/colinwalls</a> , E-Mail: colin_walls@mentor.com</i> <br><br>  Lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten, zweiten,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten und</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierten</a> Artikel, der zuvor ver√∂ffentlicht wurde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415429/">https://habr.com/ru/post/de415429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415415/index.html">Ank√ºndigung einer Hackathon-Konferenz zur Entwicklung von Spielen in der GameNode-Blockchain</a></li>
<li><a href="../de415417/index.html">Smartphone Bewertung ASUS ZenFone Max Pro (M1) ZB602KL</a></li>
<li><a href="../de415421/index.html">Wir laden Sie zum letzten Einstellungsturnier der Saison in den Gravity Co-Working Space ein</a></li>
<li><a href="../de415423/index.html">Public Key-Infrastruktur: Zertifizierungsstelle basierend auf OpenSSL und SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../de415427/index.html">Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 4. Aufgaben, Kontextwechsel und Interrupts</a></li>
<li><a href="../de415431/index.html">Hackathon-Ank√ºndigung SmartMail Hack 2: Call of Data</a></li>
<li><a href="../de415433/index.html">Verwalten von Ver√∂ffentlichungen zu GIS-Wohnungen und kommunalen Diensten - wir teilen Erfahrungen und k√§mpfen mit Intuition</a></li>
<li><a href="../de415435/index.html">Entwicklung von Schnittstellenkarten auf Soil Xilinx Zynq 7000 f√ºr die Sprachaufzeichnung im analogen und digitalen Format</a></li>
<li><a href="../de415437/index.html">Wie man ML in Prod rollt: Sechs Rechen, auf die wir getreten sind</a></li>
<li><a href="../de415439/index.html">Zwingt Sie die Unternehmenskommunikation dazu, Sie zu beenden oder in ein Projekt wie ein Spiel zu ziehen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>