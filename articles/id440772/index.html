<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥“ ğŸ“¹ â›…ï¸ Desain berbasis domain: resep untuk seorang pragmatis ğŸ´ ğŸ‘¨ğŸ¼â€âš–ï¸ ğŸŒ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa DDD biasanya didekati dari sisi yang salah? Dan sisi mana yang Anda inginkan? Apa hubungannya jerapah dan platipus dengan semua ini? 

 Khusus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desain berbasis domain: resep untuk seorang pragmatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440772/"><img src="https://habrastorage.org/webt/0d/g2/_y/0dg2_yqhafnwjnnd2iqwabmrysc.jpeg"><br>  Mengapa DDD biasanya didekati dari sisi yang salah?  Dan sisi mana yang Anda inginkan?  Apa hubungannya jerapah dan platipus dengan semua ini? <br><br>  Khusus untuk Habr - transkrip teks laporan "Desain berbasis domain: resep untuk pragmatis."  Laporan tersebut dibuat pada konferensi DotNext .NET, tetapi dapat bermanfaat tidak hanya bagi para donor, tetapi juga bagi semua orang yang tertarik pada DDD (kami yakin Anda akan menguasai beberapa contoh kode C #).  Rekaman video dari laporan ini juga dilampirkan. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CR9mLGN9jh0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Halo semuanya, nama saya Alexey Merson.  Saya akan memberi tahu Anda apa Desain Berbasis Domain dan apa esensinya, tapi pertama-tama, mari kita cari tahu mengapa itu diperlukan. <br><br><img src="https://habrastorage.org/webt/mb/3q/2v/mb3q2vmpui3hndlrdyxscvi-ovo.jpeg"><br><br>  Martin Fowler berkata: "Ada beberapa hal yang kurang logis daripada logika bisnis."  Jerapah jelas salah satu dari sedikit ini.  Jarak antara otak dan laring jerapah hanya beberapa sentimeter.  Namun, saraf yang menghubungkan mereka mencapai 4 meter.  Pertama, dia turun melalui seluruh leher, di sana dia mengelilingi arteri dan kemudian dia kembali dengan cara yang hampir sama. <br><br>  Sepintas memang tidak ada logika.  Tapi ini hanya warisan padat yang tersisa dari ikan purba.  Pada ikan, seperti yang Anda tahu, tidak ada leher, jadi saraf ini berjalan di sepanjang jalur optimal.  Dan ketika mamalia muncul setelah beberapa juta tahun refactoring, saraf harus diperluas untuk menjaga kompatibilitas ke belakang.  Nah, jangan merombak karena jerapah? <br><br>  Tapi jerapah tidak apa-apa, karena ada platipus. <br><br><img src="https://habrastorage.org/webt/j0/fv/t3/j0fvt3ieyzwdykfidna95z9w-vw.jpeg"><br>  Pikirkan lagi.  Mamalia  Dengan paruh.  Hidup terutama di air.  Bertelur.  Dan selain itu, beracun.  Kelihatannya satu-satunya penjelasan logis untuk keberadaannya adalah bahwa ia berasal dari Australia. <br><br>  Tapi saya pikir semuanya lebih dangkal.  Kontraktor hanya lupa tentang desain dan menabung dengan StackOverflow, well, atau apa yang ada di sana pada masa itu. <br><img src="https://habrastorage.org/webt/hr/xm/lw/hrxmlwxz0r0fwr4xfrueljqhc7e.jpeg"><br>  Saya tahu apa yang Anda pikirkan sekarang: "Alexey, yah, Anda menjanjikan Domain-Driven Design kepada kami, dan inilah semacam" Di dunia binatang "! <br><br>  Kolega, apa itu pembangunan?  Pengembangan adalah ketika kita mengambil beberapa bagian dari dunia nyata, proses bisnis, dan mengubahnya menjadi kode, yaitu membangun model perangkat lunak.  Masalah apa yang menanti kita di sepanjang jalan? <br><br>  Yang pertama adalah kompleksitas proses bisnis itu sendiri, yaitu, kesulitan memahami bagaimana bisnis bekerja, proses apa yang terjadi di sana, oleh apa logika mereka dibangun. <br><br>  Masalah kedua adalah implementasi proses bisnis ini dalam bentuk kode, penggunaan pola yang tepat, pendekatan yang tepat, dan sebagainya.  Ini juga topik yang agak rumit. <br><img src="https://habrastorage.org/webt/41/de/a2/41dea2lr4g73nouzxekhq8-t3qm.jpeg"><br>  Lihat, proses bisnis seperti jerapah: mereka mulai dengan yang uniseluler yang paling sederhana, dan kemudian "itu" melihat Anda, dan tidak ada yang mengerti "dari mana asalnya" atau "cara kerjanya". <br><br>  Untuk membangun model yang sukses dari proses semacam itu, Anda harus terlebih dahulu menjawab pertanyaan "mengapa?".  Mengapa kita ingin membangun model ini?  Tujuan apa yang ingin kita capai?  Lagi pula, jika pelanggan menginginkan jerapah yang diisi, tetapi mendapat nyali, maka ia akan kesal, bahkan jika pencernaan dalam model ini diimplementasikan untuk pesta untuk mata.  Dan pelanggan tidak hanya akan kehilangan uang dan waktu, dia akan kehilangan kepercayaan pada kita sebagai pengembang, dan kita akan kehilangan reputasi dan pelanggan kita. <br><br>  Tetapi bahkan jika kita mengetahui tujuannya, ini masih tidak menjamin bahwa kita tidak akan mendapatkan platipus sebagai hasilnya.  Faktanya adalah bahwa tujuannya sedikit untuk dipahami.  Tujuannya harus tercapai.  Dan ini membantu kami Desain Berbasis Domain. <br><img src="https://habrastorage.org/webt/qb/dz/ib/qbdzibra6bypzj_36zfv-dnhlti.jpeg"><br>  Tujuan utama Desain Berbasis Domain adalah untuk memerangi kompleksitas proses bisnis dan otomasi serta implementasinya dalam kode.  "Domain" diterjemahkan sebagai "domain", dan pengembangan dan desain dalam kerangka pendekatan ini didorong menjauh dari domain. <br><br>  Desain Berbasis Domain mencakup banyak hal.  Desain strategis ini, dan interaksi antara orang-orang, dan pendekatan arsitektur, dan pola taktis - ini adalah gudang senjata lengkap yang benar-benar berfungsi dan sangat membantu untuk membuat proyek.  Hanya ada satu "tetapi".  Sebelum Anda mulai berurusan dengan kompleksitas dengan Desain Berbasis Domain, Anda perlu belajar bagaimana menangani kompleksitas Desain Berbasis Domain itu sendiri. <br><br><img src="https://habrastorage.org/webt/ho/xz/9k/hoxz9k3iyujhnbgzlt8dlfzd4b0.png"><br><br>  Ketika seseorang mulai terjun ke topik ini, sejumlah besar informasi jatuh padanya: buku tebal, banyak artikel, pola, contoh.  Semua ini membingungkan, dan mudah, seperti kata mereka, tidak memperhatikan di balik pepohonan di hutan.  Saya pernah merasakan ini pada diri saya sendiri, tetapi hari ini saya ingin berbagi pengalaman saya dengan Anda dan membantu Anda melewati hutan ini, akhirnya mulai menggunakan Desain Berbasis Domain. <br><img src="https://habrastorage.org/webt/bm/mi/hs/bmmihsln4udtdm2d892qwb9elmo.jpeg"><br>  Istilah Domain-Driven Design sendiri diusulkan oleh Eric Evans pada tahun 2003 dalam bukunya yang tidak dapat dilanggar, yang oleh komunitas disebut Blue Book.  Masalahnya adalah bahwa paruh pertama buku Evans berbicara tentang pola taktis (Anda semua tahu mereka: ini adalah pabrik, entitas, repositori, layanan), dan orang-orang biasanya tidak sampai ke babak kedua.  Pria itu terlihat: semuanya akrab, saya akan pergi dan mendapatkan aplikasi DDD. <br><img src="https://habrastorage.org/webt/7y/xz/_r/7yxz_r9ayavde_qjite3vti58fi.jpeg"><br>  Di sebelah kanan adalah apa yang terjadi jika Anda melempar pola taktis pada kompiler.  Kiri - jika Anda menggunakan pola strategis. <br><br><img src="https://habrastorage.org/webt/g9/bd/cj/g9bdcj-skoztnm7s3rsbxyo9w68.jpeg"><br><br>  Sejak dirilisnya Buku Biru, komunitas DDD yang agak kuat telah terbentuk, banyak hal telah dipikirkan kembali.  Ya, dan Evans sendiri mengakui bahwa dia tidak lagi mengerti bagaimana dia bisa mengakhiri hal penting seperti desain strategis. <br><br>  Dan 10 tahun kemudian, pada 2013, Buku Merah diterbitkan oleh Vaughn Vernon.  Dan dalam buku ini, presentasi sudah dibangun dalam urutan yang benar: dimulai dengan desain strategis, dengan dasar-dasarnya.  Dan ketika pembaca telah menerima basis yang diperlukan, maka mereka sudah mulai berbicara tentang pola taktis dan detail implementasi. <br><br>  Biasanya dalam laporan DDD mereka merekomendasikan membaca Evans, di Internet bahkan ada seluruh manual di mana Anda perlu membaca bab untuk perendaman yang tepat.  Saya sarankan melakukannya dengan lebih mudah: mulai dengan Buku Merah, bacalah, dan baru kemudian beralih ke Biru. <br><br>  Dan karena desain strategis adalah hal yang sangat penting, mari kita bicara tentang ide-ide kuncinya. <br><br><h2>  "Ide-ide kunci dari desain strategis" </h2><br>  Dalam setiap proyek otomasi bisnis, selalu ada pakar domain.  Inilah orang-orang yang paling mengerti bagaimana proses bisnis yang akan dimodelkan bekerja.  Ini dapat berupa pengembang, eksekutif, manajer puncak.  Secara umum, itu bisa siapa saja, kalau saja dia memahami proses-proses bisnis yang perlu kita tangani. <br><br><img src="https://habrastorage.org/webt/c0/s1/ho/c0s1ho_prs7h-b-qbkh7_rrroaa.jpeg"><br><br>  Di sisi lain, ada pakar teknis: pengembang, arsitek yang terlibat langsung dalam otomatisasi dan implementasi aplikasi.  Dalam contoh yang digambarkan, pelanggan mungkin menginginkan kereta api anak-anak, tetapi ternyata itu semacam monster. <br><br>  Mengapa ini terjadi?  Karena interaksi antara pakar teknis dan pakar domain dalam situasi tipikal terlihat seperti ini: ada tembok besar-besar di antara mereka, dan seorang manajer berjalan di sepanjang bagian atas tembok ini dan pertama-tama mencoba mendengar apa yang mereka teriakkan di satu sisi dinding, kemudian ia mencoba meneriakkannya sebaik mungkin pada bungkusan itu. di sisi lain dinding, dan seterusnya dalam lingkaran. <br><br>  Terkadang seorang manajer tuli, maka seluruh rantai manajer tersebut dapat dibangun, yang, tentu saja, tidak berkontribusi pada keberhasilan proyek.  Dan bagaimana seharusnya? <br><br><img src="https://habrastorage.org/webt/wc/ov/sh/wcovshn5e04eei99ry9a9ydm4gy.jpeg"><br><br>  Harus ada interaksi yang konstan.  Pakar teknis, pakar domain - semua peserta proyek harus terus memelihara komunikasi, menyinkronkan, mendiskusikan tujuan, cara untuk mencapainya, dan mengapa kita melakukan semua ini. <br><br>  Dan di sini kita sampai pada yang pertama dan, mungkin, titik kunci paling penting dari desain strategis dan Desain Berbasis Domain secara umum. <br><br><img src="https://habrastorage.org/webt/tz/nl/jg/tznljgxy0ptqsd5vw-5s3ptopdk.jpeg"><br><br>  Komunikasi antara peserta proyek membentuk apa yang oleh Desain Domain-Driven disebut bahasa di mana-mana.  Dia bukan satu dalam arti bahwa dia adalah satu untuk semua kesempatan.  Justru sebaliknya.  Itu tunggal dalam arti bahwa semua peserta berkomunikasi di dalamnya, semua diskusi berlangsung dalam satu bahasa dan semua artefak harus secara maksimal dalam satu bahasa, yaitu, mulai dari TK dan diakhiri dengan kode. <br><br><h2>  Skenario bisnis </h2><br>  Untuk diskusi lebih lanjut, kita perlu semacam skenario bisnis.  Mari kita bayangkan situasi ini: <br><br><img src="https://habrastorage.org/webt/nm/4g/ig/nm4gigksgfmt0bgp-iixvbbxow4.jpeg"><br><br>  Direktur Grup JUG.ru datang kepada kami dan berkata: "Teman-teman, arus laporan semakin meningkat, orang-orang, secara umum, disiksa untuk melakukan semuanya secara manual ... Mari mengotomatiskan proses mempersiapkan konferensi."  Kami membalas: "Oke!"  - dan mulai bekerja. <br><br>  Skenario pertama yang akan kami otomatisasi adalah: "Pembicara mengajukan aplikasi untuk laporan di acara tertentu dan menambahkan informasi tentang laporannya."  Apa yang kita lihat dalam skenario ini?  Apa itu pembicara, ada acara dan ada laporan, yang berarti sudah mungkin untuk membangun model domain pertama. <br><br><img src="https://habrastorage.org/webt/e_/up/_t/e_up_tj4aagy5ewxeq1xwdnim_k.jpeg"><br><br>  Di sini kami memiliki model domain: Pembicara - pembicara, Bicara - laporan, Acara - acara.  Tetapi model domain tidak bisa tanpa batas, tidak bisa mencakup semuanya, jika tidak maka akan menjadi buram dan kehilangan fokus, sehingga model domain harus dibatasi oleh sesuatu.  Ini adalah poin kunci selanjutnya. <br><br><img src="https://habrastorage.org/webt/e_/0w/w8/e_0ww82sof-x_waqu_epiihi8de.jpeg"><br><br>  Baik model domain dan bahasa di mana-mana dibatasi oleh konteks yang oleh Desain Domain-Driven disebut konteks terbatas.  Dia membatasi model domain sedemikian rupa sehingga semua konsep di dalamnya tidak ambigu, dan semua orang mengerti apa yang dipertaruhkan. <br><br>  Jika mereka mengatakan "Pengguna", maka semuanya harus jelas sekaligus, itu harus memiliki peran yang dapat dimengerti, makna yang dapat dimengerti, seharusnya tidak menjadi semacam pengguna abstrak dari sudut pandang industri TI. <br><br><img src="https://habrastorage.org/webt/fv/v-/7r/fvv-7rprlvfbdhyo81bgitdvvny.jpeg"><br><br>  Dalam kasus kami, model domain ini berlaku untuk konteks persiapan konferensi, sehingga dalam konteks itulah kami akan menyebutnya "Konteks perencanaan acara".  Tetapi bagi pembicara untuk menambahkan sesuatu, mengubah informasi, dia harus entah bagaimana masuk, dia perlu diberi hak.  Dan ini sudah akan menjadi konteks lain, "Konteks identitas", di mana akan ada semacam entitas mereka sendiri: Pengguna, Peran, Profil. <br><br>  Dan lihat apa masalahnya di sini.  Ketika seseorang masuk ke sistem dan bermaksud untuk memasukkan beberapa jenis informasi, secara fisik ini adalah orang yang sama, tetapi dalam konteks yang berbeda ia diwakili oleh entitas yang berbeda, dan entitas ini tidak terkait langsung. <br><br>  Jika kami mengambil dan, misalnya, mewarisi Speaker dari Pengguna, maka kami akan mencampur hal-hal yang tidak dapat dicampur, dan beberapa atribut dapat dicampur dengan logika.  Dan model tersebut akan kehilangan fokus pada makna spesifik yang dimilikinya, dibagi menjadi beberapa konteks. <br><br><h2>  Demo: Layanan penjualan </h2><br>  Mari kita sedikit menyimpang dari teori kering dan melihat kodenya. <br><br>  Konferensi tidak hanya persiapan konten, tetapi juga penjualan.  Mari kita bayangkan bahwa sebuah layanan untuk menjual tiket telah ditulis, dan seorang manajer penjualan mendatangi kami dan berkata, â€œGuys!  Begitu seseorang menulis layanan ini, mari kita cari tahu, ada sesuatu yang tidak jelas bagi saya bagaimana diskon untuk pelanggan reguler dipertimbangkan. " <br><br>  Setelah berbicara dengan manajer, kami mengetahui bahwa seluruh skenario layanan ini adalah ini: dengan mengklik pada Checkout harga tiket akhir dianggap dengan mempertimbangkan diskon pelanggan reguler, dan pesanan masuk ke status "Menunggu pembayaran". <br><br>  Kode yang sekarang akan kita analisis dapat dilihat secara terpisah di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> . <br><br>  Solusi Terbuka, lihat struktur: <br><br><img src="https://habrastorage.org/webt/hy/wl/j4/hywlj4jodqlkuhsfza7b_gglj2u.png"><br><br>  Tampaknya semuanya terlihat baik: ada Aplikasi dan Inti (rupanya, orang tahu tentang lapisan), Repositori ... Rupanya, orang itu menguasai paruh pertama Evans. <br><br>  Buka OrderCheckoutService.  Apa yang kita lihat di sana?  Ini <a href="">kodenya</a> : <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Checkout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ord = _ordersRepository.GetOrder(id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orders = _ordersRepository.GetOrders() .Count(o =&gt; o.CustomerId == ord.CustomerId &amp;&amp; o.StateId == <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; o.OrderDate &gt;= DateTime.UtcNow.AddYears(<span class="hljs-number"><span class="hljs-number">-3</span></span>)); ord.Price *= (<span class="hljs-number"><span class="hljs-number">100</span></span> - (orders &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">30</span></span>m : orders &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? <span class="hljs-number"><span class="hljs-number">20</span></span>m : orders &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">10</span></span>m : <span class="hljs-number"><span class="hljs-number">0</span></span>)) / <span class="hljs-number"><span class="hljs-number">100</span></span>; ord.StateId = <span class="hljs-number"><span class="hljs-number">1</span></span>; _ordersRepository.SaveOrder(ord); }</code> </pre> <br><br>  Kami melihat garis dengan Harga: di sini perubahan harga.  Kami memanggil manajer penjualan kami dan berkata: "Di sini, singkatnya, diskon dipertimbangkan di sini, semuanya jelas": <br><br><pre> <code class="cs hljs">ord.Price *= (<span class="hljs-number"><span class="hljs-number">100</span></span> - (orders &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">30</span></span>m : orders &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? <span class="hljs-number"><span class="hljs-number">20</span></span>m : orders &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">10</span></span>m : <span class="hljs-number"><span class="hljs-number">0</span></span>)) / <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><br><br>  Dia melihat dari balik bahunya, â€œOh!  Jadi seperti inilah bentuk Brainfuck!  Dan mereka mengatakan kepada saya bahwa mereka menulis dalam bahasa C # â€. <br><br>  Jelas, pengembang kode ini menanggapi wawancara dengan baik tentang algoritma dan struktur data.  Saya menulis di olimpiade sekolah dengan gaya yang sama.  Setelah beberapa waktu, menggunakan format dan refactoring <s>cabul</s> , kami mencari tahu apa apa, dan menjelaskan kepada manajer penjualan lama kami bahwa logikanya adalah ini: jika jumlah pesanan dalam 3 tahun terakhir tidak kurang dari satu, maka ia menerima diskon 10% , tidak kurang dari tiga - 20%, dan tidak kurang dari lima - 30%.  Dia gembira pergi - sekarang jelas bagaimana semuanya bekerja. <br><br>  Saya pikir banyak yang telah membaca Bob Clean Code.  Di sana ia berkata tentang aturan Pramuka: "Tempat parkir setelah kami pergi harus lebih bersih daripada sebelum kami tiba di sana."  Oleh karena itu, mari kita refactor kode ini sehingga terlihat manusia dan sesuai dengan apa yang kita bicarakan sebelumnya tentang bahasa di mana-mana dan penggunaannya dalam kode. <br><br>  Ini adalah kode yang sudah di refactored. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DiscountCalculator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IOrdersRepository _ordersRepository; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiscountCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrdersRepository ordersRepository</span></span></span><span class="hljs-function">)</span></span> { _ordersRepository = ordersRepository; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateDiscountBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> customerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completedOrdersCount = _ordersRepository.GetLast3YearsCompletedOrdersCountFor(customerId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DiscountBy(completedOrdersCount); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiscountBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completedOrdersCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completedOrdersCount &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completedOrdersCount &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completedOrdersCount &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br>  Hal pertama yang kami lakukan adalah mentransfer perhitungan diskon ke DiscountCalculator yang terpisah, di mana metode CustomerId CalculateDiscountBy muncul.  Semuanya dibaca secara manusiawi, semuanya jelas: apa, mengapa dan bagaimana.  Di dalam metode ini, kita melihat bahwa kita secara global memiliki dua langkah untuk menghitung diskon.  Pertama: kami mendapatkan sesuatu dari repositori pesanan, semuanya sesuai dengan kasus pengguna, Anda bahkan tidak harus masuk ke dalam jika ini bukan bagian yang menarik minat Anda sekarang.  Faktanya adalah bahwa kita mendapatkan jumlah beberapa pesanan selesai, setelah itu kami segera mempertimbangkan diskon kedua untuk kuantitas ini sebagai langkah kedua. <br><br>  Jika kita ingin melihat bagaimana itu dipertimbangkan, kita pergi ke DiscountBy, dan di sini hal yang hampir sama ditulis dalam bahasa Inggris yang hampir manusiawi bahwa "jenis brainfair" kita sebelumnya, semuanya jelas dan tepat. <br><br>  Satu-satunya pertanyaan yang bisa muncul adalah dalam unit apa diskon diukur.  Dimungkinkan untuk menambahkan kata "persen" dalam nama metode untuk memperjelasnya, tetapi dari konteks dan angka-angka yang terlibat, kemungkinan besar menebak bahwa ini adalah persentase, dan untuk singkatnya dapat dihilangkan.  Jika kita ingin melihat jumlah pesanan yang ada di sana, maka kita akan pergi ke kode Repositori dan lihat.  Sekarang kita tidak akan melakukan ini.  Dalam Layanan kami, kami perlu menambahkan ketergantungan DiscountCalculator baru.  Dan mari kita lihat apa yang kita dapatkan di versi kedua dari metode Checkout. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckoutV2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orderId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = _ordersRepository.GetOrder(orderId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discount = _discountCalculator.CalculateDiscountBy(order.CustomerId); order.ApplyDiscount(discount); order.State = OrderState.AwaitingPayment; _ordersRepository.SaveOrder(order); }</code> </pre><br><br>  Lihat, metode Checkout menerima orderId, lalu menerima orderId oleh orderId, menurut CustomerId dari pesanan ini, ia menganggap diskon menggunakan kalkulator diskon, menerapkan diskon pada pesanan, mengatur status ke Menunggu Pembayaran dan menyimpan pesanan.  Kami memiliki skrip dalam bahasa Rusia di slide, tetapi di sini kami praktis membaca terjemahan skrip ini ke dalam bahasa Inggris dan semuanya jelas, semuanya jelas. <br><br>  Apakah Anda melihat apa jimat itu?  Kode ini dapat ditampilkan kepada siapa saja: bukan hanya programmer, tetapi QA, analis, pelanggan.  Mereka semua akan mengerti apa yang terjadi, karena semuanya ditulis dalam bahasa manusia.  Saya menggunakan ini di proyek kami, benar-benar QA dapat melihat beberapa bagian, periksa dengan Wiki dan mengerti bahwa ada beberapa jenis bug.  Karena Wiki mengatakan demikian, dan kodenya sedikit berbeda, tetapi dia mengerti apa yang terjadi di sana, meskipun dia bukan pengembang.  Dan dengan cara yang sama, kita dapat mendiskusikan kode dengan analis dan mendiskusikannya secara rinci.  Saya berkata, "Lihat, ini cara kerjanya dalam kode."  Pilihan terakhir kami bukanlah Wiki, melainkan kodenya.  Semuanya berfungsi seperti yang tertulis dalam kode.  Sangat penting untuk menggunakan bahasa di mana-mana saat menulis kode. <br><br><img src="https://habrastorage.org/webt/-a/15/pc/-a15pcu9tfp6xjadw-98qlpcxrs.jpeg"><br><br>  Ini adalah titik kunci ketiga. <br><br>  Ada begitu banyak kebingungan tentang Desain Berbasis Domain dalam hal-hal seperti Domain, Subdomain, konteks Bounded, bagaimana mereka berhubungan dengan apa yang mereka maksud.  Tampaknya semua orang membatasi sesuatu, semuanya entah bagaimana rapi.  Tetapi tidak jelas lalu apa bedanya, mengapa mereka begitu berbeda ditemukan. <br><br><img src="https://habrastorage.org/webt/tp/zo/nf/tpzonf_lfbysx7pgiiqrxbiineo.jpeg"><br><br>  Domain adalah hal yang global, ini adalah bidang subjek global di mana bisnis khusus ini menghasilkan uang.  Misalnya, untuk DotNext ini adalah konferensi, untuk Pyaterochka itu adalah penjualan barang secara eceran. <br><br>  Perusahaan besar mungkin memiliki beberapa domain.  Misalnya, Amazon terlibat dalam penjualan barang melalui Internet dan penyediaan layanan cloud, ini adalah area subjek yang berbeda. <br><br>  Namun demikian, ini adalah sesuatu yang global dan tidak dapat diotomatisasi secara langsung, bahkan untuk menyelidiki hal itu sulit.  Untuk analisis, Domain pasti dibagi menjadi Subdomain, yaitu, menjadi subdomain. <br><br><img src="https://habrastorage.org/webt/rc/wv/qz/rcwvqzdcicpkiw57o6p1lzunmn4.jpeg"><br><br>  Subdomain adalah bagian dari bisnis yang, dalam bahasa kami, sangat terhubung, yaitu, mereka adalah semacam proses logis terisolasi yang berinteraksi satu sama lain pada tingkat utama. <br><br>  Misalnya, jika kita mengambil toko online, itu akan menjadi formasi dan pemrosesan pesanan, itu akan menjadi pengiriman, ini bekerja dengan pemasok, ini adalah pemasaran, ini adalah akuntansi.  Berikut adalah beberapa bagian ini - inilah yang dibagi menjadi bisnis. <br><br><img src="https://habrastorage.org/webt/yc/rc/ub/ycrcubvepugwbmk-xpidrsxc1pu.jpeg"><br><br>  Dari sudut pandang DDD, Subdomain dibagi menjadi tiga jenis.  Dan di sini saya ingin mengatakan satu hal lagi: sering dalam buku dan artikel Subdomain hanya direduksi menjadi Domain, tetapi biasanya dalam kasus ketika dikombinasikan dengan jenis Subdomain.  Artinya, ketika mereka mengatakan "Core domain", maksud mereka Core Subdomain, tolong jangan bingung dalam hal ini.  Awalnya itu membuat saya terlena. <br><br>  Subdomain dibagi menjadi tiga jenis. <br><br><img src="https://habrastorage.org/webt/a0/vg/jh/a0vgjhuiklcpufzsw_lsdzgisnw.jpeg"><br><br>  Yang pertama dan paling penting adalah Core.  Core adalah Subdomain utama, ini adalah keunggulan kompetitif perusahaan, apa yang membuat uang perusahaan ini, bagaimana ia berbeda dari para pesaingnya, pengetahuannya, apa pun sebutannya.  Jika kita mengikuti konferensi DotNext, maka ini isinya.  Anda semua datang ke sini untuk mencari konten, jika tidak ada konten seperti itu di sini, Anda tidak akan pergi atau pergi ke konferensi lain.  Tidak akan ada DotNext dalam bentuknya. <br><br><img src="https://habrastorage.org/webt/up/dr/cc/updrcc6vh3xb0niwkpsuqnrlr-s.jpeg"><br><br>  Tipe kedua adalah Subdomain Pendukung.  Ini juga merupakan hal penting untuk menghasilkan uang, itu juga sesuatu yang tanpanya mustahil, tetapi ini bukan semacam pengetahuan, keunggulan kompetitif yang nyata.  Inilah yang didukung Core Subdomain.  Dari sudut pandang penerapan Desain Berbasis Domain, ini berarti bahwa lebih sedikit upaya yang dihabiskan untuk Mendukung Subdomain, semua kekuatan utama dilemparkan ke Core. <br><br>  Contoh untuk DotNext yang sama adalah pemasaran.  Tidak mungkin tanpa pemasaran, jika tidak, tidak ada yang akan tahu tentang konferensi, tetapi tanpa pemasaran konten tidak diperlukan. <br><br><img src="https://habrastorage.org/webt/ad/in/ar/adinar6ki4kdf1xnozjylhho9ea.jpeg"><br><br>  Dan akhirnya, Subdomain Generik.  Generic adalah beberapa tugas bisnis yang khas, yang, sebagai suatu peraturan, dapat diotomatisasi dengan produk jadi atau outsourcing.  Ini adalah apa yang juga dibutuhkan, tetapi tidak perlu memerlukan implementasi independen oleh kami, dan bahkan lebih dari itu, biasanya akan menjadi ide yang baik untuk menggunakan produk pihak ketiga. <br><br>  Misalnya, menjual tiket.  DotNext menjual tiket melalui TimePad.  Subdomain ini sepenuhnya diotomatiskan oleh TimePad, dan Anda tidak perlu menulis TimePad kedua sendiri. <br><br><img src="https://habrastorage.org/webt/38/xi/5c/38xi5cgogl1edatrnmd4jy6o5yg.jpeg"><br><br>  Dan akhirnya, dibatasi konteks.  Konteks terikat dan Subdomain selalu berada di suatu tempat di dekatnya, tetapi ada perbedaan yang signifikan di antara mereka.  Ini sangat penting. <br><br><img src="https://habrastorage.org/webt/pa/xm/bo/paxmbosiaaglpdk-fc-38ouji3g.jpeg"><br><br>  Ada pertanyaan di StackExchange bagaimana konteks terikat berbeda dari Subdomain.  Subdomain adalah bagian dari bisnis, bagian dari dunia nyata, itu adalah konsep ruang pernyataan masalah.  Batas konteks membatasi model domain dan bahasa di mana-mana, yaitu, apa hasil pemodelan, dan karenanya, konteks terikat adalah konsep ruang solusi.  Dalam proses implementasi proyek, semacam pemetaan Subdomain terjadi pada konteks terbatas. <br><br><img src="https://habrastorage.org/webt/ba/91/mi/ba91mikbrcn3l50d_k2dwedusug.jpeg"><br><br>  Contoh klasik: pembukuan sebagai Subdomain, bagaimana proses dipetakan, otomatis, misalnya, Pembukuan 1C, Elba atau "Bisnisku" - entah bagaimana otomatis oleh beberapa produk.  Ini adalah konteks terbatas dari akuntansi, di mana ada bahasa di mana-mana, terminologinya sendiri.  Itulah perbedaan di antara mereka. <br><br><img src="https://habrastorage.org/webt/fs/y1/lv/fsy1lvc6qabh0flcrli7bkxvpho.jpeg"><br><br>  Jika kita kembali ke DotNext, maka, seperti yang saya katakan, tiket dipetakan ke TimePad, dan konten yang merupakan Subdomain Inti kami dipetakan ke aplikasi khusus yang kami kembangkan untuk manajemen konten. <br><br><h3>  Ukuran konteks yang dibatasi </h3><br>  Ada momen yang menimbulkan banyak pertanyaan.  Bagaimana memilih ukuran yang tepat untuk konteks terbatas?  Dalam buku-buku, orang dapat menemukan definisi seperti itu: "Konteks terikat harus persis sedemikian rupa sehingga bahasa di mana-mana lengkap, konsisten, tidak ambigu, tidak ambigu, konsisten."  Definisi keren, dalam gaya ahli matematika dari lelucon terkenal: sangat akurat, tetapi tidak berguna. <br><br>  Mari kita bahas bagaimana kita memahami semua yang sama: apakah itu harus Solusi, atau Proyek, atau namespace - skala mana yang harus dilampirkan ke konteks dibatasi? <br><br><img src="https://habrastorage.org/webt/l8/h5/7y/l8h57y11erupofzzpnc3q6li7ei.jpeg"><br><br>  Hal pertama yang dapat Anda baca hampir di mana-mana: idealnya, <b>satu Subdomain harus dipetakan ke satu konteks terbatas</b> , yaitu diotomatisasi oleh satu konteks terbatas.  Kedengarannya masuk akal, karena baik di sana maupun di sana ada batasan dari proses bisnis yang terpisah, dalam kedua kasus beberapa istilah bisnis, satu bahasa muncul.  Tetapi di sini Anda perlu memahami bahwa ini adalah situasi yang ideal, Anda belum tentu memiliki ini, dan tidak perlu mencoba untuk mencapai ini. <br><br>  Karena, di satu sisi, Subdomain bisa sangat besar, dan beberapa aplikasi atau layanan dapat diperoleh yang akan mengotomatiskannya, sehingga mungkin ternyata beberapa konteks yang dibatasi sesuai dengan satu Subdomain. <br><br>  Tetapi ada situasi terbalik, sebagai suatu peraturan, ini tipikal untuk Legacy.  Yaitu, ketika mereka membuat aplikasi besar, besar yang mengotomatiskan semua yang ada di dunia di perusahaan ini, maka yang terjadi adalah yang sebaliknya.  Satu aplikasi adalah satu konteks terbatas, di sana model kemungkinan besar akan menjadi semacam ambigu, tetapi Subdomain belum hilang dari ini, masing-masing, satu konteks terikat akan sesuai dengan beberapa Subdomain. <br><br>  Ketika arsitektur microservice menjadi modis, rekomendasi lain muncul (walaupun mereka tidak saling bertentangan): <b>satu konteks terbatas per microservice</b> .  Sekali lagi, ini terdengar masuk akal, orang benar-benar melakukannya.  Karena microservice harus mengambil beberapa fungsi yang jelas, yang secara internal memiliki konektivitas tinggi, dan berkomunikasi dengan layanan lain melalui semacam interaksi.  Jika Anda menggunakan arsitektur microservice, Anda dapat mengambil rekomendasi ini sendiri. <br><br>  Tapi itu belum semuanya.  Izinkan saya mengingatkan Anda sekali lagi bahwa Desain Berbasis Domain adalah tentang banyak hal: tentang bahasa, tentang orang-orang.  Dan Anda tidak dapat mengabaikan orang dan hanya melakukan kriteria teknis dalam hal ini.  Oleh karena itu, saya menulis ini: <b>satu konteks sama dengan X-man</b> .  Dulu saya berpikir bahwa x adalah sekitar 10, tetapi kami berbicara sedikit dengan Igor Labutin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/ilabutin</a> ) dan pertanyaannya tetap terbuka. <br><br>  Di sini penting untuk memahami ini: satu bahasa tetap bersatu sementara semua peserta berbicara, berdiskusi dan semua orang memahaminya dengan jelas.  Jelas bahwa jumlah orang yang tidak terbatas tidak dapat berbicara bahasa yang sama.  Sejarah umat manusia kita dengan jelas menunjukkan hal ini.  Bagaimanapun, beberapa dialek muncul, beberapa artinya, sekarang Anda bahkan dapat menambahkan meme dan sebagainya.  Dengan satu atau lain cara, bahasa akan kabur. <br><br>  Oleh karena itu, harus dipahami bahwa jumlah orang yang menggunakan bahasa tunggal ini dan, karenanya, mengambil bagian dalam pengembangan, dalam otomatisasi, terbatas.  Buku-buku juga berbicara tentang beberapa alasan politik: jika dua tim bekerja di bawah kepemimpinan manajer yang berbeda dan bekerja pada konteks yang sama, dan untuk beberapa alasan manajer ini tidak berteman satu sama lain, konflik akan dimulai dan fokus akan hilang.  Oleh karena itu, akan jauh lebih sederhana dan lebih tepat untuk membuat dua konteks terikat untuk setiap perintah dan tidak mencoba untuk menggabungkan apa yang tidak digabungkan. <br><br><h2>  Arsitektur dan Manajemen Ketergantungan </h2><br>  Dari sudut pandang Desain Berbasis Domain, tidak terlalu masalah arsitektur apa yang Anda pilih.  Desain Berbasis Domain bukan tentang itu; Desain Berbasis Domain adalah tentang bahasa dan komunikasi. <br><br><img src="https://habrastorage.org/webt/3r/de/2i/3rde2isfgddxyjfzswpj2nvxtbe.jpeg"><br><br>  Tetapi ada satu poin penting, dari sudut pandang kriteria untuk memilih arsitektur yang menarik bagi kita dari perspektif Desain Domain-Driven: <b>tujuan kami adalah untuk secara maksimal menghilangkan logika bisnis dari ketergantungan pihak ketiga</b> .  Karena, segera setelah dependensi pihak ketiga muncul, terminologi muncul, kata-kata muncul yang tidak masuk ke dalam satu bahasa dan mulai mengotori logika bisnis kami. <br><br><img src="https://habrastorage.org/webt/nz/pw/nu/nzpwnurj_5kkbnmjo6uhosycd1u.jpeg"><br><br>  Mari kita lihat contoh arsitektur klasik: arsitektur tiga lapis yang terkenal.  Segera setelah mereka tidak memanggil lapisan domain (di sini lapisan Bisnis): bisnis, inti, dan domain semuanya sama.  Bagaimanapun, ini adalah lapisan di mana logika bisnis berada, dan jika itu tergantung pada lapisan data, itu berarti bahwa beberapa konsep dari lapisan data entah bagaimana akan mengalir ke lapisan domain dan akan membuangnya. <br><br><img src="https://habrastorage.org/webt/ft/kh/34/ftkh34ce3zbpt26jx3v8id9vaym.jpeg"><br><br>  Arsitektur empat-lapisan pada dasarnya sama, lapisan domain masih tergantung, dan karena tergantung, pihak ketiga, dependensi yang tidak perlu akan menuju ke sana. <br><br><img src="https://habrastorage.org/webt/wz/uv/ky/wzuvky-2bgljcwwarvtseclyqjy.jpeg"><br><br>  Dan dalam pengertian ini, ada arsitektur yang memungkinkan ini untuk dihindari - itu adalah bawang-arsitektur ("bawang").  Perbedaannya adalah bahwa ia terdiri dari lapisan konsentris, dependensi pergi dari luar ke pusat.  Yaitu, lapisan luar dapat bergantung pada bagian dalam mana pun, lapisan bagian dalam tidak dapat bergantung pada bagian luar. <br><br>  Lapisan terluar adalah antarmuka pengguna dalam arti global (yaitu, itu belum tentu UI manusia, itu bisa menjadi REST API atau apa pun).  Dan infrastruktur, yang sering secara umum juga terlihat seperti I / O, adalah database yang sama, pada kenyataannya, sebuah lapisan data.  Semua hal ini berada di lapisan luar.  Yaitu, karena itu aplikasi entah bagaimana menerima beberapa data, perintah, dan sebagainya, itu dikeluarkan, dan lapisan domain menghilangkan ketergantungan pada hal-hal ini. <br><br>  Selanjutnya datang lapisan Aplikasi - tema yang agak holistik, tetapi ini adalah lapisan tempat skrip, kasus pengguna berada.  Lapisan ini menggunakan lapisan domain untuk mengimplementasikan konsep-konsepnya. <br><br>  Di tengah adalah lapisan domain.  Seperti yang kita lihat, dia tidak lagi bergantung pada apa pun, dia menjadi sesuatu dalam dirinya sendiri.  Dan itulah sebabnya lapisan domain sering disebut "Inti", karena itu adalah inti, itu adalah yang ada di tengah, yang tidak bergantung pada hal-hal pihak ketiga. <br><br><img src="https://habrastorage.org/webt/h4/cl/_n/h4cl_nmaowsib1bw1thjvpolr8u.jpeg"><br><br>  Salah satu opsi untuk mengimplementasikan arsitektur bawang seperti itu adalah arsitektur heksagonal, atau "port dan adaptor".  Saya membawa gambar ini untuk intimidasi, saya tidak akan membicarakannya.  Di akhir posting ada tautan ke satu dari sejuta artikel tentang arsitektur ini, Anda bisa membaca. <br><br><h2>  Sedikit tentang pola taktis: Antarmuka Terpisah </h2><br>  Seperti yang saya katakan, pertama, sebagian besar pola taktis sudah umum bagi semua orang, dan kedua, inti dari laporan saya adalah bahwa itu bukan intisari.  Tapi saya suka pola Separated Interface secara terpisah, dan saya ingin membicarakannya secara terpisah. <br><br>  Mari kita kembali ke kode microservice kami dan melihat apa yang terjadi dengan repositori. <br><br><img src="https://habrastorage.org/webt/jl/c7/_d/jlc7_dwrkqw8mfy4zd1nibrdwti.png"><br><br>  Lapisan domain memiliki antarmuka <a href="">repositori</a> IOrdersRepository.cs dan <a href="">implementasinya,</a> OrdersRepository.cs. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DotNext.Sales.Core</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IOrdersRepository</span></span> { <span class="hljs-function"><span class="hljs-function">Order </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Order order</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IQueryable&lt;Order&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOrders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> V2 int GetLast3YearsCompletedOrdersCountFor(long customerId); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre><br><br>  Di sini kami telah menambahkan di sini metode tertentu untuk menerima pesanan selama tiga tahun terakhir GetLast3YearsCompletedOrdersCountFor. <br><br>  Dan mereka menerapkannya dalam beberapa bentuk (dalam hal ini, melalui Kerangka Entitas, tetapi bisa berupa apa saja): <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLast3YearsCompletedOrdersCountFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> customerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> threeYearsAgo = DateTime.UtcNow.AddYears(<span class="hljs-number"><span class="hljs-number">-3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dbContext.Orders .Count(o =&gt; o.CustomerId == customerId &amp;&amp; o.State == OrderState.Completed &amp;&amp; o.OrderDate &gt;= threeYearsAgo); }</code> </pre><br><br>  Lihat apa masalahnya.  Repositori berakhir di lapisan domain, implementasinya di lapisan domain, tetapi kodenya, dimulai dengan DateTime.UtcNow.AddYears (-3), secara inheren bukan milik lapisan domain, dan bukan logika bisnis.  Ya, LINQ membuatnya lebih atau kurang manusiawi, tetapi jika, misalnya, ada pertanyaan SQL di sini, semuanya akan benar-benar menyedihkan. <br><br>  Arti dari pola Interface Terpisah adalah bahwa antarmuka layanan yang kami gunakan dalam logika domain dinyatakan dalam lapisan domain.  Kita berbicara tentang repositori dan layanan serupa di mana rincian implementasi layanan ini bukan logika bisnis.  Logika bisnis adalah fakta keberadaan layanan ini dan fakta panggilan dan penggunaannya di lapisan domain.  Oleh karena itu, antarmuka repositori tetap berada di lapisan domain, dan implementasinya pindah ke lapisan infrastruktur. <br><br>  Saya menyiapkan opsi lain.  Antarmuka repositori tetap dalam perakitan Inti, tetapi implementasinya pindah ke Infrastruktur.EF. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rh/k0/b_/rhk0b_dgbqe72y--hxcx13qlqco.png"></div><br><br>  Jadi, kami membawa konsep-konsep yang tidak khas ke lapisan domain ke infrastruktur.  Sebagai efek samping, kita dapat mengganti infrastruktur ini dengan beberapa implementasi lainnya.  Tapi ini bukan tujuan utama, tujuan utama adalah, seperti yang saya katakan, untuk menghilangkan logika domain dari dependensi pihak ketiga. <br><br><h2>  Sekali lagi tentang bahasa </h2><br>  Mari kita bicara lagi, dan lagi, dan lagi tentang bahasanya. <br><br>  Pada awalnya, kami membangun model domain "speaker - talk - event".  Saya pikir tidak ada yang mengajukan pertanyaan khusus. <br><br>  Dan inilah skenario atas dasar yang kami bangun model domain ini: <br><br><img src="https://habrastorage.org/webt/2r/go/hp/2rgohppxhq7iqwvndfimzctuit8.jpeg"><br><br>  Lihat, skrip dalam bahasa Rusia, dan model domain dalam bahasa Inggris. <br><br>  Untuk pengembang yang tidak berbahasa Inggris, ini adalah sesuatu yang harus Anda jalani terus-menerus. <br><br><img src="https://habrastorage.org/webt/jm/3p/rf/jm3prfqcjwydo3mg2c1p0zh3olc.jpeg"><br><br>  Anda masing-masing, kemungkinan besar, terus-menerus melakukan proses ini: menerjemahkan dari bahasa Rusia ke bahasa Inggris dan sebaliknya.  Mereka yang bekerja dengan pelanggan dan proyek yang berbahasa Inggris sedikit lebih mudah, karena persyaratannya dalam bahasa Inggris, diskusi dengan pelanggan dalam bahasa Inggris, sebagai aturan, semua skenario dalam bahasa Inggris, kode dalam bahasa Inggris, dan hanya ada komunikasi dalam tim di Rusia, yang dengan cepat tumbuh dalam bahasa Inggris (klien - pelanggan, pesanan - pesanan).  Dan beban kognitif itu, overhead itu, yang diciptakan oleh terjemahan yang konstan, sedikit surut. <br><br>   ,     ,        ,    .    ,    . <br><br>         1,        .   ,  â€”    ,     ,          . <br><br><img src="https://habrastorage.org/webt/1e/b7/jh/1eb7jhuiy5i1ft1bsfrnu1x7_9u.jpeg"><br><br>      1. PascalCase  ,     ,     ,     <s></s>  ,      ,    , ,  - -     . <br><br>  ,  -  ? <br><br><img src="https://habrastorage.org/webt/lj/js/vd/ljjsvdrqh4v9117mps2yrelyxna.jpeg"><br><br>   ,     use case,   ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   .        C#,  ,  , .       ,    ,   ,  . <br><br>        ,  ,      Domain-Driven Design.      ,   ,    , ,        C#    .                    . <br><br>   ,      -  Continuous Integration.  ,       ,    , -   - .   ,     -  ,   ,  .  ,  95%      ,      ,  Continuous Integration,  , TeamCity .   . <br><br>               ,          . .   ,           1-,  ,    .        Â«Â»  ,     .    ,   ,    . <br><br><img src="https://habrastorage.org/webt/qh/ff/32/qhff32udhgwxb4cav3gjjoakn4e.jpeg"><br><br>         ,   Domain-Driven Design. <br><br>  â€”  ,   . Domain-Driven Design â€”    ,    .  â€”    ,  ,          ubiquitous language.     ,     ,   .      ,   ,      ,        . <br><br> .    ,  .    - ,      ,    ,     ,  ,     ,  ,  ,  ,      ,  â€” .     . <br><br>       .      .      .      .   ,    ,      .        DSL-.        .NET-,     - ,    ,  ,  ,   .   ,     . <br><br> , -    .    ,    ,     ubiquitous language  -.     . <br><br><h2>    </h2><br><ul><li> <b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">marshinov</a> </b> .    ,      DDD: , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«   DDD, CQRS  Event Sourcing    Â»</a> .    ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,  AutoMapper   MediatR.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,       Domain-Driven Design,      . </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«F# for fun and profitÂ»</a> ,   ,   F#  Domain-Driven Design.  ,  ,   ,    . </li><li>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>    ,   . </li></ul><br>   , ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  GitHub</a> . <br><br><blockquote>   DotNext: <br>   , Â«       ,     Â».   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <b>DotNext</b> ( <b>15-16   </b> )     .    ,   1   ,         . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440772/">https://habr.com/ru/post/id440772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440756/index.html">CI / CD tanpa server di AWS</a></li>
<li><a href="../id440758/index.html">Go Meetup di Acronis! (Moskow, Fiztehpark)</a></li>
<li><a href="../id440760/index.html">Zaman Keemasan Baru untuk Arsitektur Komputer</a></li>
<li><a href="../id440762/index.html">Ulasan perusahaan: sifat dan ketidakberartian ulasan anonim</a></li>
<li><a href="../id440766/index.html">Dari Geeks ke Geeks: hadiah untuk 23 Februari</a></li>
<li><a href="../id440774/index.html">Kesalahan matematika NHTSA yang serius memungkinkan Tesla mengklaim keselamatan autopilot</a></li>
<li><a href="../id440776/index.html">Email, tampilan dalam</a></li>
<li><a href="../id440778/index.html">Pertemuan OpenStack kedua di Mail.ru Group: 22 Februari</a></li>
<li><a href="../id440780/index.html">Google tidak akan memblokir pemblokir iklan pihak ketiga di browser Chromium</a></li>
<li><a href="../id440782/index.html">Saya akan lebih dalam di bawah tanah, atau apa yang harus Anda ketahui, mengoptimalkan aplikasi jaringan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>