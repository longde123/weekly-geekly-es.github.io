<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìì üíç üè≠ So programmieren Sie sicher in Bash üôÖüèª üë®‚Äçüöí üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum schlagen? 
 Es gibt Arrays und abgesicherten Modus in Bash. Bei korrekter Verwendung entspricht bash fast den sicheren Codierungspraktiken. 

 E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So programmieren Sie sicher in Bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Warum schlagen? </h1><br>  Es gibt Arrays und abgesicherten Modus in Bash.  Bei korrekter Verwendung entspricht bash fast den sicheren Codierungspraktiken. <br><br>  Es ist schwieriger, bei Fischen einen Fehler zu machen, aber es gibt keinen abgesicherten Modus.  Daher sollte das Prototyping in Fischen und die anschlie√üende √úbersetzung von Fisch zu Bash eine gute Idee sein, wenn Sie wissen, wie man es richtig macht. <br><br><h1>  Vorwort </h1><br>  Dieses Handbuch liegt ShellHarden bei, der Autor empfiehlt jedoch auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ShellCheck,</a> damit die ShellHarden-Regeln nicht von ShellCheck abweichen. <br><br>  Bash ist keine Sprache, in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der einfachste Weg, ein Problem gleichzeitig zu l√∂sen, der einfachste ist</a> .  Wenn Sie die Bash-Safe-Programmierpr√ºfung ablegen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lautet</a> die erste Regel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BashPitfalls</a> : Verwenden Sie immer Anf√ºhrungszeichen. <br><br><h1>  Die Hauptsache, die Sie √ºber das Programmieren in Bash wissen m√ºssen </h1><br>  <b>Manische Anf√ºhrungszeichen!</b>  Eine nicht zitierte Variable sollte als gespannte Bombe betrachtet werden: Sie explodiert bei Kontakt mit einem Raum.  Ja, es explodiert in dem Sinne, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein String in ein Array unterteilt wird</a> .  Insbesondere Variablenerweiterungen wie <code>$var</code> und Befehlssubstitutionen wie <code>$(cmd)</code> werden <i>wortgeteilt,</i> wenn die innere Zeichenfolge aufgrund der Aufteilung in eine spezielle <code>$IFS</code> Variable mit einem Standardraum in ein Array erweitert wird.  Dies ist normalerweise unsichtbar, da das Ergebnis meistens ein Array von 1 Element ist, das nicht von der erwarteten Zeichenfolge zu unterscheiden ist. <br><a name="habracut"></a><br>  Dies wird nicht nur erweitert, sondern auch Platzhalter ( <code>*?</code> ).  Dieser Vorgang wird ausgef√ºhrt, nachdem das Wort geteilt wurde. Wenn das Wort mindestens einen Platzhalter enth√§lt, wird das Wort zu einem Platzhalter, der f√ºr alle geeigneten Dateipfade gilt.  Diese Funktion beginnt also, auf das Dateisystem angewendet zu werden! <br><br>  Das Anf√ºhrungszeichen unterdr√ºckt die Wortteilung und Mustererweiterung f√ºr Variablen und Befehlsersetzungen. <br><br>  Variable Erweiterung: <br><br><ul><li>  Gut: <code>"$my_var"</code> </li><li>  Schlecht: <code>$my_var</code> </li></ul><br>  Befehlsersetzung: <br><br><ul><li>  Gut: <code>"$(cmd)"</code> </li><li>  Schlecht: <code>$(cmd)</code> </li></ul><br>  Es gibt Ausnahmen mit optionalen Anf√ºhrungszeichen, aber Anf√ºhrungszeichen werden niemals schaden. Die allgemeine Regel lautet, keine nicht zitierten Variablen in Anf√ºhrungszeichen zu setzen, damit wir nicht nach Randausnahmen f√ºr Sie suchen.  Es sieht falsch aus und die falsche Praxis ist weit genug verbreitet, um Verdacht zu erregen: Viele Skripte wurden mit fehlerhafter Verarbeitung von Dateinamen und Leerzeichen geschrieben ... <br><br>  ShellHarden erw√§hnt nur wenige Ausnahmen - sind diese Variablen mit numerischen Inhalten wie <code>$?</code>  , <code>$#</code> und <code>${#array[@]}</code> . <br><br><h3>  Muss ich Backticks verwenden? </h3><br>  Befehlsersetzungen k√∂nnen auch die folgende Form haben: <br><br><ul><li>  Richtig: <code>"`cmd`"</code> </li><li>  Schlecht: <code>`cmd`</code> </li></ul><br>  Obwohl dieser Stil korrekt verwendet werden kann, ist er in Anf√ºhrungszeichen weniger praktisch und im verschachtelten Zustand weniger lesbar.  Der Konsens hier ist ziemlich klar: Vermeiden Sie es. <br><br>  ShellHarden schreibt solche H√§kchen in Klammern in Dollar um. <br><br><h3>  M√ºssen geschweifte Klammern verwendet werden? </h3><br>  Klammern werden zum Interpolieren von Zeichenfolgen verwendet, daher sind sie normalerweise redundant: <br><br><ul><li>  Schlecht: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Schlecht und ausf√ºhrlich: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Gut, aber ausf√ºhrlich: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Gut: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Theoretisch ist die Verwendung von geschweiften Klammern kein Problem, aber nach den Erfahrungen Ihres Autors besteht eine starke negative Korrelation zwischen der unn√∂tigen Verwendung von geschweiften Klammern und der korrekten Verwendung von Anf√ºhrungszeichen - fast jeder w√§hlt die Form "schlecht und ausf√ºhrlich" anstelle der Form "gut, aber ausf√ºhrlich"! <br><br>  Theorien Ihres Autors: <br><br><ul><li>  Aus Angst, etwas falsch zu machen: Anstelle der tats√§chlichen Gefahr (fehlende Anf√ºhrungszeichen) k√∂nnen Anf√§nger bef√ºrchten, dass die Variable <code>$prefix</code> Variable <code>"$prefix_postfix"</code> erweitert, dies funktioniert jedoch nicht. </li><li>  Frachtkult: Schreiben von Code im Bund der falschen Angst, die ihm vorausging. </li><li>  Klammern konkurrieren mit Anf√ºhrungszeichen um die Grenze der zul√§ssigen Ausf√ºhrlichkeit. </li></ul><br>  Daher wurde beschlossen, unn√∂tige geschweifte Klammern zu verbieten: ShellHarden ersetzt diese Optionen durch die einfachste gute Form. <br><br>  Und nun zur String-Interpolation, bei der geschweifte Klammern wirklich n√ºtzlich sind: <br><br><ul><li>  Schlecht (Verkettung): <code>$var1"more string content"$var2</code> </li><li>  Gut (Verkettung): <code>"$var1""more string content""$var2"</code> </li><li>  Gut (Interpolation): <code>"${var1}more string content${var2}"</code> </li></ul><br>  Verkettung und Interpolation in Bash sind selbst in Arrays gleichwertig (was l√§cherlich ist). <br><br>  Da ShellHarden keine Stile formatiert, soll der richtige Code nicht ge√§ndert werden.  Dies gilt f√ºr die Option ‚Äûgut (Interpolation)‚Äú: Aus Sicht von ShellHarden ist dies die kanonisch korrekte Form. <br><br>  ShellHarden f√ºgt jetzt nach Bedarf geschweifte Klammern hinzu und entfernt sie: In einem schlechten Beispiel wird var1 mit Klammern geliefert, aber f√ºr var2 sind sie auch im Fall von ‚Äûgut (Interpolation)‚Äú nicht zul√§ssig, da sie am Ende der Zeile nie ben√∂tigt werden.  Die letzte Anforderung kann durchaus umgekehrt werden. <br><br><h4>  Gotcha: nummerierte Argumente </h4><br>  Im Gegensatz zu normalen Variablenbezeichnernamen (in <code>[_a-zA-Z][_a-zA-Z0-9]*</code> : <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ) erfordern nummerierte Argumente Klammern ( <code>[_a-zA-Z][_a-zA-Z0-9]*</code> nicht).  ShellCheck sagt: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden weigert sich, das Problem zu beheben (h√§lt den Unterschied f√ºr zu subtil). <br><br>  Da Klammern bis zu 9 zul√§ssig sind, l√§sst ShellHarden sie f√ºr alle nummerierten Argumente zu. <br><br><h1>  Arrays verwenden </h1><br>  Um alle Variablen zitieren zu k√∂nnen, m√ºssen Sie echte Arrays verwenden, keine pseudomassiven Zeichenfolgen, die durch Leerzeichen getrennt sind. <br><br>  Die Syntax ist ausf√ºhrlich, aber Sie m√ºssen damit umgehen.  Dieser Bashismus ist nur ein Grund, die POSIX-Kompatibilit√§t f√ºr die meisten Shell-Skripte aufzugeben. <br><br>  Gut: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Schlecht: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Deshalb sind Arrays eine so grundlegende Funktion f√ºr eine Shell: Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Argumente von Befehlen sind im Grunde Arrays</a> (und Shell-Skripte sind Befehle und Argumente).  Wir k√∂nnen sagen, dass die H√ºlle, die es k√ºnstlich unm√∂glich macht, mehrere Argumente vorzubringen, komisch und wertlos sein wird.  Einige g√§ngige Muscheln aus dieser Kategorie sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dash</a> und Busybox Ash.  Dies sind minimale POSIX-kompatible Shells - aber was n√ºtzt die Kompatibilit√§t, wenn das Wichtigste <i>nicht</i> auf POSIX ist? <br><br><h3>  Ausnahmef√§lle, in denen Sie wirklich eine Linie brechen werden </h3><br>  Beispiel mit <code>\v</code> als Datentrennzeichen (beachten Sie das zweite Vorkommen): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Auf diese Weise vermeiden wir die Erweiterung von Vorlagen, und die Methode funktioniert auch dann, wenn das Datentrennzeichen <code>\n</code> .  Das zweite Auftreten des Datentrennzeichens sch√ºtzt das letzte Element, wenn es sich als Leerzeichen herausstellt.  Aus irgendeinem Grund sollte die Option <code>-d</code> erster Stelle stehen. <code>-rad ''</code> verlockend, <code>-rad ''</code> Optionen in <code>-rad ''</code> , aber es funktioniert nicht.  Da read in diesem Fall einen Wert ungleich Null zur√ºckgibt, sollte es vor errexit ( <code>|| true</code> ) gesch√ºtzt werden, falls aktiviert.  Getestet in Bash 4.0, 4.1, 4.2, 4.3 und 4.4. <br><br>  Alternative f√ºr Bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Wo man ein Bash-Skript startet </h1><br>  Von so etwas: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Dies beinhaltet: <br><br><ul><li>  Shebang: <br><ul><li>  Portabilit√§tsprobleme: Der absolute Pfad zu <code>env</code> wahrscheinlich besser f√ºr die Portabilit√§t als der absolute Pfad zu <code>bash</code> .  Sie k√∂nnen sich das Beispiel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NixOS ansehen</a> .  POSIX erfordert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">env</a> , aber nicht bash. </li><li>  Sicherheitsprobleme: F√ºr keine Sprache werden Optionen wie <code>-euo pipefail</code> hier nicht positiv akzeptiert!  Dies wird unm√∂glich, wenn Sie die <code>env</code> Umleitung verwenden, aber selbst wenn Ihr Shebang mit <code>#!/bin/bash</code> beginnt, ist dies nicht der Ort f√ºr Parameter, die sich auf den Wert des Skripts auswirken, da sie √ºberschrieben werden k√∂nnen, wodurch das Skript falsch ausgef√ºhrt werden kann.  Als Bonus k√∂nnen jedoch Optionen neu definiert werden, die den Wert des Skripts nicht beeinflussen, z. B. <code>set -x</code> , falls verwendet. </li></ul></li><li>  Was brauchen wir aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inoffiziellen Bash-Strict-Modus</a> mit dem <code>set -u</code> Feature-Check.  Wir brauchen nicht den strengen Bash-Modus, da Shellcheck / Shellharden-Kompatibilit√§t bedeutet, alles und alles zu zitieren, was viel strenger ist.  Dar√ºber hinaus sollte die Option <code>set -u</code> in Bash 4.3 und fr√ºheren <code>set -u</code> <b>nicht verwendet werden</b> .  Da diese Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leere Arrays</a> in diesen Versionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">als verworfen betrachtet</a> , k√∂nnen Arrays nicht f√ºr die hier beschriebenen Zwecke verwendet werden.  Die Verwendung von Arrays ist der zweitwichtigste Tipp in diesem Handbuch (nach Anf√ºhrungszeichen) und der einzige Grund, warum wir die Kompatibilit√§t mit POSIX opfern. Dies ist also keineswegs inakzeptabel: Verwenden Sie entweder gar nicht <code>set -u</code> oder Bash 4.4 oder eine andere normale Shell wie Zsh.  Dies ist leichter gesagt als getan, da die M√∂glichkeit besteht, dass jemand Ihr Skript in der alten Version von Bash noch ausf√ºhrt.  Gl√ºcklicherweise funktioniert alles, was mit <code>set -u</code> funktioniert, ohne es (f√ºr <code>set -e</code> kann man das nicht sagen).  Aus diesem Grund ist es wichtig, die Versionspr√ºfung zu verwenden.  Beachten Sie die Annahme, dass das Testen und Entwickeln in einer mit Bash 4.4 kompatiblen Shell stattfindet (daher wird der Aspekt <code>set -u</code> getestet).  Wenn Sie dies st√∂rt, k√∂nnen Sie auch die Kompatibilit√§t verweigern (das Skript schl√§gt fehl, wenn die Versions√ºberpr√ºfung fehlschl√§gt) oder <code>set -u</code> ablehnen. </li><li>  <code>shopt -s nullglob</code> erzwingt, <code>for f in *.txt</code> korrekt funktioniert, wenn <code>*.txt</code> keine Dateien findet.  Das Standardverhalten (auch <i>Passglob genannt</i> ) √ºbergibt die Vorlage unver√§ndert, was im Falle eines Null-Ergebnisses aus mehreren Gr√ºnden gef√§hrlich ist.  F√ºr <i>Globstar</i> aktiviert dies die rekursive Suche.  Substitution ist einfacher zu verwenden als zu <code>find</code> .  Also benutze es. </li></ul><br>  Aber nicht: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Wenn Sie das <i>interne Feldtrennzeichen auf</i> eine leere Zeichenfolge setzen, kann das Wort nicht geteilt werden.  Klingt nach der perfekten L√∂sung.  Leider ist dies ein unvollst√§ndiger Ersatz f√ºr das Zitieren von Variablen und Befehlsersetzungen, und da Sie Anf√ºhrungszeichen verwenden, gibt es nichts.  Der Grund, warum Anf√ºhrungszeichen weiterhin verwendet werden m√ºssen, liegt darin, dass ansonsten leere Zeichenfolgen zu leeren Arrays werden (wie im <code>test $x = ""</code> ) und eine indirekte Vorlagenerweiterung weiterhin m√∂glich ist.  Dar√ºber hinaus verursachen Probleme mit dieser Variablen auch Probleme mit Befehlen wie <code>read</code> , wodurch Konstruktionen wie <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  Die Vorlagenerweiterung ist deaktiviert: nicht nur die ber√ºchtigte indirekte Erweiterung, sondern auch die problemlose direkte Erweiterung, die Sie, wie gesagt, verwenden sollten.  Es ist also schwer zu akzeptieren.  Dies ist auch f√ºr ein Shellcheck / Shellharden-kompatibles Skript v√∂llig optional. </li><li>  Im <i>Gegensatz zu</i> <i>nullglob</i> schl√§gt <i>failglob</i> mit einem Null-Ergebnis fehl.  Obwohl dies f√ºr die meisten Befehle sinnvoll ist, z. B. <code>rm -- *.txt</code> (da f√ºr die meisten Befehle immer noch keine Ausf√ºhrung mit einem Ergebnis von Null erwartet wird), kann <i>failglob</i> offensichtlich <i>nur</i> verwendet werden, wenn Sie kein Ergebnis von Null erwarten.  Dies bedeutet, dass Sie normalerweise keine Gruppenvorlagen in Befehlsargumenten platzieren, es sei denn, Sie nehmen dasselbe an.  Was jedoch immer passieren kann, ist die Verwendung von <i>nullglob</i> und die Erweiterung der Vorlage auf null Argumente in Konstrukten, die diese annehmen k√∂nnen, z. B. eine Schleife oder das Zuweisen von Werten zu einem Array ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  So vervollst√§ndigen Sie ein Bash-Skript </h1><br>  Der Skript-Exit-Status ist der Status des zuletzt ausgef√ºhrten Befehls.  Stellen Sie sicher, dass es sich um echten Erfolg oder Misserfolg handelt. <br><br>  Das Schlimmste ist, die L√∂sung einem nicht verwandten Zustand in Form einer UND-Liste am Ende des Skripts zu √ºberlassen.  Wenn die Bedingung falsch ist, ist der zuletzt ausgef√ºhrte Befehl die Bedingung selbst. <br><br>  F√ºr den Errexit werden die Bedingungen in Form einer UND-Liste √ºberhaupt nicht verwendet.  Wenn errexit nicht verwendet wird, sollten Sie die Behandlung von Fehlern auch f√ºr den letzten Befehl in Betracht ziehen, damit der Beendigungsstatus nicht maskiert wird, wenn dem Skript zus√§tzlicher Code hinzugef√ºgt wird. <br><br>  Schlecht: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Gut (errexit Option): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Gut (Fehlerbehandlungsoption): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Wie man errexit benutzt </h1><br>  Wie <code>set -e</code> . <br><br><h3>  Verz√∂gerte Bereinigung auf Programmebene </h3><br>  Wenn errexit ordnungsgem√§√ü funktioniert, installieren Sie auf diese Weise alle erforderlichen Bereinigungen beim Beenden. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Gefangen: errexit wird in Befehlsargumenten ignoriert </h3><br>  Hier ist eine sehr knifflige "Bombe", deren Verst√§ndnis mir sehr viel wert war.  Mein Build-Skript hat auf verschiedenen Entwicklungsmaschinen einwandfrei funktioniert, aber den Build-Server in die Knie gezwungen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Richtig (Befehlsersetzung in der Aufgabe): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Warnung: Integrierte <code>local</code> und <code>export</code> Befehle bleiben Befehle, daher bleibt dies immer noch falsch: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck warnt nur vor speziellen Befehlen wie in diesem Fall <code>local</code> . <br><br>  Um <code>local</code> , trennen Sie die Deklaration vom Job: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Gefangen: errexit wird je nach Kontext des Anrufers ignoriert </h3><br>  Manchmal ist POSIX schrecklich.  Errexit wird in Funktionen, Gruppenbefehlen und sogar Subshells ignoriert, wenn der Aufrufer den Erfolg √ºberpr√ºft.  Alle diese Beispiele drucken <code>Unreachable</code> und <code>Great success</code> , wie seltsam es auch erscheinen mag. <br><br>  Unterschale: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Gruppenteam: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Funktion: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Aus diesem Grund ist bash mit errexit praktisch nicht zum Verkn√ºpfen geeignet: Ja, <i>es ist m√∂glich,</i> errexit-Funktionen so <i>zu</i> verpacken, dass sie funktionieren, aber es gibt Zweifel, dass sich der eingesparte Aufwand (bei der expliziten Fehlerbehandlung) lohnt.  Ziehen Sie stattdessen die Aufteilung in vollst√§ndig autonome Skripte in Betracht. <br><br><h1>  Vermeiden Sie es, die Shell mit falschen Anf√ºhrungszeichen aufzurufen </h1><br>  Wenn Sie Befehle aus anderen Programmiersprachen aufrufen, ist es am einfachsten, einen Fehler zu machen und die Shell implizit aufzurufen.  Wenn dieser Shell-Befehl statisch ist, ist er gut - er funktioniert entweder oder nicht.  Aber wenn Ihr Programm die Zeilen zum Erstellen dieses Befehls irgendwie verarbeitet, m√ºssen Sie verstehen - Sie <b>generieren ein Shell-Skript</b> !  Ich m√∂chte das selten tun und es ist sehr anstrengend, alles richtig zu arrangieren: <br><br><ul><li>  zitiere jedes Argument; </li><li>  Escape die entsprechenden Zeichen in den Argumenten. </li></ul><br>  Unabh√§ngig davon, in welcher Programmiersprache Sie dies tun, gibt es mindestens drei M√∂glichkeiten, ein Team korrekt aufzubauen.  In der Reihenfolge der Pr√§ferenz: <br><br><h3>  Plan A: Verzichten Sie auf eine Muschel </h3><br>  Wenn dies nur ein Befehl mit Argumenten ist (dh keine Shell-Funktionen wie Pipelining oder Redirecting), w√§hlen Sie eine Array-Option aus. <br><br><ul><li>  Bad (python3): subprocess.check_call <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Gut (python3): subprocess.check_call <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Schlecht (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Gut (C / POSIX), minus Fehlerbehandlung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plan B: Ein statisches Shell-Skript </h3><br>  Wenn eine Shell erforderlich ist, lassen Sie die Argumente Argumente sein.  Sie k√∂nnten denken, dass es umst√§ndlich war, ein spezielles Shell-Skript in Ihre eigene Datei zu schreiben und darauf zuzugreifen, bis Sie einen solchen Trick sehen: <br><br>  Bad (python3): subprocess.check_call <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Gut (python3): subprocess.check_call <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  K√∂nnen Sie das Shell-Skript bemerken? <br><br>  Richtig, der Befehl printf wird umgeleitet.  Achten Sie auf korrekt zitierte nummerierte Argumente.  Das Implementieren eines statischen Shell-Skripts ist in Ordnung. <br><br>  Diese Beispiele werden in Docker ausgef√ºhrt, da sie sonst nicht so n√ºtzlich sind. Docker ist jedoch auch ein hervorragendes Beispiel f√ºr einen Befehl, der andere Befehle basierend auf Argumenten ausf√ºhrt.  Im Gegensatz zu Ssh, wie wir sp√§ter sehen werden. <br><br><h3>  Letzte Option: Zeilenverarbeitung </h3><br>  Wenn es <i>sich</i> um eine Zeichenfolge handeln sollte (z. B. weil sie √ºber <code>ssh</code> funktionieren muss), kann sie nicht umgangen werden.  Sie m√ºssen jedes Argument zitieren und alle Zeichen maskieren, die zum Beenden dieser Anf√ºhrungszeichen erforderlich sind.  Am einfachsten ist es, in einfache Anf√ºhrungszeichen zu wechseln, da diese die einfachsten Escape-Regeln enthalten.  Nur eine Regel: <code>'</code> ‚Üí <code>'\"</code> . <br><br>  Typischer Dateiname in einfachen Anf√ºhrungszeichen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Wie verwende ich diesen Trick, um ssh-Befehle sicher auszuf√ºhren?  Es ist unm√∂glich!  Hier ist die ‚Äûoft richtige‚Äú L√∂sung: <br><br><ul><li>  Die "oft korrekte" L√∂sung (python3): subprocess.check_call <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Wir selbst m√ºssen alle Argumente zu einer Zeichenfolge kombinieren, damit Ssh es nicht falsch macht: Wenn Sie versuchen, mehrere ssh-Argumente zu √ºbergeben, werden die Argumente ohne Anf√ºhrungszeichen auf verr√§terische Weise kombiniert. <br><br>  Der Grund, warum dies normalerweise nicht m√∂glich ist, liegt darin, dass die richtige Entscheidung von den Vorlieben des Benutzers am anderen Ende abh√§ngt, n√§mlich von der Remote-Shell, die alles sein kann.  Im Grunde k√∂nnte es sogar deine Mutter sein.  Es ist ‚Äûoft richtig‚Äú anzunehmen, dass die Remote-Shell Bash oder eine andere POSIX-kompatible Shell ist, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fisch ist zu diesem Zeitpunkt nicht kompatibel</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413117/">https://habr.com/ru/post/de413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413105/index.html">Hinweise des IoT-Anbieters. Aktivierung und Sicherheit in LoraWAN</a></li>
<li><a href="../de413107/index.html">√úbersetzung des Svelto.ECS-Projekt-Wikis. ECS-Framework f√ºr Unity3D</a></li>
<li><a href="../de413109/index.html">So erstellen Sie eine SaaS-Produktintegrationsplattform: Poster Cloud Checkout Experience</a></li>
<li><a href="../de413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../de413113/index.html">Klasse JavaScript Unterst√ºtzung der JavaScript-Serialisierung</a></li>
<li><a href="../de413119/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 317 (28. Mai - 3. Juni 2018)</a></li>
<li><a href="../de413121/index.html">Fototour von Moskau Coworking #tceh</a></li>
<li><a href="../de413123/index.html">JETZT in NoSQL-Datenbanken</a></li>
<li><a href="../de413125/index.html">Die Gentherapie gibt kleinen Patienten mit Muskelatrophie eine √úberlebenschance</a></li>
<li><a href="../de413127/index.html">Ein paar Worte zur tats√§chlichen Leistung des Hypervisors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>