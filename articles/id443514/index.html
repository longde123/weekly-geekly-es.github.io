<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👧 🕎 👨‍👨‍👧 Menulis lapisan jaringan Anda di Swift: pendekatan berorientasi protokol 👰🏽 🤘 🔔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang hampir 100% aplikasi menggunakan jaringan, sehingga semua orang dihadapkan pada organisasi dan penggunaan lapisan jaringan. Ada dua pendekata...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis lapisan jaringan Anda di Swift: pendekatan berorientasi protokol</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443514/"><img src="https://habrastorage.org/webt/gg/rb/pk/ggrbpkas55pf0eigg33hin46i0g.png"><br><br>  Sekarang hampir 100% aplikasi menggunakan jaringan, sehingga semua orang dihadapkan pada organisasi dan penggunaan lapisan jaringan.  Ada dua pendekatan utama untuk memecahkan masalah ini, itu baik menggunakan perpustakaan pihak ketiga, atau implementasi Anda sendiri dari lapisan jaringan.  Pada artikel ini kita akan mempertimbangkan opsi kedua, dan mencoba menerapkan lapisan jaringan menggunakan semua fitur bahasa terbaru, menggunakan protokol dan enumerasi.  Ini akan menyelamatkan proyek dari dependensi yang tidak perlu dalam bentuk perpustakaan tambahan.  Mereka yang pernah melihat Moya akan segera mengenali banyak detail serupa dalam implementasi dan penggunaan, seperti itu, hanya saja kali ini kita akan melakukannya sendiri tanpa menyentuh Moya dan Alamofire. <br><a name="habracut"></a><br><br>  Dalam panduan ini, kita akan melihat bagaimana mengimplementasikan lapisan jaringan pada Swift murni, tanpa menggunakan pustaka pihak ketiga.  Setelah Anda meninjau artikel ini, kode Anda akan menjadi <br><br><ul><li>  berorientasi protokol </li><li>  mudah digunakan </li><li>  mudah digunakan </li><li>  ketik aman </li><li>  untuk titik akhir enum akan digunakan </li></ul><br><br>  Di bawah ini adalah contoh bagaimana tampilan lapisan jaringan kami setelah implementasi: <br><br><img src="https://habrastorage.org/webt/zg/f5/jy/zgf5jybl_jika5ljlt-h3pcdg1e.png"><br><br>  Dengan hanya menulis <i><b>router.request (.</b></i> Dan menggunakan semua kekuatan enumerasi, kita akan melihat semua opsi kueri yang mungkin dan parameternya. <br><br>  <b>Pertama, sedikit tentang struktur proyek</b> <br><br>  Setiap kali Anda membuat sesuatu yang baru, dan agar dapat dengan mudah memahami segala sesuatu di masa depan, sangat penting untuk mengatur dan menyusun semuanya dengan benar.  Saya memegang keyakinan bahwa struktur folder yang tertata dengan baik adalah detail penting ketika membangun arsitektur aplikasi.  Agar kita dapat mengatur semuanya dengan benar di folder, mari kita buat terlebih dahulu.  Ini akan terlihat seperti struktur folder umum dalam proyek: <br><br><img src="https://habrastorage.org/webt/vw/fz/y0/vwfzy0nlpqmg6mccy85s2q6iqrg.png"><br><br>  <b>Protokol jenis akhir</b> <br><br>  Pertama-tama, kita perlu mendefinisikan protokol <i><b>EndPointType</b></i> kita.  Protokol ini akan berisi semua informasi yang diperlukan untuk mengonfigurasi permintaan.  Apa itu permintaan (titik akhir)?  Intinya, ini adalah URLRequest dengan semua komponen terkait, seperti tajuk, parameter permintaan, badan permintaan.  Protokol <i><b>EndPointType</b></i> adalah bagian terpenting dari implementasi lapisan jaringan kami.  Mari kita buat file dan beri nama <i><b>EndPointType</b></i> .  Letakkan file ini di folder Layanan (bukan di folder EndPoint, mengapa - ini akan dihapus sedikit kemudian) <br><br><img src="https://habrastorage.org/webt/-9/j0/ul/-9j0ulvgk-w_hftxxyqwolmbujy.png"><br><br>  <b>Protokol HTTP</b> <br><br>  <i><b>EndPointType</b></i> kami berisi beberapa protokol yang perlu kami buat permintaan.  Mari kita lihat apa protokol-protokol ini. <br><br>  <b>HTTPMetode</b> <br><br>  Buat file, <i><b>beri</b></i> nama <i><b>HTTPMetode</b></i> dan letakkan di folder Layanan.  Daftar ini akan digunakan untuk mengatur metode HTTP permintaan kami. <br><br><img src="https://habrastorage.org/webt/j2/3x/nr/j23xnrcovqknw9dzxhf-xva898q.png"><br><br>  <b>HTTPTask</b> <br>  Buat file, <i><b>beri</b></i> nama <i><b>HTTPTask</b></i> dan letakkan di folder Layanan.  HTTPTask bertanggung jawab untuk mengonfigurasi parameter permintaan tertentu.  Anda dapat menambahkan sebanyak mungkin opsi kueri yang berbeda sesuai kebutuhan, tetapi saya, pada gilirannya, akan membuat kueri reguler, kueri dengan parameter, kueri dengan parameter dan header, jadi saya hanya akan melakukan tiga jenis kueri ini. <br><br><img src="https://habrastorage.org/webt/v5/4m/j6/v54mj6yxsvdwuiossyq3em2biia.png"><br><br>  Di bagian selanjutnya, kita akan membahas <i><b>Parameter</b></i> dan bagaimana kita akan bekerja dengannya <br><br>  <b>HTTPHeaders</b> <br><br>  <i><b>HTTPHeaders</b></i> hanyalah typealias untuk kamus.  Anda dapat membuatnya di bagian atas file <i><b>HTTPTask</b></i> Anda. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">HTTPHeaders</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><br>  <b>Parameter &amp; Pengkodean</b> <br><br>  Buat file, beri nama <i><b>ParameterEncoding</b></i> dan letakkan di folder Encoding.  Buat typealias untuk <i><b>Parameter</b></i> , itu lagi akan menjadi kamus reguler.  Kami melakukan ini untuk membuat kode terlihat lebih mudah dimengerti dan dibaca. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Parameters</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">Any</span></span>]</code> </pre> <br><br>  Selanjutnya, tentukan protokol <i><b>ParameterEncoder</b></i> dengan fungsi enkode tunggal.  Metode penyandian memiliki dua parameter: <i><b>inout URLRequest</b></i> dan <i><b>Parameters</b></i> .  <b>INOUT</b> adalah kata kunci Swift yang mendefinisikan parameter fungsi sebagai referensi.  Biasanya, parameter diteruskan ke fungsi sebagai nilai.  Saat Anda menulis <i><b>masukan</b></i> sebelum parameter fungsi dalam panggilan, Anda menetapkan parameter ini sebagai jenis referensi.  Untuk mempelajari lebih lanjut tentang argumen inout, Anda dapat mengikuti tautan ini.  Singkatnya, <i><b>inout</b></i> memungkinkan Anda untuk mengubah nilai variabel itu sendiri, yang diteruskan ke fungsi, dan tidak hanya mendapatkan nilainya dalam parameter dan bekerja dengannya di dalam fungsi.  Protokol <i><b>ParameterEncoder</b></i> akan diimplementasikan dalam <i><b>JSONParameterEncoder</b></i> dan di <i><b>URLPameterEncoder</b></i> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(urlRequest: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> URLRequest, with parameters: Parameters)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><br>  <i><b>ParameterEncoder</b></i> berisi fungsi tunggal yang tugasnya menyandikan parameter.  Metode ini dapat melempar kesalahan yang perlu ditangani, jadi kami menggunakan throw. <br><br>  Mungkin juga bermanfaat untuk menghasilkan bukan kesalahan standar, tetapi kesalahan khusus.  Selalu cukup sulit untuk mendekripsi apa yang diberikan Xcode kepada Anda.  Ketika Anda memiliki semua kesalahan yang disesuaikan dan dijelaskan, Anda selalu tahu persis apa yang terjadi.  Untuk melakukan ini, mari kita tentukan enumerasi yang diwarisi dari <i><b>Kesalahan</b></i> . <br><br><img src="https://habrastorage.org/webt/tl/bj/dd/tlbjddm7l48ho1alexej8rrj15q.png"><br><br>  Buat file, <i><b>beri</b></i> nama <i><b>URLParameterEncoder</b></i> dan letakkan di folder <i><b>Encoding</b></i> . <br><br><img src="https://habrastorage.org/webt/s-/eh/tg/s-ehtgdznm1pcdjyrhn3r4fibjs.png"><br><br>  Kode ini mengambil daftar parameter, mengonversi, dan memformatnya untuk digunakan sebagai parameter URL.  Seperti yang Anda ketahui, beberapa karakter tidak diizinkan di URL.  Parameter juga dipisahkan oleh simbol "&amp;", jadi kita harus mengurus ini.  Kami juga harus menetapkan nilai default untuk header jika mereka tidak diatur dalam permintaan. <br><br>  Ini adalah bagian dari kode yang seharusnya dicakup oleh unit test.  Membangun permintaan URL adalah kuncinya, jika tidak kita bisa memancing banyak kesalahan yang tidak perlu.  Jika Anda menggunakan API terbuka, Anda jelas tidak ingin menggunakan volume permintaan penuh yang mungkin untuk pengujian yang gagal.  Jika Anda ingin tahu lebih banyak tentang tes Unit, Anda bisa mulai dengan artikel ini. <br><br>  <b>JSONParameterEncoder</b> <br><br>  Buat file, <i><b>beri</b></i> nama <i><b>JSONParameterEncoder</b></i> dan letakkan di folder Encoding. <br><br><img src="https://habrastorage.org/webt/qf/nc/gp/qfncgpv0juhwx6xnvn4llxqv0eu.png"><br><br>  Semuanya sama seperti dalam kasus <i><b>URLParameter</b></i> , hanya di sini kita akan mengkonversi parameter untuk JSON dan kembali menambahkan parameter mendefinisikan encoding "application / json" ke header. <br><br>  <b>Networkrouter</b> <br><br>  Buat file, beri nama <i><b>NetworkRouter</b></i> dan letakkan di folder Layanan.  Mari kita mulai dengan menentukan typealias untuk penutupan. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">NetworkRouterCompletion</span></span> = (<span class="hljs-number"><span class="hljs-number">_</span></span> data: <span class="hljs-type"><span class="hljs-type">Data?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> response: <span class="hljs-type"><span class="hljs-type">URLResponse?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> error: <span class="hljs-type"><span class="hljs-type">Error?</span></span>)-&gt;()</code> </pre><br><br>  Selanjutnya, kita mendefinisikan protokol <i><b>NetworkRouter</b></i> . <br><br><img src="https://habrastorage.org/webt/uf/zd/s0/ufzds0f3ci0fvx9mr0hingvxjtc.png"><br><br>  <i><b>NetworkRouter</b></i> memiliki <i><b>EndPoint</b></i> yang digunakan untuk permintaan, dan segera setelah permintaan selesai, hasil dari permintaan ini diteruskan ke penutupan <i><b>NetworkRouterCompletion</b></i> .  Protokol juga memiliki fungsi <i><b>batal</b></i> , yang dapat digunakan untuk mengganggu permintaan bongkar-muat jangka panjang.  Kami juga menggunakan jenis <i><b>terkait di</b></i> sini karena kami ingin <i><b>Router</b></i> kami mendukung semua jenis <i><b>EndPointType</b></i> .  Tanpa menggunakan tipe terkait, router harus memiliki beberapa tipe spesifik yang mengimplementasikan <i><b>EndPointType</b></i> .  Jika Anda ingin tahu lebih banyak tentang tipe terkait, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br>  <b>Router</b> <br><br>  Buat file, beri nama <i><b>Router</b></i> dan taruh di folder Layanan.  Kami mendeklarasikan variabel pribadi jenis <i><b>URLSessionTask</b></i> .  Semua pekerjaan akan ada di sana.  Kami menjadikannya pribadi karena kami tidak ingin siapa pun di luar dapat mengubahnya. <br><br><img src="https://habrastorage.org/webt/gb/wk/cx/gbwkcxouam1y86i-sruvzyhub_c.png"><br><br>  <b>Minta</b> <br><br>  Di sini kita membuat <i><b>URLSession</b></i> menggunakan <i><b>URLSession.share</b></i> , ini adalah cara termudah untuk membuat.  Tetapi ingat bahwa metode ini bukan satu-satunya.  Anda dapat menggunakan konfigurasi <i><b>URLSession</b></i> yang lebih kompleks yang dapat mengubah perilakunya.  Lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br>  Permintaan dibuat dengan memanggil fungsi <i>buildRequest.</i> Panggilan fungsi dibungkus dengan do-try-catch, karena fungsi enkode di dalam <i>buildRequest</i> dapat melempar pengecualian.  <i>Respons</i> , <i>data,</i> dan <i>kesalahan</i> diteruskan ke penyelesaian. <br><br><img src="https://habrastorage.org/webt/oi/3c/jl/oi3cjllxhvs7n_m39kmy9r7q29k.png"><br><br>  <b>Bangun permintaan</b> <br><br>  Kami membuat permintaan kami menggunakan fungsi <i>buildRequest</i> .  Fungsi ini bertanggung jawab untuk semua pekerjaan penting di lapisan jaringan kami.  Pada dasarnya mengonversi <i><b>EndPointType</b></i> ke <i><b>URLRequest</b></i> .  Dan begitu <i><b>EndPoint</b></i> berubah menjadi permintaan, kita bisa meneruskannya ke <i><b>sesi</b></i> .  Banyak hal yang terjadi di sini, jadi mari kita lihat metodenya.  Pertama, <i>mari</i> kita periksa metode <i>buildRequest</i> : <br><br>  1. Kami menginisialisasi variabel permintaan <i><b>URLRequest</b></i> .  Kami menetapkan URL basis kami di dalamnya dan menambahkan jalur permintaan khusus yang akan digunakan untuk itu. <br><br>  2. Tetapkan <i>request.httpMetode</i> metode http dari <i><b>EndPoint</b></i> kami. <br><br>  3. Kami membuat blok coba-coba-tangkap, karena pembuat enkode kami mungkin melakukan kesalahan.  Dengan membuat satu blok do-try-catch besar, kami menghilangkan kebutuhan untuk membuat blok terpisah untuk setiap percobaan. <br><br>  4. Di sakelar, periksa <i><b>route.task</b></i> . <br><br>  5. Bergantung pada jenis tugas, kami memanggil encoder yang sesuai. <br><br><img src="https://habrastorage.org/webt/pt/ij/58/ptij58jibcjvvawtyb44axo5mq4.png"><br><br>  <b>Konfigurasikan Parameter</b> <br><br>  Buat fungsi <i><b>configureParameters</b></i> di Router. <br><br><img src="https://habrastorage.org/webt/fb/gf/fy/fbgffycewgssxqrnxglvsvftl0w.png"><br><br>  Fungsi ini bertanggung jawab untuk mengonversi parameter kueri kami.  Karena API kami mengasumsikan penggunaan <i><b>bodyParameters</b></i> dalam bentuk JSON dan <i><b>URLParameters yang</b></i> dikonversi ke format URL, kami hanya meneruskan parameter yang sesuai ke fungsi konversi yang sesuai, yang kami jelaskan di awal artikel.  Jika Anda menggunakan API yang menyertakan berbagai jenis penyandian, maka dalam hal ini saya akan merekomendasikan menambahkan <i><b>HTTPTask dengan</b></i> enumerasi tambahan dengan jenis penyandian.  Daftar ini harus berisi semua jenis penyandian yang memungkinkan.  Setelah itu, di configureParameters tambahkan satu argumen lagi dengan enumerasi ini.  Bergantung pada nilainya, beralih menggunakan sakelar dan buat enkode yang Anda butuhkan. <br><br>  <b>Tambahkan Header Tambahan</b> <br><br>  Buat fungsi <i>addAdditionalHeaders</i> di Router. <br><br><img src="https://habrastorage.org/webt/ow/07/8a/ow078aeoow6qlavpxiobwl6nbh0.png"><br><br>  Tambahkan saja semua header yang diperlukan ke permintaan. <br><br>  <b>Batalkan</b> <br><br>  Fungsi <i>batal</i> akan terlihat sangat sederhana: <br><br><img src="https://habrastorage.org/webt/v4/3t/mm/v43tmm1dlso_cwstw6sy444vyu4.png"><br><br>  <b>Contoh penggunaan</b> <br><br>  Sekarang mari kita coba menggunakan layer jaringan kita pada contoh nyata.  Kami akan terhubung ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TheMovieDB</a> untuk menerima data untuk aplikasi kami. <br><br>  <b>MovieEndPoint</b> <br><br>  Buat file <i><b>MovieEndPoint</b></i> dan letakkan di folder EndPoint.  MovieEndPoint sama dengan <br>  dan TargetType di Moya.  Di sini kita menerapkan EndPointType kita sendiri sebagai gantinya.  Artikel yang menjelaskan cara menggunakan Moya untuk contoh serupa dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation enum NetworkEnvironment { case qa case production case staging } public enum MovieApi { case recommended(id:Int) case popular(page:Int) case newMovies(page:Int) case video(id:Int) } extension MovieApi: EndPointType { var environmentBaseURL : String { switch NetworkManager.environment { case .production: return "https:<span class="hljs-comment"><span class="hljs-comment">//api.themoviedb.org/3/movie/" case .qa: return "https://qa.themoviedb.org/3/movie/" case .staging: return "https://staging.themoviedb.org/3/movie/" } } var baseURL: URL { guard let url = URL(string: environmentBaseURL) else { fatalError("baseURL could not be configured.")} return url } var path: String { switch self { case .recommended(let id): return "\(id)/recommendations" case .popular: return "popular" case .newMovies: return "now_playing" case .video(let id): return "\(id)/videos" } } var httpMethod: HTTPMethod { return .get } var task: HTTPTask { switch self { case .newMovies(let page): return .requestParameters(bodyParameters: nil, urlParameters: ["page":page, "api_key":NetworkManager.MovieAPIKey]) default: return .request } } var headers: HTTPHeaders? { return nil } }</span></span></code> </pre><br><br>  <b>Moviemodel</b> <br><br>  Untuk mengurai model data <i><b>MovieModel</b></i> dan JSON ke dalam model, protokol Decodable digunakan.  Tempatkan file ini di folder <i><b>Model</b></i> . <br><br>  <i>Catatan</i> : untuk perkenalan yang lebih rinci dengan protokol Codable, Decodable, dan Encodable, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel saya yang lain</a> , yang menjelaskan secara rinci semua fitur untuk bekerja dengannya. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation struct MovieApiResponse { let page: Int let numberOfResults: Int let numberOfPages: Int let movies: [Movie] } extension MovieApiResponse: Decodable { private enum MovieApiResponseCodingKeys: String, CodingKey { case page case numberOfResults = "total_results" case numberOfPages = "total_pages" case movies = "results" } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: MovieApiResponseCodingKeys.self) page = try container.decode(Int.self, forKey: .page) numberOfResults = try container.decode(Int.self, forKey: .numberOfResults) numberOfPages = try container.decode(Int.self, forKey: .numberOfPages) movies = try container.decode([Movie].self, forKey: .movies) } } struct Movie { let id: Int let posterPath: String let backdrop: String let title: String let releaseDate: String let rating: Double let overview: String } extension Movie: Decodable { enum MovieCodingKeys: String, CodingKey { case id case posterPath = "poster_path" case backdrop = "backdrop_path" case title case releaseDate = "release_date" case rating = "vote_average" case overview } init(from decoder: Decoder) throws { let movieContainer = try decoder.container(keyedBy: MovieCodingKeys.self) id = try movieContainer.decode(Int.self, forKey: .id) posterPath = try movieContainer.decode(String.self, forKey: .posterPath) backdrop = try movieContainer.decode(String.self, forKey: .backdrop) title = try movieContainer.decode(String.self, forKey: .title) releaseDate = try movieContainer.decode(String.self, forKey: .releaseDate) rating = try movieContainer.decode(Double.self, forKey: .rating) overview = try movieContainer.decode(String.self, forKey: .overview) } }</code> </pre><br><br>  <b>Manajer jaringan</b> <br><br>  Buat file <i><b>NetworkManager</b></i> di folder Manajer.  Saat ini, NetworkManager hanya berisi dua properti statis: kunci API dan enumerasi yang menjelaskan jenis server yang akan dihubungkan.  <i><b>NetworkManager</b></i> juga berisi <i><b>Router</b></i> yang bertipe <i><b>MovieApi</b></i> . <br><br><img src="https://habrastorage.org/webt/yj/it/-b/yjit-b1afnahwsvjkkjnaezgpdu.png"><br><br>  <b>Respon jaringan</b> <br><br>  Buat enumerasi NetworkResponse di NetworkManager. <br><br><img src="https://habrastorage.org/webt/vv/fv/7s/vvfv7sl-q-dmnz289jdcntmhs0k.png"><br><br>  Kami menggunakan enumerasi ini ketika memproses tanggapan terhadap permintaan dan kami akan menampilkan pesan yang sesuai. <br><br>  <b>Hasil</b> <br><br>  Buat enumerasi <i><b>Hasil</b></i> di NetworkManager. <br><br><img src="https://habrastorage.org/webt/en/oj/ad/enojad3e4jxk2jgkntgblqftivu.png"><br><br>  Kami menggunakan <i><b>Hasil</b></i> untuk menentukan apakah permintaan itu berhasil atau tidak.  Jika tidak, maka kami akan mengembalikan pesan kesalahan dengan alasan. <br><br>  <b>Meminta Respons Pemrosesan</b> <br><br>  Buat fungsi <i><b>handleNetworkResponse</b></i> .  Fungsi ini mengambil satu argumen, seperti <i><b>HTTPResponse,</b></i> dan mengembalikan Hasil. <br><br><img src="https://habrastorage.org/webt/wt/uv/5f/wtuv5f7cptiudu69o8mn16psbsy.png"><br><br>  Dalam fungsi ini, tergantung pada kode status yang diterima dari HTTPResponse, kami mengembalikan pesan kesalahan atau tanda permintaan yang berhasil.  Biasanya, kode dalam kisaran 200..299 berarti sukses. <br><br>  <b>Membuat permintaan jaringan</b> <br><br>  Jadi, kami telah melakukan segalanya untuk mulai menggunakan lapisan jaringan kami, mari kita coba membuat permintaan. <br><br>  Kami akan meminta daftar film baru.  Buat fungsi dan <i><b>beri</b></i> nama <i><b>getNewMovies</b></i> . <br><br><img src="https://habrastorage.org/webt/ei/yn/fn/eiynfnoketqomcziq5nzv6ulaao.png"><br><br>  Mari kita lakukan langkah demi langkah: <br><br>  1. Kami mendefinisikan metode <i><b>getNewMovies</b></i> dengan dua argumen: nomor halaman pagination dan handler penyelesaian, yang mengembalikan array opsional model <i><b>Movie</b></i> , atau kesalahan opsional. <br><br>  2. Hubungi <i><b>Router</b></i> .  Kami melewati nomor halaman dan <i>menyelesaikan</i> proses di penutupan. <br><br>  3. <i><b>URLSession</b></i> mengembalikan kesalahan jika tidak ada jaringan atau tidak mungkin membuat permintaan dengan alasan apa pun.  Harap dicatat bahwa ini bukan kesalahan API, kesalahan seperti itu terjadi pada klien dan biasanya terjadi karena kualitas koneksi Internet yang buruk. <br><br>  4. Kita perlu memberikan <i><b>tanggapan</b></i> kepada <i><b>HTTPURLResponse</b></i> , karena kita perlu mengakses properti <i>statusCode</i> . <br><br>  5. Nyatakan <i><b>hasil</b></i> dan inisialisasi dengan menggunakan metode <i><b>handleNetworkResponse</b></i> <br><br>  6. <i><b>Sukses</b></i> berarti permintaan itu berhasil dan kami menerima respons yang diharapkan.  Kemudian kami memeriksa apakah data datang dengan jawabannya, dan jika tidak, maka kami cukup mengakhiri metode ini melalui pengembalian. <br><br>  7. Jika jawaban datang dengan data, maka perlu mem-parsing data yang diterima ke dalam model.  Setelah itu, kami meneruskan array model yang dihasilkan ke penyelesaian. <br><br>  8. Dalam hal terjadi kesalahan, teruskan kesalahan tersebut sampai <i>selesai</i> . <br><br>  Itu saja, ini adalah bagaimana lapisan jaringan kita sendiri bekerja pada Swift murni, tanpa menggunakan dependensi dalam bentuk pod dan pustaka pihak ketiga.  Untuk membuat permintaan uji api untuk mendapatkan daftar film, buat MainViewController dengan properti <i><b>NetworkManager</b></i> dan panggil metode <i><b>getNewMovies</b></i> melaluinya. <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkManager = networkManager } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() view.backgroundColor = .green networkManager.getNewMovies(page: <span class="hljs-number"><span class="hljs-number">1</span></span>) { movies, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> movies = movies { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(movies) } } } }</code> </pre> <br><br>  <b>Bonus kecil</b> <br><br>  Anda mengalami situasi di Xcode ketika Anda tidak mengerti apa jenis placeholder yang digunakan di tempat tertentu?  Misalnya, lihat kode yang baru saja kita tulis untuk <i><b>Router</b></i> . <br><br><img src="https://habrastorage.org/webt/sd/cb/ga/sdcbgacxit9y-j4zk8w32slxqm8.png"><br><br>  Kami menentukan sendiri <i><b>NetworkRouterCompletion</b></i> , tetapi bahkan dalam kasus ini mudah untuk melupakan jenisnya dan bagaimana menggunakannya.  Tapi Xcode tercinta kami mengurus semuanya, dan cukup dengan mengklik dua kali pada placeholder dan Xcode akan menggantikan tipe yang diinginkan. <br><br><img src="https://habrastorage.org/webt/la/wo/oj/lawoojq5qsvsdzzvfzarqc-wnsk.png"><br><br>  <b>Kesimpulan</b> <br><br>  Sekarang kami memiliki implementasi lapisan jaringan berorientasi protokol, yang sangat mudah digunakan dan yang selalu dapat Anda sesuaikan dengan kebutuhan Anda.  Kami memahami fungsinya dan bagaimana semua mekanisme bekerja. <br><br>  Anda dapat menemukan kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori ini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443514/">https://habr.com/ru/post/id443514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443504/index.html">World Wide Web berusia tiga puluh tahun - apa yang akan terjadi selanjutnya?</a></li>
<li><a href="../id443506/index.html">Parser sederhana untuk youtube di tabel google</a></li>
<li><a href="../id443508/index.html">Game papan pendidikan untuk programmer</a></li>
<li><a href="../id443510/index.html">Notebook Compaq Armada 7700 - sebagai pengembangan dari lini Compaq LTE</a></li>
<li><a href="../id443512/index.html">Analisis Data Hackathon di Nizhny Novgorod</a></li>
<li><a href="../id443516/index.html">Hacker Geohot memutuskan untuk membebaskan orang dari simulasi AI</a></li>
<li><a href="../id443518/index.html">RBKmoney Pembayaran di bawah tenda - layanan Microsoft, protokol dan konfigurasi platform</a></li>
<li><a href="../id443520/index.html">Memilih mobil untuk spesialis IT, atau tips untuk poci teh dari poci teh</a></li>
<li><a href="../id443522/index.html">Hosting: opsi, perbandingan, statistik pengguna</a></li>
<li><a href="../id443524/index.html">Animasi Flash mandiri di Unity3D. Bagian Satu, Liris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>