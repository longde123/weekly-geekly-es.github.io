<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêê üëäüèº üóûÔ∏è Por que voc√™ deve usar o pathlib üàØÔ∏è üî∂ üßïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do tradutor: Ol√°, Habr! Apresento a voc√™ a tradu√ß√£o do artigo Por que voc√™ deveria usar o pathlib e sua continua√ß√£o? N√£o, na verdade, o pathlib √© √≥tim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que voc√™ deve usar o pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Do tradutor: Ol√°, Habr!</em>  <em>Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por que voc√™ deveria usar o pathlib</a> e sua continua√ß√£o? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√£o, na verdade, o pathlib √© √≥timo</a> .</em>  <em>Est√° sendo prestada muita aten√ß√£o agora a novos recursos do Python como ass√≠ncio, operador: = e digita√ß√£o opcional.</em>  <em>Ao mesmo tempo, n√£o t√£o significativo (embora :: chamar uma linguagem de inova√ß√£o s√©ria n√£o se mostre uma inova√ß√£o s√©ria) correndo o risco de passar por tr√°s do radar, mas inova√ß√µes muito √∫teis na linguagem.</em>  <em>Em particular, em um grande n√∫mero de artigos dedicados a um assunto, n√£o encontrei (exceto um par√°grafo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ), portanto, decidi corrigir a situa√ß√£o.</em> </p><br><p> Quando descobri o ent√£o novo m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pathlib</a> , h√° alguns anos, decidi de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fundo</a> que era apenas uma vers√£o um pouco estranha e orientada a <code>os.path</code> m√≥dulo <code>os.path</code> .  Eu estava errado.  <code>pathlib</code> √© realmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maravilhoso</a> ! </p><br><p>  Neste artigo, tentarei me apaixonar pelo <code>pathlib</code> .  Espero que este artigo o <strong><code>pathlib</code></strong> a <strong>usar o <code>pathlib</code> em qualquer situa√ß√£o referente ao trabalho com arquivos em Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>os.path</code> estranho</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>os</code> sobrecarregado</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>pathlib</code> torna as coisas simples ainda mais f√°ceis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Objetos de caminho tornam seu c√≥digo mais √≥bvio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. Respostas √†s perguntas.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code> os.path</code> e <code>pathlib</code> para ser honesto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Voc√™ n√£o precisa se preocupar em normalizar os caminhos.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mas minha biblioteca favorita tem o Path melhor que o padr√£o!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>  pathlib.Path</code> e <code>str</code> n√£o se misturam, certo?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>pathlib</code> muito lento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Melhoria da legibilidade</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Parte 1 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> estranho </h3><br><p>  O m√≥dulo <code>os.path</code> sempre foi o que usamos quando se tratava de caminhos Python.  Em princ√≠pio, h√° tudo o que voc√™ precisa, mas muitas vezes n√£o parece muito elegante. </p><br><p>  Devo import√°-lo assim? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Ou ent√£o? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Talvez a fun√ß√£o de <code>join</code> tenha um nome muito geral, e devemos fazer algo assim: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Para mim, todas as op√ß√µes acima parecem n√£o muito convenientes.  Passamos strings para fun√ß√µes que retornam strings que passamos para as pr√≥ximas fun√ß√µes que trabalham com strings.  Aconteceu que todos eles cont√™m caminhos, mas ainda s√£o apenas linhas. </p><br><p>  O uso de strings para entrada e sa√≠da nas fun√ß√µes <code>os.path</code> muito inconveniente, pois √© necess√°rio ler o c√≥digo de dentro para fora.  Gostaria de converter essas chamadas de aninhadas para seq√ºenciais.  √â isso que o <code>pathlib</code> permite que voc√™ fa√ßa! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  O m√≥dulo <code>os.path</code> requer chamadas de fun√ß√£o aninhadas, mas <code>pathlib</code> <strong>nos permite criar cadeias de chamadas consecutivas para m√©todos e atributos da classe <code>Path</code></strong> com um resultado equivalente. </p><br><p>  Eu sei o que voc√™ pensa: pare, esses objetos <code>Path</code> n√£o s√£o os mesmos de antes, n√£o operamos mais nas linhas de caminho!  Voltaremos a esse problema mais tarde (dica: em quase qualquer situa√ß√£o, essas duas abordagens s√£o intercambi√°veis). </p><br><h3 id="os-peregruzhen">  <code>os</code> sobrecarregado </h3><br><p>  O m√≥dulo <code>os.path</code> cl√°ssico <code>os.path</code> projetado para trabalhar com caminhos.  Mas depois que voc√™ quiser <em>fazer algo</em> com o caminho (por exemplo, criar um diret√≥rio), precisar√° acessar outro m√≥dulo, geralmente o <code>os</code> . </p><br><p>  <code>os</code> cont√©m v√°rios utilit√°rios para trabalhar com arquivos e diret√≥rios: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Tamb√©m <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>renames</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  E um monte de coisas que n√£o est√£o relacionadas a sistemas de arquivos: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>getlogin</code> , <code>getlogin</code> , <code>system</code> , ... Mais algumas d√∫zias de coisas que n√£o vou mencionar aqui. </p><br><p>  <strong>O m√≥dulo <code>os</code> foi projetado para uma ampla variedade de tarefas;</strong>  <strong>essa √© uma caixa com tudo relacionado ao sistema operacional.</strong>  Existem muitas utilidades no sistema <code>os</code> , mas nem sempre √© f√°cil navegar: muitas vezes √© necess√°rio aprofundar um pouco no m√≥dulo antes de encontrar o que voc√™ precisa. </p><br><p>  <code>pathlib</code> transfere a maioria das fun√ß√µes do sistema de arquivos para os objetos <code>Path</code> . </p><br><p>  Aqui est√° o c√≥digo que cria o <code>src/__pypackages__</code> e renomeia nosso arquivo <code>.editorconfig</code> para <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Aqui est√° um c√≥digo semelhante usando <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Observe que o segundo exemplo de c√≥digo √© muito mais f√°cil de ler, porque √© organizado da esquerda para a direita - tudo isso gra√ßas √†s cadeias de m√©todos. </p><br><h3 id="ne-zabyvayte-pro-glob">  N√£o se esque√ßa da <code>glob</code> </h3><br><p>  N√£o apenas <code>os</code> e <code>os.path</code> cont√™m m√©todos relacionados ao sistema de arquivos.  Tamb√©m vale a pena mencionar sobre <code>glob</code> , que n√£o pode ser chamado de in√∫til. </p><br><p>  Podemos usar a fun√ß√£o <code>glob.glob</code> para procurar arquivos por um padr√£o espec√≠fico: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  O m√≥dulo <code>pathlib</code> tamb√©m fornece m√©todos semelhantes: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Depois de mudar para o m√≥dulo <code>pathlib</code> , a <strong>necessidade do <code>glob</code> desaparece completamente</strong> : tudo o que voc√™ precisa j√° √© parte integrante dos objetos <code>Path</code> </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> torna as coisas simples ainda mais f√°ceis </h3><br><p>  <code>pathlib</code> simplifica muitas situa√ß√µes dif√≠ceis, mas tamb√©m <strong>facilita alguns trechos de c√≥digo simples</strong> . </p><br><p>  Deseja ler todo o texto em um ou mais arquivos? </p><br><p>  Voc√™ pode abrir o arquivo, ler o conte√∫do e fechar o arquivo usando o bloco <code>with</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Ou voc√™ pode usar o m√©todo <code>read_text</code> em objetos <code>Path</code> e gerar listas para obter o mesmo resultado em uma express√£o: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Mas e se voc√™ precisar gravar em um arquivo? </p><br><p>  Aqui est√° o que parece usando <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou voc√™ pode usar o m√©todo <code>write_text</code> : </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Se, por algum motivo, voc√™ precisar usar o <code>open</code> , como gerenciador de contexto ou por prefer√™ncias pessoais, o <code>Path</code> fornecer√° o m√©todo <code>open</code> como uma alternativa: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou, come√ßando com Python 3.6, voc√™ pode passar seu <code>Path</code> diretamente para <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Objetos de caminho tornam seu c√≥digo mais √≥bvio </h3><br><p>  O que as seguintes vari√°veis ‚Äã‚Äãindicam?  Qual √© o significado de seus significados? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Cada vari√°vel aponta para uma linha.  Mas cada um deles tem significados diferentes: o primeiro √© JSON, o segundo √© a data e o terceiro √© o caminho do arquivo. </p><br><p>  Essa representa√ß√£o de objetos √© um pouco mais √∫til: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  Objetos JSON podem ser desserializados em um dicion√°rio, datas podem ser representadas nativamente usando <code>datetime.date</code> e <strong>objetos de caminho de arquivo podem ser representados como <code>Path</code></strong> </p><br><p>  O uso de objetos <code>Path</code> torna seu c√≥digo mais expl√≠cito.  Se voc√™ quiser trabalhar com datas, use <code>date</code> .  Se voc√™ deseja trabalhar com caminhos de arquivo, use <code>Path</code> . </p><br><p>  Eu n√£o sou um grande apoiador da OOP.  As classes adicionam uma camada extra de abstra√ß√£o, e as abstra√ß√µes √†s vezes tendem a complicar o sistema, em vez de simplific√°-lo.  Ao mesmo tempo, acredito que <code>pathlib.Path</code> √© uma <strong>abstra√ß√£o √∫til</strong> .  Muito rapidamente, torna-se uma decis√£o aceita. </p><br><p>  Gra√ßas ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEP 519</a> , os <code>Path</code> se tornam padr√£o para trabalhar com caminhos.  No momento do Python 3.6, a maioria dos <code>os.path</code> <code>os</code> , <code>shutil</code> , <code>os.path</code> funciona corretamente com esses objetos.  <strong>Voc√™ pode mudar para o <code>pathlib</code> , transparente para sua base de c√≥digo!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  O que est√° faltando no <code>pathlib</code> ? </h3><br><p>  Embora <code>pathlib</code> legal, n√£o √© abrangente.  Definitivamente, existem <strong>v√°rias possibilidades que eu gostaria de incluir no m√≥dulo</strong> . </p><br><p>  A primeira coisa que vem √† mente √© a falta de m√©todos de caminho equivalentes ao <code>shutil</code> .  Embora voc√™ possa passar o <code>Path</code> como par√¢metros do <code>shutil</code> para copiar / excluir / mover arquivos e diret√≥rios, n√£o √© poss√≠vel cham√°-los como m√©todos nos objetos <code>Path</code> . </p><br><p>  Portanto, para copiar arquivos, voc√™ precisa fazer algo assim: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Tamb√©m n√£o h√° an√°logo do m√©todo <code>os.chdir</code> .  Isso significa que voc√™ precisar√° import√°-lo se precisar alterar o diret√≥rio atual: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Tamb√©m n√£o h√° equivalente √† fun√ß√£o <code>os.walk</code> .  Embora voc√™ possa escrever sua pr√≥pria fun√ß√£o no esp√≠rito de uma <code>walk</code> sem muita dificuldade. </p><br><p>  Espero que um dia os objetos <code>pathlib.Path</code> contenham m√©todos para algumas das opera√ß√µes mencionadas.  Mas mesmo nesse cen√°rio, <strong>acho muito mais f√°cil usar o <code>pathlib</code> com outra coisa do que usar <code>os.path</code> e tudo mais</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  √â sempre necess√°rio usar o <code>pathlib</code> ? </h3><br><p>  A partir do Python 3.6, os <strong>Paths funcionam em quase todos os lugares em que voc√™ usa strings</strong> .  Portanto, n√£o vejo raz√£o <em>para n√£o</em> usar o <code>pathlib</code> se voc√™ estiver usando o Python 3.6 e superior. </p><br><p>  Se voc√™ estiver usando uma vers√£o anterior do Python 3, poder√°, a qualquer momento, agrupar o objeto <code>Path</code> em uma chamada <code>str</code> para obter uma string se precisar retornar ao pa√≠s de linhas.  Isso n√£o √© muito elegante, mas funciona: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Parte 2. Respostas √†s perguntas. </h2><br><p>  Depois que a primeira parte foi publicada, algumas pessoas tiveram algumas perguntas.  Algu√©m disse que comparei as <code>pathlib</code> e <code>pathlib</code> desonesta.  Alguns disseram que o uso do <code>os.path</code> t√£o arraigado na comunidade Python que a mudan√ßa para uma nova biblioteca levar√° muito tempo.  Eu tamb√©m vi algumas perguntas sobre desempenho. </p><br><p>  Nesta parte, eu gostaria de comentar sobre essas quest√µes.  Isso pode ser considerado prote√ß√£o contra <code>pathlib</code> e uma <code>pathlib</code> de carta de amor para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  Compare <code>os.path</code> e <code>pathlib</code> para ser honesto </h3><br><p>  Na √∫ltima parte, comparei os dois fragmentos de c√≥digo a seguir: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Isso pode parecer uma compara√ß√£o injusta, porque o uso de <code>os.path.join</code> no primeiro exemplo garante que os delimitadores corretos sejam usados ‚Äã‚Äãem todas as plataformas, o que n√£o fiz no segundo exemplo.  De fato, tudo est√° em ordem, porque o <strong>Path normaliza automaticamente os separadores de caminho</strong> </p><br><p>  Podemos provar isso, convertendo o objeto <code>Path</code> em uma string no Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  N√£o faz diferen√ßa se usamos o m√©todo <code>joinpath</code> , o <code>'/'</code> na linha do caminho, o operador <code>/</code> (outro recurso interessante do <code>Path</code> ) ou passamos argumentos individuais para o construtor Path, obtemos o mesmo resultado: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  O √∫ltimo exemplo causou certa confus√£o por pessoas que sugeriram que o <code>pathlib</code> n√£o <code>pathlib</code> inteligente o suficiente para substituir <code>/</code> por <code>\</code> na cadeia de caminho.  Felizmente, tudo est√° em ordem! </p><br><p>  Com os objetos <code>Path</code> , voc√™ n√£o precisa mais se preocupar com a dire√ß√£o das barras: defina todos os seus caminhos usando <code>/</code> , e o resultado ser√° previs√≠vel para qualquer plataforma. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  Voc√™ n√£o precisa se preocupar em normalizar os caminhos. </h3><br><p>  Se voc√™ estiver executando no Linux ou Mac, √© muito f√°cil adicionar erros acidentalmente ao c√≥digo que afeta apenas usu√°rios do Windows.  Se voc√™ n√£o monitorar de perto o uso de <code>os.path.join</code> e \ ou <code>os.path.normcase</code> para converter barras para aquelas adequadas para a plataforma atual, <strong>voc√™ pode escrever um c√≥digo que n√£o funcionar√° corretamente no Windows</strong> . </p><br><p>  Aqui est√° um exemplo de um bug espec√≠fico do Windows: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Al√©m disso, esse c√≥digo funcionar√° corretamente em qualquer lugar: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Anteriormente, o programador era respons√°vel por concatenar e normalizar os caminhos, assim como no Python 2, o programador era respons√°vel por decidir onde usar o unicode em vez de bytes.  Esta n√£o √© mais sua tarefa - o <code>Path</code> resolve todos esses problemas para voc√™. </p><br><p>  N√£o uso o Windows e n√£o tenho um computador com Windows.  Mas muitas pessoas que usar√£o meu c√≥digo provavelmente usar√£o o Windows, e eu quero que tudo funcione corretamente para elas. </p><br><p>  <strong>Se houver uma chance de seu c√≥digo ser executado no Windows, considere seriamente mudar para o <code>pathlib</code> .</strong> </p><br><p>  <strong>N√£o se preocupe com a normaliza√ß√£o</strong> : use o <code>Path</code> qualquer maneira quando se trata de caminhos de arquivo. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  Parece legal, mas eu tenho uma biblioteca de terceiros que n√£o usa o <code>pathlib</code> ! </h3><br><p>  Voc√™ tem uma grande base de c√≥digo que trabalha com seq√º√™ncias de caracteres como caminhos.  Por que mudar para <code>pathlib</code> se isso significa que tudo precisa ser reescrito? </p><br><p>  Vamos imaginar que voc√™ tenha a seguinte fun√ß√£o: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  A fun√ß√£o pega um diret√≥rio e cria um arquivo <code>.editorconfig</code> , algo como isto: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Se voc√™ substituir as linhas por <code>Path</code> , tudo funcionar√° tamb√©m: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Mas como? </p><br><p>  <code>os.path.join</code> aceita objetos <code>Path</code> (desde Python 3.6).  O mesmo pode ser dito dos <code>os.makedirs</code> . <br>  De fato, a fun√ß√£o <code>open</code> <code>shutil</code> aceita <code>Path</code> , <code>shutil</code> aceita <code>Path</code> e tudo na biblioteca padr√£o usada para aceitar strings agora deve funcionar com <code>Path</code> e strings. </p><br><p>  Dever√≠amos agradecer ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEP 519 por isso</a> , que forneceu a classe abstrata <code>os.PathLike</code> e anunciou que todos os utilit√°rios <code>os.PathLike</code> para trabalhar com caminhos de arquivos devem agora funcionar com as strings e <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  Mas minha biblioteca favorita tem Path, melhor que o padr√£o! </h3><br><p>  Voc√™ j√° pode estar usando uma biblioteca de terceiros que fornece sua implementa√ß√£o de <code>Path</code> , diferente da padr√£o.  Talvez voc√™ goste mais dela. </p><br><p>  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">django-environ</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plumbum</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">visidata</a> cont√™m seus pr√≥prios objetos <code>Path</code> .  Algumas dessas bibliotecas s√£o mais antigas que o <code>pathlib</code> e decidiram herdar do <code>str</code> para que pudessem ser passadas para fun√ß√µes que esperam que strings sejam caminhos.  Gra√ßas ao PEP 519, a integra√ß√£o de bibliotecas de terceiros em seu c√≥digo ser√° mais f√°cil e sem a necessidade de heran√ßa de <code>str</code> . </p><br><p>  Vamos imaginar que voc√™ n√£o deseja usar o <code>pathlib</code> , porque o <code>Path</code> √© um objeto imut√°vel e voc√™ realmente deseja alterar o estado deles.  Com o PEP 519, voc√™ pode criar sua melhor vers√£o mut√°vel do <code>Path</code> .  Para fazer isso, basta implementar o m√©todo <code>__fspath__</code> </p><br><p>  Qualquer implementa√ß√£o auto-escrita do <code>Path</code> agora pode trabalhar nativamente com fun√ß√µes internas do Python que esperam caminhos de arquivo.  <strong>Mesmo se voc√™ n√£o gostar do <code>pathlib</code> , o fato de sua exist√™ncia √© uma grande vantagem para bibliotecas de terceiros com seu pr√≥prio <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Mas <code>pathlib.Path</code> e <code>str</code> n√£o se misturam, certo? </h3><br><p>  Voc√™ provavelmente pensa: isso √© tudo, √© claro, √≥timo, mas essa abordagem com o caminho √†s vezes linha e √†s vezes adiciona alguma complexidade ao meu c√≥digo? </p><br><p>  A resposta a esta pergunta √© sim, at√© certo ponto.  Mas esse problema tem uma solu√ß√£o bastante simples. </p><br><p>  O PEP 519 adicionou mais algumas coisas al√©m do <code>PathLike</code> : em primeiro lugar, √© uma maneira de converter qualquer <code>PathLike</code> em uma string e, em segundo lugar, √© uma maneira de transformar qualquer <code>PathLike</code> em um <code>Path</code> . </p><br><p>  Vamos pegar dois objetos - uma string e <code>Path</code> (ou qualquer outra coisa com o m√©todo <strong>fspath</strong> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  A fun√ß√£o <code>os.fspath</code> normaliza os dois objetos e os transforma em strings: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Nesse caso, o <code>Path</code> pode levar esses dois objetos em um construtor e convert√™-los em <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Isso significa que voc√™ pode converter o resultado de <code>make_editorconfig</code> novamente em <code>Path</code> se necess√°rio: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Embora, √© claro, a melhor solu√ß√£o seja reescrever o <code>make_editorconfig</code> usando o <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> muito lento </h3><br><p>  Eu j√° vi v√°rias vezes sobre o desempenho do <code>pathlib</code> .  √â verdade - o <code>pathlib</code> pode ser lento.  Criar milhares de objetos <code>Path</code> pode afetar significativamente o comportamento do programa. </p><br><p>  Decidi medir o desempenho do <code>pathlib</code> e do <code>os.path</code> no meu computador usando dois programas diferentes que procuram todos os arquivos <code>.py</code> no diret√≥rio atual </p><br><p>  Aqui est√° a vers√£o do <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  E aqui est√° a vers√£o com <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Testar o desempenho de programas que funcionam com o sistema de arquivos √© uma tarefa complicada, porque o tempo de opera√ß√£o pode mudar bastante.  Decidi executar cada script 10 vezes e comparei os melhores resultados para cada programa. </p><br><p>  Ambos os programas encontraram arquivos 97507 no diret√≥rio em que eu os executei.  O primeiro trabalhou em 1.914 segundos, o segundo terminou em 3.430 segundos. </p><br><p>  Quando defino o par√¢metro <code>extension=''</code> , esses programas encontram aproximadamente 600.000 arquivos e a diferen√ßa aumenta.  O primeiro programa funcionou em 1.888 segundos e o segundo em 7.485 segundos. </p><br><p>  Portanto, o <code>pathlib</code> √© <strong>duas vezes mais</strong> lento para arquivos com a extens√£o <code>.py</code> e <strong>quatro vezes mais lento</strong> quando iniciado no meu diret√≥rio pessoal.  A diferen√ßa de desempenho relativa entre <code>pathlib</code> e <code>os</code> √© grande. </p><br><p>  No meu caso, essa velocidade n√£o muda muito.  Eu procurei todos os arquivos no meu diret√≥rio e perdi 6 segundos.  Se eu tivesse a tarefa de processar 10 milh√µes de arquivos, provavelmente o reescreveria.  Mas enquanto n√£o houver essa necessidade, voc√™ pode esperar. </p><br><p>  Se voc√™ tem um peda√ßo quente de c√≥digo e o <code>pathlib</code> obviamente afeta negativamente sua opera√ß√£o, n√£o h√° nada errado em substitu√≠-lo por uma alternativa.  <strong>Voc√™ n√£o deve otimizar o c√≥digo, o que n√£o √© um gargalo</strong> - isso √© um desperd√≠cio de tempo extra, que geralmente tamb√©m leva a c√≥digos mal leg√≠veis, sem muita exaust√£o. </p><br><h3 id="uluchshenie-chitaemosti">  Melhoria da legibilidade </h3><br><p>  Gostaria de encerrar esse fluxo de pensamentos com alguns exemplos de refatora√ß√£o usando <code>pathlib</code> .  Peguei alguns pequenos exemplos de c√≥digo que funcionam com arquivos e os fiz trabalhar com o <code>pathlib</code> .  Deixarei a maior parte do c√≥digo sem comentar em seu tribunal. Decida qual vers√£o voc√™ mais gosta. </p><br><p>  Aqui est√° a fun√ß√£o <code>make_editorconfig</code> que vimos anteriormente: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  E aqui est√° a vers√£o reescrita no <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Aqui est√° um programa de console que segue uma linha com um diret√≥rio e imprime o conte√∫do de um arquivo <code>.gitignore</code> , se existir: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  A mesma coisa com o <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Aqui est√° um programa que imprime todos os arquivos duplicados na pasta e subpastas atuais: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  A mesma coisa com c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> ‚Äî .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453862/">https://habr.com/ru/post/pt453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453846/index.html">Resumo dos eventos para profissionais de RH na √°rea de TI de junho de 2019</a></li>
<li><a href="../pt453848/index.html">AlphaFold: Usando a IA para descobertas cient√≠ficas</a></li>
<li><a href="../pt453850/index.html">Sistema de cr√©dito social chin√™s - o diabo √© t√£o terr√≠vel?</a></li>
<li><a href="../pt453852/index.html">Microbiota. Como cuidar de bact√©rias intestinais</a></li>
<li><a href="../pt453860/index.html">AMD apresentou seus novos processadores personalizados de 7 nm Ryzen terceira gera√ß√£o</a></li>
<li><a href="../pt453864/index.html">Usar um mouse e teclado em consoles √© trapa√ßa?</a></li>
<li><a href="../pt453866/index.html">Solicita√ß√£o de API com ganchos de rea√ß√£o, HOC ou prop de renderiza√ß√£o</a></li>
<li><a href="../pt453868/index.html">Mini interruptor sens√≠vel ao toque com painel de vidro no nRF52832</a></li>
<li><a href="../pt453870/index.html">Escrevemos o proxy reverso socks5 no PowerShell.</a></li>
<li><a href="../pt453872/index.html">Restaurando fotos usando redes neurais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>