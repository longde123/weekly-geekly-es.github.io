<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë¶‚Äçüë¶ üíáüèº üé≠ Benjamin Winterberg Stream API Guide √úbersetzung üë®üèª‚Äçüéì üéª ü§û</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels " Java 8 Stream Tutorial ". 

 Dieses Tutorial, das auf Codebeispielen basiert, bietet ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benjamin Winterberg Stream API Guide √úbersetzung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java 8 Stream Tutorial</a> ". <br><br>  Dieses Tutorial, das auf Codebeispielen basiert, bietet einen umfassenden √úberblick √ºber Streams in Java 8. Als ich die Stream-API zum ersten Mal einf√ºhrte, war ich √ºber den Namen verwirrt, da er sehr gut mit InputStream und OutputStream aus dem Paket java.io √ºbereinstimmt.  Threads in Java 8 sind jedoch etwas v√∂llig anderes. <a name="habracut"></a>  Threads sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monaden</a> , die eine wichtige Rolle bei der Entwicklung der funktionalen Programmierung in Java spielen. <br><blockquote>  In der funktionalen Programmierung ist eine Monade eine Struktur, die eine Berechnung in Form einer Kette aufeinanderfolgender Schritte darstellt.  Der Typ und die Struktur einer Monade bestimmen eine Operationskette, in unserem Fall eine Folge von Methoden mit integrierten Funktionen eines bestimmten Typs. </blockquote>  In diesem Handbuch erfahren Sie, wie Sie mit Streams arbeiten und wie Sie mit den verschiedenen in der Stream-API verf√ºgbaren Methoden umgehen.  Wir werden die Reihenfolge der Operationen analysieren und sehen, wie sich die Reihenfolge der Methoden in der Kette auf die Leistung auswirkt.  <code>flatMap</code> Sie <code>flatMap</code> leistungsstarken Stream-API-Methoden wie <code>reduce</code> , <code>collect</code> und <code>flatMap</code> .  Am Ende des Handbuchs werden wir auf die parallele Arbeit mit Threads achten. <br><br>  Wenn Sie nicht frei sind, mit Lambda-Ausdr√ºcken, funktionalen Schnittstellen und Referenzmethoden zu arbeiten, ist es hilfreich, sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Leitfaden zu Innovationen in Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©) vertraut zu machen und danach wieder mit dem Studium von Flows zu beginnen. <br><br><h3>  Wie Threads funktionieren </h3><br>  Ein Stream stellt eine Folge von Elementen dar und bietet verschiedene Methoden zum Durchf√ºhren von Berechnungen f√ºr diese Elemente: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Str√∂mungsmethoden sind <i>Intermediate</i> (Intermediate) und <i>Terminal</i> (Terminal).  Zwischenmethoden geben einen Stream zur√ºck, wodurch viele dieser Methoden nacheinander aufgerufen werden k√∂nnen.  Terminalmethoden geben entweder keinen Wert (void) oder ein Ergebnis eines anderen Typs als eines Streams zur√ºck.  Im obigen Beispiel sind die <code>filter</code> , <code>map</code> und <code>sorted</code> intermedi√§r und <code>forEach</code> sind terminal.  Eine vollst√§ndige Liste der verf√ºgbaren Flussmethoden finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Eine solche Kette von Stream-Operationen ist auch als Operations-Pipeline bekannt. <br><br>  Die meisten Methoden der Stream-API akzeptieren als Parameter Lambda-Ausdr√ºcke, eine funktionale Schnittstelle, die das spezifische Verhalten der Methode beschreibt.  Die meisten von ihnen m√ºssen gleichzeitig st√∂rungsfrei und staatenlos sein.  Was bedeutet das? <br><br>  Eine Methode ist nicht st√∂rend, wenn sie die zugrunde liegenden Daten, die dem Stream zugrunde liegen, nicht √§ndert.  Im obigen Beispiel √§ndern beispielsweise keine Lambda-Ausdr√ºcke das Listenarray myList. <br><br>  Eine Methode ist zustandslos, wenn die Reihenfolge angegeben ist, in der die Operation ausgef√ºhrt wird.  Beispielsweise h√§ngt kein einzelner Lambda-Ausdruck aus dem Beispiel von ver√§nderlichen Variablen oder externen Raumzust√§nden ab, die sich zur Laufzeit √§ndern k√∂nnen. <br><br><h3>  Verschiedene Arten von F√§den </h3><br>  Streams k√∂nnen aus verschiedenen Quelldaten erstellt werden, haupts√§chlich aus Sammlungen.  Listen und Sets unterst√ºtzen die neuen Methoden <code>stream()</code> und <code>parllelStream()</code> zum Erstellen sequentieller und paralleler Streams.  Parallele Threads k√∂nnen im Multithread-Modus (auf mehreren Threads) arbeiten und werden am Ende des Handbuchs erl√§utert.  Ber√ºcksichtigen Sie in der Zwischenzeit sequenzielle Threads: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Hier gibt der Aufruf der <code>stream()</code> -Methode in einer Liste ein normales Stream-Objekt zur√ºck. <br>  Um mit einem Stream zu arbeiten, ist es jedoch √ºberhaupt nicht erforderlich, eine Sammlung zu erstellen: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Verwenden <code>Stream.of()</code> einfach <code>Stream.of()</code> , um einen Stream aus mehreren Objektreferenzen zu erstellen. <br><br>  Zus√§tzlich zu regul√§ren Objekt-Streams verf√ºgt Java 8 √ºber spezielle Stream-Typen f√ºr die Arbeit mit primitiven Typen: int, long, double.  Wie Sie vielleicht erraten haben, ist dies <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  IntStream-Streams k√∂nnen regul√§re for (;;) - <code>IntStream.range()</code> mithilfe von <code>IntStream.range()</code> ersetzen: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Alle diese Streams f√ºr die Arbeit mit primitiven Typen funktionieren wie normale Streams von Objekten, mit Ausnahme der folgenden: <br><br><ul><li>  Primitive Streams verwenden spezielle Lambda-Ausdr√ºcke.  Zum Beispiel IntFunction anstelle von Function oder IntPredicate anstelle von Predicate. </li><li>  Primitive Streams unterst√ºtzen zus√§tzliche Terminalmethoden: <code>sum()</code> und <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  Manchmal ist es n√ºtzlich, einen Strom von Objekten in einen Strom von Grundelementen umzuwandeln oder umgekehrt.  Zu diesem Zweck unterst√ºtzen Objektfl√ºsse spezielle Methoden: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Str√∂me von <code>mapToObj()</code> k√∂nnen durch Aufrufen von <code>mapToObj()</code> in Str√∂me von Objekten <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  Im folgenden Beispiel wird ein Strom von Gleitkommazahlen einem Strom von Ganzzahlen und dann einem Strom von Objekten zugeordnet: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Ausf√ºhrungsreihenfolge </h3><br>  Nachdem wir gelernt haben, wie man verschiedene Streams erstellt und wie man damit arbeitet, werden wir tiefer eintauchen und √ºberlegen, wie Streaming-Vorg√§nge unter der Haube aussehen. <br><br>  Ein wichtiges Merkmal von Zwischenmethoden ist ihre <i>Faulheit</i> .  In diesem Beispiel gibt es keine Terminalmethode: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Wenn dieser Code ausgef√ºhrt wird, wird nichts an die Konsole ausgegeben.  Und das alles, weil Zwischenmethoden nur ausgef√ºhrt werden, wenn es eine Terminalmethode gibt.  Erweitern wir das Beispiel, indem wir die <code>forEach</code> Terminalmethode hinzuf√ºgen: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Die Ausf√ºhrung dieses Codefragments f√ºhrt zur Ausgabe des folgenden Ergebnisses an die Konsole: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  Die Reihenfolge, in der die Ergebnisse angeordnet sind, kann √ºberraschen.  Man kann naiv erwarten, dass die Methoden ‚Äûhorizontal‚Äú ausgef√ºhrt werden: nacheinander f√ºr alle Elemente des Streams.  Stattdessen bewegt sich das Element jedoch ‚Äûvertikal‚Äú entlang der Kette.  Zuerst durchl√§uft die erste Zeile von ‚Äûd2‚Äú die <code>filter</code> , dann <code>forEach</code> und erst dann, nachdem das erste Element die gesamte Methodenkette durchlaufen hat, beginnt das n√§chste Element mit der Verarbeitung. <br><br>  Aufgrund dieses Verhaltens k√∂nnen Sie die tats√§chliche Anzahl von Vorg√§ngen reduzieren: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  Die <code>anyMatch</code> Methode gibt <i>true zur√ºck</i> , sobald das Pr√§dikat auf das eingehende Element angewendet wird.  In diesem Fall ist dies das zweite Element der Sequenz - "A2".  Dementsprechend wird <code>map</code> aufgrund der "vertikalen" Ausf√ºhrung der Thread-Kette nur zweimal aufgerufen.  Anstatt alle Elemente des Streams anzuzeigen, wird die <code>map</code> so oft wie m√∂glich aufgerufen. <br><br><h3>  Warum Sequenz wichtig ist </h3><br>  Das folgende Beispiel besteht aus zwei Zwischenmethoden <code>map</code> und <code>filter</code> und einer Terminalmethode f√ºr <code>forEach</code> .  √úberlegen Sie, wie diese Methoden ausgef√ºhrt werden: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  Es ist leicht zu erraten, dass sowohl die <code>map</code> als auch die <code>filter</code> zur Laufzeit f√ºnfmal aufgerufen werden - einmal f√ºr jedes Element der Quellensammlung, w√§hrend <code>forEach</code> nur einmal aufgerufen wird - f√ºr das Element, das den Filter bestanden hat. <br><br>  Sie k√∂nnen die Anzahl der Operationen erheblich reduzieren, indem Sie die Reihenfolge der Methodenaufrufe √§ndern, indem Sie zuerst den <code>filter</code> platzieren: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Jetzt wird die Karte nur noch einmal aufgerufen.  Bei einer gro√üen Anzahl von Eingabeelementen werden wir eine sp√ºrbare Steigerung der Produktivit√§t beobachten.  Beachten Sie dies beim Erstellen komplexer Methodenketten. <br><br>  Wir erweitern das obige Beispiel, indem wir eine zus√§tzliche Sortieroperation hinzuf√ºgen - die sortierte Methode: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Das Sortieren ist eine spezielle Art von Zwischenoperation.  Dies ist die sogenannte Stateful-Operation, da zum Sortieren einer Sammlung deren Status w√§hrend der gesamten Operation ber√ºcksichtigt werden muss. <br><br>  Als Ergebnis der Ausf√ºhrung dieses Codes erhalten wir die folgende Ausgabe an die Konsole: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Zun√§chst wird die gesamte Sammlung sortiert.  Mit anderen Worten, die <code>sorted</code> Methode wird horizontal ausgef√ºhrt.  In diesem Fall wird die <code>sorted</code> f√ºr mehrere Kombinationen der Elemente in der eingehenden Sammlung achtmal aufgerufen. <br><br>  Wir optimieren erneut die Ausf√ºhrung dieses Codes, indem wir die Reihenfolge der Methodenaufrufe in der Kette √§ndern: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  In diesem Beispiel wird <code>sorted</code> nicht aufgerufen.  <code>filter</code> reduziert die Eingabesammlung auf ein Element.  Bei gro√üen Eingabedaten wird die Leistung erheblich verbessert. <br><br><h3>  Streams wiederverwenden </h3><br>  In Java 8 k√∂nnen Threads nicht wiederverwendet werden.  Nach dem Aufrufen einer beliebigen Terminalmethode wird der Thread beendet: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Das Aufrufen von <code>noneMatch</code> nach <code>anyMatch</code> in einem Thread f√ºhrt zu der folgenden Ausnahme: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Um diese Einschr√§nkung zu √ºberwinden, sollte f√ºr jede Terminalmethode ein neuer Thread erstellt werden. <br><br>  Sie k√∂nnen beispielsweise einen <i>Lieferanten</i> f√ºr einen neuen Thread-Konstruktor erstellen, in dem alle Zwischenmethoden installiert werden: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Jeder Aufruf der <code>get</code> Methode erstellt einen neuen Thread, in dem Sie die gew√ºnschte Terminalmethode sicher aufrufen k√∂nnen. <br><br><h3>  Fortgeschrittene Methoden </h3><br>  Threads unterst√ºtzen eine Vielzahl unterschiedlicher Methoden.  Wir haben uns bereits mit den wichtigsten Methoden vertraut gemacht.  Informationen zum Rest finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Und jetzt tauchen Sie noch tiefer in komplexere Methoden ein: <code>collect</code> , <code>flatMap</code> und <code>reduce</code> . <br><br>  Die meisten Codebeispiele in diesem Abschnitt beziehen sich auf das folgende Codefragment, um die Funktionsweise zu demonstrieren: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Sammeln </h4><br>  <code>Collect</code> sehr n√ºtzliche Terminalmethode, mit der Stream-Elemente in ein Ergebnis eines anderen Typs konvertiert werden, z. B. List, Set oder Map. <br><br>  <code>Collect</code> akzeptiert einen <code>Collector</code> , der vier verschiedene Methoden enth√§lt: einen Lieferanten.  Akku, Kombinierer, Finisher.  Auf den ersten Blick sieht dies sehr kompliziert aus, aber Java 8 unterst√ºtzt verschiedene integrierte Kollektoren √ºber die <code>Collectors</code> Klasse, in der die am h√§ufigsten verwendeten Methoden implementiert sind. <br><br>  Beliebter Fall: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, ist das Erstellen einer Liste aus Stream-Elementen sehr einfach.  Ben√∂tigen Sie keine Liste, aber viel?  Verwenden Sie <code>Collectors.toSet()</code> . <br><br>  Im folgenden Beispiel werden Personen nach Alter gruppiert: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Sammler sind unglaublich vielf√§ltig.  Sie k√∂nnen auch die Elemente der Sammlung aggregieren, z. B. das Durchschnittsalter bestimmen: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Um umfassendere Statistiken zu erhalten, verwenden wir einen Zusammenfassungskollektor, der ein spezielles Objekt mit Informationen zur√ºckgibt: Minimal-, Maximal- und Durchschnittswerte, die Summe der Werte und die Anzahl der Elemente: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  Im folgenden Beispiel werden alle Namen in einer Zeile zusammengefasst: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  Der Verbindungskollektor akzeptiert ein Trennzeichen sowie ein optionales Pr√§fix und Suffix. <br><br>  Um die Elemente eines Streams in eine Anzeige umzuwandeln, m√ºssen Sie festlegen, wie Schl√ºssel und Werte angezeigt werden sollen.  Denken Sie daran, dass die Schl√ºssel in der Zuordnung eindeutig sein m√ºssen.  Andernfalls erhalten wir eine <code>IllegalStateException</code> .  Sie k√∂nnen optional eine Zusammenf√ºhrungsfunktion hinzuf√ºgen, um die Ausnahme zu umgehen: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  So haben wir einige der leistungsst√§rksten eingebauten Sammler kennengelernt.  Lassen Sie uns versuchen, Ihre eigenen zu bauen.  Wir m√∂chten alle Elemente des Streams in eine einzelne Zeile konvertieren, die aus Gro√übuchstaben besteht, die durch einen vertikalen Balken | getrennt sind.  Erstellen Sie dazu mit <code>Collector.of()</code> einen neuen <code>Collector.of()</code> .  Wir ben√∂tigen die vier Komponenten unseres Kollektors: Lieferant, Batterie, Stecker, Finisher. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Da Strings in Java unver√§nderlich sind, ben√∂tigen wir eine <code>StringJoiner</code> wie <code>StringJoiner</code> , mit der der Collector einen String f√ºr uns erstellen kann.  Im ersten Schritt erstellt der Anbieter einen <code>StringJoiner</code> mit einem zugewiesenen Trennzeichen.  Mit der Batterie wird jeder Name zu <code>StringJoiner</code> . <br><br>  Der Connector wei√ü, wie zwei <code>StringJoiner</code> zu einem verbunden werden.  Und am Ende erstellt der Finisher den gew√ºnschten String aus <code>StringJoiner</code> s. <br><br><h4>  Flatmap </h4><br>  Daher haben wir gelernt, wie Stream-Objekte mithilfe der <code>map</code> in andere <code>map</code> werden.  <code>Map</code> ist eine Art eingeschr√§nkte Methode, da jedes Objekt nur einem anderen Objekt zugeordnet werden kann.  Was aber, wenn Sie ein Objekt vielen anderen zuordnen oder gar nicht anzeigen m√∂chten?  Hier hilft die <code>flatMap</code> Methode.  <code>FlatMap</code> verwandelt jedes Stream-Objekt in einen Stream anderer Objekte.  Der Inhalt dieser Threads wird dann in den zur√ºckgegebenen Stream der <code>flatMap</code> Methode <code>flatMap</code> . <br><br>  Um <code>flatMap</code> in Aktion zu betrachten, <code>flatMap</code> wir eine geeignete <code>flatMap</code> f√ºr ein Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Lassen Sie uns einige Objekte erstellen: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Jetzt haben wir eine Liste von drei <i>foo</i> , von denen jeder drei <i>Balken</i> enth√§lt. <br><br>  <code>FlatMap</code> akzeptiert eine Funktion, die einen Strom von Objekten zur√ºckgeben soll.  Um auf die <i>Balkenobjekte</i> jedes <i>Foo</i> zugreifen zu k√∂nnen, m√ºssen wir nur die entsprechende Funktion finden: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Wir haben also erfolgreich einen Stream von drei <i>foo-</i> Objekten in einen Stream von 9 <i>Balkenobjekten umgewandelt</i> . <br><br>  Schlie√ülich kann der gesamte obige Code auf eine einfache Pipeline von Operationen reduziert werden: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> auch in der in Java 8 eingef√ºhrten <code>Optional</code> Klasse verf√ºgbar. <code>FlatMap</code> aus der <code>Optional</code> Klasse gibt ein optionales Objekt einer anderen Klasse zur√ºck.  Dies kann verwendet werden, um eine Reihe von <code>null</code> zu vermeiden. <br><br>  Stellen Sie sich eine hierarchische Struktur wie diese vor: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Um die verschachtelte Zeichenfolge <i>foo</i> von einem externen Objekt <code>NullPointException</code> , m√ºssen Sie mehrere <code>NullPointException</code> hinzuf√ºgen, um eine <code>NullPointException</code> zu vermeiden: <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  Dasselbe kann mit der flatMap der optionalen Klasse erreicht werden: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Jeder Aufruf von <code>flatMap</code> gibt einen <code>Optional</code> Wrapper f√ºr das gew√ºnschte Objekt zur√ºck, falls vorhanden, oder f√ºr <code>null</code> wenn das Objekt fehlt. <br><br><h4>  Reduzieren </h4><br>  Die Vereinfachungsoperation kombiniert alle Elemente eines Streams zu einem einzigen Ergebnis.  Java 8 unterst√ºtzt drei verschiedene Arten von Reduktionsmethoden. <br><br>  Der erste reduziert den Fluss von Elementen auf ein einzelnes Flusselement.  Wir verwenden diese Methode, um das Element mit dem gr√∂√üten Alter zu bestimmen: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  Die <code>reduce</code> √ºbernimmt eine Akkumulationsfunktion mit einem <i>Bin√§roperator</i> (BinaryOperator).  Hier ist <code>reduce</code> eine <i>Bi-Funktion</i> (BiFunction), bei der beide Argumente zum selben Typ geh√∂ren.  In unserem Fall zum Typ <i>Person</i> .  Eine Bi-Funktion ist fast die gleiche wie eine <code></code> , ben√∂tigt jedoch zwei Argumente.  In unserem Beispiel vergleicht die Funktion das Alter von zwei Personen und gibt ein Element mit einem h√∂heren Alter zur√ºck. <br><br>  Die n√§chste Form der <code>reduce</code> verwendet sowohl einen Anfangswert als auch eine Batterie mit einem bin√§ren Operator.  Mit dieser Methode k√∂nnen Sie ein neues Element erstellen.  Wir haben - <i>Person</i> mit einem Namen und Alter, bestehend aus der Addition aller Namen und der Summe der gelebten Jahre: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  Die dritte <code>reduce</code> verwendet drei Parameter: den Anfangswert, den Akkumulator mit einer Bi-Funktion und eine Kombinationsfunktion wie ein bin√§rer Operator.  Da der Anfangswert des Typs nicht auf den Typ Person beschr√§nkt ist, k√∂nnen Sie mithilfe der Reduzierung die Gesamtzahl der gelebten Jahre jeder Person bestimmen: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, haben wir das Ergebnis 76 erhalten, aber was passiert wirklich unter der Haube? <br><br>  Wir erweitern das obige Codefragment mit der Ausgabe des Textes f√ºr das Debug: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, f√ºhrt die Akkumulationsfunktion die gesamte Arbeit aus.  Es wird zuerst mit einem Anfangswert von 0 und der ersten Person max aufgerufen.  In den n√§chsten drei Schritten erh√∂ht sich die Summe vom letzten Schritt bis zum Erreichen eines Gesamtalters von 76 Jahren st√§ndig um das Alter der Person. <br><br>  Und was dann?  Wird der Kombinierer nie gerufen?  Betrachten Sie die parallele Ausf√ºhrung dieses Threads: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Bei paralleler Ausf√ºhrung erhalten wir eine v√∂llig andere Konsolenausgabe.  Jetzt wird der Kombinierer wirklich gerufen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Batterie parallel aufgerufen wurde, musste der Kombinierer die separat gespeicherten Werte zusammenfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im n√§chsten Kapitel werden wir die parallele Ausf√ºhrung von Threads genauer untersuchen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallele F√§den </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads k√∂nnen parallel ausgef√ºhrt werden, um die Leistung bei der Verarbeitung einer gro√üen Anzahl eingehender Elemente zu verbessern. </font><font style="vertical-align: inherit;">Parallele Threads verwenden das √ºbliche, </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das durch einen Aufruf der statischen Methode verf√ºgbar ist </font></font><code>ForkJoinPool.commonPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Gr√∂√üe des Haupt-Thread-Pools kann 5 Ausf√ºhrungsthreads erreichen - die genaue Anzahl h√§ngt von der Anzahl der verf√ºgbaren physischen Prozessorkerne ab.</font></font><br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf meinem Computer wird standardm√§√üig ein regul√§rer Thread-Pool mit Parallelisierung in 3 Threads initialisiert. </font><font style="vertical-align: inherit;">Dieser Wert kann durch Einstellen des folgenden JVM-Parameters erh√∂ht oder verringert werden:</font></font><br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammlungen unterst√ºtzen eine Methode </font></font><code>parallelStream()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Erstellen paralleler Datenstr√∂me. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch eine Zwischenmethode aufrufen </font></font><code>parallel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um einen seriellen Stream in einen parallelen zu verwandeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Verhalten eines Threads bei der parallelen Ausf√ºhrung zu verstehen, werden im folgenden Beispiel Informationen zu jedem aktuellen Thread (Thread) gedruckt an </font></font><code>System.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie die Schlussfolgerungen mit den Debug-Eintr√§gen, um besser zu verstehen, welcher Thread zum Ausf√ºhren bestimmter Stream-Methoden verwendet wird: </font></font><br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, werden bei der parallelen Ausf√ºhrung des Datenstroms alle verf√ºgbaren Threads des aktuellen verwendet </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Ausgabesequenz kann unterschiedlich sein, da die Ausf√ºhrungssequenz f√ºr jeden bestimmten Thread nicht definiert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern wir das Beispiel durch Hinzuf√ºgen einer Methode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf den ersten Blick mag das Ergebnis seltsam erscheinen: </font></font><br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint , </font><font style="vertical-align: inherit;">als ob </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konsequent und nur in dem Fluss des gef√ºhrte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn der Stream parallel unter der Haube der Methode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der Stream-API ausgef√ºhrt wird </font></font><code>Arrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist die in Java 8 hinzugef√ºgte </font><font style="vertical-align: inherit;">Klassensortierungsmethode ausgeblendet </font></font><code>Arrays.parallelSort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie in der Dokumentation angegeben, bestimmt diese Methode basierend auf der L√§nge der eingehenden Sammlung, wie sie parallel oder nacheinander sortiert wird:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die L√§nge eines bestimmten Arrays kleiner als das minimale ‚ÄûKorn‚Äú ist, wird die Sortierung durch Ausf√ºhren der Methode Arrays.sort durchgef√ºhrt. </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zum Beispiel mit der Methode </font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem vorherigen Kapitel zur√ºck. </font><font style="vertical-align: inherit;">Wir haben bereits herausgefunden, dass die Vereinheitlichungsfunktion nur aufgerufen wird, wenn mit dem Thread parallel gearbeitet wird. </font><font style="vertical-align: inherit;">√úberlegen Sie, welche Threads betroffen sind:</font></font><br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Konsolenausgabe zeigt, dass beide Funktionen: Akkumulieren und Kombinieren parallel ausgef√ºhrt werden, wobei alle m√∂glichen Abl√§ufe verwendet werden: </font></font><br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann argumentiert werden, dass die parallele Ausf√ºhrung des Flusses zu einer signifikanten Steigerung der Effizienz beim Arbeiten mit gro√üen Mengen eingehender Elemente beitr√§gt. </font><font style="vertical-align: inherit;">Es ist jedoch zu beachten, dass einige Methoden bei der parallelen Ausf√ºhrung zus√§tzliche Berechnungen (Kombinationsoperationen) erfordern, die bei der sequentiellen Ausf√ºhrung nicht erforderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus wird f√ºr die parallele Ausf√ºhrung des Threads derselbe </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, der in der JVM so h√§ufig verwendet wird. </font><font style="vertical-align: inherit;">Die Verwendung langsamer Blockierungsmethoden des Flusses kann sich daher negativ auf die Leistung des gesamten Programms auswirken, da Threads blockiert werden, die f√ºr die Verarbeitung in anderen Aufgaben verwendet werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Tutorial zur Verwendung von Threads in Java 8 ist beendet. Weitere Informationen zum Arbeiten mit Streams finden Sie in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie tiefer gehen und mehr √ºber die Mechanismen erfahren m√∂chten, die Threads zugrunde liegen, k√∂nnten Sie einen Artikel von Martin Fowler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collection Pipelines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich auch f√ºr JavaScript interessieren, sollten Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream.js ansehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die JavaScript-Implementierung der Java 8 Streams-API. Vielleicht m√∂chten Sie auch meine Artikel √ºber das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 8-Tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">russische √úbersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Habr√©) und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 8 Nashorn-Tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, dieser Leitfaden war n√ºtzlich und interessant f√ºr Sie und Sie haben den Lesevorgang genossen. </font><font style="vertical-align: inherit;">Der vollst√§ndige Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird auf GitHub gespeichert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">F√ºhlen Sie sich frei, einen Zweig im Repository zu erstellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437038/">https://habr.com/ru/post/de437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437026/index.html">Google in Frankreich verurteilte die DSGVO wegen Missbrauchs personenbezogener Daten zu einer Geldstrafe von 50 Millionen Euro</a></li>
<li><a href="../de437030/index.html">Automatisierung der Infrastruktur eines Luxusb√ºros: wie es aussieht</a></li>
<li><a href="../de437032/index.html">Installationsanleitung f√ºr NGINX ModSecurity</a></li>
<li><a href="../de437034/index.html">Universal Whistles: Snom A230 und A210 USB Dongle Review</a></li>
<li><a href="../de437036/index.html">SAPUI5 f√ºr Dummies Teil 2: Eine vollst√§ndige Schritt-f√ºr-Schritt-√úbung</a></li>
<li><a href="../de437040/index.html">In Russland begann der Test der inl√§ndischen neuronalen Schnittstelle "Neurochat"</a></li>
<li><a href="../de437044/index.html">So besiegen Sie den Drachen: Schreiben Sie Ihr Programm auf Golang neu</a></li>
<li><a href="../de437050/index.html">Das Buch "Python. Expresskurs. 3rd ed.</a></li>
<li><a href="../de437052/index.html">Verpassen Sie nicht zu lernen: Braucht ein Universit√§ts-IT-Spezialist</a></li>
<li><a href="../de437054/index.html">Neue Intel Prozessoren der 9. Generation: Core minus GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>