<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦‍👦 💇🏼 🎭 Benjamin Winterberg Stream API Guide Übersetzung 👨🏻‍🎓 🎻 🤞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels " Java 8 Stream Tutorial ". 

 Dieses Tutorial, das auf Codebeispielen basiert, bietet ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benjamin Winterberg Stream API Guide Übersetzung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java 8 Stream Tutorial</a> ". <br><br>  Dieses Tutorial, das auf Codebeispielen basiert, bietet einen umfassenden Überblick über Streams in Java 8. Als ich die Stream-API zum ersten Mal einführte, war ich über den Namen verwirrt, da er sehr gut mit InputStream und OutputStream aus dem Paket java.io übereinstimmt.  Threads in Java 8 sind jedoch etwas völlig anderes. <a name="habracut"></a>  Threads sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monaden</a> , die eine wichtige Rolle bei der Entwicklung der funktionalen Programmierung in Java spielen. <br><blockquote>  In der funktionalen Programmierung ist eine Monade eine Struktur, die eine Berechnung in Form einer Kette aufeinanderfolgender Schritte darstellt.  Der Typ und die Struktur einer Monade bestimmen eine Operationskette, in unserem Fall eine Folge von Methoden mit integrierten Funktionen eines bestimmten Typs. </blockquote>  In diesem Handbuch erfahren Sie, wie Sie mit Streams arbeiten und wie Sie mit den verschiedenen in der Stream-API verfügbaren Methoden umgehen.  Wir werden die Reihenfolge der Operationen analysieren und sehen, wie sich die Reihenfolge der Methoden in der Kette auf die Leistung auswirkt.  <code>flatMap</code> Sie <code>flatMap</code> leistungsstarken Stream-API-Methoden wie <code>reduce</code> , <code>collect</code> und <code>flatMap</code> .  Am Ende des Handbuchs werden wir auf die parallele Arbeit mit Threads achten. <br><br>  Wenn Sie nicht frei sind, mit Lambda-Ausdrücken, funktionalen Schnittstellen und Referenzmethoden zu arbeiten, ist es hilfreich, sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Leitfaden zu Innovationen in Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré) vertraut zu machen und danach wieder mit dem Studium von Flows zu beginnen. <br><br><h3>  Wie Threads funktionieren </h3><br>  Ein Stream stellt eine Folge von Elementen dar und bietet verschiedene Methoden zum Durchführen von Berechnungen für diese Elemente: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Strömungsmethoden sind <i>Intermediate</i> (Intermediate) und <i>Terminal</i> (Terminal).  Zwischenmethoden geben einen Stream zurück, wodurch viele dieser Methoden nacheinander aufgerufen werden können.  Terminalmethoden geben entweder keinen Wert (void) oder ein Ergebnis eines anderen Typs als eines Streams zurück.  Im obigen Beispiel sind die <code>filter</code> , <code>map</code> und <code>sorted</code> intermediär und <code>forEach</code> sind terminal.  Eine vollständige Liste der verfügbaren Flussmethoden finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Eine solche Kette von Stream-Operationen ist auch als Operations-Pipeline bekannt. <br><br>  Die meisten Methoden der Stream-API akzeptieren als Parameter Lambda-Ausdrücke, eine funktionale Schnittstelle, die das spezifische Verhalten der Methode beschreibt.  Die meisten von ihnen müssen gleichzeitig störungsfrei und staatenlos sein.  Was bedeutet das? <br><br>  Eine Methode ist nicht störend, wenn sie die zugrunde liegenden Daten, die dem Stream zugrunde liegen, nicht ändert.  Im obigen Beispiel ändern beispielsweise keine Lambda-Ausdrücke das Listenarray myList. <br><br>  Eine Methode ist zustandslos, wenn die Reihenfolge angegeben ist, in der die Operation ausgeführt wird.  Beispielsweise hängt kein einzelner Lambda-Ausdruck aus dem Beispiel von veränderlichen Variablen oder externen Raumzuständen ab, die sich zur Laufzeit ändern können. <br><br><h3>  Verschiedene Arten von Fäden </h3><br>  Streams können aus verschiedenen Quelldaten erstellt werden, hauptsächlich aus Sammlungen.  Listen und Sets unterstützen die neuen Methoden <code>stream()</code> und <code>parllelStream()</code> zum Erstellen sequentieller und paralleler Streams.  Parallele Threads können im Multithread-Modus (auf mehreren Threads) arbeiten und werden am Ende des Handbuchs erläutert.  Berücksichtigen Sie in der Zwischenzeit sequenzielle Threads: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Hier gibt der Aufruf der <code>stream()</code> -Methode in einer Liste ein normales Stream-Objekt zurück. <br>  Um mit einem Stream zu arbeiten, ist es jedoch überhaupt nicht erforderlich, eine Sammlung zu erstellen: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Verwenden <code>Stream.of()</code> einfach <code>Stream.of()</code> , um einen Stream aus mehreren Objektreferenzen zu erstellen. <br><br>  Zusätzlich zu regulären Objekt-Streams verfügt Java 8 über spezielle Stream-Typen für die Arbeit mit primitiven Typen: int, long, double.  Wie Sie vielleicht erraten haben, ist dies <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  IntStream-Streams können reguläre for (;;) - <code>IntStream.range()</code> mithilfe von <code>IntStream.range()</code> ersetzen: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Alle diese Streams für die Arbeit mit primitiven Typen funktionieren wie normale Streams von Objekten, mit Ausnahme der folgenden: <br><br><ul><li>  Primitive Streams verwenden spezielle Lambda-Ausdrücke.  Zum Beispiel IntFunction anstelle von Function oder IntPredicate anstelle von Predicate. </li><li>  Primitive Streams unterstützen zusätzliche Terminalmethoden: <code>sum()</code> und <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  Manchmal ist es nützlich, einen Strom von Objekten in einen Strom von Grundelementen umzuwandeln oder umgekehrt.  Zu diesem Zweck unterstützen Objektflüsse spezielle Methoden: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Ströme von <code>mapToObj()</code> können durch Aufrufen von <code>mapToObj()</code> in Ströme von Objekten <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  Im folgenden Beispiel wird ein Strom von Gleitkommazahlen einem Strom von Ganzzahlen und dann einem Strom von Objekten zugeordnet: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Ausführungsreihenfolge </h3><br>  Nachdem wir gelernt haben, wie man verschiedene Streams erstellt und wie man damit arbeitet, werden wir tiefer eintauchen und überlegen, wie Streaming-Vorgänge unter der Haube aussehen. <br><br>  Ein wichtiges Merkmal von Zwischenmethoden ist ihre <i>Faulheit</i> .  In diesem Beispiel gibt es keine Terminalmethode: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Wenn dieser Code ausgeführt wird, wird nichts an die Konsole ausgegeben.  Und das alles, weil Zwischenmethoden nur ausgeführt werden, wenn es eine Terminalmethode gibt.  Erweitern wir das Beispiel, indem wir die <code>forEach</code> Terminalmethode hinzufügen: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Die Ausführung dieses Codefragments führt zur Ausgabe des folgenden Ergebnisses an die Konsole: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  Die Reihenfolge, in der die Ergebnisse angeordnet sind, kann überraschen.  Man kann naiv erwarten, dass die Methoden „horizontal“ ausgeführt werden: nacheinander für alle Elemente des Streams.  Stattdessen bewegt sich das Element jedoch „vertikal“ entlang der Kette.  Zuerst durchläuft die erste Zeile von „d2“ die <code>filter</code> , dann <code>forEach</code> und erst dann, nachdem das erste Element die gesamte Methodenkette durchlaufen hat, beginnt das nächste Element mit der Verarbeitung. <br><br>  Aufgrund dieses Verhaltens können Sie die tatsächliche Anzahl von Vorgängen reduzieren: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  Die <code>anyMatch</code> Methode gibt <i>true zurück</i> , sobald das Prädikat auf das eingehende Element angewendet wird.  In diesem Fall ist dies das zweite Element der Sequenz - "A2".  Dementsprechend wird <code>map</code> aufgrund der "vertikalen" Ausführung der Thread-Kette nur zweimal aufgerufen.  Anstatt alle Elemente des Streams anzuzeigen, wird die <code>map</code> so oft wie möglich aufgerufen. <br><br><h3>  Warum Sequenz wichtig ist </h3><br>  Das folgende Beispiel besteht aus zwei Zwischenmethoden <code>map</code> und <code>filter</code> und einer Terminalmethode für <code>forEach</code> .  Überlegen Sie, wie diese Methoden ausgeführt werden: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  Es ist leicht zu erraten, dass sowohl die <code>map</code> als auch die <code>filter</code> zur Laufzeit fünfmal aufgerufen werden - einmal für jedes Element der Quellensammlung, während <code>forEach</code> nur einmal aufgerufen wird - für das Element, das den Filter bestanden hat. <br><br>  Sie können die Anzahl der Operationen erheblich reduzieren, indem Sie die Reihenfolge der Methodenaufrufe ändern, indem Sie zuerst den <code>filter</code> platzieren: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Jetzt wird die Karte nur noch einmal aufgerufen.  Bei einer großen Anzahl von Eingabeelementen werden wir eine spürbare Steigerung der Produktivität beobachten.  Beachten Sie dies beim Erstellen komplexer Methodenketten. <br><br>  Wir erweitern das obige Beispiel, indem wir eine zusätzliche Sortieroperation hinzufügen - die sortierte Methode: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Das Sortieren ist eine spezielle Art von Zwischenoperation.  Dies ist die sogenannte Stateful-Operation, da zum Sortieren einer Sammlung deren Status während der gesamten Operation berücksichtigt werden muss. <br><br>  Als Ergebnis der Ausführung dieses Codes erhalten wir die folgende Ausgabe an die Konsole: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Zunächst wird die gesamte Sammlung sortiert.  Mit anderen Worten, die <code>sorted</code> Methode wird horizontal ausgeführt.  In diesem Fall wird die <code>sorted</code> für mehrere Kombinationen der Elemente in der eingehenden Sammlung achtmal aufgerufen. <br><br>  Wir optimieren erneut die Ausführung dieses Codes, indem wir die Reihenfolge der Methodenaufrufe in der Kette ändern: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  In diesem Beispiel wird <code>sorted</code> nicht aufgerufen.  <code>filter</code> reduziert die Eingabesammlung auf ein Element.  Bei großen Eingabedaten wird die Leistung erheblich verbessert. <br><br><h3>  Streams wiederverwenden </h3><br>  In Java 8 können Threads nicht wiederverwendet werden.  Nach dem Aufrufen einer beliebigen Terminalmethode wird der Thread beendet: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Das Aufrufen von <code>noneMatch</code> nach <code>anyMatch</code> in einem Thread führt zu der folgenden Ausnahme: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Um diese Einschränkung zu überwinden, sollte für jede Terminalmethode ein neuer Thread erstellt werden. <br><br>  Sie können beispielsweise einen <i>Lieferanten</i> für einen neuen Thread-Konstruktor erstellen, in dem alle Zwischenmethoden installiert werden: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Jeder Aufruf der <code>get</code> Methode erstellt einen neuen Thread, in dem Sie die gewünschte Terminalmethode sicher aufrufen können. <br><br><h3>  Fortgeschrittene Methoden </h3><br>  Threads unterstützen eine Vielzahl unterschiedlicher Methoden.  Wir haben uns bereits mit den wichtigsten Methoden vertraut gemacht.  Informationen zum Rest finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Und jetzt tauchen Sie noch tiefer in komplexere Methoden ein: <code>collect</code> , <code>flatMap</code> und <code>reduce</code> . <br><br>  Die meisten Codebeispiele in diesem Abschnitt beziehen sich auf das folgende Codefragment, um die Funktionsweise zu demonstrieren: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Sammeln </h4><br>  <code>Collect</code> sehr nützliche Terminalmethode, mit der Stream-Elemente in ein Ergebnis eines anderen Typs konvertiert werden, z. B. List, Set oder Map. <br><br>  <code>Collect</code> akzeptiert einen <code>Collector</code> , der vier verschiedene Methoden enthält: einen Lieferanten.  Akku, Kombinierer, Finisher.  Auf den ersten Blick sieht dies sehr kompliziert aus, aber Java 8 unterstützt verschiedene integrierte Kollektoren über die <code>Collectors</code> Klasse, in der die am häufigsten verwendeten Methoden implementiert sind. <br><br>  Beliebter Fall: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Wie Sie sehen können, ist das Erstellen einer Liste aus Stream-Elementen sehr einfach.  Benötigen Sie keine Liste, aber viel?  Verwenden Sie <code>Collectors.toSet()</code> . <br><br>  Im folgenden Beispiel werden Personen nach Alter gruppiert: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Sammler sind unglaublich vielfältig.  Sie können auch die Elemente der Sammlung aggregieren, z. B. das Durchschnittsalter bestimmen: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Um umfassendere Statistiken zu erhalten, verwenden wir einen Zusammenfassungskollektor, der ein spezielles Objekt mit Informationen zurückgibt: Minimal-, Maximal- und Durchschnittswerte, die Summe der Werte und die Anzahl der Elemente: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  Im folgenden Beispiel werden alle Namen in einer Zeile zusammengefasst: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  Der Verbindungskollektor akzeptiert ein Trennzeichen sowie ein optionales Präfix und Suffix. <br><br>  Um die Elemente eines Streams in eine Anzeige umzuwandeln, müssen Sie festlegen, wie Schlüssel und Werte angezeigt werden sollen.  Denken Sie daran, dass die Schlüssel in der Zuordnung eindeutig sein müssen.  Andernfalls erhalten wir eine <code>IllegalStateException</code> .  Sie können optional eine Zusammenführungsfunktion hinzufügen, um die Ausnahme zu umgehen: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  So haben wir einige der leistungsstärksten eingebauten Sammler kennengelernt.  Lassen Sie uns versuchen, Ihre eigenen zu bauen.  Wir möchten alle Elemente des Streams in eine einzelne Zeile konvertieren, die aus Großbuchstaben besteht, die durch einen vertikalen Balken | getrennt sind.  Erstellen Sie dazu mit <code>Collector.of()</code> einen neuen <code>Collector.of()</code> .  Wir benötigen die vier Komponenten unseres Kollektors: Lieferant, Batterie, Stecker, Finisher. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Da Strings in Java unveränderlich sind, benötigen wir eine <code>StringJoiner</code> wie <code>StringJoiner</code> , mit der der Collector einen String für uns erstellen kann.  Im ersten Schritt erstellt der Anbieter einen <code>StringJoiner</code> mit einem zugewiesenen Trennzeichen.  Mit der Batterie wird jeder Name zu <code>StringJoiner</code> . <br><br>  Der Connector weiß, wie zwei <code>StringJoiner</code> zu einem verbunden werden.  Und am Ende erstellt der Finisher den gewünschten String aus <code>StringJoiner</code> s. <br><br><h4>  Flatmap </h4><br>  Daher haben wir gelernt, wie Stream-Objekte mithilfe der <code>map</code> in andere <code>map</code> werden.  <code>Map</code> ist eine Art eingeschränkte Methode, da jedes Objekt nur einem anderen Objekt zugeordnet werden kann.  Was aber, wenn Sie ein Objekt vielen anderen zuordnen oder gar nicht anzeigen möchten?  Hier hilft die <code>flatMap</code> Methode.  <code>FlatMap</code> verwandelt jedes Stream-Objekt in einen Stream anderer Objekte.  Der Inhalt dieser Threads wird dann in den zurückgegebenen Stream der <code>flatMap</code> Methode <code>flatMap</code> . <br><br>  Um <code>flatMap</code> in Aktion zu betrachten, <code>flatMap</code> wir eine geeignete <code>flatMap</code> für ein Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Lassen Sie uns einige Objekte erstellen: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Jetzt haben wir eine Liste von drei <i>foo</i> , von denen jeder drei <i>Balken</i> enthält. <br><br>  <code>FlatMap</code> akzeptiert eine Funktion, die einen Strom von Objekten zurückgeben soll.  Um auf die <i>Balkenobjekte</i> jedes <i>Foo</i> zugreifen zu können, müssen wir nur die entsprechende Funktion finden: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Wir haben also erfolgreich einen Stream von drei <i>foo-</i> Objekten in einen Stream von 9 <i>Balkenobjekten umgewandelt</i> . <br><br>  Schließlich kann der gesamte obige Code auf eine einfache Pipeline von Operationen reduziert werden: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> auch in der in Java 8 eingeführten <code>Optional</code> Klasse verfügbar. <code>FlatMap</code> aus der <code>Optional</code> Klasse gibt ein optionales Objekt einer anderen Klasse zurück.  Dies kann verwendet werden, um eine Reihe von <code>null</code> zu vermeiden. <br><br>  Stellen Sie sich eine hierarchische Struktur wie diese vor: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Um die verschachtelte Zeichenfolge <i>foo</i> von einem externen Objekt <code>NullPointException</code> , müssen Sie mehrere <code>NullPointException</code> hinzufügen, um eine <code>NullPointException</code> zu vermeiden: <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  Dasselbe kann mit der flatMap der optionalen Klasse erreicht werden: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Jeder Aufruf von <code>flatMap</code> gibt einen <code>Optional</code> Wrapper für das gewünschte Objekt zurück, falls vorhanden, oder für <code>null</code> wenn das Objekt fehlt. <br><br><h4>  Reduzieren </h4><br>  Die Vereinfachungsoperation kombiniert alle Elemente eines Streams zu einem einzigen Ergebnis.  Java 8 unterstützt drei verschiedene Arten von Reduktionsmethoden. <br><br>  Der erste reduziert den Fluss von Elementen auf ein einzelnes Flusselement.  Wir verwenden diese Methode, um das Element mit dem größten Alter zu bestimmen: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  Die <code>reduce</code> übernimmt eine Akkumulationsfunktion mit einem <i>Binäroperator</i> (BinaryOperator).  Hier ist <code>reduce</code> eine <i>Bi-Funktion</i> (BiFunction), bei der beide Argumente zum selben Typ gehören.  In unserem Fall zum Typ <i>Person</i> .  Eine Bi-Funktion ist fast die gleiche wie eine <code></code> , benötigt jedoch zwei Argumente.  In unserem Beispiel vergleicht die Funktion das Alter von zwei Personen und gibt ein Element mit einem höheren Alter zurück. <br><br>  Die nächste Form der <code>reduce</code> verwendet sowohl einen Anfangswert als auch eine Batterie mit einem binären Operator.  Mit dieser Methode können Sie ein neues Element erstellen.  Wir haben - <i>Person</i> mit einem Namen und Alter, bestehend aus der Addition aller Namen und der Summe der gelebten Jahre: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  Die dritte <code>reduce</code> verwendet drei Parameter: den Anfangswert, den Akkumulator mit einer Bi-Funktion und eine Kombinationsfunktion wie ein binärer Operator.  Da der Anfangswert des Typs nicht auf den Typ Person beschränkt ist, können Sie mithilfe der Reduzierung die Gesamtzahl der gelebten Jahre jeder Person bestimmen: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Wie Sie sehen können, haben wir das Ergebnis 76 erhalten, aber was passiert wirklich unter der Haube? <br><br>  Wir erweitern das obige Codefragment mit der Ausgabe des Textes für das Debug: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Wie Sie sehen können, führt die Akkumulationsfunktion die gesamte Arbeit aus.  Es wird zuerst mit einem Anfangswert von 0 und der ersten Person max aufgerufen.  In den nächsten drei Schritten erhöht sich die Summe vom letzten Schritt bis zum Erreichen eines Gesamtalters von 76 Jahren ständig um das Alter der Person. <br><br>  Und was dann?  Wird der Kombinierer nie gerufen?  Betrachten Sie die parallele Ausführung dieses Threads: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Bei paralleler Ausführung erhalten wir eine völlig andere Konsolenausgabe.  Jetzt wird der Kombinierer wirklich gerufen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Batterie parallel aufgerufen wurde, musste der Kombinierer die separat gespeicherten Werte zusammenfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im nächsten Kapitel werden wir die parallele Ausführung von Threads genauer untersuchen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallele Fäden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads können parallel ausgeführt werden, um die Leistung bei der Verarbeitung einer großen Anzahl eingehender Elemente zu verbessern. </font><font style="vertical-align: inherit;">Parallele Threads verwenden das übliche, </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das durch einen Aufruf der statischen Methode verfügbar ist </font></font><code>ForkJoinPool.commonPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Größe des Haupt-Thread-Pools kann 5 Ausführungsthreads erreichen - die genaue Anzahl hängt von der Anzahl der verfügbaren physischen Prozessorkerne ab.</font></font><br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf meinem Computer wird standardmäßig ein regulärer Thread-Pool mit Parallelisierung in 3 Threads initialisiert. </font><font style="vertical-align: inherit;">Dieser Wert kann durch Einstellen des folgenden JVM-Parameters erhöht oder verringert werden:</font></font><br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammlungen unterstützen eine Methode </font></font><code>parallelStream()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Erstellen paralleler Datenströme. </font><font style="vertical-align: inherit;">Sie können auch eine Zwischenmethode aufrufen </font></font><code>parallel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um einen seriellen Stream in einen parallelen zu verwandeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Verhalten eines Threads bei der parallelen Ausführung zu verstehen, werden im folgenden Beispiel Informationen zu jedem aktuellen Thread (Thread) gedruckt an </font></font><code>System.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie die Schlussfolgerungen mit den Debug-Einträgen, um besser zu verstehen, welcher Thread zum Ausführen bestimmter Stream-Methoden verwendet wird: </font></font><br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, werden bei der parallelen Ausführung des Datenstroms alle verfügbaren Threads des aktuellen verwendet </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Ausgabesequenz kann unterschiedlich sein, da die Ausführungssequenz für jeden bestimmten Thread nicht definiert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern wir das Beispiel durch Hinzufügen einer Methode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf den ersten Blick mag das Ergebnis seltsam erscheinen: </font></font><br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint , </font><font style="vertical-align: inherit;">als ob </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konsequent und nur in dem Fluss des geführte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn der Stream parallel unter der Haube der Methode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der Stream-API ausgeführt wird </font></font><code>Arrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist die in Java 8 hinzugefügte </font><font style="vertical-align: inherit;">Klassensortierungsmethode ausgeblendet </font></font><code>Arrays.parallelSort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie in der Dokumentation angegeben, bestimmt diese Methode basierend auf der Länge der eingehenden Sammlung, wie sie parallel oder nacheinander sortiert wird:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Länge eines bestimmten Arrays kleiner als das minimale „Korn“ ist, wird die Sortierung durch Ausführen der Methode Arrays.sort durchgeführt. </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zum Beispiel mit der Methode </font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem vorherigen Kapitel zurück. </font><font style="vertical-align: inherit;">Wir haben bereits herausgefunden, dass die Vereinheitlichungsfunktion nur aufgerufen wird, wenn mit dem Thread parallel gearbeitet wird. </font><font style="vertical-align: inherit;">Überlegen Sie, welche Threads betroffen sind:</font></font><br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Konsolenausgabe zeigt, dass beide Funktionen: Akkumulieren und Kombinieren parallel ausgeführt werden, wobei alle möglichen Abläufe verwendet werden: </font></font><br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann argumentiert werden, dass die parallele Ausführung des Flusses zu einer signifikanten Steigerung der Effizienz beim Arbeiten mit großen Mengen eingehender Elemente beiträgt. </font><font style="vertical-align: inherit;">Es ist jedoch zu beachten, dass einige Methoden bei der parallelen Ausführung zusätzliche Berechnungen (Kombinationsoperationen) erfordern, die bei der sequentiellen Ausführung nicht erforderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus wird für die parallele Ausführung des Threads derselbe </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, der in der JVM so häufig verwendet wird. </font><font style="vertical-align: inherit;">Die Verwendung langsamer Blockierungsmethoden des Flusses kann sich daher negativ auf die Leistung des gesamten Programms auswirken, da Threads blockiert werden, die für die Verarbeitung in anderen Aufgaben verwendet werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Tutorial zur Verwendung von Threads in Java 8 ist beendet. Weitere Informationen zum Arbeiten mit Streams finden Sie in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie tiefer gehen und mehr über die Mechanismen erfahren möchten, die Threads zugrunde liegen, könnten Sie einen Artikel von Martin Fowler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collection Pipelines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich auch für JavaScript interessieren, sollten Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream.js ansehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die JavaScript-Implementierung der Java 8 Streams-API. Vielleicht möchten Sie auch meine Artikel über das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 8-Tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">russische Übersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Habré) und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 8 Nashorn-Tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, dieser Leitfaden war nützlich und interessant für Sie und Sie haben den Lesevorgang genossen. </font><font style="vertical-align: inherit;">Der vollständige Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird auf GitHub gespeichert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Fühlen Sie sich frei, einen Zweig im Repository zu erstellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437038/">https://habr.com/ru/post/de437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437026/index.html">Google in Frankreich verurteilte die DSGVO wegen Missbrauchs personenbezogener Daten zu einer Geldstrafe von 50 Millionen Euro</a></li>
<li><a href="../de437030/index.html">Automatisierung der Infrastruktur eines Luxusbüros: wie es aussieht</a></li>
<li><a href="../de437032/index.html">Installationsanleitung für NGINX ModSecurity</a></li>
<li><a href="../de437034/index.html">Universal Whistles: Snom A230 und A210 USB Dongle Review</a></li>
<li><a href="../de437036/index.html">SAPUI5 für Dummies Teil 2: Eine vollständige Schritt-für-Schritt-Übung</a></li>
<li><a href="../de437040/index.html">In Russland begann der Test der inländischen neuronalen Schnittstelle "Neurochat"</a></li>
<li><a href="../de437044/index.html">So besiegen Sie den Drachen: Schreiben Sie Ihr Programm auf Golang neu</a></li>
<li><a href="../de437050/index.html">Das Buch "Python. Expresskurs. 3rd ed.</a></li>
<li><a href="../de437052/index.html">Verpassen Sie nicht zu lernen: Braucht ein Universitäts-IT-Spezialist</a></li>
<li><a href="../de437054/index.html">Neue Intel Prozessoren der 9. Generation: Core minus GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>