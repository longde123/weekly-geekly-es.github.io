<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½ â­ï¸ ğŸ›‚ Metrik kinerja untuk meneliti aplikasi web yang sangat cepat ğŸ‘­ ğŸ¤¤ ğŸ¤©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada satu pepatah: "Apa yang tidak bisa Anda ukur, Anda tidak bisa tingkatkan." Penulis artikel, terjemahan yang kami terbitkan hari ini, berfungsi unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metrik kinerja untuk meneliti aplikasi web yang sangat cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Ada satu pepatah: "Apa yang tidak bisa Anda ukur, Anda tidak bisa tingkatkan."  Penulis artikel, terjemahan yang kami terbitkan hari ini, berfungsi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Superhuman</a> .  Dia mengatakan perusahaan ini sedang mengembangkan klien email tercepat di dunia.  Di sini kita akan berbicara tentang apa yang "cepat", dan bagaimana membuat alat untuk mengukur kinerja aplikasi web yang sangat cepat. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pengukuran Kecepatan Aplikasi</font> </h2><br>  Dalam upaya meningkatkan pengembangan kami, kami menghabiskan banyak waktu untuk mengukur kecepatannya.  Dan, ternyata, metrik kinerja adalah indikator yang secara mengejutkan sulit dipahami dan diterapkan. <br><br>  Di satu sisi, sulit untuk merancang metrik yang secara akurat menggambarkan sensasi yang dialami pengguna saat bekerja dengan sistem.  Di sisi lain, tidak mudah untuk membuat metrik yang begitu akurat sehingga analisisnya memungkinkan Anda membuat keputusan yang tepat.  Akibatnya, banyak tim pengembangan tidak dapat mempercayai data yang mereka kumpulkan pada kinerja proyek mereka. <br><br>  Sekalipun pengembang memiliki metrik yang andal dan akurat, menggunakannya tidaklah mudah.  Bagaimana cara mendefinisikan istilah "cepat"?  Bagaimana menemukan keseimbangan antara kecepatan dan konsistensi?  Bagaimana cara belajar dengan cepat mendeteksi penurunan kinerja atau belajar untuk mengevaluasi dampak optimisasi pada sistem? <br><br>  Di sini kami ingin berbagi beberapa pemikiran mengenai pengembangan alat analisis kinerja aplikasi web. <br><br><h2>  <font color="#3AC1EF">1. Menggunakan "jam" yang tepat</font> </h2><br>  JavaScript memiliki dua mekanisme untuk mengambil cap waktu: <code>performance.now()</code> dan <code>new Date()</code> . <br><br>  Bagaimana mereka berbeda?  Dua perbedaan berikut ini mendasar bagi kami: <br><br><ul><li>  Metode <code>performance.now()</code> jauh lebih akurat.  Keakuratan konstruksi <code>new Date()</code> adalah Â± 1 ms, sedangkan akurasi <code>performance.now()</code> sudah Â± 100 Î¼s (ya, ini tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikrodetik</a> !). </li><li>  Nilai-nilai yang dikembalikan oleh metode <code>performance.now()</code> selalu meningkat pada tingkat yang konstan dan tidak tergantung pada waktu sistem.  Metode ini hanya mengukur interval waktu tanpa berfokus pada waktu sistem.  Dan pada <code>new Date()</code> waktu sistem mempengaruhi.  Jika Anda mengatur ulang jam sistem, itu juga akan mengubah <code>new Date ()</code> apa yang kembali, dan ini akan merusak data pemantauan kinerja. </li></ul><br>  Meskipun "jam" yang diwakili oleh metode <code>performance.now()</code> jelas jauh lebih cocok untuk mengukur interval waktu, mereka juga tidak ideal.  Baik <code>performance.now()</code> dan <code>new Date()</code> menderita dari masalah yang sama, yang memanifestasikan dirinya dalam hal sistem berada dalam kondisi tidur: pengukuran meliputi waktu ketika mesin bahkan tidak aktif. <br><br><h2>  <font color="#3AC1EF">2. Memeriksa aktivitas aplikasi</font> </h2><br>  Jika Anda, mengukur kinerja aplikasi web, beralih dari tabnya ke yang lain - ini akan mengganggu proses pengumpulan data.  Mengapa  Faktanya adalah bahwa browser membatasi aplikasi yang terletak di tab latar belakang. <br><br>  Ada dua situasi di mana metrik dapat terdistorsi.  Akibatnya, aplikasi akan tampak jauh lebih lambat daripada yang sebenarnya. <br><br><ol><li>  Komputer beralih ke mode tidur. </li><li>  Aplikasi berjalan di tab latar belakang browser. </li></ol><br>  Terjadinya kedua situasi ini tidak jarang terjadi.  Untungnya, kami memiliki dua opsi untuk menyelesaikannya. <br><br>  Pertama, kita bisa mengabaikan metrik yang terdistorsi, membuang hasil pengukuran yang terlalu berbeda dari beberapa nilai wajar.  Misalnya, kode yang dipanggil ketika tombol ditekan tidak dapat dijalankan selama 15 menit!  Mungkin ini adalah satu-satunya hal yang Anda butuhkan untuk menangani dua masalah yang dijelaskan di atas. <br><br>  Kedua, Anda bisa menggunakan properti <code>document.hidden</code> dan acara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">visibilitychange</a> .  Acara perubahan <code>visibilitychange</code> dinaikkan ketika pengguna beralih dari tab browser yang menarik ke tab lain atau kembali ke tab yang diinginkan kepada kami.  Disebut ketika jendela browser meminimalkan atau memaksimalkan ketika komputer mulai bekerja, keluar dari mode tidur.  Dengan kata lain, inilah tepatnya yang kita butuhkan.  Selain itu, selama tab di latar belakang, properti <code>document.hidden</code> <code>true</code> . <br><br>  Berikut ini adalah contoh sederhana yang menunjukkan penggunaan properti <code>document.hidden</code> dan acara perubahan <code>visibilitychange</code> . <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Seperti yang Anda lihat, kami membuang beberapa data, tetapi ini bagus.  Faktanya adalah bahwa ini adalah data yang terkait dengan periode-periode program ketika tidak dapat sepenuhnya menggunakan sumber daya sistem. <br><br>  Sekarang kita berbicara tentang indikator yang tidak menarik bagi kita.  Tetapi ada banyak situasi, data yang dikumpulkan sangat menarik bagi kami.  Mari kita lihat bagaimana cara mengumpulkan data ini. <br><br><h2>  <font color="#3AC1EF">3. Cari indikator yang memungkinkan Anda menangkap waktu acara dimulai</font> </h2><br>  Salah satu fitur paling kontroversial dari JavaScript adalah loop acara untuk bahasa ini adalah utas tunggal.  Pada titik waktu tertentu, hanya satu bagian kode yang dapat dieksekusi, eksekusi yang tidak dapat terganggu. <br><br>  Jika pengguna menekan tombol saat mengeksekusi kode tertentu, program tidak akan mengetahuinya sampai eksekusi kode ini selesai.  Misalnya, jika aplikasi menghabiskan 1000 ms dalam siklus berkelanjutan, dan pengguna menekan tombol <code>Escape</code> 100 ms setelah dimulainya siklus, acara tidak akan direkam untuk 900 ms lainnya. <br><br>  Ini dapat sangat mendistorsi metrik.  Jika kita membutuhkan akurasi dalam mengukur dengan tepat bagaimana pengguna memandang bekerja dengan program, maka ini adalah masalah besar! <br><br>  Untungnya, menyelesaikan masalah ini tidak begitu sulit.  Jika kita berbicara tentang acara saat ini, maka kita dapat, alih-alih menggunakan <code>performance.now()</code> (waktu ketika kita melihat acara), gunakan <code>window.event.timeStamp</code> (waktu saat acara dibuat). <br><br>  Stempel waktu acara diatur oleh proses browser utama.  Karena proses ini tidak memblokir ketika loop peristiwa JS terkunci, <code>event.timeStamp</code> memberi kita informasi yang jauh lebih berharga tentang kapan acara itu benar-benar dipecat. <br><br>  Perlu dicatat bahwa mekanisme ini tidak ideal.  Jadi, di antara saat tombol fisik ditekan dan saat acara yang sesuai tiba di Chrome, 9-15 ms waktu yang tidak terhitung berlalu (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah</a> artikel yang bagus untuk Anda mengetahui mengapa ini terjadi). <br><br>  Namun, meskipun kami dapat mengukur waktu yang dibutuhkan untuk acara untuk mencapai Chrome, kami tidak boleh memasukkan waktu ini dalam metrik kami.  Mengapa  Faktanya adalah bahwa kami tidak dapat memperkenalkan optimasi tersebut ke dalam kode yang dapat secara signifikan mempengaruhi keterlambatan tersebut.  Kami tidak dapat memperbaikinya dengan cara apa pun. <br><br>  Akibatnya, jika kita berbicara tentang menemukan cap waktu untuk memulai acara, maka indikator <code>event.timeStamp</code> terlihat paling memadai di sini. <br><br>  Apa estimasi terbaik saat acara berakhir? <br><br><h2>  <font color="#3AC1EF">4. Matikan timer di requestAnimationFrame ()</font> </h2><br>  Satu konsekuensi lagi mengikuti dari fitur-fitur perangkat loop acara di JavaScript: beberapa kode yang tidak terkait dengan kode Anda dapat dieksekusi setelah itu, tetapi sebelum browser menampilkan versi halaman yang diperbarui pada layar. <br><br>  Pertimbangkan, misalnya, Bereaksi.  Setelah menjalankan kode Anda, React memperbarui DOM.  Jika Anda hanya mengukur waktu dalam kode Anda, itu berarti Anda tidak akan mengukur waktu yang diperlukan untuk menjalankan kode Bereaksi. <br><br>  Untuk mengukur waktu tambahan ini, kami menggunakan <code>requestAnimationFrame()</code> untuk mematikan timer.  Ini dilakukan hanya ketika browser siap untuk menampilkan frame berikutnya. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Berikut ini adalah siklus hidup frame (diagram diambil dari materi yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> berdasarkan <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Bingkai siklus hidup</font></i> <br><br>  Seperti yang Anda lihat pada gambar ini, <code>requestAnimationFrame()</code> dipanggil setelah prosesor selesai, tepat sebelum bingkai ditampilkan.  Jika kita mematikan timer di sini, itu berarti kita dapat benar-benar yakin bahwa semua yang membutuhkan waktu untuk menyegarkan layar termasuk dalam data yang dikumpulkan pada interval waktu. <br><br>  Sejauh ini bagus, tapi sekarang situasinya menjadi agak rumit ... <br><br><h2>  <font color="#3AC1EF">5. Mengabaikan waktu yang diperlukan untuk membuat tata letak halaman dan visualisasinya.</font> </h2><br>  Diagram sebelumnya, menunjukkan siklus hidup suatu bingkai, menggambarkan masalah lain yang kami temui.  Di akhir siklus hidup frame, ada blok Layout (membentuk tata letak halaman) dan Paint (menampilkan halaman).  Jika Anda tidak memperhitungkan waktu yang diperlukan untuk menyelesaikan operasi ini, maka waktu yang diukur oleh kami akan kurang dari waktu yang diperlukan untuk beberapa data yang diperbarui muncul di layar. <br><br>  Untungnya, <code>requestAnimationFrame</code> memiliki kartu as lainnya.  Ketika fungsi yang dilewati oleh <code>requestAnimationFrame</code> dipanggil, fungsi ini melewati timestamp yang menunjukkan waktu mulai dari pembentukan frame saat ini (yaitu, yang terletak di bagian paling kiri dari diagram kita).  Stempel waktu ini biasanya sangat dekat dengan waktu akhir bingkai sebelumnya. <br><br>  Akibatnya, kelemahan di atas dapat diperbaiki dengan mengukur total waktu yang telah berlalu sejak saat <code>event.timeStamp</code> ke waktu ketika pembentukan frame berikutnya dimulai.  Perhatikan permintaan bersarangAnimationFrame: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Meskipun apa yang ditunjukkan di atas terlihat seperti solusi yang sangat baik untuk masalah ini, pada akhirnya, kami memutuskan untuk tidak menggunakan desain ini.  Faktanya adalah bahwa, meskipun teknik ini memungkinkan untuk memperoleh data yang lebih andal, keakuratan data tersebut berkurang.  Frame di Chrome dibentuk dengan frekuensi 16 ms.  Ini berarti bahwa akurasi tertinggi yang tersedia bagi kami adalah Â± 16 ms.  Dan jika browser kelebihan beban dan melompati bingkai, maka akurasinya akan lebih rendah, dan kemunduran ini tidak dapat diprediksi. <br><br>  Jika Anda menerapkan solusi ini, maka peningkatan serius dalam kinerja kode Anda, seperti mempercepat tugas yang sebelumnya dilakukan 32 ms, hingga 15 ms, mungkin tidak mempengaruhi hasil pengukuran kinerja. <br><br>  Tidak memperhitungkan waktu yang diperlukan untuk membuat tata letak halaman dan hasilnya, kami mendapatkan metrik yang jauh lebih akurat (Â± 100 Î¼s) untuk kode yang berada di bawah kendali kami.  Sebagai hasilnya, kita bisa mendapatkan ekspresi numerik dari setiap perbaikan yang dilakukan pada kode ini. <br><br>  Kami juga mengeksplorasi ide serupa: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Ini akan termasuk waktu render, tetapi keakuratan indikator tidak akan dibatasi hingga Â± 16 ms.  Namun, kami memutuskan untuk tidak menggunakan pendekatan ini juga.  Jika sistem menemukan event input yang panjang, maka panggilan ke <code>setTimeout</code> ditransmisikan dapat secara signifikan ditunda dan dieksekusi setelah antarmuka pengguna diperbarui. <br><br><h2>  <font color="#3AC1EF">6. Klarifikasi "persentase acara yang di bawah target"</font> </h2><br>  Kami sedang mengembangkan proyek dan berfokus pada kinerja tinggi, mencoba mengoptimalkannya dengan dua cara: <br><br><ol><li>  Kecepatan.  Waktu pelaksanaan tugas tercepat harus sedekat mungkin dengan 0 ms. </li><li>  Keseragaman.  Waktu pelaksanaan tugas yang paling lambat harus sedekat mungkin dengan waktu pelaksanaan tugas tercepat. </li></ol><br>  Karena fakta bahwa indikator-indikator ini berubah dari waktu ke waktu, mereka sulit untuk divisualisasikan dan tidak mudah untuk didiskusikan.  Apakah mungkin untuk membuat sistem visualisasi indikator yang akan menginspirasi kita untuk mengoptimalkan kecepatan dan keseragaman? <br><br>  Pendekatan tipikal adalah mengukur persentil ke-90 dari keterlambatan.  Pendekatan ini memungkinkan Anda untuk menggambar grafik garis di sepanjang sumbu Y yang waktu dalam milidetik disimpan.  Grafik ini memungkinkan Anda untuk melihat bahwa 90% dari peristiwa di bawah grafik garis, yaitu, mereka mengeksekusi lebih cepat daripada waktu yang ditunjukkan grafik garis. <br><br>  Diketahui bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">100 ms</a> adalah batas antara apa yang dianggap sebagai "cepat" dan "lambat". <br><br>  Tapi apa yang akan kita temukan tentang bagaimana perasaan pengguna dari pekerjaan jika kita tahu bahwa persentil ke-90 keterlambatan adalah 103 ms?  Tidak terlalu banyak.  Indikator apa yang akan memberi pengguna kegunaan?  Tidak ada cara untuk mengetahui hal ini dengan pasti. <br><br>  Tetapi bagaimana jika kita tahu bahwa persentil ke-90 dari penundaan adalah 93 ms?  Ada perasaan bahwa 93 lebih baik daripada 103, tetapi kami tidak bisa mengatakan apa-apa lagi tentang indikator-indikator ini, serta apa artinya dalam hal persepsi pengguna terhadap proyek.  Sekali lagi, tidak ada jawaban pasti untuk pertanyaan ini. <br><br>  Kami telah menemukan solusi untuk masalah ini.  Ini terdiri dalam mengukur persentase peristiwa yang waktu eksekusi tidak melebihi 100 ms.  Ada tiga keuntungan besar untuk pendekatan ini: <br><br><ul><li>  Metrik ini berorientasi pada pengguna.  Dia dapat memberi tahu kami berapa persen waktu aplikasi kami cepat, dan berapa persen pengguna menganggapnya cepat. </li><li>  Metrik ini memungkinkan kami mengembalikan pengukuran ke akurasi yang hilang karena fakta bahwa kami tidak mengukur waktu yang diperlukan untuk menyelesaikan tugas di bagian paling akhir frame (kami membicarakannya di bagian No. 5).  Karena kami menetapkan indikator target yang sesuai dengan beberapa bingkai, hasil pengukuran yang dekat dengan indikator ini ternyata lebih kecil atau lebih banyak. </li><li>  Metrik ini lebih mudah untuk dihitung.  Cukup menghitung jumlah peristiwa yang waktu pelaksanaannya di bawah indikator target, dan setelah itu - bagi dengan jumlah total peristiwa.  Persentil jauh lebih sulit untuk dihitung.  Ada perkiraan yang efektif, tetapi untuk melakukan semuanya dengan benar, Anda harus memperhitungkan setiap dimensi. </li></ul><br>  Pendekatan ini hanya memiliki satu minus: jika indikator lebih buruk daripada target, maka tidak akan mudah untuk melihat peningkatannya. <br><br><h2>  <font color="#3AC1EF">7. Penggunaan beberapa nilai ambang batas dalam analisis indikator</font> </h2><br>  Untuk memvisualisasikan hasil optimasi kinerja, kami memperkenalkan beberapa nilai ambang tambahan ke sistem kami - di atas 100 ms dan di bawah. <br><br>  Kami mengelompokkan penundaan seperti ini: <br><br><ul><li>  Kurang dari 50 ms (cepat). </li><li>  50 hingga 100 ms (bagus). </li><li>  100 hingga 1000 ms (lambat). </li><li>  Lebih dari 1000 ms (sangat lambat). </li></ul><br>  Hasil "Sangat lambat" memungkinkan kita untuk melihat bahwa kita telah sangat merindukan suatu tempat.  Karena itu, kami menyorotinya dengan warna merah cerah. <br><br>  Apa yang cocok dalam 50 ms sangat sensitif terhadap perubahan.  Di sini, peningkatan kinerja sering terlihat jauh sebelum terlihat dalam grup yang sesuai dengan 100 ms. <br><br>  Sebagai contoh, grafik berikut memvisualisasikan kinerja melihat thread di Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Lihat utas</font></i> <br><br>  Ini menunjukkan periode penurunan kinerja, dan kemudian - hasil perbaikan.  Sulit untuk menilai penurunan kinerja jika Anda hanya melihat indikator yang sesuai dengan 100 ms (bagian atas kolom biru).  Ketika melihat hasil yang sesuai dengan 50 ms (bagian atas kolom hijau), masalah kinerja sudah terlihat jauh lebih jelas. <br><br>  Jika kami menggunakan pendekatan tradisional untuk mempelajari metrik kinerja, kami mungkin tidak akan melihat masalah yang pengaruhnya terhadap sistem ditunjukkan pada gambar sebelumnya.  Namun berkat cara kami melakukan pengukuran dan cara memvisualisasikan metrik kami, kami dapat dengan cepat menemukan dan memecahkan masalah. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Ternyata sulit untuk menemukan pendekatan yang tepat untuk bekerja dengan metrik kinerja.  Kami berhasil mengembangkan metodologi yang memungkinkan kami membuat alat berkualitas tinggi untuk mengukur kinerja aplikasi web.  Yaitu, kita berbicara tentang hal berikut: <br><br><ol><li>  Waktu mulai dari suatu peristiwa diukur menggunakan <code>event.timeStamp</code> . </li><li>  Waktu akhir acara diukur menggunakan <code>performance.now()</code> di dalam callback yang diteruskan ke <code>requestAnimationFrame()</code> . </li><li>  Segala sesuatu yang terjadi dengan aplikasi saat berada di tab browser yang tidak aktif diabaikan. </li><li>  Data dikumpulkan menggunakan indikator, yang dapat digambarkan sebagai "persentase kejadian yang di bawah target". </li><li>  Data divisualisasikan dengan beberapa tingkatan nilai ambang batas. </li></ol><br>  Teknik ini memberi Anda alat untuk membuat metrik yang andal dan akurat.  Anda dapat membuat grafik yang dengan jelas menunjukkan penurunan kinerja, Anda dapat memvisualisasikan hasil optimasi.  Dan yang paling penting - Anda memiliki kesempatan untuk membuat proyek cepat lebih cepat. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda menganalisis kinerja aplikasi web Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470872/">https://habr.com/ru/post/id470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470856/index.html">Telegram GRAM Wallet: ketentuan layanan</a></li>
<li><a href="../id470858/index.html">Antiquities: Benchmark dari prosesor 386 dan sembilan puluhan gagah</a></li>
<li><a href="../id470864/index.html">Tentang kelezatan beralih ke panel dan tidak hanya</a></li>
<li><a href="../id470868/index.html">Waktu untuk byte pertama: apa itu dan mengapa itu penting</a></li>
<li><a href="../id470870/index.html">Prapemuat Font</a></li>
<li><a href="../id470874/index.html">Mengoptimalkan pemuatan JavaScript di Wikipedia</a></li>
<li><a href="../id470876/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 1</a></li>
<li><a href="../id470878/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 2</a></li>
<li><a href="../id470880/index.html">Mekanik game. Petualangan, konsep terapi bicara nol dan menarik</a></li>
<li><a href="../id470882/index.html">Mengapa Anda menangkap mouse saya, atau permainan papan sebagai model interaksi sosial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>