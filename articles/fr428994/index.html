<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßï ü•ü üïå Mise en r√©seau sous Android avec Corutin et Retrofit üî© üè¨ üë®üèø‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Plus je lisais et regardais les rapports sur les coroutines √† Kotlin, plus j'admirais cet outil de langage. Leur version stable a √©t√© r√©cemment publi√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise en r√©seau sous Android avec Corutin et Retrofit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428994/"><p>  Plus je lisais et regardais les rapports sur les coroutines √† Kotlin, plus j'admirais cet outil de langage.  Leur version stable a √©t√© r√©cemment publi√©e dans Kotlin 1.3, ce qui signifie qu'il est temps de commencer la plong√©e et d'essayer les coroutines en action en utilisant mon code RxJava existant comme exemple.  Dans cet article, nous nous concentrerons sur la fa√ßon de prendre les requ√™tes r√©seau existantes et de les convertir en rempla√ßant RxJava par des coroutines. </p><br><p><img src="https://habrastorage.org/webt/h-/7v/mt/h-7vmtalbemnlfsu3g8hto3x2la.png"></p><a name="habracut"></a><br><p>  Franchement, avant d'essayer les coroutines, je pensais qu'elles √©taient tr√®s diff√©rentes de ce qu'elles √©taient.  Cependant, le principe de base de la corutine inclut les m√™mes concepts que ceux auxquels nous sommes habitu√©s dans les √©coulements r√©actifs RxJava.  √Ä titre d'exemple, prenons une configuration RxJava simple pour cr√©er une demande r√©seau √† partir de l'une de mes applications: </p><br><ul><li> D√©finissez l'interface r√©seau pour la mise √† niveau √† l'aide de l'adaptateur Rx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">retrofit2: adapter-rxjava2</a> ).  Les fonctions renverront des objets √† partir d'un framework Rx, tel que <strong>Single</strong> ou <strong>Observable</strong> .  (Les fonctions sont utilis√©es ici et non les m√©thodes, car on suppose que l'ancien code a √©galement √©t√© √©crit en Kotlin. Eh bien, ou converti √† partir de Java via Android Studio). </li><li>  Nous appelons une certaine fonction d'une autre classe (par exemple, un r√©f√©rentiel ou une activit√©). </li><li>  Nous d√©terminons pour les threads sur quel Scheduler ils seront ex√©cut√©s et retournons le r√©sultat (m√©thodes <strong>.subscribeOn ()</strong> et <strong>.observeOn ()</strong> ). </li><li>  Nous enregistrons le lien vers l'objet pour la d√©sinscription (par exemple, dans CompositeObservable). </li><li>  Abonnez-vous au flux d'√©v√©nements. </li><li>  Se d√©sinscrire du flux en fonction des √©v√©nements du cycle de vie de l'activit√©. </li></ul><br><p>  Il s'agit de l'algorithme de base pour travailler avec Rx (sans tenir compte des fonctions de mappage et des d√©tails des autres manipulations de donn√©es).  Quant √† la corutine, le principe ne change pas grand-chose.  Le m√™me concept, seule la terminologie change. </p><br><ul><li>  Nous d√©finissons l'interface r√©seau pour le Retrofit en utilisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adaptateur pour coroutine</a> .  Les fonctions renverront des objets <strong>diff√©r√©s</strong> de l'API Corutin. </li><li>  Nous appelons ces fonctions √† partir d'une autre classe (par exemple, un r√©f√©rentiel ou une activit√©).  La seule diff√©rence: chaque fonction doit √™tre marqu√©e comme <strong>suspendue</strong> . </li><li>  D√©finissez le r√©partiteur qui sera utilis√© pour la coroutine. </li><li>  Nous enregistrons le lien vers l'objet <strong>Job</strong> pour la d√©sinscription. </li><li>  Ex√©cutez coroutine de toutes les mani√®res possibles. </li><li>  Nous annulons les coroutines en fonction des √©v√©nements du cycle de vie de l'activit√©. </li></ul><br><p>  Comme vous pouvez le voir sur les s√©quences ci-dessus, le processus d'ex√©cution de Rx et Corutin est tr√®s similaire.  Si nous ne prenons pas en compte les d√©tails de l'impl√©mentation, cela signifie que nous pouvons maintenir l'approche que nous avons - nous rempla√ßons seulement certaines choses pour rendre notre impl√©mentation coroutine-friendly. </p><br><p><img src="https://habrastorage.org/webt/rx/wm/xt/rxwmxtqqqcz0_wsvmjl8tjmel7m.png"></p><br><p>  La premi√®re √©tape que nous devons prendre est de permettre √† Retrofit de renvoyer des objets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diff√©r√©s</a> .  Les objets diff√©r√©s sont des futures non bloquants qui peuvent √™tre annul√©s si n√©cessaire.  Ces objets sont essentiellement un travail coroutine, qui contient la valeur du travail correspondant.  L'utilisation du type diff√©r√© nous permet de m√©langer la m√™me id√©e que Job, avec en plus la possibilit√© d'obtenir des √©tats suppl√©mentaires, tels que le succ√®s ou l'√©chec - ce qui le rend id√©al pour les demandes r√©seau. </p><br><p>  Si vous utilisez Retrofit avec RxJava, vous utilisez probablement RxJava Call Adapter Factory.  Heureusement, Jake Worton a √©crit son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©quivalent pour coroutine</a> . </p><br><p>  Nous pouvons utiliser cet adaptateur d'appel dans le g√©n√©rateur Retrofit, puis impl√©menter notre interface Retrofit de la m√™me mani√®re qu'avec RxJava: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(okHttpClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OkHttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: MyService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retrofit = Retrofit.Builder() .baseUrl(<span class="hljs-string"><span class="hljs-string">"some_api"</span></span>) .client(okHttpClient) .addCallAdapterFactory(CoroutineCallAdapterFactory()) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrofit.create(MyService::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Regardons maintenant l'interface MyService, qui est utilis√©e ci-dessus.  Nous devons remplacer les types observables retourn√©s par Deferred dans l'interface Retrofit.  Si c'√©tait comme √ßa: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Maintenant, nous le rempla√ßons par: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Deferred&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Chaque fois que nous appelons getData (), l'objet Deferred nous revient - un analogue de Job pour les requ√™tes r√©seau.  Auparavant, nous appelions en quelque sorte cette fonction avec RxJava: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myService.getData() .map { result -&gt; result.map { myDataMapper.mapFromRemote(it) } } }</code> </pre> <br><p>  Dans ce flux RxJava, nous appelons notre fonction utilitaire, puis appliquons l'op√©ration de mappage de l'API RxJava avec le mappage ult√©rieur des donn√©es renvoy√©es par la demande √† quelque chose utilis√© dans la couche d'interface utilisateur.  Cela changera un peu lorsque nous utiliserons une impl√©mentation avec des coroutines.  Pour commencer, notre fonction doit √™tre <strong>suspendue</strong> (diff√©r√©e), afin de faire une op√©ration paresseuse √† l'int√©rieur du corps de la fonction.  Et pour cela, la fonction appelante doit √©galement √™tre diff√©r√©e.  Une fonction diff√©r√©e n'est pas bloquante et peut √™tre contr√¥l√©e apr√®s son appel initial.  Vous pouvez le d√©marrer, le mettre en pause, le reprendre ou l'annuler. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { ... }</code> </pre> <br><p>  Maintenant, nous devons appeler notre fonction d'utilit√©.  √Ä premi√®re vue, nous faisons la m√™me chose, mais nous devons nous rappeler que nous obtenons maintenant <strong>diff√©r√©</strong> au lieu d' <strong>Observable</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData() ... }</code> </pre> <br><p>  En raison de ce changement, nous ne pouvons plus utiliser la cha√Æne d'op√©rations de carte de l'API RxJava.  Et m√™me √† ce stade, les donn√©es ne sont pas disponibles pour nous - nous avons seulement une instance diff√©r√©e.  Maintenant, nous devons utiliser la fonction wait <strong>()</strong> afin d'attendre le r√©sultat de la requ√™te et ensuite continuer √† ex√©cuter le code √† l'int√©rieur de la fonction: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() ... }</code> </pre> <br><p>  √Ä ce stade, nous obtenons la demande compl√©t√©e et les donn√©es de celle-ci disponibles pour utilisation.  Par cons√©quent, nous pouvons maintenant effectuer des op√©rations de mappage: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.map { myDataMapper.mapFromRemote(it) } }</code> </pre> <br><p>  Nous avons pris notre interface Retrofit avec la classe appelante et utilis√© des coroutines.  Maintenant, nous voulons appeler ce code √† partir de notre activit√© ou de fragments et utiliser les donn√©es que nous avons obtenues du r√©seau. </p><br><p>  Dans notre activit√©, nous allons commencer par cr√©er un lien vers Job, dans lequel nous pouvons affecter notre op√©ration coroutine, puis l'utiliser pour contr√¥ler, par exemple, l'annulation d'une demande, lors d'un appel <strong>onDestroy ()</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myJob: Job? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { myJob?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() }</code> </pre> <br><p>  Maintenant, nous pouvons affecter quelque chose √† la variable myJob.  Regardons notre demande avec coroutines: </p><br><pre> <code class="hljs pgsql">myJob = CoroutineScope(Dispatchers.IO).launch { val result = repo.getLeagues() withContext(Dispatchers.Main) { //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> result } }</code> </pre> <br><p>  Dans cet article, je ne voudrais pas me plonger dans les r√©partiteurs ou effectuer des op√©rations dans les coroutines, car c'est un sujet pour d'autres articles.  En bref, ce qui se passe ici: </p><br><ul><li>  Cr√©ez une instance de CoroutineScope en utilisant IO Dispatcher comme param√®tre.  Ce r√©partiteur est utilis√© pour effectuer des op√©rations d'E / S de blocage, telles que des requ√™tes r√©seau. </li><li>  Nous lan√ßons notre coroutine avec la fonction de <strong>lancement</strong> - cette fonction lance une nouvelle coroutine et renvoie un lien vers une variable de type Job. </li><li>  Ensuite, nous utilisons le lien vers notre r√©f√©rentiel pour recevoir des donn√©es en effectuant une demande r√©seau. </li><li>  Au final, nous utilisons le r√©partiteur principal pour effectuer le travail sur le thread d'interface utilisateur.  Ici, nous pouvons montrer les donn√©es re√ßues aux utilisateurs. </li></ul><br><p>  Dans le prochain article, l'auteur promet de creuser un peu plus dans les d√©tails, mais le mat√©riel actuel devrait √™tre suffisant pour commencer √† √©tudier les coroutines. </p><br><p>  Dans cet article, nous avons remplac√© l'impl√©mentation RxJava des r√©ponses Retrofit par des objets <strong>Deferred</strong> de l'API Corutin.  Nous appelons ces fonctions pour recevoir des donn√©es du r√©seau, puis les afficher dans notre activit√©.  J'esp√®re que vous avez vu le peu de changements que vous devez effectuer pour commencer avec les coroutines et que vous avez appr√©ci√© la simplicit√© de l'API, en particulier lors de la lecture et de l'√©criture de code. </p><br><p>  Dans les commentaires sur le post original, j'ai trouv√© une requ√™te traditionnelle: afficher tout le code.  Par cons√©quent, j'ai fait une application simple qui, au d√©marrage, re√ßoit un horaire de trains avec l'API Yandex.Horaires et l'affiche dans RecyclerView.  Lien: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/AndreySBer/RetrofitCoroutinesExample</a> </p><br><p>  Je voudrais √©galement ajouter que les coroutines semblent √™tre un remplacement inf√©rieur pour RxJava, car elles n'offrent pas un ensemble √©quivalent d'op√©rations pour la synchronisation des threads.  √Ä cet √©gard, il vaut la peine d'examiner la mise en ≈ìuvre de ReactiveX pour Kotlin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxKotlin</a> . </p><br><p>  Si vous utilisez Android Jetpack, j'ai √©galement trouv√© un exemple avec Retrofit, coroutines, LiveData et MVVM: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codinginfinite.com/kotlin-coroutine-call-adapter-retrofit/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428994/">https://habr.com/ru/post/fr428994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428984/index.html">Julia et portraits de phases de syst√®mes dynamiques</a></li>
<li><a href="../fr428986/index.html">Conf√©rence ThinkJava n ¬∞ 8 √† Kharkov</a></li>
<li><a href="../fr428988/index.html">Conseils nature - Veilleuse nuageuse</a></li>
<li><a href="../fr428990/index.html">Exemples de configuration d'UIViewControllers utilisant RouteComposer</a></li>
<li><a href="../fr428992/index.html">Contournement s√©lectif des verrous sur les routeurs avec le firmware Padavan et Keenetic OS</a></li>
<li><a href="../fr428996/index.html">Club de Santa Clauses anonymes 2018-2019 sur Habrahabr</a></li>
<li><a href="../fr428998/index.html">Comment utiliser la nouvelle fonctionnalit√© Profiler exp√©rimentale dans React</a></li>
<li><a href="../fr429000/index.html">Pourquoi Bill Gates a invent√© les toilettes pour 233 milliards de dollars</a></li>
<li><a href="../fr429006/index.html">Chine: ¬´l'atelier de montage mondial¬ª n'est pas aussi simple qu'il y para√Æt</a></li>
<li><a href="../fr429008/index.html">Alpha Zero, les √©checs et l'apprentissage de l'anglais: le pr√©sent et l'avenir de l'intelligence artificielle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>