<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ü§≥ üïâÔ∏è MVCC-7. Limpieza autom√°tica üôåüèæ üåè üë≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perm√≠tame recordarle que comenzamos con problemas relacionados con el aislamiento , hicimos una digresi√≥n sobre la organizaci√≥n de datos en un nivel b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Limpieza autom√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Perm√≠tame recordarle que comenzamos con problemas relacionados con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislamiento</a> , hicimos una digresi√≥n sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">organizaci√≥n de datos en un nivel bajo</a> , hablamos en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre las versiones de fila</a> y c√≥mo se obtienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas</a> de las versiones. <br><br>  Luego analizamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">limpieza en la p√°gina</a> (y las actualizaciones HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la limpieza regular</a> , pero hoy nos fijamos en la limpieza autom√°tica. <br><br><h1>  Auto limpieza (autovacuum) </h1><br>  Ya hemos dicho que la limpieza ordinaria en condiciones normales (cuando nadie mantiene el horizonte de transacciones durante mucho tiempo) debe hacer frente a su trabajo.  La pregunta es con qu√© frecuencia llamarlo. <br><br>  Si limpia una mesa para cambiar pa√±ales muy raramente, crecer√° m√°s de lo que quisiera.  Adem√°s, para la pr√≥xima limpieza, puede tomar varios pasos a trav√©s de los √≠ndices si se han acumulado demasiados cambios. <br><br>  Si borra la tabla con demasiada frecuencia, en lugar de un trabajo √∫til, el servidor se dedicar√° constantemente al mantenimiento, lo que tampoco es bueno. <br><br>  Tenga en cuenta que comenzar una limpieza regular programada no resuelve el problema, porque la carga puede cambiar con el tiempo.  Si la tabla comenz√≥ a actualizarse m√°s activamente, deber√≠a limpiarse con m√°s frecuencia. <br><br>  La limpieza autom√°tica es solo el mecanismo que le permite comenzar a limpiar, dependiendo de la actividad de los cambios en las tablas. <br><a name="habracut"></a><br>  Cuando <em>la limpieza autom√°tica est√°</em> habilitada (par√°metro de configuraci√≥n de vac√≠o autom√°tico), el proceso del iniciador de vac√≠o autom√°tico siempre est√° presente en el sistema, que planea funcionar, y los flujos de trabajo de los trabajadores de vac√≠o autom√°tico est√°n involucrados en la limpieza real, varias de las cuales pueden funcionar en paralelo. <br><br>  El proceso del iniciador de autovacuum compila una lista de bases de datos en las que hay alguna actividad.  La actividad est√° determinada por las estad√≠sticas, y para que se recopile, se debe establecer el par√°metro <em>track_counts</em> .  Nunca apague <em>autovacuum</em> y <em>track_counts</em> , de lo contrario, la <em>limpieza</em> <em>autom√°tica</em> no funcionar√°. <br><br>  Una vez en <em>autovacuum_naptime,</em> se inicia el proceso del iniciador de autovacuum (utilizando el proceso postmaster) un flujo de trabajo para cada base de datos en la lista.  En otras palabras, si hay alguna actividad en la base de datos, los flujos de trabajo entrar√°n en ella con un intervalo <em>autovacuum_naptime</em> .  Para hacer esto, si hay varias bases de datos activas (N piezas), los procesos de trabajo se <em>inician</em> N veces m√°s a menudo que <em>autovacuum_naptime</em> .  Pero al mismo tiempo, el n√∫mero total de flujos de trabajo que trabajan simult√°neamente est√° limitado por el par√°metro <em>autovacuum_max_workers</em> . <br><br>  Una vez iniciado, el flujo de trabajo se conecta a la base de datos especificada por √©l y comienza construyendo la lista: <br><br><ul><li>  todas las tablas, vistas materializadas y tablas tostadas que deben borrarse, </li><li>  todas las tablas y representaciones materializadas que requieren an√°lisis (no se analizan las tablas tostadas, porque siempre se accede a ellas por √≠ndice). </li></ul><br>  Adem√°s, el flujo de trabajo a su vez limpia y / o analiza los objetos seleccionados y finaliza cuando se completa la limpieza. <br><br>  Si el proceso no ha completado todo el trabajo previsto para <em>autovacuum_naptime</em> , el proceso del iniciador de autovacuum enviar√° otro flujo de trabajo a la misma base de datos y trabajar√°n juntos.  "Juntos" simplemente significa que el segundo proceso construir√° su lista de tablas y la seguir√°.  Por lo tanto, se procesar√°n diferentes tablas en paralelo, pero a nivel de una tabla no hay paralelismo: si uno de los procesos de trabajo ya est√° trabajando en la tabla, el otro lo omitir√° y continuar√°. <br><br><blockquote>  Se ha debatido la necesidad de un procesamiento paralelo durante mucho tiempo, pero el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> a√∫n no se ha adoptado. <br></blockquote><br>  Ahora echemos un vistazo m√°s de cerca a lo que "requiere limpieza" y "requiere an√°lisis". <br><br><h1>  ¬øQu√© mesas necesitan limpieza? </h1><br>  Se cree que la limpieza es necesaria si el n√∫mero de versiones "muertas", es decir, irrelevantes, de cadenas supera un valor umbral establecido.  El recopilador de estad√≠sticas recopila constantemente el n√∫mero de versiones muertas y se almacena en la tabla pg_stat_all_tables.  Y el umbral se establece mediante dos par√°metros: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> define el valor absoluto (en piezas), </li><li>  <em>autovacuum_vacuum_scale_factor</em> determina la proporci√≥n de filas en una tabla. </li></ul><br>  La f√≥rmula final es: la limpieza es necesaria si pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * pg_class.reltupes. <br><br>  La configuraci√≥n predeterminada establece <em>autovacuum_vacuum_threshold</em> = 50 y <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  El par√°metro principal aqu√≠, por supuesto, es <em>autovacuum_vacuum_scale_factor</em> : es lo que es importante para las tablas grandes (es decir, los posibles problemas est√°n asociados con ellas).  El valor del 20% parece estar muy sobreestimado, lo m√°s probable es que deba reducirse significativamente. <br><br>  Los valores √≥ptimos de los par√°metros pueden variar para diferentes tablas seg√∫n su tama√±o y la naturaleza de los cambios.  Tiene sentido establecer, en general, valores adecuados y, si es necesario, configurar especialmente los par√°metros a nivel de algunas tablas utilizando los par√°metros de almacenamiento: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> y <em>toast.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> y <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Para no confundirse, esto debe hacerse solo para un peque√±o n√∫mero de tablas que se destacan entre otras por el volumen o la intensidad de los cambios, y solo si los valores establecidos globalmente no son adecuados. <br><br>  Adem√°s, la limpieza autom√°tica se puede desactivar en el nivel de la mesa (aunque es dif√≠cil pensar en una raz√≥n por la cual esto ser√≠a necesario): <br><br><ul><li>  <em>autovacuum_enabled</em> y <em>toast.autovacuum_enabled</em> . </li></ul><br>  Por ejemplo, la √∫ltima vez que creamos una mesa de vac√≠o con la limpieza autom√°tica desactivada, para, con fines de demostraci√≥n, gestionar la limpieza manual.  El par√°metro de almacenamiento se puede cambiar de la siguiente manera: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Para formalizar todo lo anterior, crearemos una vista que muestre qu√© tablas necesitan limpiarse actualmente.  Utilizar√° una funci√≥n que devuelve el valor actual del par√°metro, dado que puede anularse a nivel de tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Y aqu√≠ est√° la vista: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  ¬øQu√© tablas necesitan an√°lisis? </h1><br>  Con el autoan√°lisis, la situaci√≥n es aproximadamente la misma.  Se cree que el an√°lisis es necesario para aquellas tablas para las cuales el n√∫mero de versiones cambiadas (desde el √∫ltimo an√°lisis) de las filas excede el valor umbral especificado por dos par√°metros similares: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * pg_class.reltu. <br><br>  La configuraci√≥n predeterminada de an√°lisis autom√°tico es ligeramente diferente: <em>autovacuum_analyze_threshold</em> = 50 y <em>autovacuum_analyze_scale_factor</em> = 0.1.  Tambi√©n se pueden definir a nivel de par√°metros de almacenamiento para tablas individuales: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Como las tablas de tostadas no se analizan, no hay par√°metros correspondientes para ellas. <br><br>  Creemos una vista para el an√°lisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Ejemplo </h1><br>  Para los experimentos, establecemos los siguientes valores de par√°metros: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Ahora cree una tabla similar a la que usamos la √∫ltima vez e inserte mil filas en ella.  La limpieza autom√°tica est√° deshabilitada en el nivel de la mesa, y la activaremos nosotros mismos.  Si esto no se hace, los ejemplos no ser√°n reproducibles, ya que la limpieza autom√°tica puede funcionar en el momento equivocado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Esto es lo que mostrar√° nuestra vista de limpieza: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Hay dos puntos a los que debe prestar atenci√≥n.  En primer lugar, max_dead_tup = 0, aunque el 3% de 1000 l√≠neas son 30 l√≠neas.  El hecho es que todav√≠a no tenemos estad√≠sticas sobre la mesa, ya que INSERT no la actualiza.  Hasta que se analice nuestra tabla, los ceros permanecer√°n, ya que pg_class.reltuples = 0. Sin embargo, echemos un vistazo a la segunda vista para el an√°lisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Como la tabla ha cambiado (agregado) 1000 filas, y esto es m√°s que cero, el an√°lisis autom√°tico deber√≠a funcionar.  Mira esto: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Despu√©s de una breve pausa, vemos que la tabla se analiza y en lugar de ceros en max_mod_tup vemos las 20 l√≠neas correctas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Volvamos a la limpieza autom√°tica: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Max_dead_tup, como vemos, ya se ha solucionado.  El segundo punto al que debe prestar atenci√≥n es dead_tup = 0. Las estad√≠sticas muestran que no hay versiones muertas de filas en la tabla ... y esto es cierto.  Todav√≠a no hay nada que limpiar en nuestra mesa.  Por lo tanto, cualquier tabla que se use solo en el modo de solo agregar no se borrar√° y, por lo tanto, el mapa de visibilidad no se actualizar√°.  Y esto hace que sea imposible utilizar exclusivamente el escaneo de √≠ndice (escaneo de solo √≠ndice). <br><br>  (La pr√≥xima vez veremos que la limpieza tarde o temprano llegar√° a la tabla de solo agregar, pero esto suceder√° muy raramente). <br><br>  Conclusi√≥n pr√°ctica: si es importante utilizar solo el escaneo de √≠ndice, es posible que deba solicitar la limpieza manual. <br><br>  Ahora apague la limpieza autom√°tica nuevamente y actualice la l√≠nea 31, una m√°s que el valor umbral. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Ahora se cumple la condici√≥n para activar la limpieza autom√°tica.  Active la limpieza autom√°tica y despu√©s de una breve pausa veremos que la tabla ha sido procesada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Regulaci√≥n de la carga </h1><br>  La limpieza no bloquea otros procesos, ya que funciona p√°gina por p√°gina, pero crea una carga en el sistema y puede tener un efecto notable en el rendimiento. <br><br><h2>  Regulaci√≥n para limpieza regular </h2><br>  Para poder controlar la intensidad de la limpieza y, en consecuencia, su efecto en el sistema, el proceso alterna entre el trabajo y las expectativas.  La limpieza realiza aproximadamente <em>vac√≠o_cost_limit</em> unidades de trabajo convencionales, y luego se queda dormido en <em>vacuum_cost_delay</em> ms. <br><br>  La configuraci√≥n predeterminada establece <em>vacuum_cost_limit</em> = 200, <em>vacuum_cost_delay</em> = 0. El √∫ltimo cero en realidad significa que la limpieza (normal) no se duerme, por lo que el valor espec√≠fico de <em>vacuum_cost_limit</em> no juega ning√∫n papel.  Esto se hace porque si el administrador tuvo que iniciar VACUUM manualmente, probablemente quiera realizar la limpieza lo m√°s r√°pido posible. <br><br>  Sin embargo, si todav√≠a configura el tiempo de suspensi√≥n, la cantidad de trabajo especificada en <em>vacuum_cost_limit</em> consistir√° en el costo de trabajar con p√°ginas en la memoria cach√© del b√∫fer.  Cada acceso a la p√°gina se eval√∫a de la siguiente manera: <br><br><ul><li>  si la p√°gina se encontr√≥ en la memoria cach√© del b√∫fer, entonces <em>vacuum_cost_page_hit</em> = 1; </li><li>  si no se encuentra, entonces <em>vacuum_cost_page_miss</em> = 10; </li><li>  si no pudo encontrarlo y tuvo que sacar la p√°gina sucia del b√∫fer, entonces <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Es decir, con la configuraci√≥n del <em>vac√≠o_cost_limit</em> por defecto, 200 p√°ginas del cach√©, o 20 p√°ginas del disco, o 10 p√°ginas con extrusi√≥n se pueden procesar de una vez.  Est√° claro que se trata de n√∫meros bastante arbitrarios, pero no tiene sentido seleccionarlos con mayor precisi√≥n. <br><br><h2>  Regulaci√≥n para auto limpieza </h2><br>  El control de carga durante la limpieza autom√°tica funciona igual que para la limpieza regular.  Pero para que la <em>limpieza</em> manual y la <em>limpieza</em> <em>autom√°tica</em> puedan funcionar con diferentes intensidades, los <em>procesos</em> <em>autom√°ticos</em> tienen sus propios par√°metros: <em>autovacuum_vacuum_cost_limit</em> y <em>autovacuum_vacuum_cost_delay</em> .  Si estos par√°metros toman el valor -1, <em>se utiliza</em> el valor de <em>vacuum_cost_limit</em> y / o <em>vacuum_cost_delay</em> . <br><br>  Por defecto, <em>autovacuum_vacuum_cost_limit</em> = -1 (es decir, se utiliza el valor <em>vacuum_cost_limit</em> = 200) y <em>autovacuum_vacuum_cost_delay</em> = 20ms.  En equipos modernos con estos n√∫meros, la limpieza autom√°tica funcionar√° muy, muy lentamente. <br><br>  En la versi√≥n 12, el valor de <em>autovacuum_vacuum_cost_delay</em> se reducir√° a 2 ms, lo que puede considerarse una primera aproximaci√≥n m√°s apropiada. <br><br>  Adem√°s, debe tenerse en cuenta que el l√≠mite establecido por estos par√°metros es com√∫n a todos los procesos de trabajo.  En otras palabras, a medida que cambia el n√∫mero de procesos de trabajo concurrentes, la carga total permanecer√° constante.  Por lo tanto, si la tarea es aumentar el rendimiento de <em>la limpieza autom√°tica</em> , al agregar flujos de trabajo, vale la pena aumentar <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Uso de memoria y monitoreo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez,</a> vimos c√≥mo la limpieza utiliza la memoria RAM del tama√±o <em>maintenance_work_mem</em> para almacenar los identificadores de versi√≥n de las filas que se van a limpiar. <br><br>  La limpieza autom√°tica hace exactamente lo mismo.  Pero puede haber muchos procesos concurrentes si configura <em>autovacuum_max_workers</em> en un valor grande.  Adem√°s, toda la memoria se asigna de forma inmediata y completa, y no por necesidad.  Por lo tanto, para el flujo de trabajo de <em>limpieza autom√°tica</em> , puede establecer su propia restricci√≥n utilizando el par√°metro <em>autovacuum_work_mem</em> .  Por defecto, este par√°metro es -1, es decir, no se usa. <br><br>  Como ya se mencion√≥, la limpieza puede funcionar con una cantidad m√≠nima de memoria.  Pero si se crean √≠ndices en la tabla, entonces un peque√±o valor de <em>maintenance_work_mem</em> puede conducir a escaneos de √≠ndice repetidos.  Lo mismo es cierto para la limpieza autom√°tica.  Idealmente, debe seleccionar un valor m√≠nimo de <em>autovacuum_work_mem</em> en el que no se realicen exploraciones repetidas. <br><br>  Vimos que para monitorear la limpieza puede usar el par√°metro VERBOSE (pero no se puede especificar para la limpieza autom√°tica) o la vista pg_stat_progress_vacuum (pero solo muestra la informaci√≥n actual).  Por lo tanto, la forma principal de supervisar <em>la limpieza autom√°tica</em> es el par√°metro <em>log_autovacuum_min_duration</em> , que muestra informaci√≥n en el registro de mensajes del servidor.  Por defecto est√° desactivado (establecido en -1).  Hay una raz√≥n para habilitar este par√°metro (con un valor de 0, se mostrar√° informaci√≥n sobre todos los inicios de limpieza autom√°tica) y observar los n√∫meros. <br><br>  As√≠ es como se ve la salida: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toda la informaci√≥n necesaria est√° presente aqu√≠. <br><br>  Recuerde que a menudo no debe aumentar el tama√±o de la memoria, sino disminuir el umbral de limpieza para que se procesen menos datos a la vez. <br><br>  Tambi√©n puede tener sentido controlar la longitud de la lista de tablas que deben limpiarse utilizando las vistas anteriores.  Un aumento en la longitud de la lista indicar√° que la limpieza autom√°tica no tiene tiempo para hacer su trabajo y que es necesario cambiar la configuraci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452762/">https://habr.com/ru/post/452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452750/index.html">Nextcloud dentro y fuera de OpenLiteSpeed: configurar proxy inverso</a></li>
<li><a href="../452752/index.html">BigData hecho en casa. Parte 1. Pr√°ctica de Spark Streaming en un cl√∫ster de AWS</a></li>
<li><a href="../452754/index.html">El 19% de las im√°genes Docker m√°s populares no tienen una contrase√±a de root</a></li>
<li><a href="../452756/index.html">Creando Tower Defense en Unity: Enemies</a></li>
<li><a href="../452760/index.html">Vitamina D. Beber o no beber, esa es la cuesti√≥n. (O una historia sobre c√≥mo pas√© un an√°lisis que no me recetaron)</a></li>
<li><a href="../452764/index.html">[Peter] Reuni√≥n JUG.ru con Sergei Melnikov - Perfilando con velocidad superluminal: teor√≠a y pr√°ctica</a></li>
<li><a href="../452766/index.html">Tecnolog√≠a de transmisi√≥n progresiva, o c√≥mo ver video 4k a trav√©s de la red, sin frisos</a></li>
<li><a href="../452768/index.html">C√≥mo dise√±ar un producto si decide ingresar al mercado extranjero</a></li>
<li><a href="../452772/index.html">5 t√©cnicas avanzadas de prueba de Go</a></li>
<li><a href="../452774/index.html">Dell XPS 13 9380: port√°til confiable y muy compacto para negocios serios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>