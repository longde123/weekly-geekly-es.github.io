<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏼 🤶🏼 🚷 Wie wir bei 1C: Enterprise Systeme algebraischer Gleichungen lösen 🌌 ⏯️ 👨🏾‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Arbeiten mit numerischen Matrizen im Allgemeinen und das Lösen von Systemen linearer algebraischer Gleichungen im Besonderen ist ein klassisches m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir bei 1C: Enterprise Systeme algebraischer Gleichungen lösen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/420029/">  Das Arbeiten mit numerischen Matrizen im Allgemeinen und das Lösen von Systemen linearer algebraischer Gleichungen im Besonderen ist ein klassisches mathematisches und algorithmisches Problem, das häufig bei der Modellierung und Berechnung einer großen Klasse von Geschäftsprozessen (z. B. bei der Berechnung von Kosten) verwendet wird.  Beim Erstellen und Betreiben von 1C: Enterprise-Konfigurationen standen viele Entwickler vor der Notwendigkeit, SLAU-Berechnungsalgorithmen manuell zu implementieren, und dann vor dem Problem, lange auf eine Lösung zu warten. <br><br>  „1C: Enterprise“ 8.3.14 enthält Funktionen, mit denen sich die Zeit zum Lösen linearer Gleichungssysteme mithilfe eines auf der Graphentheorie basierenden Algorithmus erheblich verkürzen lässt. <br><br>  Es ist für die Verwendung mit Daten optimiert, die eine spärliche Struktur aufweisen (dh nicht mehr als 10% Koeffizienten ungleich Null in den Gleichungen enthalten), und zeigt im Durchschnitt und im besten Fall die Asymptotik Θ (n⋅log (n) ⋅log (n)), wobei n ist Die Anzahl der Variablen und im schlimmsten Fall (wenn das System zu ~ 100% voll ist) ist sein asymptotisches Verhalten mit klassischen Algorithmen vergleichbar (Θ (n <sup>3</sup> )).  Darüber hinaus zeigt der Algorithmus auf Systemen mit ~ 10 <sup>5</sup> Unbekannten eine hundertfache Beschleunigung im Vergleich zu solchen, die in speziellen Bibliotheken für lineare Algebra (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Superlu</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lapack</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert sind</a> . <br><br><img src="https://habrastorage.org/webt/_v/ol/y3/_voly3cxdw7o-wuhal2wpshtxdc.jpeg" alt="Bild"><br>  <i>Wichtig: Der Artikel und der beschriebene Algorithmus erfordern ein Verständnis der linearen Algebra und der Graphentheorie im ersten Studienjahr einer Universität.</i> <br><a name="habracut"></a><br><h3>  Darstellung der SLAE als Grafik </h3><br>  Betrachten Sie das einfachste spärliche System linearer Gleichungen: <br><br><img src="https://habrastorage.org/webt/ho/w-/q4/how-q4oegesurw5god2vwnwz2du.png" alt="Bild"><br>  <i>Achtung: Das System wird zufällig generiert und später zur Demonstration der Schritte des Algorithmus verwendet</i> <br><br>  Auf den ersten Blick entsteht eine Assoziation mit einem anderen mathematischen Objekt - der Graph-Adjazenz-Matrix.  Warum also nicht die Daten in Adjazenzlisten konvertieren, RAM zur Laufzeit sparen und den Zugriff auf Koeffizienten ungleich Null beschleunigen? <br><br>  Dazu reicht es aus, die Matrix zu transponieren und die Invariante <i>„A [i] [j] = z establish die i-te Variable gibt die j-te Gleichung mit dem Koeffizienten z ein“ zu erstellen</i> und dann für jede Nicht-Null A [i] [j] die entsprechende Kante zu konstruieren vom Scheitelpunkt i zum Scheitelpunkt j. <br><br>  Das resultierende Diagramm sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/fw/sn/qu/fwsnqugbps4ohz6orh1kov4wmoa.png" alt="Bild"><br><br>  Selbst visuell stellt sich heraus, dass es weniger umständlich ist und die asymptotischen Speicherkosten von O (n <sup>2</sup> ) auf O (n + m) sinken, wobei m die Anzahl der Koeffizienten im System ist. <br><br><h3>  Isolierung schwach verbundener Komponenten </h3><br>  Die zweite algorithmische Idee, die bei der Betrachtung der resultierenden Entität in den Sinn kommt: die Verwendung des Prinzips „Teilen und Erobern“.  In Bezug auf den Graphen führt dies zur Trennung des Satzes von Eckpunkten in schwach verbundene Komponenten. <br><br>  Ich möchte Sie daran erinnern, dass die schwach verbundene Komponente eine solche Teilmenge von Scheitelpunkten ist, die maximal eingeschlossen ist, dass zwischen zwei beliebigen Punkten ein Pfad von Kanten in einem ungerichteten Diagramm existiert.  Wir können einen ungerichteten Graphen aus dem ursprünglichen erhalten, indem wir beispielsweise jeder Kante das Gegenteil hinzufügen (mit anschließender Entfernung).  Dann enthält ein Scheitelpunkt der Verbindung alle Scheitelpunkte, die wir erreichen können, wenn wir den Graphen in der Tiefe umrunden. <br><br>  Nach der Trennung der schwach verbundenen Komponenten hat der Graph die folgende Form: <br><br><img src="https://habrastorage.org/webt/rl/bs/uu/rlbsuubbetpzb_j4hvslzyvyvx4.png" alt="Bild"><br><br>  Im Rahmen der Analyse eines linearen Gleichungssystems bedeutet dies, dass kein einziger Scheitelpunkt aus der ersten Komponente in den Gleichungen mit den Zahlen der zweiten Komponente enthalten ist und umgekehrt, dh wir können diese Subsysteme unabhängig voneinander lösen (z. B. parallel). <br><br><h3>  Scheitelpunktreduzierung </h3><br>  Der nächste Schritt des Algorithmus ist genau die Optimierung für die Arbeit mit spärlichen Matrizen.  Selbst in der Grafik aus dem Beispiel gibt es "hängende" Peaks, was bedeutet, dass einige der Gleichungen nur einen Unbekannten enthalten und der Wert dieses Unbekannten bekanntlich leicht zu finden ist. <br><br>  Um solche Gleichungen zu bestimmen, wird vorgeschlagen, ein Array von Listen zu speichern, die die Anzahl der in der Gleichung enthaltenen Variablen mit der Nummer dieses Array-Elements enthalten.  Wenn die Liste die Einheitsgröße erreicht, können wir den „einzigen“ Scheitelpunkt reduzieren und den Rest der Gleichungen in den anderen Gleichungen, in die dieser Scheitelpunkt eingeht, informieren. <br><br>  Somit können wir den Scheitelpunkt 3 unmittelbar nach der vollständigen Verarbeitung der Komponente aus dem Beispiel reduzieren: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2">8</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-4"><span class="MJXp-mrow" id="MJXp-Span-5" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.278em; margin-right: 0.278em;"></span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-7" style="vertical-align: -0.4em;">3</span></span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-9">4</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;">⇒</span><span class="MJXp-msubsup" id="MJXp-Span-11"><span class="MJXp-mrow" id="MJXp-Span-12" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.278em; margin-right: 0.278em;"></span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-14" style="vertical-align: -0.4em;">3</span></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-16">1</span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-19">2</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> 8⋅_3 = 4⇒_3 = 1/2 </script></p><br>  Ähnlich verfahren wir mit Gleichung 0, da sie nur eine Variable enthält: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-20"><span class="MJXp-mn" id="MJXp-Span-21">1</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-25" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-27">1</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">⇒</span><span class="MJXp-msubsup" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-31" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-33">1</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> 1⋅x_1 = 1⇒x_1 = 1 </script></p><br>  Andere Gleichungen ändern sich ebenfalls, nachdem dieses Ergebnis gefunden wurde: <br><p><math> </math> $$ display $$ 1⋅_1 ​​+ 1⋅_2 = 3⇒1⋅_2 = 3-1 = 2 $$ display $$ </p><br>  Das Diagramm hat die folgende Form: <br><br><img src="https://habrastorage.org/webt/l-/gg/fw/l-ggfwjd1nvaadatvfca5jl2abe.png" alt="Bild"><br><br>  Beachten Sie, dass beim Reduzieren eines Scheitelpunkts möglicherweise auch andere angezeigt werden, die ebenfalls einen unbekannten enthalten.  Daher sollte dieser Schritt des Algorithmus wiederholt werden, bis mindestens einer der Eckpunkte reduziert werden kann. <br><br><h3>  Graph neu erstellen </h3><br>  Die aufmerksamsten Leser könnten feststellen, dass eine Situation möglich ist, in der jeder der Scheitelpunkte des Diagramms einen Grad von mindestens zwei aufweist und es unmöglich ist, die Scheitelpunkte weiterhin konsequent zu reduzieren. <br><br>  <i>Das einfachste Beispiel für einen solchen Graphen: Jeder Scheitelpunkt hat einen Auftrittsgrad von zwei, keiner der Scheitelpunkte kann reduziert werden.</i> <br><br><img src="https://habrastorage.org/webt/_p/w-/ae/_pw-aeoap4hluejoabquyt7nnfu.png" alt="Bild"><br><br>  Im Rahmen der Optimierung für dünn besetzte Matrizen wird davon ausgegangen, dass solche Untergraphen klein sind. Sie müssen jedoch noch mit ihnen arbeiten.  Um die Werte der Unbekannten zu berechnen, die Teil des Gleichungssystems sind, wird vorgeschlagen, klassische Methoden zur Lösung von SLAEs zu verwenden (aus diesem Grund zeigt die Einführung, dass unser Algorithmus für eine Matrix, in der alle oder fast alle Koeffizienten in den Gleichungen ungleich Null sind, dieselbe asymptotische Komplexität aufweist wie die Standardkoeffizienten ) <br><br>  Sie können beispielsweise die nach der Reduktion verbleibenden Scheitelpunkte wieder in die Matrixform bringen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Gauß-Methode zum Lösen von SLAEs darauf anwenden</a> .  Auf diese Weise erhalten wir die genaue Lösung, und die Geschwindigkeit des Algorithmus wird verringert, da nicht das gesamte System, sondern nur ein Teil davon verarbeitet wird. <br><br><h3>  Algorithmus testen </h3><br>  Um die Software-Implementierung des Algorithmus zu testen, haben wir mehrere reale Gleichungssysteme mit großem Volumen sowie eine große Anzahl zufällig generierter Systeme verwendet. <br>  Die Erzeugung eines zufälligen Gleichungssystems erfolgte durch sequentielles Hinzufügen von Kanten beliebigen Gewichts zwischen zwei zufälligen Eckpunkten.  Insgesamt war das System zu 5-10% voll.  Die Richtigkeit der Lösungen wurde überprüft, indem die erhaltenen Antworten in das ursprüngliche Gleichungssystem eingesetzt wurden. <br><br><img src="https://habrastorage.org/webt/nu/zs/sv/nuzssvlv6knoria2dt8hra1qtlk.png" alt="Bild"><br>  <i>Die Systeme reichten von 1.000 bis 200.000 Unbekannten</i> <br><br>  Um die Leistung zu vergleichen, haben wir die beliebtesten Bibliotheken zur Lösung linearer Algebra-Probleme wie Superlu und Lapack verwendet.  Natürlich konzentrieren sich diese Bibliotheken auf die Lösung einer Vielzahl von Problemen, und die Lösung von SLAE in ihnen ist in keiner Weise optimiert, sodass sich der Geschwindigkeitsunterschied als signifikant herausstellte. <br><br><img src="https://habrastorage.org/webt/i1/qz/fu/i1qzfuhnioxeembymoj0n3enljy.png" alt="Bild"><br>  <i>Testen der Lapack-Bibliothek</i> <br><br><img src="https://habrastorage.org/webt/um/pj/vr/umpjvriahpa7fjnathlsx2aabak.png" alt="Bild"><br>  <i>Testen der Bibliothek 'superlu'</i> <br><br>  Hier ist der endgültige Vergleich unseres Algorithmus mit den in gängigen Bibliotheken implementierten Algorithmen: <br><br><img src="https://habrastorage.org/webt/z2/gq/ch/z2gqchadb9nqosg_6tz5pa9vfn4.png" alt="Bild"><br><br><h3>  Fazit </h3><br>  Auch wenn Sie kein Entwickler von 1C: Enterprise-Konfigurationen sind, können Sie die in diesem Artikel beschriebenen Ideen und Optimierungsmethoden nicht nur bei der Implementierung eines Algorithmus zur Lösung von SLAEs verwenden, sondern auch für eine ganze Klasse von linearen Algebra-Problemen, die mit Matrizen verbunden sind. <br><br>  Für 1C-Entwickler fügen wir hinzu, dass die neue Funktionalität der SLAE-Lösung die parallele Verwendung von Computerressourcen unterstützt und Sie die Anzahl der verwendeten Berechnungsthreads anpassen können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420029/">https://habr.com/ru/post/de420029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420017/index.html">Die Kunst, Passwörter zu sammeln</a></li>
<li><a href="../de420019/index.html">Client-Server-Interaktion in einem neuen mobilen PvP-Shooter und Spieleserver: Probleme und Lösungen</a></li>
<li><a href="../de420021/index.html">Warum brauchst du Splunk? Internet der Dinge und Industriedaten</a></li>
<li><a href="../de420023/index.html">Speichern von Status in Android-Anwendungen</a></li>
<li><a href="../de420025/index.html">Intelligente Farm. Wie wird sie sein?</a></li>
<li><a href="../de420031/index.html">Zeichnen mit Renderzielen in Unreal Engine</a></li>
<li><a href="../de420033/index.html">Wie wir angefangen haben, Registrierkassen für unsere Kunden zu registrieren</a></li>
<li><a href="../de420035/index.html">Golang GUI: GTK + 3</a></li>
<li><a href="../de420037/index.html">Streamen Sie mit mehreren Kameras aus improvisierten Materialien</a></li>
<li><a href="../de420039/index.html">Funktionales Denken. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>