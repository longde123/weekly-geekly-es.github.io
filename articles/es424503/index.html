<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔛 🙏🏾 💙 Arranca tú mismo, llega la primavera (Parte 1) 👩🏻‍🍳 ♿️ 🤘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evgeny EvgenyBorisov Borisov (NAYA Technologies) y Kirill tolkkv Tolkachev (Cyan.Finance, Twitter ) hablan sobre los momentos más importantes e intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arranca tú mismo, llega la primavera (Parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424503/"> Evgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">EvgenyBorisov</a> Borisov (NAYA Technologies) y Kirill <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">tolkkv</a> Tolkachev (Cyan.Finance, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> ) hablan sobre los momentos más importantes e interesantes de Spring Boot en el ejemplo de un titular para un banco de hierro imaginario. <br><br><img src="https://habrastorage.org/webt/wj/p5/pf/wjp5pfvfgcnp_mda9gcpuiln3zs.png"><br><br>  El artículo se basa en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de</a> Eugene y Cyril de nuestra conferencia Joker 2017. Debajo del corte está la transcripción del video y el texto del informe. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yy43NOreJG4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La conferencia Joker está patrocinada por muchos bancos, así que imaginemos que la aplicación en la que estudiaremos el trabajo de arranque de Spring y el iniciador que creamos está conectada con el banco. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b9/6b3/735/6b96b3735385c3774928851319b3569c.png"><br><br>  Entonces, supongamos que se recibe una orden para una solicitud del Banco de Hierro de Braavos.  Un banco ordinario simplemente transfiere dinero de un lado a otro.  Por ejemplo, así (tenemos una API para esto): <br><br> <code>http://localhost:8080/credit\?name\=Targarian\&amp;amount\=100 <br></code> <br>  Y en Iron Bank, antes de transferir dinero, es necesario que la API del banco calcule si una persona puede devolverlo.  Tal vez no sobrevivirá al invierno y no habrá nadie a quien regresar.  Por lo tanto, se proporciona un servicio que verifica la confiabilidad. <br><br>  Por ejemplo, si intentamos transferir dinero a Targaryen, la operación será aprobada: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc1/d3b/c67/cc1d3bc67ae34759c85b4cae57189037.png"><br><br>  Pero si Stark, entonces no: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a65/453/a4d/a65453a4dc6bf6a0490cbbdaadf78404.png"><br><br>  No es de extrañar: Starks muere con demasiada frecuencia.  ¿Por qué transferir dinero si una persona no sobrevive al invierno? <br><br>  Veamos cómo se ve por dentro. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronBankController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TransferMoneyService transferMoney; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MoneyDao moneyDao; <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/credit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">credit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestParam String name, @RequestParam </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> resultedDeposit = transferMoney.transfer(name, amount);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultedDeposit == -<span class="hljs-number"><span class="hljs-number">1</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Rejected&lt;br/&gt;"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" &lt;b&gt;will`t&lt;/b&gt; survive this winter"</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> format(       <span class="hljs-string"><span class="hljs-string">"&lt;i&gt;Credit approved for %s&lt;/i&gt; &lt;br/&gt;Current  bank balance: &lt;b&gt;%s&lt;/b&gt;"</span></span>,       name,       resultedDeposit   ); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/state"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currentState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moneyDao.findAll().get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getTotalAmount(); } }</code> </pre><br>  Este es un controlador de cadena normal. <br><br>  ¿Quién es responsable de la lógica de elección, a quién otorgar un préstamo y a quién no?  Línea simple: si su nombre es Stark, ciertamente no traicionamos.  En otros casos, qué suerte.  Banco ordinario <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !name.contains(<span class="hljs-string"><span class="hljs-string">"Stark"</span></span>) &amp;&amp; ThreadLocalRandom.current().nextBoolean(); } }</code> </pre><br>  Todo lo demás no es tan interesante.  Estas son algunas anotaciones que hacen todo el trabajo por nosotros.  Todo es muy rapido. <br><br>  ¿Dónde están todas las configuraciones principales?  Solo hay un controlador.  En Dao, generalmente es una interfaz vacía. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoneyDao</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bank</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre><br>  En servicios: solo servicios de traducción y predicción a los que puede enviar.  No hay directorio Conf.  De hecho, solo tenemos application.yml (una lista de quienes pagan deudas).  Y principal es el más común: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(ProphetProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoneyRavenApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{   SpringApplication.run(MoneyRavenApplication.class, args); } }</code> </pre><br>  Entonces, ¿dónde está escondida toda la magia? <br><br>  El hecho es que a los desarrolladores no les gusta pensar en dependencias, configurar configuraciones, especialmente si se trata de configuraciones XML, y pensar en cómo se inicia su aplicación.  Por lo tanto, Spring Boot nos resuelve estos problemas.  Solo necesitamos escribir una solicitud. <br><br><h2>  Dependencias </h2><br>  El primer problema que siempre tuvimos es un conflicto de versiones.  Cada vez que conectamos diferentes bibliotecas que hacen referencia a otras bibliotecas, aparecen conflictos de dependencia.  Cada vez que leo en Internet que necesito agregar algún administrador de entidades, surge una pregunta y ¿qué versión debo agregar para que no rompa nada? <br><br>  Spring Boot resuelve el problema de los conflictos de versiones. <br><br>  ¿Cómo solemos obtener un proyecto Spring Boot (si no hemos llegado a algún lugar donde ya existe)? <br><br><ul><li>  o vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">start.spring.io</a> , marque las casillas de verificación que Josh Long nos enseñó a configurar, haga clic en Descargar proyecto y abra el proyecto donde todo ya está allí; <br></li><li>  o use IntelliJ, donde, gracias a la opción aparecida, las casillas de verificación en Spring Initializer se pueden configurar desde allí. <br></li></ul><br>  Si trabajamos con Maven, entonces el proyecto tendrá pom.xml, donde hay un padre Spring Boot llamado <code>spring-boot-dependencies</code> .  Habrá un gran bloque de gestión de dependencias. <br><br>  No entraré en los detalles de Maven ahora.  Solo dos palabras. <br><br>  El bloque de gestión de dependencias no registra dependencias.  Este es un bloque con el que puede especificar versiones en caso de que se necesiten estas dependencias.  Y cuando indica algún tipo de dependencia en el bloque de administración de dependencias sin especificar la versión, Maven comienza a buscar si hay un bloque de administración de dependencias en el que la versión principal está escrita en el pom principal o en otro lugar.  Es decir  en mi proyecto, agregando una nueva dependencia, ya no indicaré la versión con la esperanza de que se indique en algún lugar del padre.  Y si no se especifica en el padre, entonces ciertamente no creará ningún conflicto con nadie.  En nuestra gestión de dependencias, se indican unas buenas quinientas dependencias, y todas son coherentes entre sí. <br><br>  Pero cual es el problema?  El problema es que en mi empresa, por ejemplo, tengo mi propio padre pom.  Si quiero usar Spring, ¿qué debo hacer con mi padre pom? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fc/b83/2ce/3fcb832ce3faa2a19f2d9f1e1cf6957a.png"><br><br>  No tenemos herencia múltiple.  Queremos usar nuestro pom y obtener el bloque de gestión de dependencias desde el exterior. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02e/835/ff7/02e835ff7cdd677895b23aa561e51130.png"><br><br>  Esto se puede hacer.  Es suficiente registrar la importación BOM del bloque de gestión de dependencias. <br><br><pre> <code class="java hljs">&lt;dependencyManagement&gt; &lt;dependencies&gt;    &lt;dependency&gt;       &lt;groupId&gt;io.spring.platform&lt;/groupId&gt;       &lt;artifactId&gt;platform-bom&lt;/artifactId&gt;       &lt;version&gt;Brussels-SR2&lt;/version&gt;       &lt;type&gt;pom&lt;/type&gt;       &lt;scope&gt;<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>&lt;/scope&gt;    &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;</code> </pre><br>  ¿Quién quiere saber más sobre bom? Vea el informe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Maven vs. Gradle</a> ".  Allí todo esto se explicó en detalle. <br><br>  Hoy en día, entre las grandes empresas se ha puesto de moda escribir bloques tan enormes de gestión de dependencias, donde indican todas las versiones de sus productos y todas las versiones de productos que usan sus productos y que no entran en conflicto entre sí.  Y esto se llama bom.  Esto puede importarse a su bloque de gestión de dependencias sin herencia. <br><br>  Y así es como se hace en Gradle (como de costumbre, lo mismo, pero más fácil): <br><br><pre> <code class="java hljs">dependencyManagement { imports {   mavenBom <span class="hljs-string"><span class="hljs-string">'org.springframework.cloud:spring-cloud-dependencies:Dalston.RELEASE'</span></span> } }</code> </pre><br>  Ahora hablemos de las dependencias mismas. <br><br>  ¿Qué escribiremos en la aplicación?  La gestión de dependencias es buena, pero queremos que la aplicación tenga ciertas capacidades, por ejemplo, para responder a través de HTTP, tener una base de datos o soporte para JPA.  Por lo tanto, todo lo que necesitamos ahora es obtener tres dependencias. <br>  Solía ​​verse así.  Quiero trabajar con la base de datos y comienza: se necesita algún tipo de administrador de transacciones, por lo que se necesita el módulo spring-tx.  Necesito un poco de hibernación, por lo que se requiere EntityManager, hibernate-core u otra cosa.  Configuro todo a través de Spring, por lo que necesito Spring Core.  Es decir, por una cosa simple, tenía que pensar en una docena de dependencias. <br><br>  Hoy tenemos entrantes.  La idea de un iniciador es que le ponemos una dependencia.  Para empezar, agrega las dependencias que se necesitan para el mundo del que vino.  Por ejemplo, si se trata de un iniciador de seguridad, entonces no piensa qué dependencias se necesitan, inmediatamente llegan en forma de dependencias transitivas al iniciador.  O si está trabajando con Spring Data Jpa, ponga una dependencia en el iniciador y traerá todos los módulos necesarios para trabajar con Spring Data Jpa. <br><br>  Es decir  Nuestro pom se ve así: contiene solo esas 3-5 dependencias que necesitamos: <br><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> <span class="hljs-string"><span class="hljs-string">'com.h2database:h2'</span></span></code> </pre><br>  Con las dependencias resueltas, todo se volvió más fácil.  Necesitamos pensar menos ahora.  No hay conflicto y el número de dependencias ha disminuido. <br><br><h2>  Configuración del contexto </h2><br>  Hablemos del siguiente dolor que siempre tuvimos: establecer el contexto.  Cada vez que comenzamos a escribir una aplicación desde cero, lleva mucho tiempo configurar toda la infraestructura.  Registramos en xml o java config muchos de los llamados beans de infraestructura.  Si trabajamos con hibernate, necesitábamos el bean EntityManagerFactory.  Una gran cantidad de beans de infraestructura: administrador de transacciones, fuente de datos, etc.  - Era necesario ajustarse con las manos.  Naturalmente, todos cayeron en contexto. <br><br>  Durante el informe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spring Ripper</a> , creamos el contexto en el principal, y si era el contexto xml, inicialmente estaba vacío.  Si creamos el contexto a través de <code>AnnotationConfigApplicationContext</code> , hay algunos procesadores de beanpost que podrían configurar los beans según las anotaciones, pero el contexto también estaba casi vacío. <br>  Y ahora en main hay <code>SpringApplication.run</code> y no hay contexto visible: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplilcation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{   SpringApplication.run(App.class,args); } }</code> </pre><br>  Pero en realidad tenemos un contexto.  <code>SpringApplication.run</code> nos devuelve algo de contexto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da7/988/391/da79883913f411287e7a5fe0606bab8d.png"><br>  Este es un caso completamente atípico.  Solía ​​haber dos opciones: <br><br><ul><li>  si se trata de una aplicación de escritorio, directamente en la página principal, tenía que escribir una nueva con las manos, seleccionar <code>ClassPathXmlApplicationContext</code> , etc. <br></li><li>  Si trabajamos con Tomcat, entonces había un administrador de servlets, que, según algunas convenciones, buscaba XML y, por defecto, creaba un contexto a partir de él. <br></li></ul><br>  En otras palabras, el contexto era de alguna manera.  Y todavía pasamos algunas clases de configuración a la entrada.  En general, elegimos el tipo de contexto.  Ahora solo tenemos <code>SpringApplication.run</code> , toma configuraciones como argumentos y construye un contexto <br><br><h2>  Riddle: ¿qué podemos pasar allí? </h2><br>  <b>Dado:</b> <br><br> <code>RipperApplication.class</code> <br> <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>… main(String[] args) {  SpringApplication.run(?,args); }</code> </pre><br>  Pregunta: ¿qué más se puede transferir allí? <br><br>  <b>Opciones:</b> <br><ol><li> <code>RipperApplication.class</code> <br> </li><li> <code>String.class</code> <br> </li><li> <code>"context.xml"</code> <br> </li><li> <code>new ClassPathResource("context.xml")</code> <br> </li><li> <code>Package.getPackage("conference.spring.boot.ripper")</code> <br> </li></ol><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  <b>La respuesta es:</b> <br>  La documentación dice que cualquier cosa puede transferirse allí.  Como mínimo, esto se compilará y de alguna manera funcionará. <br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/524/9c0/cae/5249c0cae466170986ee0678fc608979.png"><br><br>  Es decir  De hecho, todas las respuestas son correctas.  Se puede hacer que cualquiera de ellos funcione, incluso <code>String.class</code> , y en algunas condiciones ni siquiera tiene que hacer nada para que funcione.  Pero esta es una historia diferente. <br><br>  Lo único que no se dice en la documentación es en qué forma enviarnos allí.  Pero esto ya es del reino del conocimiento secreto. <br><br><pre> <code class="java hljs">SpringApplication.run(Object[] sources, String[] args) # <span class="hljs-function"><span class="hljs-function">APPLICATION </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SETTINGS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SpringApplication)</span></span></span><span class="hljs-function"> spring.main.sources</span></span>= # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xml</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spring</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">web</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">environment</span></span></span></span>= # <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> spring.main.banner-mode=console # log/off</code> </pre><br>  <code>SpringApplication</code> es realmente importante aquí: más abajo en las diapositivas lo tendremos con Carlson. <br><br>  Nuestro Carlson crea algún tipo de contexto basado en la información que le transmitimos.  Le recuerdo, le damos, por ejemplo, cinco maravillosas opciones que puede hacer que todo funcione con <code>SpringApplication.run</code> : <br><br><ul><li> <code>RipperApplication.class</code> <br> </li><li> <code>String.class</code> <br> </li><li> <code>"context.xml"</code> <br> </li><li> <code>new ClassPathResource("context.xml")</code> <br> </li><li> <code>Package.getPackage("conference.spring.boot.ripper")</code> <br> </li></ul><br>  ¿Qué hace <code>SpringApplication</code> por nosotros? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/dca/945/f10dca945d839f103d5f557fe456d0c9.png"><br><br>  Cuando creamos el contexto a través de <code>new</code> en main a través de <code>new</code> , tuvimos muchas clases diferentes que implementan la interfaz <code>ApplicationContext</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/8c2/936/3628c2936a6b2fb26ffca700bde37db8.png"><br><br>  ¿Y qué opciones hay cuando Carlson construye el contexto? <br><br>  Solo tiene dos tipos de contexto: un contexto web ( <code>WebApplicationContext</code> ) o un contexto genérico ( <code>AnnotationConfigApplicationContext</code> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fd/cf8/b4b/2fdcf8b4b95f922676b67bca5e80ebf7.png"><br><br>  La elección del contexto se basa en la presencia de dos clases en el classpath: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07b/aa1/a79/07baa1a7908e04c88d3f707b2f60354e.png"><br><br>  Es decir, el número de configuraciones no ha disminuido.  Para construir un contexto, podemos especificar todas las opciones de configuración.  Para construir el contexto, puedo pasar un script maravilloso o xml;  Puedo indicar qué paquetes escanear o pasar la clase marcada con algunas anotaciones.  Es decir, tengo todas las posibilidades. <br><br>  Sin embargo, este es Spring Boot.  Todavía no hemos creado un único contenedor, ni una sola clase, solo tenemos main, y en él está nuestro Carlson - <code>SpringApplication.run</code> .  En la entrada, recibe una clase marcada con algún tipo de anotación Spring Boot. <br><br>  Si nos fijamos en este contexto, ¿qué pasará allí? <br><br>  En nuestra aplicación, después de conectar un par de arrancadores, había 436 contenedores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/8c2/3bd/d3f8c23bde2c09e137620b7b13bda291.png"><br><br>  Casi 500 frijoles solo para comenzar a escribir. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bea/cce/768/beacce7686a37a19fa7af18af29906af.png"><br><br>  A continuación, entenderemos de dónde provienen estos frijoles. <br><br>  Pero antes que nada, queremos hacer lo mismo. <br><br>  La magia de los principiantes, además de resolver todos los problemas con las adicciones, es que conectamos solo 3-4 iniciadores y tenemos 436 contenedores.  Conectaríamos 10 arrancadores, habría más de 1000 bins, porque cada arrancador, excepto las dependencias, ya trae configuraciones en las que se registran algunos bins necesarios.  Es decir  Usted dijo que desea un iniciador para la web, por lo que necesita un despachador de servlets y <code>InternalResourceViewResolver</code> .  Conectamos el iniciador jpa; necesitamos el bean <code>EntityManagerFactory</code> .  Todos estos beans ya están en algún lugar de las configuraciones iniciales, y llegan mágicamente a la aplicación sin ninguna acción de nuestra parte. <br><br>  Para comprender cómo funciona esto, hoy escribiremos un iniciador, que también traerá contenedores de infraestructura a todas las aplicaciones que usan este iniciador. <br><br><h2>  Ley del Hierro 1.1.  Siempre envía un cuervo </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/100/bbf/93f100bbf10a54759538b2bcb87c6b89.png"><br><br>  Veamos el requisito del cliente.  Iron Bank tiene muchas aplicaciones diferentes que se ejecutan en diferentes sucursales.  Los clientes quieren que se envíe un cuervo cada vez que se eleva la aplicación, información que la aplicación ha aumentado. <br><br>  Comencemos a escribir el código en la aplicación de un banco de hierro específico (banco de hierro).  Escribiremos un iniciador para que todas las aplicaciones de Iron Bank que dependan de este iniciador puedan enviar automáticamente un cuervo.  Recordamos que los iniciadores nos permiten ajustar automáticamente las dependencias.  Y lo más importante, no escribimos casi ninguna configuración. <br><br>  Creamos un oyente que escucha el contexto para actualizarse (último evento), después de lo cual envía un cuervo.  Escucharemos <code>ContextRefreshEvent</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">" ..."</span></span>); } }</code> </pre><br><br>  Escribimos oyente en la configuración inicial.  Hasta ahora, solo habrá un oyente, pero mañana el cliente pedirá algunas otras piezas de infraestructura, y también las escribiremos en esta configuración. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br>  Surge la pregunta: ¿cómo hacer que la configuración de nuestro iniciador se ajuste automáticamente a todas las aplicaciones que utilizan este iniciador? <br><br>  Para todas las ocasiones hay un "habilitar algo". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c4/567/776/6c45677768f95b821d097093387cf611.png"><br><br>  Realmente, si dependo de 20 titulares, tendré que poner <code>@Enable</code> ?  ¿Y si el motor de arranque tiene varias configuraciones?  La clase de configuración principal se colgará con <code>@Enable*</code> , ¿cómo es el árbol de Año Nuevo? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/628/871/4ab/6288714abd5cb5b81b1abd6745507c1d.png"><br><br>  De hecho, quiero obtener algún tipo de inversión de control en el nivel de dependencia.  Quiero conectar el motor de arranque (para que todo funcione), y no sé nada sobre cómo se llama su interior.  Por lo tanto, usaremos spring.factories. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/568/3cf/7e1/5683cf7e11a3019052515b81db30bf11.png"><br><br><h2>  Entonces, ¿qué es la <code>spring.factories</code> </h2><br>  La documentación dice que hay tales spring.factories en las que debe indicar la correspondencia de las interfaces y lo que necesita cargar en ellas: nuestras configuraciones.  Y todo esto aparecerá mágicamente en contexto, mientras que varias condiciones funcionarán en ellos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db0/f31/36c/db0f3136cdcb579a498223f3272e5d61.png"><br><br>  Así obtenemos la inversión de control, que necesitábamos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/915/4be/6fd/9154be6fd40c4a626a2ecd8d5198636c.png"><br><br>  Tratemos de implementar.  En lugar de acceder a las entrañas del motor de arranque que conecté (tome esta configuración, y esto ...), todo será exactamente lo contrario.  El iniciador tendrá un archivo llamado <b>spring.factories</b> .  En este archivo, prescribimos qué configuración de este iniciador debe activarse para todos los que lo hayan descargado.  Un poco más adelante explicaré cómo funciona exactamente esto en Spring Boot: en algún momento comienza a escanear todos los frascos y busca el archivo spring.factories. <br><br><pre> <code class="java hljs">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ironbank.IronConfiguration</code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br>  Ahora todo lo que nos queda por hacer es conectar el iniciador en el proyecto. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">compile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':iron-starter'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br><br>  En Maven, de manera similar, debe registrar la dependencia. <br><br>  Lanzamos nuestra aplicación.  El cuervo debería despegar en el momento en que sube, aunque no hicimos nada en la aplicación en sí.  En términos de infraestructura, nosotros, por supuesto, escribimos y configuramos el motor de arranque.  Pero desde el punto de vista del desarrollador, solo conectamos la dependencia y apareció la configuración: el cuervo voló.  Todo lo que quisimos. <br><br>  Esto no es mágico.  La inversión del control no debería ser mágica.  Así como el uso de Spring no debería ser mágico.  Sabemos que este es un marco principalmente para la inversión de control.  Como hay una inversión de control para su código, también hay una inversión de control para los módulos. <br><br><h2>  @SpringBootApplication alrededor de la cabeza </h2><br>  Recuerde el momento en que construimos el contexto en general con nuestras manos.  Escribimos un <code>new AnnotationConfigApplicationContext</code> y pasamos alguna configuración a la entrada, que era una clase java.  Ahora también escribimos <code>SpringApplication.run</code> y pasamos la clase allí, que es la configuración, solo que está marcada con otra anotación bastante poderosa <code>@SpringBootApplication</code> , que lleva a todo el mundo. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Inherited</span></span> <span class="hljs-meta"><span class="hljs-meta">@SpringBootConfiguration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableAutoConfiguration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(excludeFilters = { <span class="hljs-meta"><span class="hljs-meta">@Filter</span></span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), <span class="hljs-meta"><span class="hljs-meta">@Filter</span></span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> SpringBootApplication { … }</code> </pre><br>  En primer lugar, dentro hay <code>@Configuration</code> , es decir, es una configuración.  Puede escribir <code>@Bean</code> y, como de costumbre, registrar los beans. <br><br>  En segundo lugar, <code>@ComponentScan</code> encuentra por encima de él.  Por defecto, escanea absolutamente todos los paquetes y subpaquetes.  En consecuencia, si comienza a crear servicios en el mismo paquete o en sus <code>@Service</code> ( <code>@Service</code> , <code>@RestController</code> ), se escanean automáticamente, ya que la configuración principal inicia su proceso de escaneo. <br><br>  En realidad, <code>@SpringBootApplication</code> no hace nada nuevo.  Simplemente compiló todas las mejores prácticas que estaban en las aplicaciones de Spring, por lo que ahora se trata de algún tipo de composición de anotaciones, incluido <code>@ComponentScan</code> . <br><br>  Además, todavía hay cosas que no estaban allí antes: <code>@EnableAutoConfiguration</code> .  Esta es la clase que prescribí en spring.factories. <br>  <code>@EnableAutoConfiguration</code> , si nos fijamos, lleva <code>@Import</code> con él: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.TYPE}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Inherited</span></span> <span class="hljs-meta"><span class="hljs-meta">@AutoConfigurationPackage</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>({EnableAutoConfigurationImportSelector.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EnableAutoConfiguration {  String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string"><span class="hljs-string">"spring.boot.enableautoconfiguration"</span></span>;  Class&lt;?&gt;[] exclude() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {};  String[] excludeName() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; }</code> </pre><br>  La tarea principal de <code>@EnableAutoConfiguration</code> es hacer la importación de la que queríamos deshacernos en nuestra aplicación, porque su implementación debería habernos obligado a escribir el nombre de alguna clase desde el inicio.  Y solo podemos averiguarlo a partir de la documentación.  Pero todo debería ser por sí mismo. <br><br>  Debes prestar atención a esta clase.  Termina con <code>ImportSelector</code> .  En Spring normal, escribimos <code>Import(Some Configuration.class)</code> alguna configuración y se carga, como todos sus dependientes.  Esto es <code>ImportSelector</code> , esto no es una configuración.  <code>ImportSelector</code> todos nuestros iniciadores en contexto.  Procesa la anotación <code>@EnableAutoConfiguration</code> de spring.factories, que selecciona qué configuraciones cargar y agrega los beans que especificamos en IronConfiguration al contexto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/606/62f/5cd/60662f5cd333ea707070ccf297177bc7.png"><br><br>  ¿Cómo lo hace él? <br><br>  En primer lugar, utiliza una clase de utilidad sencilla, SpringFactoriesLoader, que analiza spring.factories y carga todo lo que se le pide.  Él tiene dos métodos, pero no son muy diferentes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d2/219/686/2d2219686ee5232678b48cbaa051abf1.png"><br><br>  Spring Factories Loader existió en Spring 3.2, pero nadie lo usó.  Aparentemente fue escrito como un desarrollo potencial del marco.  Y así se convirtió en Spring Boot, donde hay tantos mecanismos que utilizan la convención spring.factories.  Además, mostraremos que, además de la configuración, también puede escribir en spring.factories: oyentes, procesadores inusuales, etc. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFactories</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Class&lt;T&gt; factoryClass, ClassLoader cl )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFactoryNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Class&lt;?&gt; factoryClass, ClassLoader cl )</span></span></span></span></code> </pre><br>  Así es como funciona la inversión de control.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que cumplimos con el principio abierto cerrado, de acuerdo con el cual no es necesario cambiar algo en algún lugar cada vez. Cada iniciador lleva muchas cosas útiles al proyecto (hasta ahora solo estamos hablando de las configuraciones que lleva). Y cada iniciador puede tener su propio archivo llamado spring.factories. Con su ayuda, le dice qué lleva exactamente. Y en Spring Boot hay muchos mecanismos diferentes que son capaces de todos los principiantes de aportar lo que dicen las fábricas de spring. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay un matiz en todo este esquema. Si vamos a estudiar cómo funciona en Spring, como escriben las personas que han </font></font><code>org.springframework.boot:spring-boot-autoconfigure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ideado </font><font style="vertical-align: inherit;">todo este esquema de iniciadores, veremos que tienen una dependencia </font><font style="vertical-align: inherit;">, hay una línea en META-INF / spring.</font></font><code>EnableAutoConfiguration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y tiene muchas configuraciones (la última vez que miré, había alrededor de 80 configuraciones automáticas desconectadas allí). </font></font><br><br><pre> <code class="java hljs">spring-boot-autoconfigure.jar/spring.factories&lt;/b&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration.\ ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, independientemente de si conecté el motor de arranque o no, cuando trabajo con Spring Boot, siempre habrá uno de los jar-s (jar del propio Spring Boot), en el que está su spring.factories personal, donde se escriben 90 configuraciones. </font><font style="vertical-align: inherit;">Cada una de estas configuraciones puede contener muchas otras configuraciones, por ejemplo </font></font><code>CacheAutoConfiguration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que contienen tal cosa, algo de lo que queríamos escapar:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; types.length; i++) { Imports[i] = CacheConfigurations.getConfigurationClass(types[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> imports;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otra parte, entonces algún mapa se saca estáticamente de la clase allí, y las configuraciones cargadas (que no están en esta primavera. Fábricas) están codificadas en este mapa. </font><font style="vertical-align: inherit;">No serán tan fáciles de encontrar.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;CacheType, Class&lt;?&gt;&gt; MAPPINGS; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { Map&lt;CacheType, Class&lt;?&gt;&gt; mappings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;CacheType, Class&lt;?&gt;&gt;(); mappings.put(CacheType.GENERIC,    GenericCacheConfiguration.class); mappings.put(CacheType.EHCACHE,    EhCacheCacheConfiguration.class); mappings.put(CacheType.HAZELCAST,  HazelcastCacheConfiguration.class); mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class); mappings.put(CacheType.JCACHE,     JCacheCacheConfiguration.class); mappings.put(CacheType.COUCHBASE,  CouchbaseCacheConfiguration.class); mappings.put(CacheType.REDIS,      RedisCacheConfiguration.class); mappings.put(CacheType.CAFFEINE,   CaffeineCacheConfiguration.class); addGuavaMapping(mappings); mappings.put(CacheType.SIMPLE,     SimpleCacheConfiguration.class); mappings.put(CacheType.NONE,       NoOpCacheConfiguration.class); MAPPINGS = Collections.unmodifiableMap(mappings); }</code> </pre><br>  ,          . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/2fc/453/c3b2fc453c4a8dc085495a14e5e55fe5.png"><br><br>   . : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/620/a14/247/620a1424730c6f0a49c87e212966e049.png"><br><br>   .   — , ,  ,      open closed principle —   spring.factories,     .     ,    -   . <br><br>      ,    Spring Boot,    —   90 .     30 ,     Spring Boot. <br><br>    ,     .   2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre las novedades en Spring 4, donde se dijo que apareció una anotación </font></font><code>@Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que hace posible escribir condiciones en sus anotaciones que se refieren a clases que regresan </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dependiendo de esto, los beans se crean o no. </font><font style="vertical-align: inherit;">Dado que la configuración de Java en Spring también es un bean, también puede establecer diferentes condiciones allí. </font><font style="vertical-align: inherit;">Por lo tanto, se consideran las configuraciones, pero si se devuelve condicional </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se descartarán. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay matices. </font><font style="vertical-align: inherit;">En primer lugar, esto lleva a una situación en la que el contenedor puede o no estar, dependiendo de algunas configuraciones del entorno. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cc/f90/83f/2ccf9083f1a80c0d6b7723d846912b2e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considera esto como un ejemplo.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ley de Hierro 1.2. </font><font style="vertical-align: inherit;">Cuervo solo en producción</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cliente tiene un nuevo requisito. </font><font style="vertical-align: inherit;">Raven es algo caro, no hay muchos. </font><font style="vertical-align: inherit;">Por lo tanto, deben lanzarse solo si sabemos que la producción ha aumentado. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1f/17e/71d/e1f17e71dcd1ec015e9044dbf021fbba.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En consecuencia, el oyente que lanza el cuervo solo debe crearse si es producción. </font><font style="vertical-align: inherit;">Intentemos hacerlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entramos en la configuración y escribimos:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> &lt;b&gt;<span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span>&lt;/b&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo decidimos si es producción o no? </font><font style="vertical-align: inherit;">Tenía una compañía extraña que decía: "Si Windows está en la máquina, significa no producción, pero si no Windows, entonces producción". </font><font style="vertical-align: inherit;">Cada uno tiene su propio condicional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Específicamente, el Banco de Hierro dijo que quieren administrar esto manualmente: cuando el servicio sube, debería aparecer una ventana emergente: "producción o no". </font><font style="vertical-align: inherit;">Tal condición no se proporciona en Spring Boot.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>(OnProductionCondition.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ConditionalOnProduction { }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hacemos un buen viejo popap: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnProductionCondition</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JOptionPane.showConfirmDialog(parentComponent: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">" ?"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probémoslo. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/431/b6d/865/431b6d8658b449e804b2cad93ecf6f08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elevamos el servicio, hacemos clic en Sí en la ventana y el cuervo vuela (se crea un oyente). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzamos de nuevo, responda No, el cuervo no vuela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, la anotación se </font></font><code>@Conditional(OnProductionCondition.class)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refiere a la clase recién escrita, donde hay un método que debería devolver </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tal aire acondicionado se puede inventar independientemente, lo que hace que la aplicación sea muy dinámica, le permite funcionar de manera diferente en diferentes condiciones.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pazzler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribimos. Podemos hacer varias configuraciones, ponerlas a condición. Supongamos que tenemos nuestra propia condición y es popular, como </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y hay, por ejemplo, 15 frijoles que solo se necesitan en la producción. Los marqué con esta anotación. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pregunta: la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lógica que descubre si es producción o no, ¿cuántas veces debería funcionar? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué diferencia funciona? Bueno, tal vez esta lógica es cara, lleva tiempo y el tiempo es dinero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A modo de ilustración, se nos ocurrió un ejemplo:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UndeadArmyConfiguration</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DragonIslandConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DragonGlassFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dragonGlassFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DragonGlassFactory(); } ... }</code> </pre><br>      :  ,  .   - —  ,    . <br><br>    .          —     ,  ,  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69d/220/f6e/69d220f6e04188268807f41dcde6c5ed.png"><br><br>      ,       (  <code>OnProductionCondition.class</code>   ,       —   ).    .   ,      ,        ,  - .      5 ? <br><br> <b> </b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no muy claro: 300 o 400. En realidad, hay algún tipo de juego completo. </font><font style="vertical-align: inherit;">Estuvimos dando vueltas durante mucho tiempo para entender primero lo que estaba sucediendo. </font><font style="vertical-align: inherit;">Cómo sucede es un tema aparte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La situación es así. </font><font style="vertical-align: inherit;">Si kondishn está por encima de la primera clase (clase </font></font><code>@Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>@Configuration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>@Service</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">junto con él es kondishn), cumple tres veces en cada uno de tales bin. </font><font style="vertical-align: inherit;">Además, si esta configuración está registrada en el iniciador, entonces dos veces.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UndeadArmyConfiguration</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el contenedor está registrado dentro de la configuración, siempre una vez. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DragonIslandConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DragonGlassFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dragonGlassFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DragonGlassFactory(); } ... }</code> </pre><br>       ,   ,   .     ,    -   ,          ,  300.       ,     ,      .  400. <br><br>  :         ?      : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c7/efa/d4b/6c7efad4bc5e1279c7ba350355a0fa59.png"><br><br>  ,   .   :     -,      ,    ,      .          ,   ,   . <br><br><h2>   1.3.    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos desarrollando nuestro motor de arranque. De alguna manera debemos especificar el vuelo del cuervo. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/4fc/726/9324fc726c3e1f36d5459fae6838f093.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿En qué archivo prescribimos cosas para el principiante? Los principiantes traen una configuración en la que hay beans. ¿Cómo se configuran estos beans? ¿De dónde obtienen la fuente de datos, el usuario, etc. Naturalmente, tienen valores predeterminados para todas las ocasiones, pero ¿cómo permiten que esto se redefina? Hay dos opciones: </font></font><code>application.properties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>application.yml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Allí puede ingresar información que se completará maravillosamente en IDEA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué empeora nuestro arranque? Cualquiera que lo use también debería poder decir en qué direcciones vuela el cuervo: debemos hacer una lista de destinatarios. Este es el primero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, queremos que el oyente no se cree y que el cuervo no se envíe si la persona no registró los destinatarios. </font><font style="vertical-align: inherit;">Necesitamos una condición adicional para crear un oyente que envíe el cuervo.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el iniciador en sí mismo es necesario porque puede tener muchas cosas diferentes además de un cuervo. </font><font style="vertical-align: inherit;">Pero si no está escrito dónde debe volar el cuervo, ese simplemente no se crea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y el tercero: también queremos autocompletar, para que las personas que empujaron nuestro motor de arranque contra ellos mismos reciban un cumplido sobre todas las propiedades que lee el motor de arranque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada una de estas tareas, tenemos nuestra propia herramienta. </font><font style="vertical-align: inherit;">Pero antes que nada, debes mirar las anotaciones existentes. </font><font style="vertical-align: inherit;">Tal vez algo nos convenga?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnCloudPlatform</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnExpression</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJava</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJndi</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnNotWebApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnResource</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnSingleCandidate</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnWebApplication</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, hay cosas aquí que nos ayudarán. </font><font style="vertical-align: inherit;">En el primer lugar </font></font><code>@ConditionalOnProperty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta es una condición que funciona si hay una propiedad específica o propiedad con algún valor especificado en application.yml. </font><font style="vertical-align: inherit;">Del mismo modo, tenemos </font></font><code>@ConfigurationalProperty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que hacer un autocompletado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autocompletar </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debemos asegurarnos de que todas las propiedades comiencen a autocompletarse. </font><font style="vertical-align: inherit;">Sería bueno que esto se completara automáticamente no solo entre las personas que los registrarán en su application.yml, sino también en nuestro iniciador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamemos a nuestra propiedad "cuervo". </font><font style="vertical-align: inherit;">Debe saber a dónde volar.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDEA nos dice que algo está mal aquí: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/377/da5/e03/377da5e032812dd581b7832e2e6ef56b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la documentación dice que no hemos agregado una dependencia (en Maven no habría referencia a la documentación, sino un botón "agregar dependencia"). </font><font style="vertical-align: inherit;">Solo agrégalo a tu proyecto.</font></font><br><br><pre> <code class="java hljs">subproject { dependencies { compileOnly <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-configuration-processor'</span></span> compile <span class="hljs-string"><span class="hljs-string">'org.springframework.boot: spring-boot-starter'</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, según IDEA, tenemos todo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicaré qué tipo de adicción agregamos. </font><font style="vertical-align: inherit;">Todo el mundo sabe qué es el procesador de anotaciones. </font><font style="vertical-align: inherit;">En una forma simplificada, esto es algo que puede hacer algo en la etapa de compilación. </font><font style="vertical-align: inherit;">Por ejemplo, Lombok tiene su propio procesador de anotaciones, que genera una gran cantidad de código útil en la etapa de compilación: establecedores, captadores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿De dónde viene el autocompletado en la propiedad que está en las propiedades de la aplicación? </font><font style="vertical-align: inherit;">Hay un archivo JSON con el que IDEA puede trabajar. </font><font style="vertical-align: inherit;">Este archivo describe todas las propiedades que IDEA debería poder compilar automáticamente. </font><font style="vertical-align: inherit;">Si desea la propiedad que se le ocurrió para el iniciador, IDEA también puede compilar automáticamente, tiene dos formas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede ingresar manualmente a este JSON usted mismo y agregarlos en un formato determinado; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede extraer el procesador de anotaciones de Spring Boot, que puede generar esta pieza de JSON en la etapa de compilación. </font><font style="vertical-align: inherit;">Las propiedades que se deben agregar allí están determinadas por la anotación mágica Spring Boot, con la que podemos marcar las clases que son propietarios. </font><font style="vertical-align: inherit;">En la etapa de compilación, el procesador de anotación Spring Boot encuentra todas las clases que están etiquetadas </font></font><code>@ConfigurationalProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lee la propiedad de nombre de ellas y genera JSON. </font><font style="vertical-align: inherit;">Como resultado, todos los que dependerán del iniciador recibirán este JSON como regalo.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También debe recordar </font></font><code>@EnableConfigurationProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que esta clase aparece dentro de su contexto como un bean.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo no se ve muy bien, pero debe hacer esto para que aparezca un poco antes que el resto de los beans (porque el resto de los beans utilizan su propiedad para configurarse). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, fue necesario poner dos anotaciones:</font></font><br><br><ul><li> <code>@EnableConfigurationProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indicando las propiedades de quién; </font></font><br></li><li> <code>@ConfigurationalProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diciendo qué prefijo. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y no hay que olvidar a los captadores y setters. </font><font style="vertical-align: inherit;">También son importantes, de lo contrario nada funciona, la acción no sube. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, tenemos un archivo que, en principio, puede escribirse manualmente. </font><font style="vertical-align: inherit;">Pero a nadie le gusta escribir manualmente.</font></font><br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"hints"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"groups"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"sourceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbank.RavenProperties"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbankRavenProperties"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"sourceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbank.RavenProperties"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"java.util.List&lt;java.lang.String&gt;"</span></span> } ] }</code> </pre><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dirección del cuervo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hicimos la primera parte de la tarea: obtuvimos algunas propiedades. </font><font style="vertical-align: inherit;">Pero nadie está relacionado con estas propiedades todavía. </font><font style="vertical-align: inherit;">Ahora deben establecerse como condición para crear nuestro oyente.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregamos una condición más: un cuervo debe crearse solo con la condición de que alguien le diga a dónde volar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora escribiremos a dónde volar en application.yml.</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">spring</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">application</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">money-raven</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jpa</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hibernate</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ddl-auto</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">validate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ironbank</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>:   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  : <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>: ,   : <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por prescribir en la lógica que vuela a donde le dijeron. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, podemos generar un constructor. </font><font style="vertical-align: inherit;">El nuevo Spring tiene una inyección de constructor, esta es la forma recomendada. </font><font style="vertical-align: inherit;">A Eugene le gusta </font></font><code>@Autowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hacer que todo aparezca en la aplicación a través de la reflexión. </font><font style="vertical-align: inherit;">Me encanta seguir las convenciones que ofrece Spring:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no es gratis. </font><font style="vertical-align: inherit;">Por un lado, obtienes un comportamiento verificable, por otro lado, obtienes algunas hemorroides.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay ninguno </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, con Spring 4.3 no puedes instalarlo. </font><font style="vertical-align: inherit;">Si hay un solo constructor, lo es </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, se usa una anotación </font></font><code>@RequiredArgsConstructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que genera un solo constructor. </font><font style="vertical-align: inherit;">Esto es equivalente a este comportamiento:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ravenProperties = ravenProperties; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring aconseja escribir de esta manera o usar Lombok. </font><font style="vertical-align: inherit;">Jurgen Holler, que ha estado escribiendo el 80% del código de Spring desde 2002, le recomienda que lo configure </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que sea visible (de lo contrario, la mayoría de las personas miran y no ven ninguna inyección).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-meta"><span class="hljs-meta">@Aurowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ravenProperties = ravenProperties; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo pagamos por este enfoque? </font><font style="vertical-align: inherit;">Tuvimos que agregar </font></font><code>RavenProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la configuración de Java. </font><font style="vertical-align: inherit;">Y si lo puse </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre el campo, no habría que cambiar nada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, los cuervos son enviados. </font><font style="vertical-align: inherit;">Completamos la tarea, lo que permitió a los usuarios de nuestro iniciador tener cumplidos en sus configuraciones, mientras que obtuvimos un contenedor que se enciende y apaga dependiendo de estas configuraciones.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ley del hierro 1.4. </font><font style="vertical-align: inherit;">Cuervo personalizado</font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/cdd/00e/5a3/cdd00e5a367e65ca813b456d704b8e44.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sucede que necesita personalizar el comportamiento del iniciador. Por ejemplo, tenemos nuestro propio cuervo negro. Y necesitamos uno blanco que fume, y queremos enviarlo para que la gente vea humo en el horizonte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasemos de la alegoría a la vida real. El primer plato me trajo un montón de beans de infraestructura, y eso es genial. Pero no me gusta cómo están configurados. Ingresé a las propiedades de la aplicación y cambié algo allí, y ahora me gusta todo. Pero hay situaciones en las que la configuración es tan complicada que es más fácil registrar la fuente de datos usted mismo que tratar de averiguar las propiedades de la aplicación. Es decir, queremos registrar la fuente de datos nosotros mismos en el contenedor recibido del iniciador. ¿Qué pasará entonces? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yo mismo registré algo y el motor de arranque me trajo mi fuente de datos. ¿Tengo dos ahora? ¿O uno aplastará a uno (y cuál?)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queremos mostrarle otra condición que permita que el iniciador traiga algún tipo de contenedor solo si la persona que usa el iniciador no tiene dicho contenedor. </font><font style="vertical-align: inherit;">Al final resultó que, esto es completamente no trivial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una gran cantidad de condiciones que ya se nos han hecho:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnCloudPlatform</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnExpression</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJava</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJndi</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnNotWebApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnResource</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnSingleCandidate</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnWebApplication</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principio, </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también lo hay, así que solo use el ya hecho. </font><font style="vertical-align: inherit;">Vayamos a la configuración, donde indicamos que debe crearse solo si nadie ha creado ese contenedor antes.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>&lt;/b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si abre la mayoría de los iniciadores, verá que cada bin, cada configuración se cuelga con un conjunto de anotaciones. Solo estamos tratando de hacer un análogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al intentar lanzar el cuervo no fue, pero apareció el Evento, que escribimos en nuestro nuevo oyente - </font></font><code>MyRavenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/456/3a1/93c/4563a193c67943645fc7a4c006cd791b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos puntos importantes aquí. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer punto es que nos enganchamos de nuestro oyente existente y no escribimos ningún oyente allí:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ravenProperties); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"event = "</span></span> + event); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo: lo hicimos con la ayuda del componente. Si lo hicimos en una configuración de Java, es decir registraría la misma clase que un bean de configuración, nada funcionaría para nosotros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si limpio </font></font><code>extends</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y hago algún tipo de escucha de aplicaciones, </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no funcionará. Pero desde También se llama a la clase, cuando intentamos crearla, podemos escribir </font></font><code>ravenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tal como lo hicimos en nuestra configuración. Arriba, nos centramos en el hecho de que el nombre del bean en la configuración de Java será por el nombre del método. Y en este caso, creamos un bin llamado </font></font><code>ravenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué necesitas saber todo esto? Con Spring Boot, todo suele ser excelente, pero solo al principio. Cuando el proyecto avanza, aparece un iniciador, el segundo, el tercero. Empiezas a escribir algunas cosas con tus manos, porque incluso el mejor principiante no te dará lo que necesitas. Y comienzan los conflictos bin. Por lo tanto, es bueno si tiene al menos una idea general de cómo asegurarse de que no se cree un bean y cómo registrar el bean en su hogar para que el iniciador no genere conflictos (o si tiene dos iniciadores que traen uno y el mismo el mismo contenedor para que no entren en conflicto entre ellos). Para resolver el conflicto, estoy escribiendo mi bean, que se asegurará de que no se cree ni el primero ni el segundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, un conflicto de frijoles es una buena situación porque lo ves. </font><font style="vertical-align: inherit;">Si especificamos los mismos nombres de bin, no tendremos un conflicto. </font><font style="vertical-align: inherit;">Un bean simplemente sobrescribirá a otro. </font><font style="vertical-align: inherit;">Y comprenderán durante mucho tiempo dónde está lo que estaba allí. </font><font style="vertical-align: inherit;">Por ejemplo, si hacemos algún tipo de fuente de datos </font></font><code>@Bean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sobrescribirá la fuente de datos existente </font></font><code>@Bean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, si el motor de arranque lleva lo que no necesita, simplemente haga un contenedor con la misma identificación y listo. </font><font style="vertical-align: inherit;">Es cierto, si el iniciador en alguna versión cambia el nombre del método, entonces eso es todo, su bin nuevamente será dos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ConditionalOnPuzzler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos </font></font><code>@ConditionalOnClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede haber clases de escritura. </font><font style="vertical-align: inherit;">Como ejemplo, considere la configuración de ejecución. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay jabón, hay una soga, nos colgamos en la horca. </font><font style="vertical-align: inherit;">Hay una silla y una corriente: es lógico poner a una persona en una silla. </font><font style="vertical-align: inherit;">Hay una guillotina y un buen humor, eso significa que necesitas cortar cabezas.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">  </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  c() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo vamos a ejecutar? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pregunta:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Cómo pueden </font></font><code>@ConditionalOnMissingClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funcionar las </font><font style="vertical-align: inherit;">anotaciones de tipo en general </font><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos que tengo un método que creará una horca. </font><font style="vertical-align: inherit;">Pero solo se debe crear un contenedor de horca si hay jabón y cuerda. </font><font style="vertical-align: inherit;">Pero no hay jabón. </font><font style="vertical-align: inherit;">¿Cómo puedo entender que no hay jabón o solo cuerda? </font><font style="vertical-align: inherit;">¿Qué sucede si intento leer anotaciones de un método, y estas anotaciones se refieren a clases que no lo son? </font><font style="vertical-align: inherit;">¿Puedo tomar esas anotaciones? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opciones de respuesta:</font></font></b> <br><ul><li> ClassDefNotFound?     ,    .     - ,  ClassDefNotFound  ,       reflection-    ,   conditional as long as; <br></li><li>   ,  .  reflection    .     ,  . <br></li><li>  ; <br></li><li>   . <br></li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> <b>:</b>  ,   .    reflection   .    exception,     ,        —    .   reflection?        ,      ,    ,    ,     —   <code>ClassDefNotFound</code> . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto funcionará usando ASM. </font><font style="vertical-align: inherit;">Al ver eso a través de la reflexión, nada en absoluto, Spring analizará el código de bytes, condicionalmente, manualmente. </font><font style="vertical-align: inherit;">Él lee el archivo para no descargarlo prematuramente, y entiende lo que hay allí </font></font><code>@Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con jabón, cuerda. </font><font style="vertical-align: inherit;">Ya puede verificar la presencia de estas clases en contexto por separado. </font><font style="vertical-align: inherit;">Pero ASM, como dicen, no se trata de velocidad. </font><font style="vertical-align: inherit;">Esta es una oportunidad para leer una clase sin cargarla y comprender la información del método. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero Juergen Hoeller recomienda no estar vinculado a los nombres de clase, prescribiendo condiciones, a pesar del hecho de que hay una anotación </font></font><code>OnMissingClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que puede tomar el nombre de clase (String) como parámetro. </font><font style="vertical-align: inherit;">Si sigue esta recomendación, todo funciona más rápido y no se necesita ASM. </font><font style="vertical-align: inherit;">Pero a juzgar por la fuente, nadie hace eso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ley del Hierro 1.5. </font><font style="vertical-align: inherit;">Enciende y apaga el cuervo</font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/eb6/9b9/b83/eb69b9b8361dcc9924dc843290af9af2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitábamos otra propiedad: la capacidad de habilitar o deshabilitar el cuervo manualmente. Para no enviar a nadie garantizado. Esta es la última condición que le mostramos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro entrante no da nada excepto un cuervo. Por lo tanto, puede preguntar, ¿por qué ser capaz de encenderlo / apagarlo, simplemente no puede tomarlo? Pero en la segunda parte, se incluirán cosas útiles adicionales en este iniciador. Específicamente, un cuervo puede no ser necesario: es costoso, se puede apagar. Al mismo tiempo, no es muy bueno quitar el punto final donde enviarlo, parece una muleta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, haremos todo a través </font></font><code>@ConditionalOnProperty(".")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y nos jura que esto no se puede hacer: anotación duplicada. </font><font style="vertical-align: inherit;">El problema es que si tenemos una anotación con algunos parámetros, no es repetible. </font><font style="vertical-align: inherit;">No podemos hacer esto en dos propiedades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos métodos para esta anotación, hay String y esta es una matriz; puede especificar varias propiedades allí.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>(OnPropertyCondition.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ConditionalOnProperty { String[] value() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> ""</span></span>; String[] name() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">havingValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> ""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchIfMissing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">false</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relaxedNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">true</span></span></span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y todo está bien, hasta que intente personalizar el valor de cada elemento de esta matriz por separado. </font><font style="vertical-align: inherit;">Tenemos una propiedad </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que debería ser </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y es otra propiedad, que debería tener </font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cierto valor. </font><font style="vertical-align: inherit;">Pero puede especificar solo un valor en todas las propiedades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, no puedes hacer esto:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>, havingValue=<span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,  havingValue=<span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,havingValue=<span class="hljs-string"><span class="hljs-string">"false"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IronBankApplicationListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>( name = {    <span class="hljs-string"><span class="hljs-string">"."</span></span>,    <span class="hljs-string"><span class="hljs-string">"."</span></span>,    <span class="hljs-string"><span class="hljs-string">"."</span></span> }, havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IronBankApplicationListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo resaltado aquí no es una matriz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay una perversión que le permite trabajar con varias propiedades, con un solo valor para ellas: </font></font><code>AllNestedConditions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>AnyNestedCondition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae2/7f1/0fe/ae27f10fea30542adc8340f98dc85887.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ve, francamente, extraño. </font><font style="vertical-align: inherit;">Pero funciona. </font><font style="vertical-align: inherit;">Vamos a tratar de hacer que la configuración - el nuevo kondishn, que será tomado en cuenta </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnRaven</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponemos nuestra anotación </font></font><code>@Conditional()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y aquí tenemos que registrar alguna clase.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>({OnRavenCondional.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> CondionalOnRaven { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nosotros lo creamos. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Además, tuvimos que implementar algún tipo de condicionamiento, pero es posible que no lo hagamos porque tenemos la siguiente anotación: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeCondition</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(  name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,  havingValue = <span class="hljs-string"><span class="hljs-string">"false"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenProperty</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(  name = <span class="hljs-string"><span class="hljs-string">".enabled"</span></span>,  havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span>,  matchIfMissing = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenEnabled</span></span></span><span class="hljs-class"> </span></span>{ } ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos uno compuesto </font></font><code>Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que también se heredará de otra clase, ya sea </font></font><code>AllNestedConditions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>AnyNestedCondition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y contendrá otras clases que contienen las anotaciones habituales con condimentos.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su lugar </font></font><code>@Condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debemos especificar:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, debe crear un constructor dentro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos que crear clases estáticas aquí. </font><font style="vertical-align: inherit;">Hacemos algún tipo de clase (llamémosla R).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> </span></span>{} }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacemos nuestro valor </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(debe ser exactamente </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(value= <span class="hljs-string"><span class="hljs-string">"."</span></span>, havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{} }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para repetir esto, solo recuerda el nombre de la clase. </font><font style="vertical-align: inherit;">Spring tiene buenos muelles Java. </font><font style="vertical-align: inherit;">Puede abandonar IDEA, leer el dock de Java y comprender lo que debe hacerse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosotros ponemos el nuestro </font></font><code>@ConditionalOnRaven</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En principio, puede ajustar ambos </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">, y </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero ahora no haremos esto. </font><font style="vertical-align: inherit;">Solo mira lo que pasó.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnRaven</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ausencia de un </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuervo no debe volar. </font><font style="vertical-align: inherit;">El no voló. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No quiero apostar </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque primero debemos hacer un autocompletado; este es uno de nuestros requisitos.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConfigurationalProperties</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> ; }</code> </pre><br>  Eso es todo. <code></code>   <code>false</code> ,  <code>true</code>  <br> application.yml: <br><br><pre> <code class="java hljs">jpa.hibernate.ddl-auto: validate ironbank: ---: -  : : ,   : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre><br> ,    . <br><br>                ,     repeatable.     Java.   . <br><br>    ,      ,        . <br><br><hr><br><br>  Minuto de publicidad. 19-20    Joker 2018,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«          [Joker Edition]»</a> ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«Micronaut vs Spring Boot,     ?»</a>  .  En general, habrá muchos más informes interesantes y notables en Joker.  Las entradas se pueden comprar en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web oficial de la</a> conferencia. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¡Y también tenemos una pequeña encuesta para ti! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424503/">https://habr.com/ru/post/es424503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424491/index.html">Mapas del hexágono de la unidad: asperezas, ríos y caminos</a></li>
<li><a href="../es424495/index.html">Google Chrome agregará la capacidad de rechazar la sincronización automática de perfiles al iniciar sesión en los servicios de la compañía *</a></li>
<li><a href="../es424497/index.html">Deja de sospechar de los desarrolladores de la impostura. Aprenda a entrevistar mejor</a></li>
<li><a href="../es424499/index.html">Bueno él, tu pentest</a></li>
<li><a href="../es424501/index.html">Terminales de diagnóstico para soldadores reales</a></li>
<li><a href="../es424505/index.html">"Tenemos ideas para Maven 4 e incluso Maven 5" - una entrevista con Robert Scholte, un participante clave en el proyecto Maven</a></li>
<li><a href="../es424507/index.html">VI Hackathon anual de JetBrains: Shiftius Altius Ctrlius</a></li>
<li><a href="../es424509/index.html">Trabajando con la API KOMPAS-3D → Lección 12 → Líneas compuestas</a></li>
<li><a href="../es424511/index.html">Herramientas para encontrar clases anotadas en Java</a></li>
<li><a href="../es424513/index.html">Sobre centros de datos baratos, protección ILV y DDoS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>