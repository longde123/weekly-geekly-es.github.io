<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçß üëäüèΩ üë©üèæ‚Äçüéì Qt-Wrapper um das gRPC-Framework in C ++ üôçüèª ‚¨úÔ∏è ü§•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Heute werden wir uns ansehen, wie Sie das gRPC-Framework in C ++ und die Qt-Bibliothek verkn√ºpfen k√∂nnen. Der Artikel enth√§lt Code, der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt-Wrapper um das gRPC-Framework in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p>  Hallo an alle.  Heute werden wir uns ansehen, wie Sie das gRPC-Framework in C ++ und die Qt-Bibliothek verkn√ºpfen k√∂nnen.  Der Artikel enth√§lt Code, der die Verwendung aller vier Interaktionsmodi in gRPC zusammenfasst.  Zus√§tzlich wird ein Code bereitgestellt, der die Verwendung von gRPC √ºber Qt-Signale und -Slots erm√∂glicht.  Der Artikel kann vor allem f√ºr Qt-Entwickler von Interesse sein, die an der Verwendung von gRPC interessiert sind.  Trotzdem wird eine Verallgemeinerung der vier Betriebsmodi von gRPC in C ++ ohne Verwendung von Qt geschrieben, wodurch Entwickler, die nicht mit Qt verwandt sind, den Code anpassen k√∂nnen.  Ich frage alle Interessierten unter Katze. </p><a name="habracut"></a><br><h2>  Hintergrund </h2><br><p>  Vor ungef√§hr sechs Monaten hingen zwei Projekte an mir, die die Client- und Serverteile von gRPC verwendeten.  Beide Projekte gingen in Produktion.  Diese Projekte wurden von Entwicklern geschrieben, die bereits gek√ºndigt haben.  Die einzige gute Nachricht war, dass ich mich aktiv am Schreiben des gRPC-Server- und Client-Codes beteiligt habe.  Aber das war vor ungef√§hr einem Jahr.  Deshalb musste ich mich wie immer von Grund auf um alles k√ºmmern. </p><br><p>  Der gRPC-Servercode wurde mit der Erwartung geschrieben, dass er von der .proto-Datei weiter generiert wird.  Der Code wurde gut geschrieben.  Der Server hatte jedoch einen gro√üen Nachteil: Nur ein Client konnte eine Verbindung herstellen. </p><br><p>  Der gRPC-Client wurde einfach schrecklich geschrieben. </p><br><p>  Nur wenige Tage sp√§ter fand ich den Client- und Servercode gRPC heraus.  Und mir wurde klar, dass ich mich erneut mit dem Server und dem gRPC-Client befassen m√ºsste, wenn ich ein Projekt f√ºr ein paar Wochen aufnehmen w√ºrde. </p><br><p>  Damals entschied ich, dass es Zeit war, den gRPC-Client und -Server zu schreiben und zu debuggen, damit: </p><br><ul><li><p>  Sie konnten nachts ruhig schlafen; </p></li><li><p>  Sie mussten sich nicht jedes Mal daran erinnern, wie dies funktioniert, wenn Sie einen Client oder einen gRPC-Server schreiben m√ºssen. </p></li><li><p>  Sie k√∂nnen den geschriebenen gRPC-Client und -Server in anderen Projekten verwenden. </p></li></ul><br><p>  Beim Schreiben von Code habe ich mich an folgenden Anforderungen orientiert: </p><br><ul><li><p>  Sowohl der gRPC-Client als auch der Server k√∂nnen auf nat√ºrliche Weise mit den Signalen und Slots der Qt-Bibliothek arbeiten. </p></li><li><p>  Der gRPC-Client- und Servercode muss beim √Ñndern der .proto-Datei nicht repariert werden. </p></li><li><p>  Der gRPC-Client sollte dem Clientcode den Status der Verbindung zum Server mitteilen k√∂nnen. </p></li></ul><br><p>  Die Struktur des Artikels ist wie folgt.  Zun√§chst wird ein kurzer √úberblick √ºber die Ergebnisse der Arbeit mit Client-Code und eine kleine Erkl√§rung dazu gegeben.  Am Ende der √úberpr√ºfung ein Link zum Repository.  Weiterhin wird es allgemeine Dinge zur Architektur geben.  Dann eine Beschreibung des Server- und Client-Codes (was sich unter der Haube befindet) und eine Schlussfolgerung. </p><br><h2>  Kurzer R√ºckblick </h2><br><p>  Die einfachste pingproto.proto-Datei wurde als .proto-Datei verwendet, in der RPCs aller Arten von Interaktionen definiert wurden: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Die Datei pingpong.proto wiederholt die Datei helloworld.proto aus dem Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asynchrone gRPC-Modi in C ++</a> bis zum genauen Namen. </p><br><p>  Infolgedessen kann ein geschriebener Server wie folgt verwendet werden: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  Wenn ein Client RPC aufruft, benachrichtigt der gRPC-Server den Clientcode (in diesem Fall Klasse A) mit dem entsprechenden Signal. </p><br><p>  Der gRPC-Client kann folgenderma√üen verwendet werden: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  Mit dem gRPC-Client k√∂nnen Sie RPC direkt aufrufen und die Antwort des Servers mit den entsprechenden Signalen abonnieren. </p><br><p>  Der gRPC-Client hat auch ein Signal: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  Hiermit werden vergangene und aktuelle Serververbindungsstatus gemeldet.  Der gesamte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielcode</a> befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qgrpc-Repository</a> . <br><br><h2>  Wie funktioniert es? </h2><br><p>  Das Prinzip der Einbeziehung des Clients und des gRPC-Servers in das Projekt ist in der Abbildung dargestellt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  In der .pro-Projektdatei werden .proto-Dateien angegeben, auf deren Grundlage gRPC funktioniert.  Die Datei grpc.pri enth√§lt Befehle zum Generieren von gRPC- und QgRPC-Dateien.  Der Protoc-Compiler generiert gRPC-Dateien [protofile] .grpc.pb.h und [protofile] .grpc.pb.cc.  [protofile] ist der Name der .proto-Datei, die an die Compiler-Eingabe √ºbergeben wird. </p><br><p>  Die Generierung von QgRPC-Dateien [protofile] .qgrpc. [Config] .h wird vom Skript genQGrpc.py √ºbernommen.  [config] ist entweder "Server" oder "Client". <br><br>  Die generierten QgRPC-Dateien enthalten einen Qt-Wrapper um gRPC-Klassen und Aufrufe mit entsprechenden Signalen.  In den vorherigen Beispielen wurden die Klassen QpingServerService und QpingClientService in den generierten Dateien pingpong.qgrpc.server.h und pingpong.qgrpc.client.h deklariert.  Generierte QgRPC-Dateien werden der MOC-Verarbeitung hinzugef√ºgt. </p><br><p>  In den generierten QgRPC-Dateien sind die QGrpc [config] .h-Dateien enthalten, in denen alle Hauptarbeiten stattfinden.  Lesen Sie weiter unten mehr dar√ºber. </p><br><p>  Um all diese Konstruktionen mit dem Projekt zu verbinden, m√ºssen Sie die Datei grpc.pri in die Projekt-Pro-Datei aufnehmen und drei Variablen angeben.  Die GRPC-Variable definiert .proto-Dateien, die an die Eingaben des Protoc-Compilers und des Skripts genQGrpc.py √ºbertragen werden.  Die Variable QGRPC_CONFIG definiert den Konfigurationswert der generierten QgRPC-Dateien und kann die Werte "Server" oder "Client" enthalten.  Sie k√∂nnen auch die optionale Variable GRPC_VERSION definieren, um die Version von gRPC anzugeben. </p><br><p>  Weitere Informationen zu allem Gesagten finden Sie in den Beispieldateien grpc.pri und .pro. </p><br><h2>  Serverarchitektur </h2><br><p>  Das Serverklassendiagramm ist in der Abbildung dargestellt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  Die dicken Pfeile zeigen die Hierarchie der Klassenvererbung und die d√ºnnen Pfeile zeigen die Zugeh√∂rigkeit von Mitgliedern und Methoden zu Klassen.  Im Allgemeinen wird die ServerService-Klasse Q [Dienstname] f√ºr den Dienst generiert, wobei Dienstname der Name des in der .proto-Datei deklarierten Dienstes ist.  RPCCallData sind Kontrollstrukturen, die f√ºr jeden RPC im Service generiert werden.  Im Konstruktor der QpingServerService-Klasse wird die Basisklasse QGrpcServerService mit dem asynchronen Dienst gRPC pingpong :: ping :: AsyncService initialisiert.  Um den Dienst zu starten, m√ºssen Sie die Start () -Methode mit der Adresse und dem Port aufrufen, auf dem der Dienst ausgef√ºhrt wird.  Die Funktion Start () implementiert die Standardprozedur zum Starten eines Dienstes. </p><br><p>  Am Ende der Funktion Start () wird die reine virtuelle Funktion makeRequests () aufgerufen, die in der generierten Klasse QpingServerService implementiert ist: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  Der zweite Vorlagenparameter der Funktion needAnotherCallData sind die generierten RPCCallData-Strukturen.  Die gleichen Strukturen sind die Parameter der Signale in der erzeugten Qt-Klasse des Dienstes. </p><br><p>  Die generierten RPCCallData-Strukturen erben von der ServerCallData-Klasse.  Die ServerCallData-Klasse wird wiederum vom ServerResponder-Responder geerbt.  Die Schaffung eines Objekts mit koh√§renten Strukturen f√ºhrt somit zur Schaffung eines Antwortobjekts. </p><br><p>  Der Konstruktor f√ºr die ServerCallData-Klasse akzeptiert zwei Parameter: signal_func und request_func.  signal_func ist ein generiertes Signal, das nach dem Empfang eines Tags aus der Warteschlange aufgerufen wird.  request_func ist eine Funktion, die beim Erstellen eines neuen Responders aufgerufen werden sollte.  In diesem Fall kann es sich beispielsweise um die Funktion RequestSayHello () handeln.  Der Aufruf request_func erfolgt in der Funktion needAnotherCallData ().  Dies erfolgt so, dass die Verwaltung der Befragten (Erstellung und L√∂schung) im Dienst erfolgt. </p><br><p>  Der Code der Funktion needAnotherCallData () besteht aus dem Erstellen eines Responderobjekts und dem Aufrufen einer Funktion, die den Responder mit einem RPC-Aufruf verbindet: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  Die RequestRPC () -Funktionen sind Vorlagenfunktionen f√ºr vier Arten von Interaktionen.  Infolgedessen f√ºhrt der Aufruf von RequestRPC () zu einem Aufruf: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  Dabei ist service_ der gRPC-Dienst.  In diesem Fall handelt es sich um pingpong :: ping :: AsyncService. </p><br><p>  Um die Ereigniswarteschlange synchron oder asynchron zu √ºberpr√ºfen, m√ºssen Sie die Funktionen CheckCQ () bzw. AsyncCheckCQ () aufrufen.  Der Code der CheckCQ () - Funktion besteht aus Aufrufen des synchronen Tags aus der Warteschlange und der Verarbeitung dieses Tags: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  Nach dem Empfang des Tags aus der Warteschlange werden die G√ºltigkeit des Tags und der Serverstart √ºberpr√ºft.  Wenn der Server ausgeschaltet ist, wird das Tag nicht mehr ben√∂tigt - es kann gel√∂scht werden.  Danach hei√üt die in der ServerCallData-Klasse definierte Funktion cqReaction (): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  Das Flag first_time_reaction_ gibt an, dass Sie einen neuen Responder f√ºr den aufgerufenen RPC erstellen m√ºssen.  Die Funktionen CouldBeDeleted () und ProcessEvent () werden von der entsprechenden ServerResponder-Responderklasse geerbt.  Die Funktion CouldBeDeleted () gibt ein Zeichen zur√ºck, dass das Responder-Objekt gel√∂scht werden kann.  Die Funktion processEvent () verarbeitet das Tag- und das OK-Flag.  F√ºr einen Responder vom Typ Client-Streaming sieht die Funktion beispielsweise folgenderma√üen aus: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Die ProcessEvent () -Funktion gibt unabh√§ngig vom Typ des Responders immer true zur√ºck.  Der R√ºckgabewert dieser Funktion bleibt f√ºr eine m√∂gliche Erweiterung der Funktionalit√§t und theoretisch zur Beseitigung von Fehlern √ºbrig. </p><br><p>  Nach der Verarbeitung des Ereignisses folgt der Aufruf: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  Die Variable service_ ist eine Instanz des generierten Dienstes, in unserem Fall QpingServerService.  Die Variable signal_func_ ist ein Dienstsignal, das einem bestimmten RPC entspricht.  Zum Beispiel SayHelloRequest ().  Die Variable genRpcCallData ist ein Responderobjekt des entsprechenden Typs.  Aus Sicht des aufrufenden Codes ist die Variable genRpcCallData ein Objekt einer der generierten RPCCallData-Strukturen. <br></p><br><h2>  Kundenarchitektur </h2><br><p>  Wann immer m√∂glich, stimmen die Namen der Klassen und Funktionen des Clients mit den Namen der Klassen und Funktionen des Servers √ºberein.  Das Clientklassendiagramm ist in der Abbildung dargestellt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  Die dicken Pfeile zeigen die Hierarchie der Klassenvererbung und die d√ºnnen Pfeile zeigen die Zugeh√∂rigkeit von Mitgliedern und Methoden zu Klassen.  Im Allgemeinen wird f√ºr den Dienst die ClientService-Klasse Q [Dienstname] generiert, wobei Dienstname der Name des in der .proto-Datei deklarierten Dienstes ist.  RPCCallData sind Kontrollstrukturen, die f√ºr jeden RPC im Service generiert werden.  Um einen RPC aufzurufen, stellt die generierte Klasse Funktionen bereit, deren Namen genau mit dem in der .proto-Datei deklarierten RPC √ºbereinstimmen.  In unserem Beispiel wird SayHello () in der .proto-RPC-Datei wie folgt deklariert: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  In der generierten QpingClientService-Klasse sieht die entsprechende RPC-Funktion folgenderma√üen aus: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  Die generierten RPCCallData-Strukturen werden wie im Fall des Servers letztendlich von der ClientResponder-Klasse geerbt.  Daher f√ºhrt die Erstellung eines Objekts der generierten Struktur zur Erstellung eines Responders.  Nach dem Erstellen des Responders wird der RPC aufgerufen und der Responder dem Ereignis zugeordnet, bei dem eine Antwort vom Server empfangen wird.  In Bezug auf den Clientcode sieht ein RPC-Aufruf folgenderma√üen aus: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  Im Gegensatz zur generierten QpingServerService-Serverklasse erbt die QpingClientService-Klasse von zwei Vorlagenklassen: ConnectivityFeatures und MonitorFeatures. </p><br><p>  Die ConnectivityFeatures-Klasse ist f√ºr den Status der Client-Server-Verbindung verantwortlich und bietet drei zu verwendende Funktionen: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  Die Funktion grpc_disconnect () entfernt einfach alle Datenstrukturen, die f√ºr die Interaktion mit dem Server verantwortlich sind.  Der Aufruf von grpc_connect reduziert sich auf Aufrufe der Funktion grpc_connect_ (), mit der Steuerdatenstrukturen erstellt werden: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  Die ChannelFeatures-Klasse √ºberwacht den Status der <em>channel_</em> channel-Kommunikation mit dem Server.  Die ConnectivityFeatures-Klasse kapselt ein Objekt der ChannelFeatures-Klasse und implementiert die abstrakten Funktionen channelState (), checkChannelState () und connection () unter Verwendung dieses Objekts.  Die Funktion channelState () gibt den zuletzt beobachteten Status des Kommunikationskanals mit dem Server zur√ºck.  Die Funktion checkChannelState () gibt tats√§chlich den aktuellen Status des Kanals zur√ºck.  Die Funktion linked () gibt das Vorzeichen des Clients zur√ºck, der eine Verbindung zum Server herstellt. <br></p><br><p>  Die MonitorFeatures-Klasse ist f√ºr den Empfang und die Verarbeitung von Ereignissen vom Server verantwortlich und stellt die CheckCQ () -Funktion zur Verwendung bereit: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Die Codestruktur ist dieselbe wie im Fall des Servers.  Im Gegensatz zum Server wird dem Client ein Codeblock hinzugef√ºgt, der f√ºr die Verarbeitung des aktuellen Status verantwortlich ist.  Wenn sich der Status des Kommunikationskanals ge√§ndert hat, wird das Signal channelStateChangedSignal_ () aufgerufen.  Bei allen generierten Diensten ist dies ein Signal: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Im Gegensatz zum Server wird hier anstelle von Next () auch die Funktion AsyncNext () verwendet.  Dies wurde aus mehreren Gr√ºnden getan.  Erstens kann der Clientcode bei Verwendung von AsyncNext () Informationen √ºber die √Ñnderung des Status des Kommunikationskanals erhalten.  Zweitens ist es bei Verwendung von AsyncNext () m√∂glich, verschiedene RPCs im Client-Code beliebig oft aufzurufen.  Wenn Sie in diesem Fall die Funktion Next () verwenden, wird der Thread blockiert, bis ein Ereignis aus der Warteschlange empfangen wird, und dadurch werden die beiden beschriebenen Funktionen verloren. <br><br><p>  Nach dem Empfang des Ereignisses aus der Warteschlange wird wie im Fall des Servers die in der ClientCallData-Klasse definierte Funktion cqReaction () aufgerufen: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  Wie beim Server verarbeitet die Funktion processEvent () das Tag- und das OK-Flag und gibt immer true zur√ºck.  Wie im Fall des Servers sollte nach der Verarbeitung des Ereignisses das Signal des generierten Dienstes aufgerufen werden.  Es gibt jedoch zwei signifikante Unterschiede zur gleichnamigen Serverfunktion.  Der erste Unterschied besteht darin, dass in dieser Funktion keine Responder erstellt werden.  Die Erstellung von Respondern erfolgt wie oben gezeigt, wenn der RPC aufgerufen wird.  Der zweite Unterschied besteht darin, dass Responder in dieser Funktion nicht gel√∂scht werden.  Das Fehlen der Entfernung von Respondern erfolgt aus zwei Gr√ºnden.  Erstens kann Client-Code Zeiger verwenden, um RPCCallData-Strukturen f√ºr ihre eigenen Zwecke zu generieren.  Das L√∂schen von Inhalten mit diesem Zeiger, die im Clientcode verborgen sind, kann zu unangenehmen Konsequenzen f√ºhren.  Zweitens f√ºhrt das Entfernen des Responders dazu, dass kein Signal mit Daten erzeugt wird.  Daher empf√§ngt der Clientcode nicht die letzte Servernachricht.  Unter mehreren Alternativen zur L√∂sung der angegebenen Probleme wurde die Entscheidung getroffen, das Entfernen des Responders (generierte Strukturen) auf den Client-Code zu verschieben.  Daher m√ºssen die Signalhandlerfunktionen (Slots) den folgenden Code enthalten: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  Das Fehlen des Entfernens des Responders im Client-Code f√ºhrt nicht nur zu einem Speicherverlust, sondern auch zu m√∂glichen Problemen mit dem Kommunikationskanal.  Signalhandler aller Arten von RPC-Interaktionen sind im Beispielcode implementiert. </p><br><h2>  Fazit </h2><br><p>  Abschlie√üend machen wir auf zwei Punkte aufmerksam.  Der erste Punkt bezieht sich auf den Aufruf der CheckCQ () - Funktionen des Clients und des Servers.  Sie funktionieren wie oben gezeigt nach einem Prinzip: Wenn sich ein Ereignis in der Warteschlange befindet, wird ein Signal mit der entsprechenden generierten RPCCallData-Struktur "emittiert".  Sie k√∂nnen diese Funktion manuell aufrufen und (im Fall eines Clients) nach einem Ereignis suchen.  Zun√§chst bestand jedoch die Idee, den gesamten mit gRPC verkn√ºpften Netzwerkteil auf einen anderen Thread zu √ºbertragen.  Zu diesem Zweck wurden die Hilfsklassen QGrpcSrvMonitor f√ºr den gRPC-Server und QGrpcCliServer f√ºr den gRPC-Client geschrieben.  Beide Klassen arbeiten nach demselben Prinzip: Sie erstellen einen separaten Stream, f√ºgen den generierten Service in diesen Stream ein und rufen regelm√§√üig die CheckCQ () - Funktion dieses Service auf.  Wenn Sie beide Hilfsklassen verwenden, m√ºssen Sie daher keine CheckCQ () -Funktionen im Clientcode aufrufen.  Die Signale des generierten Dienstes "kommen" in diesem Fall von einem anderen Stream.  Client- und Serverbeispiele werden mithilfe dieser Hilfsklassen implementiert. </p><br><p>  Der zweite Punkt betrifft die Mehrheit der Entwickler, die die Qt-Bibliothek in ihrer Arbeit nicht verwenden.  Qt-Klassen und Makros in QgRPC werden nur an zwei Stellen verwendet: in generierten Servicedateien und in Dateien, die Zusatzklassen enthalten: QGrpcServerMonitor.h und QGrpcClientMonitor.h.  Die verbleibenden Dateien mit der Qt-Bibliothek sind in keiner Weise zugeordnet.  Es war geplant, Assembly mit cmake hinzuzuf√ºgen und einige Qt-Anweisungen zu stubben.  Insbesondere die QObject-Klasse und das Q_OBJECT-Makro.  Aber die H√§nde kamen einfach nicht dazu.  Vorschl√§ge sind daher willkommen. </p><br><p>  Das ist alles.  Danke an alle! </p><br><h2>  Referenzen </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository mit QgRPC-Code</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchroner gRPC in C ++</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420237/">https://habr.com/ru/post/de420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420225/index.html">Unendliche algorithmische Melodie basierend auf Primzahlen</a></li>
<li><a href="../de420227/index.html">Der t√ºrkische Pr√§sident gibt ein Verbot des US-Imports von Elektronik bekannt</a></li>
<li><a href="../de420229/index.html">K√∂nnen Kinder in den D√∂rfern Programmierer werden, wenn sie in der N√§he nur Eisenbahnarbeiter unterrichten? Gespr√§ch mit dem "Kreis"</a></li>
<li><a href="../de420233/index.html">UE4 | Ausr√ºstung f√ºr den Mehrspielermodus # 5 | Informations√ºbertragung zwischen Server und Client</a></li>
<li><a href="../de420235/index.html">Zenject: Wie ein IoC-Container die Abh√§ngigkeitsinjektion f√ºr Ihr Projekt beenden kann</a></li>
<li><a href="../de420239/index.html">Mobile Entwicklung. Swift: das Geheimnis der Protokolle</a></li>
<li><a href="../de420243/index.html">Durchbruch Philanthropie: Humanit√§re Durchbruchsprojekte</a></li>
<li><a href="../de420245/index.html">So verhindern Sie einen Speicher√ºberlauf bei Verwendung von Java-Sammlungen</a></li>
<li><a href="../de420251/index.html">Apple behauptet, dass der Hauptsitzkomplex des Unternehmens nur 200 US-Dollar kostet</a></li>
<li><a href="../de420253/index.html">Wie offene Banking-APIs die Finanzwelt ver√§ndern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>