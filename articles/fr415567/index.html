<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçú üéõÔ∏è üôáüèæ Diffusez de la vid√©o h264 sans transcodage √† partir d'une cam√©ra Logitech C920 üôÖüèΩ üôè üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le retard n'√©tait pas sup√©rieur √† 0,3 seconde, √©tant donn√© que la cam√©ra est connect√©e √† un BeagleBone Blue faible avec une charge de processeur ne d√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Diffusez de la vid√©o h264 sans transcodage √† partir d'une cam√©ra Logitech C920</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415567/"><img src="https://habrastorage.org/webt/dc/by/xs/dcbyxsicqllz2-jksmikcesodlu.jpeg"><br><br>  Le retard n'√©tait pas sup√©rieur √† 0,3 seconde, √©tant donn√© que la cam√©ra est connect√©e √† un BeagleBone Blue faible avec une charge de processeur ne d√©passant pas 30% et que le flux vid√©o est transmis via un routeur wifi √† un ordinateur portable. <br><a name="habracut"></a><br>  Initialement, la t√¢che consistait √† diffuser la vid√©o du robot vers un grand ordinateur sans charger le processeur sur le robot et sans retards.  Dans le processus de recherche de cam√©ras et de programmes pour cette t√¢che, il a √©t√© constat√© qu'il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cam√©ras avec un codage vid√©o mat√©riel sur la cam√©ra elle</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√™me</a> , apr√®s quoi la cam√©ra Logitech C920 a √©t√© achet√©e.  Et des tests et exp√©riences ont commenc√©, au cours desquels deux options de traduction ont √©t√© trouv√©es sans transcodage. <br><br>  Toutes les autres actions sont v√©rifi√©es sur Ubuntu 16.04, la deuxi√®me option fonctionne probablement sur Windows <br><br><h3>  Diffuser de la vid√©o cod√©e par mat√©riel √† partir d'une cam√©ra Logitech C920 via cvlc et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v4l2</a> </h3><br>  clvc - serveur de diffusion vid√©o via vlc √† partir de la ligne de commande. <br><br><h4>  Encodage mat√©riel d'un flux vid√©o </h4><br>  R√©glez les cam√©ras au format pixel sur H264 <br><br><pre><code class="bash hljs">v4l2-ctl --device=/dev/video1 --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-fmt-video=width=800,height=600,pixelformat=1</code> </pre> <br>  Testez H264 avec vlc, il ne r√©initialisera donc pas les param√®tres: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1 --demux h264</code> </pre> <br>  Si vous essayez ceci, vlc r√©initialisera les param√®tres avant de jouer: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264</code> </pre> <br>  La lecture fonctionne.  Nous obtenons le flux H264 de la cam√©ra.  Passons maintenant sur le r√©seau via HTTP: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264:width=800:height=600 --sout <span class="hljs-string"><span class="hljs-string">'#standard{access=http,mux=ts,dst=localhost:8080,name=stream,mime=video/ts}'</span></span> -vvv</code> </pre> <br>  (sur le r√©seau, vous devez utiliser l'adresse IP de votre appareil local au lieu de localhost) <br><br>  Lancement du r√©cepteur: <br><br><pre> <code class="bash hljs">mplayer http://localhost:8080/</code> </pre> <br>  Il s'av√®re que MPEG-TS permet √† mplayer de se connecter au flux √† tout moment avec un l√©ger retard (probablement en attente d'une image cl√© ou de qch). <br><br>  Si vous utilisez mux = avi, mime = video / avi, vous devez ex√©cuter mplayer au moment o√π vous d√©marrez vlc, sinon mplayer ne commencera pas √† jouer. <br><br><h4>  Erreur Ffmpeg </h4><br><ul><li>  Si vous essayez ffmpeg au lieu de vlc pour jouer, vous rencontrerez probablement ce probl√®me: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ffmpeg.org/trac/ffmpeg/ticket/1387</a> </li><li>  D√®s que vous ex√©cutez ffmpeg, il passera √† ¬´Vid√©o: rawvideo (YUY2 / 0x32595559)¬ª </li><li>  Bien qu'il accepte MJPEG, il ne fonctionnera pas avec H.264 </li><li>  La m√™me chose se produit lors de l'utilisation de qv4l2: le d√©marrage de la capture en mode H264 vous donne en fait la fen√™tre vid√©o YUY2 </li></ul><br><h4>  Lire la vid√©o d√©cod√©e par le mat√©riel </h4><br>  Mplayer est capable de jouer au framebuffer, assurez-vous que X ne fonctionne pas et entrez: <br><br><pre> <code class="bash hljs">mplayer http://192.168.1.100:8080/ -fs -framedrop -vo fbdev</code> </pre> <br>  Vous pouvez √©galement jouer dans la fen√™tre X si vous le souhaitez: ex√©cutez X √† partir de la ligne de commande: <br><br><pre> <code class="bash hljs">Xorg -retro &amp;&gt; /dev/zero</code> </pre> <br>  Il y a des tonnes de messages d'erreur fbdev que nous d√©posons silencieusement dans / dev / zero <br><br>  Lire un flux vid√©o √† partir d'une source LAN vlc (voir la section ci-dessus): <br><br><pre> <code class="bash hljs">DISPLAY=<span class="hljs-string"><span class="hljs-string">":0"</span></span> mplayer http://192.168.1.100:8080/ -fs -framedrop</code> </pre> <br><ul><li>  Si nous le faisons, nous remarquerons que nous n'utilisons pas encore Xvideo ou toute acc√©l√©ration mat√©rielle </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">linux-sunxi.org/CedarX</a> semble nous fournir une biblioth√®que VPU, qui est malheureusement une chose peu s√ªre pour Allwinner </li><li>  Mais il existe un VLC pirat√© qui peut l'utiliser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">linux-sunxi.org/VLC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compil√© avec succ√®s</a> </li></ul><br><h4>  Raspberry pi </h4><br>  Si vous rencontrez des artefacts dans l'image et que les flux provenant de Raspberry Pi utilisent: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video0:chroma=h264 ...</code> </pre> <br>  Vous devrez peut-√™tre mettre √† jour le firmware: <br><br><pre> <code class="bash hljs">apt-get install rpi-update raspi-config rpi-update reboot</code> </pre> <br><h4>  R√©sum√© de la diffusion via cvlc et v4l2 </h4><br>  Les tests ont montr√© que la charge du processeur sur Beaglebone Blue ne d√©passe pas 30%, ce qui est tr√®s bon pour un processeur faible, mais il n'est pas clair comment pousser ensuite cette vid√©o dans ROS. <br><br>  Si la bande passante wifi n'est pas suffisante, le retard vid√©o augmente consid√©rablement, en th√©orie cela peut √™tre r√©solu en passant de tcp √† udp, la documentation cvlc mentionne la possibilit√© de diffuser via udp. <br><br><h3>  Diffuser du mat√©riel vid√©o encod√© √† partir d'une cam√©ra Logitech C920 via Gstreamer </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article de d√©veloppeur original prenant en charge cette m√©thode dans Gstreamer.</a> <br>  Installer gstreamer sur Ubuntu 16.04 <br><br><pre> <code class="bash hljs">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools sudo apt-get install libgstreamer-plugins-base1.0-dev</code> </pre> <br><h4>  La source uvch264src vous permet de: </h4><br><ul><li>  Capturez simultan√©ment un flux vid√©o cod√© mat√©riel H264 et un flux vid√©o sur chenilles. </li><li>  Configurer l'encodage vid√©o mat√©riel (bitrate, images cl√©s et plus) </li></ul><br>  La source du viseur secondaire est un concept int√©ressant.  En plus du flux principal H.264, vous obtenez un flux secondaire basse r√©solution au format MJPG ou YUV.  Je ne sais pas s'il s'agit d'une fonctionnalit√© de la cam√©ra, du pilote ou du bloc source gstreamer, mais j'esp√®re que cela sera utile pour nos cam√©ras Beaglebone, √† condition que la fonction n'utilise pas un processeur trop grand pour convertir entre raw et jpg. <br><br>  Voici un exemple de pipeline qui affiche un flux H.264 haute r√©solution et un flux viseur: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Le flux principal H.264 est d√©cod√© √† l'aide du bloc avdec_h264, accessible via le package gst-libav, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir les notes sur le wiki oz9aec</a> .  Le panneau du viseur peut √™tre connect√© au fakelink s'il n'est pas n√©cessaire, mais je ne pense pas qu'il puisse √™tre d√©sactiv√© (vous pouvez toujours le d√©sactiver).  C'est du moins l'impression que je lis le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">billet de blog KaKaRoTo</a> original. <br><br>  Vous serez probablement surcharg√© lorsque vous verrez un grand nombre de param√®tres pouvant √™tre configur√©s pour ce bloc source: <br><br><pre> <code class="bash hljs">gst-inspect-1.0 uvch264src</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Liste des param√®tres uvch264src</b> <div class="spoiler_text">  D√©tails d'usine: <br>  Aucun (0) <br>  Nom UVC H264 de longue date <br>  Source / vid√©o Klass <br>  Description UVC H264 Source de cam√©ra d'encodage <br>  Auteur Youness Alaoui &lt;youness.alaoui@collabora.co.uk&gt; <br><br>  D√©tails du plugin: <br>  Nom uvch264 <br>  Description Plugin des cam√©ras d'encodage H264 conforme UVC <br>  Nom de fichier /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstuvch264.so <br>  Version 1.8.3 <br>  Licence LGPL <br>  Module source gst-plugins-bad <br>  Date de sortie de la source 2016-08-19 <br>  Package binaire GStreamer Bad Plugins (Ubuntu) <br>  URL d'origine <a href="">launchpad.net/distros/ubuntu/+source/gst-plugins-bad1.0</a> <br><br>  GObject <br>  + ---- GInitiallyUnown <br>  + ---- GstObject <br>  + ---- GstElement <br>  + ---- GstBin <br>  + ---- GstBaseCameraSrc <br>  + ---- GstUvcH264Src <br><br>  Interfaces impl√©ment√©es: <br>  Gstchildproxy <br><br>  Mod√®les de pads: <br>  Mod√®le SRC: 'vidsrc' <br>  Disponibilit√©: Toujours <br>  Capacit√©s: <br>  vid√©o / x-raw <br>  format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV16 , NV61, NV24, GREY8, GRAY16_BE, GRAY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_10LE, I420_22_10410 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  largeur: [1, 2147483647] <br>  hauteur: [1, 2147483647] <br>  cadence d'images: [0/1, 2147483647/1] <br>  image / jpeg <br>  largeur: [1, 2147483647] <br>  hauteur: [1, 2147483647] <br>  cadence d'images: [0/1, 2147483647/1] <br>  vid√©o / x-h264 <br>  largeur: [1, 2147483647] <br>  hauteur: [1, 2147483647] <br>  cadence d'images: [0/1, 2147483647/1] <br>  format de flux: {byte-stream, avc} <br>  alignement: au <br>  profil: {√©lev√©, principal, ligne de base, ligne de base contrainte} <br><br>  Mod√®le SRC: ¬´imgsrc¬ª <br>  Disponibilit√©: Toujours <br>  Capacit√©s: <br>  VIDE <br><br>  Mod√®le SRC: 'vfsrc' <br>  Disponibilit√©: Toujours <br>  Capacit√©s: <br>  vid√©o / x-raw <br>  format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV16 , NV61, NV24, GREY8, GRAY16_BE, GRAY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_10LE, I420_22_10410 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  largeur: [1, 2147483647] <br>  hauteur: [1, 2147483647] <br>  cadence d'images: [0/1, 2147483647/1] <br>  image / jpeg <br>  largeur: [1, 2147483647] <br>  hauteur: [1, 2147483647] <br>  cadence d'images: [0/1, 2147483647/1] <br><br>  Drapeaux d'√©l√©ment: <br>  aucun jeu de drapeaux <br><br>  Indicateurs de bac: <br>  aucun jeu de drapeaux <br><br>  Mise en ≈ìuvre de l'√©l√©ment: <br>  A la fonction change_state (): 0x7ff438f22ba0 <br><br>  L'√©l√©ment n'a aucune capacit√© de synchronisation. <br>  L'√©l√©ment n'a aucune capacit√© de gestion d'URI. <br><br>  Tampons: <br>  Src: 'vfsrc' <br>  Src: ¬´imgsrc¬ª <br>  SRC: ¬´vidsrc¬ª <br><br>  Propri√©t√©s des √©l√©ments: <br>  name: le nom de l'objet <br>  drapeaux: lire, √©crire <br>  String  Par d√©faut: "uvch264src0" <br>  parent: parent de l'objet <br>  drapeaux: lire, √©crire <br>  Objet de type "GstObject" <br>  gestion asynchrone: le bac g√©rera les changements d'√©tat asynchrones <br>  drapeaux: lire, √©crire <br>  Bool√©en.  Par d√©faut: faux <br>  message-forward: transf√®re tous les messages enfants <br>  drapeaux: lire, √©crire <br>  Bool√©en.  Par d√©faut: faux <br>  mode: Le mode de capture (capture d'images fixes ou enregistrement vid√©o) <br>  drapeaux: lire, √©crire <br>  Enum "GstCameraBin2Mode" Par d√©faut: 2, "mode-video" <br>  (1): mode-image - Capture d'images fixes (par d√©faut) <br>  (2): mode-vid√©o - Enregistrement vid√©o <br>  zoom: facteur de zoom num√©rique (par exemple 1,5 signifie 1,5x) <br>  drapeaux: lire, √©crire <br>  Flotter.  Plage: 1 - 3.402823e + 38 Par d√©faut: 1 <br>  zoom max: facteur de zoom num√©rique (par exemple 1,5 signifie 1,5x) <br>  drapeaux: lisibles <br>  Flotter.  Plage: 1 - 3.402823e + 38 Par d√©faut: 10 <br>  ready-for-capture: informe que cet √©l√©ment est pr√™t √† d√©marrer une autre capture <br>  drapeaux: lisibles <br>  Bool√©en.  Par d√©faut: vrai <br>  post-aper√ßus: si des images d'aper√ßu de capture doivent √™tre publi√©es sur le bus <br>  drapeaux: lire, √©crire <br>  Bool√©en.  Par d√©faut: vrai <br>  preview-caps: les majuscules de l'image d'aper√ßu √† publier (NULL signifie TOUT) <br>  drapeaux: lire, √©crire <br>  TOUT <br><br>  preview-filter: Un filtre d'aper√ßu personnalis√© pour traiter les donn√©es d'image d'aper√ßu <br>  drapeaux: lire, √©crire <br>  Objet de type "GstElement" <br>  d√©marrage automatique: d√©marre automatiquement la capture lorsque vous passez √† l'√©tat PAUSED <br>  drapeaux: lire, √©crire <br>  Bool√©en.  Par d√©faut: faux <br>  colorspace-name: nom de l'√©l√©ment de l'espace colorim√©trique <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  String  Par d√©faut: "vid√©oconvert" <br>  jpeg-decoder-name: nom de l'√©l√©ment d√©codeur jpeg <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  String  Par d√©faut: "jpegdec" <br>  num-clock-samples: nombre d'√©chantillons d'horloge √† collecter pour la synchronisation PTS (-1 = illimit√©) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: 0 - 2147483647 Par d√©faut: 0 <br>  num-buffers: Nombre de tampons √† sortir avant d'envoyer EOS (-1 = illimit√©) <br>  drapeaux: lire, √©crire <br>  Entier  Plage: -1 - 2147483647 Par d√©faut: -1 <br>  appareil: emplacement de l'appareil <br>  drapeaux: lire, √©crire <br>  String  Par d√©faut: "/ dev / video0" <br>  nom-p√©riph√©rique: nom du p√©riph√©rique <br>  drapeaux: lisibles <br>  String  Par d√©faut: "" <br>  bitrate initial: bitrate initial en bits / seconde (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Entier non sign√©.  Plage: 0 - 4294967295 Par d√©faut: 3 000 000 <br>  slice-units: Slice units (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Entier non sign√©.  Plage: 0 - 65535 Par d√©faut: 4 <br>  slice-mode: d√©finit l'unit√© de la propri√©t√© slice-units (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  √ânum√©ration "UvcH264SliceMode" Par d√©faut: 3, "tranche / trame" <br>  (0): ignor√© - Ignor√© <br>  (1): bits / tranche - Bits par tranche <br>  (2): Mo / tranche - Mo par tranche <br>  (3): tranche / image - tranche par image <br>  iframe-period: temps entre les trames IDR en millisecondes (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Entier non sign√©.  Plage: 0 - 65535 Par d√©faut: 10000 <br>  type-utilisation: type d'utilisation (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  √ânum√©ration "UvcH264UsageType" Par d√©faut: 1, "temps r√©el" <br>  (1): temps r√©el - Temps r√©el (vid√©oconf√©rence) <br>  (2): diffusion - diffusion <br>  (3): stockage - Stockage <br>  (4): ucconfig0 - UCConfig 0 <br>  (5): ucconfig1 - UCConfig 1 <br>  (6): ucconfig2q - UCConfig 2Q <br>  (7): ucconfig2s - UCConfig 2S <br>  (8): ucconfig3 - UCConfig 3 <br>  entropie: entropie (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Enum "UvcH264Entropy" Par d√©faut: 0, "cavlc" <br>  (0): cavlc - CAVLC <br>  (1): cabac - CABAC <br>  enable-sei: active la temporisation de l'image SEI (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Bool√©en.  Par d√©faut: faux <br>  num-reorder-frames: nombre de cadres B entre les cadres de r√©f√©rence (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Entier non sign√©.  Plage: 0 - 255 Par d√©faut: 0 <br>  Aper√ßu invers√©: image invers√©e horizontalement pour les flux non H.264 (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Bool√©en.  Par d√©faut: faux <br>  leaky-bucket-size: taille de la taille du seau qui fuit en millisecondes (contr√¥le statique) <br>  drapeaux: lecture, √©criture, ne peut √™tre que NULL ou READY <br>  Entier non sign√©.  Plage: 0 - 65535 Par d√©faut: 1000 <br>  contr√¥le du taux: mode de contr√¥le du taux (contr√¥le statique et dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Enum "UvcH264RateControl" Par d√©faut: 1, "cbr" <br>  (1): cbr - D√©bit binaire constant <br>  (2): vbr - D√©bit binaire variable <br>  (3): qp - QP constant <br>  Fixed-Framerate: Framerate fixe (contr√¥le statique et dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Bool√©en.  Par d√©faut: faux <br>  max-mbps: le nombre de macroblocs par seconde pour la vitesse de traitement maximale <br>  drapeaux: lisibles <br>  Entier non sign√©.  Plage: 0 - 4294967295 Par d√©faut: 0 <br>  level-idc: Level IDC (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier non sign√©.  Plage: 0 - 255 Par d√©faut: 40 <br>  d√©bit binaire de cr√™te: le d√©bit binaire de pointe en bits / seconde (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier non sign√©.  Plage: 0 - 4294967295 Par d√©faut: 3 000 000 <br>  bitrate moyen: le bitrate moyen en bits / seconde (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier non sign√©.  Plage: 0 - 4294967295 Par d√©faut: 3 000 000 <br>  min-iframe-qp: taille minimale du pas de quantification pour les trames I (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 10 <br>  max-iframe-qp: taille minimale du pas de quantification pour les trames I (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 46 <br>  min-pframe-qp: taille minimale du pas de quantification pour les trames P (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 10 <br>  max-pframe-qp: la taille minimale du pas de quantification pour les trames P (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 46 <br>  min-bframe-qp: taille minimale du pas de quantification pour les trames B (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 10 <br>  max-bframe-qp: la taille minimale du pas de quantification pour les trames B (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: -127 - 127 Par d√©faut: 46 <br>  ltr-buffer-size: nombre total de trames de r√©f√©rence √† long terme (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: 0 - 255 Par d√©faut: 0 <br>  ltr-encoder-control: nombre de trames LTR que l'appareil peut contr√¥ler (contr√¥le dynamique) <br>  drapeaux: lire, √©crire, peut √™tre NULL, READY, PAUSED ou PLAYING <br>  Entier  Plage: 0 - 255 Par d√©faut: 0 <br><br>  Actions des √©l√©ments: <br>  "Get-enum-setting": gboolean user_function (objet GstElement *, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-boolean-setting": gboolean user_function (objet GstElement *, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-int-setting": gboolean user_function (objet GstElement *, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2, <br>  gpointer arg3); <br>  "Start-capture": void user_function (objet GstElement *); <br>  "Stop-capture": void user_function (objet GstElement *); <br></div></div><br>  Beaucoup de ces param√®tres peuvent √™tre utilis√©s pour configurer des param√®tres dans la compression H.264.  Je trouve cela plut√¥t surprenant √©tant donn√© que la compression est effectu√©e par la puce √† l'int√©rieur de la cam√©ra.  L'exemple suivant augmente le d√©bit de donn√©es par d√©faut de 3 √† 5 Mbps et r√©duit l'intervalle d'images cl√©s par d√©faut de 10 √† 3 secondes: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src initial-bitrate=5000000 average-bitrate=5000000 iframe-period=3000 device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  D'un autre c√¥t√©, il n'y a pas de param√®tres pour ajuster les param√®tres habituels de la webcam, tels que le contraste, la luminosit√©, la mise au point, etc. Ainsi, pour les configurer, nous avons encore besoin d'outils externes, tels que v4l2.ctl, ou l'option mentionn√©e dans section suivante. <br><br><h4>  v4l2src </h4><br>  Il semble que nous pouvons √©galement utiliser le bon vieux v4l2src pour capturer les flux cod√©s H.264 √† partir du Logitech C920: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e v4l2src device=/dev/video1 ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Cela est probablement d√ª √† l'√©volution de gstreamer et de V4L2.  Cette option semble plus simple si vous n'avez pas besoin de modifier les param√®tres de compression H.264, ce qui nous donne acc√®s aux param√®tres de la cam√©ra tels que la luminosit√© et le contraste.  Il a √©galement l'avantage d'√™tre dans un bon package de plugins qui pourrait √™tre mieux conserv√© √† l'avenir. <br><br><h4>  Webdiffusion via Gstreamer </h4><br>  Sur l'ordinateur r√©cepteur, d√©marrez le r√©cepteur: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v udpsrc port=6666 ! application/x-rtp, encoding-name=H264 ! rtph264depay ! h264parse ! avdec_h264 ! videoconvert ! autovideosink</code> </pre> <br>  Sur un appareil avec une cam√©ra, nous commen√ßons √† transmettre de la vid√©o cod√©e par mat√©riel: <br><br><pre> <code class="bash hljs">gst-launch-1.0 uvch264src name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vidsrc ! video/x-h264,width=160,height=120,framerate=30/1 ! h264parse ! rtph264pay ! udpsink host=192.168.1.196 port=6666</code> </pre> <br>  Un merci sp√©cial √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Amomum</a> pour m'avoir aid√© √† √©crire ce code. <br><br><h4>  R√©sum√© du d√©lai de diffusion vid√©o via Gstreamer </h4><br>  M√™me avec une r√©solution de 1920 * 1080, la charge du processeur sur Beaglebone Blue ne d√©passait pas 30% et le retard vid√©o ne d√©passait pas 0,3 seconde.  Oui, puisque la vid√©o de cette version a √©t√© diffus√©e via udp, lorsque des paquets sont perdus, l'image se d√©sagr√®ge √† l'image cl√© suivante, mais nous pouvons la configurer de sorte que les images cl√©s soient envoy√©es plus souvent. <br><br><h3>  T√¢ches ROS </h3><br>  Il ne reste plus qu'√† pousser la vid√©o re√ßue dans ROS, si quelqu'un peut vous aider, √©crivez de mani√®re personnelle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415567/">https://habr.com/ru/post/fr415567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415557/index.html">Codec 2 + r√©seau neuronal = podcast entier sur une disquette</a></li>
<li><a href="../fr415559/index.html">L'histoire du d√©veloppement des centres d'appels, ou comment les technologies ont chang√© le travail des op√©rateurs avec les clients</a></li>
<li><a href="../fr415561/index.html">Comment transf√©rer des √©v√©nements de Veeam Backup & Replication vers des messageries instantan√©es</a></li>
<li><a href="../fr415563/index.html">Le traitement de Scrum "m√©canique". Partie 2. √âquipe</a></li>
<li><a href="../fr415565/index.html">Pourquoi (aujourd'hui) retourner 444 n'est pas toujours utile</a></li>
<li><a href="../fr415569/index.html">HOWTO setup ubuntu 18.04 sendmail + DKIM + SPF + DMARC ou comment j'ai r√©ussi √† entrer dans le bastion Gmail</a></li>
<li><a href="../fr415571/index.html">kaggle: Identification du mod√®le de cam√©ra de l'IEEE</a></li>
<li><a href="../fr415573/index.html">Optimisation d'un mod√®le pour l'impression 3D en utilisant le logiciel Blender comme exemple</a></li>
<li><a href="../fr415575/index.html">Fonctions de documentation des bases de donn√©es PostgreSQL. Premi√®re partie</a></li>
<li><a href="../fr415577/index.html">Diapositives du cours "Technologies et d√©veloppement du SGBD"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>