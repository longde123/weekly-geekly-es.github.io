<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌎 🤵🏿 🖕🏾 使用闪烁的“ rhino”示例对设备固件进行反向工程。 第二部分 💩 🧖🏽 🐼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在SMARTRHINO-2018大会上的一次研讨会的基础上，我们向您介绍有关Flash Rhino设备固件的逆向工程的文章的第二部分。 

 在本文的第一部分中 ，将设备固件加载到IDA拆装器中，并对设备协议命令进行了初步分析。 在工作设备上测试了各个命令。 

 在第二部分中，将执行剩余固件任务的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用闪烁的“ rhino”示例对设备固件进行反向工程。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/412561/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/yo/jz/nyyojzktr_-hcfv4j7ygq_eaiuu.png"></div><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SMARTRHINO-2018</a>大会上的一次研讨会的基础上，我们向您介绍有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flash</a> Rhino设备固件的逆向工程的文章的第二部分。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在本文的第一部分中</a> ，将设备固件加载到IDA拆装器中，并对设备协议命令进行了初步分析。 在工作设备上测试了各个命令。 <br><br> 在第二部分中，将执行剩余固件任务的分析。 <br><br> 让我提醒您，在从控制LED的角度分析了蓝牙任务之后，决定切换到LED任务，因为最初的任务是创建一个用于控制LED的应用程序，为此需要对固件操作进行详细的了解。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">固件文件</a>可供独立研究。 <br><br>  <i>提供所有信息仅出于教育目的。</i> <br><br> 猫下有很多闪烁的犀牛。 <br><a name="habracut"></a><br><h2>  LED任务 </h2><br>  <i>简要地说：对负责切换LED的任务的完整分析。</i>  <i>分析数据类型和全局变量。</i> <br><br>  LED任务由位于<code>0x08005A08</code>的<b>x_leds_task</b>函数表示。 <br><br> 除了在LED任务的主要功能中出现奇怪的行“我拥有超能力...”之外，您还可以注意行<b>“ hue&gt; max：change shine \ r \ n”</b> 。 <br><br><img src="https://habrastorage.org/webt/6j/7u/qv/6j7uqvcupizmfsbqca81as5dwlw.png"><br><br> 同时，我们看到了一个熟悉的情况-（WORD *）（v26 + 4）。 在变量v26的上下文菜单中，选择“转换为struct *”项，然后指示之前创建的结构： <br><br><img src="https://habrastorage.org/webt/6a/2i/jv/6a2ijvqm631yl3ce5z6uom02znw.png"><br><br> 给定<code>v5 = v26</code> ，我们对变量v5重复执行<i>“转换为struct *”</i>操作。 <br><br> 我们将继续构建代码和数据。 在各处设置十六进制表示。 重命名： <br><br><ul><li>  v5 <b>领导</b> ; </li><li>  v6- <b>idx</b> ; </li><li>  v8- <b>hue_1</b> ; </li><li>  <b>v9-色调_2</b> ; </li><li>  v26- <b>_led</b> ; </li></ul><br> 代码正在改进。 但是有些变量仍然伤害眼睛，例如变量v23： <br><br><img src="https://habrastorage.org/webt/pz/cp/ch/pzcpchfjgrlwgwwtbun85x6weve.png"><br><br><img src="https://habrastorage.org/webt/k1/4k/fi/k14kfil99uzjgtwdpimtjcrl-ye.png"><br><br><div class="spoiler">  <b class="spoiler_title">显然，v23是4个字节的数组。</b> <div class="spoiler_text">  idx是LED的索引； 该索引被添加到基址中； 这样，可以访问相同位移的元素-这就是数组的行为方式。 <br></div></div><br> 我们将类型分配为<code>char v23[4]</code>并将其重命名为<b>leds_smth</b> ，代码变得更漂亮： <br><br><img src="https://habrastorage.org/webt/3a/zp/vv/3azpvvasy-8oabd8be6tshcy6z8.png"><br><br> 您还可以注意到x_queue_recv函数的结果返回到v25变量： <br><br><pre> <code class="cpp hljs">x_queue_recv(&amp;v25, leds_queue, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br> 但是可能不清楚您需要的数据如何在<i>_led</i>结构中。 事实是变量v25和_led <b><i>位于堆栈的附近</i></b> -这可以通过以下事实来理解，即在反编译中它们被写在相邻的行上。 如果双击变量，则可以在单独的窗口中查看变量在堆栈上的位置： <br><br><img src="https://habrastorage.org/webt/gm/1z/qs/gm1zqsoxvvppvneguj76arsppdu.png"><br><br> 它们可能是一个结构，或者编译器已经做了一些优化。 因此，可以说来自蓝牙任务的数据被传输到LED任务。 为了更精确地查找，我将检查设备-通过蓝牙的零LED，我将发送值<b>0x208，0x2D0，0x398，0x3E9</b> ，这可以在代码中注意到： <br><br><img src="https://habrastorage.org/webt/f-/1k/ds/f-1kdsphlzdbhuc4q6dwtfk6zge.png"><br><br> 检查设备上的色相值的结果： <br><br><ul><li>  0x208-LED停止平稳开关并设置为以下颜色：红色，绿色，蓝色，紫色； </li><li>  0x2D0-LED重新开始切换； </li><li>  0x398-一切都没有改变； </li><li>  0x3E9-一切都没有改变。 </li></ul><br> 如果再次查看该代码，则会看到值0x398可以与小于0x167的值在逻辑上关联（为数组元素<i>leds_smth</i>设置了不同的值）。 因此，我将执行此检查：首先，将第一个LED设置为绿色（色相= 0x78， <code>LED 010078FF20</code> ），而其他三个LED继续切换其颜色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5h/mp/dc/5hmpdckwscpkhlgvth05w1xvmuy.gif"></div><br> 现在，我将<code>LED 010398FFFF</code>蓝牙协议<code>LED 010398FFFF</code>在此之后，第一个LED已切换到常规颜色切换模式。 <br><br> 因此，色调值为0x398会重置静态颜色值，这意味着leds_smth数组包含要占用的LED的标志（0或1）： <br><br><ul><li>  0-LED不忙，参与平滑的颜色切换（ <b>色相= 0x398</b> ）； </li><li>  1-LED忙，用户设置静态颜色（ <b>色相&lt;= 0x167</b> ）。 </li></ul><br> 将leds_smth重命名为<b>leds_busy</b> 。 <br><br> 现在，以下代码块的目的应该变得清楚： <br><br><img src="https://habrastorage.org/webt/sb/x8/mf/sbx8mfnnah6gziclrsqmgdcmpu0.png"><br><br> 第83-101行的循环执行颜色切换步骤为5的平滑颜色拼接： <code>v12 += 5</code> 。 如果LED具有静态颜色，则此LED不参与镶嵌。 周期结束后，短期内将包含所有LED。 <br><br> 重命名： <br><br><ul><li>  sub_800678A- <b>x_led_set_hsv</b> ; </li><li>  v12- <b>hue_step</b> ; </li><li>  v13，v17，v18，v19- <b>led0_busy</b> ， <b>led1_busy</b> ， <b>led2_busy</b> ， <b>led3_busy</b> ; </li><li>  v11，v20，v21，v22- <b>hue0</b> ， <b>hue1</b> ， <b>hue2</b> ， <b>hue3</b> ; </li><li>  dword_200004C4- <b>led_control</b> 。 </li></ul><br>  sub_80039FE函数大概会执行超时（否则，LED不会平稳切换，而是立即切换），我们将其<b>称为x_sleep</b> ，变量v16为<b>led_timeout</b> 。 <br><br>  sub_8006934函数的用途尚不明确，但是在将LED上的颜色设置好之后，该函数将在所有地方使用-您可以将其<b>称为x_led_fix_color</b> 。 <br><br> 这些重命名之后，很容易理解函数<b>sub_8006944</b> （在hue &lt;= 0x167分支中调用）： <br><br><img src="https://habrastorage.org/webt/nf/8a/j-/nf8aj-jzfsk9livqh_zxpwtojgq.png"><br><br> 它仅执行附加检查即可确定LED的颜色。 将函数sub_8006944重命名为<b>x_led_set_hsv_wrap</b> （后缀<i>_wrap-</i>这是另一个函数的“包装器”的说明），并为其设置以下原型： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_led_set_hsv_wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_control, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span></span></code> </pre> <br> 让我们回到x_leds_task函数的上一级。 再次查看代码，您会发现分支“ hue&gt; 0x3E8”开始看起来像这样： <br><br><img src="https://habrastorage.org/webt/sh/tm/5j/shtm5jrmecd3quimykrcgognngs.png"><br><br> 也就是说，色相值大于0x3E8会改变彩色马赛克的超时时间。 我将向设备发送一些值进行检查： <br><br><ul><li> 色相= 0x3E9-LED开始快速切换： <br><br><img src="https://habrastorage.org/webt/1z/an/to/1zantozqcbgf0ho69jmgbvdd8v8.gif"><br></li><li> 色相= 0xFFFF-LED开始缓慢切换： <br><br><img src="https://habrastorage.org/webt/jr/ty/sn/jrtysngekw8_1ise6uwd0kikrhc.gif"><br></li></ul><br> 退出LED任务的主循环时，将使用<b>sub_8003C44</b>函数，该函数也在sub_8005070函数中使用： <br><br><img src="https://habrastorage.org/webt/ow/ws/ql/owwsqly9wu0bhmwzhu3r7buky5s.png"><br><br> 重命名： <br><br><ul><li>  sub_8005070- <b>x_freeMsg</b> ; </li><li>  sub_8003C44- <b>x_free_queue</b> 。 </li></ul><br> 在LED任务中，以下分支不得不引起注意： <br><br><img src="https://habrastorage.org/webt/iu/q6/rr/iuq6rrf54hzoupmpslmnp0r8pcu.png"><br><br> 您可以尝试执行<code>LED B816D8D90000FFFF</code>命令<code>LED B816D8D90000FFFF</code> 。 但是，如果您还记得只有2个字符被用作LED索引，那么尝试达到此代码显然是不成功的。 将此线程留待以后使用。 将函数sub_8004AE8重命名为<b>x_mad_blinking</b> ，现在该修复<b>x_printf</b>函数的签名了（上次我写错了签名）： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span></code> </pre> <br>  LED任务的主要周期已被分解，但是在任务开始时仍然有一个代码。 <br><br> 让我们看一下代码： <br><br><img src="https://habrastorage.org/webt/kt/xx/wn/ktxxwnzjvx9eqkkuiydzlro3vz4.png"><br><br> 在第49行中，最有可能检查LED的可用性，并在发生错误的情况下调用sub_8004BBC函数，该函数关闭中断并启动无限循环，其中使用“ ../Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c”行。 最有可能是<b>断言</b>或类似功能。 <br><br> 重命名： <br><br><ul><li>  sub_8004BBC- <b>x_gpio_assert</b> ; </li><li>  sub_800698C- <b>x_check_gpio</b> 。 </li></ul><br> 如果在打开设备时仔细查看设备， <b>sub_8006968</b>函数的目的将变得清楚： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/ap/t4/i8apt4kjg6rrbu73wzya5noyx6m.gif"></div><br> 所有四个LED一起先点亮红色，然后点亮绿色，然后点亮蓝色。 之后，按颜色设置它们：0红色，1-绿色，2-蓝色，3-紫色。 然后他们才开始切换马赛克。 <br><br> 由于拼接是从主任务周期开始的，因此合乎逻辑的是，主周期之前的线58-61负责短期内在LED上包含不同的颜色，而线52-56则负责一次在所有LED上设置红绿蓝。 将函数sub_8006968重命名为<b>x_led_all_set_rgb</b> （根据传递的参数，RGB <b>仅凭</b>直觉）。 <br><br><h2>  LED任务的可能性 </h2><br>  <i>简要地说：定义包含奇怪行的代码的功能。</i>  <i>生成设备密码。</i> <br><br> 现在，让我们继续x_leds_task函数的最开始： <br><br><img src="https://habrastorage.org/webt/k1/64/2j/k1642jmvbxu5d0a7vs5lrtd3pru.png"><br><br>  <b>“ Eraze”</b> ， <b>“ gen”</b> ， <b>“ flash”</b> ， <b>“ reset”</b> -为什么所有这些？？？ <br><br> 让我们尝试找出答案。 <br><br> 设sub_80066BC为<b>x_leds_task_init</b> 。 <br><br> 我们来看一下sub_8006B38： <br><br><img src="https://habrastorage.org/webt/qa/80/ez/qa80ezojcnsyo_vz_q1hru7whz8.png"><br><br> 纯净水，同意吗？ <br><br><img src="https://habrastorage.org/webt/pf/oa/tf/pfoatfwwwasjk338b3lphqiiya4.png"><br><br> 返回到x_leds_task。  v24变量类型出了点问题： <br><br><img src="https://habrastorage.org/webt/vg/ag/8u/vgag8ujkoylag2iryzujjvjldfu.png"><br><br>  IDA在类型上犯了一个小错误，但是带有堆栈标记的注释对我们有帮助。 在变量v24和v25之间，最多12个字节（0x44-0x38）。 因此，我们将<code>unsigned __int8 buf[12]</code>重命名为<b>buf</b>并分配类型为<code>unsigned __int8 buf[12]</code> （Ida将警告新数据类型大于旧数据类型-我们同意）。 <br><br> 下一个 函数sub_8004CE4： <br><br><img src="https://habrastorage.org/webt/sc/qg/tw/scqgtwrqr1vzlaubtsqstydsqmu.png"><br><br> 将<i>a1</i>重命名为<b>buf</b> ，将<i>v1</i>重命名为<b>_buf</b> 。 <br><br> 函数sub_8006B26： <br><br><img src="https://habrastorage.org/webt/gs/du/ff/gsduffmdls272wqpmmv6_klqxdm.png"><br><br> 你认识她吗？ <br><br><div class="spoiler">  <b class="spoiler_title">如果不化妆？</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8k/1d/p9/8k1dp9nmxkl0xjktjtsk_cp2vem.png"><br> 当然是<b>memcpy</b> 。 重命名。 <br></div></div><br> 那么sub_8004CE4函数的目的是在地址<b>0x08007C00</b>处获取一些数据。 顺便说一下，该地址在微控制器的闪存（特别是固件）的地址范围内。 将sub_8004CE4重命名为<b>x_read_data_0x08007C00</b> 。 <br><br>  X_leds_task功能行36： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">65</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0x19</span></span> )</code> </pre> <br> 更改数据显示（数字65上的R键，数字0x19上的H键）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'A'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> )</code> </pre> <br> 经过一番反思，您可以理解这是对拉丁字母AZ范围的测试。 <br><br> 接下来，使用格式字符串形式的提示，重命名： <br><br><ul><li>  sub_8004C10- <b>x_erase</b> ; </li><li>  sub_80059C8- <b>x_gen</b> ; </li><li>  sub_8004C84- <b>x_flash</b> 。 </li></ul><br>  sub_8003C66函数的作用不明显-它仅增加一些全局变量-将sub_8003C66重命名为<b>x_smth_inc</b> 。 <br><br>  <b>x_erase</b>函数实际上并不接受任何参数-这可以在反汇编程序中进行验证： <br><br><img src="https://habrastorage.org/webt/rv/p3/_i/rvp3_iqmhzsegjqyi3mugvpxnis.png"><br><br> 在x_erase内部，使用了熟悉的地址0x08007C00，并访问了三个未知函数： <br><br><img src="https://habrastorage.org/webt/ys/nb/_b/ysnb_bfgd19htkrnmbyo5hudr0m.png"><br><br>  <b>快速</b>浏览这三个函数，我们看到它们正在访问<b>0x40022000-0x400223FF</b>范围内的地址。 微控制器的文档明确指出，这是<b>“闪存接口”</b>范围。 也就是说，x_erase函数可擦除闪存-太棒了！ <br><br> 显然，在检查了要写入的行的长度之后，x_flash函数将写入闪存（顺便说一下，参数a2和a3在这里是多余的-我们将帮助Idea）： <br><br><img src="https://habrastorage.org/webt/ki/di/zi/kidizigfv5lb6bwg24aspkgvxmw.png"><br><br> 而这一切都发生在“照明设备”中？ <br><br> 那么， <b>x_gen</b>函数呢？ 快速浏览并重命名变量后，将如下所示： <br><br><img src="https://habrastorage.org/webt/v3/js/nb/v3jsnb8jb36wstn3obcln2c3pvk.png"><br><br>  <b>sub_8006CB4</b>函数如下所示： <br><br><img src="https://habrastorage.org/webt/ub/h1/rk/ubh1rki0ikjrygsiqcx9vuwylxc.png"><br><br> 和<b>sub_8006D10-</b>像这样： <br><br><img src="https://habrastorage.org/webt/gp/qy/oc/gpqyocts_ubcd4u3ep9koyrcb0o.png"><br><br> 不要抑制在Internet上搜索这些不雅的常量的愿望： <b>0xABCD</b> ， <b>0x1234，0xE66D</b> ， <b>0xDEEC</b> ， <b>0x4C957F2D</b>和<b>0x5851F42D</b> 。 如果尚未完全禁止Internet，则可能会在<b>随机函数</b>的源代码中找到这些常量。 难怪父函数称为x_gen。 <br><br> 这也是一种非常典型的情况：在循环之前调用srand（），在循环中调用random（），因此将其重命名： <br><br><ul><li>  sub_8006D10-x_rand; </li><li>  sub_8006CB4-x_srand。 </li></ul><br> 好奇的读者可以通过查看<b>sub_8005098</b>函数来找出srand函数<i>的种子来源</i> 。 <br><br> 因此，x_gen函数生成<b>指定大小的随机字符串</b> 。 <br><br> 将生成的行写入闪存后，设备将重新引导： <br><br><img src="https://habrastorage.org/webt/a9/ta/rr/a9tarrhqqc-jj7g-e-dplvr67py.png"><br><br> 似乎有些奇怪的重启。 但是，如果我们查看此设备的任务列表，则会在其中找到“ watchdogTask”。 显然，如果存在“卡住任务”，则看门狗会重新启动。 <br><br> 可以考虑分析除MadBlinking模式以外的LED任务。 <br><br> 让我们仔细看看系统中还有哪些其他任务： <br><br><img src="https://habrastorage.org/webt/fz/yj/yk/fzyjykt6djuq8v20hjpuw5l0xow.png"><br><br> 恢复了代码中字符串的链接后，您可以看到以下图片： <br><br><img src="https://habrastorage.org/webt/ha/bl/ks/hablksetvyb0rskx6veqrxbt_z0.png"><br><br> 首先，存在指向名称为task的字符串的链接，然后是至主task函数的链接。 它们在启动以下任务的<b>主要</b>功能中使用： <br><br><img src="https://habrastorage.org/webt/oc/ah/qd/ocahqdn8usagpkr-isbabunuwms.png"><br><br> 让我们执行丢失的重命名： <br><br><ul><li>  sub_80050FC- <b>x_sensor_task</b> ; </li><li>  sub_8004AAC- <b>x_watchdogTask</b> ; </li><li>  sub_8005440- <b>x_uartRxTask</b> 。 </li></ul><br><h2> 看门狗任务 </h2><br> 任务看门狗没有做任何特别有趣的事情： <br><br><img src="https://habrastorage.org/webt/m-/65/5w/m-655wpo6oboqmrob1tonwaoska.png"><br><br> 重命名： <br><br><ul><li>  dword_200003F8- <b>wd_variable</b> ; </li><li>  sub_8001050- <b>x_update_wd_var</b> 。 </li></ul><br><h2>  UART任务 </h2><br>  <i>简要地说：搜索具有来自不同功能的链接的数据和功能。</i>  <i>确定其目的。</i> <br><br> 快速浏览UART任务使您能够检测到将数据发送到由变量<b>unk_200003EC</b>定义的未知队列： <br><br><img src="https://habrastorage.org/webt/8j/ei/zz/8jeizzxpvgu5opijgopamebser0.png"><br><br> 通过二进制搜索恢复到此变量的链接后，我们将看到除x_uartRxTask之外，它还在主要（显然已经创建了队列）和迄今为止未知的函数<b>sub_80051EC中使用</b> ： <br><br><img src="https://habrastorage.org/webt/g2/md/sg/g2mdsgx9wwhzpklgcacelye8rb8.png"><br><br> 重命名： <br><br><ul><li>  sub_80051EC- <b>x_recvMsg_uart_queue</b> ; </li><li>  unk_200003EC- <b>uart_queue</b> 。 </li></ul><br> 请参阅对x_recvMsg_uart_queue的交叉引用： <br><br><ul><li>  sub_8005250; </li><li>  x_bluetooth_task。 </li></ul><br> 首先，请参见<b>sub_8005250</b>函数： <br><br><img src="https://habrastorage.org/webt/z1/8z/yj/z18zyj09grly6nwhuycpftjbrcu.png"><br><br> 思考之后，重命名： <br><br><ul><li>  unk_2000034C- <b>cmd_count</b> ; </li><li>  a1- <b>cmd</b> ; </li><li>  v4- <b>_cmd</b> ; </li><li>  v6是<b>rsp</b> ; </li><li>  sub_8005250- <b>x_bluetooth_cmd</b> 。 </li></ul><br> 现在让我们看一下仍在使用x_bluetooth_cmd的位置。 所有其他链接仅来自Bluetooth任务，现在该返回它。 <br><br><h2> 回到蓝牙任务 </h2><br>  <i>简要地说：蓝牙任务的最终分析。</i>  <i>搜索无密码的授权。</i> <br><br><img src="https://habrastorage.org/webt/mb/2b/-e/mb2b-eatekfev7dil5vfk3_s-es.png"><br><br> 如果您查看<b>使用sub_8006A84</b>函数的<b>位置</b> ，并且您不太懒惰并且仔细研究其肠子，那么毫无疑问-这就是<b>calloc</b> 。 这是合乎逻辑的-为了将数据接收到缓冲区中，必须首先创建此缓冲区。 <br><br> 现在为<b>sub_8006DBC</b> 。 让我们看一下（变量已经重命名）： <br><br><img src="https://habrastorage.org/webt/kt/hw/31/kthw31aeqzwyae4jvnoqf5u6yl4.png"><br><br> 回顾标准C库用于处理字符串的功能，我们将在此处看到<b>strstr</b> （搜索子字符串）并对其进行粗体重命名。 <br><br> 让我们看一下x_bluetooth_task函数的代码- <i>自上次访问以来，这里的内容可能有所更改</i> 。 在此过程中，我们将变量命名为： <br><br><ul><li>  v2- <b>_state</b> ; </li><li>  v3- <b>data_len</b> 。 </li></ul><br> 它旁边有一个<b>sub_80052E2</b>函数。 类似于从Bluetooth命令中提取数字的函数，它提取指定长度的字符串-我们称之为<b>x_get_str</b> 。 <br><br> 我们继续： <br><br><ul><li>  v26- <b>isEcho</b> ; </li><li>  v6- <b>meow_str</b> ; </li><li>  v10- <b>uart_cmd_byte</b> ; </li><li>  v11- <b>uart_cmd_str</b> ; </li><li>  v12- <b>str_0</b> ; </li><li>  v13- <b>str_1</b> ; </li><li>  v14- <b>format_str</b> ; </li><li>  sub_8000F5C- <b>x_blink_small_led</b> 。 </li></ul><br> 完成快速重命名： <br><br><ul><li>  v19 <b>密码</b> ;  （因为旁边有关于授权和密码的行） </li><li>  sub_8004CC0- <b>x_check_password</b> ; </li><li>  sub_8006AF4- <b>x_free</b> （由于密码，cmd和bt_args是指向动态对象的指针（请选中此选项！），使用它们后应释放内存）； </li><li>  sub_8006DAC- <b>x_strcpy</b> （检查出来！）。 </li></ul><br> 现在探索<b>READ</b> ， <b>WRIT</b> ， <b>AUTP</b> ， <b>SETP等</b>分支。 <br><br> 如在运行中的设备上进行的测试所示，READ，WRIT，SETP命令需要授权。 使用AUTP命令进行的授权尝试使我们进入<b>x_check_password</b>函数以验证密码： <br><br><img src="https://habrastorage.org/webt/vt/pw/6b/vtpw6b3h64bivcvzdlalldoo45k.png"><br><br> 事实证明，密码长度必须为8个字符，并且将密码（在sub_8006B08函数中）与地址<b>0x08007C00</b>处的字节进行<b>比较</b> -存储生成的随机字符AZ字符串。 <br><br> 原来，不知道密码，我们就无法登录该设备。 好吧，还是几乎不能... <br><br> 注意<b>使用auth_flag</b>变量的位置： <br><br><img src="https://habrastorage.org/webt/8h/ng/l0/8hngl0dqritcx8yzk1jbvkqpq34.png"><br><br> 事实证明，它不仅用于蓝牙任务。 在这里，我们只是没有查看Sensor任务。 我们去那里。 <br><br><h2> 传感器任务 </h2><br>  <i>简要地说：触摸按钮有什么作用？</i> <br><br> 根据最佳编程实践，整个Sensor任务都放在一个IDA屏幕中。 这不能不让我们高兴： <br><br><img src="https://habrastorage.org/webt/mq/13/3v/mq133vs_uxqmyldfhmicajpxiak.png"><br><br> 线对线... <br><br><ul><li>  “ TSC％d \ r \ n”-此行应使您考虑STM32微控制器的触摸感应控制器； </li><li>  “ AUTH BTN \ r \ n”-授权按钮？？？ </li><li>  “ SET AUTH％d \ r \ n”-设置授权标志？ </li></ul><br> 让我们看看如果您按下触摸按钮，设备将如何运行（您是否意识到腿上的犀牛具有触摸按钮？）： <br><br><img src="https://habrastorage.org/webt/0p/ig/bp/0pigbpj4pj5gdrn1onololc_zfk.gif"><br><br> 短暂按下时，红色的小LED点亮。 长按此指示灯可长时间点亮。 <br><br> 如果将其与代码相关联，则可以假定<b>sub_8000708</b>函数是用于获取当前时间的函数。 然后，如果当前时间与开始触摸传感器之间的时间差大于1000（1秒），则LED点亮<b>0xEA60</b>毫秒（1分钟）。 但是auth_flag变量引起了极大的兴趣，通过长按触摸按钮将其设置为1，可以使<s>攻击者</s>可以访问“照明设备”的管理员来访问特权功能。 <br><br> 因此，在通过“按钮”授权后，您可以读取设备中存储的密码（READ命令），写入RAM（WRIT功能）或设置新密码（SETP）。 <br><br><h2> 疯狂眨眼 </h2><br>  <i>简要地说：可以执行一个奇怪的Mad Blinking代码分支吗？</i> <br><br> 让我们回到蓝牙任务并进行更多重命名。 <br><br><ul><li>  v21- <b>vip_smth</b> （目前尚不清楚那里是什么）； </li><li>  v22- <b>vip_str</b> （未知大小的字符串，从参数中提取）； </li><li>  v23- <b>mad_led-</b>分配“转换为struct *”并指定<i>struct_LED</i> 。 </li></ul><br> 在这里，我们看到数字<b>0xB816D8D9</b> （在Bluetooth任务的文章的第一部分中找到）作为LED的索引。 如果执行验证，将执行以下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sub_8005520(vip_str, vip_smth) == <span class="hljs-number"><span class="hljs-number">0x46F70674</span></span> )</code> </pre> <br> 将sub_8005520重命名为<b>x_vip_check</b>并进行查看： <br><br><img src="https://habrastorage.org/webt/dl/h9/tx/dlh9txqyu5n1t4orgprpptbk8oc.png"><br><br> 假定第一个参数是一个字符串（至少字符串已传递给此函数），此代码显示第二个参数是该字符串的长度（或必须处理的长度）。 重命名： <br><br><ul><li>  a1- <b>str</b> ; </li><li>  a2- <b>len</b> 。 </li></ul><br> 让我们看一下<b>sub_8000254</b>函数： <br><br><img src="https://habrastorage.org/webt/y-/ql/js/y-qljsey4clq4lowsdbrblnkyf8.png"><br><br> 现在查看<b>sub_8000148</b> 。 这是它的开始： <br><br><img src="https://habrastorage.org/webt/l7/xz/cr/l7xzcrdgjq0n5a82enkalsukqse.png"><br><br> 这只是功能的三分之一...嗯...好吃！ 经验丰富的挖掘机很容易在这里看到... <br><br><div class="spoiler">  <b class="spoiler_title">什么啊</b> <div class="spoiler_text"> 整数除法运算。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">怎么发掘呢？</b> <div class="spoiler_text"> 如果您<b>不费吹灰之力</b> ，则可以从功能<b>sub_8000254</b>进入<b>x_printf</b> （通过其他几个功能）。 重要的一点是，通常所有<i>标准功能都是相当标准的</i> 。 这意味着您可以尝试在公共领域中至少找到要研究的功能的某些源代码，从而使研究工作更有效率。 <br><br> 因此，我们以printf的源代码为基础，然后查看<b>vfprintf</b> ，并将其与所研究固件的代码进行比较。  <b>使用</b>源代码，我们退出到<b>itoa</b>函数，并得出以下结论： <b>sub_8000254</b>函数是运算符<b>operator％</b> （取除法的余数），而这个可怕的long函数仅取除法的整数部分（div运算）。 <br></div></div><br> 可能会出现一个合理的问题-为什么会这样？ 事实是，在特定的微控制器中不能进行DIV，MOD操作，因此，编译器代替了对单个函数的调用来代替这些运算符。 顺便说一下，这里还有其他一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数学函数</a> 。 <br><br> 挖掘时不要忘记重命名。 <br><br> 因此，函数<b>x_vip_check会</b>计算...这将是您的<b><i>作业</i></b> 。 <br><br> 顺便说一句，如果您执行正确的<b>VIP</b>命令，我们将得到“迪斯科犀牛”： <br><br><img src="https://habrastorage.org/webt/ah/ty/sc/ahtyscents-3j77aqcxfa0_hrtq.gif"><br><br><h2> 固件简要报告 </h2><br> 设备的固件基于FreeRTOS实时操作系统。 系统具有以下任务： <br><br><ol><li>  <b>蓝牙任务</b> 。 通过蓝牙处理文本形式的命令。 </li><li>  <b>LED任务</b> 。 根据蓝牙命令控制彩色LED。 </li><li>  <b>传感器任务</b> 。 打开红色LED指示灯，允许短期授权而无需在设备上输入密码。 </li><li>  <b>UART任务</b> 。 允许您通过内部UART端口与蓝牙模块进行交互（用于初始化蓝牙）。 </li><li>  <b>看门狗任务</b> 。 跟踪冻结。 </li></ol><br> 该研究没有考虑从UART端口（Tx / GND触点）读取数据的能力。 <br><br><h2> 总结 </h2><br> 在会议的大师班上，只有主要的LED控制功能被拆卸了。 向最活跃的参与者展示了他们的实验性“犀牛”。 <br><br> 在我看来，“犀牛”为反向工程和漏洞搜索培训课程提供了不错的布局。 布局的一个特点是可以根据需要多次更改固件，每个过程都有自己的固件。 与解析可执行文件不同，反向固件使您可以更好地理解： <br><br><ul><li> 如何与IDA合作； </li><li> 固件和设备之间的交互原理； </li><li>  RTOS的工作原理。 </li></ul><br> 非常感谢读完所有文章的所有人！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412561/">https://habr.com/ru/post/zh-CN412561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412551/index.html">通过ADB将文本从剪贴板复制到Android设备</a></li>
<li><a href="../zh-CN412553/index.html">2018年6月IT领域人力资源专业人员的事件摘要</a></li>
<li><a href="../zh-CN412555/index.html">无刷电机的磁性齿轮</a></li>
<li><a href="../zh-CN412557/index.html">如何在没有编程技能的情况下创建自己的机器人并将其连接到Yandex.Alice</a></li>
<li><a href="../zh-CN412559/index.html">智能合约对区块链初创公司构成安全威胁</a></li>
<li><a href="../zh-CN412565/index.html">关于系统管理员的漫画：所有的生命在我眼前闪过</a></li>
<li><a href="../zh-CN412571/index.html">Kubernetes在生产中的成功案例。 第9部分：CERN和210 K8s机群</a></li>
<li><a href="../zh-CN412573/index.html">Geektimes返回Habr有什么问题</a></li>
<li><a href="../zh-CN412575/index.html">每年，流行音乐变得越来越单调，因为同一个人组成了流行音乐</a></li>
<li><a href="../zh-CN412579/index.html">奇迹：无限战争或如何在几分钟内为您的项目收集数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>