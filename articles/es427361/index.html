<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüöí üö¥üèæ üê≠ Caracter√≠sticas del filtrado de ventanas en FPGA üñêÔ∏è ü§≥üèæ üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Este art√≠culo se centrar√° en una parte importante del procesamiento de se√±al digital: el filtrado de se√±al de ventana, en particular en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caracter√≠sticas del filtrado de ventanas en FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427361/"> Hola a todos!  Este art√≠culo se centrar√° en una parte importante del procesamiento de se√±al digital: el filtrado de se√±al de ventana, en particular en FPGA.  El art√≠culo mostrar√° c√≥mo dise√±ar ventanas cl√°sicas de longitud est√°ndar y ventanas "largas" de 64K a 16M + muestras.  El lenguaje de desarrollo principal es VHDL, la base del elemento son los √∫ltimos cristales Xilinx FPGA de las √∫ltimas familias: estos son Ultrascale, Ultrascale +, 7-series.  El art√≠culo demostrar√° la implementaci√≥n de CORDIC, el n√∫cleo b√°sico para configurar funciones de ventana de cualquier duraci√≥n, as√≠ como funciones b√°sicas de ventana.  El art√≠culo describe el m√©todo de dise√±o utilizando lenguajes de alto nivel C / C ++ en Vivado HLS.  Como de costumbre, al final del art√≠culo encontrar√° un enlace a los c√≥digos fuente del proyecto. <br><br>  KDPV: un esquema t√≠pico de transmisi√≥n de se√±al a trav√©s de nodos DSP para tareas de an√°lisis de espectro. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Del curso "Procesamiento de se√±al digital" muchas personas saben que para una forma de onda sinusoidal que es infinita en el tiempo, su espectro es una funci√≥n delta en la frecuencia de la se√±al.  En la pr√°ctica, el espectro de una se√±al arm√≥nica limitada en tiempo real es equivalente a la funci√≥n <b>~ sin (x) / x</b> , y el ancho del l√≥bulo principal depende de la duraci√≥n del intervalo de an√°lisis de se√±al <b>T.</b>  El l√≠mite de tiempo no es m√°s que multiplicar la se√±al por una envoltura rectangular.  Se sabe por el curso DSP que la multiplicaci√≥n de se√±ales en el dominio del tiempo es una convoluci√≥n de sus espectros en el dominio de la frecuencia (y viceversa), por lo tanto, el espectro de la envoltura rectangular limitada de la se√±al arm√≥nica es equivalente a ~ sinc (x).  Esto tambi√©n se debe al hecho de que no podemos integrar la se√±al en un intervalo de tiempo infinito, y la transformada de Fourier en forma discreta, expresada a trav√©s de una suma finita, est√° limitada por el n√∫mero de muestras.  Como regla general, la longitud de la FFT en los modernos dispositivos de procesamiento digital FPGA lleva los valores de <b>NFFT</b> de 8 a varios millones de puntos.  En otras palabras, el espectro de la se√±al de entrada se calcula en el intervalo <b>T</b> , que en muchos casos es igual a <b>NFFT</b> .  Al limitar la se√±al al intervalo <b>T</b> , imponemos una "ventana" rectangular con una duraci√≥n de <b>T</b> muestras.  Por lo tanto, el espectro resultante es el espectro de la se√±al arm√≥nica multiplicada y la envolvente rectangular.  En las tareas DSP, se han inventado ventanas de varias formas durante mucho tiempo, que, cuando se superponen a una se√±al en el dominio del tiempo, pueden mejorar sus caracter√≠sticas espectrales.  Una gran cantidad de varias ventanas se debe principalmente a una de las caracter√≠sticas principales de cualquier superposici√≥n de ventanas.  Esta caracter√≠stica se expresa en la relaci√≥n entre el nivel de los l√≥bulos laterales y el ancho del l√≥bulo central.  Un patr√≥n bien conocido: cuanto m√°s fuerte es la supresi√≥n de los l√≥bulos laterales, m√°s ancho es el l√≥bulo principal y viceversa. <br><br>  Una de las aplicaciones de las funciones de ventana: detecci√≥n de se√±ales d√©biles en el contexto de las m√°s fuertes al suprimir el nivel de los l√≥bulos laterales.  Las funciones de la ventana principal en las tareas de DSP son una ventana triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, Blackman-Harris, ventana plana, ventana Natall, Gauss, Kaiser y muchas otras.  La mayor√≠a de ellos se expresan a trav√©s de una serie finita sumando se√±ales arm√≥nicas con pesos espec√≠ficos.  Las ventanas de forma compleja se calculan tomando un exponente (ventana de Gauss) o una funci√≥n Bessel modificada (ventana de Kaiser), y no se considerar√°n en este art√≠culo.  Puede leer m√°s sobre las funciones de ventana en la literatura, que tradicionalmente dar√© al final del art√≠culo. <br><br>  La siguiente figura muestra las funciones de ventana t√≠picas y sus caracter√≠sticas espectrales construidas con las herramientas CAD de Matlab. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Implementaci√≥n </h3><br>  Al comienzo del art√≠culo, insert√© KDPV, que muestra en t√©rminos generales un diagrama estructural de la multiplicaci√≥n de datos de entrada por una funci√≥n de ventana.  Obviamente, la forma m√°s f√°cil de implementar el almacenamiento de una funci√≥n de ventana en el FPGA es escribirlo en la memoria (bloquear <i>RAMB</i> o distribuido <i>distribuido</i> , no importa mucho), y luego recuperar c√≠clicamente los datos cuando llegan las muestras de entrada de la se√±al.  Como regla general, en los FPGA modernos, la cantidad de memoria interna permite almacenar funciones de ventana de tama√±os relativamente peque√±os, que luego se multiplican con las se√±ales de entrada entrantes.  Por peque√±o quiero decir funciones de ventana de hasta 64K muestras de largo. <br><br>  Pero, ¬øqu√© pasa si la funci√≥n de ventana es demasiado larga?  Por ejemplo, 1M de lecturas.  Es f√°cil calcular que para dicha funci√≥n de ventana presentada en una cuadr√≠cula de bits de 32 bits, se requieren NRAMB = 1024 * 1024 * 32/32768 = 1024 celdas de memoria de bloque de los cristales de RAMGA36K tipo FPGA Xilinx.  ¬øY para 16 millones de muestras?  ¬°16 mil celdas de memoria!  Ni un solo FPGA moderno tiene tanta memoria.  Para muchos FPGA esto es demasiado, y en otros casos es un uso derrochador de recursos FPGA (y, por supuesto, el dinero del cliente). <br><br>  A este respecto, debe encontrar un m√©todo para generar muestras de funciones de ventana directamente al FPGA sobre la marcha, sin escribir coeficientes desde el dispositivo remoto en la memoria de bloque.  Afortunadamente, las cosas b√°sicas han sido inventadas por mucho tiempo para nosotros.  Usando un algoritmo como <b>CORDIC</b> (el m√©todo <i>d√≠gito a d√≠gito</i> ), es posible dise√±ar muchas funciones de ventana cuyas f√≥rmulas se expresan en t√©rminos de se√±ales arm√≥nicas (Blackman-Harris, Hann, Hamming, Nattal, etc.) <br><br><h3>  CORDIC </h3><br>  CORDIC es un m√©todo iterativo simple y conveniente para calcular la rotaci√≥n de un sistema de coordenadas, que le permite calcular funciones complejas realizando operaciones de suma y desplazamiento primitivas.  Usando el algoritmo CORDIC, uno puede calcular los valores de las se√±ales arm√≥nicas sin (x), cos (x), encontrar la fase - atan (x) y atan2 (x, y), funciones trigonom√©tricas hiperb√≥licas, rotar el vector, extraer la ra√≠z del n√∫mero, etc. <br><br>  Al principio, quer√≠a tomar el n√∫cleo CORDIC terminado y reducir la cantidad de trabajo, pero me disgustan mucho los n√∫cleos Xilinx.  Despu√©s de estudiar los repositorios en el github, me di cuenta de que todos los n√∫cleos presentados no son adecuados por varias razones (mal documentados e ilegibles, no universales, hechos para una tarea espec√≠fica o base de elementos, <s>escritos en verilog</s> , etc.).  Luego le ped√≠ al compa√±ero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">lazifo</a> que hiciera este trabajo por m√≠.  Por supuesto, lo hizo frente, porque la implementaci√≥n de CORDIC es una de las tareas m√°s simples en el campo de DSP.  Pero como soy impaciente, en paralelo con su trabajo, escrib√≠ <s>mi bicicleta con</s> mi <s>propio</s> n√∫cleo parametrizado.  Las caracter√≠sticas principales son la profundidad de bits configurable de las se√±ales de salida <b>DATA_WIDTH</b> y la fase de entrada normalizada <b>PHASE_WIDTH</b> de -1 a 1, y la precisi√≥n de los c√°lculos de <b>PRECISI√ìN</b> .  El n√∫cleo CORDIC se ejecuta de acuerdo con el circuito paralelo de la tuber√≠a: en cada ciclo de reloj, el n√∫cleo est√° listo para realizar c√°lculos y recibir muestras de entrada.  El n√∫cleo gasta N ciclos para calcular la muestra de salida, cuyo n√∫mero depende de la capacidad de las muestras de salida (cuanto m√°s capacidad, m√°s iteraciones para calcular el valor de salida).  Todos los c√°lculos ocurren en paralelo.  Por lo tanto, CORDIC es el n√∫cleo base para crear funciones de ventana. <br><br><h3>  Funciones de ventana </h3><br>  En el marco de este art√≠culo, me doy cuenta solo de esas funciones de ventana que se expresan a trav√©s de se√±ales arm√≥nicas (Hann, Hamming, Blackman-Harris de varios √≥rdenes, etc.).  ¬øQu√© se necesita para esto?  En t√©rminos generales, la f√≥rmula para construir una ventana se parece a una serie de longitud finita. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  Un cierto conjunto de coeficientes <b>a <sub>k</sub></b> y miembros de la serie determina el nombre de la ventana.  La ventana m√°s popular y de uso frecuente es la ventana Blackman-Harris: de diferente orden (de 3 a 11).  La siguiente es una tabla de coeficientes para las ventanas Blackman-Harris: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  En principio, el conjunto de ventanas Blackman-Harris es aplicable en muchos problemas de an√°lisis espectral, y no hay necesidad de intentar usar ventanas complejas como Gauss o Kaiser.  Las ventanas Nattal o planas son solo una variedad de ventanas con diferentes pesos, pero los mismos principios b√°sicos que Blackman-Harris.  Se sabe que cuantos m√°s miembros de la serie, m√°s fuerte es la supresi√≥n del nivel de los l√≥bulos laterales (sujeto a una elecci√≥n razonable de la profundidad de bits de la funci√≥n de ventana).  En funci√≥n de la tarea, el desarrollador solo tiene que elegir el tipo de ventanas utilizadas. <br><br><h3>  Implementaci√≥n de FPGA - enfoque tradicional </h3><br>  Todos los n√∫cleos de las funciones de ventana est√°n dise√±ados utilizando el enfoque cl√°sico para describir circuitos digitales en FPGA y est√°n escritos en el lenguaje VHDL.  A continuaci√≥n se muestra una lista de los componentes realizados: <br><br><ul><li>  <i>bh_win_7term</i> - <i>Orden</i> Blackman-Harris 7, una ventana con m√°xima supresi√≥n de andamios laterales. </li><li>  <i>bh_win_5term</i> : orden de Blackman-Harris 5, incluye una ventana con una parte superior plana. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4 pedidos, incluye la ventana Nattal y Blackman-Nattal. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 pedidos, </li><li>  <i>hamming_win</i> : ventanas de Hamming y Hann. </li></ul><br>  El c√≥digo fuente para el componente de ventana Blackman-Harris es de 3 √≥rdenes de magnitud: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  En algunos casos, utilic√© la biblioteca <i>UNISIM</i> para incrustar los <b>nodos DSP48E1 y DSP48E2</b> en el proyecto, lo que finalmente <b>me</b> permite aumentar la velocidad de los c√°lculos debido a la canalizaci√≥n dentro de estos bloques, pero como la pr√°ctica ha demostrado, es m√°s r√°pido y f√°cil dar rienda suelta y escribir algo como <b>P = A * B + C</b> y especifique las siguientes directivas en el c√≥digo: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  Esto funciona bien y establece r√≠gidamente el tipo de elemento en el que se implementa la funci√≥n matem√°tica para el sintetizador. <br><br><h3>  Vivado hls </h3><br>  Adem√°s, implement√© todos los n√∫cleos utilizando las herramientas <b>Vivado HLS</b> .  Enumerar√© las principales <b>ventajas de</b> Vivado HLS: alta velocidad de dise√±o ( <i>tiempo de comercializaci√≥n</i> ) en lenguajes de alto nivel C o C ++, modelado r√°pido de nodos desarrollados debido a la falta de un concepto de frecuencia de reloj, configuraci√≥n flexible de soluciones (en t√©rminos de recursos y rendimiento) mediante la introducci√≥n pragmas y directivas en el proyecto, as√≠ como un umbral de entrada bajo para desarrolladores en lenguajes de alto nivel.  La principal desventaja es el costo sub√≥ptimo de los recursos de FPGA en comparaci√≥n con el enfoque cl√°sico.  Adem√°s, no es posible alcanzar esas velocidades proporcionadas por los antiguos m√©todos RTL cl√°sicos (VHDL, Verilog, SV).  Bueno, el mayor <b>inconveniente</b> es bailar con una pandereta, pero esto es caracter√≠stico de todos los CAD de Xilinx.  (Nota: en el depurador Vivado HLS y en el modelo C ++ real, a menudo se obtuvieron resultados diferentes, porque Vivado HLS funciona de manera torcida utilizando las ventajas de la <i>precisi√≥n arbitraria</i> ). <br><br>  La siguiente imagen muestra el registro del n√∫cleo CORDIC sintetizado en Vivado HLS.  Es bastante informativo y muestra mucha informaci√≥n √∫til: la cantidad de recursos utilizados, la interfaz de usuario del n√∫cleo, los bucles y sus propiedades, el retraso en la computaci√≥n, el intervalo para calcular el valor de salida (importante al dise√±ar circuitos en serie y en paralelo): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  Tambi√©n puede ver la forma de calcular datos en varios componentes (funciones).  Se puede ver que en la fase cero, se leen los datos de la fase, y en los pasos 7 y 8, se muestra el resultado del nodo CORDIC. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  El resultado de Vivado HLS: un n√∫cleo RTL sintetizado creado a partir del c√≥digo C.  El registro muestra que en el an√°lisis de tiempo, el n√∫cleo pasa con √©xito todas las restricciones: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Otra gran ventaja de Vivado HLS es que para verificar el resultado, ella misma realiza un banco de pruebas del c√≥digo RTL sintetizado en funci√≥n del modelo que se utiliz√≥ para verificar el c√≥digo C.  Esta puede ser una prueba primitiva, pero creo que es lo suficientemente genial y conveniente para comparar el funcionamiento del algoritmo en C y en HDL.  A continuaci√≥n se muestra una captura de pantalla de Vivado que muestra una simulaci√≥n del modelo de funci√≥n del n√∫cleo de una funci√≥n de ventana obtenida por Vivado HLS: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Por lo tanto, para todas las funciones de la ventana, se obtuvieron resultados similares, independientemente del m√©todo de dise√±o, en VHDL o en C ++.  Sin embargo, en el primer caso, se logra una mayor frecuencia de operaci√≥n y un menor n√∫mero de recursos, y en el segundo caso, se logra la velocidad m√°xima de dise√±o.  Ambos enfoques tienen derecho a la vida. <br><br>  Calcul√© espec√≠ficamente cu√°nto tiempo dedicar√≠a al desarrollo utilizando diferentes m√©todos.  Implement√© un proyecto C ++ en Vivado HLS ~ 12 veces m√°s r√°pido que en VHDL. <br><br><h3>  Comparaci√≥n de enfoques </h3><br>  Compare el c√≥digo fuente de HDL y C ++ para el n√∫cleo CORDIC.  El algoritmo, como se dijo anteriormente, se basa en las operaciones de suma, resta y desplazamiento.  En VHDL, se ve as√≠: hay tres vectores de datos: uno es responsable de la rotaci√≥n del √°ngulo y los otros dos determinan la longitud del vector a lo largo de los ejes X e Y, que es equivalente a sin y cos (ver la imagen de la wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  Al calcular iterativamente el valor Z, los valores X e Y se calculan en paralelo. El proceso de b√∫squeda c√≠clica de valores de salida en HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  En C ++, en Vivado HLS, el c√≥digo se ve casi igual, pero el registro es varias veces m√°s corto: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Aparentemente, se usa el mismo ciclo con turno y adiciones.  Sin embargo, de forma predeterminada, todos los bucles en Vivado HLS est√°n "colapsados" y se ejecutan secuencialmente, seg√∫n lo previsto para el lenguaje C ++.  La introducci√≥n del <b>pragma HLS UNROLL</b> o <b>HLS PIPELINE</b> convierte los c√°lculos en serie en paralelos.  Esto conduce a un aumento en los recursos de FPGA, sin embargo, le permite calcular y enviar nuevos valores al n√∫cleo en cada ciclo de reloj. <br><br>  Los resultados de la s√≠ntesis del proyecto en VHDL y C ++ se presentan en la figura a continuaci√≥n.  Como puede ver, l√≥gicamente, la diferencia es dos veces a favor del enfoque tradicional.  Para otros recursos de FPGA, la discrepancia es insignificante.  No profundic√© en la optimizaci√≥n del proyecto en C ++, pero sin ambig√ºedades al establecer varias directivas o cambiar parcialmente el c√≥digo, se puede reducir la cantidad de recursos utilizados.  En ambos casos, los tiempos convergieron para una frecuencia central dada de ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Caracter√≠sticas de implementaci√≥n </h3><br>  Dado que los c√°lculos se realizan en un formato de punto fijo, las funciones de ventana tienen una serie de caracter√≠sticas que deben tenerse en cuenta al dise√±ar sistemas DSP en FPGA.  Por ejemplo, cuanto mayor sea la profundidad de bits de los datos de la funci√≥n de ventana, mejor ser√° la precisi√≥n de la superposici√≥n de la ventana.  Por otro lado, con una profundidad de bits insuficiente de la funci√≥n de ventana, se introducir√°n distorsiones en la forma de onda resultante, lo que afectar√° la calidad de las caracter√≠sticas espectrales.  Por ejemplo, una funci√≥n de ventana debe tener al menos 20 bits cuando se multiplica por una se√±al con una duraci√≥n de 2 ^ 20 = 1M muestras. <br><br><h3>  Conclusi√≥n </h3><br>  Este art√≠culo muestra una forma de dise√±ar funciones de ventana sin usar memoria externa o memoria de bloque FPGA.  Se da el m√©todo de usar recursos exclusivamente l√≥gicos de FPGA (y en algunos casos bloques DSP).  Usando el algoritmo CORDIC, es posible obtener funciones de ventana de cualquier profundidad de bits (dentro de lo razonable), de cualquier longitud y orden, y por lo tanto tener un conjunto de pr√°cticamente cualquier caracter√≠stica espectral de la ventana. <br><br>  Como parte de uno de los estudios, logr√© obtener un n√∫cleo de trabajo estable de la funci√≥n de ventana Blackman-Harris de 5 y 7 √≥rdenes de magnitud en muestras 1M a una frecuencia de ~ 375 MHz, y tambi√©n hacer un generador de coeficientes rotativos para un FFT basado en CORDIC a una frecuencia de ~ 400 MHz.  Cristal FPGA usado: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Enlace al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto <b>github</b> aqu√≠</a> .  El proyecto contiene un modelo matem√°tico en Matlab, c√≥digos fuente para funciones de ventana y CORDIC en VHDL, as√≠ como modelos de las funciones de ventana enumeradas en C ++ para Vivado HLS. <br><br><h3>  Art√≠culos √∫tiles </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de la ventana DSPLib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algunas funciones de la ventana DSPlib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wiki ampliado de filtrado de ventanas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo de Wiki sobre CORDIC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de usuario de Vivado HLS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art√≠culo sobre an√°lisis espectral sobre el Habr</a> </li></ul><br>  Tambi√©n aconsejo un libro muy popular sobre DSP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ayficher E., Jervis B. Procesamiento de se√±al digital.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enfoque pr√°ctico</a> <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427361/">https://habr.com/ru/post/es427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427351/index.html">Semana de la seguridad 40: Vulnerabilidades en CMS Drupal y m√°s</a></li>
<li><a href="../es427353/index.html">Show de drones: c√≥mo coordinamos un enjambre de helic√≥pteros bailando</a></li>
<li><a href="../es427355/index.html">Compilaci√≥n de CJM, habilidades clave de director de arte y comprensi√≥n del usuario</a></li>
<li><a href="../es427357/index.html">Escribiendo sombreadores en Unity. GrabPass, PerRendererData</a></li>
<li><a href="../es427359/index.html">C√≥mo ECS, C # Job System y SRP cambian la arquitectura</a></li>
<li><a href="../es427363/index.html">Implementaci√≥n de LoRaWAN en una empresa agr√≠cola. Todo sobre construcci√≥n, lanzamiento y soluciones.</a></li>
<li><a href="../es427365/index.html">Informe de RedSlerm sobre monitoreo (Monit, Zabbix)</a></li>
<li><a href="../es427367/index.html">SOMBRERO NEGRO Conferencia de Estados Unidos. C√≥mo un hacker de Hollywood usa c√°maras de vigilancia. Parte 1</a></li>
<li><a href="../es427369/index.html">SOMBRERO NEGRO Conferencia de Estados Unidos. C√≥mo un hacker de Hollywood usa c√°maras de vigilancia. Parte 2</a></li>
<li><a href="../es427371/index.html">Video curso "Fundamentos del trabajo con anotaciones BPMN". Gratis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>