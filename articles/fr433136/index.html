<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 👱 🍌 Infrastructure System.Transactions dans le monde .NET 🖋️ 🚣🏾 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avez-vous vu une construction comme l' using (var scope = new TransactionScope(TransactionScopeOption.Required)) en C #? Cela signifie que le code exé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastructure System.Transactions dans le monde .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/433136/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/df/aq/ctdfaqnuvdjaw6tobyxja78mk-s.png"></div><br>  Avez-vous vu une construction comme l' <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> en C #?  Cela signifie que le code exécuté dans le bloc <code>using</code> est dans la transaction et après avoir quitté ce bloc, les modifications seront validées ou annulées.  Cela semble compréhensible jusqu'à ce que vous commenciez à creuser plus profondément.  Et plus vous creusez profondément, plus cela devient «étrange et étrange».  En tout cas, lorsque je me suis familiarisé avec la classe <code>TransactionScope</code> et, en général, avec les transactions .NET, tout un tas de questions se sont posées. <br><br>  Qu'est-ce que la classe <code>TransactionScope</code> ?  Dès que nous utilisons la construction <code>using (var scope = new TransactionScope())</code> , tout dans notre programme devient-il immédiatement transactionnel?  Que sont «Resource Manager» et «Transaction Manager»?  Puis-je écrire mon propre gestionnaire de ressources et comment «se connecter» à l'instance <code>TransactionScope</code> créée?  Qu'est-ce qu'une transaction distribuée et est-il vrai qu'une transaction distribuée dans SQL Server ou Oracle Database est identique à une transaction .NET distribuée? <br><br>  Dans cette publication, j'ai essayé de collecter des informations qui aident à trouver des réponses à ces questions et à mieux comprendre les transactions dans le monde .NET. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que sont les transactions et quels problèmes résolvent-elles?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelles transactions sont considérées ici</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Section TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transactions basées sur System.Transactions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est ce que c'est</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestionnaires de ressources</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de gestionnaires de ressources</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de TransactionScope</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Applicabilité des transactions logicielles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple de gestionnaire de ressources volage</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Section TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transactions distribuées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est ce que c'est</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Protocoles transactionnels</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fixation biphasique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aide-mémoire de System.Transations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Limitations et alternatives des transactions distribuées par logiciel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-ce donc dans .NET Core?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transactions distribuées et WCF</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Section TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lit d'enfant</a> </div></div><br><a name="Introduction"></a><h2>  Présentation </h2><br><a name="Transactions"></a><h4>  Que sont les transactions et quels problèmes résolvent-elles? </h4><br>  Les transactions en question ici sont des opérations qui transfèrent le système d'un état acceptable à un autre et sont garanties de ne pas laisser le système dans un état inacceptable même en cas de situations imprévues.  Le type de conditions acceptables dans le cas général dépend du contexte.  Nous considérerons ici une situation acceptable dans laquelle les données que nous traitons font partie intégrante.  Il est entendu que les modifications qui composent la transaction sont engagées ensemble ou non engagées.  De plus, les modifications apportées à une transaction peuvent être isolées des modifications apportées au système par une autre transaction.  Les exigences de base pour les transactions sont désignées par l'acronyme ACID.  Pour la première connaissance avec eux, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article sur Wikipedia</a> convient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/p7/2b/4rp72bf2l_qdxmlhawxsjslkj-i.png" width="250"></div><br>  Un exemple classique de transaction est le transfert d'argent entre deux comptes.  Dans cette situation, retirer de l'argent du compte n ° 1 sans créditer sur le compte n ° 2 est inacceptable, de la même manière que déposer sur le compte n ° 2 sans retirer du compte n ° 1. En d'autres termes, nous voulons que les deux opérations soient à la fois des retraits et des crédits - effectuée immédiatement.  Si l'un d'eux échoue, la deuxième opération ne doit pas être effectuée.  Vous pouvez appeler ce principe «tout ou rien».  De plus, il est souhaitable que les opérations soient effectuées de manière synchrone même en cas de pannes systémiques telles qu'une coupure de courant, c'est-à-dire que nous voyons le système dans un état acceptable dès qu'il devient disponible après restauration. <br><br>  En termes mathématiques, nous pouvons dire qu'en ce qui concerne le système, il y a un invariant que nous aimerions certainement conserver.  Par exemple, le montant sur les deux comptes: il est nécessaire qu'après la transaction (virement) le montant reste le même qu'avant.  Soit dit en passant, dans l'exemple classique du transfert d'argent, la comptabilité apparaît également - un domaine où le concept de transaction est apparu naturellement. <br><br>  Nous illustrons l'exemple du transfert d'argent entre deux comptes.  La première image montre la situation où le transfert de 50 roubles du compte n ° 1 au compte n ° 2 s'est terminé avec succès.  La couleur verte indique que le système est dans un état acceptable (les données sont complètes). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/az/ra/snazracqgy0u8fdxtrtksb8jc7g.png"></div><br>  Imaginez maintenant que le transfert soit effectué en dehors de la transaction et après avoir retiré de l'argent du compte n ° 1, une défaillance s'est produite, en raison de laquelle l'argent retiré n'a pas été crédité sur le compte n ° 2. Le système sera dans un état inacceptable (couleur rouge). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8h/ph/yj8hphqu7cszpcdvnboh97h3xfe.png"></div><br>  Si une erreur s'est produite entre les opérations de retrait et de crédit, mais que le transfert a été effectué dans le cadre d'une transaction, l'opération de retrait sera annulée.  Par conséquent, le système restera dans son état acceptable d'origine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/6b/wi/3d6bwim5vko1yam5mhiv1ekl9ve.png"></div><br>  Je vais donner des exemples de situations tirées de l'expérience de notre entreprise dans lesquelles les transactions sont utiles: comptabilisation des marchandises (comptabilisation du nombre de marchandises de différents types qui se trouvent dans certains magasins et en cours de route), comptabilisation des ressources de stockage (comptabilisation du volume d'une pièce occupée par des marchandises d'un certain type, volume d'une gratuit pour le placement de marchandises, la quantité de marchandises que les employés et les systèmes de stockage automatisés peuvent déplacer par jour). <br><br>  Les problèmes qui surviennent lorsque l'intégrité des données est violée sont évidents.  Les informations fournies par le système ne deviennent pas seulement fausses - elles perdent contact avec la réalité et se transforment en bêtises. <br><br><a name="KindsOfTransactions"></a><h4>  Quelles transactions sont considérées ici </h4><br>  Les avantages procurés par les transactions sont connus.  Donc, pour maintenir l'intégrité des données, avons-nous besoin d'une base de données relationnelle, car c'est là que les transactions sont effectuées?  Pas vraiment.  Il a été dit plus haut que le concept de transaction dépend du contexte, et maintenant nous allons brièvement examiner de quelles transactions nous pouvons parler lorsque nous discutons des systèmes d'information. <br><br>  Pour commencer, nous séparons les concepts de transactions du domaine sujet (transactions commerciales) et de transactions système.  Le second peut être mis en œuvre à différents endroits et de différentes manières. <br><br>  Allons du plus haut niveau - le domaine.  La personne intéressée peut déclarer qu'il existe des états acceptables et ne souhaite pas voir le système d'information en dehors de ces états.  Nous ne proposerons pas d'exemples supplémentaires: le transfert d'argent entre les comptes convient ici.  Nous précisons seulement qu'un transfert n'est pas nécessairement un transfert d'argent entre les comptes de règlement de deux clients bancaires.  La tâche de comptabilité est tout aussi importante, lorsque les comptes doivent refléter les sources et l’objet des fonds de l’organisation, et que le transfert doit refléter le changement dans la répartition des fonds par ces sources et cet objectif.  Il s'agit d'un exemple de <b>transaction de domaine sujet</b> . <br><br>  Voyons maintenant les exemples les plus courants et les plus intéressants de la mise en œuvre de transactions système.  Dans les transactions système, divers moyens techniques répondent aux exigences du domaine.  Une solution éprouvée classique de ce type est une <strong>transaction SGBD relationnelle</strong> (premier exemple).  Les systèmes de gestion de base de données modernes (à la fois relationnels <a href="">et pas très</a> ) fournissent un mécanisme de transaction qui vous permet soit d'enregistrer (valider) toutes les modifications apportées au cours de la période de travail spécifiée, soit de les annuler (annuler).  Lors de l'utilisation d'un tel mécanisme, des opérations de retrait d'argent d'un compte et de crédit sur un autre compte qui composent la transaction du domaine concerné, les moyens SGBD seront combinés en une transaction système et seront exécutés ensemble ou ne seront pas exécutés du tout. <br><br>  Bien entendu, l'utilisation d'un SGBD n'est pas nécessaire.  En gros, vous pouvez généralement implémenter le mécanisme de transaction SGBD dans votre langage de programmation préféré et profiter de l'analogue instable et bogué des outils existants.  Mais votre «vélo» peut être optimisé pour des situations spécifiques dans le domaine. <br><br>  Il existe des options plus intéressantes.  Les langages de programmation industrielle modernes (C # et Java en premier lieu) offrent des outils conçus spécifiquement pour organiser des transactions impliquant des sous-systèmes complètement différents, et pas seulement le SGBD.  Dans cette publication, nous appellerons ces logiciels de transactions.  Dans le cas de C #, il s'agit de <b>transactions à partir de l'espace de noms System.Transactions</b> (le deuxième exemple), et elles sont décrites ci-dessous. <br><br>  Avant de passer aux transactions <code>System.Transactions</code> , on ne peut manquer de mentionner un autre phénomène intéressant.  <code>System.Transactions</code> outils <code>System.Transactions</code> permettent au programmeur d'implémenter indépendamment la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mémoire de transaction programmatique</a> .  Dans ce cas, les opérations de programme qui affectent l'état du système (dans le cas des langages de programmation impératifs classiques, il s'agit d'une opération d'affectation) sont incluses par défaut dans les transactions qui peuvent être validées et annulées de la même manière que les transactions SGBD.  Avec cette approche, la nécessité d'utiliser des mécanismes de synchronisation (en C # - <code>lock</code> , en Java - <code>synchronized</code> ) est considérablement réduite.  Un autre développement de cette idée est la <strong>mémoire transactionnelle logicielle, prise en charge au niveau de la plate-forme</strong> (troisième exemple).  Un tel miracle devrait se trouver dans une langue dont l'élégance dépasse son applicabilité industrielle - Clojure.  Et pour les langues ouvrières-paysannes, il existe des bibliothèques de plug-ins qui fournissent les fonctionnalités de la mémoire transactionnelle programmatique. <br><br>  Les transactions système peuvent inclure plusieurs systèmes d'information, auquel cas elles sont distribuées.  Distribué peut être à la fois des transactions SGBD et des logiciels;  tout dépend de la fonctionnalité prise en charge par un outil de transaction particulier.  Des transactions réparties plus détaillées sont décrites dans la section correspondante.  Je vais donner une image pour faciliter la compréhension des sujets abordés. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/yd/4s/diyd4spwelqhd61eoetfacuncjm.png"></div><br><a name="TLDR1"></a><h4>  Section TL; DR </h4><br>  Il existe des processus qui consistent en plusieurs opérations indivisibles (atomiques) appliquées au système, dans le cas général pas nécessairement informatives.  Chaque opération indivisible peut laisser le système dans un état inacceptable lorsque l'intégrité des données est compromise.  Par exemple, si un transfert d'argent entre deux comptes est représenté par deux opérations indivisibles de retrait du compte n ° 1 et de crédit sur le compte n ° 2, alors une seule de ces opérations violera l'intégrité des données.  L'argent disparaît au milieu de nulle part, ou apparaît au milieu de nulle part.  Une transaction combine des opérations indivisibles afin qu'elles soient exécutées toutes ensemble (bien sûr, séquentiellement, si nécessaire) ou non exécutées du tout.  Nous pouvons parler des transactions de domaine et des transactions dans les systèmes techniques qui implémentent généralement les transactions de domaine. <br><br><a name="SystemTransactions"></a><h2>  Transactions basées sur System.Transactions </h2><br><a name="WhatIsIt1"></a><h4>  Qu'est ce que c'est </h4><br>  Dans le monde .NET, il existe un cadre logiciel conçu par les créateurs d'une plateforme de gestion des transactions.  Du point de vue d'un programmeur transactionnel, ce cadre comprend les <code>System.Transactions</code> <code>TransactionScope</code> , <code>TransactionScopeOption</code> , <code>TransactionScopeAsyncFlowOption</code> et <code>TransactionOptions</code> <code>System.Transactions</code> espace de noms <code>System.Transactions</code> .  Si nous parlons de .NET Standard, tout cela est disponible à partir de la <a href="">version 2.0</a> . <br><br>  Les transactions à partir de l'espace de noms <code>System.Transactions</code> sont basées sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la norme X / Open XA de The Open Group</a> .  Cette norme introduit de nombreux termes abordés ci-dessous et, plus important encore, décrit les transactions distribuées, qui sont également couvertes dans cette publication dans une section spéciale.  L'implémentation de transactions logicielles sur d'autres plateformes, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java, est</a> basée sur le même standard. <br><br>  Un cas d'utilisation de transaction typique pour un programmeur C # est le suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { <span class="hljs-comment"><span class="hljs-comment">// -  ,    . scope.Complete(); }</span></span></code> </pre> <br>  À l'intérieur du bloc <code>using</code> trouve le code qui effectue le travail, dont les résultats doivent être validés ou annulés tous ensemble.  Des exemples classiques d'un tel travail sont la lecture et l'écriture dans la base de données ou l'envoi et la réception de messages de la file d'attente.  Lorsque le contrôle quitte le bloc <code>using</code> , la transaction sera validée.  Si vous supprimez l'appel <code>Complete</code> , la transaction sera annulée.  Assez simple. <br><br>  Il s'avère que lors d'une annulation de transaction, toutes les opérations effectuées à l'intérieur d'un tel bloc <code>using</code> seront annulées?  Et si j'ai assigné à une variable une valeur différente, alors cette variable restaurera l'ancienne valeur?  Quand j'ai vu un design similaire pour la première fois, je le pensais.  En fait, bien sûr, tous les changements ne seront pas annulés, mais seulement des changements très <i>spéciaux</i> .  Si toutes les modifications étaient annulées, ce serait la mémoire transactionnelle logicielle décrite ci-dessus.  Voyons maintenant quelles sont ces modifications spéciales qui peuvent participer aux transactions de programme basées sur <code>System.Transactions</code> . <br><br><a name="ResourceManagers"></a><h4>  Gestionnaires de ressources </h4><br>  Pour que quelque chose prenne en charge les transactions basées sur <code>System.Transactions</code> , il est nécessaire qu'il possède des informations qu'une transaction est actuellement en cours et qu'il est enregistré dans un registre des participants aux transactions.  Vous pouvez obtenir des informations indiquant si le travail transactionnel est en cours en vérifiant la propriété statique <code>Current</code> de la classe <code>System.Transactions.Transaction</code> .  La saisie du bloc <code>using</code> du type indiqué ci-dessus ne fait que définir cette propriété, si elle n'a pas été définie auparavant.  Et pour vous inscrire en tant que participant à une transaction, vous pouvez utiliser des méthodes de type <code>Transaction.Enlist <i>Smth</i></code> .  De plus, vous devez implémenter l'interface requise par ces méthodes.  Gestionnaire de ressources - c'est juste un «quelque chose» qui prend en charge l'interaction avec les transactions de <code>System.Transactions</code> (une définition plus spécifique est donnée ci-dessous). <br><br>  Que sont les gestionnaires de ressources?  Si nous travaillons à partir de C # avec un SGBD, par exemple, SQL Server ou Oracle Database, nous utilisons généralement les pilotes appropriés et ce sont les ressources de gestion.  Dans le code, ils sont représentés par les types <code>System.Data.SqlClient.SqlConnection</code> et <code>Oracle.ManagedDataAccess.Client.OracleConnection</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ils disent également</a> que MSMQ prend en charge les transactions basées sur <code>System.Transactions</code> .  Guidé par des connaissances et des exemples tirés d'Internet, vous pouvez créer votre propre gestionnaire de ressources.  L'exemple le plus simple est donné dans la section suivante. <br><br>  En plus des gestionnaires de ressources, nous devons également avoir un gestionnaire de transactions, qui surveillera la transaction et donnera des ordres aux gestionnaires de ressources en temps opportun.  Selon les gestionnaires de ressources impliqués dans la transaction (leurs caractéristiques et leur emplacement), différents gestionnaires de transactions sont connectés au travail.  Dans ce cas, la sélection de la version appropriée est automatique et ne nécessite pas l'intervention d'un programmeur. <br><br>  Plus précisément, le gestionnaire de ressources est une instance d'une classe qui implémente l'interface spéciale <code>System.Transactions.IEnlistmentNotification</code> .  L'instance de classe, selon les instructions du client, est enregistrée en tant que participant à la transaction à l'aide de la propriété statique <code>System.Transactions.Transaction.Current</code> .  Par la suite, le gestionnaire de transactions appelle les méthodes de l'interface spécifiée si nécessaire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/ea/vp/tweavpimeod539do_fkzpr6yzrw.png"></div><br>  Il est clair qu'au moment de l'exécution, l'ensemble des gestionnaires de ressources impliqués dans la transaction peut changer.  Par exemple, après avoir entré le bloc <code>using</code> , nous pouvons d'abord faire quelque chose dans SQL Server, puis dans Oracle Database.  En fonction de cet ensemble de gestionnaires de ressources, le gestionnaire de transactions utilisé est déterminé.  Pour être plus précis, le protocole de transaction utilisé est déterminé par l'ensemble des gestionnaires de ressources, et le gestionnaire de transaction qui le prend en charge est déterminé sur la base du protocole.  Nous examinerons les protocoles transactionnels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus tard</a> lorsque nous parlerons de transactions distribuées.  Le mécanisme de sélection automatique du gestionnaire de transactions approprié au moment de l'exécution lors du changement des gestionnaires de ressources impliqués dans la transaction est appelé Promotion des transactions. <br><br><a name="KindsOfResourceManagers"></a><h4>  Types de gestionnaires de ressources </h4><br>  Les gestionnaires de ressources peuvent être divisés en deux grands groupes: durables et variables. <br><br>  Durable Resource Manager - un gestionnaire de ressources qui prend en charge une transaction même si le système d'information n'est pas disponible (par exemple, lorsque l'ordinateur redémarre).  Volatile Resource Manager - Un gestionnaire de ressources qui ne prend pas en charge une transaction si le système d'information n'est pas disponible.  Un gestionnaire de ressources incohérent prend uniquement en charge les transactions en mémoire. <br><br>  Les gestionnaires de ressources classiques à long terme sont le SGBD (ou le pilote SGBD pour la plate-forme logicielle).  Quoi qu'il arrive - au moins un dysfonctionnement du système d'exploitation, au moins une panne de courant - le SGBD garantira l'intégrité des données après son retour en état de fonctionnement.  Pour cela, bien sûr, vous devez payer quelques inconvénients, mais dans cet article, nous ne les considérerons pas.  Un exemple de gestionnaire de ressources non persistant est la mémoire transactionnelle logicielle mentionnée ci-dessus. <br><br><a name="TransactionScope"></a><h4>  Utilisation de TransactionScope </h4><br>  Lors de la création d'un objet de type <code>TransactionScope</code> vous pouvez spécifier certains paramètres. <br><br>  Tout d'abord, il existe un paramètre qui indique au runtime ce dont il a besoin: <br><br><ol><li>  Utilisez une transaction qui existe déjà à ce moment; </li><li>  Assurez-vous d'en créer un nouveau; </li><li>  à l'inverse, exécutez du code à l'intérieur d'un bloc <code>using</code> dehors d'une transaction. </li></ol><br>  L'énumération <code>System.Transactions.TransactionScopeOption</code> est responsable de tout cela. <br><br>  Deuxièmement, vous pouvez définir le niveau d'isolement des transactions.  C'est un paramètre qui vous permet de trouver un compromis entre l'indépendance du changement et la vitesse.  Le niveau le plus indépendant - sérialisable - garantit qu'il n'y a pas de situations où des modifications apportées dans une transaction qui n'ont pas encore été validées peuvent être vues dans une autre transaction.  Chaque niveau suivant ajoute une telle situation spécifique, lorsque l'exécution simultanée de transactions peut s'influencer mutuellement.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par défaut, une transaction est ouverte au niveau sérialisable, ce qui peut être désagréable (voir par exemple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce commentaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La définition du niveau d'isolement des transactions lors de la création </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est conseillée aux gestionnaires de ressources. Ils peuvent même ne pas prendre en charge tous les niveaux répertoriés </font></font><code>System.Transactions.IsolationLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En outre, il convient de garder à l'esprit que lors de l'utilisation du pool de connexions pour travailler avec la base de données, la connexion pour laquelle le niveau d'isolement des transactions a été modifié </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conservera ce niveau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors du retour au pool </font><font style="vertical-align: inherit;">. Désormais, lorsque le programmeur reçoit cette connexion du pool et s'appuie sur les valeurs par défaut, il observe un comportement inattendu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénarios de travail typiques c</font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les pièges importants (à savoir, les transactions imbriquées) sont bien couverts dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cet article sur "Habr"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="Applicability"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Applicabilité des transactions logicielles </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il faut dire que dans presque tous les systèmes d'information en exploitation commerciale, des processus sont lancés qui peuvent conduire le système à un état inacceptable. </font><font style="vertical-align: inherit;">Par conséquent, il peut être nécessaire de contrôler ces processus, de déterminer si l'état actuel du système est acceptable et, sinon, de le restaurer. </font><font style="vertical-align: inherit;">Transactions logicielles - un outil prêt à l'emploi pour maintenir le système dans un état acceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans chaque cas, il serait constructif de considérer le coût:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intégrer les processus dans l'infrastructure de transaction logicielle (ces processus doivent également être conscients </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de bien d'autres choses);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'entretien de cette infrastructure (par exemple, le coût de location d'équipement avec Windows à bord); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la formation des employés (car le sujet des transactions .NET n'est pas courant). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne devons pas oublier que le processus de transaction peut être tenu de rendre compte de ses progrès au "monde extérieur", par exemple, pour tenir un journal des actions en dehors de la transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute évidence, le rejet des transactions logicielles nécessitera la création ou la mise en œuvre de certains autres moyens de maintenir l'intégrité des données, qui auront également leur valeur. </font><font style="vertical-align: inherit;">En fin de compte, il peut y avoir des cas où les violations de l'intégrité des données sont si rares qu'il est plus facile de restaurer un état acceptable du système par des interventions chirurgicales que de maintenir un mécanisme de récupération automatique.</font></font><br><br><a name="Example"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un exemple de gestionnaire de ressources volage </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant un exemple de gestionnaire de ressources simple qui ne prend pas en charge la récupération après une défaillance du système. Nous aurons un bloc de mémoire transactionnelle logicielle qui stocke une certaine valeur qui peut être lue et écrite. En l'absence de transaction, ce bloc se comporte comme une variable normale, et en présence d'une transaction, il stocke la valeur initiale, qui peut être restaurée après l'annulation de la transaction. Le code d'un tel gestionnaire de ressources est présenté ci-dessous:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Stm</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Transactions</span></span>.<span class="hljs-title"><span class="hljs-title">IEnlistmentNotification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _current; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _original; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _enlisted; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _current; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Enlist()) { _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_enlisted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTx = System.Transactions.Transaction.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTx == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; currentTx.EnlistVolatile(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, System.Transactions.EnlistmentOptions.None); _enlisted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IEnlistmentNotification public void Commit(System.Transactions.Enlistment enlistment) { _original = _current; _enlisted = false; } public void InDoubt(System.Transactions.Enlistment enlistment) { _enlisted = false; } public void Prepare(System.Transactions.PreparingEnlistment preparingEnlistment) { preparingEnlistment.Prepared(); } public void Rollback(System.Transactions.Enlistment enlistment) { _current = _original; _enlisted = false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> IEnlistmentNotification }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On peut voir que la seule exigence formelle est l'implémentation de l'interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Parmi les intéressantes, les méthodes </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(qui ne font pas partie </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La méthode </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vérifie simplement si le code donné fonctionne dans le cadre de la transaction et, si c'est le cas, enregistre une instance de sa classe en tant que gestionnaire de ressources non constant. La méthode </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est appelée par le gestionnaire de transactions avant de valider les modifications. Notre gestionnaire de ressources signale sa disponibilité pour la validation en appelant une méthode </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui suit est un code montrant un exemple d'utilisation de notre gestionnaire de ressources:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stm&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { stm.Value = <span class="hljs-number"><span class="hljs-number">2</span></span>; scope.Complete(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lisez la propriété </font><font style="vertical-align: inherit;">immédiatement après avoir quitté le bloc </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la valeur attendue y sera attendue </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et si vous supprimez l'appel </font></font><code>scope.Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la transaction sera annulée et la propriété </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura la valeur </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définie avant le début de la transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une séquence d'appels simplifiée lors de l'utilisation de transactions est </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">illustrée dans le diagramme ci-dessous.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/je/1d/09je1dkghhmmwts6rvaufuntpna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On peut voir que dans cet exemple, toutes les possibilités offertes par l'infrastructure ne sont pas prises en compte </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous les examinerons plus en détail après avoir pris connaissance des protocoles transactionnels et des transactions distribuées dans la section suivante.</font></font><br><br><a name="TLDR2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Section TL; DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programmeur peut utiliser une classe </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour exécuter du code dans une transaction existante ou nouvelle. Une transaction est validée si et seulement si la </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode est appelée </font><font style="vertical-align: inherit;">sur une instance existante de la classe </font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, même si la méthode a été appelée avant</font></font><code>Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un programmeur peut indiquer s'il souhaite démarrer une nouvelle transaction, tirer parti d'une transaction existante ou, à l'inverse, exécuter du code en dehors d'une transaction existante. Seuls les gestionnaires de ressources sont impliqués dans la transaction - des composants logiciels qui implémentent certaines fonctionnalités. Les gestionnaires de ressources peuvent être à long terme (se remettre d'une défaillance du système) et intermittents (ne pas se remettre). Un SGBD est un exemple de gestionnaire de ressources à longue durée de vie. Le gestionnaire de ressources est coordonné par un gestionnaire de transactions - un composant logiciel qui est automatiquement sélectionné par le runtime sans la participation d'un programmeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le gestionnaire de ressources incohérent est une classe qui implémente l'interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la méthode</font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confirmant sa volonté de valider les modifications ou, inversement, signalant une annulation des modifications. </font><font style="vertical-align: inherit;">Lorsque l'appelant fait quelque chose avec le gestionnaire de ressources, il vérifie si la transaction est ouverte maintenant et si elle est ouverte, elle est enregistrée à l'aide de la méthode </font></font><code>System.Transactions.Transaction.EnlistVolatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="DistributedTransactions"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transactions distribuées </font></font></h2><br><a name="WhatIsIt2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est ce que c'est </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une transaction distribuée implique plusieurs sous-systèmes d'information (en fait, tout n'est pas aussi simple, voir plus loin ci-dessous). </font><font style="vertical-align: inherit;">Il est entendu que les modifications de tous les systèmes impliqués dans une transaction distribuée doivent être validées ou annulées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divers moyens de mise en œuvre des transactions ont été présentés ci-dessus: SGBD, infrastructure </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et mémoire transactionnelle programmatique intégrée à la plate-forme. </font><font style="vertical-align: inherit;">Les transactions distribuées peuvent également être fournies avec ces outils. </font><font style="vertical-align: inherit;">Par exemple, dans la base de données Oracle, la modification (et la lecture effective) des données de plusieurs bases de données au sein d'une même transaction les transforme automatiquement en données distribuées. </font><font style="vertical-align: inherit;">Ensuite, nous parlerons des transactions distribuées par logiciel, qui peuvent inclure des gestionnaires de ressources hétérogènes.</font></font><br><br><a name="TransactionProtocols"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocoles transactionnels </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un protocole transactionnel est un ensemble de principes par lesquels les applications impliquées dans une transaction interagissent. Dans le monde .NET, les protocoles suivants sont les plus courants. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Léger.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pas plus d'un gestionnaire de ressources durable n'est utilisé. Toutes les interactions transactionnelles se produisent dans le même domaine d'application ou le gestionnaire de ressources prend en charge la promotion et la validation en une seule phase (implémente </font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OleTx.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'interopérabilité entre plusieurs domaines d'application et plusieurs ordinateurs est autorisée. Vous pouvez utiliser de nombreux gestionnaires de ressources durables. Tous les ordinateurs participants doivent exécuter Windows. Utilisez les appels de procédure à distance (RPC). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS-AT.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interopérabilité entre plusieurs domaines d'application et plusieurs ordinateurs est autorisée. Vous pouvez utiliser de nombreux gestionnaires de ressources durables. Les ordinateurs participants peuvent exécuter différents systèmes d'exploitation, pas seulement Windows. Le protocole HTTP (Hypertext Transmission Protocol) est utilisé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il a été noté ci-dessus que le protocole de transaction actuel affecte le choix du gestionnaire de transactions, et les caractéristiques des ressources de contrôle impliquées dans la transaction influencent le choix du protocole. Nous listons maintenant les gestionnaires de transactions bien connus. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionnaire de transactions léger (LTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Introduit dans le .NET Framework 2.0 et versions ultérieures. Gère les transactions à l'aide du protocole léger. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionnaire de transactions du noyau (KTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Introduit dans Windows Vista et Windows Server 2008. Gère les transactions à l'aide du protocole léger. Il peut appeler un système de fichiers transactionnels (TxF) et un registre transactionnel (TxR) sur Windows Vista et Windows 2008. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinateur de transactions distribuées (MSDTC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gère les transactions à l'aide des protocoles OleTx et WS-AT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient également de garder à l'esprit que certains gestionnaires de ressources ne prennent pas en charge tous les protocoles répertoriés. Par exemple, MSMQ et SQL Server 2000 ne prennent pas en charge Lightweight, donc les transactions impliquant MSMQ ou SQL Server 2000 seront gérées par MSDTC, même s'ils sont les seuls participants. Techniquement, cette limitation provient du fait que les gestionnaires de ressources spécifiés, implémentant, bien sûr, l'interface</font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'implémentez pas l'interface </font></font><code>System.Transactions.IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il contient, entre autres, une méthode </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le runtime invoque, si nécessaire, pour basculer vers un gestionnaire de transactions plus raide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ambiguïté du concept de transaction distribuée devrait maintenant devenir évidente. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez définir une transaction distribuée comme une transaction à laquelle elle participe:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au moins deux des gestionnaires de ressources; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des gestionnaires de ressources arbitrairement variables et au moins deux à long terme; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au moins deux des gestionnaires de ressources nécessairement situés sur des ordinateurs différents. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, il est préférable de toujours clarifier quelles transactions particulières sont impliquées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et dans ce contexte, MSDTC est principalement discuté. </font><font style="vertical-align: inherit;">Il s'agit d'un composant logiciel de Windows qui gère les transactions distribuées. </font><font style="vertical-align: inherit;">Il existe une interface graphique pour configurer et surveiller les transactions, qui se trouve dans l'utilitaire «Services de composants», en suivant le chemin «Ordinateurs - Poste de travail - Coordinateur de transactions distribuées - DTC local».</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/35/gc/vo35gcdta3c9qx5w5cnsuxkbzz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour la configuration, sélectionnez l'élément «Propriétés» dans le menu contextuel du nœud «Local DTC», et pour surveiller les transactions distribuées, sélectionnez l'élément «Statistiques de transaction» dans le panneau central. </font></font><br><br><a name="TwoPhaseCommit"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fixation biphasique </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si plusieurs gestionnaires de ressources participent à la transaction, les résultats de leur travail peuvent différer: par exemple, l'un d'eux s'est terminé avec succès, et il est prêt à valider les modifications, et l'autre a une erreur, et il va annuler les modifications. Cependant, l'essence d'une transaction distribuée réside dans le fait que les changements dans toutes les ressources de contrôle impliquées dans la transaction sont soit validés tous ensemble, soit annulés. Par conséquent, dans de tels cas, un protocole de fixation en deux phases est généralement utilisé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, l'essence de ce protocole est la suivante. Pendant la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">première phase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les gestionnaires de ressources impliqués dans la transaction préparent des informations suffisantes pour se remettre de l'échec (s'il s'agit d'un gestionnaire de ressources à long terme) et pour une exécution réussie à la suite d'une validation. D'un point de vue technique, le gestionnaire de ressources signale qu'il a terminé la première phase en appelant la méthode </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la méthode </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ou le gestionnaire de ressources peut vous informer que les modifications ont été annulées en appelant la méthode </font></font><code>ForceRollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque tous les gestionnaires de ressources impliqués dans la transaction ont «voté», c'est-à-dire qu'ils ont informé le gestionnaire de transactions s'ils souhaitaient valider ou annuler les modifications, la </font><b><font style="vertical-align: inherit;">deuxième phase</font></b><font style="vertical-align: inherit;"> commence</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. À ce stade, les gestionnaires de ressources sont invités à valider leurs modifications (si tous les participants ont voté pour la correction) ou à refuser les modifications (si au moins un participant a voté pour la restauration). Techniquement, cela se traduit par l'invocation des méthodes </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que les gestionnaires de ressources implémentent et dans lesquelles ils invoquent la méthode </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le gestionnaire de ressources peut également appeler la méthode </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors de la première phase. Dans ce cas, il est entendu qu'il n'engagera aucun changement (par exemple, ne fonctionne que pour la lecture) et ne participera pas à la deuxième phase. En savoir plus sur la validation en deux phases </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chez Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la connexion entre le gestionnaire de transactions et au moins l'un des gestionnaires de ressources est perdue, la transaction devient gelée («dans le doute», dans le doute). </font><font style="vertical-align: inherit;">Le gestionnaire de transactions, en appelant des méthodes </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avertit les gestionnaires de ressources disponibles de cet événement qui peuvent répondre de manière appropriée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe encore une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixation triphasée</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ses modifications avec ses avantages et ses inconvénients. </font><font style="vertical-align: inherit;">Le protocole de validation en trois phases est moins courant, peut-être parce qu'il nécessite encore plus de coûts de communication entre les sous-systèmes en interaction.</font></font><br><br><a name="Interfaces"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aide-mémoire sur les interfaces System.Transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelque chose est difficile. Pour trier un peu les choses, je vais brièvement décrire les principales interfaces d'espace de noms </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessaires pour créer un gestionnaire de ressources. Voici un diagramme de classes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/rj/sx/bsrjsxptqz6w3g7l6zxawrzeyco.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEnlistmentNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le gestionnaire de ressources implémente cette interface. Le gestionnaire de transactions appelle les méthodes implémentées dans l'ordre suivant. Au cours de la première phase, il appelle la méthode </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sauf si les étoiles se sont réunies pour appeler la méthode </font></font><code>ISinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme décrit dans le paragraphe suivant). Selon cette méthode, le gestionnaire de ressources enregistre les informations nécessaires pour se remettre d'un échec, prépare la validation finale des modifications de son côté et vote pour valider ou annuler les modifications. S'il arrive une deuxième phase, en </font><font style="vertical-align: inherit;">fonction de la disponibilité des ressources et le </font><font style="vertical-align: inherit;">contrôle des résultats du vote de l'opération de contrôle est l' </font><font style="vertical-align: inherit;">une des trois méthodes: </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le gestionnaire de ressources implémente cette interface s'il souhaite fournir au gestionnaire de transactions l'opportunité d'optimiser l'exécution en réduisant la deuxième phase de validation. Si le gestionnaire de transactions ne voit qu'un seul gestionnaire de ressources, dans la première phase de validation, il essaie d'appeler la méthode du gestionnaire de ressources </font></font><code>SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(à la place </font></font><code>IEnlistmentNotification.Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et d'exclure ainsi le vote et la transition vers la deuxième phase. Cette approche présente des avantages et des inconvénients, dont Microsoft a le plus clairement parlé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITransactionPromoter.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le gestionnaire de ressources implémente cette interface (non seulement directement, mais via l'interface</font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), s'il souhaite fournir au gestionnaire de transactions la possibilité d'adhérer au protocole Lightweight même lors d'un appel à distance, jusqu'à ce que d'autres conditions surviennent nécessitant une complication du protocole. Lorsque vous devez compliquer le protocole, la méthode sera appelée </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPromotableSinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le gestionnaire de ressources implémente cette interface afin, d'une part, de mettre en œuvre l'interface </font></font><code>ITransactionPromoter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et d'autre part, afin que le gestionnaire de transactions puisse utiliser la validation en une seule phase, les méthodes d'appel </font></font><code>IPromotableSinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>IPromotableSinglePhaseNotification.Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le gestionnaire de transactions appelle une méthode </font></font><code>IPromotableSinglePhaseNotification.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour marquer l'enregistrement réussi du gestionnaire de ressources de manière simplifiée. Plus ou moins, cela peut être compris à partir d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un document Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardons un peu plus</font></font><code>System.Transactions.Enlistment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ses héritiers. Ce type d'instance est fourni par le gestionnaire de transactions lorsqu'il invoque les méthodes d'interface implémentées par le gestionnaire de ressources.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bd/xc/qibdxcddktegq5h2xnpuaelygj0.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enrôlement. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le gestionnaire de ressources peut appeler une seule méthode de ce type - </font></font><code>Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, - pour signaler la réussite de sa partie du travail. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préparation de l'inscription. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'aide d'une instance de ce type lors de la première phase de validation, le gestionnaire de ressources peut signaler son intention de valider ou d'annuler les modifications. </font><font style="vertical-align: inherit;">Un gestionnaire de ressources à longue durée de vie peut également obtenir les informations nécessaires pour récupérer d'une défaillance du système. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SinglePhaseEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'aide d'une instance de ce type, le gestionnaire de ressources peut transmettre au gestionnaire de transactions des informations sur les résultats de son travail à l'aide d'un schéma simplifié (validation en une phase).</font></font><br><br><a name="LimitationsAndAlternatives"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limitations et alternatives des transactions distribuées par logiciel </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une brève étude des opinions trouvées sur Internet montre que dans de nombreux domaines, les transactions distribuées sont démodées. Jetez un œil à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce commentaire malveillant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par exemple </font><font style="vertical-align: inherit;">. L'objet principal de la critique, qui est brièvement mentionné </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , est la nature synchrone (bloquante) des transactions distribuées. Si l'utilisateur a envoyé une demande au cours du traitement de laquelle une transaction distribuée a été organisée, il ne recevra une réponse qu'après (avec succès ou avec une erreur) que tous les sous-systèmes inclus dans la transaction aient fini de fonctionner. Dans le même temps, il existe une opinion soutenue par la recherche selon laquelle le protocole de validation en deux phases affiche de mauvaises performances, en particulier avec une augmentation du nombre de sous-systèmes impliqués dans la transaction, comme cela est mentionné, par exemple, dans</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette publication sur "Habré"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le créateur du système préfère renvoyer la réponse à l'utilisateur le plus tôt possible, en différant la coordination des données pour plus tard, alors une autre solution lui conviendra mieux. Dans le contexte du théorème de Brewer (théorème </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), nous pouvons dire que les transactions distribuées conviennent aux cas où la cohérence des données est plus importante que la disponibilité.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe d'autres restrictions pratiques sur l'utilisation des transactions distribuées par logiciel. Par exemple, il a été établi expérimentalement que les transactions distribuées utilisant le protocole OleTx ne devaient pas traverser des domaines réseau. En tout cas, de longues tentatives pour les faire travailler n'ont pas abouti. De plus, il a été révélé que l'interaction entre plusieurs instances d'Oracle Database (transactions de bases de données distribuées) impose de sérieuses restrictions sur l'applicabilité des transactions logicielles distribuées (là encore, n'a pas pu démarrer).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelles sont les alternatives aux transactions distribuées? Tout d'abord, je dois dire qu'il sera très difficile de se passer de transactions techniques (normales, non distribuées). Il y a probablement des processus dans le système qui peuvent temporairement perturber l'intégrité des données, et il sera nécessaire d'assurer en quelque sorte la surveillance de ces processus. De la même manière, en termes de domaine, un concept peut surgir qui inclut un processus mis en œuvre par un ensemble de processus dans différents systèmes techniques, qui devrait commencer et se terminer dans le domaine des données intégrales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En passant à des alternatives aux transactions distribuées, nous pouvons noter des solutions basées sur des services de messagerie, tels que RabbitMQ et Apache Kafka. Dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette publication sur "Habré",</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quatre de ces solutions sont envisagées:</font></font><br><br><ol><li>   ,        ,    ; </li><li>    ,           (Transaction Log Tailing); </li><li>       ,       ; </li><li>             (Event Sourcing). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre alternative est le modèle Saga. Il implique une cascade de sous-systèmes avec ses transactions locales. À la fin des travaux, chaque système appelle les éléments suivants (soit indépendamment, soit avec l'aide d'un coordinateur). Pour chaque transaction, il existe une transaction d'annulation correspondante, et au lieu de transférer le contrôle, le sous-système peut initier l'annulation des modifications apportées précédemment par les sous-systèmes précédents. Sur "Habré" il y a de bons articles sur le modèle "Saga". Par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette publication</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fournit des informations générales sur le maintien des principes d'ACID dans les microservices, et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cet article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> détaille un exemple d'implémentation du modèle Saga avec un coordinateur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre entreprise, certains produits utilisent avec succès les transactions distribuées par logiciel via WCF, mais il existe d'autres options. Une fois, lorsque nous avons essayé de nous faire des amis un nouveau système avec des transactions distribuées, nous avons eu de nombreux problèmes, y compris une collision avec les limitations décrites ci-dessus et des problèmes parallèles avec la mise à jour de l'infrastructure logicielle. Par conséquent, dans des conditions de pénurie de ressources pour exécuter une autre décision de capital, nous avons appliqué les tactiques suivantes. L'appelé capture les modifications dans tous les cas, mais note qu'elles sont à l'état de brouillon, de sorte que ces modifications n'affectent pas encore le fonctionnement du système appelé. Ensuite, l'appelant, lorsqu'il termine son travail via une transaction distribuée, le SGBD active les modifications apportées par le système appelé. De cette façonau lieu de transactions distribuées par logiciel, nous avons utilisé des transactions SGBD distribuées, qui dans ce cas se sont révélées beaucoup plus fiables.</font></font><br><br><a name="NetCore"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est-ce donc dans .NET Core? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans .NET Core (et même dans .NET Standard), il existe tous les types nécessaires pour organiser les transactions et créer votre propre gestionnaire de ressources. </font><font style="vertical-align: inherit;">Malheureusement, dans .NET Core, les transactions basées </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ont une sérieuse limitation: elles ne fonctionnent qu'avec le protocole Lightweight. </font><font style="vertical-align: inherit;">Par exemple, si deux gestionnaires de ressources durables sont utilisés dans le code, lors de l'exécution, l'environnement lèvera une exception dès que le deuxième gestionnaire sera appelé.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fait est qu'ils essaient de rendre .NET Core indépendant du système d'exploitation, de sorte que le lien vers les gestionnaires de transactions tels que KTM et MSDTC est exclu, à savoir qu'ils sont nécessaires pour prendre en charge les transactions avec les propriétés spécifiées. </font><font style="vertical-align: inherit;">Il est possible que la connexion des gestionnaires de transactions soit implémentée sous la forme de plugins, mais jusqu'à présent, cela a été écrit avec une fourche, vous ne pouvez donc pas encore compter sur l'utilisation industrielle des transactions distribuées dans .NET Core. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par expérience, vous pouvez vérifier les différences dans les transactions distribuées dans .NET Framework et .NET Core en écrivant le même code, en le compilant et en l'exécutant sur différentes plates-formes.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple d'un tel code qui appelle SQL Server et Oracle Database de manière séquentielle.</font></font></b> <div class="spoiler_text"><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { MsSqlServer(); Oracle(); scope.Complete(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Oracle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oracle.ManagedDataAccess.Client.OracleConnection(<span class="hljs-string"><span class="hljs-string">"User Id=some_user;Password=some_password;Data Source=some_db"</span></span>)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MsSqlServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnectionStringBuilder { DataSource = <span class="hljs-string"><span class="hljs-string">"some_computer\\some_db"</span></span>, UserID = <span class="hljs-string"><span class="hljs-string">"some_user"</span></span>, Password = <span class="hljs-string"><span class="hljs-string">"some_password"</span></span>, InitialCatalog = <span class="hljs-string"><span class="hljs-string">"some_scheme"</span></span>, Enlist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnection(builder.ConnectionString)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les projets prêts pour la construction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont sur GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'exécution de l'exemple pour .NET Core échoue. </font><font style="vertical-align: inherit;">L'emplacement et le type de l'exception levée dépendent de l'ordre de l'appel du SGBD, mais dans tous les cas, cette exception indique une opération de transaction non valide. </font><font style="vertical-align: inherit;">L'exécution de l'exemple pour .NET Framework réussit si MSDTC est en cours d'exécution à ce moment; </font><font style="vertical-align: inherit;">cependant, dans l'interface graphique de MSDTC, vous pouvez observer l'enregistrement d'une transaction distribuée.</font></font><br><br><a name="WCF"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transactions distribuées et WCF </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Communication Foundation (WCF) est le cadre .NET pour l'organisation et l'appel des services réseau. Comparé aux approches REST et ASP.NET Web API les plus en vogue, il présente ses propres avantages et inconvénients. WCF est un très bon ami des transactions .NET, et dans le monde du .NET Framework, il est pratique de l'utiliser pour organiser les transactions réparties entre le client et le service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans .NET Core, cette technologie ne fonctionne que du côté client, c'est-à-dire que vous ne pouvez pas créer un service, mais vous pouvez uniquement faire référence à un service existant. Cependant, cela n'est pas très important, car, comme mentionné ci-dessus, avec les transactions distribuées dans .NET Core, les choses ne vont pas du tout bien. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les lecteurs qui ne sont pas familiers avec WCF, voici les informations générales les plus courtes sur ce que cette technologie est en pratique. Contexte - deux systèmes d'information appelés client et service. Au moment de l'exécution, le client accède à un autre système d'information qui prend en charge le service qui l'intéresse et nécessite qu'une opération soit effectuée. La gestion est ensuite retournée au client.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer un service sur WCF, vous devez généralement écrire une interface qui décrit le contrat pour le service en cours de création et une classe qui implémente cette interface. La classe et l'interface sont marquées avec des attributs WCF spéciaux qui les distinguent du reste des types et spécifient certains détails du comportement lors de la découverte et de l'appel du service. Ces types sont enveloppés dans quelque chose qui fonctionne comme un serveur (par exemple, dans une DLL sur laquelle IIS est défini) et sont complétés par un fichier de configuration (il existe des options), où les détails de l'implémentation du service sont indiqués. Après le démarrage, le service est accessible, par exemple, à l'adresse réseau; dans le navigateur Internet, vous pouvez voir les contrats que le service demandé met en œuvre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programmeur qui souhaite accéder à un service WCF existant utilise un utilitaire de console ou une interface graphique intégrée à l'environnement de développement afin de former des types en C # (ou dans un autre langage pris en charge) qui correspondent aux contrats de service à l'adresse du service. Le fichier avec les types obtenus est inclus dans le projet d'application client, et ensuite le programmeur utilise les mêmes termes que ceux contenus dans l'interface de service, profitant des avantages de la progression (typage statique). De plus, le fichier de configuration du client précise les caractéristiques techniques du service appelé (il peut également être configuré dans le code, sans le fichier de configuration).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF prend en charge différents types de transport, de chiffrement et d'autres paramètres techniques plus subtils. </font><font style="vertical-align: inherit;">La plupart d'entre eux sont unis par le concept de "liaison" (Reliure). </font><font style="vertical-align: inherit;">Le service WCF comporte trois paramètres importants:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'adresse à laquelle il est disponible; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contraignant </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contrat (interfaces). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous ces paramètres sont définis dans les fichiers de configuration du service et du client. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre entreprise, WCF (avec et sans transactions distribuées) est largement utilisé dans les produits mis en œuvre, cependant, étant donné les tendances de la mode, son utilisation dans les nouveaux produits est toujours en question. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment lancer des transactions distribuées dans WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afin d'initier des transactions basées dans WCF </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le programmeur doit définir plusieurs attributs dans le code, s'assurer que les liaisons utilisées prennent en charge les transactions distribuées, qu'elles sont écrites sur le client et dans le service, </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et qu'un gestionnaire de transactions approprié s'exécute sur tous les ordinateurs impliqués (le plus probable , ce sera MSDTC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liaisons de transactions distribuées: NetTcpBinding, NetNamedPipeBinding, WSHttpBinding, WSDualHttpBinding et WSFederationHttpBinding. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode (opération) de l'interface de service doit être marquée d'un attribut </font></font><code>System.ServiceModel.TransactionFlowAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, avec certains paramètres d'attribut et lors de la définition du paramètre d' </font></font><code>TransactionScopeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribut </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">la </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transaction sera répartie entre le client et le service. </font><font style="vertical-align: inherit;">De plus, par défaut, le service est considéré comme votant pour valider la transaction, sauf si une exception est levée au moment de l'exécution. </font><font style="vertical-align: inherit;">Pour modifier ce comportement, vous devez définir la valeur de paramètre d' </font></font><code>TransactionAutoComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribut </font><font style="vertical-align: inherit;">correspondante </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code d'un service WCF simple qui prend en charge les transactions distribuées.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.ServiceModel.ServiceContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationContract] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyService</span></span> : <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationBehavior(TransactionScopeRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(input)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.Length; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute évidence, il ne diffère du code de service normal que par l'utilisation de l'attribut </font></font><code>System.ServiceModel.TransactionFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et par le réglage spécial de l'attribut </font></font><code>System.ServiceModel.OperationBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de configuration pour ce service.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.MyService"</span></span> behaviorConfiguration=<span class="hljs-string"><span class="hljs-string">"serviceBehavior"</span></span>&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">""</span></span> binding=<span class="hljs-string"><span class="hljs-string">"wsHttpBinding"</span></span> bindingConfiguration=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.IMyService"</span></span>/&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">"mex"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"IMetadataExchange"</span></span> binding=<span class="hljs-string"><span class="hljs-string">"mexHttpBinding"</span></span>/&gt; &lt;/service&gt; &lt;/services&gt; &lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> maxReceivedMessageSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxBufferPoolSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> transactionFlow=<span class="hljs-string"><span class="hljs-string">"true"</span></span> closeTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> openTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> receiveTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> sendTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span>&gt; &lt;security mode=<span class="hljs-string"><span class="hljs-string">"None"</span></span>/&gt; &lt;readerQuotas maxArrayLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxStringContentLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span>/&gt; &lt;/binding&gt; &lt;/wsHttpBinding&gt; &lt;/bindings&gt; &lt;/system.serviceModel&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que la liaison est de type WSHttpBinding et l'attribut est utilisé </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></div></div><br><a name="TLDR3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Section TL; DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les transactions distribuées incluent plusieurs gestionnaires de ressources et toutes les modifications doivent être validées ou annulées. Certains SGBD modernes implémentent des transactions distribuées qui fournissent un mécanisme pratique pour connecter plusieurs bases de données. Les transactions distribuées par logiciel (non implémentées dans le SGBD) peuvent inclure différentes combinaisons de gestionnaires de ressources sur différents ordinateurs exécutant des systèmes d'exploitation différents, mais elles ont des limites qui doivent être prises en compte avant de se fier à elles. Les solutions de messagerie constituent une alternative moderne aux transactions distribuées. Dans .NET Core, les transactions distribuées ne sont pas encore prises en charge.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF est l'un des outils standard et éprouvés de création et d'accès aux services dans le monde .NET, prenant en charge plusieurs types de transport et de chiffrement. </font><font style="vertical-align: inherit;">WCF est très proche des transactions distribuées basées sur </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La configuration des transactions distribuées pour WCF consiste à baliser le code avec plusieurs attributs et à ajouter quelques mots dans les fichiers de configuration du service et du client. </font><font style="vertical-align: inherit;">Toutes les liaisons WCF ne prennent pas en charge les transactions distribuées. </font><font style="vertical-align: inherit;">De plus, il est clair que les transactions dans WCF ont les mêmes limitations que sans utiliser WCF. </font><font style="vertical-align: inherit;">Jusqu'à présent, la plate-forme .NET Core vous permet uniquement d'accéder aux services sur WCF, plutôt que de les créer.</font></font><br><br><a name="Conclusion"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lit d'enfant </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet article est un aperçu des bases des transactions logicielles .NET. Certaines conclusions concernant les tendances des transactions de logiciels peuvent être trouvées dans les sections sur l'applicabilité et les limites des sujets discutés, et en conclusion, les principales thèses de la publication sont rassemblées. Je suppose qu'ils peuvent être utilisés comme une feuille de triche lorsque l'on considère les transactions logicielles comme l'une des options pour la mise en œuvre d'un système technique ou pour actualiser les informations pertinentes en mémoire. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions (domaine, SGBD, logiciels)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les exigences de domaine sont parfois formulées sous la forme de transactions - opérations qui, commençant dans le domaine des données intégrales, une fois terminées (y compris infructueuses) devraient également entrer dans le domaine des données intégrales (éventuellement déjà différentes). Ces exigences sont généralement implémentées en tant que transactions système. Un exemple classique de transaction est le transfert d'argent entre deux comptes, consistant en deux opérations indivisibles - retirer de l'argent d'un compte et créditer un autre. En plus des transactions bien connues implémentées par le SGBD, il existe également des transactions logicielles, par exemple, dans le monde .NET. Les gestionnaires de ressources sont des composants logiciels qui sont conscients de l'existence de telles transactions et peuvent y être inclus, c'est-à-dire valider ou annuler les modifications apportées.Les gestionnaires de ressources reçoivent des instructions sur la validation et l'annulation des modifications du gestionnaire de transactions, qui est le fondement de l'infrastructure</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionnaires de ressources durables et intermittents.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les gestionnaires de ressources à long terme prennent en charge la récupération de données après une défaillance du système. Les pilotes de SGBD pour .NET offrent généralement de telles fonctionnalités. Les gestionnaires de ressources intermittents </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prennent </font><b><font style="vertical-align: inherit;">pas en</font></b><font style="vertical-align: inherit;"> charge la reprise après sinistre. La mémoire transactionnelle programmatique - un moyen de gérer des objets en RAM - peut être considérée comme un exemple de gestionnaire de ressources volage. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions et gestionnaires de ressources .NET.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le programmeur .NET utilise des transactions logicielles et crée ses propres gestionnaires de ressources à l'aide de types de l'espace de noms</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette infrastructure permet d'utiliser des transactions d'imbrication et d'isolement diverses (avec des limitations connues). L'utilisation des transactions n'est pas compliquée, et elle consiste à encapsuler le code dans un bloc </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec certaines caractéristiques. Cependant, les gestionnaires de ressources inclus de cette manière dans la transaction doivent conserver pour leur part les fonctionnalités requises. L'utilisation de gestionnaires de ressources hétérogènes dans une transaction ou l'utilisation d'un gestionnaire de différentes manières peut automatiquement transformer une transaction en transaction distribuée. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions distribuées (SGBD, logiciels).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une transaction distribuée couvre plusieurs sous-systèmes, dont les changements doivent être synchronisés, c'est-à-dire qu'ils sont soit validés tous ensemble, soit annulés. Les transactions distribuées sont implémentées dans certains SGBD modernes. Les transactions distribuées par logiciel (ce ne sont pas celles qui sont implémentées par le SGBD) imposent des restrictions supplémentaires sur les processus et les plates-formes en interaction. Les transactions distribuées se dégradent progressivement pour laisser place à des solutions basées sur les services de messagerie. Pour transformer une transaction ordinaire en transaction distribuée, le programmeur n'a rien à faire: lorsqu'un gestionnaire de ressources avec certaines caractéristiques est inclus dans la transaction au moment de l'exécution, le gestionnaire de transaction fera automatiquement tout ce qu'il faut. Les transactions logicielles régulières sont disponibles dans .NET Core et .NET Standard, et les transactions distribuées ne sont pas disponibles.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions distribuées via WCF. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF est l'un des outils .NET standard pour créer et appeler des services, qui prend également en charge des protocoles standardisés. </font><font style="vertical-align: inherit;">En d'autres termes, les services WCF configurés d'une manière spécifique sont accessibles à partir de n'importe quelle application, pas seulement .NET ou Windows. </font><font style="vertical-align: inherit;">Pour créer une transaction distribuée au-dessus de WCF, vous devez baliser les types qui composent le service avec des attributs supplémentaires et apporter des modifications minimales aux fichiers de configuration du service et du client. </font><font style="vertical-align: inherit;">Vous ne pouvez pas créer de services WCF dans .NET Core et .NET Standard, mais vous pouvez créer des clients WCF. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de vérification de System.Transactions sur GitHub</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Les références</b> <div class="spoiler_text"><h4>  Concepts de base </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACID</a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ( «») <br><br><h4>     </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   X/Open XA</a> ( The Open Group) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Transaction API</a> ( «») <br> <a href="">     Cache</a> (  InterSystems) <br><br><h4>   .NET </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   .NET</a> (   Tech Blog Collection) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     TransactionScope</a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  ,     </a> ( Microsoft) <br> <a href="">   .NET Standard 2.0</a> ( .NET Standard  GitHub) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">       </a> ( YarFullStack) <br><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    «»     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     «»  </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> («») <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éditorial</font></font></b> <div class="spoiler_text"><ul><li> 20.12.2018 . </li><li> 21.12.2018  .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">OlegAxenow</a> . </li><li> 23.12.2018      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">qw1</a> . </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433136/">https://habr.com/ru/post/fr433136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433122/index.html">React-Hot-Loader v4.6</a></li>
<li><a href="../fr433126/index.html">Revue Zabbix: Comment organiser une revue de code pour surveiller la configuration</a></li>
<li><a href="../fr433128/index.html">Ce que les professionnels de l'informatique jouent et ne jouent pas (Bulletin 2018)</a></li>
<li><a href="../fr433130/index.html">Que la force soit avec nous: notre propre immunité contre le cancer</a></li>
<li><a href="../fr433132/index.html">"Calendrier des testeurs" pour décembre. Essayez une approche différente</a></li>
<li><a href="../fr433138/index.html">Cinq principes de conception de produits lors de la réservation</a></li>
<li><a href="../fr433140/index.html">Module client Google Pay prêt</a></li>
<li><a href="../fr433142/index.html">Des classiques intemporels ou un aperçu des nouveaux vecteurs d'attaque via Microsoft Office</a></li>
<li><a href="../fr433144/index.html">Sortie de .NET Core 2.2. Quoi de neuf (1 sur 3)</a></li>
<li><a href="../fr433146/index.html">[compétition] Top 25 des consoles de jeux (secouez les temps anciens)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>