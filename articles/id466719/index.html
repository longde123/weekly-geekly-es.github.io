<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ»â€ğŸš’ â™€ï¸ ğŸ‘¨ğŸ½â€ğŸš€ Profil kecepatan superlight: teori dan praktik. Bagian 1 ğŸ”¡ ğŸ´ ğŸ‘©ğŸ¿â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Dari tajuk utama, Anda sudah mengerti apa yang akan saya bicarakan. Akan ada banyak hardcore: 
 kita akan membahas Java, C, C ++, assembler, sedik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profil kecepatan superlight: teori dan praktik. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/466719/">  Hai  Dari tajuk utama, Anda sudah mengerti apa yang akan saya bicarakan.  Akan ada banyak hardcore: <br>  kita akan membahas Java, C, C ++, assembler, sedikit Linux, sedikit kernel sistem operasi.  Kami juga akan menganalisis kasus praktis, jadi artikelnya akan menjadi tiga bagian besar (cukup banyak). <br><br><img src="https://habrastorage.org/webt/mp/cl/er/mpclerfppp9jx5ciuziyfv-n8oa.png"><br><br>  Pada bagian pertama, kami akan mencoba memeras segala sesuatu dari profiler yang ada. <br>  Di bagian kedua, kami akan membuat profiler kecil kami sendiri, dan di bagian ketiga kita akan melihat bagaimana cara membuat profil yang tidak biasa untuk profil, karena alat yang ada tidak begitu cocok untuk ini.  Jika Anda siap untuk pergi dengan cara ini - Saya menunggu Anda di bawah potongan :) <br><a name="habracut"></a><br><h3>  Isi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu dan sarana pemahaman - profiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara pengambilan sampel profiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seberapa sering kita perlu mengambil sampel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pilih profiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajari perf untuk membangun profil aplikasi Java.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meningkatkan laju pengambilan sampel perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami menggunakan (secara eksplisit) acara PMU / PEBS perangkat keras</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan singkat</a> </li></ul><br><a name="1"></a><h3>  Waktu dan sarana pemahaman - profiler </h3><br>  Dari sudut pandang sehari-hari, 1 detik sangat kecil.  Tetapi kita tahu bahwa 1 detik adalah satu miliar nanodetik.  Dan biarkan dibutuhkan sekitar 4 siklus prosesor hanya dalam 1 nanodetik, dalam 1 detik banyak hal dilakukan di komputer yang dapat meningkatkan atau memperburuk kehidupan kita. <br><br>  Misalkan kita sedang mengembangkan aplikasi yang dengan sendirinya cukup kritis untuk mempercepat, dan untuk beberapa fragmen kode ini umumnya kritis.  Potongan-potongan ini dieksekusi, katakanlah, ratusan mikrodetik - cukup cepat, tetapi mereka [ <i>bagian kode</i> ] secara langsung mempengaruhi keberhasilan aplikasi kita dan jumlah uang yang diperoleh atau hilang.  Sebagai contoh <br>  saat mengirim pesanan untuk menyelesaikan transaksi pertukaran, keterlambatan 100 mikrodetik mungkin menelan biaya pertukaran 1 juta rubel atau lebih pada setiap transaksi, yang diselesaikan oleh satu, bukan dua, atau bahkan tidak seratus. <br><br>  Dan <b>tugas</b> telah ditetapkan untuk saya: di satu sisi, Anda harus mengirim semua pesanan pada saat yang sama, dan di sisi lain, mengirimkannya sehingga varians antara yang pertama dan terakhir minimal.  Artinya, itu perlu untuk profil fungsi yang mengirim pesanan ke bursa.  Tugas khas, kecuali untuk satu nuansa kecil: waktu eksekusi karakteristik dari fungsi ini <i>secara signifikan kurang dari 100 Î¼s</i> . <br><br>  Mari kita pikirkan bagaimana kita membuat profil 100 Î¼s ini untuk memahami apa yang terjadi di dalam. <br>  Apa yang harus dipertimbangkan ketika memilih alat ini? <br><br><ol><li>  Bagian kode yang menarik minat kita jarang dieksekusi, yaitu, 100 mikrodetik dieksekusi di suatu tempat satu detik sekali.  Dan ini ada di bangku tes, dan dalam produksi lebih sedikit lagi. </li><li>  Sepotong kode ini akan sulit untuk diisolasi ke dalam microbenchmark, karena mempengaruhi sebagian besar proyek, dan bahkan input / output melalui jaringan. </li><li>  Dan akhirnya, yang paling penting, saya ingin profil yang dihasilkan sesuai dengan perilaku yang akan ada di server produksi kami. </li></ol><br>  Bagaimana kita memperhitungkan semua nuansa ini dan membuat profil metode minat yang benar? <br><br>  Secara konseptual, semua profiler dapat dibagi menjadi dua kelompok profiler yang <i>menginstruksikan</i> atau <i>mengambil sampel</i> .  Mari kita pertimbangkan setiap kelompok secara terpisah. <br><br>  <b>Tooler profiler</b> menyumbang banyak overhead karena mereka memodifikasi bytecode kami dan memasukkan catatan waktu ke dalamnya.  Oleh karena itu kelemahan utama dari profiler tersebut: mereka dapat secara signifikan mempengaruhi kode yang dapat dieksekusi.  Akibatnya, akan sulit untuk mengatakan seberapa banyak profil yang dihasilkan cocok dengan perilaku di server produksi: beberapa optimasi mungkin bekerja secara berbeda, beberapa terjadi, dan beberapa tidak.  Mungkin, pada skala waktu lain - detik, menit, jam - kami akan mendapatkan data representatif.  Tetapi pada skala 100 Î¼s, optimisasi yang dipicu atau gagal dapat menyebabkan profil benar-benar tidak representatif.  Jadi mari kita lihat lebih dekat kelompok profiler lain. <br><br>  <b>Profiler sampel</b> berkontribusi baik overhead minimal atau sedang.  Alat-alat ini tidak secara langsung mempengaruhi kode yang dapat dieksekusi, dan penggunaannya memerlukan sedikit perhatian dari Anda.  Karena itu, kita akan membahas profiler samping.  Mari kita lihat data apa dan dalam bentuk apa kita akan menerima darinya. <br><br><a name="2"></a><h3>  Bagaimana cara kerja sampel profiler? </h3><br>  Untuk memahami bagaimana profiler pengambilan sampel bekerja, pertimbangkan contoh berikut - metode <b>sendToMoex</b> memanggil beberapa metode lain.  Kami melihat: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sendToMoex() { a.qqq(); b.doo(); c.ccc() } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> doo() { da(); db(); }</code> </pre> <br>  Jika kami memantau keadaan tumpukan panggilan pada saat pelaksanaan bagian program ini dan secara berkala merekamnya, kami akan mendapatkan informasi dalam kira-kira bentuk berikut: <br><br><img src="https://habrastorage.org/webt/gl/je/y5/gljey5esfyih7lqm1yjvpaxfese.png"><br><br>  Ini adalah satu set tumpukan panggilan.  Dengan asumsi bahwa sampel terdistribusi secara merata, jumlah tumpukan yang identik menunjukkan waktu eksekusi relatif dari metode yang ada di atas tumpukan. <br><br>  Dalam contoh ini, metode Da dilakukan sebanyak metode C.ccc, dan ini adalah 2 kali lebih banyak daripada metode Db.Namun, asumsi bahwa distribusi sampel bahkan mungkin tidak sepenuhnya benar, dan kemudian perkiraan waktu eksekusi akan salah. <br><br><a name="3"></a><h3>  Seberapa sering kita perlu mengambil sampel? </h3><br>  Misalkan kita ingin mengambil 1000 sampel dalam 100 mikrodetik untuk memahami apa yang diputar di dalamnya.  Selanjutnya, kita menghitung dengan proporsi sederhana bahwa jika kita perlu melakukan 1000 sampel dalam 100 Î¼s, maka itu adalah 10 juta sampel dalam 1 detik atau 10.000.000 sampel / s. <br><br><img src="https://habrastorage.org/webt/x6/rw/2j/x6rw2jbbfxfouax9ncy8hkfn3nq.png"><br><br>  Jika kita mengambil sampel dengan kecepatan ini, maka dalam satu eksekusi kode kita akan mengumpulkan 1000 sampel, mengumpulkan dan memahami apa yang bekerja dengan cepat atau lambat.  Setelah itu, kami akan menganalisis kinerja dan menyesuaikan kode. <br><br>  Namun, frekuensi 10 juta sampel per detik banyak.  Dan jika kita gagal mencapai kecepatan pembuatan profil sejak awal?  Misalkan kita mengumpulkan selama 10 Î¼s hanya 10 sampel, bukan 1000. Dalam hal ini, kita perlu menunggu eksekusi kode profil yang selanjutnya, yang akan terjadi setelah 1 detik (setelah semua, kode profil dieksekusi sekali per detik).  Jadi kami akan mengumpulkan 10 sampel lagi.  Karena mereka didistribusikan secara merata kepada kami, mereka dapat digabungkan menjadi satu set yang sama.  Cukup menunggu hingga kode yang diprofilkan dijalankan 1000/10 = 100 kali, dan kami akan mengumpulkan 1000 sampel yang diperlukan (10 sampel masing-masing 100 kali). <br><br><a name="4"></a><h3>  Pilih profiler </h3><br>  Berbekal pengetahuan teoretis ini, mari beralih ke praktik. <br><br>  Ambil <b>Async-profiler.</b>  Alat yang hebat (menggunakan panggilan mesin virtual AsyncGetCallTrace) yang mengumpulkan panggilan hingga instruksi kode byte dari mesin virtual Java.  Tingkat sampling async-profiler asli adalah <i>1000 sampel per detik</i> . <br><br>  Kami akan memecahkan proporsi sederhana: 10.000.000 sampel / detik - 1 detik, 1000 sampel / detik - X detik. <br>  Kami mendapatkan bahwa pada frekuensi sampling standar async-profiler, pembuatan profil akan memakan waktu sekitar 3 jam.  Ini waktu yang lama.  Idealnya, saya ingin merakit profil secepat mungkin, tepat pada kecepatan superluminal. <br><br>  Mari kita coba melakukan overclock <b>Async-profiler</b> .  Untuk melakukan ini, di readme, kita menemukan flag <code>-i</code> , yang menetapkan interval sampling.  Mari kita coba mengatur flag <code>-i1</code> (1 nanosecond), atau <code>-i0</code> secara umum, sehingga sampel profiler tidak berhenti.  Saya mendapat frekuensi sekitar 2,5 ribu sampel per detik.  Dalam hal ini, total durasi profil akan sekitar 1 jam.  Tentu saja, bukan 3 jam, tetapi juga tidak terlalu cepat.  Tampaknya untuk mencapai kecepatan pembuatan profil yang diperlukan, Anda perlu melakukan sesuatu yang berbeda secara kualitatif, untuk mencapai tingkat yang baru. <br><br>  Untuk mencapai frekuensi yang jauh lebih tinggi, Anda harus meninggalkan panggilan AsyncGetCallTrace dan menggunakan <b>perf</b> , profiler Linux penuh waktu yang ditemukan di setiap distribusi Linux.  Namun, perf tidak tahu apa-apa tentang Java, dan kami belum melatih perf untuk bekerja dengan Java.  Sementara itu, mari kita coba menjalankan perf dengan cara yang menakutkan ini: <br><br><pre> <code class="java hljs">$ perf record â€“F <span class="hljs-number"><span class="hljs-number">10000</span></span> -p PID -g -- sleep <span class="hljs-number"><span class="hljs-number">1</span></span> [ perf record: Woken up <span class="hljs-number"><span class="hljs-number">1</span></span> times to write data ] [ perf record: .. <span class="hljs-number"><span class="hljs-number">0.215</span></span> MB perf.data (<span class="hljs-number"><span class="hljs-number">4032</span></span> samples) ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Lebih lanjut tentang notasi</b> <div class="spoiler_text"><ul><li>  <i>catatan perf</i> berarti kami ingin merekam profil. </li><li>  Bendera <code>-F</code> dan argumen 10.000 adalah laju sampling. </li><li>  Bendera <code>-p</code> menunjukkan bahwa kami ingin profil hanya PID spesifik dari proses Java kami. </li><li>  Bendera <code>-g</code> bertanggung jawab untuk mengumpulkan tumpukan panggilan. </li><li>  Akhirnya, dengan <i>sleep 1,</i> kami membatasi entri profil menjadi 1 detik. </li></ul></div></div><br>  Mengapa kita perlu mengumpulkan tumpukan panggilan?  Kami memetakan segala sesuatu secara berurutan, dan kemudian dari data yang dikumpulkan kami mengekstrak bagian yang menarik minat kami (metode yang bertanggung jawab untuk pembentukan dan pengiriman pesanan).  Penanda bahwa sampel yang dikumpulkan milik data yang kami minati adalah keberadaan bingkai tumpukan <b>panggilan</b> metode <b>sendToMoex</b> . <br><br><a name="5"></a><h3>  Pelajari perf untuk membangun profil aplikasi Java. </h3><br>  Kami menjalankan catatan perf ... perintah, tunggu 1 detik dan jalankan skrip perf untuk melihat apa yang telah diprofilkan?  Dan kita akan melihat sesuatu yang tidak terlalu jelas: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.746571</span></span>: <span class="hljs-number"><span class="hljs-number">3745505</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53f8 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.747565</span></span>: <span class="hljs-number"><span class="hljs-number">3728336</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b5372 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.748613</span></span>: <span class="hljs-number"><span class="hljs-number">3731147</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53ef [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map)</code> </pre><br>  Tampaknya menjadi alamat, tetapi tidak ada nama metode Java.  Jadi, Anda perlu mengajar perf agar sesuai dengan alamat ini dengan nama metode. <br><br>  Dalam dunia C dan C ++, apa yang disebut informasi debug digunakan untuk mencocokkan alamat dan nama fungsi.  Korespondensi disimpan di bagian khusus dari file yang dapat dieksekusi: satu metode terletak di alamat tersebut, metode lain terletak di alamat lain.  Perf menarik informasi ini dan melakukan pemetaan. <br><br>  Jelas, kompiler JIT mesin virtual tidak menghasilkan informasi debug dalam format ini.  Kami masih memiliki cara lain - untuk menulis data tentang korespondensi alamat dan nama metode dalam file perf-map khusus, yang akan diperlakukan sebagai tambahan untuk informasi debug yang dibaca.  File perf-map ini harus ada di folder tmp dan memiliki struktur data berikut: <br><div class="scrollable-table"><table><tbody><tr><th>  Kode metode alamat mulai </th><th>  Panjang kode </th><th>  Nama metode </th></tr><tr><td>  7f99a911d600 </td><td>  120 </td><td>  java.util.AbstractCollection. &lt;init&gt; </td></tr><tr><td>  7f99a911d9c0 </td><td>  180 </td><td>  java.util.AbstractList. &lt;init&gt; </td></tr><tr><td>  7f99a911de80 </td><td>  5c0 </td><td>  java.util.Arrays.copyOf </td></tr><tr><td>  7f99a911ed40 </td><td>  140 </td><td>  java.util.ArrayList $ Itr.hasNext </td></tr><tr><td>  7f99a911f200 </td><td>  3e0 </td><td>  java.util.ArrayList $ Itr.next <br></td></tr></tbody></table></div><br>  Kolom pertama adalah alamat awal kode metode, yang kedua adalah panjangnya, kolom ketiga adalah nama metode. <br><br>  Jadi, kita perlu membuat file serupa.  Jelas, ini tidak dapat dilakukan secara manual (bagaimana kita tahu di alamat apa kompiler JIT akan menempatkan kode), jadi kita akan menggunakan skrip create-java-perf-map.sh dari proyek perf-map-agent, memberikan PID dari proses Java kita .  File sudah siap, periksa isinya, jalankan perf-script lagi. <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.867498</span></span>: cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f527 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868176</span></span>: <span class="hljs-number"><span class="hljs-number">2127960</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f57f Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868737</span></span>: <span class="hljs-number"><span class="hljs-number">1959990</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f627 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map)</code> </pre> <br>  Voila!  Kami melihat nama-nama metode java!  Apa yang baru saja terjadi: kami mengajarkan profiler perf, yang tidak tahu apa-apa tentang Java, membuat profil aplikasi Java biasa dan melihat metode hot java aplikasi ini! <br><br>  Namun, untuk menganalisis kinerja potongan program yang kami interogasi, kami tidak memiliki cukup tumpukan panggilan untuk menyaring data yang diinginkan dari semua sampel yang dikumpulkan. <br><br>  <b>Bagaimana cara mendapatkan panggilan stack?</b> <br><br>  Sekarang Anda perlu melakukan sesuatu yang lain dengan perf atau mesin virtual untuk mendapatkan tumpukan panggilan.  Untuk memahami apa yang perlu dilakukan, mari kita mundur dan melihat bagaimana tumpukan umumnya bekerja.  Bayangkan kita memiliki tiga fungsi f1, f2, f3.  Selain itu, panggilan f1 f2, dan panggilan f2 f3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f1() { f2(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f2() { f3(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f3() { ... }</code> </pre> <br>  Pada saat fungsi <code>f3</code> dieksekusi, mari kita lihat status stack.  Kami melihat register <code>rsp</code> , yang menunjuk ke bagian atas tumpukan.  Kita juga tahu bahwa stack memiliki alamat frame stack sebelumnya.  Dan bagaimana saya bisa mendapatkan panggilan-tumpukan? <br><br>  Jika kami entah bagaimana bisa mendapatkan alamat area ini, maka kami dapat membayangkan stack sebagai daftar yang terhubung dan memahami urutan panggilan yang membawa kami ke titik eksekusi saat ini. <br><br>  Apa yang kita butuhkan untuk ini?  Kami membutuhkan register rbp tambahan yang akan menunjuk ke area kuning.  Ternyata register rbp memungkinkan untuk mendapatkan stack panggilan, untuk memahami urutan yang membawa kita ke titik saat ini.  Saya sarankan membaca detail ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antarmuka Biner Aplikasi Sistem V.</a>  Ini menjelaskan bagaimana metode dipanggil di Linux. <br><br><img src="https://habrastorage.org/webt/0m/0w/vx/0m0wvx8wcaplslb7k5illbb4hbm.png"><br><br>  Kami mengerti apa masalah kami.  Kita perlu memaksa mesin virtual untuk menggunakan register rbp untuk tujuan aslinya - sebagai pointer ke awal frame stack.  Ini adalah bagaimana kompiler JIT harus menggunakan register rbp.  Ada flag PreserveFramePointer di mesin virtual untuk ini.  Ketika kami meneruskan flag ini ke mesin virtual, mesin virtual akan mulai menggunakan register rbp untuk tujuan tradisionalnya.  Dan kemudian Perf dapat memutar tumpukan.  Dan kami mendapatkan tumpukan panggilan nyata di profil.  Bendera dikontribusikan oleh Brendan Gregg yang terkenal jahat hanya dalam JDK8u60. <br><br>  Kami memulai mesin virtual dengan bendera baru.  Jalankan <code>create-java-perf-map</code> , lalu <code>perf record</code> dan <code>perf script</code> .  Sekarang kita dapat membuat profil yang akurat dengan tumpukan panggilan: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">18657</span></span> <span class="hljs-number"><span class="hljs-number">1901247.601878</span></span>: <span class="hljs-number"><span class="hljs-number">979583</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d007b10 Interpreter (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d0004e7 call_stub (...) <span class="hljs-number"><span class="hljs-number">67</span></span>d0db [unknown] (... libjvm.so) ... <span class="hljs-number"><span class="hljs-number">708</span></span>c start_thread (... libpthread<span class="hljs-number"><span class="hljs-number">-2.26</span></span>.so)</code> </pre><br>  Kami mengajarkan perf profiler, termasuk dengan sebagian besar distribusi Linux, untuk bekerja dengan aplikasi Java.  Oleh karena itu, sekarang kita tidak hanya dapat melihat bagian kode yang panas, tetapi juga urutan panggilan yang mengarah ke hot spot saat ini.  Sebuah pencapaian besar, mengingat bahwa profiler perf tidak tahu apa-apa tentang java.  Kami baru saja mengajarkan semua ini! <br><br><a name="7"></a><h3>  Meningkatkan laju pengambilan sampel perf </h3><br>  Mari kita coba untuk melakukan overclock hingga 10 juta sampel per detik.  Sekarang kita memiliki frekuensi yang jauh lebih rendah. <br><br>  Untuk mengotomatiskan semua tugas yang baru saja kita lakukan, Anda dapat menggunakan skrip <code>perf-java-record-stack</code> dari proyek perf-map-agent.  Ia memiliki pena yang luar biasa - variabel lingkungan <code>perf_record-freq</code> , yang dengannya Anda dapat mengatur frekuensi pengambilan sampel.  Pertama, mari atur 100 ribu sampel per detik dan coba jalankan.  Pesan mengerikan muncul di konsol bahwa kami telah melampaui frekuensi pengambilan sampel maksimum yang diizinkan: <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">100000</span></span> ./bin/perf-java-record-stack PID ... Maximum frequency rate (<span class="hljs-number"><span class="hljs-number">30000</span></span>) reached. Please use -F freq option <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lower value or consider tweaking /proc/sys/kernel/perf_event_max_sample_rate. ...</code> </pre><br>  Dalam kasus saya, batasnya adalah 30 ribu sampel per detik.  Perf segera mengatakan argumen kernel mana yang perlu diperbaiki, yang akan kita lakukan baik menggunakan gema sudo tee ke file yang diinginkan, atau langsung melalui <code>sysctl</code> .  Jadi: <br><br><pre> <code class="javascript hljs">$ echo <span class="hljs-string"><span class="hljs-string">'1000000'</span></span> | sudo tee /proc/sys/kernel/perf_event_max_sample_rate</code> </pre> <br>  atau lebih: <br><br><pre> <code class="javascript hljs">$ sudo sysctl kernel.perf_event_max_sample_rate=<span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre><br>  Sekarang kami memberi tahu kernel bahwa batas atas frekuensi sekarang 1 juta sampel per detik.  Kami memulai profiler lagi dan menunjukkan frekuensi 200 ribu sampel per detik.  Profiler akan bekerja selama 15 detik dan memberi kami 1 juta sampel.  Segalanya tampak baik-baik saja.  Setidaknya tidak ada pesan kesalahan yang tangguh.  Tapi frekuensi apa yang sebenarnya kita dapatkan?  Ternyata hanya 70 ribu sampel per detik.  Apa yang salah? <br><br>  Mari kita lihat output dari <code>dmesg</code> : <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">84430.412898</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">1783</span></span> &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">89700</span></span> ... [<span class="hljs-number"><span class="hljs-number">84431.618452</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">2229</span></span> &gt; <span class="hljs-number"><span class="hljs-number">2228</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">71700</span></span></code> </pre><br>  Ini adalah output dari kernel Linux.  Itu menyadari bahwa kami mengambil sampel terlalu sering, dan itu membutuhkan terlalu banyak waktu, sehingga kernel menurunkan frekuensi.  Ternyata kita perlu melepaskan pegangan lain di kernel - ini disebut <code>kernel.perf_cpu_time_max_percent</code> dan mengontrol jumlah waktu yang dapat dihabiskan kernel untuk interupsi dari perf. <br><br>  Kami akan memesan frekuensi sampling 200 ribu sampel per detik.  Dan setelah 15 detik kami mendapatkan 3 juta sampel - 200 ribu sampel per detik. <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">200000</span></span> ./bin/perf-java-record-stack PID Recording events <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> seconds ... ... [ perf record: Captured ... (<span class="hljs-number"><span class="hljs-number">2.961</span></span><span class="hljs-number"><span class="hljs-number">.252</span></span> samples) ]</code> </pre><br>  Sekarang mari kita lihat profilnya.  Jalankan <code>perf script</code> : <br><br><pre> <code class="javascript hljs">$ perf script ... java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) java ... Loop2.main (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-29621.</span></span>map) java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) ...</code> </pre><br>  Kami melihat fungsi-fungsi aneh dan modul yang dapat dieksekusi vmlinux - kernel Linux.  Ini jelas bukan kode kita.  Apa yang terjadi  Frekuensi ternyata sangat tinggi sehingga kode kernel mulai jatuh ke dalam sampel.  Artinya, semakin tinggi frekuensi yang kita naikkan, semakin banyak sampel yang tidak terkait dengan kode kita, tetapi dengan kernel Linux. <br><br>  Jalan buntu. <br><br><a name="8"></a><h3>  Kami menggunakan (secara eksplisit) acara PMU / PEBS perangkat keras </h3><br>  Kemudian saya memutuskan untuk mencoba menggunakan teknologi perangkat keras PMU / PEBS - Unit Pemantau Kinerja, Pengambilan Sampel Berbasis Kejadian yang Tepat.  Ini memungkinkan Anda untuk menerima pemberitahuan bahwa suatu peristiwa telah terjadi beberapa kali.  Ini disebut "periode."  Misalnya, kami dapat menerima pemberitahuan tentang eksekusi oleh prosesor dari setiap instruksi ke-20.  Mari kita lihat sebuah contoh.  Biarkan instruksi xor dieksekusi sekarang, dan penghitung PMU mendapatkan nilai 18;  kemudian datang instruksi mov - konter adalah 19;  dan instruksi berikutnya, <b>tambahkan% r14,% r13</b> , PMU akan ditampilkan sebagai "panas". <br><br>  Kemudian siklus baru dimulai: <code>inc</code> dieksekusi - PMU diatur ulang ke 1. Beberapa iterasi lagi dari siklus dilalui.  Pada akhirnya, kita berhenti pada instruksi <code>mov</code> , PMU terkunci 19. Pernyataan tambahan berikutnya, dan lagi kita menandainya panas.  Lihat daftar: <br><br><pre> <code class="plaintext hljs">mov aaa, bbbb xor %rdx, %rdx L_START: mov $0x0(%rbx, %rdx),%r14 add %r14, %r13 ; (PMU       "") cmp %rdx,100000000 jne L_START</code> </pre> <br>  Tidak memperhatikan keanehannya?  Siklus lima instruksi, tetapi setiap kali kita menandai instruksi yang sama seperti panas.  Jelas, ini tidak benar: semua instruksi "panas".  Mereka juga menghabiskan waktu, dan kami hanya menandai satu.  Faktanya adalah bahwa antara periode dan penghitung jumlah instruksi dalam iterasi kita memiliki faktor umum 4. Ternyata setiap iterasi keempat kita akan menandai instruksi yang sama dengan "panas".  Untuk menghindari perilaku ini, Anda harus memilih angka sebagai periode di mana probabilitas pembagi bersama antara jumlah iterasi dalam loop dan penghitung itu sendiri diminimalkan.  Idealnya, periode tersebut harus prima, yaitu  hanya berbagi pada diri sendiri dan pada unit.  Untuk contoh di atas: Anda harus memilih periode yang sama dengan 23. Kemudian kami akan secara merata menandai semua instruksi dalam siklus ini sebagai "panas". <br><br>  Teknologi PMU / PEBS telah didukung dalam bentuk modern sejak setidaknya 2009, yaitu, tersedia di hampir semua komputer.  Untuk menerapkannya secara eksplisit, mari kita modifikasi skrip <code>perf-java-record-stack</code> .  Ganti flag <code>-F</code> dengan <code>-e</code> , yang secara eksplisit menentukan penggunaan PMU / PEBS. <br><br><pre> <code class="javascript hljs">... sudo perf record -F $PERF_RECORD_FREQ ... ...</code> </pre> <br>  Mengubah naskah: <br><br><pre> <code class="javascript hljs">... sudo perf record -e cycles â€“c <span class="hljs-number"><span class="hljs-number">10007</span></span> ... ...</code> </pre> <br>  Anda sudah tahu properti apa yang harus dimiliki suatu periode - kita perlu bilangan prima.  Untuk kasus kami, ini akan menjadi periode 10007. <br><br>  Kami meluncurkan skrip perf-java-record-stack yang dimodifikasi dan dalam 15 detik menerima 4,5 juta sampel - ini hampir 300 ribu per detik, satu sampel setiap 3 Î¼s.  Yaitu, untuk satu eksekusi kode profil kami, untuk 100 Î¼s kami akan mengumpulkan 33 sampel.  Pada frekuensi ini, total waktu pengumpulan profil hanya 30 detik.  Jangan minum secangkir kopi!  Pada kenyataannya, semuanya sedikit lebih rumit.  Apa yang terjadi jika kode kita mulai dijalankan bukan sekali per detik, tetapi setiap 5 detik?  Kemudian durasi profil akan tumbuh hingga 2,5 menit, yang juga merupakan hasil yang cukup baik. <br><br>  Jadi, dalam 30 detik Anda bisa mendapatkan profil yang sepenuhnya mencakup semua kebutuhan penelitian kami.  Kemenangan <br><br>  Tetapi perasaan beberapa trik kotor tidak meninggalkan saya.  Mari kita kembali ke situasi di mana kode kita dieksekusi setiap 5 detik.  Kemudian pembuatan profil akan memakan waktu 150 detik, dan selama itu kami akan mengumpulkan sekitar 45 juta sampel.  Dari jumlah tersebut, kita hanya membutuhkan 1000, yaitu, 0,002% dari data yang dikumpulkan.  Yang lainnya adalah sampah, yang memperlambat kerja alat lain dan menambah biaya overhead.  Ya, masalahnya sudah dipecahkan, tetapi itu diselesaikan dengan dahi, kotor, gaya tumpul. <br><br>  Dan malam itu, ketika saya pertama kali mendapatkan profil yang begitu rinci dengan bantuan perf, saya bermimpi.  Saya pulang dari kerja dan berpikir, tetapi alangkah baiknya jika setrika mampu menyusun profil itu sendiri dan bahkan untuk keakuratan struktur mikro dan mikrodetik, dan kami hanya akan menganalisis hasilnya.  Akankah mimpi saya menjadi kenyataan?  Apa yang kamu pikirkan <br><br><a name="9"></a><h3>  Ringkasan singkat: </h3><br><ul><li>  Untuk membuat profil aplikasi Java menggunakan perf, Anda perlu membuat file dengan informasi tentang simbol menggunakan skrip dari proyek perf-map-agent </li><li>  Untuk mengumpulkan informasi tidak hanya tentang bagian kode yang panas, tetapi juga tumpukan, Anda perlu menjalankan mesin virtual dengan -XX: + flag PreserveFramePointer </li><li>  Jika Anda ingin meningkatkan frekuensi pengambilan sampel, Anda harus memperhatikan sysctl'i dan kernel.perf_cpu_time_max_percent dan kernel.perf_event_max_sample_rate. </li><li>  Jika sampel dari kernel yang tidak terkait dengan aplikasi mulai masuk ke profil, Anda harus berpikir tentang menentukan secara eksplisit periode PMU / PEBS. </li></ul><br>  Artikel ini (dan bagian selanjutnya) adalah transkrip laporan, yang diadaptasi dalam bentuk teks.  Jika Anda ingin tidak hanya membaca, tetapi juga mendengarkan tentang pembuatan profil, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> untuk presentasi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466719/">https://habr.com/ru/post/id466719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466701/index.html">Let's Encrypt melayani hampir 30% domain</a></li>
<li><a href="../id466705/index.html">Vivaldi Beta untuk Android - Browser Asli</a></li>
<li><a href="../id466709/index.html">Mengembangkan OS seperti Unix monolitik - Perpustakaan C (2)</a></li>
<li><a href="../id466711/index.html">Kerentanan DaOffice diizinkan untuk menghapus pengguna mana pun dari jejaring sosial</a></li>
<li><a href="../id466713/index.html">Apakah mungkin dalam 1C untuk tidak mengamati teknologi komponen eksternal? Atau Bagaimana cara memberi selamat kepada kolega menggunakan 1C?</a></li>
<li><a href="../id466721/index.html">[Yekaterinburg, pengumuman] java.ural.Meetup @ 3 - pengumuman laporan video mitap + Java ketiga dari java.ural.Meetup @ 2</a></li>
<li><a href="../id466723/index.html">Siaran Teks Apple - 10 September 2019</a></li>
<li><a href="../id466725/index.html">Belati 2 adalah unsur dasar (Bagian 1)</a></li>
<li><a href="../id466727/index.html">Upgrade malas: bagaimana PostgreSQL 12 meningkatkan kinerja</a></li>
<li><a href="../id466729/index.html">Buku "Data mining. Mengambil informasi dari Facebook, Twitter, LinkedIn, Instagram, GitHub Â»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>