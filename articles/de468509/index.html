<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚕️ 🔬 💠 Unix-ähnliche Betriebssystementwicklung - Zeichengerätetreiber (8) 🐽 🧖🏽 ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Artikel haben wir Multitasking eingeführt. Heute ist es Zeit, sich mit dem Thema Zeichengerätetreiber zu befassen. 

 Insbesondere werde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unix-ähnliche Betriebssystementwicklung - Zeichengerätetreiber (8)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468509/">  Im vorherigen Artikel haben wir Multitasking eingeführt.  Heute ist es Zeit, sich mit dem Thema Zeichengerätetreiber zu befassen. <br><br>  Insbesondere werden wir heute einen Terminaltreiber schreiben, einen Mechanismus für die verzögerte Verarbeitung von Interrupts, und das Thema Handler für die obere und untere Hälfte von Interrupts betrachten. <br><br>  Wir beginnen mit der Erstellung einer Gerätestruktur, führen dann die grundlegende Unterstützung für Datei-E / A ein und berücksichtigen die io_buf-Struktur und -Funktionen für die Arbeit mit Dateien aus stdio.h. <br><a name="habracut"></a><br><h4>  Inhaltsverzeichnis </h4><br>  Build-System (make, gcc, gas).  Erster Start (Multiboot).  Starten Sie (qemu).  C-Bibliothek (strcpy, memcpy, strext).  C-Bibliothek (sprintf, strcpy, strcmp, strtok, va_list ...).  Erstellen der Bibliothek im Kernelmodus und im Benutzeranwendungsmodus.  Das Kernel-Systemprotokoll.  Videospeicher  Ausgabe an das Terminal (kprintf, kpanic, kassert).  Dynamischer Speicher, Heap (kmalloc, kfree).  Organisation der Speicher- und Interrupt-Behandlung (GDT, IDT, PIC, Syscall).  Ausnahmen  Virtueller Speicher (Seitenverzeichnis und Seitentabelle).  Prozess.  Planer  Multitasking.  Systemaufrufe (kill, exit, ps). <br><br>  <b>Zeichengerätetreiber.</b>  <b>Systemaufrufe (ioctl, fopen, fread, fwrite).</b>  <b>C-Bibliothek (fopen, fclose, fprintf, fscanf).</b> <br><br>  Das Dateisystem des Kernels (initrd), elf und seiner Interna.  Systemaufrufe (exec).  Shell als komplettes Programm für den Kernel.  Benutzerschutzmodus (Ring3).  Aufgabenstatussegment (tss). <br><br><h4>  Charaktertreiber </h4><br>  Alles beginnt mit dem Erscheinen eines symbolischen Geräts.  Wie Sie sich erinnern, sah die Gerätedefinition in Linux-Gerätetreibern folgendermaßen aus: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_cdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev_alloc</span></span></span><span class="hljs-class">( );</span></span> my_cdev-&gt;ops = &amp;my_fops;</code> </pre> <br>  Der Hauptpunkt besteht darin, dem Gerät die Implementierung von Datei-E / A-Funktionen zuzuweisen. <br><br>  Wir werden mit einer Struktur auskommen, aber die Bedeutung wird ähnlich sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* device name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* base_r; <span class="hljs-comment"><span class="hljs-comment">/* base read address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* base_w; <span class="hljs-comment"><span class="hljs-comment">/* base write address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_read_cb_t</span></span> read_cb; <span class="hljs-comment"><span class="hljs-comment">/* read handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_write_cb_t</span></span> write_cb; <span class="hljs-comment"><span class="hljs-comment">/* write handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dev_ioctl_cb_t</span></span> ioctl_cb; <span class="hljs-comment"><span class="hljs-comment">/* device specific command handler */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* low half interrupt handlers */</span></span> };</code> </pre><br>  Jedes Gerät entspricht der Hälfte der Liste der Interrupts, die beim Generieren von Interrupts aufgerufen werden. <br><br>  Unter Linux werden solche Hälften als obere, im Gegenteil als untere (untere Ebene) bezeichnet. <br><br>  Persönlich schien es mir logischer und ich erinnerte mich versehentlich an die Begriffe umgekehrt.  Wir beschreiben jedes Element der Liste der unteren Hälften der Unterbrechungen wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number; <span class="hljs-comment"><span class="hljs-comment">/* interrupt number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ih_low_cb_t</span></span> handler; <span class="hljs-comment"><span class="hljs-comment">/* interrupt handler */</span></span> };</code> </pre><br>  Bei der Initialisierung registriert der Treiber sein Gerät über die Funktion dev_register. Mit anderen Worten, fügen Sie der Ringliste ein neues Gerät hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dev_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* create list entry */</span></span> entry = clist_insert_entry_after(&amp;dev_list, dev_list.head); device = (struct <span class="hljs-keyword"><span class="hljs-keyword">dev_t</span></span>*)entry-&gt;data; <span class="hljs-comment"><span class="hljs-comment">/* fill data */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(device-&gt;name, dev-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dev-&gt;name)); device-&gt;base_r = dev-&gt;base_r; device-&gt;base_w = dev-&gt;base_w; device-&gt;read_cb = dev-&gt;read_cb; device-&gt;write_cb = dev-&gt;write_cb; device-&gt;ioctl_cb = dev-&gt;ioctl_cb; device-&gt;ih_list.head = dev-&gt;ih_list.head; device-&gt;ih_list.slot_size = dev-&gt;ih_list.slot_size; }</code> </pre><br>  Damit dies alles irgendwie funktioniert, brauchen wir das Rudiment des Dateisystems.  Zunächst werden wir nur Dateien für Zeichengeräte haben. <br><br>  Das heißt,  Das Öffnen der Datei entspricht dem Erstellen einer DATEI-Struktur aus stdio für die entsprechende Treiberdatei. <br><br>  In diesem Fall stimmen die Dateinamen mit dem Gerätenamen überein.  Wir definieren das Konzept eines Dateideskriptors in unserer C-Bibliothek (stdio.h). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-comment"><span class="hljs-comment">/* file descriptor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* base; <span class="hljs-comment"><span class="hljs-comment">/* buffer beginning */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr; <span class="hljs-comment"><span class="hljs-comment">/* position in buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_eof; <span class="hljs-comment"><span class="hljs-comment">/* whether end of file */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* file; <span class="hljs-comment"><span class="hljs-comment">/* file definition */</span></span> }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FILE struct io_buf_t</span></span></code> </pre><br>  Lassen Sie der Einfachheit halber alle geöffneten Dateien vorerst in einer Ringliste gespeichert werden.  Das Listenelement wird wie folgt beschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io_buf</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* file handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* file name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mod_rw; <span class="hljs-comment"><span class="hljs-comment">/* whether read or write */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* whether device driver */</span></span> };</code> </pre><br>  Für jede geöffnete Datei speichern wir einen Link zum Gerät.  Wir implementieren eine Ringliste offener Dateien und implementieren die Systemaufrufe read / write / ioctl. <br><br>  Beim Öffnen einer Datei müssen wir nur die Anfangspositionen der Lese- und Schreibpuffer vom Treiber der io_buf_t-Struktur zuweisen und dementsprechend dem Geräte-Treiber Dateivorgänge zuordnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> struct io_buf_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mod_rw)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* try to find already opened file */</span></span> entry = clist_find(&amp;file_list, file_list_by_name_detector, path, mod_rw); file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)entry-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;file-&gt;io_buf; } <span class="hljs-comment"><span class="hljs-comment">/* create list entry */</span></span> entry = clist_insert_entry_after(&amp;file_list, file_list.head); file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)entry-&gt;data; <span class="hljs-comment"><span class="hljs-comment">/* whether file is device */</span></span> dev = dev_find_by_name(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev != null) { <span class="hljs-comment"><span class="hljs-comment">/* device */</span></span> file-&gt;dev = dev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod_rw == MOD_R) { file-&gt;io_buf.base = dev-&gt;base_r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod_rw == MOD_W) { file-&gt;io_buf.base = dev-&gt;base_w; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* fs node */</span></span> file-&gt;dev = null; unreachable(); <span class="hljs-comment"><span class="hljs-comment">/* fs in not implemented yet */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* fill data */</span></span> file-&gt;mod_rw = mod_rw; file-&gt;io_buf.fd = next_fd++; file-&gt;io_buf.ptr = file-&gt;io_buf.base; file-&gt;io_buf.is_eof = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; file-&gt;io_buf.file = file; <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(file-&gt;name, path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(file-&gt;name)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;file-&gt;io_buf; }</code> </pre><br>  Die Dateioperationen read / write / ioctl werden durch ein Muster definiert, wobei der Aufruf des Lesesystems als Beispiel dient. <br><br>  Die Systemaufrufe, die wir in der letzten Lektion gelernt haben zu schreiben, rufen diese Funktionen einfach auf. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">;</span></span> file = (struct <span class="hljs-keyword"><span class="hljs-keyword">file_t</span></span>*)io_buf-&gt;file; <span class="hljs-comment"><span class="hljs-comment">/* whether file is device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file-&gt;dev != null) { <span class="hljs-comment"><span class="hljs-comment">/* device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file-&gt;dev-&gt;read_cb(&amp;file-&gt;io_buf, buff, size); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* fs node */</span></span> unreachable(); <span class="hljs-comment"><span class="hljs-comment">/* fs in not implemented yet */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Kurz gesagt, sie ziehen einfach Rückrufe aus der Gerätedefinition.  Jetzt werden wir den Terminaltreiber schreiben. <br><br><h4>  Terminaltreiber </h4><br>  Wir benötigen einen Bildschirmausgabepuffer und einen Tastatureingabepuffer sowie einige Flags für den Eingabe- und Ausgabemodus. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_dev_name = TTY_DEV_NAME; <span class="hljs-comment"><span class="hljs-comment">/* teletype device name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tty_output_buff[VIDEO_SCREEN_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* teletype output buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tty_input_buff[VIDEO_SCREEN_WIDTH]; <span class="hljs-comment"><span class="hljs-comment">/* teletype input buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_output_buff_ptr = tty_output_buff; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* tty_input_buff_ptr = tty_input_buff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> read_line_mode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether read only whole line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_echo = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether to put readed symbol to stdout */</span></span></code> </pre><br>  Wir schreiben die Funktion zum Erstellen eines Geräts.  Es werden einfach Rückrufe von Dateioperationen und Handler der unteren Hälfte von Unterbrechungen abgelegt, wonach das Gerät in einer Ringliste registriert wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ih_low</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tty_output_buff, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(VIDEO_SCREEN_SIZE)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tty_input_buff, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(VIDEO_SCREEN_WIDTH)); <span class="hljs-comment"><span class="hljs-comment">/* register teletype device */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(dev.name, tty_dev_name); dev.base_r = tty_input_buff; dev.base_w = tty_output_buff; dev.read_cb = tty_read; dev.write_cb = tty_write; dev.ioctl_cb = tty_ioctl; dev.ih_list.head = null; <span class="hljs-comment"><span class="hljs-comment">/* add interrupt handlers */</span></span> dev.ih_list.slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">ih_low_t</span></span>); entry = clist_insert_entry_after(&amp;dev.ih_list, dev.ih_list.head); ih_low = (struct <span class="hljs-keyword"><span class="hljs-keyword">ih_low_t</span></span>*)entry-&gt;data; ih_low-&gt;number = INT_KEYBOARD; ih_low-&gt;handler = tty_keyboard_ih_low; dev_register(&amp;dev); }</code> </pre><br>  Der untere Interrupt-Handler für die Tastatur ist wie folgt definiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Key press low half handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_keyboard_ih_low</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ih_low_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* write character to input buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* keycode = data-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = *keycode; assert(index &lt; <span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = keyboard_map[index]; *tty_input_buff_ptr++ = ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_echo &amp;&amp; ch != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* echo character to screen */</span></span> *tty_output_buff_ptr++ = ch; } <span class="hljs-comment"><span class="hljs-comment">/* register deffered execution */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">;</span></span> msg.type = IPC_MSG_TYPE_DQ_SCHED; msg.len = <span class="hljs-number"><span class="hljs-number">4</span></span>; *((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)msg.data) = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_keyboard_ih_high; ksend(TID_DQ, &amp;msg); }</code> </pre><br>  Hier legen wir einfach das eingegebene Zeichen in den Tastaturpuffer.  Am Ende registrieren wir den verzögerten Anruf des Handlers der oberen Hälften der Tastaturunterbrechungen.  Dies erfolgt durch Senden einer Nachricht (IPC) an den Kernel-Thread. <br><br>  Der Kernel-Thread selbst ist ziemlich einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Deferred queue execution scheduler * This task running in kernel mode */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dq_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { kreceive(TID_DQ, &amp;msg); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (msg.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IPC_MSG_TYPE_DQ_SCHED: <span class="hljs-comment"><span class="hljs-comment">/* do deffered callback execution */</span></span> assert(msg.len == <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dq_handler_t</span></span> handler = (<span class="hljs-keyword"><span class="hljs-keyword">dq_handler_t</span></span>)*((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*)msg.data); assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)handler &lt; KERNEL_CODE_END_ADDR); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_DQ_SCHED, handler); handler(msg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Mit ihm wird der Handler der oberen Hälften des Tastaturinterrupts aufgerufen.  Der Zweck besteht darin, ein Zeichen auf dem Bildschirm zu duplizieren, indem der Ausgabepuffer in den Videospeicher kopiert wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Key press high half handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_keyboard_ih_high</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ video_flush(tty_output_buff); }</code> </pre><br>  Jetzt müssen die E / A-Funktionen selbst geschrieben werden, die aus Dateivorgängen aufgerufen werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Read line from tty to string */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u_int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buffer, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = buffer; assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr); assert((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff); assert(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); io_buf-&gt;is_eof = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr == (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_line_mode) { io_buf-&gt;is_eof = !<span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(io_buf-&gt;ptr, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !io_buf-&gt;is_eof; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = tty_read_ch(io_buf); *ptr++ = ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_line_mode &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)buffer; } <span class="hljs-comment"><span class="hljs-comment">/* * Write to tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size &amp;&amp; !io_buf-&gt;is_eof; ++i) { tty_write_ch(io_buf, *ptr++); } }</code> </pre><br>  Zeichenweise Operationen sind nicht viel komplizierter und ich denke nicht, dass sie kommentiert werden müssen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Write single character to tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_write_ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff_ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; VIDEO_SCREEN_SIZE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* regular character */</span></span> *tty_output_buff_ptr++ = ch; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* new line character */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line_pos = ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff_ptr - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_output_buff) % VIDEO_SCREEN_WIDTH; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; VIDEO_SCREEN_WIDTH - line_pos; ++j) { *tty_output_buff_ptr++ = <span class="hljs-string"><span class="hljs-string">' '</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tty_output_buff_ptr = video_scroll(tty_output_buff, tty_output_buff_ptr); tty_write_ch(io_buf, ch); } io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-comment"><span class="hljs-comment">/* * Read single character from tty */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_read_ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)io_buf-&gt;ptr &lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)tty_input_buff_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *io_buf-&gt;ptr++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { io_buf-&gt;is_eof = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } }</code> </pre><br>  Es bleibt nur die Steuerung der Eingabe- und Ausgabemodi zur Implementierung von ioctl. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Teletype specific command */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tty_ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* io_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* hello_msg = MSG_KERNEL_NAME; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_INIT: <span class="hljs-comment"><span class="hljs-comment">/* prepare video device */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { kmode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* detach syslog from screen */</span></span> tty_output_buff_ptr = video_clear(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; tty_write(io_buf, hello_msg, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(hello_msg)); video_flush(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_CLEAR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { <span class="hljs-comment"><span class="hljs-comment">/* fill output buffer with spaces */</span></span> tty_output_buff_ptr = video_clear(io_buf-&gt;base); video_flush(io_buf-&gt;base); io_buf-&gt;ptr = tty_output_buff_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { <span class="hljs-comment"><span class="hljs-comment">/* clear input buffer */</span></span> tty_input_buff_ptr = tty_input_buff; io_buf-&gt;ptr = io_buf-&gt;base; io_buf-&gt;is_eof = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_FLUSH: <span class="hljs-comment"><span class="hljs-comment">/* flush buffer to screen */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { video_flush(io_buf-&gt;base); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_READ_MODE_LINE: <span class="hljs-comment"><span class="hljs-comment">/* read only whole line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { read_line_mode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IOCTL_READ_MODE_ECHO: <span class="hljs-comment"><span class="hljs-comment">/* put readed symbol to stdout */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_input_buff) { is_echo = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (io_buf-&gt;base == tty_output_buff) { unreachable(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: unreachable(); } }</code> </pre><br>  Jetzt implementieren wir die Ausgabe von Dateieingaben auf der Ebene unserer Bibliothek C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Open file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> FILE* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mod_rw)</span></span></span><span class="hljs-function"> </span></span>{ FILE* result = null; asm_syscall(SYSCALL_OPEN, file, mod_rw, &amp;result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Close file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fclose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ asm_syscall(SYSCALL_CLOSE, file); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Read from file to buffer */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> u_int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asm_syscall(SYSCALL_READ, file, buff, size); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Write data to file */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fwrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, u_int size)</span></span></span><span class="hljs-function"> </span></span>{ asm_syscall(SYSCALL_WRITE, file, data, size); }</code> </pre><br>  Nun, hier sind einige Funktionen auf hoher Ebene: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Print user message */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uvnprintf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* format, u_int n, va_list </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[VIDEO_SCREEN_WIDTH]; vsnprintf(buff, n, format, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>); uputs(buff); } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Read from file to string */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uscanf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, ...)</span></span></span><span class="hljs-function"> </span></span>{ u_int readed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { readed = fread(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, buff, <span class="hljs-number"><span class="hljs-number">255</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (readed == <span class="hljs-number"><span class="hljs-number">0</span></span>); buff[readed - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* erase new line character */</span></span> uprintf(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); uflush(); }</code> </pre><br>  Um das bisherige Lesen des Formats nicht zu täuschen, lesen wir immer nur in die Zeile, als ob das% s-Flag gegeben wäre.  Ich war zu faul, um einen neuen Aufgabenstatus einzuführen, um auf Dateideskriptoren zu warten, also versuchen wir einfach, etwas in einer Endlosschleife zu lesen, bis wir erfolgreich sind. <br><br>  Das ist alles.  Jetzt können Sie Treiber sicher an Ihrem Kernel befestigen! <br><br><h4>  Referenzen </h4><br>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial</a> . <br><br>  → Quellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Git-Repository</a> (Sie benötigen eine Lektion8-Verzweigung) <br><br><h4>  Referenzliste </h4><br><ol><li>  James Molloy.  Rollen Sie Ihr eigenes UNIX-Klon-Betriebssystem. </li><li>  Zubkov.  Assembler für DOS, Windows, Unix </li><li>  Kalaschnikow.  Assembler ist einfach! </li><li>  Tanenbaum.  Betriebssysteme.  Implementierung und Entwicklung. </li><li>  Robert Love.  Linux-Kernel  Beschreibung des Entwicklungsprozesses. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468509/">https://habr.com/ru/post/de468509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468491/index.html">Hurras karmischer Fluch</a></li>
<li><a href="../de468493/index.html">Die Struktur der Luftaufnahme des Data Science-Projekts</a></li>
<li><a href="../de468497/index.html">Zeitgesteuerter 3-Minuten-Bürst-Timer</a></li>
<li><a href="../de468501/index.html">Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt</a></li>
<li><a href="../de468503/index.html">Mail geht nicht weiter 500 Meilen - FAQ</a></li>
<li><a href="../de468511/index.html">Veröffentlichen eines Servers über ein D-Link DFL-Gateway</a></li>
<li><a href="../de468515/index.html">Nützliche Tipps zur Integration in neue Projekte</a></li>
<li><a href="../de468517/index.html">2. Überblick über den technischen Support und die Garantie von Extreme Networks Switch</a></li>
<li><a href="../de468519/index.html">Erstellen Sie eine gemeinsame Codebasis</a></li>
<li><a href="../de468521/index.html">Wie wir die Informationssicherheit verallgemeinerten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>