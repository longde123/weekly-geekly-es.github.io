<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåï ‚èπÔ∏è üï∏Ô∏è 256 l√≠neas de C ++ desnudo: escribir un trazador de rayos desde cero en unas pocas horas üôçüèæ üìô ü§∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estoy publicando el pr√≥ximo cap√≠tulo de mi curso de conferencias sobre gr√°ficos por computadora ( aqu√≠ puede leer el original en ruso, aunque la versi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 l√≠neas de C ++ desnudo: escribir un trazador de rayos desde cero en unas pocas horas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Estoy publicando el pr√≥ximo cap√≠tulo de mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso de conferencias sobre gr√°ficos por computadora</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ puede leer el</a> original en ruso, aunque la versi√≥n en ingl√©s es m√°s reciente).  Esta vez, el tema de conversaci√≥n es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dibujar escenas usando el trazado de rayos</a> .  Como de costumbre, trato de evitar las bibliotecas de terceros, ya que esto hace que los estudiantes miren bajo el cap√≥. <br><br>  Ya hay muchos proyectos similares en Internet, pero casi todos muestran programas terminados que son extremadamente dif√≠ciles de entender.  Aqu√≠, por ejemplo, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa de renderizado</a> muy famoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que cabe en una tarjeta de visita</a> .  Un resultado muy impresionante, pero entender este c√≥digo es muy dif√≠cil.  Mi objetivo no es mostrar c√≥mo puedo, sino decir en detalle c√≥mo reproducir esto.  Adem√°s, me parece que esta conferencia espec√≠ficamente ni siquiera es √∫til tanto como el material de capacitaci√≥n en gr√°ficos por computadora, sino m√°s bien como una herramienta de programaci√≥n.  Siempre mostrar√© c√≥mo llegar al resultado final, comenzando desde cero: c√≥mo descomponer un problema complejo en etapas elementales solucionables. <br><br>  <i>Atenci√≥n: solo mirar mi c√≥digo, as√≠ como leer este art√≠culo con una taza de t√© en la mano, no tiene sentido.</i>  <i>Este art√≠culo est√° dise√±ado para que puedas agarrar un teclado y escribir tu propio motor.</i>  <i>Seguramente ser√° mejor que el m√≠o.</i>  <i>Bueno, ¬°o simplemente cambia el lenguaje de programaci√≥n!</i> <br><br>  Entonces, hoy mostrar√© c√≥mo dibujar tales im√°genes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Etapa uno: guarda la imagen en el disco </h1><br>  No quiero molestarme con los gestores de ventanas, el procesamiento del mouse / teclado y similares.  El resultado de nuestro programa ser√° una simple imagen guardada en el disco.  Entonces, lo primero que debemos hacer es guardar la imagen en el disco.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> yace el c√≥digo que te permite hacer esto.  D√©jame darte su archivo principal: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  En la funci√≥n principal, solo se llama a la funci√≥n render (), nada m√°s.  ¬øQu√© hay dentro de la funci√≥n render ()?  En primer lugar, defino una imagen como una matriz unidimensional de valores de framebuffer de tipo Vec3f, estos son simples vectores tridimensionales que nos dan el color (r, g, b) para cada p√≠xel. <br><br>  La clase de vectores vive en el archivo geometry.h, no lo describir√© aqu√≠: en primer lugar, todo es trivial all√≠, la manipulaci√≥n simple de vectores de dos y tres dimensiones (suma, resta, asignaci√≥n, multiplicaci√≥n por un producto escalar, escalar), y en segundo lugar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">gbg</a> ya lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describi√≥</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detalle</a> como parte de un curso de conferencias sobre gr√°ficos por computadora. <br><br>  Guardo la imagen en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato ppm</a> ;  Esta es la forma m√°s f√°cil de guardar im√°genes, aunque no siempre es la m√°s conveniente para su posterior visualizaci√≥n.  Si desea guardar en otros formatos, le recomiendo conectar una biblioteca de terceros, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">stb</a> .  Esta es una biblioteca maravillosa: es suficiente para incluir un archivo de encabezado stb_image_write.h en el proyecto, y esto permitir√° guardar incluso en png, incluso en jpg. <br><br>  En total, el objetivo de esta etapa es asegurarnos de que podemos a) crear una imagen en la memoria y escribir diferentes valores de color all√≠ b) guardar el resultado en el disco para que pueda verse en un programa de terceros.  Aqu√≠ est√° el resultado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Etapa dos, la m√°s dif√≠cil: directamente trazado de rayos </h1><br>  Esta es la etapa m√°s importante y dif√≠cil de toda la cadena.  Quiero definir una esfera en mi c√≥digo y mostrarla en la pantalla sin molestarme ni con materiales ni con iluminaci√≥n.  As√≠ es como deber√≠a verse nuestro resultado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Por conveniencia, en mi repositorio, hay una confirmaci√≥n para cada etapa;  Github hace que sea muy conveniente ver sus cambios.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠, por ejemplo</a> , lo que ha cambiado en la segunda confirmaci√≥n en comparaci√≥n con la primera. <br><br>  Para empezar: ¬øqu√© necesitamos para representar una esfera en la memoria de la computadora?  Cuatro n√∫meros son suficientes para nosotros: un vector tridimensional con el centro de la esfera y un escalar que describe el radio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Lo √∫nico no trivial en este c√≥digo es una funci√≥n que le permite verificar si un rayo dado (que se origina desde el origen en la direcci√≥n de dir) se cruza con nuestra esfera.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer</a> una descripci√≥n detallada del algoritmo para verificar la intersecci√≥n del haz y la esfera. Recomiendo encarecidamente hacerlo y verificar mi c√≥digo. <br><br>  ¬øC√≥mo funciona el trazado de rayos?  Muy simple  En la primera etapa, simplemente cubrimos la imagen con un degradado: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Ahora, para cada p√≠xel, formaremos un rayo proveniente del centro de coordenadas y pasando a trav√©s de nuestro p√≠xel, y verificaremos si este rayo se cruza con nuestra esfera. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  Si no hay intersecci√≥n con la esfera, entonces pondremos color1, de lo contrario color2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre><br>  En este punto, recomiendo tomar un l√°piz y verificar en papel todos los c√°lculos, tanto la intersecci√≥n de un rayo con una esfera como el barrido de una imagen con rayos.  Por si acaso, nuestra c√°mara est√° determinada por lo siguiente: <br><br><ul><li>  ancho de imagen </li><li>  altura de la imagen </li><li>  √°ngulo de visi√≥n, fov </li><li>  ubicaci√≥n de la c√°mara, Vec3f (0,0,0) </li><li>  direcci√≥n de la mirada, a lo largo del eje z, en la direcci√≥n de menos infinito </li></ul><br><h1>  Etapa tres: agregar m√°s esferas </h1><br>  Todo lo m√°s dif√≠cil est√° detr√°s de nosotros, ahora nuestro camino est√° despejado.  Si podemos dibujar una esfera.  entonces obviamente agregar un poco m√°s de trabajo no es dif√≠cil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ puede</a> ver los cambios en el c√≥digo, y aqu√≠ est√° el resultado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Etapa cuatro: iluminaci√≥n </h1><br>  Todos somos buenos en nuestra imagen, pero eso no es suficiente iluminaci√≥n.  En el resto del art√≠culo, solo hablaremos de esto.  Agregue algunas fuentes de luz puntuales: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Considerar la iluminaci√≥n real es una tarea muy, muy dif√≠cil, por lo tanto, como todos los dem√°s, enga√±aremos al ojo dibujando resultados completamente no f√≠sicos, pero muy probables y plausibles.  Primera observaci√≥n: ¬øpor qu√© hace fr√≠o en invierno y calor en verano?  Porque calentar la superficie de la tierra depende del √°ngulo de incidencia de la luz solar.  Cuanto m√°s alto es el sol sobre el horizonte, m√°s brillante se ilumina la superficie.  Y viceversa, cuanto m√°s bajo es el horizonte, m√°s d√©bil.  Bueno, despu√©s de que el sol se pone en el horizonte, los fotones no nos alcanzan en absoluto.  Con respecto a nuestras esferas: aqu√≠ est√° nuestro haz emitido desde la c√°mara (¬°sin relaci√≥n con los fotones, preste atenci√≥n!) Interseccionado con la esfera.  ¬øC√≥mo entendemos c√≥mo se ilumina el punto de intersecci√≥n?  Simplemente puede mirar el √°ngulo entre el vector normal en este punto y el vector que describe la direcci√≥n de la luz.  Cuanto m√°s peque√±o es el √°ngulo, mejor se ilumina la superficie.  Para hacerlo a√∫n m√°s conveniente, simplemente puede tomar el producto escalar entre el vector normal y el vector de iluminaci√≥n.  Recuerdo que el producto escalar entre dos vectores a y b es igual al producto de las normas de los vectores por el coseno del √°ngulo entre los vectores: a * b = | a |  | b |  cos (alfa (a, b)).  Si tomamos vectores de longitud unitaria, el producto escalar m√°s simple nos dar√° la intensidad de la iluminaci√≥n de la superficie. <br><br>  Por lo tanto, en la funci√≥n cast_ray, en lugar de un color constante, devolveremos el color teniendo en cuenta las fuentes de luz: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vea los</a> cambios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , pero el resultado del programa: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Etapa cinco: superficies brillantes </h1><br>  Un truco con un producto escalar entre un vector normal y un vector de luz se aproxima bastante bien a la iluminaci√≥n de superficies mate, en la literatura se llama iluminaci√≥n difusa.  ¬øQu√© hacer si queremos liso y brillante?  Quiero obtener esta foto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Vea los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pocos</a> cambios necesarios para hacerse.  En resumen, los reflejos en superficies brillantes son m√°s brillantes, cuanto menor es el √°ngulo entre la direcci√≥n de visi√≥n y la direcci√≥n de la luz <i>reflejada</i> .  Bueno, las esquinas, por supuesto, contaremos a trav√©s de productos escalares, exactamente como antes. <br><br>  Esta gimnasia con iluminaci√≥n mate y superficies brillantes se conoce como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el modelo Phong</a> .  La wiki tiene una descripci√≥n bastante detallada de este modelo de iluminaci√≥n; se lee bien en comparaci√≥n con mi c√≥digo.  Aqu√≠ hay una imagen clave para entender: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Etapa Seis: Sombras </h1><br>  ¬øPor qu√© tenemos luz, pero no sombras?  L√≠o!  Quiero esta foto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solo seis l√≠neas de c√≥digo</a> nos permiten lograr esto: al dibujar cada punto, solo nos aseguramos de que la fuente puntual de luz no se cruce con los objetos de nuestra escena, y si lo hace, la fuente de luz actual se salta.  Solo hay una peque√±a sutileza: cambio un poco el punto en la direcci√≥n de lo normal: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Por qu√©  S√≠, es solo que nuestro punto se encuentra en la superficie del objeto y (excluyendo el problema de los errores num√©ricos) cualquier rayo de este punto cruzar√° nuestra escena. <br><br><h1>  Paso siete: reflexiones </h1><br>  Esto es incre√≠ble, pero para agregar reflexiones a nuestra escena, solo necesitamos agregar tres l√≠neas de c√≥digo: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compru√©belo usted mismo:</a> en la intersecci√≥n con el objeto, simplemente contamos el rayo reflejado (¬°la funci√≥n del c√°lculo de los golpes fue √∫til!) Y llamamos recursivamente a la funci√≥n cast_ray en la direcci√≥n del rayo reflejado.  Aseg√∫rate de jugar con la <a href="">profundidad de recursi√≥n</a> , la configur√© en cuatro, comienzo desde cero, ¬øqu√© cambiar√° en la imagen?  Aqu√≠ est√° mi resultado con una reflexi√≥n de trabajo y una profundidad de cuatro: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Etapa ocho: refracci√≥n </h1><br>  Al aprender a contar las reflexiones, las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">refracciones se cuentan exactamente igual</a> .  Una funci√≥n que le permite calcular la direcci√≥n del rayo refractado (de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acuerdo con la ley de Snell</a> ) y tres l√≠neas de c√≥digo en nuestra funci√≥n recursiva cast_ray.  Aqu√≠ est√° el resultado, en el cual la bola m√°s cercana se convirti√≥ en "vidrio", refracta y refleja levemente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Etapa nueve: agrega m√°s objetos </h1><br>  ¬øPor qu√© estamos todos sin leche, pero sin leche?  Hasta este momento, representamos solo esferas, ya que este es uno de los objetos matem√°ticos no triviales m√°s simples.  Y agreguemos un pedazo del avi√≥n.  Un cl√°sico del g√©nero es un tablero de ajedrez.  Para esto, una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docena de l√≠neas</a> en una funci√≥n que considera la intersecci√≥n del haz con la escena son suficientes para nosotros. <br><br>  Bueno, aqu√≠ est√° el resultado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Como promet√≠, exactamente 256 l√≠neas de c√≥digo, ¬° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuenta por ti mismo</a> ! <br><br><h1>  Etapa Diez: Tarea </h1><br>  Hemos recorrido un camino bastante largo: aprendimos a agregar objetos a la escena, a considerar una iluminaci√≥n bastante complicada.  D√©jame dejar dos tareas como tarea.  Absolutamente todo el trabajo preparatorio ya se ha realizado en la rama de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tarea</a> .  Cada trabajo requerir√° un m√°ximo de diez l√≠neas de c√≥digo. <br><br><h3>  Tarea uno: mapa del entorno </h3><br>  Por el momento, si el rayo no cruza la escena, simplemente lo configuramos con un color constante.  ¬øY por qu√©, de hecho, permanente?  ¬°Tomemos una foto esf√©rica (archivo <a href="">envmap.jpg</a> ) y <a href="">√∫sela</a> como fondo!  Para facilitar la vida, vincul√© nuestro proyecto con la biblioteca stb para la conveniencia de trabajar con jpegs.  Esto deber√≠a ser un render como este: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  La segunda tarea: quack! </h3><br>  Podemos representar tanto esferas como planos (ver tablero de ajedrez).  ¬°Entonces agreguemos un dibujo de modelos triangulados!  Escrib√≠ un c√≥digo para leer la cuadr√≠cula de tri√°ngulos, y agregu√© una funci√≥n de intersecci√≥n tri√°ngulo de rayos all√≠.  ¬°Ahora agregar un pato a nuestra escena deber√≠a ser completamente trivial! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Conclusi√≥n </h1><br>  Mi tarea principal es mostrar proyectos que sean interesantes (¬°y f√°ciles!) Para programar, realmente espero poder hacerlo.  Esto es muy importante, ya que estoy convencido de que un programador debe escribir mucho y con gusto.  No s√© sobre usted, pero la contabilidad personal y un zapador, con una complejidad de c√≥digo bastante comparable, no me atraen en absoluto. <br><br>  Se pueden escribir doscientas cincuenta l√≠neas de trazado de rayos en unas pocas horas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quinientas l√≠neas de</a> rasterizador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> software se pueden dominar en unos pocos d√≠as.  La pr√≥xima vez clasificaremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rakecasting</a> y, al mismo tiempo, mostrar√© los juegos m√°s simples que escriben mis alumnos de primer a√±o como parte de la ense√±anza de la programaci√≥n en C ++.  Est√©n atentos! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436790/">https://habr.com/ru/post/es436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436778/index.html">defi.js es una biblioteca reactiva basada en Object.defineProperty</a></li>
<li><a href="../es436780/index.html">Errores del desarrollo instant√°neo de Google Play</a></li>
<li><a href="../es436784/index.html">Dedal (Mozilla) se mueve a Glitch</a></li>
<li><a href="../es436786/index.html">C√≥mo monitoreamos Black Hat Europe 2018</a></li>
<li><a href="../es436788/index.html">Implemente Office 2019 en un entorno empresarial (para profesionales de TI)</a></li>
<li><a href="../es436792/index.html">Conferencia DEFCON 19. An√≥nimo y nosotros. Parte 1</a></li>
<li><a href="../es436798/index.html">Deformaci√≥n profesional del administrador</a></li>
<li><a href="../es436800/index.html">T√©cnica de proyecto de bricolaje. Parte dos</a></li>
<li><a href="../es436822/index.html">Android Robotics hasta 2019: la historia real; en 5 partes; parte 3</a></li>
<li><a href="../es436828/index.html">La transici√≥n a Boost-1.65.1 y los errores que surgieron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>