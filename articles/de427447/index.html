<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦‍👦 ✋🏼 ☪️ PVS-Studio unterstützt die GNU Arm Embedded Toolchain 🤨 🖕🏼 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eingebettete Systeme haben unser Leben lange und fest geprägt. Die Anforderungen an ihre Stabilität und Zuverlässigkeit sind sehr hoch und eine Fehler...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio unterstützt die GNU Arm Embedded Toolchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/427447/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/427/f4c/fef427f4c05625dec0a8cfd484ad79d0.png" alt="GNU Arm Embedded Toolchain + PVS-Studio"></div><br>  Eingebettete Systeme haben unser Leben lange und fest geprägt.  Die Anforderungen an ihre Stabilität und Zuverlässigkeit sind sehr hoch und eine Fehlerkorrektur ist teuer.  Daher ist es für Embedded-Entwickler besonders wichtig, regelmäßig spezielle Tools zu verwenden, um die Qualität des Quellcodes sicherzustellen.  In diesem Artikel wird über die Unterstützung der GNU Arm Embedded Toolchain im PVS-Studio-Analysegerät und über Codefehler im Mbed OS-Projekt gesprochen. <br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Der PVS-Studio Analyzer unterstützt bereits mehrere kommerzielle Compiler für eingebettete Systeme, zum Beispiel: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IAR Embedded Workbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keil Embedded Development Tools für Arm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools zur Generierung von TI ARM-Code</a> </li></ul><br>  Jetzt wurde ein weiteres Entwicklertool zur Unterstützung hinzugefügt - die GNU Embedded Toolchain. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die GNU Embedded Toolchain</a> ist eine Sammlung von Compilern von Arm, die auf der GNU Compiler Collection basieren.  Die erste offizielle Veröffentlichung fand 2012 statt und seitdem wurde das Projekt zusammen mit dem GCC entwickelt. <br><br>  Der Hauptzweck der GNU Embedded Toolchain besteht darin, Code zu generieren, der auf Bare Metal ausgeführt wird, dh direkt auf dem Prozessor ohne Zwischenschicht in Form eines Betriebssystems.  Das Paket enthält Compiler für C und C ++, Assembler, eine Reihe von GNU Binutils-Dienstprogrammen und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newlib-</a> Bibliothek.  Der Quellcode für alle Komponenten ist vollständig geöffnet und unter der GNU GPL lizenziert.  Von der offiziellen Website können Sie Versionen für Windows, Linux und macOS herunterladen. <br><br><h2>  Mbed OS </h2><br>  Zum Testen des Analysators benötigen Sie so viel Quellcode wie möglich.  Normalerweise gibt es damit kein Problem, aber wenn wir uns mit eingebetteter Entwicklung befassen, die hauptsächlich auf Geräte abzielt, die in IoT enthalten sind, kann es schwierig sein, eine ausreichende Anzahl großer Projekte zu finden.  Glücklicherweise wurde dieses Problem durch spezialisierte Betriebssysteme gelöst, deren Quellcode in den meisten Fällen offen ist.  Weiter werden wir über einen von ihnen sprechen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb9/5b1/8a8/bb95b18a83f4b1b97c8cb2519c6d7018.png" alt="Mbed OS + PVS-Studio"></div><br><br>  Obwohl der Hauptzweck dieses Artikels darin besteht, über die Unterstützung der GNU Embedded Toolchain zu sprechen, ist es schwierig, viel darüber zu schreiben.  Darüber hinaus warten die Leser unserer Artikel wahrscheinlich auf eine Beschreibung einiger interessanter Fehler.  Lassen Sie uns ihre Erwartungen nicht täuschen und den Analysator für das Mbed OS-Projekt ausführen.  Dies ist ein Open Source-Betriebssystem, das mit Unterstützung von Arm entwickelt wurde. <br><br>  Offizielle Website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.mbed.com/</a> <br><br>  Quellcode: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ARMmbed/mbed-os</a> <br><br>  Die Wahl für Mbed OS fiel nicht zufällig, so beschreiben die Autoren das Projekt: <br><br>  Arm Mbed OS ist ein Open Source Embedded-Betriebssystem, das speziell für die "Dinge" im Internet der Dinge entwickelt wurde.  Es enthält alle Funktionen, die Sie zur Entwicklung eines verbundenen Produkts auf der Basis eines Arm Cortex-M-Mikrocontrollers benötigen, einschließlich Sicherheit, Konnektivität, RTOS und Treiber für Sensoren und E / A-Geräte. <br><br>  Dies ist ein ideales Build-Projekt mit der GNU Embedded Toolchain, insbesondere angesichts der Beteiligung von Arm an seiner Entwicklung.  Ich werde sofort reservieren, dass ich nicht das Ziel hatte, so viele Fehler wie möglich in einem bestimmten Projekt zu finden und anzuzeigen. Daher werden die Ergebnisse der Überprüfung kurz überprüft. <br><br><h2>  Fehler </h2><br>  Während der Überprüfung des Mbed-Betriebssystemcodes generierte der PVS-Studio-Analysator 693 Warnungen, davon 86 mit hoher Priorität.  Ich werde sie nicht alle im Detail betrachten, zumal viele von ihnen wiederholt werden oder nicht von besonderem Interesse sind.  Beispielsweise hat der Analysator viele Warnungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> (Ausdruck ist immer wahr / falsch) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">generiert</a> , die sich auf dieselben Codefragmente beziehen.  Der Analysator kann so konfiguriert werden, dass die Anzahl falscher und uninteressanter Antworten erheblich reduziert wird. Diese Aufgabe wurde jedoch beim Schreiben eines Artikels nicht gestellt.  Diejenigen, die dies wünschen, können ein Beispiel für eine solche Konfiguration sehen, die im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio-Analysatorspezifikationen am Beispiel der EFL-Kernbibliotheken, 10-15% der falsch positiven Ergebnisse</a> " beschrieben ist. <br><br>  Für den Artikel habe ich einige interessante Fehler ausgewählt, um die Funktionsweise des Analysators zu demonstrieren. <br><br><h2>  Speicherlecks </h2><br>  Beginnen wir mit der allgemeinen Fehlerklasse in C und C ++ - Speicherlecks. <br><br>  Analyzer Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> CWE-401 Die Funktion wurde beendet, ohne den Zeiger 'read_buf' loszulassen.  Ein Speicherverlust ist möglich.  cfstore_test.c 565 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> cfstore_test_init_1(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... read_buf = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(max_len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(read_buf == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { CFSTORE_ERRLOG(....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(node-&gt;key_name != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { .... ret = drv-&gt;Create(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret &lt; ARM_DRIVER_OK){ CFSTORE_ERRLOG(....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... free(read_buf); return ret; }</span></span></code> </pre> <br>  Die klassische Situation beim Arbeiten mit dynamischem Speicher.  Der von <i>malloc</i> zugewiesene Puffer wird nur innerhalb der Funktion verwendet und vor dem Beenden freigegeben.  Das Problem ist, dass dies nicht passiert, wenn die Funktion vorzeitig nicht mehr funktioniert.  Beachten Sie den gleichen Code in den <i>if-</i> Blöcken.  Höchstwahrscheinlich hat der Autor das oberste Fragment kopiert und vergessen, einen <i>kostenlosen</i> Anruf hinzuzufügen. <br><br>  Ein weiteres Beispiel ähnlich dem vorherigen. <br><br>  Analysator Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> CWE-401 Die Funktion wurde beendet, ohne den Zeiger 'Schnittstelle' loszulassen.  Ein Speicherverlust ist möglich.  nanostackemacinterface.cpp 204 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">nsapi_error_t</span></span> Nanostack::add_ethernet_interface( EMAC &amp;emac, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> default_if, Nanostack::EthernetInterface **interface_out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *mac_addr) { .... Nanostack::EthernetInterface *interface; interface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (nothrow) Nanostack::EthernetInterface(*single_phy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!interface) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NSAPI_ERROR_NO_MEMORY; } <span class="hljs-keyword"><span class="hljs-keyword">nsapi_error_t</span></span> err = interface-&gt;initialize(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } *interface_out = interface; return NSAPI_ERROR_OK; }</span></span></code> </pre> <br>  Der Zeiger auf den zugewiesenen Speicher wird über den Ausgabeparameter zurückgegeben, jedoch nur, wenn der <i>Initialisierungsaufruf</i> erfolgreich war. Im Fehlerfall tritt ein Leck auf, da die lokale <i>Schnittstellenvariable den</i> Gültigkeitsbereich verlässt und der Zeiger einfach verloren geht.  Hier sollte man entweder <i>delete</i> aufrufen oder zumindest die in der <i>Schnittstellenvariablen</i> gespeicherte Adresse nach außen geben, damit sich der aufrufende Code darum kümmern kann. <br><br><h2>  Memset </h2><br>  Die Verwendung der <i>Memset-</i> Funktion führt häufig zu Fehlern. Beispiele für die damit verbundenen Probleme finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die gefährlichste Funktion in der C / C ++ - Welt</a> ". <br><br>  Beachten Sie die folgende Warnung des Analysators: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> CWE-628 Die Funktion 'memset' verarbeitet '0'-Elemente.  Untersuchen Sie das dritte Argument.  mbed_error.c 282 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbed_error_status_t</span></span> mbed_clear_all_errors(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-comment"><span class="hljs-comment">//Clear the error and context capturing buffer memset(&amp;last_error_ctx, sizeof(mbed_error_ctx), 0); //reset error count to 0 error_count = 0; .... }</span></span></code> </pre> <br>  Der Programmierer wollte den von der <i>last_error_ctx-</i> Struktur belegten Speicher zurücksetzen, <i>verwechselte</i> jedoch das zweite und dritte Argument.  Infolgedessen werden <i>0</i> Bytes mit dem Wert <i>sizeof (mbed_error_ctx)</i> gefüllt. <br><br>  Genau der gleiche Fehler ist hundert Zeilen weiter oben vorhanden: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> CWE-628 Die Funktion 'memset' verarbeitet '0'-Elemente.  Untersuchen Sie das dritte Argument.  mbed_error.c 123 <br><br><h2>  Unbedingte 'return'-Anweisung in einer Schleife </h2><br>  Analyzer-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V612</a> CWE-670 Eine bedingungslose 'Rückgabe' innerhalb einer Schleife.  thread_network_data_storage.c 2348 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_nd_service_anycast_address_mapping_from_network_data</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thread_network_data_cache_entry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *networkDataList, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rlocAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> S_id)</span></span></span><span class="hljs-function"> </span></span>{ ns_list_foreach(<span class="hljs-keyword"><span class="hljs-keyword">thread_network_data_service_cache_entry_t</span></span>, curService, &amp;networkDataList-&gt;service_list) { <span class="hljs-comment"><span class="hljs-comment">// Go through all services if (curService-&gt;S_id != S_id) { continue; } ns_list_foreach(thread_network_data_service_server_entry_t, curServiceServer, &amp;curService-&gt;server_list) { *rlocAddress = curServiceServer-&gt;router_id; return true; // &lt;= } } return false; }</span></span></code> </pre> <br>  In diesem Snippet ist <i>ns_list_foreach</i> das Makro, das in die <i>for-</i> Anweisung erweitert wird.  Die innere Schleife führt aufgrund des Aufrufs, unmittelbar nach der Zeile zurückzukehren, in der der Ausgabeparameter der Funktion initialisiert wird, nicht mehr als eine Iteration durch.  Vielleicht funktioniert dieser Code wie beabsichtigt, aber die Verwendung der inneren Schleife sieht in diesem Zusammenhang ziemlich seltsam aus.  Höchstwahrscheinlich <i>muss die</i> Initialisierung von <i>rlocAddress</i> und das Verlassen der Funktion je nach Bedingung ausgeführt werden, sonst können Sie die innere Schleife <i>entfernen</i> . <br><br><h2>  Fehler in den Bedingungen </h2><br>  Wie ich oben sagte, hat der Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> ziemlich große Anzahl uninteressanter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547-</a> Warnungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">generiert</a> , daher habe ich sie fließend studiert und nur zwei Fälle für den Artikel geschrieben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> CWE-570 Der Ausdruck 'pcb-&gt; state == LISTEN' ist immer falsch.  lwip_tcp.c 689 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> tcp_state { CLOSED = <span class="hljs-number"><span class="hljs-number">0</span></span>, LISTEN = <span class="hljs-number"><span class="hljs-number">1</span></span>, .... }; <span class="hljs-function"><span class="hljs-function">struct tcp_pcb * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tcp_listen_with_backlog_and_err</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tcp_pcb *pcb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">u8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> backlog, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">err_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *err)</span></span></span><span class="hljs-function"> </span></span>{ .... LWIP_ERROR(<span class="hljs-string"><span class="hljs-string">"tcp_listen: pcb already connected"</span></span>, pcb-&gt;state == CLOSED, res = ERR_CLSD; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done); <span class="hljs-comment"><span class="hljs-comment">/* already listening? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pcb-&gt;state == LISTEN) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= lpcb = (struct tcp_pcb_listen*)pcb; res = ERR_ALREADY; goto done; } .... }</span></span></code> </pre> <br>  Der Analysator ist der Ansicht, dass die Bedingung <i>pcb-&gt; state == LISTEN</i> immer falsch ist. Mal <i>sehen,</i> warum. <br><br>  Vor der <i>if-Anweisung</i> wird das Makro <i>LWIP_ERROR verwendet</i> , das gemäß der Logik seiner Operation dem <i>Assert</i> ähnelt.  Seine Anzeige sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LWIP_ERROR(message, expression, handler) do { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(expression)) { \ LWIP_PLATFORM_ERROR(message); handler;}} while(0)</span></span></code> </pre> <br>  Wenn die Bedingung falsch ist, meldet das Makro einen Fehler und führt den durch den <i>Handler-</i> Parameter übergebenen Code aus. In diesem Codefragment gibt es einen bedingungslosen Sprung mit <i>goto</i> . <br><br>  In diesem Beispiel wird die Bedingung 'pcb-&gt; state == CLOSED' aktiviert, dh der Übergang zum <i>erledigten</i> Label erfolgt, wenn <i>pcb-&gt; state</i> einen anderen Wert hat.  Die <i>if-Anweisung</i> nach dem Aufruf von <i>LWIP_ERROR</i> überprüft den <i>Status pcb-&gt;</i> auf <i>LISTEN</i> . Diese Bedingung wird jedoch nie erfüllt, da der <i>Status</i> in dieser Zeile nur den Wert <i>CLOSED enthalten</i> kann. <br><br>  Betrachten Sie eine weitere Warnung in Bezug auf die Bedingungen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V517</a> CWE-570 Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  Überprüfen Sie die Zeilen: 62, 65. libdhcpv6_server.c 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">libdhcpv6_address_generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry-&gt;linkType == DHCPV6_DUID_HARDWARE_EUI64_TYPE) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { memcpy(ptr, entry-&gt;linkId, 8); *ptr ^= 2; } else if (entry-&gt;linkType == DHCPV6_DUID_HARDWARE_EUI64_TYPE)// &lt;= { *ptr++ = entry-&gt;linkId[0] ^ 2; *ptr++ = entry-&gt;linkId[1]; .... } }</span></span></code> </pre> <br>  Hier, <i>wenn</i> und <i>sonst, wenn</i> dieselbe Bedingung überprüft wird, wodurch der Code im <i>else, wenn</i> body nie ausgeführt wird.  Solche Fehler treten häufig auf, wenn Code mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Copy-Paste-</a> Methode geschrieben wird. <br><br><h2>  Eigentümerloser Ausdruck </h2><br>  Werfen wir einen Blick auf einen lustigen Code. <br><br>  Analyzer-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V607</a> Besitzerloser Ausdruck '&amp; remove_response_tlv'.  thread_discovery.c 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_discovery_response_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thread_discovery_class_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *class, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thread_discovery_response_msg_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg_buffers)</span></span></span><span class="hljs-function"> </span></span>{ .... thread_extension_discover_response_tlv_write( &amp;discover_response_tlv, class-&gt;version, linkConfiguration-&gt;securityPolicy); .... }</code> </pre> <br>  Schauen wir uns nun die <i>Makrodeklaration thread_extension_discover_response_tlv_write an</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> thread_extension_discover_response_tlv_write \ ( data, version, extension_bit)\ (data)</span></span></code> </pre> <br>  Das Makro wird in das <i>Datenargument erweitert, dh</i> sein Aufruf innerhalb der Funktion <i>thread_discovery_response_send</i> , nachdem die Vorverarbeitung in einen Ausdruck umgewandelt wurde <i>(&amp;</i> <i>remove_response_tlv</i> <i>)</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/721/781/148/721781148d58d4fcfe8a8882c16bf2c5.png" alt="Warten Sie was"></div><br><br>  Ich habe keine Kommentare.  Dies ist wahrscheinlich kein Fehler, aber ein solcher Code versetzt mich immer in einen ähnlichen Zustand wie das Bild auf dem Bild :). <br><br><h2>  Fazit </h2><br>  Die Liste der in PVS-Studio unterstützten Compiler wurde erweitert.  Wenn Sie ein Projekt haben, das für die Montage mit der GNU Arm Embedded Toolchain vorgesehen ist, empfehle ich, es mit unserem Analysegerät zu testen.  Laden Sie die Demo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunter.  Beachten Sie auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlose</a> Lizenzoption, die für einige kleine Projekte geeignet ist. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Yuri Minaev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio unterstützt jetzt GNU Arm Embedded Toolchain</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427447/">https://habr.com/ru/post/de427447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427435/index.html">STM32H7 - Uhreinstellung ohne HAL</a></li>
<li><a href="../de427437/index.html">Verbindungsserver konfigurieren: MS SQL Server und Teradata</a></li>
<li><a href="../de427439/index.html">Die ganze Wahrheit über RTOS. Artikel 16. Signale</a></li>
<li><a href="../de427441/index.html">Konvergenz mit Kubernetes</a></li>
<li><a href="../de427443/index.html">Vivisektion des Erfolgs</a></li>
<li><a href="../de427449/index.html">Wie man Tensorflow versteht und nicht stirbt und sogar etwas über ein Auto lehrt</a></li>
<li><a href="../de427451/index.html">Verbinden Sie phpStorm-Tasks mit Bitrix24</a></li>
<li><a href="../de427453/index.html">Wie ich die Tonübertragung auf dem Raspberry Pi gemacht habe</a></li>
<li><a href="../de427457/index.html">Die dritte Welle von KI und Systemen für die Staatssicherheit</a></li>
<li><a href="../de427459/index.html">Diall LED-Lampen aus dem Castorama Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>