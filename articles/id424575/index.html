<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏾 🔷 ⏬ Ubah ukuran jip video dengan cepat 📇 ☔️ 👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam aplikasi untuk bekerja dengan gambar, tugas mengubah ukuran jip (gambar dikompresi menggunakan algoritma JPEG) sangat umum. Dalam hal ini, Anda ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ubah ukuran jip video dengan cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424575/">  Dalam aplikasi untuk bekerja dengan gambar, tugas mengubah ukuran jip (gambar dikompresi menggunakan algoritma JPEG) sangat umum.  Dalam hal ini, Anda tidak dapat segera mengubah ukuran dan Anda harus terlebih dahulu memecahkan kode data asli.  Tidak ada yang rumit dan baru dalam hal ini, tetapi jika Anda perlu melakukannya jutaan kali sehari, maka mengoptimalkan kinerja solusi semacam itu, yang seharusnya sangat cepat, adalah sangat penting. <br><br><img src="https://habrastorage.org/webt/ty/1c/gm/ty1cgmvqp5rt915vpx9whsdr5gw.jpeg"><br><a name="habracut"></a><br>  Masalah ini sering dihadapi ketika mengatur hosting jarak jauh untuk repositori gambar, karena sebagian besar kamera dan ponsel merekam dalam format JPEG.  Setiap hari, arsip foto dari layanan web terkemuka (jejaring sosial, forum, hosting foto dan banyak lainnya) diisi ulang dengan sejumlah besar gambar seperti itu, sehingga pertanyaan tentang bagaimana menyimpan gambar tersebut sangat penting.  Untuk mengurangi ukuran lalu lintas keluar dan untuk meningkatkan waktu respons terhadap permintaan pengguna, banyak layanan web menyimpan lusinan file untuk satu gambar dalam resolusi berbeda.  Kecepatan responsnya bagus, tetapi salinan ini memakan banyak ruang.  Ini adalah masalah besar, meskipun ada kelemahan lain dari pendekatan ini. <br><br>  Gagasan untuk menyelesaikan masalah ini bukan untuk menyimpan di server banyak pilihan untuk gambar asli dalam resolusi yang berbeda, tetapi untuk secara dinamis membuat gambar yang diinginkan dengan dimensi yang diberikan dari aslinya yang disiapkan sebelumnya, dan secepat mungkin.  Dengan demikian, secara real time, Anda dapat membuat gambar dari resolusi yang diinginkan dan segera mengirimkannya kepada pengguna.  Sangat penting bahwa resolusi gambar ini dapat segera dibuat sehingga perangkat pengguna tidak melakukan pengubahan ukuran layar, karena itu tidak akan diperlukan. <br><br>  Menggunakan format selain JPEG sebagai dasar untuk mengatur repositori gambar seperti itu tampaknya tidak dibenarkan.  Tentu saja, ada format standar, banyak digunakan yang memberikan kompresi lebih baik dengan kualitas yang sama (JPEG2000, WebP), tetapi kecepatan encoding dan decoding gambar tersebut sangat rendah dibandingkan dengan JPEG, sehingga masuk akal untuk memilih JPEG sebagai format dasar untuk menyimpan foto asli, yang, jika perlu, akan diskalakan secara real time setelah menerima permintaan dari pengguna. <br><br>  Tentu saja, selain jip, setiap situs paling sering memiliki gambar PNG dan GIF, tetapi biasanya jumlahnya relatif kecil dan foto dalam format ini sangat jarang.  Oleh karena itu, format ini tidak akan membuat dampak yang signifikan pada tugas yang dimaksud dalam kebanyakan kasus. <br><br><h2>  Deskripsi algoritma pengubahan ukuran dengan cepat </h2><br>  Jadi, data input adalah file JPEG, dan untuk mencapai decoding cepat (ini berlaku untuk CPU dan GPU), gambar yang dikompresi harus memiliki marker restart bawaan.  Marker ini dijelaskan dalam standar JPEG dan bagian dari codec dapat bekerja dengannya, sisanya tahu cara untuk tidak melihatnya.  Jika jip tidak memiliki spidol seperti itu, mereka dapat ditambahkan terlebih dahulu menggunakan utilitas jpegtran.  Ketika marker ditambahkan, gambar tidak berubah, tetapi ukuran file menjadi sedikit lebih besar.  Hasilnya, kami mendapatkan skema kerja berikut: <br><br><ol><li>  Dapatkan data gambar dari memori CPU </li><li>  Jika ada profil warna, dapatkan dari bagian EXIF ​​dan simpan </li><li>  Salin gambar ke kartu video </li><li>  Dekode JPEG </li><li>  Kami melakukan pengubahan ukuran sesuai dengan algoritma Lanczos (berkurang) </li><li>  Ketajaman </li><li>  Kami menyandikan gambar menggunakan JPEG </li><li>  Salin gambar ke host </li><li>  Tambahkan profil warna asli ke file yang dihasilkan. </li></ol><br>  Anda dapat membuat keputusan yang lebih akurat ketika, sebelum mengubah ukuran, gamma terbalik ditumpangkan pada setiap komponen piksel sehingga ukurannya berada di ruang linear, dan kemudian menerapkan gamma lagi, tetapi setelah sharpe.  Perbedaan sebenarnya untuk pengguna kecil, tetapi ada, dan biaya komputasi untuk modifikasi seperti itu minimal.  Anda hanya perlu memasukkan superposisi gamma invers dan langsung ke dalam skema pemrosesan umum. <br><br>  Ada juga solusi yang memungkinkan ketika decoding jip dilakukan pada CPU multi-core menggunakan libjpeg-turbo library.  Dalam hal ini, setiap gambar diterjemahkan dalam aliran CPU yang terpisah, dan semua tindakan lain dilakukan pada kartu video.  Dengan sejumlah besar core CPU, ini bisa terjadi lebih cepat, tetapi akan ada kerugian serius dalam latensi.  Jika latensi saat mendekode jip pada satu inti CPU dapat diterima, maka opsi ini bisa sangat cepat, terutama untuk kasus ketika jip asli memiliki resolusi kecil.  Ketika resolusi gambar asli meningkat, waktu decoding jip dalam satu aliran CPU akan meningkat, sehingga opsi ini hanya cocok untuk resolusi kecil. <br><br><h2>  Persyaratan dasar untuk tugas pengubahan ukuran web </h2><br><ul><li>  Dianjurkan untuk tidak menyimpan lusinan salinan dari setiap gambar dalam resolusi yang berbeda di server, tetapi untuk dengan cepat membuat gambar yang diinginkan dengan resolusi yang benar segera setelah menerima permintaan.  Ini penting untuk mengurangi ukuran penyimpanan, karena jika tidak, Anda harus menyimpan banyak salinan berbeda dari setiap gambar. </li><li>  Masalahnya harus diselesaikan secepat mungkin.  Ini adalah pertanyaan tentang kualitas layanan yang disediakan untuk mengurangi waktu respons terhadap permintaan pengguna. </li><li>  Kualitas gambar yang dikirim harus tinggi. </li><li>  Ukuran file untuk gambar yang dikirim harus sekecil mungkin, dan resolusinya harus sama persis dengan ukuran jendela di mana gambar itu muncul.  Poin-poin berikut ini penting di sini: </li></ul><br>  a) Jika ukuran gambar tidak sesuai dengan ukuran jendela, maka perangkat pengguna (ponsel, tablet, laptop) akan melakukan pengubahan ukuran perangkat keras setelah decoding sebelum menampilkan gambar di layar.  Dalam OpenGL, pengubahan ukuran perangkat keras ini dilakukan hanya berdasarkan algoritme bilinear, yang sering menyebabkan munculnya moire (noda) dan artefak lain dalam gambar yang berisi detail kecil. <br><br>  b) Pengubahan ukuran layar juga menghabiskan energi perangkat. <br><br>  c) Jika Anda menggunakan serangkaian gambar pra-skala untuk mengatasi masalah, itu tidak selalu mungkin untuk mendapatkan ukuran yang tepat, yang berarti bahwa Anda harus mengirim gambar dengan resolusi yang lebih tinggi.  Ukuran gambar yang meningkat mengarah ke lebih banyak lalu lintas, yang juga ingin saya hindari. <br><br><h2>  Deskripsi skema kerja umum </h2><br><ol><li>  Kami menerima gambar dari pengguna dalam format apa pun dan dalam resolusi apa pun.  Dokumen asli disimpan dalam database terpisah (jika perlu). </li><li>  Offline, menggunakan ImageMagick atau perangkat lunak sejenis, menyimpan profil warna, mengonversi gambar asli asli ke format BMP atau PPM standar, kemudian mengubah ukuran menjadi resolusi 1K atau 2K dan kompres ke JPEG, kemudian tambahkan penanda mulai ulang dengan interval tetap yang ditentukan menggunakan utilitas jpegtran. </li><li>  Kami menyusun basis data gambar 1K atau 2K tersebut. </li><li>  Setelah menerima permintaan dari pengguna, kami memperoleh informasi tentang gambar dan ukuran jendela tempat gambar ini akan ditampilkan. </li><li>  Kami menemukan gambar dalam database dan mengirimkannya ke pengubah ukuran. </li><li>  Pengubah menerima file gambar, menerjemahkan kode, mengubah ukuran, benda tajam, menyandikan dan memasukkan profil warna asli ke dalam jip yang dihasilkan.  Setelah itu, gambar itu diberikan ke program eksternal. </li><li>  Di setiap kartu video, Anda dapat menjalankan banyak utas, dan Anda dapat memasang beberapa kartu video di komputer Anda - sehingga mencapai penskalaan kinerja. </li><li>  Semua ini dapat dilakukan berdasarkan kartu video NVIDIA Tesla (misalnya, P40 atau V100), karena kartu video NVIDIA GeForce tidak dirancang untuk operasi jangka panjang yang berkelanjutan, dan NVIDIA Quadro memiliki banyak output video yang tidak diperlukan dalam kasus ini.  Untuk mengatasi masalah ini, persyaratan untuk ukuran memori GPU minimal. </li><li>  Selain itu, dari database dengan gambar yang disiapkan, Anda dapat secara dinamis mengalokasikan cache untuk file yang sering digunakan.  Masuk akal untuk menyimpan gambar yang sering digunakan menurut statistik dari periode sebelumnya. </li></ol><br><img src="https://habrastorage.org/webt/po/zo/tq/pozotq70cgopg1_g3wvqd8wyzis.jpeg"><br><br><h2>  Parameter program </h2><br><ol><li>  Lebar dan tinggi gambar baru.  Mereka dapat berupa apa saja dan lebih baik untuk mengaturnya secara eksplisit. </li><li>  Mode penipisan JPEG (subsampling).  Ada tiga opsi: 4: 2: 0, 4: 2: 2 dan 4: 4: 4, tetapi mereka biasanya menggunakan 4: 4: 4 atau 4: 2: 0.  Kualitas maksimum adalah 4: 4: 4, ukuran frame minimum adalah 4: 2: 0.  Penjarangan dilakukan untuk komponen-komponen perbedaan warna, yang tidak dilihat oleh penglihatan seseorang seperti halnya pencahayaan.  Setiap mode penipisan memiliki interval optimalnya sendiri untuk memulai kembali marker untuk mencapai kecepatan enkode atau decoding maksimum. </li><li>  Kualitas kompresi JPEG dan mode penipisan saat membuat basis data gambar. </li><li>  Tajam dilakukan dalam jendela 3x3, sigma (radius) dapat dikontrol. </li><li>  Kualitas kompresi JPEG dan mode penipisan ketika meng-encode gambar akhir.  Biasanya, kualitas setidaknya 90% berarti bahwa kompresi ini "tanpa kehilangan visual", yaitu.  pengguna yang tidak terlatih seharusnya tidak melihat artefak dari algoritma JPEG dalam kondisi tampilan standar.  Diyakini bahwa untuk pengguna yang terlatih, 93-95% diperlukan.  Semakin besar nilai ini, semakin besar ukuran frame yang dikirim ke pengguna, dan semakin lama waktu decoding dan encoding. </li></ol><br><h2>  Keterbatasan penting </h2><br>  Mulai ulang spidol.  Kami dapat dengan cepat mendekode gambar JPEG pada kartu video hanya jika ada tanda mulai ulang di dalamnya.  Dalam standar JPEG resmi, penanda ini dijelaskan, ini adalah parameter standar.  Jika tidak ada tanda mulai ulang, maka tidak mungkin untuk memparalelkan decoding gambar pada kartu video, yang akan mengarah pada kecepatan decoder yang sangat rendah.  Oleh karena itu, kita memerlukan database gambar yang disiapkan di mana ada penanda ini. <br><br>  Algoritma diperbaiki untuk codec gambar.  Penguraian dan pengodean gambar menggunakan algoritma JPEG sejauh ini merupakan pilihan tercepat. <br><br>  Resolusi gambar dalam database yang disiapkan dapat berupa apa saja, tetapi sebagai opsi, kami akan mempertimbangkan 1K dan 2K (Anda dapat mengambil 4K).  Anda juga dapat membuat tidak hanya penurunan, tetapi juga peningkatan gambar saat mengubah ukuran. <br><br><h2>  Ubah Ukuran Kinerja Cepat </h2><br>  Kami menguji aplikasi pengubahan ukuran cepat dari Fastvideo SDK pada kartu video NVIDIA Tesla V100 (OS Windows Server 2016, 64-bit, driver 24.21.13.9826) pada gambar 24-bit 1k_wild.ppm dan 2k_wild.ppm dengan resolusi 1K dan 2K (1280x720 dan 1920x1080).  Pengujian dilakukan untuk sejumlah thread yang berbeda yang berjalan pada kartu video yang sama.  Ini membutuhkan tidak lebih dari 110 MB memori pada kartu video per streaming.  4 stream tidak lebih dari 440 MB. <br><br>  Pertama, kami memampatkan gambar asli dalam format JPEG dengan kualitas 90%, dengan penipisan 4: 2: 0 atau 4: 4: 4.  Kemudian kami mendekode dan mengubah ukuran 2 kali lebar dan tinggi, membuat tajam, kemudian lagi mengkodekan dengan kualitas 90% pada 4: 2: 0 atau 4: 4: 4.  Sumber data dalam RAM, gambar terakhir ditempatkan di sana. <br><br>  Waktu operasi dihitung dari mulai memuat gambar asli dari RAM untuk menyimpan gambar yang diproses ke RAM.  Waktu inisialisasi program dan alokasi memori pada kartu video tidak termasuk dalam pengukuran. <br><br>  Contoh baris perintah untuk gambar 1K 24-bit <br>  PhotoHostingSample.exe -i 1k_wild.90.444.jpg -o 1k_wild.640.jpg -outputLebar 640 -q 90 -s 444 -sharp_after 0,95 -ulang 200 <br><br><h4>  Benchmark untuk memproses satu gambar 1K dalam satu utas </h4><br>  Decoding (termasuk transfer data ke kartu video): 0,70 ms <br>  Ubah ukuran dua kali (lebar dan tinggi): 0,27 ms <br>  Tajam: 0,02 ms <br>  Pengkodean JPEG (termasuk transfer data dari kartu video): 0,20 ms <br>  <b>Total waktu per frame: 1,2 ms</b> <br><br><h2>  Performa untuk 1K </h2><br><table border="1"><tbody><tr><td></td><td>  Kualitas </td><td>  Penipisan </td><td>  Ubah ukuran </td><td>  Streaming </td><td align="center">  Frame rate (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  1 </td><td align="center">  868/682 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  2 </td><td align="center">  <strong>1039/790</strong> </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  3 </td><td align="center">  <strong>993/831</strong> </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  4 </td><td align="center">  1003/740 </td></tr></tbody></table><br><br><h2>  Performa untuk 2K </h2><br><table border="1"><tbody><tr><td></td><td>  Kualitas </td><td>  Penipisan </td><td>  Ubah ukuran </td><td>  Streaming </td><td align="center">  Frame rate (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  1 </td><td align="center">  732/643 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  2 </td><td align="center">  913/762 </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  3 </td><td align="center">  891/742 </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 kali </td><td>  4 </td><td align="center">  <strong>923/763</strong> </td></tr></tbody></table><br><br>  Penipisan 4: 2: 0 untuk gambar sumber mengurangi kecepatan, tetapi ukuran file sumber dan tujuan menjadi lebih kecil.  Ketika beralih ke 4: 2: 0, tingkat paralelisme turun 4 kali, karena sekarang blok 16x16 dianggap sebagai satu unit, oleh karena itu dalam mode ini kecepatannya lebih rendah daripada untuk 4: 4: 4. <br><br>  Kinerja terutama ditentukan oleh tahap decoding JPEG, karena pada tahap ini gambar memiliki resolusi maksimum, dan kompleksitas komputasi dari tahap pemrosesan ini lebih tinggi daripada yang lain. <br><br><h2>  Ringkasan </h2><br>  Hasil pengujian menunjukkan bahwa untuk kartu video NVIDIA Tesla V100, kecepatan pemrosesan gambar 1K dan 2K maksimum ketika 2-4 stream diluncurkan pada saat yang sama, dan berkisar dari 800 hingga 1000 frame per detik per kartu video.  Memproses gambar 1K lebih cepat dari 2K, dan bekerja dengan gambar 4: 2: 0 selalu lebih lambat daripada dengan 4: 4: 4.  Untuk mendapatkan hasil akhir pada kinerja, Anda perlu menentukan secara akurat semua parameter program dan mengoptimalkannya untuk model kartu video tertentu. <br><br>  Latensi urutan satu milidetik adalah hasil yang bagus.  Sejauh yang kami tahu, latensi semacam itu tidak dapat diperoleh untuk tugas pengubahan ukuran yang serupa pada CPU (bahkan jika tidak perlu menyandikan dan mendekode jip), jadi ini adalah argumen penting lain yang mendukung penggunaan kartu video dalam solusi pemrosesan gambar berkinerja tinggi. <br><br>  Hingga 16 kartu grafis NVIDIA Tesla V100 mungkin diperlukan untuk memproses satu miliar jip per hari dengan resolusi 1K atau 2K.  Beberapa pelanggan kami sudah menggunakan solusi ini, sementara yang lain mengujinya dalam tugas mereka. <br><br>  Mengubah ukuran jip pada kartu video bisa sangat berguna tidak hanya untuk layanan web.  Ada sejumlah besar aplikasi pemrosesan gambar berkinerja tinggi di mana fungsi seperti itu mungkin diminati.  Misalnya, pengubahan ukuran cepat seringkali diperlukan untuk hampir semua skema pemrosesan untuk gambar yang diterima dari kamera sebelum menampilkan gambar pada monitor.  Solusi ini dapat bekerja untuk Windows / Linux pada kartu grafis NVIDIA: Tegra K1 / X1 / X2 / Xavier, GeForce GT / GTX / RTX, Quadro, Tesla. <br><br><h2>  Keuntungan dari solusi pengubahan ukuran cepat pada kartu grafis </h2><br><ul><li>  Pengurangan signifikan dalam ukuran penyimpanan untuk gambar sumber </li><li>  Mengurangi biaya primer untuk biaya infrastruktur (perangkat keras dan perangkat lunak) </li><li>  Meningkatkan kualitas layanan karena waktu respons yang singkat </li><li>  Pengurangan lalu lintas keluar </li><li>  Konsumsi daya yang lebih rendah pada perangkat pengguna </li><li>  Keandalan dan kecepatan solusi yang disajikan, yang telah diuji pada set data yang sangat besar </li><li>  Mengurangi waktu pengembangan untuk memasarkan aplikasi semacam itu untuk Linux dan Windows </li><li>  Skalabilitas solusi yang dapat bekerja baik pada kartu video tunggal dan sebagai bagian dari sebuah cluster </li><li>  Pengembalian investasi cepat untuk proyek-proyek tersebut </li></ul><br><h2>  Siapa yang mungkin tertarik </h2><br>  Perpustakaan untuk mengubah ukuran jip secara cepat dapat digunakan dalam layanan web yang sarat muatan, toko online besar, jejaring sosial, sistem manajemen foto online, e-commerce, di hampir semua perangkat lunak manajemen perusahaan besar. <br><br>  Pengembang perangkat lunak dapat menggunakan perpustakaan ini, yang menyediakan latensi urutan beberapa milidetik untuk mengubah ukuran jip dengan resolusi 1K, 2K dan 4K pada kartu video. <br><br>  Rupanya, pendekatan ini mungkin ternyata lebih cepat daripada solusi NVIDIA DALI untuk decoding cepat jip, mengubah ukuran dan persiapan gambar selama tahap pelatihan jaringan saraf untuk Deep Learning. <br><br><h2>  Apa lagi yang bisa dilakukan </h2><br><ul><li>  Selain mengubah ukuran dan berbagi, Anda dapat menambahkan memotong ke algoritma yang ada, memutar 90/180/270, menerapkan tanda air, kontrol kecerahan dan kontras. </li><li>  Optimalisasi solusi untuk kartu video NVIDIA Tesla P40 dan V100. </li><li>  Dekoder JPEG kinerja pengoptimalan tambahan. </li><li>  Mode burst untuk memecahkan kode jip pada kartu video. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424575/">https://habr.com/ru/post/id424575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424565/index.html">Tinjauan umum: Pemindaian 3D dari bangunan real estat</a></li>
<li><a href="../id424567/index.html">Pengalaman memblokir iklan online di jaringan lokal perusahaan</a></li>
<li><a href="../id424569/index.html">Mempekerjakan programmer. Kiat Pemrogram</a></li>
<li><a href="../id424571/index.html">Eksperimen Das Perusahaan</a></li>
<li><a href="../id424573/index.html">Kehidupan dan kematian mitokondria</a></li>
<li><a href="../id424577/index.html">JUG.EKB: penggabungan menggunakan mitaps pengembang Java</a></li>
<li><a href="../id424579/index.html">Jangan jatuh ke dalam perangkap menggunakan Oracle JDK 11</a></li>
<li><a href="../id424581/index.html">Ingin memenangkan Perlombaan Pahlawan? Dapatkan resep dari LANIT</a></li>
<li><a href="../id424583/index.html">Anda tidak akan menjadi pahlawan jika Anda seorang pengembang</a></li>
<li><a href="../id424585/index.html">CryEngine 5.5 dirilis oleh Crytek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>