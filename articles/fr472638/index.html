<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍼 ⬜️ 🖐🏻 Construisez un déambulateur en fonte sur Spring Boot et AppCDS 🛣️ 👶🏻 🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partage de données de classe d'application (AppCDS) - Fonction JVM pour accélérer le démarrage et économiser de la mémoire. Après être apparu à ses dé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construisez un déambulateur en fonte sur Spring Boot et AppCDS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472638/"><p><img src="https://habrastorage.org/webt/se/py/8z/sepy8zdhkojsr-xiqs-lwdtyegy.jpeg"></p><br><p> <strong>Partage de données de classe d'application (AppCDS)</strong> - <strong>Fonction</strong> JVM pour accélérer le démarrage et économiser de la mémoire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Après être apparu</a> à ses débuts dans HotSpot dans JDK 1.5 (2004), il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est resté</a> longtemps très limité, et même partiellement commercial.  Ce n'est qu'avec OpenJDK 10 (2018) qu'il a été mis à la disposition de simples mortels, tout en élargissant le champ d'application.  Et récemment, Java 13 a essayé de simplifier cette application. </p><br><p>  L'idée d'AppCDS est de «partager» des classes une fois chargées entre des instances de la même machine virtuelle Java sur le même hôte.  Il semble que cela devrait être idéal pour les microservices, en particulier les "broilers" sur Spring Boot avec leurs milliers de classes de bibliothèque, car maintenant ces classes n'auront plus besoin d'être chargées (analysées et vérifiées) à chaque démarrage de chaque instance JVM, et elles ne seront pas dupliquées en mémoire.  Cela signifie que le lancement devrait devenir plus rapide et la consommation de mémoire devrait être inférieure.  Merveilleux, non? </p><br><p>  Tout est ainsi, tout est ainsi.  Mais si vous, l'odnokhabryanin, ne croyiez pas aux panneaux du boulevard, mais aux chiffres et aux exemples spécifiques, alors bienvenue à Kat - essayons de comprendre comment c'est vraiment ... </p><a name="habracut"></a><br><h2 id="vmesto-disclaimera">  Au lieu de l'avertissement </h2><br><p>  Avant vous n'est pas un guide d'utilisation d'AppCDS, mais un résumé des résultats d'une petite étude.  J'étais intéressé à comprendre comment cette fonction JVM est applicable dans mon projet de travail, et j'ai essayé de l'évaluer du point de vue d'un développeur d'entreprise, en exposant le résultat dans cet article.  Cela n'incluait pas des sujets tels que l'utilisation d'AppCDS sur le chemin du module, l'implémentation d'AppCDS sur d'autres machines virtuelles (pas HotSpot) et les subtilités de l'utilisation des conteneurs.  Mais il y a une partie théorique pour explorer le sujet, ainsi qu'une partie expérimentale écrite pour que vous puissiez répéter l'expérience vous-même.  Aucun résultat n'a encore été appliqué en production, mais qui sait à quoi ressemblera demain ... </p><br><h2 id="teoriya">  Théorie </h2><br><h3 id="kratkoe-vvedenie-v-appcds">  Une brève introduction à AppCDS </h3><br><p>  La connaissance de ce sujet peut avoir eu lieu dans plusieurs sources, par exemple: </p><br><ul><li>  dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> de Nikolai Parlog (y compris Java 13 buns, mais sans Spring Boot) </li><li>  dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> de Volker Simonis (sans Java 13, mais avec des détails) </li><li>  dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport de l'</a> auteur de ces lignes (sans Java 13, mais en mettant l'accent sur Spring Boot) </li></ul><br><p>  Afin de ne pas me lancer dans une nouvelle narration, je ne soulignerai que quelques points importants pour cet article. </p><br><p>  Tout d'abord, AppCDS est une extension de la fonction CDS qui est apparue depuis longtemps dans HotSpot, dont l'essence est la suivante: </p><br><p><img src="https://habrastorage.org/webt/gi/kg/ro/gikgrobp0s_hbnr5ox8z6d1ziqc.png"></p><br><p>  Pour donner vie aux deux idées, vous devez procéder comme suit (en termes généraux): </p><br><ol><li>  Obtenez une liste des classes que vous souhaitez partager entre les instances d'application </li><li>  Fusionnez ces classes dans une archive adaptée au mappage de la mémoire </li><li>  Connectez l'archive à chaque instance de l'application au démarrage </li></ol><br><p>  Il semblerait que l'algorithme ne soit que 3 étapes - prenez-le et faites-le.  Mais ici commence la nouvelle, toutes sortes de choses. </p><br><p>  La mauvaise chose est que dans le pire des cas, chacun de ces éléments se transforme en au moins un lancement JVM avec ses propres options spécifiques, ce qui signifie que l'algorithme entier est un jonglage subtil du même type d'options et de fichiers.  Cela ne semble pas très prometteur, n'est-ce pas? </p><br><p>  Mais il y a une bonne nouvelle: les travaux d'amélioration de cet algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont en cours</a> , et à chaque version de Java, son application devient plus simple.  Ainsi, par exemple: </p><br><ul><li> Dans OpenJDK <strong>10 et 11,</strong> vous pouvez ignorer l'étape <strong>1</strong> si vous souhaitez partager uniquement les classes JDK principales, car elles ont déjà été compilées pour nous et placées dans <code>$JAVA_HOME\lib\classlist</code> (≈1200 pcs.). </li><li>  Dans OpenJDK <strong>12,</strong> vous pouvez ignorer l' <strong>étape 2</strong> , car avec la liste des classes, l'archive de distribution comprend également une archive prête à l'emploi avec eux, qui est utilisée prête à l'emploi et ne nécessite pas de connexion explicite. </li><li>  Au cas où vous souhaiteriez partager tout le reste (et le souhaitez généralement) <br>  OpenJDK <strong>13</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournit des</a> archives Dynamic CDS - des archives qui sont collectées pendant le fonctionnement de l'application et enregistrées lors de la dotation en personnel.  Cela vous permet de réduire les <strong>points 1 et 2</strong> en un point pas trop confus (bien que tout ne soit pas si simple, mais plus à ce sujet plus tard). </li></ul><br><p>  Ainsi, quel que soit le processus de préparation d'AppCDS, les 3 étapes énumérées ci-dessus sont toujours derrière, juste dans certains cas, elles sont voilées. </p><br><p>  Comme vous l'avez probablement remarqué, avec l'avènement d'AppCDS, de nombreuses classes d'application commencent une double vie: elles vivent simultanément dans leurs anciens emplacements (le plus souvent des fichiers JAR) et dans une nouvelle archive partagée.  Dans le même temps, le développeur continue de les modifier / supprimer / compléter au même endroit, et la JVM les reprend de la nouvelle lorsqu'elle fonctionne.  Il n'est pas nécessaire d'être un devin pour voir le danger d'une telle situation: si rien n'est fait, tôt ou tard des copies des cours se corrodent, et nous obtiendrons de nombreux charmes de «l'enfer JAR» typique.  Il est clair que la JVM ne peut pas empêcher les changements de classe, mais elle devrait être capable de détecter un écart dans le temps.  Cependant, faire cela en comparant les classes par paires, même par des sommes de contrôle, est une idée;  il peut annuler le reste des gains de productivité.  C'est probablement pourquoi les ingénieurs JVM n'ont pas sélectionné les classes individuelles comme objet de comparaison, mais tout le chemin de classe, et ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déclaré</a> dans la documentation AppCDS: "Le chemin de classe lors de la création d'une archive partagée doit être le même (ou au moins un préfixe) que lors des lancements ultérieurs de l'application." </p><br><blockquote>  Notez que le chemin de classe utilisé au moment de la création de l'archive doit être le même que (ou un préfixe) le chemin de classe utilisé au moment de l'exécution. </blockquote><p>  Mais ce n'est pas une déclaration sans ambiguïté, car, comme vous vous en souvenez, un chemin de classe peut être formé de différentes manières, telles que: </p><br><ul><li>  lire des fichiers <code>.class</code> nus à partir de répertoires de packages compilés, <br>  par exemple <code>java com.example.Main</code> </li><li>  l'analyse des répertoires avec des fichiers JAR lors de l'utilisation de caractères génériques, <br>  par exemple <code>java -cp mydir/* com.example.Main</code> </li><li>  liste explicite des fichiers JAR et / ou ZIP, <br>  par exemple <code>java -cp lib1.jar;lib2.jar com.example.Main</code> </li></ul><br><p>  (sans parler du fait que le <code>-cp/-classpath/--class-path</code> peut également être défini différemment, par exemple via les options JVM <code>-cp/-classpath/--class-path</code> , la <code>CLASSPATH</code> environnement <code>CLASSPATH</code> ou l'attribut du fichier JAR <code>Class-Path</code> à lancer) </p><br><p>  Parmi ces méthodes, une seule est prise en charge dans AppCDS - énumération explicite des fichiers JAR.  Apparemment, les ingénieurs HotSpot JVM ont estimé que la comparaison des chemins de classe dans l'archive AppCDS et dans l'application lancée ne serait suffisamment rapide et fiable que s'ils étaient spécifiés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aussi</a> clairement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que possible</a> - avec une liste exhaustive habituelle. </p><br><blockquote>  CDS / AppCDS prend en charge l'archivage des classes à partir de fichiers JAR uniquement. </blockquote><p>  Il est important de noter ici que cette déclaration n'est pas récursive, c'est-à-dire  ne s'applique pas aux fichiers JAR à l'intérieur des fichiers JAR (sauf s'il s'agit de Dynamic CDS, voir ci-dessous).  Cela signifie que les poupées JAR habituelles émises par Spring Boot ne fonctionneront pas comme ça avec AppCDS normal, vous devrez vous asseoir. </p><br><p>  Un autre inconvénient du travail de CDS est que les archives partagées sont projetées sur la mémoire avec des adresses fixes (commençant généralement à <code>0x800000000</code> ).  En soi, ce n'est pas mauvais, mais comme la randomisation de la disposition de l'espace d'adressage (ASLR) est activée par défaut sur la plupart des systèmes d'exploitation, la plage de mémoire requise peut être partiellement occupée.  Dans ce cas, la <code>-Xshare</code> HotSpot fait l’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">option</a> spéciale <code>-Xshare</code> qui prend en charge trois valeurs: </p><br><ul><li>  <code>-Xshare:on</code> - force CDS / AppCDS;  si la plage est occupée, la JVM se termine avec une erreur.  Ce mode n'est <strong>pas recommandé pour une utilisation en production</strong> , car cela peut entraîner des plantages sporadiques lors du lancement des applications. </li><li>  <code>-Xshare:off</code> - (vous) changez de CDS / AppCDS;  désactive complètement l'utilisation des données partagées (y compris les archives intégrées) </li><li>  <code>-Xshare:auto</code> - le comportement par défaut de la JVM lorsqu'elle, en cas d'impossibilité d'allouer la plage de mémoire requise, se rend discrètement et charge les classes comme d'habitude </li></ul><br><p>  Au moment de la rédaction de cet article, Oracle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s'efforce</a> simplement de résoudre ces problèmes, mais aucun numéro de version n'a encore été attribué. </p><br><p>  Ces options nous sont partiellement utiles plus tard, mais pour l'instant, regardons ... </p><br><h3 id="varianty-primeneniya-appcds">  Applications AppCDS </h3><br><p>  Il existe plusieurs façons d'utiliser AppCDS. <del>  ruine ta vie </del>  optimiser le travail des microservices.  Leur complexité et leur profit potentiel varient considérablement. Il est donc important de décider immédiatement lequel sera discuté plus tard. </p><br><p>  Le plus simple est de ne pas utiliser même AppCDS, mais seulement CDS - c'est lorsque seules les classes de plate-forme entrent dans l'archive partagée (voir "Une brève introduction à AppCDS").  Nous supprimerons cette option immédiatement, car lorsqu'elle est appliquée aux microservices sur Spring Boot, elle donne trop peu de profit.  Cela peut être vu par la proportion du nombre de classes partagées dans leur distribution générale en utilisant l'exemple d'un vrai microservice (voir le segment vert): </p><br><p><img src="https://habrastorage.org/webt/lz/7x/9l/lz7x9lodfzwv4ihwjjifjyxsf_a.png"></p><br><p>  Plus complexe, mais prometteur est l'utilisation d'AppCDS à part entière, c'est-à-dire l'inclusion des classes de bibliothèque et d'application dans la même archive.  Il s'agit de toute une famille d'options dérivées de combinaisons du nombre d'applications participantes et du nombre d'instances.  Voici les évaluations subjectives de l'auteur sur les avantages et les difficultés de diverses applications d'AppCDS. </p><br><div class="scrollable-table"><table><thead><tr><th>  Non. </th><th>  Les applications </th><th>  Instances </th><th>  Bénéfice CPU </th><th>  Bénéfice RAM </th><th>  Difficulté </th></tr></thead><tbody><tr><td>  1 </td><td>  Un </td><td>  Un </td><td>  + </td><td>  ± </td><td>  Faible </td></tr><tr><td>  <strong>2</strong> </td><td>  <strong>Un</strong> </td><td>  <strong>Quelques-uns</strong> </td><td>  <strong>++</strong> </td><td>  <strong>++</strong> </td><td>  <strong>Faible</strong> </td></tr><tr><td>  3 </td><td>  Quelques-uns </td><td>  Un à la fois </td><td>  ++ </td><td>  ++ </td><td>  Élevé </td></tr><tr><td>  4 </td><td>  Quelques-uns </td><td>  Quelques-uns </td><td>  +++ </td><td>  +++ </td><td>  Élevé </td></tr></tbody></table></div><br><p>  Faites attention: </p><br><ul><li>  Dans l'application à une application dans une instance (n ° 1), le gain de mémoire peut s'avérer nul ou même négatif (surtout lors de la mesure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous Windows</a> ) </li><li>  La création de l'archive partagée correcte nécessite des actions, dont la complexité ne dépend pas du nombre de copies que l'application sera ensuite lancée (comparer les paires d'options n ° 1-2 et n ° 3-4) </li><li>  Dans le même temps, le passage d'une instance à plusieurs donne évidemment une augmentation du bénéfice pour les deux indicateurs, mais n'affecte pas la complexité de la préparation. </li></ul><br><p>  Dans cet article, nous n'atteindrons <strong>que l'option n ° 2</strong> (à travers le n ° 1), car elle est assez simple pour une connaissance approfondie d'AppCDS et seulement pour elle sans astuces supplémentaires, nous pouvons utiliser les archives <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP-350</a> Dynamic CDS récemment publiées, que je veux ressentir en action. </p><br><h3 id="dynamic-cds-archives">  Archives dynamiques du CDS </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les</a> archives dynamiques CDS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP-350</a> , l'une des principales innovations de Java 13, sont conçues pour simplifier l'utilisation d'AppCDS.  Pour ressentir la simplification, vous devez d'abord comprendre la complexité.  Permettez-moi de vous rappeler que l'algorithme d'application «propre» classique pour AppCDS se compose de 3 étapes: (1) obtenir une liste des classes partagées, (2) créer une archive à partir de celles-ci, et (3) exécuter l'application avec l'archive connectée.  De ces étapes, seule la 3ème est réellement utile, le reste ne fait que la préparer.  Et bien que l'obtention d'une liste de classes (étape # 1) puisse sembler très simple (dans certains cas, ce n'est même pas nécessaire), en fait lorsque vous travaillez avec des applications non triviales, cela s'avère être le plus difficile, en particulier en ce qui concerne Spring Boot.  Le JEP-350 est donc nécessaire juste pour éliminer cette étape, ou plutôt l'automatiser.  L'idée est que la JVM elle-même dresse une liste des classes dont l'application a besoin, puis forme elle-même l'archive dite «dynamique».  D'accord, ça sonne bien.  Mais le hic, c'est que maintenant il devient difficile de savoir à quel moment cesser d'accumuler des classes et procéder à leur placement dans l'archive.  Auparavant, dans l'AppCDS classique, nous avions choisi un tel moment nous-mêmes et pouvions même coincer entre ces actions pour changer quelque chose dans la liste des classes avant de le transformer en archive.  Maintenant, cela se produit automatiquement et seulement à un moment, pour lequel les ingénieurs JVM ont peut-être choisi la seule option de compromis - l'arrêt régulier de la JVM.  Cela signifie que l'archive ne sera pas créée avant l'arrêt de l'application.  Cette solution a deux conséquences importantes: </p><br><ul><li>  En cas de plantage de la JVM, l'archive ne sera pas créée, quelle que soit la beauté de la liste des classes accumulées d'ici là (vous ne pouvez pas l'extraire plus tard en utilisant des moyens réguliers). </li><li>  L'archive sera créée uniquement à partir des classes qui ont réussi à se charger pendant la session d'application.  Pour les applications Web, cela signifie que la création d'une archive en démarrant et en s'arrêtant là n'est pas correcte, car alors de nombreuses classes importantes n'entreront pas dans l'archive.  Il est nécessaire d'exécuter au moins une requête HTTP sur l'application (et il est préférable de l'exécuter correctement dans tous les scénarios) afin que toutes les classes qu'elle utilise réellement soient chargées. </li></ul><br><p>  Une différence importante entre les archives dynamiques et statiques est qu'elles constituent toujours un «module complémentaire» sur les archives statiques de base, qui peuvent être soit des archives <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégrées</a> dans le kit de distribution Java, soit créées séparément de manière classique en 3 étapes. </p><br><p>  Syntaxiquement, l'utilisation des archives Dynamic CDS se résume à deux lancements JVM avec deux options: </p><br><ol><li>  Essai avec l'option <code>-XX:ArchiveClassesAtExit=archive.jsa</code> , à la fin de laquelle une archive dynamique sera créée (vous pouvez spécifier n'importe quel chemin et nom) </li><li>  Lancement utile avec l'option <code>-XX:SharedArchiveFile=archive.jsa</code> , qui utilisera l'archive précédemment créée </li></ol><br><p>  La deuxième option n'est pas différente de la connexion d'une archive statique régulière.  Mais si tout à coup l'archive statique de base n'est pas à l'emplacement par défaut (à l'intérieur du JDK), cette option peut également inclure une indication du chemin d'accès, par exemple: </p><br><pre> <code class="bash hljs">-XX:SharedArchiveFile=base.jsa:dynamic.jsa</code> </pre> <br><p>  <em>(sous Windows, le séparateur de chemin doit être le caractère ";")</em> </p><br><p>  Vous en savez maintenant assez sur AppCDS pour pouvoir le regarder en action. </p><br><h2 id="praktika">  Pratique </h2><br><h3 id="podopytnyy-krolik">  Lapin expérimental </h3><br><p>  Pour que notre application d'AppCDS dans la pratique ne se limite pas à un HelloWorld typique, nous prendrons comme base la vraie application sur Spring Boot.  Mes collègues et moi devons souvent regarder les journaux des applications sur des serveurs de test distants et regarder en direct, tout comme ils sont écrits.  Utiliser pour cela un agrégateur de journaux à part entière (comme ELK) n'est souvent pas approprié;  télécharger des fichiers journaux à l'infini - pendant longtemps, et regarder la sortie de la console grise de <code>tail</code> est déprimant.  Par conséquent, j'ai créé une application Web qui peut sortir tous les journaux en temps réel directement vers le navigateur, coloriser les lignes par niveau d'importance (en formatant XML en même temps), agréger plusieurs journaux en un seul, ainsi que d'autres astuces.  Il s'appelle <strong>ANALOG</strong> (comme un «analyseur de journaux», bien que ce ne soit pas vrai) et se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> .  Cliquez sur la capture d'écran pour agrandir: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/q3/lo/m_/q3lom_x6c9wghlerm1g9oa9-yfw.png"></a> </p><br><p>  Techniquement, il s'agit d'une application sur Spring Boot + Spring Integration, sous le capot de laquelle <code>tail</code> , <code>docker</code> et <code>kubectl</code> (pour prendre en charge les journaux de fichiers, les conteneurs Docker et les ressources Kubernetes, respectivement).  Il se présente sous la forme du fichier JAR Spring Boot «épais» classique.  Au moment de l'exécution, <strong>classes10K classes sont suspendues</strong> dans la mémoire de l'application, dont la grande majorité sont des classes Spring et JDK.  Évidemment, ces classes changent assez rarement, ce qui signifie qu'elles peuvent être placées dans une archive partagée et réutilisées dans toutes les instances de l'application, économisant de la mémoire et du CPU. </p><br><h3 id="odinochnyy-eksperiment">  Expérience unique </h3><br><p>  Appliquons maintenant les connaissances existantes de Dynamic AppCDS au lapin expérimental.  Puisque tout est connu en comparaison, nous aurons besoin d'un point de référence - l'état du programme avec lequel nous comparerons les résultats obtenus pendant l'expérience. </p><br><h4 id="vvodnye-zamechaniya">  Remarques introductives </h4><br><ul><li>  Toutes les autres commandes sont pour Linux.  Les différences pour Windows et macOS ne sont pas fondamentales. </li><li>  La compilation JIT peut sensiblement affecter les résultats et, en théorie, pour la pureté de l'expérience, elle pourrait être désactivée (avec l'option <code>-Xint</code> , comme cela a été fait dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> mentionné), mais dans un souci de plausibilité maximale, il a été décidé de ne pas le faire. </li><li>  Les nombres suivants concernant l'heure de début ont été obtenus sur un serveur de test rapide.  Sur les machines qui fonctionnent, des nombres similaires sont généralement plus modestes, mais comme nous ne nous intéressons pas aux valeurs absolues, mais aux incréments de pourcentage, nous considérons cette différence comme insignifiante. </li><li>  Afin de ne pas entrer prématurément dans la complexité de la mesure de la mémoire partagée, pour l'instant nous omettons d'obtenir des lectures précises en octets.  Au lieu de cela, nous introduisons le concept de « <strong>potentiel CDS</strong> », exprimé en pourcentage du nombre de classes partagées par rapport au nombre total de classes chargées.  Il s'agit bien sûr d'une quantité abstraite, mais d'un autre côté, elle affecte directement la consommation réelle de mémoire;  de plus, sa définition ne dépend pas du tout de l'OS, et pour son calcul, seuls les logs sont suffisants. </li></ul><br><h4 id="referentnaya-tochka">  Point de référence </h4><br><p>  Soit ce point l'état d'une application fraîchement téléchargée, c'est-à-dire  sans utilisation explicite d'aucun AppCDS'ov et autres.  Pour l'évaluer, nous avons besoin de: </p><br><ol><li><p>  Installez OpenJDK 13 (par exemple, la distribution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liberica</a> domestique, mais pas la version lite). <br>  Il doit également être ajouté à la variable d'environnement PATH ou à <code>JAVA_HOME</code> , par exemple, comme ceci: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_HOME=~/tools/jdk-13</code> </pre> <br></li><li><p>  <a href="">Téléchargez</a> ANALOG (au moment de la rédaction, la dernière version était la v0.12.1). </p><br><p>  Si nécessaire, vous pouvez spécifier dans le fichier <code>config/application.yaml</code> du paramètre <code>server.address</code> le nom d'hôte externe pour accéder à l'application (par défaut, <code>localhost</code> est spécifié). </p><br></li><li><p>  Activez la journalisation du chargement de classe JVM. <br>  Pour ce faire, vous pouvez <code>JAVA_OPTS</code> la variable d'environnement <code>JAVA_OPTS</code> avec cette valeur: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=-Xlog:class+load=info:file=<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/class-load.log</code> </pre> <br><p>  Cette option sera transmise à la JVM et lui demandera de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">garantir la</a> source de chaque classe. </p><br></li><li><p>  Exécutez un test: </p><br><ol><li>  Exécutez l'application avec le script <code>bin/analog</code> </li><li>  Ouvrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8083</a> dans le navigateur, piquez les boutons et les daws </li><li>  Arrêtez l'application en appuyant sur <code>Ctrl+C</code> dans la console de script <code>bin/analog</code> </li></ol><br></li><li><p>  Prendre le résultat (à partir des fichiers du <code>log/</code> répertoire) </p><br><ul><li><p>  Nombre total de classes chargées (par <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10463</code> </pre> <br></li><li><p>  Combien d'entre eux sont téléchargés à partir d'une archive partagée (selon elle): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> - class-load.log 1146</code> </pre> <br></li><li><p>  Heure de début moyenne (après une série de démarrages; par <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.5225</code> </pre> <br></li></ul><br></li></ol><br><p>  Ainsi, à cette étape, le potentiel du CDS était de <code>1146/10463=0,1095</code> <strong>-11%</strong> .  Si vous êtes surpris de l'origine des classes partagées (après tout, nous n'avons pas encore inclus d'AppCDS), je vous rappelle qu'à partir de la 12ème version, le JDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inclut l'</a> archive CDS finie <code>$JAVA_HOME/lib/server/classes.jsa</code> , construite par pas moins de liste de classes prête: </p><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$JAVA_HOME</span></span>/lib/classlist | wc -l 1170</code> </pre> <br><p>  Maintenant, après avoir évalué l'état initial de l'application, nous pouvons lui appliquer AppCDS et, par comparaison, comprendre ce que cela donne. </p><br><h4 id="osnovnoy-opyt">  Expérience de base </h4><br><p>  Comme la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> nous a été léguée, pour créer une archive AppCDS dynamique, vous devez effectuer un seul essai de l'application avec l'option <code>-XX:ArchiveClassesAtExit</code> .  Dès le prochain lancement, l'archive peut être utilisée et recevoir des bénéfices.  Pour vérifier cela sur le même lapin expérimental (AnaLog), vous avez besoin de: </p><br><ol><li><p>  Ajoutez l'option spécifiée à la commande d'exécution: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:ArchiveClassesAtExit=work/classes.jsa"</span></span></code> </pre> <br></li><li><p>  Étendre la journalisation: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -Xlog:cds=debug:file=log/cds.log"</span></span></code> </pre><br><p>  Cette option forcera le processus de construction d'une archive CDS à être enregistré lorsque l'application sera arrêtée. </p><br></li><li><p>  Effectuez le même test que pour le point de référence: </p><br><ol><li>  Exécutez l'application avec le script <code>bin/analog</code> </li><li>  Ouvrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8083</a> dans le navigateur, piquez les boutons et les daws </li><li>  Arrêtez l'application en appuyant sur <code>Ctrl+C</code> dans la console de script <code>bin/analog</code> <br>  Après cela, un énorme footcloth avec toutes sortes d'avertissements devrait tomber dans la console, et le <code>log/cds.log</code> devrait être rempli de détails;  ils ne nous intéressent pas encore. </li></ol><br></li><li><p>  Faites passer le mode de lancement d'essai à utile: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-XX:SharedArchiveFile=work/classes.jsa -Xlog:class+load=info:file=log/class-load.log -Xlog:class+path=debug:file=log/class-path.log"</span></span></code> </pre><br><p>  Ici, nous ne <code>JAVA_OPTS</code> pas la variable <code>JAVA_OPTS</code> , mais nous la <code>JAVA_OPTS</code> par de nouvelles valeurs qui incluent (1) l'utilisation d'une archive partagée, (2) la journalisation des sources de classe et (3) la journalisation des vérifications de chemin de classe. </p><br></li><li><p>  Effectuez un lancement utile de l'application selon le schéma du paragraphe 3. </p><br></li><li><p>  Prendre le résultat (à partir des fichiers du <code>log/</code> répertoire) </p><br><ul><li><p>  Vérification de l'application réelle d'AppCDS (par le <code>class-path.log</code> ): </p><br><pre> <code class="plaintext hljs">[0.011s][info][class,path] type=BOOT [0.011s][info][class,path] Expecting BOOT path=/home/upc/tools/jdk-13/lib/modules [0.011s][info][class,path] ok [0.011s][info][class,path] type=APP [0.011s][info][class,path] Expecting -Djava.class.path=/home/upc/tmp/analog/lib/analog.jar [0.011s][info][class,path] ok</code> </pre><br><p>  Les marques <code>ok</code> après les lignes <code>type=BOOT</code> et <code>type=APP</code> indiquent respectivement l'ouverture, la vérification et le chargement réussis des archives CDS intégrées et appliquées. </p><br></li><li><p>  Nombre total de classes chargées (par <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10403</code> </pre><br></li><li><p>  Combien d'entre eux sont téléchargés à partir d'une archive partagée (selon elle): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> -c class-load.log 6910</code> </pre><br></li><li><p>  Heure de début moyenne (après une série de démarrages; par fichier <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.04167</code> </pre><br></li></ul><br></li></ol><br><p>  Mais à ce <code>6910/10403≈0,66</code> , le potentiel du CDS était déjà de <code>6910/10403≈0,66</code> <strong>= 66%</strong> , c'est-à-dire qu'il a augmenté <strong>de 55%</strong> par rapport au point de référence.  Dans le même temps, le temps de lancement moyen a été réduit de <code>(4,5225-4,04167)=0,48</code> seconde, soit  le démarrage est plus rapide de <strong>≈10,6%</strong> de la valeur initiale. </p><br><h4 id="analiz-rezultatov">  Analyse des résultats </h4><br><p>  <em>Le titre de travail de l'article est: "Pourquoi si peu?"</em> </p><br><p>  Nous, comme, avons tout fait selon les instructions, mais toutes les classes n'étaient pas dans l'archive.  Leur nombre affecte le temps de lancement non moins que la puissance de calcul de la machine de l'expérimentateur, nous allons donc nous concentrer sur ce nombre. </p><br><p>  Si vous vous en souvenez, nous avons ignoré le fichier <code>log/cds.log</code> créé lors de l'arrêt de l'application expérimentale après la période d'essai.  Dans ce fichier HotSpot, la JVM a gentiment noté les classes d'avertissement pour chaque classe qui n'apparaissait pas dans l'archive CDS.  Voici le nombre total de ces marques: </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'[warning]'</span></span> cds.log -c 3591</code> </pre><br><p>  Étant donné que seules 10 000 classes et plus sont mentionnées dans le journal <code>class-load.log</code> et que 66% d'entre elles sont téléchargées à partir de l'archive, il n'est pas difficile de comprendre que les 3600 classes répertoriées dans <code>cds.log</code> représentent les 44% «manquants» du potentiel CDS.  Vous devez maintenant découvrir pourquoi ils ont été ignorés. </p><br><p>  Si vous regardez le journal cds.log, il s'avère qu'il n'y a que 4 raisons uniques pour sauter des classes.  Voici des exemples de chacun d'eux: </p><br><pre> <code class="plaintext hljs">Skipping org/springframework/web/client/HttpClientErrorException: Not linked Pre JDK 6 class not supported by CDS: 49.0 org/jrobin/core/RrdUpdater Skipping java/util/stream/Collectors$$Lambda$554: Unsafe anonymous class Skipping ch/qos/logback/classic/LoggerContext: interface org/slf4j/ILoggerFactory is excluded</code> </pre><br><p>  Parmi les 3591 classes manquées, ces raisons se retrouvent ici avec une telle fréquence: </p><br><p><img src="https://habrastorage.org/webt/sp/f6/6k/spf66kzmkajvdxki1xdiwjyx9lg.png"></p><br><p>  Examinez-les de plus près: </p><br><ul><li><p> <code>Unsafe anonymous class</code> <br>   JVM   “”   ,       -,         . </p><br></li><li><p> <code>Not linked</code> <br>      , “”     ,  ,   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StackOverflow </a>    . , ,       “” () JAR-  ,   AppCDS.       ,     (  ). </p><br></li><li><p> <code>Pre JDK 6 class</code> <br>  ,   CDS    Java 5.        class-   ,   CDS    .    ,    ,  6,  Java,       .       -   ,      runtime- (, slf4j). </p><br></li><li><p> <code>Skipping ... : super class/interface ... is excluded</code> <br>   ,  “”     .          CDS',    .  Par exemple: </p><br><pre> <code class="plaintext hljs">[warning][cds] Pre JDK 6 class not supported by CDS: 49.0 org/slf4j/spi/MDCAdapter [warning][cds] Skipping ch/qos/logback/classic/util/LogbackMDCAdapter: interface org/slf4j/spi/MDCAdapter is excluded</code> </pre><br></li></ul><br><p>  <strong>Conclusion</strong> </p><br><blockquote>  CDS       100%. </blockquote><p> ,     ,  ,         ,  ,     .      . </p><br><h3 id="mnozhestvennyy-eksperiment">   </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP-310</a> , AppCDS                         JDK.   .       ,     .    CDS (, ,     )       . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de cloner le lapin expérimental (exécuter AnaLog dans plusieurs cas), nous devons changer quelque chose dans les paramètres; </font><font style="vertical-align: inherit;">cela permettra aux processus levés de ne pas «coude». </font><font style="vertical-align: inherit;">Grâce à Spring Boot, vous pouvez le faire sans modifier ni copier aucun fichier; </font><font style="vertical-align: inherit;">tous les paramètres peuvent être remplacés par les options JVM. </font><font style="vertical-align: inherit;">Le transfert de ces options à partir de la variable d'environnement </font></font><code>ANALOG_OPTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fournit un script de lancement, gentiment généré par Gradle.</font></font></p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"-Djavamelody.enabled=false -Dlogging.config=classpath:logging/logback-console.xml"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p>      JavaMelody,             ,        ,       .     TCP-    ;       . </p><br><p>  ,    ,   JVM      AppCDS    .         <code>JAVA_OPTS</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JVM Unified Logging Framework</a> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xlog:class+load=info:file=log/class-load-%p.log -Xlog:class+path=debug:file=log/class-path-%p.log"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:SharedArchiveFile=work/classes.jsa"</span></span></code> </pre><br><p>        <code>%p</code> ,    JVM      (PID).   AppCDS  ,     (         ). </p></div></div><br><h4 id="osnovnoy-opyt-1">   </h4><br><p>  ,          .                  .     : </p><br><ol><li><p>      <code>server.port</code>  <code>nodes.this.agentPort</code> ,      : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p> ,       (    ). </p><br></li><li><p>    <code>bin/analog</code> </p><br><p> <em>()</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://localhost:8091</a>  ,     </p><br></li><li><p>  PID  (  ), : </p><br><pre> <code class="bash hljs">pgrep -f analog 13792</code> </pre><br></li><li><p>      <code>pmap</code> (    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ): </p><br><pre> <code class="bash hljs">pmap -XX 13792 | sed -n -e <span class="hljs-string"><span class="hljs-string">'2p;$p'</span></span> Address Perm Offset Device Inode Size KernelPageSize MMUPageSize Rss Pss Shared_Clean Shared_Dirty Private_Clean Private_Dirty Referenced Anonymous LazyFree AnonHugePages ShmemPmdMapped Shared_Hugetlb Private_Hugetlb Swap SwapPss Locked ProtectionKey VmFlagsMapping 3186952 1548 1548 328132 325183 3256 0 10848 314028 212620 314024 0 0 0 0 0 0 0 325183 0 KB</code> </pre><br><p>           ;   . </p><br></li><li><p>   1-4     (,  ). </p><br></li></ol><br><h4 id="analiz-rezultatov-1">   </h4><br><p>    <code>pmap</code>             .        CDS'    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> .    ,  ,        PSS: </p><br><blockquote> The "proportional set size" (PSS) of a process is the count of pages it has in memory, where each page is divided by the number of processes sharing it. So if a process has 1000 pages all to itself, and 1000 shared with one other process, its PSS will be 1500. </blockquote><p>  ,   ,  “ ” .        ,      . </p><br><p>    PSS       ,    : </p><br><div class="scrollable-table"><table><thead><tr><th> Iteration: </th><th>  1 </th><th>  2 </th><th>  3 </th><th>  4 </th><th>  5 </th></tr></thead><tbody><tr><td> PSS of inst#1: </td><td> 339 088 </td><td> 313 778 </td><td> 305 517 </td><td> 301 153 </td><td> 298 604 </td></tr><tr><td> PSS of inst#2: </td><td></td><td> 314 904 </td><td> 306 567 </td><td> 302 555 </td><td> 299 919 </td></tr><tr><td> PSS of inst#3: </td><td></td><td></td><td> 314 914 </td><td> 311 008 </td><td> 308 691 </td></tr><tr><td> PSS of inst#4: </td><td></td><td></td><td></td><td> 306 563 </td><td> 304 495 </td></tr><tr><td> PSS of inst#5: </td><td></td><td></td><td></td><td></td><td> 294 686 </td></tr><tr><td> <em>Average:</em> </td><td> 339 088 </td><td> 314 341 </td><td> 308 999 </td><td> 305 320 </td><td> 301 279 </td></tr></tbody></table></div><br><p>         ,      - : </p><br><ul><li>        “”  </li><li>     , PSS   </li><li>  “” ,     PSS      </li></ul><br><p>    ,      .         AppCDS.        ,       <code>-XX:SharedArchiveFile=work/classes.jsa</code>   <code>-Xshare:off</code> ,    CDS .              ,    . </p><br><p><img src="https://habrastorage.org/webt/vq/4s/n6/vq4sn66zppmcyl5aovqj6xpkwyq.png"></p><br><p>       : </p><br><ul><li><p>  PSS  AppCDS      CDS. <br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .  ,  ,    HelloWorld- JVM   CDS   2   ,   CDS.      PSS            CDS,     .        : </p><br></li><li><p>    PSS   AppCDS    2-  ; 3-      . <br>        ,      ,    ,     .  ,        AppCDS,   ,   ,      3-    . <br>  :    ,    CDS?      : </p><br></li><li><p>    CDS/AppCDS  JVM      ,  PSS       .  ,    ,      <code>pmap</code> ,   “”   <code>sed</code> '.              : </p><br><pre> <code class="bash hljs">pmap -X `pgrep -f analog` 14981: <span class="hljs-comment"><span class="hljs-comment"># ... Address Perm Offset Device Inode Size Rss Pss ... Mapping # ... ... 7faf5e31a000 r-xp 00000000 08:03 269427 17944 14200 14200 ... libjvm.so # ... ... 7faf5f7f9000 r-xp 00000000 08:03 1447189 1948 1756 25 ... libc-2.27.so</span></span></code> </pre><br><p>       ( <code>Mapping</code> )  , “”      .       JVM  ( <code>libjvm.so</code>   ),     ( <code>libc-2.27.so</code>  ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>        : </p><br><blockquote> For the Java VM, the read-only parts of the loaded shared libraries (ie <code>libjvm.so</code> ) can be shared between all the VM instances running at the same time. This explains why, taking together, the two VM's consume less memory (ie have a smaller memory footprint) than the simple sum of their single resident set sizes when running alone. </blockquote><br></li></ul><br><p>           .     ,  , .  ,          ,         JVM     ,    Java-    .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>  GeekOut: </p><br><p><img src="https://habrastorage.org/webt/wp/ia/qo/wpiaqom-2teiw_iegjacskkt3sm.png"></p><br><p> , , ,      AppCDS    , ..     Java-.   ,             JVM,  , -      . </p><br><p>       VisualVM      Metaspace    AppCDS  ,      : </p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/pt/wv/6r/ptwv6rmyk8j7f7yzgxrjkqrsvww.png"></p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/dt/jn/0m/dtjn0mdpcgykbfynjbwdma2vmqm.png"></p><br><p>   ,         128     Metaspace   AppCDS    <code>64.2 MiB / 8.96 MiB</code> <strong>≈7,2  </strong> ,   CDS .            (.  )       <code>66.4 MiB / 13.9 MiB</code> <strong>≈4,8 </strong> .      ,    AppCDS      ,       Metaspace.            Metaspace,    ,    CDS . </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>            Spring Boot  AppCDS –  JVM,        . </p><br><ul><li>            JEP-350 Dynamic CDS Archives –    JDK 13. </li><li>    Spring Boot  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ó</a>          CDS (  ). ,           100%   -   <strong>66%</strong> .      ,      <strong>≈11%</strong> (    15%,      ). </li><li>     ,       5-     PSS (      ).  ,  AppCDS     ,   <strong>  </strong>           , <strong> 8%</strong> (PSS).       ,    CDS,     ,     .        AppCDS  <strong> </strong> . </li><li>          Metaspace,  ,         AppCDS  <strong> 5  </strong> ,   CDS. </li></ul><br><p> ,    , AppCDS,  ,    “killer feature”.           Spring Boot.   ,   ,    AppCDS      .  , ,        AppCDS   <em></em>   Spring Boot.              ,      … </p><br><p> <em>  by <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nick Fewings</a> on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unsplash</a></em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472638/">https://habr.com/ru/post/fr472638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472620/index.html">Museum DataArt. Inspection du terminal vidéo Mera CM 7209</a></li>
<li><a href="../fr472622/index.html">Plan de mise à niveau pour la profession Data Engineer</a></li>
<li><a href="../fr472626/index.html">Test de la carte mère ASRock Z390 Phantom Gaming 7: préparation pour 9900KS</a></li>
<li><a href="../fr472628/index.html">Encodages, chiffrement par décalage, hachages bruts et création d'images à l'aide de Python PIL. Résolution de problèmes avec r0ot-mi Cryto. Partie 1</a></li>
<li><a href="../fr472636/index.html">Aperçu du programme DotNext 2019 Moscou: qui vous dira quoi?</a></li>
<li><a href="../fr472640/index.html">Ce que j'ai appris en 6 ans pour aider les startups à se développer</a></li>
<li><a href="../fr472642/index.html">Webdev indépendant - comment et avec qui vous ne devriez PAS travailler</a></li>
<li><a href="../fr472644/index.html">Stages dans des entreprises internationales: comment ne pas remplir l'entretien et obtenir l'offre convoitée</a></li>
<li><a href="../fr472650/index.html">Peur, douleur et haine du support technique</a></li>
<li><a href="../fr472658/index.html">Presque tout sur le futur HolyJS 2019 Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>