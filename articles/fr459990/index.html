<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🌾 👨🏾‍⚕️ 🧝🏽 Immersion in Move - le langage de programmation de la chaîne de blocs Libra de Facebook ⚒️ 👩🏾‍🤝‍👨🏿 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ensuite, nous examinerons en détail les principales caractéristiques du langage Move et quelles sont ses principales différences avec un autre langage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Immersion in Move - le langage de programmation de la chaîne de blocs Libra de Facebook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459990/"> Ensuite, nous examinerons en détail les principales caractéristiques du langage Move et quelles sont ses principales différences avec un autre langage déjà populaire pour les contrats intelligents - Solidity (sur la plate-forme Ethereum).  Le matériel est basé sur une étude d'un livre blanc disponible en ligne de 26 pages. <br><br><h3>  Présentation </h3><br>  Move est un langage de bytecode exécutable utilisé pour exécuter des transactions utilisateur et des contrats intelligents.  Faites attention à deux points: <br><br><ol><li>  Alors que Move est un langage de bytecode qui peut être directement exécuté sur la machine virtuelle Move, Solidity (langage de contrat intelligent dans Ethereum) est un langage de niveau supérieur qui est d'abord compilé en bytecode avant d'être exécuté dans EVM (Ethereum Virtual Machine ) </li><li>  Move peut être utilisé non seulement pour la mise en œuvre de contrats intelligents, mais également pour les transactions des utilisateurs (plus d'informations à ce sujet plus tard), tandis que Solidity est un langage uniquement pour les contrats intelligents. </li></ol><a name="habracut"></a><br>  <i>Traduction réalisée par l'équipe du projet INDEX Protocol.</i>  <i>Nous avons déjà traduit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup de documents décrivant le projet Libra</a> , maintenant c'est au tour de regarder le langage Move un peu plus en profondeur.</i>  <i>La traduction a été faite en collaboration avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">coolsiu</a></i> <br><br>  Une caractéristique clé de Move est la possibilité de définir des types de ressources personnalisés avec une sémantique de logique linéaire: une ressource ne peut jamais être copiée ou supprimée implicitement, seulement déplacée.  Fonctionnellement, cela est similaire aux capacités du langage Rust.  Les valeurs de Rust ne peuvent être attribuées qu'à un seul nom à la fois.  L'attribution d'une valeur à un autre nom la rend inaccessible sous le nom précédent. <br><br><img src="https://habrastorage.org/webt/np/px/97/nppx97owkfkamua9ccpc1aovkrg.png"><br><br>  Par exemple, le fragment de code suivant générera une erreur: <i>Utilisation de la valeur déplacée «x».</i>  En effet, il n'y a pas de collecte des ordures dans Rust.  Lorsque les variables sortent du domaine, la mémoire à laquelle elles se réfèrent est également libérée.  Autrement dit, il ne peut y avoir qu'un seul «propriétaire» de données.  Dans cet exemple, <i>x</i> est le propriétaire d'origine, puis <i>y</i> devient le nouveau propriétaire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En savoir plus sur ce comportement ici</a> . <br><br><h3>  Représentation des actifs numériques dans les systèmes ouverts </h3><br>  Il existe deux propriétés des actifs physiques qui sont difficiles à représenter numériquement: <br><br><ul><li>  <b>Rareté</b> (rareté, dans l'original - rareté).  Le montant des actifs (émission) dans le système doit être contrôlé.  La duplication des actifs existants doit être interdite et la création de nouveaux est une opération privilégiée. </li><li>  <b>Contrôle d'accès</b> .  Le participant au système doit être en mesure de protéger les actifs avec des politiques de contrôle d'accès. </li></ul><br>  Ces deux caractéristiques, naturelles pour les actifs physiques, doivent être implémentées pour les objets numériques, si l'on veut les considérer comme des actifs.  Par exemple, un métal rare - a un déficit naturel, et vous seul y avez accès (en le tenant par la main, par exemple) et vous pouvez le vendre ou le dépenser. <br><br>  Pour illustrer comment nous sommes arrivés à ces deux propriétés, commençons par les phrases suivantes: <br><br><h4>  Proposition 1: La règle la plus simple sans rareté et contrôle d'accès </h4><br><img src="https://habrastorage.org/webt/it/ar/vy/itarvy-z1ns775gm4oxu2isimxe.png"><br><br><ul><li>  <i>G [K]: = n</i> signifie mettre à jour le numéro accessible par la clé <i>K</i> dans l'état global de la blockchain avec la nouvelle valeur <i>n</i> . </li><li>  <i>transaction «Alice, 100»</i> signifie que le solde du compte d'Alice est de 100. </li></ul><br>  La solution ci-dessus présente plusieurs problèmes graves: <br><br><ul><li>  Alice peut recevoir un nombre illimité de pièces simplement en envoyant la <i>transaction «Alice, 100».</i> </li><li>  Les pièces que Alice envoie à Bob sont inutiles, car Bob pourrait s'envoyer un nombre illimité de pièces en utilisant la même technique. </li></ul><br><h4>  Proposition n ° 2: nous prenons en compte le déficit </h4><br><img src="https://habrastorage.org/webt/_1/s4/08/_1s408pxxtmawws6dw_vddgzr-m.png"><br><br>  Nous surveillons maintenant la situation afin que le nombre de pièces <i>Ka</i> soit au moins <i>n</i> avant la transaction de transfert.  Néanmoins, bien que cela résout le problème de pénurie, il n'y a aucune information sur qui peut envoyer des pièces d'Alice (jusqu'à présent, tout le monde peut le faire, l'essentiel est de ne pas violer la règle des limites de quantité). <br><br><h4>  Proposition 3: Combiner le déficit et le contrôle d'accès </h4><br><img src="https://habrastorage.org/webt/yi/so/hh/yisohh7xhtgmzt8aparwsxdccfc.png"><br><br>  Nous résolvons ce problème avec le <i>mécanisme de</i> signature numérique <i>verify_sig</i> avant de vérifier le solde, ce qui signifie qu'Alice utilise sa clé privée pour signer la transaction et confirmer qu'elle possède ses pièces. <br><br><h3>  Langages de programmation Blockchain </h3><br>  Les langues de blockchain existantes sont confrontées aux problèmes suivants (tous ont été résolus dans Move (remarque: <i>malheureusement, l'auteur de l'article ne fait appel à Ethereum que dans ses comparaisons, vous ne devez donc les prendre que dans ce contexte. Par exemple, la plupart des problèmes suivants sont également résolus dans EOS</i> )): <br><br>  <b>Représentation indirecte des actifs</b> .  Un actif est codé à l'aide d'un entier, mais une valeur entière n'est pas la même chose qu'un actif.  En fait, il n'y a pas de type ou de valeur représentant bitcoin / éther / &lt;Any Coin&gt;!  Cela rend difficile l'écriture de programmes utilisant des ressources et des erreurs.  Les modèles tels que le transfert d'actifs vers / depuis des procédures ou le stockage d'actifs dans des structures nécessitent un support linguistique spécial. <br><br>  <b>Le déficit n'est pas extensible</b> .  La langue ne représente qu'un atout rare.  De plus, les remèdes contre le déficit sont directement liés à la sémantique de la langue elle-même.  Un développeur, s'il veut créer un actif utilisateur, doit surveiller attentivement tous les aspects de la ressource lui-même.  Ce ne sont que les problèmes des contrats intelligents Ethereum. <br><br>  Les utilisateurs émettent leurs actifs, des jetons standard ERC-20, à l'aide d'entiers pour déterminer à la fois le coût et le problème total.  Chaque fois que de nouveaux jetons sont créés, le code de contrat intelligent doit vérifier indépendamment la conformité aux règles d'émission.  De plus, la représentation indirecte des actifs entraîne, dans certains cas, de graves erreurs - duplication, double dépense ou même perte totale d'actifs. <br><br>  <b>Manque de contrôle d'accès flexible</b> .  La seule politique de contrôle d'accès actuellement utilisée est un schéma de signature utilisant la cryptographie asymétrique.  Tout comme la protection contre le déficit, les politiques de contrôle d'accès sont profondément ancrées dans la sémantique du langage.  Mais comment étendre le langage pour permettre aux programmeurs de définir leurs propres politiques de contrôle d'accès est souvent une tâche très simple. <br><br>  Cela est également vrai pour Ethereum, où les contrats intelligents ne prennent pas en charge la cryptographie native pour le contrôle d'accès.  Les développeurs doivent prescrire manuellement le contrôle d'accès, par exemple, à l'aide du modificateur onlyOwner. <br><br>  Bien que je sois un grand fan d'Ethereum, je pense que les propriétés des actifs devraient être prises en charge nativement par le langage pour des raisons de sécurité.  En particulier, le transfert d'Ether vers un contrat intelligent implique une répartition dynamique, ce qui a conduit à l'émergence d'une nouvelle classe d'erreurs connue sous le nom de vulnérabilités de ré-entrée.  La répartition dynamique signifie ici que la logique d'exécution du code sera déterminée au moment de l'exécution (dynamique) et non au moment de la compilation (statique). <br><br>  Ainsi, dans Solidity, lorsque le contrat A appelle la fonction du contrat B, le contrat B peut exécuter du code qui n'a pas été fourni par le développeur du contrat A, ce qui peut entraîner des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vulnérabilités de rentrée</a> (le contrat A remplit accidentellement la fonction du contrat B pour retirer de l'argent avant la déduction effective). soldes des comptes). <br><br><h3>  Déplacer les bases de la conception de la langue </h3><br><h4>  Ressources de premier ordre </h4><br>  Parlant à un niveau supérieur, l'interaction entre les modules / ressources / procédures dans le langage Move est très similaire aux relations entre les classes / objets et les méthodes dans les langages OOP. <br>  Les modules de Move sont similaires aux contrats intelligents dans d'autres chaînes de blocs.  Le module déclare les types de ressources et les procédures qui définissent les règles de création, de destruction et de mise à jour des ressources déclarées.  Mais tout cela n'est que des conventions (« <i>jargon</i> ») dans Move.  Un peu plus tard, nous illustrerons ce point. <br><br><h4>  Flexibilité </h4><br>  Move ajoute de la flexibilité à Libra grâce aux scripts.  Chaque transaction dans Libra comprend un script, qui est en fait la procédure de transaction principale.  Le script peut effectuer une action spécifiée, par exemple, des paiements en fonction de la liste de destinataires spécifiée, ou réutiliser d'autres ressources - par exemple, en appelant une procédure dans laquelle la logique générale est spécifiée.  C'est pourquoi les scripts de transaction Move offrent plus de flexibilité.  Le script peut utiliser à la fois des comportements ponctuels et répétitifs, tandis qu'Ethereum ne peut exécuter que des scripts répétitifs (appeler une méthode de contrat intelligent en appelant une méthode).  La raison pour laquelle il est appelé «multiple» est que les fonctions d'un contrat intelligent peuvent être exécutées plusieurs fois.  (Remarque: <i>le moment est très délicat ici. D'une part, les scripts de transaction sous forme de pseudo-bytecode sont également en Bitcoin. D'un autre côté, si je comprends bien, Move étend cette langue, en fait, au niveau d'un langage de contrat intelligent à part entière</i> ). <br><br><h4>  La sécurité </h4><br>  Le format exécutable Move est un bytecode, qui, d'une part, est un langage de niveau supérieur à l'assembleur, mais de niveau inférieur au code source.  Le bytecode est vérifié en chaîne pour la disponibilité des ressources, des types et de la sécurité de la mémoire à l'aide du vérificateur de bytecode, puis exécuté par l'interpréteur.  Cette approche permet à Move de fournir une sécurité spécifique au code source, mais sans le processus de compilation ni la nécessité d'ajouter un compilateur au système.  Faire de Move un langage de bytecode est une très bonne solution.  Il n'est pas nécessaire de le compiler depuis la source, comme c'est le cas avec Solidity, pas besoin de s'inquiéter d'éventuels plantages ou attaques sur l'infrastructure du compilateur. <br><br><h4>  Vérifiabilité </h4><br>  Nous visons à effectuer des vérifications aussi simples que possible, car tout cela se fait en chaîne (remarque: <i>en ligne, dans le processus de chaque transaction, donc tout retard entraîne un ralentissement de l'ensemble du réseau</i> ), cependant, la conception du langage est initialement prête à l'emploi et moyens hors chaîne de vérification statique.  Bien que cela soit plus préférable, jusqu'à présent, le développement d'outils de vérification (en tant que boîte à outils séparée) a été reporté à l'avenir, et maintenant seule la vérification dynamique au moment de l'exécution (en chaîne) est prise en charge. <br><br><h4>  Modularité </h4><br>  Les modules Move fournissent une abstraction des données et localisent les opérations critiques sur les ressources.  L'encapsulation fournie par le module, combinée à la protection fournie par le système de type Move, garantit que les propriétés définies pour les types de module ne peuvent pas être violées par du code à l'extérieur du module.  Il s'agit d'une conception d'abstraction bien pensée, ce qui signifie que les données à l'intérieur du contrat ne peuvent être modifiées que dans le cadre du contrat, mais pas de l'extérieur. <br><br><img src="https://habrastorage.org/webt/rm/co/qe/rmcoqelz3bad4ltayox-u9rpxq0.png"><br><br><h3>  Déplacer la révision </h3><br>  Un exemple de script de transaction montre que les actions malveillantes ou imprudentes d'un programmeur en dehors d'un module ne peuvent pas violer la sécurité des ressources du module.  Ensuite, nous examinerons des exemples d'utilisation des modules, des ressources et des procédures pour programmer la blockchain Libra. <br><br><h4>  Paiements d'égal à égal </h4><br><img src="https://habrastorage.org/webt/1a/hr/hh/1ahrhhw3rd4ky7jpfsvzxeohi0e.png"><br><br>  Le montant des pièces spécifié dans le montant sera transféré du solde de l'expéditeur au destinataire. <br>  Il y a plusieurs nouveaux points (surlignés en rouge): <br><br><ul><li>  <b>0x0</b> : adresse du compte où le module est stocké </li><li>  <b>Devise</b> : nom du module </li><li>  <b>Coin</b> : type de ressource </li><li>  La valeur de pièce retournée par la procédure est une valeur de ressource dont le type est 0x0.Currency.Coin </li><li>  <b>move ()</b> : la valeur ne peut plus être utilisée </li><li>  <b>copy ()</b> : la valeur peut être utilisée plus tard </li></ul><br>  Nous analysons le code: dans la première étape, l'expéditeur appelle une procédure appelée <i>remove_from_sender</i> à partir du module stocké dans <i>0x0.Currency</i> .  À la deuxième étape, l'expéditeur transfère les fonds au destinataire, déplaçant la valeur de la ressource de pièce dans la procédure de dépôt du module <i>0x0.Currency</i> . <br><br>  Voici trois exemples d'erreurs de code qui seront rejetées par les contrôles: <br>  <b>Duplication de fonds en changeant l'appel à <i>déplacer (pièce)</i> à <i>copier (pièce)</i></b> .  Les ressources ne peuvent être déplacées.  Tenter de dupliquer la quantité d'une ressource (par exemple, en appelant <i>copy (coin)</i> dans l'exemple ci-dessus) entraînera une erreur lors de la vérification du bytecode. <br><br>  <b>Réutilisation des fonds en spécifiant le <i>mouvement (pièce)</i> deux fois</b> .  L'ajout de la ligne <i>0x0.Currency.deposit (copy (some_other_payee), move (coin))</i> pour l'exemple ci-dessus permettra à l'expéditeur de "dépenser" les pièces deux fois - la première fois avec le bénéficiaire, et la seconde avec <i>some_other_payee</i> .  Il s'agit d'un comportement indésirable, impossible avec un actif physique.  Heureusement, Move rejettera ce programme. <br><br>  <b>Perte de fonds due à l'échec du <i>mouvement (pièce)</i></b> .  Si vous ne déplacez pas la ressource (par exemple, en supprimant la ligne contenant <i>move (coin)</i> ), une erreur sera générée en vérifiant le bytecode.  Cela protège les programmeurs Move de toute perte de fonds accidentelle ou malveillante. <br><br><h3>  Module de devise </h3><br><img src="https://habrastorage.org/webt/p1/gx/rh/p1gxrhzyyl4cmlmlq5rcr4yhzmc.png"><br><br>  Chaque compte peut contenir 0 ou plusieurs modules (représentés sous forme de rectangles) et une ou plusieurs valeurs de ressources (représentées sous forme de cylindres).  Par exemple, un compte à <i>0x0</i> contient un module <i>0x0.Currency</i> et une valeur de ressource de type <i>0x0.Currency.Coin</i> .  Le compte à <i>0x1</i> a deux ressources et un module;  Le compte à <i>0x2</i> a deux modules et une valeur de ressource. <br><br>  Quelques points: <br><br><ul><li>  Le script de transaction est atomique - soit complètement exécuté, soit pas du tout. </li><li>  Un module est un morceau de code de longue durée disponible dans le monde entier. </li><li>  L'état global est structuré comme une table de hachage, où la clé sera l'adresse du compte </li><li>  Les comptes ne peuvent pas contenir plus d'une valeur de ressource de ce type et pas plus d'un module avec un nom donné (un compte à <i>0x0</i> ne peut pas contenir une ressource supplémentaire <i>0x0.Currency.Coin</i> ou un autre module nommé <i>Currency</i> ) </li><li>  L'adresse du module déclaré fait partie du type ( <i>0x0.Currency.Coin</i> et <i>0x1.Currency.Coin</i> sont des types distincts qui ne peuvent pas être utilisés de manière interchangeable) </li><li>  Les programmeurs peuvent stocker plusieurs instances de ce type de ressource dans le compte en définissant leur ressource personnalisée - ( <i>ressource TwoCoins {c1: 0x0.Currency.Coin, c2: 0x0.Currency.Coin}</i> ) </li><li>  Vous pouvez faire référence à une ressource par son nom sans conflits, par exemple, vous pouvez faire référence à deux ressources à l'aide de <i>TwoCoins.c1</i> et <i>TwoCoins.c2</i> . </li></ul><br><h4>  Annonce de ressource de pièce de monnaie </h4><br><img src="https://habrastorage.org/webt/az/79/8o/az798o2jkg9ft5tkiisy5fitk2o.png"><br>  Un module nommé <i>Currency</i> et un type de ressource nommé <i>Coin</i> <br><br>  Quelques points: <br><br><ul><li>  <i>La pièce</i> est une structure à champ unique de type <i>u64</i> (entier non signé 64 bits) </li><li>  Seules les procédures du module <i>Devise</i> peuvent créer ou détruire des valeurs de <i>pièces</i> . </li><li>  D'autres modules et scripts peuvent écrire ou référencer le champ de valeur uniquement via des procédures ouvertes fournies par le module. </li></ul><br><h4>  Mise en œuvre du dépôt </h4><br><img src="https://habrastorage.org/webt/52/uj/nw/52ujnwxqzafegglfjqrsckqwy50.png"><br><br>  Cette procédure prend la ressource <i>Coin</i> en entrée et la combine avec la ressource <i>Coin</i> stockée dans le compte du destinataire: <br><br><ol><li>  Détruire la ressource d'entrée Coin et enregistrer sa valeur. </li><li>  Obtenir un lien vers une ressource Coin unique stockée sur le compte du destinataire. </li><li>  Modification de la valeur du montant de la pièce par la valeur transmise dans le paramètre lors de l'appel de la procédure. </li></ol><br>  Quelques points: <br><br><ul><li>  <i>Déballer, BorrowGlobal</i> - procédures intégrées </li><li>  <i>Décompresser &lt;T&gt;</i> est le seul moyen de supprimer une ressource de type T. La procédure prend la ressource en entrée, la détruit et renvoie la valeur associée aux champs de la ressource. </li><li>  <i>BorrowGlobal &lt;T&gt;</i> accepte l'adresse en entrée et renvoie un lien vers une instance unique de T publiée (détenue) par cette adresse </li><li>  <i>&amp; mut Coin</i> est un lien vers la ressource <i>Coin</i> </li></ul><br><h4>  Mettre en œuvre le retrait_de_l'expéditeur </h4><br><img src="https://habrastorage.org/webt/af/6s/h_/af6sh_tc_6jpvlwzgka0by5cnjo.png"><br><br>  Cette procédure: <br><br><ol><li>  Obtient un lien vers une ressource <i>Coin</i> unique liée au compte de l'expéditeur </li><li>  Diminue la valeur de la ressource <i>Coin</i> par référence au montant spécifié </li><li>  Crée et renvoie une nouvelle ressource <i>Coin</i> avec un solde mis à jour. </li></ol><br>  Quelques points: <br><br><ul><li>  <i>Le dépôt</i> peut être appelé par n'importe qui, mais <i>retir_de_l'expéditeur</i> n'a accès qu'aux pièces du compte appelant </li><li>  <i>GetTxnSenderAddress</i> est similaire à <i>msg.sender</i> dans <i>Solidity</i> </li><li>  <i>RejectUnless</i> est similaire à <i>exiger</i> dans Solidity.  Si cette vérification échoue, la transaction est arrêtée et toutes les modifications sont annulées. </li><li>  <i>Pack &lt;T&gt;</i> est également une procédure intégrée qui crée une nouvelle ressource de type T. </li><li>  Comme <i>Unpack &lt;T&gt;</i> , <i>Pack &lt;T&gt;</i> ne peut être appelé qu'à l'intérieur du module où la ressource <i>T est</i> décrite </li></ul><br><h3>  Conclusion </h3><br>  Nous avons examiné les principales caractéristiques du langage Move, l'avons comparé à Ethereum et nous nous sommes également familiarisés avec la syntaxe de base des scripts.  En conclusion, je recommande fortement de parcourir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre blanc d'origine</a> .  Il comprend de nombreux détails concernant les principes de conception du langage de programmation, ainsi que de nombreux liens utiles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459990/">https://habr.com/ru/post/fr459990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459978/index.html">Outils de développement Node.js. Appel de procédure à distance sur les sockets Web</a></li>
<li><a href="../fr459980/index.html">Lettres nigérianes de haute technologie</a></li>
<li><a href="../fr459982/index.html">Analyseurs de Roslyn. Comment écrire du code rapidement et avec précision</a></li>
<li><a href="../fr459984/index.html">Construire une infrastructure en tant que code avec GitLab et Ansible</a></li>
<li><a href="../fr459988/index.html">Le chien a mangé sur des réseaux de neurones</a></li>
<li><a href="../fr459992/index.html">GOST R 57100-2016. C'était quoi?</a></li>
<li><a href="../fr459994/index.html">Recherche: Linux est toujours le système d'exploitation le plus populaire dans le cloud</a></li>
<li><a href="../fr459996/index.html">Allemagne Munich Guide d'immigration avancé</a></li>
<li><a href="../fr460002/index.html">Comment nous avons créé le Dream Service Desk</a></li>
<li><a href="../fr460004/index.html">Bonne journée de l'administrateur système</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>