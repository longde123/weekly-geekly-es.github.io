<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ  ğŸ“ƒ ğŸ•°ï¸ React Native - Application dan Criticism ğŸ§”ğŸ½ ğŸš ğŸ†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Paling sering, ketika memilih bahasa ini, diharapkan bahwa pengembangan satu aplikasi untuk dua platform akan memakan waktu setengah dari pengembangan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React Native - Application dan Criticism</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468901/"><p>  Paling sering, ketika memilih bahasa ini, diharapkan bahwa pengembangan satu aplikasi untuk dua platform akan memakan waktu setengah dari pengembangan dua aplikasi.  Tetapi pada akhirnya ternyata pengembangan itu mengambil banyak, jika tidak lebih, karena kesulitan yang tersembunyi di bawah kecemerlangan dan pemasaran luar.  Kami akan berbicara tentang beberapa kesulitan serupa yang kami temui dalam beberapa bulan terakhir bekerja dengan React Native. </p><a name="habracut"></a><br><p>  React Native mengadaptasi Javascript untuk pengembangan seluler.  Ini dicapai oleh fakta bahwa ia menggunakan beberapa kolektor untuk membangun proyek - Metro Bundler, yang menginterpretasikan kode JS dan mewakili sumber daya dan pengumpul sistem target.  Dalam kasus kami, itu adalah gradle untuk Android.  Secara teori, aplikasi React Native harus dimulai dengan cukup sederhana.  Perintah run-android run-native memungkinkan Metro Bundler dan membangun aplikasi untuk semua perangkat dan emulator Android yang terhubung. </p><br><p> Pada kenyataannya, ternyata bahkan pada tahap ini ada kesulitan.  Kesalahan "Tidak dapat mengunduh bundel JS" terus-menerus muncul di proyek kami, yang berarti bundler tidak dapat menerjemahkan kode ke kode asli.  Ternyata kemudian, karena fakta bahwa itu tidak dimulai.  StackOverflow mengkonfirmasi dugaan dan menyarankan Anda harus menjalankan bundler di utas terpisah menggunakan perintah mulai asli-reaksi.  Ini memungkinkan Anda untuk me-restart bundler hanya jika package.json telah berubah, karena prosedurnya tidak terlalu memperlambat pengembangan. </p><br><p>  <em>Package.json</em> adalah file yang berisi satu set modul eksternal untuk aplikasi.  Di npmjs.com ada sejumlah besar perpustakaan yang berbeda untuk React Native, memperluas fungsionalitas dan menyederhanakan pengembangan.  Banyak perpustakaan (misalnya, Firebase) menggunakan fungsi asli, dan karenanya harus dikaitkan langsung dengan kode asli.  Untuk melakukan ini, gunakan perintah &lt;library-name&gt; tautan reaksi asli, yang harus mengonfigurasi hubungan ini dengan kode asli. </p><br><p>  Karena fakta bahwa semua perpustakaan ditulis pada waktu yang berbeda, mereka menggunakan versi SDK yang berbeda dan memerlukan pendekatan yang berbeda.  Kadang-kadang terjadi bahwa perpustakaan tidak kompatibel satu sama lain, atau versi terbaru dari perpustakaan adalah eksperimental, dan pengembang sendiri menyarankan untuk menurunkan versi ke yang kedua dari belakang.  Cukup sering, tautan tidak mengkonfigurasi semua dependensi yang diperlukan.  Jadi, untuk firebase yang disebutkan di atas, Anda perlu menambahkan banyak pustaka tambahan dalam kode asli, menghubungkan berbagai repositori eksternal, memodifikasi mainApplication.java (dan ini hanya untuk android!).  Untuk Firebase, ada instruksi yang cukup dimengerti untuk melakukan tindakan ini, tetapi untuk perpustakaan lain tidak selalu ada. </p><br><p>  Setelah koneksi dengan kode asli dikonfigurasikan, Anda dapat membangun proyek dengan harapan bahwa pustaka yang terhubung akan berfungsi.  Ketika berkumpul, perlu diingat bahwa jika Anda mendapatkan kesalahan, maka Anda harus memastikan bahwa itu muncul justru karena tindakan Anda, dan bukan karena kesalahan kolektor.  Untuk kepercayaan penuh, Anda harus melakukan urutan tindakan berikut: </p><br><pre><code class="plaintext hljs">rmdir node_modules /s /q &amp;&amp; npm cache clean - force &amp;&amp; npm i</code> </pre> <br><p>  Perintah ini akan menghapus folder node_modules dan kemudian memuatnya kembali.  Ini adalah salah satu tugas terpanjang, oleh karena itu sangat jarang menggunakannya.  Pada beberapa proyek, node_modules dapat menempati hingga beberapa gigabytes pada hard drive, dan karenanya penginstalan ulang akan memakan waktu. </p><br><pre> <code class="plaintext hljs">rmdir android/app/build /s /q</code> </pre> <br><p>  Selama pengembangan, diketahui bahwa build yang sering gagal adalah konsekuensi dari fakta bahwa kolektor tidak dapat membuat (atau menghapus) folder dari direktori debug.  Tindakan ini menyelesaikan masalah yang bereaksi tidak dapat menghapus folder sendiri.  Tetapi pada saat yang sama, menghasilkan file untuk folder ini dari awal lagi akan membutuhkan waktu ekstra. </p><br><pre> <code class="plaintext hljs">react-native start-reset-cache</code> </pre> <br><p>  Luncurkan Metro Bundler.  Tab ini harus tetap terbuka selama proses debugging.  Jika kesalahan terjadi, log kesalahan dapat muncul di sini.  Kemungkinan besar, jika terjadi kesalahan, proses ini akan berakhir, dan itu harus dimulai lagi. </p><br><pre> <code class="plaintext hljs">react-native run-android</code> </pre> <br><p>  Instal aplikasi pada perangkat atau emulator yang terhubung.  Sebagian besar kesalahan build terjadi di sini, dan beberapa di antaranya dapat dimengerti, tetapi beberapa sangat tidak rasional dan "disembuhkan" dengan memulai kembali seluruh proses. </p><br><p>  Bayangkan proses pembuatan dengan urutan perintah untuk satu proyek (sudah memiliki ranah, redux, navigasi reaksi, sekitar sepuluh perpustakaan lagi) setelah menghubungkan Firebase. </p><br><pre> <code class="plaintext hljs">react-native start react-native run-android &gt;&gt;    debug react-native run-android &gt;&gt; , metro bundler  react-native start react-native run-android &gt;&gt;    debug react-native run-android &gt;&gt;  !  metro bundler ,   JS-   react-native start &gt;&gt;   restart         - </code> </pre><br><p>  Tak perlu dikatakan, itu membutuhkan waktu yang sangat lama?  Dan ini bukan proses satu kali: pada saat dijelaskan, prosedur ini diperlukan setelah hampir setiap perubahan dalam kode program.  Dengan setiap perpustakaan baru, proyek menjadi semakin tidak stabil, dan proses ini dapat berubah, paling sering menjadi lebih buruk.  Debugging aplikasi adalah salah satu fungsi terpenting bagi pengembang, dan dalam hal ini kecepatannya menurun cukup banyak. </p><br><p>  Berbicara tentang debugging.  React Native debugger tidak hanya memiliki masalah dengan peluncuran.  Koreksi kesalahan yang ditemukan sebagai hasil dari tes ini juga merupakan proses yang agak menyakitkan.  Dalam reaksi asli, kode JS diterjemahkan ke dalam kode asli, tetapi dikaburkan selama terjemahan.  Jadi, jika Anda tidak ingin melihat kesalahan seperti "pengecualian pointer nol di zzz.yyy ()", maka Anda perlu menggunakan debugger bawaan, Anda tidak bisa membaca pengecualian di logcat.  Pada kesalahan, debugger menampilkan "layar kematian" merah dengan deskripsinya, sedikit banyak mendorong ke arah koreksi.  Tetapi ada masalah dengan bagian ini. </p><br><p>  Nah, ketika kesalahannya terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/oh/sr/zo/ohsrzozloajbn7g9y0nczb_6zkq.png"></p><br><p>  Sangat jelas apa yang terjadi di sini - alih-alih objek array yang diharapkan, this.state.noteArray.map tidak terdefinisi dalam variabel, yang menyebabkan TypeError terkenal.  Anda bisa memperbaikinya dengan membuka app.js: 14 dan memeriksa nilai dalam variabel ini sebelum digunakan. </p><br><p>  Lebih buruk ketika kesalahannya terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/wn/hb/6b/wnhb6bq3akewzc6vidymuhnv9ec.png"></p><br><p>  Jadi: </p><br><p><img src="https://habrastorage.org/webt/tn/-k/oe/tn-koehm2wzsl7gu-4hqemsvpz4.png"></p><br><p>  Atau lebih: </p><br><p><img src="https://habrastorage.org/webt/qb/jk/qw/qbjkqwgcbm59ffqwesbfholo6zu.png"></p><br><p>  Gambar diambil dari Internet, tetapi kami melihatnya langsung.  Dan terlepas dari kenyataan bahwa mereka ditampilkan dalam runtime, kesalahan ini bukan karena fakta bahwa ada sesuatu yang salah dalam kode Anda.  Ini mungkin disebabkan oleh fakta bahwa Anda menginstal pustaka secara tidak benar, atau jika impor Anda memiliki dependensi yang tidak kompatibel, atau ada yang salah dalam kode asli, dan Bereaksi mencoba untuk menangkap kesalahan.  Setiap kesalahan bersifat individual dan diselesaikan dengan sangat berbeda.  Bagus bahwa ada StackOverflow dan setidaknya beberapa jenis mode debugging. </p><br><p>  Lebih buruk lagi, ketika kesalahan tidak direproduksi dalam debug.  Kami mengalami situasi ini ketika mencoba membangun aplikasi dengan React versi baru dengan dukungan arsitektur x64 untuk Android.  Saat memasang aplikasi dengan debugger, semuanya berfungsi dengan baik.  Tapi begitu kami membuat tester di telepon, semuanya berhenti berfungsi dan rusak begitu berinteraksi dengan basis data.  Untuk men-debug non-debugging dengan tergesa-gesa, kami menggunakan pesan konsol, yang dalam hal ini adalah komponen roti panggang Android.  Komponen ini menampilkan teks pendek untuk mencapai baris kode tertentu.  Secara metodis, lebih disukai membagi kode menjadi dua, kami melokalkan fungsi di mana kesalahan terjadi dan menemukan bahwa metode Object.assign ({}, item) tidak berfungsi dalam versi baru Bereaksi.  Beruntung Anda bisa mengganti fungsi ini dengan {... item} yang lebih pendek sambil mempertahankan fungsionalitas aplikasi, tetapi pencarian untuk kesalahan ini menghabiskan waktu sekitar selusin jam kerja. </p><br><p>  Setelah penelitian kecil dilakukan mencari alasan.  Ternyata, React Native menggunakan mesin Javascript yang berbeda untuk menafsirkan kode JS dalam versi debug dan produksi: untuk debugging mesin Chrome JS, dan di JavaScriptCore.  Ya, React Native tidak menerjemahkan JavaScript ke dalam kode asli, tetapi menafsirkannya saat berjalan.  Pada saat yang sama, mesin debugging bekerja jauh lebih stabil, dan karena itu bug semakin menyusup ke dalam produksi.  Misalnya, artikel ini menunjukkan cara kerja format tanggal dalam kondisi yang berbeda.  Kembali ke kesalahan: ternyata setelah memperbarui versi React Native, mesin web produksi produksi kehilangan dukungan untuk Object.assign ().  Tetapi mesin debugging tetap sama. </p><br><p>  Mungkin opsi terburuk adalah kasus ketika aplikasi rusak di tempat acak, hanya dalam versi produksi dan tanpa log dari Bereaksi Asli.  Contoh: setelah menginstal versi rilis aplikasi di telepon, ia "bekerja untuk sementara", dan kemudian "mati tanpa kesalahan atau peringatan pada saat yang acak."  Selain itu, kesalahan tidak direproduksi di semua perangkat.  Pada akhirnya, dengan coba-coba (dan dengan mendeteksi bahwa Firebase Crashlytics yang disebutkan di atas tidak mengirimkan kesalahan yang sesuai), kami berhasil menangkap log musim gugur yang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/oh/sr/zo/ohsrzozloajbn7g9y0nczb_6zkq.png"></p><br><p>  Teks ini bahkan tidak berlaku untuk aplikasi kita, bahkan tidak ditandai dengan warna merah.  Tetapi setelah kami mendapatkannya dan pergi ke forum, kami menemukan bahwa versi baru React Native rusak.  Dan yang sebelumnya rusak.  Pada Pelacak Masalah resmi, kesalahan "Android crash: signal 11 (SIGSEGV)" ada selama dua bulan, dan kami beruntung dua hari sebelum kami pergi ke sana (!) Solusi eksperimental diusulkan untuk memperbaiki kesalahan tersebut. </p><br><p>  Sungguh ironis bahwa beberapa pengembang yang harus berurusan dengan Android Studio bingung bahwa IDE memiliki opsi seperti build / clean project atau file / cache tidak valid.  Ini diperlukan untuk menghilangkan perilaku gradle yang abnormal, dari pesan kesalahan dan peringatan yang salah, dari kesalahan sinkronisasi.  Pengembang bertanya: "mengapa kita harus melakukan pekerjaan untuk IDE kita, dalam situasi seperti itu, perintah ini harus dijalankan secara otomatis."  Dan mereka dapat dipahami, tetapi pada saat yang sama, IDE modern melakukan semua pekerjaan sulit di belakang layar.  Dan pengembang ini sama sekali tidak bekerja dengan Bereaksi Asli. </p><br><p>  Semua hal di atas adalah kasus terisolasi yang telah terjadi selama beberapa minggu terakhir.  Di sini kami tidak menjelaskan kompleksitas menjalankan aplikasi dengan Expo, dengan mengatur gaya kode di babel / eslint, kami tidak memarahi Javascript untuk fleksibilitas yang berlebihan, kami tidak memberi tahu bagaimana debugging karena hubungan redux / realm hampir sepenuhnya hilang pada salah satu proyek.  Mempertimbangkan kesulitan yang dijelaskan dari dukungan dan pengembangan dan fakta bahwa untuk dua sistem semuanya dikalikan dua, ada baiknya mempertimbangkan apakah React Native benar-benar menguntungkan?  Setelah kami menyelesaikan proyek ketiga kami dalam bahasa ini, kami memutuskan tidak.  Apa yang kamu pikirkan </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468901/">https://habr.com/ru/post/id468901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468885/index.html">Jangan belajar pola, belajar konsep</a></li>
<li><a href="../id468889/index.html">Fungsi Panggilan Balik Script</a></li>
<li><a href="../id468891/index.html">Barang antik: pertimbangkan motherboard dari komputer ke-386</a></li>
<li><a href="../id468897/index.html">SwiftUI untuk tugas kompetitif Telegram Charts terakhir (Maret 2019): semuanya sederhana</a></li>
<li><a href="../id468899/index.html">Proyek apa yang masuk akal untuk memulai dan apa yang dibutuhkan industri dari TI saat ini</a></li>
<li><a href="../id468903/index.html">Masa depan adalah milik platform pendidikan adaptif. Mengalir Wawancara dengan Asger Palm</a></li>
<li><a href="../id468905/index.html">Menuju aksesibilitas</a></li>
<li><a href="../id468907/index.html">Demodulasi Yandex</a></li>
<li><a href="../id468909/index.html">Berkat otentikasi dua faktor, saya kehilangan semua uang saya dan 3 tahun bekerja</a></li>
<li><a href="../id468911/index.html">Tanya Jawab Quantum Excellence Luar Biasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>