<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍑 👨‍✈️ ℹ️ 我们使虾更有用：将图像转码添加到其他格式 👱 🧛🏽 🐆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自2017年初以来，我们的小型团队一直在开发RESTinio OpenSource库，以将HTTP服务器嵌入C ++应用程序中。 令我们感到惊讶的是，我们有时会收到“为什么为什么需要嵌入式C ++ HTTP服务器？”这一类别的问题。 不幸的是，最简单的问题很难回答。 有时最好的答案是示例代码。 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使虾更有用：将图像转码添加到其他格式</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br> 自2017年初以来，我们的小型团队一直在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RESTinio OpenSource库，</a>以将HTTP服务器嵌入C ++应用程序中。 令我们感到惊讶的是，我们有时会收到“为什么为什么需要嵌入式C ++ HTTP服务器？”这一类别的问题。 不幸的是，最简单的问题很难回答。 有时最好的答案是示例代码。 <br><br> 几个月前，我们启动了一个小型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示项目Shrimp</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目</a>清楚地展示了一个典型的场景，在该场景下，我们的图书馆被“锐化了”。 该演示项目是一个简单的Web服务，它接收缩放服务器上存储的图像的请求，并返回用户所需大小的图片。 <br><br> 该演示项目的优点在于，首先，它需要与很久以前用C或C ++（在本例中为ImageMagick）编写并正常工作的代码进行集成。 因此，应该清楚为什么将HTTP服务器嵌入C ++应用程序才有意义。 <br><br> 其次，在这种情况下，需要异步处理请求，以便在缩放图像时HTTP服务器不会阻塞（这可能需要数百毫秒甚至几秒钟）。 正是由于我们找不到专门针对异步请求处理的健全的C ++嵌入式服务器，我们才开始RESTinio的开发。 <br><br> 我们迭代地在Shrimp上构建工作：首先，制作并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a>了最简单的版本，仅缩放了图片。 然后，我们修复了第一个版本的许多缺点，并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在第二篇文章中对此进行了描述</a> 。 最后，我们再次扩展了Shrimp的功能：添加了图像从一种格式到另一种格式的转换。 有关如何完成的，将在本文中进行讨论。 <br><a name="habracut"></a><br><h1> 目标格式支持 </h1><br> 因此，在下一版本的Shrimp中，我们添加了以不同格式生成缩放图片的功能。 因此，如果您发出以下形式的虾请求： <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br> 然后虾将以与原始图像相同的JPG格式渲染图像。 <br><br> 但是，如果将target-format参数添加到URL，则Shrimp会将图像转换为指定的目标格式。 例如： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br> 在这种情况下，Shrimp将以webp格式呈现图像。 <br><br> 更新的虾支持五种图像格式：jpg，png，gif，webp和heic（也称为HEIF）。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在特殊的网页上</a>尝试各种格式： <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  （在此页面上，无法选择heic格式，因为默认情况下普通台式机浏览器不支持此格式）。 <br><br> 为了支持Shrimp中的目标格式，需要稍微修改Shrimp代码（我们自己很惊讶，因为实际上所做的更改很少）。 但另一方面，我不得不玩ImageMagick的程序集，对此我们感到更加惊讶，因为 较早之前，我们不得不通过偶然的方式来处理这个厨房。 但是，让我们依次讨论所有内容。 <br><br><h2>  ImageMagick必须了解不同的格式 </h2><br>  ImageMagick使用外部库对图像进行编码/解码：libjpeg，libpng，libgif等。 在配置和构建ImageMagick之前，必须在系统上安装这些库。 <br><br> 为了使ImageMagick支持webp和heic格式，应该发生相同的事情：首先，您需要构建并安装libwebp和libheif，然后配置并安装ImageMagick。 如果使用libwebp一切都很简单，那么在libheif周围，我不得不和手鼓跳舞。 尽管过了一段时间，所有事情终于都收集起来并工作了，但现在还不清楚：为什么你不得不诉诸手鼓，一切似乎都很琐碎？  ;） <br><br> 通常，如果有人想与heic和ImageMagick交朋友，则必须安装： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来自videolan.org的x265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">利比耶夫</a> </li></ul><br> 它的顺序是这样（您可能必须安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nasm</a>才能使x265以最快的速度工作）。 然后，在发出<i>./configure</i>命令时，ImageMagick将能够找到支持.heic文件所需的所有内容。 <br><br><h2> 支持传入请求的查询字符串中的目标格式 </h2><br> 在使用webp和heic格式使ImageMagick成为朋友之后，是时候修改Shrimp代码了。 首先，我们需要学习如何识别传入HTTP请求中的target-format参数。 <br><br> 从RESTinio的角度来看，这根本不是问题。 好吧，查询字符串中出现了另一个参数，那又如何呢？ 但是从Shrimp的角度来看，情况变得更加复杂，因此负责解析HTTP请求的功能的代码也变得更加复杂。 <br><br> 事实是，在仅需要区分两种情况之前： <br><br><ul><li> 发出的形式为“ /filename.ext”的请求没有任何其他参数。 因此，您只需要原样提供文件“ filename.ext”即可； </li><li> 请求以“ /filename.ext?op=resize＆...”的形式出现。 在这种情况下，您需要从文件“ filename.ext”缩放图像。 </li></ul><br> 但是在添加了目标格式之后，我们需要区分四种情况： <br><br><ul><li> 发出的形式为“ /filename.ext”的请求没有任何其他参数。 因此，您只需要按原样提供文件“ filename.ext”，无需缩放即可将其转码为另一种格式； </li><li> 发出的格式为“ /filename.ext?target-format=fmt”的请求没有任何其他参数。 这意味着从文件“ filename.ext”中获取图像并将其转码为“ fmt”格式，同时保留原始大小； </li><li> 请求的格式为“ /filename.ext?op=resize＆...”，但没有目标格式。 在这种情况下，您需要缩放文件“ filename.ext”中的图像并以原始格式提供图像； </li><li> 请求的格式为“ /filename.ext?op=resize&amp;...&amp;target-format=fmt”。 在这种情况下，您需要执行缩放，然后将结果转码为“ fmt”格式。 </li></ul><br> 结果，用于确定查询参数的函数采用<a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">以下形式</a> ： <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br> 在Shrimp的先前版本中，您无需对图像进行转码，使用请求参数<a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">看起来更加容易</a> 。 <br><br><h2> 针对目标格式量身定制的请求队列和图像缓存 </h2><br> 实现目标格式支持的下一点是在a_transform_manager代理中处理等待请求队列和现成图像的缓存。 我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在上一篇文章中</a>更详细地讨论了这些事情，但让我们稍微提醒一下它的含义。 <br><br> 当图像转换请求到达时，可能会发现具有此类参数的完成图像已在缓存中。 在这种情况下，您无需执行任何操作，只需从缓存中发送图像作为响应即可。 如果需要转换图片，则可能表明目前没有免费的工作人员，您需要等待直到图片出现。 为此，必须将请求信息排队。 但同时，有必要检查请求的唯一性-如果我们有三个相同的请求在等待处理（即我们需要以相同的方式转换相同的图像），那么我们应该只处理一次图像，并给出处理结果作为响应对这三个请求。 即 在等待队列中，必须将相同的请求分组。 <br><br> 在Shrimp的早期，我们使用了一个简单的组合键来搜索图像缓存和等待队列： <a href="">原始文件名+图像大小调整选项的组合</a> 。 现在，必须考虑两个新因素： <br><br><ul><li> 首先，目标图像格式（即原始图像可以是jpg，结果图像可以是png）； </li><li> 其次，缩放图片可能不是必需的。 发生这种情况的情况下，客户端仅命令将图像从一种格式转换为另一种格式，但保留了图像的原始大小。 </li></ul><br> 我必须说，这里我们走了最简单的道路，而没有尝试以某种方式优化任何东西。 例如，一个可以尝试建立两个缓存：一个以原始格式存储图像，但按比例缩放到所需的大小，第二个，将缩放后的图像转换为目标格式。 <br><br> 为什么需要这种双重缓存？ 事实是，在转换图片时，时间上两个最昂贵的操作是将图片调整大小并将其序列化为目标格式。 因此，如果我们收到了将example.jpg图像缩放到1920宽度并将其转换为webp格式的请求，则可以在内存中存储两个图像：example_1920px_width.jpg和example_1920px_width.webp。 当我们收到第二个请求时，我们将提供一个example_1920px_width.webp图片。 但是，在接收将example.jpg缩放为1920宽度并将其转换为heic格式的请求时，可以使用example_1920px_width.jpg图片。 我们可以跳过调整大小的操作，而只进行格式转换（即，完成的图像example_1920px_width.jpg将被转码为heic格式）。 <br><br> 另一个潜在机会：当请求将图像转码为其他格式而不调整大小时，您可以确定图像的实际大小，并在组合键中使用此大小。 例如，让example.jpg的大小为3000x2000像素。 如果下一次收到将example.jpg缩放到2000px高度的请求，那么我们可以立即确定我们已经有此尺寸的图片。 <br><br> 从理论上讲，所有这些考虑都值得关注。 但是从实际的角度来看，尚不清楚这种事件发展的可能性有多高。 即 我们多久会收到将example.jpg缩放到1920px并转换为webp的请求，然后又收到对同一图像进行相同缩放但转换为png的请求？ 没有真实的统计数据很难说。 因此，我们决定不让我们的演示项目复杂化，而是首先走最简单的道路。 期望如果有人需要更高级的缓存方案，则可以在以后使用真实的，非虚构的Shrimp场景开始添加。 <br><br> 结果，在更新版本的Shrimp中，我们稍微扩展了密钥，并在其中添加了诸如目标格式之类的参数： <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br> 即 将example.jpg调整为1920px并转换为png的请求与相同的调整大小不同，但转换为webp或heic。 <br><br> 但是，主要焦点在于<a href="">resize_params_t类的新实现，该实现</a>确定了缩放图像的新大小。  <a href="">以前，此类</a>支持三个选项：仅设置宽度，仅设置高度或设置长边（高度或宽度由当前图像大小确定）。 因此， <a href="">resize_params_t :: value（）</a>方法始终返回一些实际值（该值由<a href="">resize_params_t :: mode（）</a>方法确定）。 <br><br> 但是在新的Shrimp中，添加了另一种模式-keep_original，这意味着不执行缩放并且图片以其原始大小进行渲染。 为了支持此模式，resize_params_t必须进行一些更改。 首先，现在， <a href="">resize_params_t :: make（）</a>方法确定是否使用keep_original模式（如果未指定传入请求的查询字符串中的width，height和max参数，则认为使用了该模式）。 这使我们不必重写<a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request（）</a>函数，该函数<a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">将按</a>比例缩放要执行的图片的请求。 <br><br> 其次，现在不总是可以调用<a href="">resize_params_t :: value（）</a>方法，而仅在缩放模式不同于keep_original时才可以调用。 <br><br> 但是最重​​要的是<a href="">resize_params_t ::运算符&lt;（）</a>继续按预期工作。 <br><br> 由于a_transform_manager中的所有这些更改，缩放后的图像缓存和等待请求的队列都保持不变。 但是现在，有关各种查询的信息存储在这些数据结构中。 因此，键{“ example.jpg”，“ jpg”，keep_original}与键{“ example.jpg”，“ png”，keep_original}以及键{“ example.jpg”，“ jpg”，宽度= 1920px}。 <br><br> 事实证明，在简化诸如resize_params_t和resize_params_key_t这样的简单数据结构的定义时，我们避免了更改更复杂的结构，例如生成的图像的缓存和等待请求的队列。 <br><br><h2> 支持a_transformer中的目标格式 </h2><br> 好了，支持目标格式的最后一步是扩展a_transformer代理的逻辑，以便将可能已经缩放的图片转换为目标格式。 <br><br> 事实证明，这样做最简单，所需要做的只是扩展<a href="">a_transform_t :: handle_resize_request（）</a>方法的代码： <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br> 与<a href="">以前的版本</a>相比<a href="">，</a>有两个基本补充。 <br><br> 首先，在调整大小后调用真正魔术的image.magick（）方法。 此方法告诉ImageMagick生成的图像格式。 同时，图像在内存中的表示形式不会更改-ImageMagick继续存储适合的图像。 但是，在随后的Image :: write（）调用期间，将考虑magick（）方法设置的值。 <br><br> 其次，更新的版本记录了将图像序列化为指定格式所花费的时间。 现在，新版本的Shrimp分别修复了缩放所花费的时间以及转换为目标格式所花费的时间。 <br><br> 代理a_transformer_t的其余部分未进行任何更改。 <br><br><h1>  ImageMagick并行化 </h1><br> 默认情况下，ImageMagic内置OpenMP支持。 即 可以并行处理ImageMagick执行的图像上的操作。 您可以使用环境变量MAGICK_THREAD_LIMIT来控制ImageMagick在这种情况下使用的工作流程数量。 <br><br> 例如，在我的测试机上，值MAGICK_THREAD_LIMIT = 1（即，没有真正的并行化），我得到以下结果： <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br> 调整大小所花费的时间在Shrimp-Resize-Time标头中指示。 在这种情况下，为1086.72ms。 <br><br> 但是，如果您在同一台计算机上设置MAGICK_THREAD_LIMIT = 3并运行Shrimp，那么我们将获得不同的值： <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br> 即 调整大小时间减少到558.25ms。 <br><br> 因此，由于ImageMagick提供了并行计算的功能，因此您可以利用这一机会。 但同时，人们希望能够控制虾自己带走了多少个工作线程。 在早期版本的Shrimp中，无法影响Shrimp创建的工作流程数量。 在虾的更新版本中，可以做到这一点。 或通过环境变量，例如： <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br> 或通过命令行参数，例如： <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br> 通过命令行指定的值具有更高的优先级。 <br><br> 应该强调的是，MAGICK_THREAD_LIMIT仅影响ImageMagick自身执行的那些操作。 例如，调整大小是由ImageMagick完成的。 但是从一种格式到另一种ImageMagick的转换将委托给外部库。 这些外部库中的操作如何并行化是我们不了解的单独问题。 <br><br><h1> 结论 </h1><br> 也许在此版本的Shrimp中，我们使演示项目达到了可接受的状态。 想要观看和实验的人可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BitBucket</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上找到Shrimp的源文本。 您还可以在那里找到Dockerfile来为您的实验构建Shrimp。 <br><br> 总的来说，我们通过启动此演示项目实现了我们设定的目标。 为了进一步开发RESTinio和SObjectizer，出现了许多想法，其中一些已经找到了体现。 因此，虾是否会进一步发展完全取决于问题和愿望。 如果有的话，虾可以扩大。 如果不是这样，那么Shrimp将仍然是一个演示项目和一个试验场，用于试验RESTinio和SObjectizer的新版本。 <br><br> 最后，我要特别感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">aensidhe</a>的帮助和建议，如果没有他们的帮助和建议，我们与铃鼓的舞蹈将变得更长而悲伤。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420353/">https://habr.com/ru/post/zh-CN420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420343/index.html">LED灯行</a></li>
<li><a href="../zh-CN420345/index.html">IXcellerate数据中心概述（俄罗斯联邦最大的机房）</a></li>
<li><a href="../zh-CN420347/index.html">了解如何在不到4分钟的时间内创建自己的bash命令</a></li>
<li><a href="../zh-CN420349/index.html">IT外包清单：无风险工作</a></li>
<li><a href="../zh-CN420351/index.html">如何使用Vue在GitHub上进行用户搜索</a></li>
<li><a href="../zh-CN420355/index.html">智能手表Pebble：如何在一夜之间变得稀有</a></li>
<li><a href="../zh-CN420357/index.html">Vuex：构建大型项目并使用模块</a></li>
<li><a href="../zh-CN420359/index.html">Var，let还是const？ 可变范围问题和ES6</a></li>
<li><a href="../zh-CN420361/index.html">在.NET WPF中运行TextBox.GetLineText时的错误</a></li>
<li><a href="../zh-CN420363/index.html">8月至10月的HPE网络研讨会：新主题（+ SHD，AI实践，交钥匙PB存储）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>