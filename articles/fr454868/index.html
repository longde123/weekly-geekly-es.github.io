<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛲️ 👵🏻 🤛🏽 Compilation de C dans WebAssembly sans Emscripten 👨🏽‍🎓 🧔🏼 👩🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le compilateur fait partie d' Emscripten . Mais que se passe-t-il si vous retirez tous les sifflets et ne le laissez que? 

 Emscripten est requis pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compilation de C dans WebAssembly sans Emscripten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454868/"> Le compilateur fait partie d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> .  Mais que se passe-t-il si vous retirez tous les sifflets et ne le laissez que? <br><br>  Emscripten est requis pour compiler C / C ++ dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebAssembly</a> .  Mais c'est bien plus qu'un simple compilateur.  L'objectif d'Emscripten est de remplacer complètement votre compilateur C / C ++ et d'exécuter du code sur le Web qui n'est <b>pas</b> initialement <b>conçu</b> pour le Web.  Pour cela, Emscripten émule l'intégralité du système d'exploitation POSIX.  Si le programme utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fopen ()</a> , Emscripten fournira une émulation du système de fichiers.  Si OpenGL est utilisé, Emscripten fournira un contexte GL compatible C pris en charge par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebGL</a> .  C'est beaucoup de travail et beaucoup de code qui devra être implémenté dans le package final.  Mais pouvez-vous juste ... l'enlever? <br><a name="habracut"></a><br>  Le <i>compilateur</i> réel dans la boîte à outils Emscripten est LLVM.  C'est lui qui traduit le code C en bytecode WebAssembly.  Il s'agit d'un cadre modulaire moderne pour l'analyse, la transformation et l'optimisation des programmes.  LLVM est modulaire dans le sens où il ne se compile jamais directement en code machine.  Au lieu de cela, le <i>compilateur frontal</i> intégré génère <i>une représentation intermédiaire</i> (IR).  Cette représentation intermédiaire, en fait, est appelée LLVM, une abréviation de Low-Level Virtual Machine, d'où le nom du projet. <br><br>  Le <i>compilateur principal</i> traduit <i>ensuite</i> l'IR en code machine hôte.  L'avantage de cette séparation stricte est que les nouvelles architectures sont prises en charge par l'ajout «simple» d'un nouveau compilateur.  En ce sens, WebAssembly n'est que l'un des nombreux objectifs de compilation pris en charge par LLVM, et pendant un certain temps, il a été activé avec un indicateur spécial.  À partir de LLVM 8, la cible de compilation WebAssembly est disponible par défaut. <br><br>  Sur MacOS, vous pouvez installer LLVM en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homebrew</a> : <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  Vérifiez la prise en charge de WebAssembly: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># …,  … systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  Il semble que nous soyons prêts! <br><br><h1>  Compiler C à la dure </h1><br><blockquote>  <b>Remarque:</b> voici quelques formats RAW WebAssembly de bas niveau.  Si vous avez du mal à comprendre, c'est normal.  <b>Une bonne utilisation de WebAssembly ne nécessite pas une compréhension de l'intégralité du texte de cet article.</b>  <b>Si vous recherchez du code pour copier-coller, consultez l'appel au compilateur dans la section Optimisation</b> .  Mais si ça vous intéresse, continuez à lire!  J'ai précédemment écrit une introduction à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Webassembly pur</a> et à WAT: ce sont les bases nécessaires pour comprendre ce post. </blockquote>  Avertissement: je vais légèrement dévier de la norme et essayer d'utiliser des formats lisibles par l'homme à chaque étape (dans la mesure du possible).  Notre programme ici sera très simple afin d'éviter les situations frontalières et de ne pas se laisser distraire: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  Quel magnifique exploit d'ingénierie!  Surtout parce que le programme s'appelle <i>ajouter</i> , mais en réalité il <i>n'ajoute</i> rien (n'ajoute pas).  Plus important encore: le programme n'utilise pas la bibliothèque standard, et des types ici, seulement «int». <br><br><h3>  Transformer C en une vue LLVM interne </h3><br>  La première étape consiste à transformer notre programme C en LLVM IR.  C'est la tâche du compilateur frontal <code>clang</code> , qui est installé avec LLVM: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  Et en conséquence, nous obtenons <code>add.ll</code> avec une représentation interne de LLVM IR.  <b>Je ne le montre que par souci d'exhaustivité</b> .  Lorsque vous travaillez avec WebAssembly ou même clang, en tant que développeur C, vous <i>n'entrerez</i> jamais en contact avec LLVM IR. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR regorge de métadonnées et d'annotations supplémentaires, ce qui permet au compilateur de prendre des décisions plus éclairées lors de la génération du code machine.</i> <br><br><h3>  Transformez LLVM IR en fichiers objets </h3><br>  L'étape suivante consiste à appeler le compilateur d'arrière-plan <code>llc</code> pour créer un fichier objet à partir de la représentation interne. <br><br>  Le fichier de sortie <code>add.o</code> est déjà un module WebAssembly valide qui contient tout le code compilé de notre fichier C. Mais généralement, vous ne pourrez pas exécuter les fichiers objets car ils manquent de parties essentielles. <br><br>  Si nous <code>-filetype=obj</code> dans la commande, nous obtiendrions l'assembleur LLVM pour WebAssembly, un format lisible par l'homme qui est quelque peu similaire à WAT.  Cependant, l'outil <code>llvm-mc</code> pour travailler avec de tels fichiers ne prend pas encore totalement en charge le format et ne peut souvent pas traiter les fichiers.  Par conséquent, nous démontons les fichiers objets après coup.  Un outil spécifique est nécessaire pour vérifier ces fichiers objets.  Dans le cas de WebAssembly, il s'agit de <code>wasm-objdump</code> , qui fait partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebAssembly Binary Toolkit</a> ou wabt pour faire court. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  La sortie montre que notre fonction add () est dans ce module, mais elle contient également <i>des</i> sections <i>personnalisées</i> avec des métadonnées et, étonnamment, plusieurs importations.  À l'étape suivante de la <i>liaison,</i> les sections personnalisées seront analysées et supprimées, et l'éditeur de liens (éditeur de liens) s'occupera de l'importation. <br><br><h3>  Disposition </h3><br>  Traditionnellement, la tâche de l'éditeur de liens est d'assembler plusieurs fichiers objets dans un fichier exécutable.  L'éditeur de liens LLVM est appelé <code>lld</code> et il est appelé avec le lien symbolique cible.  Pour WebAssembly, ce <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  Le résultat est un module WebAssembly de 262 octets. <br><br><h3>  Lancement </h3><br>  Bien sûr, le plus important est de voir que tout fonctionne <i>vraiment</i> .  Comme dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> , vous pouvez utiliser quelques lignes de JavaScript intégré pour charger et exécuter ce module WebAssembly. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Si tout va bien, vous verrez le numéro 17 dans la console DevTool <b>Nous venons de compiler avec succès C dans WebAssembly sans toucher Emscripten.</b>  Il convient également de noter qu'il n'existe aucun middleware pour configurer et charger le module WebAssembly. <br><br><h1>  Compiler C est un peu plus simple </h1><br>  Pour compiler C dans WebAssembly, nous avons pris de nombreuses mesures.  Comme je l'ai dit, à des fins pédagogiques, nous avons examiné en détail toutes les étapes.  Ignorons les formats intermédiaires lisibles par l'homme et appliquons immédiatement le compilateur C comme un couteau suisse, tel qu'il a été développé: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Ici, nous obtenons le même fichier <code>.wasm</code> , mais avec une seule commande. <br><br><h1>  Optimisation </h1><br>  Jetez un œil au WAT de notre module WebAssembly en exécutant <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, quel bon code.  À ma grande surprise, le module utilise de la mémoire (comme le <code>i32.store</code> <code>i32.load</code> et <code>i32.store</code> ), huit variables locales et plusieurs variables globales.  Vous pouvez probablement écrire manuellement une version plus concise.  Ce programme est si grand parce que nous n'avons appliqué aucune optimisation.  Faisons-le: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Remarque:</b> techniquement, l'optimisation de la mise en page (LTO) n'offre aucun avantage car nous ne composons qu'un seul fichier.  Dans les grands projets, LTO contribuera à réduire considérablement la taille du fichier. </blockquote>  Après avoir exécuté ces commandes, le fichier <code>.wasm</code> passé de 262 à 197 octets, et WAT est également devenu beaucoup plus simple: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Appelez la bibliothèque standard </h1><br>  L'utilisation de C sans la bibliothèque libc standard semble plutôt grossière.  Il est logique de l'ajouter, mais je vais être honnête: ce <i>ne</i> sera <i>pas</i> facile.  <b>En fait, nous n'appelons directement aucune bibliothèque libc dans l'article</b> .  Il en existe plusieurs, en particulier la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glibc</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">musl</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dietlibc</a> .  Cependant, la plupart de ces bibliothèques sont supposées s'exécuter dans le système d'exploitation POSIX, qui implémente un certain ensemble d'appels système.  Comme nous n'avons pas d'interface noyau en JavaScript, nous devrons implémenter nous-mêmes ces appels système POSIX, probablement via JavaScript.  C'est une tâche difficile et je ne vais pas le faire ici.  La bonne nouvelle est que c'est <b>ce que Emscripten fait pour vous</b> . <br><br>  Bien sûr, toutes les fonctions libc ne dépendent pas des appels système.  Des fonctions telles que <code>strlen()</code> , <code>sin()</code> ou même <code>memset()</code> sont implémentées en simple C. Cela signifie que vous pouvez utiliser ces fonctions ou même simplement copier / coller leur implémentation à partir d'une bibliothèque mentionnée. <br><br><h1>  Mémoire dynamique </h1><br>  Sans libc, les interfaces C fondamentales telles que <code>malloc()</code> et <code>free()</code> ne sont pas disponibles pour nous.  Dans le WAT non optimisé, nous avons vu que le compilateur utilise de la mémoire si nécessaire.  Cela signifie que nous ne pouvons pas simplement utiliser la mémoire comme nous le voulons, sans risquer de l'endommager.  Vous devez comprendre comment il est utilisé. <br><br><h3>  Modèles de mémoire LLVM </h3><br>  La méthode de segmentation de la mémoire WebAssembly surprendra un peu les programmeurs expérimentés.  Premièrement, dans WebAssembly, une adresse nulle est techniquement admissible, mais souvent elle est toujours traitée comme une erreur.  Deuxièmement, la pile vient en premier et croît (vers des adresses inférieures), et le tas apparaît plus tard et grandit.  La raison en est que la mémoire de WebAssembly peut augmenter lors de l'exécution.  Cela signifie qu'il n'y a pas d'extrémité fixe pour accueillir la pile ou le tas. <br><br>  Voici la disposition <code>wasm-ld</code> : <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">La pile grandit et le tas grandit.</font></i>  <i><font color="gray">La pile commence par <code>__data_end</code> et le tas <code>__heap_base</code> par <code>__heap_base</code> .</font></i>  <i><font color="gray">Étant donné que la pile est placée en premier, elle est limitée par la taille maximale définie lors de la compilation, c'est-à-dire <code>__heap_base</code> moins <code>__data_end</code></font></i> <br><br>  Si nous revenons en arrière et regardons la section des globaux dans notre WAT, nous trouvons ces valeurs: <code>__heap_base</code> défini sur 66560, et <code>__data_end</code> est défini sur 1024. Cela signifie que la pile peut atteindre un maximum de 64 Ko, ce qui n'est pas beaucoup.  Heureusement, <code>wasm-ld</code> vous permet de modifier cette valeur: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Ensemble d'allocateur </h3><br>  La zone de <code>__heap_base</code> de <code>__heap_base</code> est connue pour commencer par <code>__heap_base</code> .  Comme la fonction <code>malloc()</code> est manquante, nous savons que la prochaine zone mémoire peut être utilisée en toute sécurité.  Nous pouvons y placer les données comme nous le souhaitons, et il n'est pas nécessaire d'avoir peur de la corruption de la mémoire, car la pile croît dans l'autre sens.  Cependant, un tas gratuit pour tout le monde peut rapidement se boucher, donc généralement une sorte de gestion dynamique de la mémoire est nécessaire.  Une option consiste à prendre une implémentation à part entière de malloc (), telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'implémentation malloc de Doug Lee</a> , qui est utilisée dans Emscripten.  Il existe plusieurs autres petites implémentations avec divers compromis. <br><br>  Mais pourquoi ne pas écrire votre propre <code>malloc()</code> ?  Nous sommes si profondément enlisés que cela ne fait aucune différence.  L'un des plus simples est un allocateur de relief: il est ultra-rapide, extrêmement petit et facile à implémenter.  Mais il y a un inconvénient: vous ne pouvez pas libérer de mémoire.  Bien qu'à première vue un tel allocateur semble incroyablement inutile, mais lors du développement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Squoosh,</a> je suis tombé sur des précédents où ce serait un excellent choix.  Le concept d'allocateur de relief est que nous stockons l'adresse de départ de la mémoire inutilisée comme globale.  Si le programme demande <code>n</code> octets de mémoire, nous déplaçons le marqueur sur <code>n</code> et retournons la valeur précédente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Les variables globales de WAT sont en fait définies par <code>wasm-ld</code> , de sorte que nous pouvons y accéder à partir de notre code C en tant que variables ordinaires si nous les déclarons <code>extern</code> .  Donc, <b>nous venons d'écrire notre propre <code>malloc()</code> ... en cinq lignes de C.</b> <br><br><blockquote>  <b>Remarque:</b> notre bump allocator n'est pas entièrement compatible avec <code>malloc()</code> de C. Par exemple, nous ne donnons aucune garantie d'alignement.  Mais cela fonctionne assez bien, alors ... </blockquote><h3>  Utilisation dynamique de la mémoire </h3><br>  Pour tester, créons une fonction C, qui prend un tableau de nombres de taille arbitraire et calcule la somme.  Pas très intéressant, mais cela nous oblige à utiliser la mémoire dynamique, car nous ne connaissons pas la taille du tableau lors de l'assemblage: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Espérons que la fonction sum () soit assez simple.  Une question plus intéressante est de savoir comment passer un tableau de JavaScript à WebAssembly - après tout, WebAssembly ne comprend que les nombres.  L'idée générale est d'utiliser <code>malloc()</code> <i>partir de JavaScript</i> pour allouer un morceau de mémoire, y copier les valeurs et passer l'adresse (nombre!) <i>Où</i> se trouve <i>le</i> tableau: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Après le démarrage, vous devriez voir la réponse 15 dans la console DevTools, qui est vraiment la somme de tous les nombres de 1 à 5. <br><br><h1>  Conclusion </h1><br>  Alors, vous lisez jusqu'à la fin.  Félicitations!  Encore une fois, si vous vous sentez un peu surchargé, tout est en ordre.  <b>Il n'est pas nécessaire de lire tous les détails.</b>  <b>Les comprendre est complètement facultatif pour un bon développeur Web et n'est même pas nécessaire pour l'excellente utilisation de WebAssembly</b> .  Mais je voulais partager cette information, car elle vous permet d'apprécier vraiment tout le travail qu'un projet comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> fait pour vous.  Dans le même temps, cela permet de comprendre à quel point les modules purement informatiques de WebAssembly peuvent être petits.  Le module Wasm pour additionner le tableau ne fait que 230 octets, <i>y compris un allocateur de mémoire dynamique</i> .  La compilation du même code avec Emscripten produira 100 octets de code WebAssembly et 11K de code de liaison JavaScript.  Vous devez essayer pour un tel résultat, mais il y a des situations où cela en vaut la peine. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454868/">https://habr.com/ru/post/fr454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454844/index.html">Odigest: intéressant pour les créateurs de la semaine</a></li>
<li><a href="../fr454850/index.html">L'évolution d'un algorithme unique</a></li>
<li><a href="../fr454856/index.html">Nous analysons les vulnérabilités de validation de certificat SSL / TLS dans un logiciel non navigateur</a></li>
<li><a href="../fr454860/index.html">Aidons QueryProvider à gérer les chaînes interpolées</a></li>
<li><a href="../fr454864/index.html">Comment sont les processus de développement dans différentes entreprises</a></li>
<li><a href="../fr454872/index.html">Space Invaders: maintenant en 512 octets (assembleur x86)</a></li>
<li><a href="../fr454874/index.html">Un peu sur le multitâche dans les microcontrôleurs</a></li>
<li><a href="../fr454876/index.html">A propos de la conception d'un système flexible de capacités de personnage dans les jeux</a></li>
<li><a href="../fr454878/index.html">Nous étudions MITRE ATT & CK. Matrices mobiles: accès aux appareils. 3e partie</a></li>
<li><a href="../fr454880/index.html">«Hors saison» dans la vie d'un pigiste: comment survivre et survivre?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>