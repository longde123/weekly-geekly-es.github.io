<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ≤Ô∏è üëµüèª ü§õüèΩ Compilation de C dans WebAssembly sans Emscripten üë®üèΩ‚Äçüéì üßîüèº üë©üèº‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le compilateur fait partie d' Emscripten . Mais que se passe-t-il si vous retirez tous les sifflets et ne le laissez que? 

 Emscripten est requis pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compilation de C dans WebAssembly sans Emscripten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454868/"> Le compilateur fait partie d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> .  Mais que se passe-t-il si vous retirez tous les sifflets et ne le laissez que? <br><br>  Emscripten est requis pour compiler C / C ++ dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebAssembly</a> .  Mais c'est bien plus qu'un simple compilateur.  L'objectif d'Emscripten est de remplacer compl√®tement votre compilateur C / C ++ et d'ex√©cuter du code sur le Web qui n'est <b>pas</b> initialement <b>con√ßu</b> pour le Web.  Pour cela, Emscripten √©mule l'int√©gralit√© du syst√®me d'exploitation POSIX.  Si le programme utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fopen ()</a> , Emscripten fournira une √©mulation du syst√®me de fichiers.  Si OpenGL est utilis√©, Emscripten fournira un contexte GL compatible C pris en charge par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebGL</a> .  C'est beaucoup de travail et beaucoup de code qui devra √™tre impl√©ment√© dans le package final.  Mais pouvez-vous juste ... l'enlever? <br><a name="habracut"></a><br>  Le <i>compilateur</i> r√©el dans la bo√Æte √† outils Emscripten est LLVM.  C'est lui qui traduit le code C en bytecode WebAssembly.  Il s'agit d'un cadre modulaire moderne pour l'analyse, la transformation et l'optimisation des programmes.  LLVM est modulaire dans le sens o√π il ne se compile jamais directement en code machine.  Au lieu de cela, le <i>compilateur frontal</i> int√©gr√© g√©n√®re <i>une repr√©sentation interm√©diaire</i> (IR).  Cette repr√©sentation interm√©diaire, en fait, est appel√©e LLVM, une abr√©viation de Low-Level Virtual Machine, d'o√π le nom du projet. <br><br>  Le <i>compilateur principal</i> traduit <i>ensuite</i> l'IR en code machine h√¥te.  L'avantage de cette s√©paration stricte est que les nouvelles architectures sont prises en charge par l'ajout ¬´simple¬ª d'un nouveau compilateur.  En ce sens, WebAssembly n'est que l'un des nombreux objectifs de compilation pris en charge par LLVM, et pendant un certain temps, il a √©t√© activ√© avec un indicateur sp√©cial.  √Ä partir de LLVM 8, la cible de compilation WebAssembly est disponible par d√©faut. <br><br>  Sur MacOS, vous pouvez installer LLVM en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homebrew</a> : <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  V√©rifiez la prise en charge de WebAssembly: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># ‚Ä¶,  ‚Ä¶ systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  Il semble que nous soyons pr√™ts! <br><br><h1>  Compiler C √† la dure </h1><br><blockquote>  <b>Remarque:</b> voici quelques formats RAW WebAssembly de bas niveau.  Si vous avez du mal √† comprendre, c'est normal.  <b>Une bonne utilisation de WebAssembly ne n√©cessite pas une compr√©hension de l'int√©gralit√© du texte de cet article.</b>  <b>Si vous recherchez du code pour copier-coller, consultez l'appel au compilateur dans la section Optimisation</b> .  Mais si √ßa vous int√©resse, continuez √† lire!  J'ai pr√©c√©demment √©crit une introduction √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Webassembly pur</a> et √† WAT: ce sont les bases n√©cessaires pour comprendre ce post. </blockquote>  Avertissement: je vais l√©g√®rement d√©vier de la norme et essayer d'utiliser des formats lisibles par l'homme √† chaque √©tape (dans la mesure du possible).  Notre programme ici sera tr√®s simple afin d'√©viter les situations frontali√®res et de ne pas se laisser distraire: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  Quel magnifique exploit d'ing√©nierie!  Surtout parce que le programme s'appelle <i>ajouter</i> , mais en r√©alit√© il <i>n'ajoute</i> rien (n'ajoute pas).  Plus important encore: le programme n'utilise pas la biblioth√®que standard, et des types ici, seulement ¬´int¬ª. <br><br><h3>  Transformer C en une vue LLVM interne </h3><br>  La premi√®re √©tape consiste √† transformer notre programme C en LLVM IR.  C'est la t√¢che du compilateur frontal <code>clang</code> , qui est install√© avec LLVM: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  Et en cons√©quence, nous obtenons <code>add.ll</code> avec une repr√©sentation interne de LLVM IR.  <b>Je ne le montre que par souci d'exhaustivit√©</b> .  Lorsque vous travaillez avec WebAssembly ou m√™me clang, en tant que d√©veloppeur C, vous <i>n'entrerez</i> jamais en contact avec LLVM IR. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR regorge de m√©tadonn√©es et d'annotations suppl√©mentaires, ce qui permet au compilateur de prendre des d√©cisions plus √©clair√©es lors de la g√©n√©ration du code machine.</i> <br><br><h3>  Transformez LLVM IR en fichiers objets </h3><br>  L'√©tape suivante consiste √† appeler le compilateur d'arri√®re-plan <code>llc</code> pour cr√©er un fichier objet √† partir de la repr√©sentation interne. <br><br>  Le fichier de sortie <code>add.o</code> est d√©j√† un module WebAssembly valide qui contient tout le code compil√© de notre fichier C. Mais g√©n√©ralement, vous ne pourrez pas ex√©cuter les fichiers objets car ils manquent de parties essentielles. <br><br>  Si nous <code>-filetype=obj</code> dans la commande, nous obtiendrions l'assembleur LLVM pour WebAssembly, un format lisible par l'homme qui est quelque peu similaire √† WAT.  Cependant, l'outil <code>llvm-mc</code> pour travailler avec de tels fichiers ne prend pas encore totalement en charge le format et ne peut souvent pas traiter les fichiers.  Par cons√©quent, nous d√©montons les fichiers objets apr√®s coup.  Un outil sp√©cifique est n√©cessaire pour v√©rifier ces fichiers objets.  Dans le cas de WebAssembly, il s'agit de <code>wasm-objdump</code> , qui fait partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebAssembly Binary Toolkit</a> ou wabt pour faire court. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  La sortie montre que notre fonction add () est dans ce module, mais elle contient √©galement <i>des</i> sections <i>personnalis√©es</i> avec des m√©tadonn√©es et, √©tonnamment, plusieurs importations.  √Ä l'√©tape suivante de la <i>liaison,</i> les sections personnalis√©es seront analys√©es et supprim√©es, et l'√©diteur de liens (√©diteur de liens) s'occupera de l'importation. <br><br><h3>  Disposition </h3><br>  Traditionnellement, la t√¢che de l'√©diteur de liens est d'assembler plusieurs fichiers objets dans un fichier ex√©cutable.  L'√©diteur de liens LLVM est appel√© <code>lld</code> et il est appel√© avec le lien symbolique cible.  Pour WebAssembly, ce <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  Le r√©sultat est un module WebAssembly de 262 octets. <br><br><h3>  Lancement </h3><br>  Bien s√ªr, le plus important est de voir que tout fonctionne <i>vraiment</i> .  Comme dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> , vous pouvez utiliser quelques lignes de JavaScript int√©gr√© pour charger et ex√©cuter ce module WebAssembly. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Si tout va bien, vous verrez le num√©ro 17 dans la console DevTool <b>Nous venons de compiler avec succ√®s C dans WebAssembly sans toucher Emscripten.</b>  Il convient √©galement de noter qu'il n'existe aucun middleware pour configurer et charger le module WebAssembly. <br><br><h1>  Compiler C est un peu plus simple </h1><br>  Pour compiler C dans WebAssembly, nous avons pris de nombreuses mesures.  Comme je l'ai dit, √† des fins p√©dagogiques, nous avons examin√© en d√©tail toutes les √©tapes.  Ignorons les formats interm√©diaires lisibles par l'homme et appliquons imm√©diatement le compilateur C comme un couteau suisse, tel qu'il a √©t√© d√©velopp√©: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Ici, nous obtenons le m√™me fichier <code>.wasm</code> , mais avec une seule commande. <br><br><h1>  Optimisation </h1><br>  Jetez un ≈ìil au WAT de notre module WebAssembly en ex√©cutant <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, quel bon code.  √Ä ma grande surprise, le module utilise de la m√©moire (comme le <code>i32.store</code> <code>i32.load</code> et <code>i32.store</code> ), huit variables locales et plusieurs variables globales.  Vous pouvez probablement √©crire manuellement une version plus concise.  Ce programme est si grand parce que nous n'avons appliqu√© aucune optimisation.  Faisons-le: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Remarque:</b> techniquement, l'optimisation de la mise en page (LTO) n'offre aucun avantage car nous ne composons qu'un seul fichier.  Dans les grands projets, LTO contribuera √† r√©duire consid√©rablement la taille du fichier. </blockquote>  Apr√®s avoir ex√©cut√© ces commandes, le fichier <code>.wasm</code> pass√© de 262 √† 197 octets, et WAT est √©galement devenu beaucoup plus simple: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Appelez la biblioth√®que standard </h1><br>  L'utilisation de C sans la biblioth√®que libc standard semble plut√¥t grossi√®re.  Il est logique de l'ajouter, mais je vais √™tre honn√™te: ce <i>ne</i> sera <i>pas</i> facile.  <b>En fait, nous n'appelons directement aucune biblioth√®que libc dans l'article</b> .  Il en existe plusieurs, en particulier la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glibc</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">musl</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dietlibc</a> .  Cependant, la plupart de ces biblioth√®ques sont suppos√©es s'ex√©cuter dans le syst√®me d'exploitation POSIX, qui impl√©mente un certain ensemble d'appels syst√®me.  Comme nous n'avons pas d'interface noyau en JavaScript, nous devrons impl√©menter nous-m√™mes ces appels syst√®me POSIX, probablement via JavaScript.  C'est une t√¢che difficile et je ne vais pas le faire ici.  La bonne nouvelle est que c'est <b>ce que Emscripten fait pour vous</b> . <br><br>  Bien s√ªr, toutes les fonctions libc ne d√©pendent pas des appels syst√®me.  Des fonctions telles que <code>strlen()</code> , <code>sin()</code> ou m√™me <code>memset()</code> sont impl√©ment√©es en simple C. Cela signifie que vous pouvez utiliser ces fonctions ou m√™me simplement copier / coller leur impl√©mentation √† partir d'une biblioth√®que mentionn√©e. <br><br><h1>  M√©moire dynamique </h1><br>  Sans libc, les interfaces C fondamentales telles que <code>malloc()</code> et <code>free()</code> ne sont pas disponibles pour nous.  Dans le WAT non optimis√©, nous avons vu que le compilateur utilise de la m√©moire si n√©cessaire.  Cela signifie que nous ne pouvons pas simplement utiliser la m√©moire comme nous le voulons, sans risquer de l'endommager.  Vous devez comprendre comment il est utilis√©. <br><br><h3>  Mod√®les de m√©moire LLVM </h3><br>  La m√©thode de segmentation de la m√©moire WebAssembly surprendra un peu les programmeurs exp√©riment√©s.  Premi√®rement, dans WebAssembly, une adresse nulle est techniquement admissible, mais souvent elle est toujours trait√©e comme une erreur.  Deuxi√®mement, la pile vient en premier et cro√Æt (vers des adresses inf√©rieures), et le tas appara√Æt plus tard et grandit.  La raison en est que la m√©moire de WebAssembly peut augmenter lors de l'ex√©cution.  Cela signifie qu'il n'y a pas d'extr√©mit√© fixe pour accueillir la pile ou le tas. <br><br>  Voici la disposition <code>wasm-ld</code> : <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">La pile grandit et le tas grandit.</font></i>  <i><font color="gray">La pile commence par <code>__data_end</code> et le tas <code>__heap_base</code> par <code>__heap_base</code> .</font></i>  <i><font color="gray">√âtant donn√© que la pile est plac√©e en premier, elle est limit√©e par la taille maximale d√©finie lors de la compilation, c'est-√†-dire <code>__heap_base</code> moins <code>__data_end</code></font></i> <br><br>  Si nous revenons en arri√®re et regardons la section des globaux dans notre WAT, nous trouvons ces valeurs: <code>__heap_base</code> d√©fini sur 66560, et <code>__data_end</code> est d√©fini sur 1024. Cela signifie que la pile peut atteindre un maximum de 64 Ko, ce qui n'est pas beaucoup.  Heureusement, <code>wasm-ld</code> vous permet de modifier cette valeur: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Ensemble d'allocateur </h3><br>  La zone de <code>__heap_base</code> de <code>__heap_base</code> est connue pour commencer par <code>__heap_base</code> .  Comme la fonction <code>malloc()</code> est manquante, nous savons que la prochaine zone m√©moire peut √™tre utilis√©e en toute s√©curit√©.  Nous pouvons y placer les donn√©es comme nous le souhaitons, et il n'est pas n√©cessaire d'avoir peur de la corruption de la m√©moire, car la pile cro√Æt dans l'autre sens.  Cependant, un tas gratuit pour tout le monde peut rapidement se boucher, donc g√©n√©ralement une sorte de gestion dynamique de la m√©moire est n√©cessaire.  Une option consiste √† prendre une impl√©mentation √† part enti√®re de malloc (), telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'impl√©mentation malloc de Doug Lee</a> , qui est utilis√©e dans Emscripten.  Il existe plusieurs autres petites impl√©mentations avec divers compromis. <br><br>  Mais pourquoi ne pas √©crire votre propre <code>malloc()</code> ?  Nous sommes si profond√©ment enlis√©s que cela ne fait aucune diff√©rence.  L'un des plus simples est un allocateur de relief: il est ultra-rapide, extr√™mement petit et facile √† impl√©menter.  Mais il y a un inconv√©nient: vous ne pouvez pas lib√©rer de m√©moire.  Bien qu'√† premi√®re vue un tel allocateur semble incroyablement inutile, mais lors du d√©veloppement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Squoosh,</a> je suis tomb√© sur des pr√©c√©dents o√π ce serait un excellent choix.  Le concept d'allocateur de relief est que nous stockons l'adresse de d√©part de la m√©moire inutilis√©e comme globale.  Si le programme demande <code>n</code> octets de m√©moire, nous d√©pla√ßons le marqueur sur <code>n</code> et retournons la valeur pr√©c√©dente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Les variables globales de WAT sont en fait d√©finies par <code>wasm-ld</code> , de sorte que nous pouvons y acc√©der √† partir de notre code C en tant que variables ordinaires si nous les d√©clarons <code>extern</code> .  Donc, <b>nous venons d'√©crire notre propre <code>malloc()</code> ... en cinq lignes de C.</b> <br><br><blockquote>  <b>Remarque:</b> notre bump allocator n'est pas enti√®rement compatible avec <code>malloc()</code> de C. Par exemple, nous ne donnons aucune garantie d'alignement.  Mais cela fonctionne assez bien, alors ... </blockquote><h3>  Utilisation dynamique de la m√©moire </h3><br>  Pour tester, cr√©ons une fonction C, qui prend un tableau de nombres de taille arbitraire et calcule la somme.  Pas tr√®s int√©ressant, mais cela nous oblige √† utiliser la m√©moire dynamique, car nous ne connaissons pas la taille du tableau lors de l'assemblage: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Esp√©rons que la fonction sum () soit assez simple.  Une question plus int√©ressante est de savoir comment passer un tableau de JavaScript √† WebAssembly - apr√®s tout, WebAssembly ne comprend que les nombres.  L'id√©e g√©n√©rale est d'utiliser <code>malloc()</code> <i>partir de JavaScript</i> pour allouer un morceau de m√©moire, y copier les valeurs et passer l'adresse (nombre!) <i>O√π</i> se trouve <i>le</i> tableau: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Apr√®s le d√©marrage, vous devriez voir la r√©ponse 15 dans la console DevTools, qui est vraiment la somme de tous les nombres de 1 √† 5. <br><br><h1>  Conclusion </h1><br>  Alors, vous lisez jusqu'√† la fin.  F√©licitations!  Encore une fois, si vous vous sentez un peu surcharg√©, tout est en ordre.  <b>Il n'est pas n√©cessaire de lire tous les d√©tails.</b>  <b>Les comprendre est compl√®tement facultatif pour un bon d√©veloppeur Web et n'est m√™me pas n√©cessaire pour l'excellente utilisation de WebAssembly</b> .  Mais je voulais partager cette information, car elle vous permet d'appr√©cier vraiment tout le travail qu'un projet comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> fait pour vous.  Dans le m√™me temps, cela permet de comprendre √† quel point les modules purement informatiques de WebAssembly peuvent √™tre petits.  Le module Wasm pour additionner le tableau ne fait que 230 octets, <i>y compris un allocateur de m√©moire dynamique</i> .  La compilation du m√™me code avec Emscripten produira 100 octets de code WebAssembly et 11K de code de liaison JavaScript.  Vous devez essayer pour un tel r√©sultat, mais il y a des situations o√π cela en vaut la peine. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454868/">https://habr.com/ru/post/fr454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454844/index.html">Odigest: int√©ressant pour les cr√©ateurs de la semaine</a></li>
<li><a href="../fr454850/index.html">L'√©volution d'un algorithme unique</a></li>
<li><a href="../fr454856/index.html">Nous analysons les vuln√©rabilit√©s de validation de certificat SSL / TLS dans un logiciel non navigateur</a></li>
<li><a href="../fr454860/index.html">Aidons QueryProvider √† g√©rer les cha√Ænes interpol√©es</a></li>
<li><a href="../fr454864/index.html">Comment sont les processus de d√©veloppement dans diff√©rentes entreprises</a></li>
<li><a href="../fr454872/index.html">Space Invaders: maintenant en 512 octets (assembleur x86)</a></li>
<li><a href="../fr454874/index.html">Un peu sur le multit√¢che dans les microcontr√¥leurs</a></li>
<li><a href="../fr454876/index.html">A propos de la conception d'un syst√®me flexible de capacit√©s de personnage dans les jeux</a></li>
<li><a href="../fr454878/index.html">Nous √©tudions MITRE ATT & CK. Matrices mobiles: acc√®s aux appareils. 3e partie</a></li>
<li><a href="../fr454880/index.html">¬´Hors saison¬ª dans la vie d'un pigiste: comment survivre et survivre?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>