<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥠 👩🏽‍🤝‍👩🏻 🔲 Aspects problématiques de la programmation en C ++ 🈷️ 🏵️ 🎥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, il existe de nombreuses fonctionnalités qui peuvent être considérées comme potentiellement dangereuses - avec des erreurs de calcul dans la c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aspects problématiques de la programmation en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>En C ++, il existe de nombreuses fonctionnalités qui peuvent être considérées comme potentiellement dangereuses - avec des erreurs de calcul dans la conception ou un codage inexact, elles peuvent facilement conduire à des erreurs.</i>  <i>L'article fournit une sélection de ces fonctionnalités, donne des conseils sur la façon de réduire leur impact négatif.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Table des matières </h1><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Types</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instructions et opérateurs conditionnels</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conversions implicites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Résolution du nom</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Masquage de variables dans des étendues imbriquées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surcharge de fonction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Constructeurs, destructeurs, initialisation, suppression</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions membres de classe générées par le compilateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Variables non initialisées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Procédure d'initialisation pour les classes de base et les membres de classe non statiques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Procédure d'initialisation pour les membres de classe statique et les variables globales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exceptions dans les destructeurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression d'objets et de tableaux dynamiques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression lorsque la déclaration de classe est incomplète</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Opérateurs, expressions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Priorité de l'opérateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surcharge de l'opérateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La procédure de calcul des sous-expressions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Fonctions virtuelles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.1 Remplacement des fonctions virtuelles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.2 Surcharge et utilisation des paramètres par défaut</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.3 Appel de fonctions virtuelles dans le constructeur et le destructeur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.4 Destructeur virtuel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Travail direct avec mémoire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.1 Débordement du tampon</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2 Chaînes terminées par Z</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.3 Fonctions à nombre de paramètres variable</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Syntaxe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7.1 Annonces compliquées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7.2 Ambiguïté de syntaxe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Divers</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.1 Mot-clé en ligne et ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.2 Fichiers d'en-tête</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.3 instruction switch</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.4 Passage des paramètres par valeur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.5 Gestion des ressources</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.6 Liens propriétaires et non propriétaires</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.7 Compatibilité binaire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.8 Macros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Résumé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les références</a> <br></p><br></div></div><br><p>  <i>Praemonitus, praemunitus.</i> <i><br></i>  <i>Averti signifie armé.</i>  <i>(lat.)</i> <br></p><br><a name="id-introdaction"></a><br><h1>  Présentation </h1><br><p>  En C ++, il existe de nombreuses fonctionnalités qui peuvent être considérées comme potentiellement dangereuses - avec des erreurs de calcul dans la conception ou un codage inexact, elles peuvent facilement conduire à des erreurs.  Certains d'entre eux peuvent être attribués à une enfance difficile, certains à la norme C ++ 98 obsolète, mais d'autres sont déjà associés aux fonctionnalités du C ++ moderne.  Considérez les principaux et essayez de donner des conseils sur la façon de réduire leur impact négatif. </p><br><a name="id-1"></a><br><h1>  1. Types </h1><br><a name="id-1-1"></a><br><h2>  1.1.  Instructions et opérateurs conditionnels </h2><br><p> Le besoin de compatibilité avec C conduit au fait que dans l'instruction <code>if(...)</code> et similaires, vous pouvez remplacer n'importe quelle expression numérique ou pointeur, et pas seulement des expressions comme <code>bool</code> .  Le problème est aggravé par la conversion implicite de <code>bool</code> en <code>int</code> dans les expressions arithmétiques et la priorité de certains opérateurs.  Cela conduit, par exemple, aux erreurs suivantes: </p><br><p>  <code>if(a=b)</code> quand correctement <code>if(a==b)</code> , <br>  <code>if(a&lt;x&lt;b)</code> , quand correctement <code>if(a&lt;x &amp;&amp; x&lt;b)</code> , <br>  <code>if(a&amp;x==0)</code> , quand correctement <code>if((a&amp;x)==0)</code> , <br>  <code>if(Foo)</code> quand correctement <code>if(Foo())</code> , <br>  <code>if(arr)</code> quand correctement <code>if(arr[0])</code> , <br>  <code>if(strcmp(s,r))</code> lorsqu'il est correct <code>if(strcmp(s,r)==0)</code> . </p><br><p>  Certaines de ces erreurs provoquent un avertissement du compilateur, mais pas une erreur.  Les analyseurs de code peuvent également parfois aider.  En C #, de telles erreurs sont presque impossibles, l' <code>if(...)</code> et similaires nécessitent un type <code>bool</code> , vous ne pouvez pas mélanger des types <code>bool</code> et numériques dans des expressions arithmétiques. </p><br><p>  Comment se battre: </p><br><ul><li>  Programme sans avertissements.  Malheureusement, cela n'aide pas toujours; certaines des erreurs décrites ci-dessus ne donnent pas d'avertissement. </li><li>  Utilisez des analyseurs de code statique. </li><li>  Technique de réception à l'ancienne: lors de la comparaison avec une constante, placez-la à gauche, par exemple <code>if(MAX_PATH==x)</code> .  Il a l'air assez copropriété (et a même son propre nom - "notation Yoda"), et aide dans un petit nombre de cas. </li><li>  Utilisez le qualificatif <code>const</code> aussi largement que possible.  Encore une fois, cela n'aide pas toujours. </li><li>  Prenez l'habitude d'écrire les expressions logiques correctes: <code>if(x!=0)</code> au lieu de <code>if(x)</code> .  (Bien que vous puissiez tomber dans le piège des priorités des opérateurs ici, consultez le troisième exemple.) </li><li>  Soyez extrêmement attentif. </li></ul><br><a name="id-1-2"></a><br><h2>  1.2.  Conversions implicites </h2><br><p>  C ++ fait référence à des langages fortement typés, mais les conversions de types implicites sont largement utilisées pour raccourcir le code.  Ces conversions implicites peuvent dans certains cas conduire à des erreurs. </p><br><p>  Les conversions implicites les plus ennuyeuses sont les conversions d'un type numérique ou d'un pointeur vers <code>bool</code> et de <code>bool</code> vers <code>int</code> .  Ce sont ces transformations (nécessaires à la compatibilité avec C) qui provoquent les problèmes décrits dans la section 1.1.  Les conversions implicites qui peuvent potentiellement entraîner une perte de précision des données numériques (rétrécissement des conversions), par exemple du <code>double</code> au <code>int</code> sont pas toujours appropriées non plus.  Dans de nombreux cas, le compilateur génère un avertissement (surtout lorsqu'il peut y avoir une perte de précision des données numériques), mais un avertissement n'est pas une erreur.  En C #, les conversions entre types numériques et <code>bool</code> interdites (même explicites), et les conversions qui peuvent potentiellement entraîner une perte de précision dans les données numériques sont presque toujours une erreur. </p><br><p>  Le programmeur peut ajouter d'autres conversions implicites: (1) définir un constructeur avec un paramètre sans le mot-clé <code>explicit</code> ;  (2) la définition d'un opérateur de conversion de type.  Ces transformations comblent des lacunes de sécurité supplémentaires basées sur des principes de typage solides. </p><br><p>  En C #, le nombre de conversions implicites intégrées est beaucoup plus petit; les conversions implicites personnalisées doivent être déclarées à l'aide du mot clé <code>implicit</code> . </p><br><p>  Comment se battre: </p><br><ul><li>  Programme sans avertissements. </li><li>  Faites très attention aux modèles décrits ci-dessus, ne les utilisez pas sans besoin extrême. </li></ul><br><a name="id-2"></a><br><h1>  2. Résolution du nom </h1><br><a name="id-2-1"></a><br><h2>  2.1.  Masquage de variables dans des étendues imbriquées </h2><br><p>  En C ++, la règle suivante s'applique.  Soit </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p>  Selon les règles C ++, la variable <code></code> déclarée en <code></code> cache la variable <code></code> déclarée en <code></code>  La première déclaration <code>x</code> ne doit pas nécessairement être dans un bloc: elle peut être membre d'une classe ou d'une variable globale, elle doit juste être visible dans le bloc <code></code> </p><br><p>  Imaginez maintenant la situation où vous devez refactoriser le code suivant </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p>  Par erreur, des modifications sont apportées: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p>  Et maintenant, le code «quelque chose se fait avec <code></code> de <code></code> » fera quelque chose avec <code></code> de <code></code> !  Il est clair que tout ne fonctionne pas comme avant, et de trouver ce qui est souvent très difficile.  Ce n'est pas en vain qu'en C # il est interdit de cacher les variables locales (bien que les membres de la classe le puissent).  Notez que le mécanisme de masquage des variables sous une forme ou une autre est utilisé dans presque tous les langages de programmation. </p><br><p>  Comment se battre: </p><br><ul><li>  Déclarez les variables dans la portée la plus étroite possible. </li><li>  N'écrivez pas de blocs longs et profondément imbriqués. </li><li>  Utilisez des conventions de codage pour distinguer visuellement les identifiants de portée différente. </li><li>  Soyez extrêmement attentif. </li></ul><br><a name="id-2-2"></a><br><h2>  2.2.  Surcharge de fonction </h2><br><p>  La surcharge de fonctions fait partie intégrante de nombreux langages de programmation et C ++ ne fait pas exception.  Mais cette opportunité doit être utilisée avec précaution, sinon vous pouvez avoir des ennuis.  Dans certains cas, par exemple, lorsque le constructeur est surchargé, le programmeur n'a pas le choix, mais dans d'autres cas, le refus de surcharger peut être justifié.  Tenez compte des problèmes qui surviennent lors de l'utilisation de fonctions surchargées. </p><br><p>  Si vous essayez de considérer toutes les options possibles pouvant survenir lors de la résolution d'une surcharge, les règles de résolution d'une surcharge s'avèrent être très compliquées, et donc difficiles à prévoir.  La complexité supplémentaire est introduite par les fonctions de modèle et la surcharge des opérateurs intégrés.  C ++ 11 a ajouté des problèmes avec les liens rvalue et les listes d'initialisation. </p><br><p>  Des problèmes peuvent être créés par l'algorithme de recherche pour que les candidats résolvent la surcharge dans les zones de visibilité imbriquées.  Si le compilateur a trouvé des candidats dans la portée actuelle, la recherche se termine.  Si les candidats trouvés ne sont pas appropriés, conflictuels, supprimés ou inaccessibles, une erreur est générée, mais aucune autre recherche n'est tentée.  Et seulement s'il n'y a aucun candidat dans la portée actuelle, la recherche passe à la portée suivante, plus large.  Le mécanisme de masquage du nom fonctionne, qui est presque le même que celui discuté dans la section 2.1, voir [Dewhurst]. </p><br><p>  Les fonctions de surcharge peuvent réduire la lisibilité du code, ce qui signifie provoquer des erreurs. </p><br><p>  L'utilisation de fonctions avec des paramètres par défaut ressemble à l'utilisation de fonctions surchargées, bien que, bien sûr, il y ait moins de problèmes potentiels.  Mais le problème de la mauvaise lisibilité et des erreurs possibles subsiste. </p><br><p>  Avec une extrême prudence, les paramètres de surcharge et par défaut pour les fonctions virtuelles doivent être utilisés, voir la section 5.2. </p><br><p>  C # prend également en charge la surcharge de fonctions, mais les règles de résolution des surcharges sont légèrement différentes. </p><br><p>  Comment se battre: </p><br><ul><li>  N'abusez pas de la surcharge de fonctions, ainsi que de la conception de fonctions avec des paramètres par défaut. </li><li>  Si les fonctions sont surchargées, utilisez des signatures qui ne font aucun doute lors de la résolution des surcharges. </li><li>  Ne déclarez pas les fonctions du même nom dans la portée imbriquée. </li><li>  N'oubliez pas que le mécanisme des fonctions distantes ( <code>=delete</code> ) apparu en C ++ 11 peut être utilisé pour interdire certaines options de surcharge. </li></ul><br><a name="id-3"></a><br><h1>  3. Constructeurs, destructeurs, initialisation, suppression </h1><br><a name="id-3-1"></a><br><h2>  3.1.  Fonctions membres de classe générées par le compilateur </h2><br><p>  Si le programmeur n'a pas défini les fonctions membres de la classe dans la liste suivante - le constructeur par défaut, le constructeur de copie, l'opérateur d'affectation de copie, le destructeur - le compilateur peut le faire pour lui.  C ++ 11 a ajouté un constructeur de déplacement et un opérateur d'affectation de déplacement à cette liste.  Ces fonctions membres sont appelées fonctions membres spéciales.  Ils ne sont générés que s'ils sont utilisés et des conditions supplémentaires spécifiques à chaque fonction sont remplies.  Nous attirons l'attention sur le fait que cette utilisation peut s'avérer assez cachée (par exemple lors de l'implémentation de l'héritage).  Si la fonction requise ne peut pas être générée, une erreur est générée.  (À l'exception des opérations de relocalisation, elles sont remplacées par des opérations de copie.) Les fonctions membres générées par le compilateur sont publiques et intégrables.  Des détails sur les fonctions spéciales des membres peuvent être trouvés dans [Meyers2]. </p><br><p>  Dans certains cas, une telle aide du compilateur peut être un «service baissier».  L'absence de fonctions membres spéciales personnalisées peut conduire à la création d'un type trivial, ce qui, à son tour, provoque le problème des variables non initialisées, voir la section 3.2.  Les fonctions membres générées sont publiques, ce qui n'est pas toujours cohérent avec la conception des classes.  Dans les classes de base, le constructeur doit être protégé; parfois, pour un contrôle plus fin du cycle de vie de l'objet, un destructeur protégé est nécessaire.  Si une classe a un descripteur de ressource brute en tant que membre et possède cette ressource, le programmeur doit alors implémenter le constructeur de copie, l'opérateur d'affectation de copie et le destructeur.  La soi-disant «règle des trois grands» est bien connue, qui stipule que si un programmeur définit au moins une des trois opérations - constructeur de copie, opérateur d'affectation de copie ou destructeur - alors il doit définir les trois opérations.  Le constructeur de déplacement et l'opérateur d'affectation de déplacement généré par le compilateur sont également loin de toujours ce dont vous avez besoin.  Le destructeur généré par le compilateur conduit dans certains cas à des problèmes très subtils, pouvant entraîner une fuite de ressources, voir section 3.7. </p><br><p>  Le programmeur peut interdire la génération de fonctions membres spéciales, en C ++ 11 il est nécessaire d'utiliser la construction <code>"=delete"</code> lors de la déclaration, en C ++ 98 déclarer la fonction membre correspondante privée et non définir. </p><br><p>  Si le programmeur est à l'aise avec les fonctions membres générées par le compilateur, alors en C ++ 11, il peut l'indiquer explicitement, et pas simplement supprimer la déclaration.  Pour ce faire, vous devez utiliser la construction <code>"=default"</code> lors de la déclaration, tandis que le code est mieux lu et que des fonctionnalités supplémentaires apparaissent liées à la gestion du niveau d'accès. </p><br><p>  En C #, le compilateur peut générer un constructeur par défaut, cela ne pose généralement aucun problème. </p><br><p>  Comment se battre: </p><br><ul><li>  Contrôlez le compilateur générant des fonctions membres spéciales.  Si nécessaire, mettez-les en œuvre vous-même ou interdisez-les. </li></ul><br><a name="id-3-2"></a><br><h2>  3.2.  Variables non initialisées </h2><br><p>  Les constructeurs et les destructeurs peuvent être appelés éléments clés du modèle d'objet C ++.  Lors de la création d'un objet, le constructeur doit être appelé et lors de la suppression, le destructeur est appelé.  Mais les problèmes de compatibilité avec C ont forcé certaines exceptions, et cette exception est appelée types triviaux.  Ils sont introduits pour simuler les types sichny et le cycle de vie syshny des variables, sans l'appel obligatoire du constructeur et du destructeur.  Le code C, s'il est compilé et exécuté en C ++, devrait fonctionner comme en C. Les types triviaux incluent les types numériques, les pointeurs, les énumérations, ainsi que les classes, les structures, les unions et les tableaux constitués de types triviaux.  Les classes et les structures doivent remplir des conditions supplémentaires: absence de constructeur personnalisé, destructeur, copie, fonctions virtuelles.  Pour une classe triviale, le compilateur peut générer un constructeur par défaut et un destructeur.  Le constructeur par défaut met à zéro l'objet, le destructeur ne fait rien.  Mais ce constructeur ne sera généré et utilisé que s'il est explicitement appelé lors de l'initialisation de la variable.  Une variable de type trivial ne sera pas initialisée si vous n'utilisez pas une variante d'initialisation explicite.  La syntaxe d'initialisation dépend du type et du contexte de la déclaration de variable.  Les variables statiques et locales sont initialisées lorsqu'elles sont déclarées.  Pour une classe, les classes de base immédiates et les membres de classe non statiques sont initialisés dans la liste d'initialisation du constructeur.  (C ++ 11 vous permet d'initialiser des membres de classe non statiques lors de la déclaration, voir plus loin.) Pour les objets dynamiques, l'expression <code>new T()</code> crée un objet initialisé par le constructeur par défaut, mais le <code>new T</code> pour les types triviaux crée un objet non initialisé.  Lors de la création d'un tableau dynamique d'un type trivial, <code>new T[N]</code> , ses éléments seront toujours non initialisés.  Si une instance de <code>std::vector&lt;T&gt;</code> est créée ou étendue et que les paramètres ne sont pas fournis pour l'initialisation explicite des éléments, ils sont garantis pour appeler le constructeur par défaut.  C ++ 11 introduit une nouvelle syntaxe d'initialisation - utilisant des accolades.  Une paire de crochets vide signifie l'initialisation à l'aide du constructeur par défaut.  Une telle initialisation est possible partout où l'initialisation traditionnelle est utilisée, en plus il est devenu possible d'initialiser des membres non statiques de la classe lors de la déclaration, ce qui remplace l'initialisation dans la liste d'initialisation du constructeur. </p><br><p>  Une variable non initialisée est structurée comme suit: si elle est définie dans la portée de l' <code>namespace</code> (globalement), elle aura tous les bits zéro, si elle est locale ou créée dynamiquement, elle recevra un ensemble aléatoire de bits.  Il est clair que l'utilisation d'une telle variable peut conduire à un comportement imprévisible du programme. </p><br><p>  Certes, la progression ne s'arrête pas, les compilateurs modernes, dans certains cas, détectent les variables non initialisées et génèrent une erreur.  Les analyseurs de code non initialisés détectent encore mieux. </p><br><p>  La bibliothèque standard C ++ 11 possède des modèles appelés propriétés de type (fichier d'en-tête <code>&lt;type_traits&gt;</code> ).  L'un d'eux vous permet de déterminer si le type est trivial.  L'expression <code>std::is_trivial&lt;&gt;::value</code> est <code>true</code> si <code>T</code> type trivial et <code>false</code> sinon. </p><br><p>  Les structures sysyliques sont aussi souvent appelées Plain Old Data (POD).  Nous pouvons supposer que POD et le «type trivial» sont des termes presque équivalents. </p><br><p>  En C #, les variables non initialisées provoquent une erreur qui est contrôlée par le compilateur.  Les champs d'objets d'un type de référence sont initialisés par défaut si l'initialisation explicite n'est pas effectuée.  Les champs d'objets d'un type significatif sont initialisés soit tous par défaut, soit tous doivent être initialisés explicitement. </p><br><p>  Comment se battre: </p><br><ul><li>  Prenez l'habitude d'initialiser explicitement une variable.  Une variable non initialisée devrait "couper l'œil". </li><li>  Déclarez les variables dans la portée la plus étroite possible. </li><li>  Utilisez des analyseurs de code statique. </li><li>  Ne concevez pas de types triviaux.  Pour s'assurer que le type n'est pas trivial, il suffit de définir un constructeur personnalisé. </li></ul><br><a name="id-3-3"></a><br><h2>  3.3.  Procédure d'initialisation pour les classes de base et les membres de classe non statiques </h2><br><p>  Lors de l'implémentation du constructeur de classe, les classes de base immédiates et les membres de classe non statiques sont initialisés.  L'ordre d'initialisation est déterminé par la norme: d'abord, les classes de base dans l'ordre dans lequel elles sont déclarées dans la liste des classes de base, puis les membres non statiques de la classe dans l'ordre de déclaration.  Si nécessaire, l'initialisation explicite des classes de base et des membres non statiques utilise la liste d'initialisation du constructeur.  Malheureusement, les éléments de cette liste ne doivent pas nécessairement être dans l'ordre dans lequel l'initialisation a lieu.  Ceci doit être pris en compte si, lors de l'initialisation, les éléments de liste utilisent des références à d'autres éléments de liste.  En cas d'erreur, le lien peut être vers un objet qui n'a pas encore été initialisé.  C ++ 11 vous permet d'initialiser des membres de classe non statiques lors de la déclaration (en utilisant des accolades).  Dans ce cas, ils n'ont pas besoin d'être initialisés dans la liste d'initialisation du constructeur et le problème est partiellement supprimé. </p><br><p>  En C #, un objet est initialisé comme suit: d'abord les champs sont initialisés, du sous-objet de base à la dernière dérivée, puis les constructeurs sont appelés dans le même ordre.  Le problème décrit ne se produit pas. </p><br><p>  Comment se battre: </p><br><ul><li>  Conservez la liste d'initialisation du constructeur dans l'ordre de déclaration. </li><li>  Essayez de rendre l'initialisation des classes de base et des membres de classe indépendants. </li><li>  Utilisez l'initialisation des membres non statiques lors de la déclaration. </li></ul><br><a name="id-3-4"></a><br><h2>  3.4.  Procédure d'initialisation pour les membres de classe statique et les variables globales </h2><br><p>  Les membres de classe statiques, ainsi que les variables définies dans l' <code>namespace</code> portée (globalement) dans différentes unités de compilation (fichiers), sont initialisés dans l'ordre déterminé par l'implémentation.  Ceci doit être pris en compte si, lors de l'initialisation, ces variables utilisent des références les unes aux autres.  Le lien peut être vers une variable non initialisée. </p><br><p>  Comment se battre: </p><br><ul><li>  Prenez des mesures spéciales pour éviter cette situation.  Par exemple, utilisez des variables statiques locales (singleton), elles sont initialisées à la première utilisation. </li></ul><br><a name="id-3-5"></a><br><h2>  3.5.  Exceptions dans les destructeurs </h2><br><p>  Le destructeur ne doit pas lever d'exceptions.  Si vous enfreignez cette règle, vous pouvez obtenir un comportement indéfini, le plus souvent une résiliation anormale. </p><br><p>  Comment se battre: </p><br><ul><li>  Évitez de lancer des exceptions dans le destructeur. </li></ul><br><a name="id-3-6"></a><br><h2>  3.6.  Suppression d'objets et de tableaux dynamiques </h2><br><p>  Si un objet dynamique d'un type <code>T</code> </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p>  puis il est supprimé avec l'opérateur de <code>delete</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p>  Si un tableau dynamique est créé </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p>  puis il est supprimé avec l'opérateur <code>delete[]</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p>  Si vous ne respectez pas cette règle, vous pouvez obtenir un comportement indéfini, c'est-à-dire que tout peut arriver: une fuite de mémoire, un crash, etc.  Voir [Meyers1] pour plus de détails. </p><br><p>  Comment se battre: </p><br><ul><li>  Utilisez le bon formulaire de <code>delete</code> . </li></ul><br><a name="id-3-7"></a><br><h2>  3.7.  Suppression lorsque la déclaration de classe est incomplète </h2><br><p>  Le caractère omnivore de l'opérateur de <code>delete</code> peut créer certains problèmes; il peut être appliqué à un pointeur de type <code>void*</code> ou à un pointeur sur une classe qui a une déclaration incomplète (préemptive).  L'opérateur de <code>delete</code> appliqué à un pointeur sur une classe est une opération en deux phases; d'abord, le destructeur est appelé, puis la mémoire est libérée.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'opérateur est appliqué </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à un pointeur sur une classe avec une déclaration incomplète, aucune erreur ne se produit, le compilateur ignore simplement l'appel au destructeur (bien qu'un avertissement soit émis).</font></font> Prenons un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code compile même si la </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclaration de classe complète n'est pas disponible </font><font style="vertical-align: inherit;">au cadran-pair </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Visual Studio affiche l'avertissement suivant:</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il existe une implémentation </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et que </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code est compilé, s'il </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un pointeur vers un objet créé par l'opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors l'appel est </font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exécuté avec succès, le destructeur n'est pas appelé. </font><font style="vertical-align: inherit;">Il est clair que cela peut conduire à un épuisement des ressources, donc encore une fois sur la nécessité de traiter soigneusement les avertissements.</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p>  Voici un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    —    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  .   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  . </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1.    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2.       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3.        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      —         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       —  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4.   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        —      C/C++,        .           .        .     «  ». </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2>  6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       —       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2>  6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2>  7.1.   </h2><br><p>  ++     , ,   ,        .  Voici un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2>  7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2>  8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> —             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  «» <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        —  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2>  8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2>  8.3.  <code>switch</code> <br></h2><br><p>   —  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      —     , —       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    —   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    —     ( <code>=delete</code> ),   —     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2>  8.5.  Gestion des ressources </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     «»     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        «»,      .          COM-      . (,    .)      ,    C++   .      —      .        .            .  ,      («»     )    ,      .        . </p><br><p>  #    ,     .     —    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   —    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    .  Au lieu de cela </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      — ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1>  Les références </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  de l'anglais — .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  de l'anglais — .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  de l'anglais — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  de l'anglais — :  «.. », 2015. </p><br><p> [Spolsky] <br> , .   .: .  de l'anglais — .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428898/">https://habr.com/ru/post/fr428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428888/index.html">qml: puissance et simplicité</a></li>
<li><a href="../fr428890/index.html">Toute la vérité sur RTOS. Article # 18. Groupes d'indicateurs d'événements: services d'assistance et structures de données</a></li>
<li><a href="../fr428892/index.html">Comment créer un jeu AI: un guide pour les débutants</a></li>
<li><a href="../fr428894/index.html">TVA sur les achats nationaux</a></li>
<li><a href="../fr428896/index.html">Réseaux de neurones de censure Hentai</a></li>
<li><a href="../fr428900/index.html">Des robots à roues commencent à livrer des marchandises aux résidents des États-Unis et de la Grande-Bretagne</a></li>
<li><a href="../fr428902/index.html">Balises sans fil NFC</a></li>
<li><a href="../fr428904/index.html">Fintech Digest: Central Bank Robotics, Ethereum 2.0, Cryptocurrency Control by Rosfinmonitoring and Trends in Fintech</a></li>
<li><a href="../fr428906/index.html">Création de jeux de puzzle sur Puzzle Script</a></li>
<li><a href="../fr428908/index.html">Frostpunk: démontage de la mécanique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>