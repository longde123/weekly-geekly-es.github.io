<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ“ ğŸ± ğŸ¤±ğŸ¼ Angka Acak dan Jaringan Terdesentralisasi: Implementasi ğŸ™ï¸ ğŸ’ ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


function getAbsolutelyRandomNumer() { return 4; // returns absolutely random number! }  


 Seperti dalam kasus konsep sandi kriptograf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angka Acak dan Jaringan Terdesentralisasi: Implementasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452340/"><h1 id="vvedenie">  Pendahuluan </h1><br><pre><code class="plaintext hljs">function getAbsolutelyRandomNumer() { return 4; // returns absolutely random number! }</code> </pre> <br><p>  Seperti dalam kasus konsep sandi kriptografi yang benar-benar aman, protokol Random Beacon acak yang dapat diverifikasi secara publik (selanjutnya disebut PVRB) hanya berusaha sedekat mungkin dengan skema ideal.  dalam jaringan nyata dalam bentuknya yang murni, itu tidak berlaku: perlu untuk menyetujui sepenuhnya pada satu bit, harus ada banyak putaran, dan semua pesan harus sangat cepat dan selalu disampaikan.  Tentu saja, dalam jaringan nyata ini tidak demikian.  Oleh karena itu, ketika mendesain PVRB untuk tugas-tugas spesifik dalam blockchain modern, selain ketidakmampuan untuk mengontrol keacakan dan kekuatan kriptografi yang dihasilkan, banyak masalah arsitektur dan teknis murni muncul. </p><a name="habracut"></a><br><p>  Blockchain itu sendiri untuk PVRB pada dasarnya merupakan media komunikasi di mana pesan = transaksi.  Ini memungkinkan Anda untuk mengabaikan sebagian masalah jaringan, pengiriman pesan, masalah middleware - semua risiko ini ditanggung oleh jaringan yang didesentralisasi, dan nilai utamanya untuk PVRB adalah ketidakmampuan untuk menarik atau merusak transaksi yang sudah dikirim - ini tidak memungkinkan peserta untuk menolak berpartisipasi dalam protokol, kecuali mereka memiliki serangan konsensus yang berhasil.  Tingkat keamanan ini dapat diterima, jadi PVRB harus tahan terhadap kolusi di antara para peserta dengan cara yang persis sama dengan rantai blockchain utama.  Juga, ini mengisyaratkan bahwa PVRB harus menjadi bagian dari konsensus, jika jaringan menyetujui rantai blok utama, biarkan ia setuju pada saat yang sama pada satu-satunya hasil acak yang jujur.  Atau, PVRB hanyalah protokol mandiri yang diimplementasikan oleh kontrak pintar yang bekerja secara serempak sehubungan dengan blockchain dan blok.  Kedua metode memiliki kelebihan dan kekurangan masing-masing, dan pilihan di antara keduanya sangat tidak penting. </p><br><h2 id="dva-sposoba-implementacii-pvrb">  Dua cara untuk mengimplementasikan PVRB </h2><br><p>  Mari kita jelaskan secara lebih rinci dua opsi untuk mengimplementasikan PVRB: versi mandiri, yang berfungsi menggunakan kontrak pintar yang independen dari blockchain, dan terintegrasi dengan konsensus, yang dibangun ke dalam protokol yang dengannya jaringan menyetujui rantai blok dan termasuk transaksi.  Dalam semua kasus, saya akan mengingat mesin blockchain yang populer: Ethereum, EOS, dan semuanya mirip dengan mereka dalam cara menempatkan dan memproses kontrak pintar. </p><br><h3 id="standalone-contract">  Kontrak mandiri </h3><br><p>  Dalam perwujudan ini, PVRB adalah kontrak pintar yang menerima transaksi produsen acak (selanjutnya RP), memprosesnya, menggabungkan hasilnya, dan, sebagai hasilnya, mencapai nilai yang dapat diperoleh setiap pengguna dari kontrak ini.  Nilai ini mungkin tidak disimpan secara langsung dalam kontrak, tetapi hanya diwakili oleh data dari mana satu dan hanya satu nilai dari keacakan yang dihasilkan dapat ditentukan secara deterministik.  Dalam skema ini, RP adalah pengguna blockchain, dan siapa saja dapat berpartisipasi dalam proses pembuatan. </p><br><p>  Opsi kontrak mandiri baik: </p><br><ul><li>  portabilitas (kontrak dapat diseret dari blockchain ke blockchain) </li><li>  kesederhanaan dalam implementasi dan pengujian (kontrak mudah untuk menulis dan menguji) </li><li>  kenyamanan dalam mengimplementasikan skema ekonomi (mudah untuk membuat token Anda sendiri, yang logikonya melayani tujuan PVRB) </li><li>  kemampuan untuk berjalan di blockchains yang ada </li></ul><br><p>  Ini juga memiliki kelemahan: </p><br><ul><li>  keterbatasan kuat pada sumber daya dalam perhitungan, volume transaksi dan penyimpanan (dengan kata lain, cpu / mem / io) </li><li>  pembatasan operasi dalam kontrak (tidak semua instruksi tersedia, sulit untuk menghubungkan perpustakaan eksternal) </li><li>  ketidakmampuan untuk mengatur pengiriman pesan lebih cepat daripada transaksi termasuk dalam blockchain </li></ul><br><p>  Opsi ini cocok untuk menerapkan PVRB, yang harus dijalankan pada jaringan yang ada yang tidak mengandung kriptografi kompleks dan tidak memerlukan sejumlah besar interaksi. </p><br><h3 id="consensus-integrated">  Terintegrasi-konsensus </h3><br><p>  Dalam perwujudan ini, PVRB diimplementasikan dalam kode node blockchain, built-in, atau bekerja secara paralel dengan pertukaran pesan antara node blockchain.  Hasil protokol ditulis langsung ke blok yang dihasilkan, dan pesan protokol dikirim melalui jaringan p2p antara node.  Karena protokol menghasilkan angka-angka yang ditulis dalam blok, jaringan harus mencapai konsensus tentangnya.  Ini berarti bahwa pesan PVRB, serta transaksi, harus divalidasi oleh node dan dimasukkan dalam blok sehingga setiap peserta jaringan dapat memverifikasi kepatuhan dengan protokol PVRB.  Ini secara otomatis membawa kita pada keputusan yang jelas - jika jaringan menegosiasikan konsensus tentang blok dan transaksi di dalamnya, maka PVRB harus menjadi bagian dari konsensus, bukan protokol yang berdiri sendiri.  Kalau tidak, suatu situasi dimungkinkan di mana blok tersebut valid dari sudut pandang konsensus, tetapi protokol PVRB tidak dihormati, dan dari sudut pandang PVRB blok tidak dapat diterima.  Jadi jika opsi "terintegrasi konsensus" dipilih, PVRB menjadi bagian penting dari konsensus. </p><br><p>  Menjelaskan implementasi PVRB pada tingkat konsensus pada jaringan, dalam hal apa pun Anda tidak dapat melewati masalah finalitas.  Finalitas adalah mekanisme yang digunakan dalam konsensus deterministik, blok pengunci (dan rantai yang mengarah ke sana) yang final dan tidak akan pernah dibuang meskipun garpu paralel muncul.  Misalnya, tidak ada mekanisme seperti itu dalam Bitcoin - jika Anda mempublikasikan rantai kompleksitas yang lebih besar, itu akan menggantikan mekanisme yang kurang kompleks, terlepas dari panjang rantai tersebut.  Dan dalam EOS, misalnya, yang terakhir adalah yang disebut Blok Terakhir yang Tidak Dapat Dibalik, yang muncul rata-rata setiap 432 blok (12 * 21 + 12 * 15, pra-pemilihan + pra-komit).  Proses ini pada dasarnya menunggu 2/3 dari tanda tangan produsen blok (selanjutnya disebut BP).  Ketika garpu yang lebih tua dari LIB terakhir muncul, mereka hanya dibuang.  Mekanisme ini memungkinkan Anda untuk menjamin bahwa transaksi termasuk dalam blockchain dan tidak akan pernah dipompa keluar, apa pun sumber daya yang dimiliki penyerang.  Juga, blok terakhir adalah blok yang ditandatangani oleh 2/3 BP dalam Hyperledger, Tendermint dan konsensus berbasis pBFT lainnya.  Juga, protokol untuk memastikan finalitas masuk akal untuk membuat add-on pada konsensus, karena dapat bekerja secara tidak serempak dengan produksi dan publikasi blok.  Inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> bagus tentang finalisasi Ethereum. </p><br><p>  Finalitas sangat penting bagi pengguna yang, tanpa itu, mungkin menjadi korban serangan "pembelanjaan ganda" ketika BP "menahan" blok dan menerbitkannya setelah jaringan "melihat" transaksi yang baik.  Jika tidak ada finalitas, maka garpu yang diterbitkan menggantikan blok dengan transaksi "baik" dengan yang lain, dari garpu "buruk", di mana dana yang sama ditransfer ke alamat penyerang.  Dalam kasus PVRB, persyaratan untuk finalitas masih diperketat, karena pembangunan garpu untuk PVRB berarti bahwa penyerang dapat menyiapkan beberapa opsi untuk rumah acak untuk menerbitkan yang paling menguntungkan baginya, dan membatasi waktu serangan yang mungkin adalah solusi yang baik. </p><br><p>  Oleh karena itu, pilihan terbaik adalah menggabungkan PVRB dan finalitas dalam satu protokol - maka blok yang difinalisasi = diselesaikan secara acak, dan inilah yang harus Anda dapatkan.  Sekarang pemain akan menerima keacakan dijamin dalam N detik, dan mereka dapat yakin bahwa tidak mungkin untuk memutar kembali atau memutar ulang itu. </p><br><p>  Opsi yang terintegrasi dengan konsensus baik: </p><br><ul><li>  kemungkinan implementasi asinkron sehubungan dengan produksi blok - blok diproduksi seperti biasa, tetapi secara paralel dengan ini, protokol PVRB dapat bekerja, yang tidak membuat setiap blok acak </li><li>  kemampuan untuk mengimplementasikan kriptografi yang berat, tanpa batasan yang dikenakan pada kontrak yang cerdas </li><li>  kemampuan untuk mengatur pengiriman pesan lebih cepat daripada transaksi yang termasuk dalam blockchain, misalnya, bagian dari protokol dapat bekerja di antara node tanpa menyebarkan pesan melalui jaringan </li></ul><br><p>  Ini juga memiliki kelemahan: </p><br><ul><li>  kesulitan dalam pengujian dan pengembangan - Anda harus meniru kesalahan jaringan, hilang node, garpu jaringan keras </li><li>  kesalahan implementasi memerlukan jaringan garpu keras </li></ul><br><p>  Kedua metode implementasi PVRB memiliki hak untuk hidup, tetapi implementasi kontrak pintar pada blockchain modern masih sangat terbatas dalam sumber daya komputasi, dan setiap transisi ke kriptografi serius seringkali tidak mungkin dilakukan.  Kita akan memerlukan kriptografi serius, seperti yang akan ditunjukkan nanti.  Meskipun masalah ini jelas bersifat sementara, kriptografi serius dalam kontrak diperlukan untuk menyelesaikan banyak masalah, dan secara bertahap muncul (misalnya, kontrak sistem untuk zkSNARKs di Ethereum) </p><br><p>  Blockchain, yang menyediakan saluran pesan protokol yang transparan dan andal, melakukan ini karena suatu alasan.  Setiap protokol yang didesentralisasi harus memperhitungkan kemungkinan serangan Sybil, tindakan apa pun dapat dilakukan oleh pasukan terkoordinasi dari banyak akun, oleh karena itu, ketika merancang, perlu memperhitungkan kemampuan penyerang untuk membuat jumlah peserta protokol yang sewenang-wenang bertindak dalam kolusi. </p><br><h2 id="pvrb-i-peremennye-bloka">  PVRB dan blok variabel. </h2><br><p>  Saya tidak berbohong ketika saya mengatakan bahwa sejauh ini tidak ada yang menerapkan PVRB yang baik, diverifikasi oleh banyak aplikasi perjudian, di blockchains.  Di mana, kemudian, dari begitu banyak aplikasi perjudian di Ethereum dan EOS?  Itu mengejutkan saya seperti halnya Anda, yah, dari mana Anda mendapatkan begitu banyak angka acak "persisten" dari dalam lingkungan yang sepenuhnya deterministik? </p><br><p>  Cara favorit untuk mendapatkan acak di blockchain adalah dengan mengambil beberapa jenis informasi yang "tidak dapat diprediksi" dari blok tersebut, dan berdasarkan itu untuk melakukan secara acak - cukup cache satu atau lebih nilai.  Artikel bagus tentang masalah skema semacam itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Anda dapat mengambil beberapa nilai "tak terduga" di blok, misalnya, hash blok, jumlah transaksi, kompleksitas jaringan, dan nilai-nilai lain yang tidak diketahui sebelumnya.  Kemudian cache mereka, satu atau lebih, dan, secara teori, Anda harus mendapatkan acak nyata.  Anda bahkan dapat menambahkan ke wihitepaper bahwa skema Anda adalah "post-quantum secure" (karena ada fungsi hash bukti-kuantum :)). </p><br><p>  Tetapi bahkan hash aman pasca-kuantum tidak cukup, sayangnya.  Rahasianya terletak pada persyaratan untuk PVRB, saya mengingatnya dari artikel sebelumnya: </p><br><ol><li>  Hasilnya harus memiliki distribusi yang terbukti seragam, yaitu berdasarkan kriptografi yang terbukti kuat. </li><li>  Tidak mungkin untuk mengontrol bit dari hasilnya.  Akibatnya, hasilnya tidak dapat diprediksi sebelumnya. </li><li>  Anda tidak dapat menyabotase protokol pembuatan dengan tidak berpartisipasi dalam protokol atau dengan membebani jaringan dengan pesan serangan </li><li>  Semua hal di atas harus tahan terhadap kolusi jumlah peserta tidak jujur â€‹â€‹yang diizinkan dalam protokol (misalnya, 1/3 dari peserta). </li></ol><br><p>  Dalam hal ini, hanya persyaratan 1 yang dipenuhi, dan 2. tidak terpenuhi. Memukul nilai yang tidak terduga dari blok, kami mendapatkan distribusi yang seragam dan keacakan yang baik.  Tetapi BP setidaknya memiliki kemampuan untuk "menerbitkan blok atau tidak."  Dengan demikian, BP setidaknya dapat memilih dari dua pilihan untuk keacakan: "milik kita" dan yang akan berubah jika orang lain membuat blok.  BP dapat "memata-matai" terlebih dahulu apa yang terjadi jika menerbitkan blok, dan hanya memutuskan untuk melakukannya atau tidak.  Jadi, bermain misalnya "odd-even" atau "red / black" dalam roulette, ia dapat menerbitkan blok hanya jika ia melihat kemenangan.  Ini juga membuat strategi tidak beroperasi untuk menggunakan, misalnya, hash blok dari masa depan.  Dalam hal ini, mereka mengatakan bahwa "acak akan digunakan, yang diperoleh dengan hashing data saat ini dan hash dari blok masa depan dengan tinggi, misalnya, N + 42, di mana N adalah tinggi blok saat ini.  Ini sedikit memperkuat skema, tetapi masih memungkinkan BP, meskipun di masa depan, untuk memilih, menahan blok atau menerbitkan. </p><br><p>  BP lunak dalam hal ini rumit, tetapi tidak banyak.  Hanya saja ketika memvalidasi dan memasukkan transaksi dalam blok, pemeriksaan cepat dilakukan untuk melihat apakah akan ada keuntungan, dan, mungkin, pemilihan satu parameter transaksi untuk mendapatkan probabilitas tinggi untuk menang.  Pada saat yang sama, menangkap BP cerdas, untuk manipulasi semacam itu hampir tidak mungkin, setiap kali Anda dapat menggunakan alamat baru, dan memenangkan sedikit, tanpa menimbulkan kecurigaan. </p><br><p>  Jadi metode yang menggunakan informasi dari blok tidak cocok untuk peran implementasi universal PVRB.  Dalam versi terbatas, dengan batasan ukuran taruhan, batasan jumlah pemain dan / atau registrasi KYC (untuk mencegah satu pemain menggunakan banyak alamat), skema ini dapat bekerja untuk permainan kecil, tetapi tidak lebih. </p><br><h2 id="pvrb-i-commit-reveal">  PVRB dan komit-ungkapkan. </h2><br><p>  Oke, terima kasih untuk hashing dan paling tidak ketidakpastian relatif dari hash blok dan variabel lainnya.  Jika Anda memecahkan masalah penambang yang beroperasi di depan, Anda harus mendapatkan sesuatu yang lebih cocok.  Mari kita tambahkan pengguna ke skema ini - meskipun mereka juga mempengaruhi keacakan: setiap orang dukungan teknis akan memberi tahu Anda bahwa hal yang paling acak dalam sistem TI adalah tindakan pengguna :) </p><br><p>  Skema naif, ketika pengguna hanya mengirim angka acak, dan hasilnya dihitung sebagai, misalnya, hash dari jumlah mereka, tidak cocok.  Dalam hal ini, pemain terakhir dapat memilih kontrol acaknya sendiri tentang apa hasilnya nanti.  Oleh karena itu, pola commit-express yang sangat banyak digunakan digunakan.  Peserta pertama-tama mengirim hash dari acak (komit) mereka, dan kemudian membuka acak sendiri.  Fase "pengungkapan" dimulai hanya setelah komit yang diperlukan telah dikumpulkan, sehingga para peserta dapat mengirim secara acak dari mana mereka mengirim hash sebelumnya.  Sekarang kita membutakan semua ini dengan parameter blok, dan itu lebih baik daripada yang diambil dari masa depan (Anda dapat mengetahui keacakan hanya di salah satu blok masa depan), dan voila - acak sudah siap!  Sekarang, setiap pemain memengaruhi keacakan, dan dapat "mengalahkan" BP jahat dengan memblokirnya dengan acaknya sendiri, yang sebelumnya tidak diketahui, acak ... Anda juga dapat menambahkan perlindungan terhadap sabotase protokol dengan tidak membukanya pada tahap pengungkapan - hanya membutuhkan penerapan jumlah tertentu pada transaksi - setoran asuransi, yang akan dikembalikan hanya selama prosedur pengungkapan.  Dalam hal ini, melakukan komit dan tidak melakukan mengungkapkan akan merugikan. </p><br><p>  Itu adalah upaya yang baik, dan skema seperti itu juga ada dalam permainan DApps, tetapi sayangnya, ini sekali lagi tidak cukup.  Sekarang, tidak hanya penambang, tetapi setiap peserta dalam protokol dapat memengaruhi hasilnya.  Masih mungkin untuk mengontrol nilai itu sendiri, dengan tingkat variabilitas yang lebih rendah, dan untuk uang, tetapi, seperti dalam kasus penambang, jika hasil undian lebih berharga daripada biaya partisipasi dalam protokol PVRB, maka produsen acak (RP) dapat memutuskan apakah akan mengungkapkan dan masih dapat memilih dari setidaknya dua opsi acak. <br>  Tetapi ada kesempatan untuk menghukum mereka yang melakukan dan tidak mengungkapkan, dan skema ini masih berguna.  Kesederhanaannya adalah keuntungan utama - protokol yang lebih serius membutuhkan komputasi yang jauh lebih kuat. </p><br><h2 id="pvrb-i-determinirovannye-podpisi">  PVRB dan tanda tangan deterministik. </h2><br><p>  Ada cara lain untuk mendapatkan RP untuk memberikan nomor pseudo-acak yang tidak dapat memengaruhi jika dilengkapi dengan "prototipe" â€”ini adalah tanda tangan deterministik.  Tanda tangan seperti itu, misalnya, RSA, dan bukan ECS.  Jika RP memiliki sepasang kunci: RSA dan ECC, dan ia menandatangani beberapa nilai dengan kunci pribadinya, maka dalam kasus RSA ia akan mendapatkan SATU DAN SATU-SATUNYA satu tanda tangan, dan dalam kasus ECS ia dapat menghasilkan sejumlah tanda tangan valid yang berbeda.  Hal ini disebabkan oleh fakta bahwa ketika membuat tanda tangan ECS, nomor acak digunakan, dipilih oleh penandatangan, dan dapat dipilih sesuai keinginan, memberikan kesempatan kepada penanda tangan untuk memilih satu dari beberapa tanda tangan.  Dalam kasus RSA: â€œsatu nilai inputâ€ + â€œsatu pasangan kunciâ€ = â€œsatu tanda tanganâ€.  Tidak mungkin untuk memprediksi seperti apa tanda tangan RP lainnya, sehingga PVRB dengan tanda tangan deterministik dapat diatur dengan menggabungkan tanda tangan RSA dari beberapa peserta yang menandatangani nilai yang sama.  Misalnya - acak sebelumnya.  Dalam skema ini, banyak sumber daya disimpan, karena  tanda tangan adalah konfirmasi kebenaran perilaku protokol dan sumber keacakan. </p><br><p>  Namun, bahkan dengan tanda tangan deterministik, skema tersebut masih rentan terhadap masalah "aktor terakhir".  Peserta terakhir masih dapat memutuskan apakah akan menerbitkan tanda tangannya atau tidak, dengan demikian mengendalikan hasilnya.  Anda dapat memperbaiki skema, menambahkan hash blok ke dalamnya, membuat putaran sehingga hasilnya tidak dapat diprediksi sebelumnya, tetapi semua metode ini, bahkan dengan mempertimbangkan banyak perbaikan, masih menyisakan masalah yang belum terselesaikan dari pengaruh satu peserta pada hasil kolektif dalam lingkungan yang tidak dipercaya dan hanya dapat bekerja dalam kondisi keterbatasan ekonomi dan waktu.  Selain itu, ukuran kunci RSA (1024 dan 2048 bit) cukup besar, dan ukuran untuk transaksi blockchain merupakan parameter yang sangat penting.  Tampaknya dengan cara sederhana itu tidak akan berhasil, kita melangkah lebih jauh. </p><br><h2 id="pvrb-i-secret-sharing-shemy">  PVRB dan skema berbagi rahasia </h2><br><p>  Dalam kriptografi, ada skema yang memungkinkan jaringan untuk menyepakati satu dan hanya satu nilai PVRB, sementara skema semacam itu tahan terhadap tindakan jahat dari sebagian peserta.  Satu protokol yang bermanfaat untuk diketahui adalah skema berbagi rahasia Shamir.  Ini berfungsi untuk membagi rahasia (misalnya kunci rahasia) menjadi beberapa bagian, dan untuk mendistribusikan bagian-bagian ini kepada N peserta.  Rahasianya didistribusikan sedemikian rupa sehingga bagian M dari N cukup untuk pemulihannya, sementara itu dapat berupa bagian M.  Jika dengan jari, kemudian memiliki grafik fungsi yang tidak diketahui, peserta bertukar poin pada grafik, dan setelah menerima poin M, seluruh fungsi dapat dipulihkan. <br>  Penjelasan yang baik diberikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> dan bermain dengannya praktis kehilangan protokol di kepala Anda berguna di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> . </p><br><p>  Jika skema FSSS (Fiat-Shamir Secret Sharing) berlaku dalam bentuk murni, itu akan menjadi PVRB yang tidak dapat digunakan.  Dalam versi paling sederhana, protokolnya mungkin terlihat seperti ini: </p><br><ul><li>  Setiap peserta menghasilkan acak mereka sendiri dan membagikan saham dari itu kepada peserta lain </li><li>         </li><li>      M shares,      ,    ,       </li><li>   random-    PVRB </li></ul><br><p>         ,   ,       threshold-  .   ,          RP ,     ,      â€œlast actorâ€. </p><br><p>      ,   PVRB   secret sharing - , ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . ,     ,        ,    .       - EOS      â€”   share : <a href=""></a> .   ,   proof-    ,     .    ,    verify   ,  block-producer  ,         ,      verify  .      ,         (0.5 ). </p><br><p>   â€”        -      .  proof-,   â€”     off-chain     ,      â€”       PVRB. </p><br><h2 id="pvrb-i-threshold-signatures"> PVRB  threshold signatures </h2><br><p>    secret sharing,     ,    â€œthresholdâ€.        M    N,         N,   â€œthresholdâ€ .       â€œlast actorâ€,        ,     ,  .          ,      . </p><br><p>     threshold-          PVRB â€”   threshold-.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    threshold-,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">longread</a>  Dash. </p><br><p>     BLS  (BLS   Boneh-Lynn-Shacham, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ),           â€” , ,     BLS          ,         ,             .                  .   ,  BLS     ,    ,   M  N       ,  , publicly verifiable,     ,     M- . </p><br><p>    threshold BLS signatures      BLS - (  ),   threshold-    .    BLS     , threshold-   â€œlast-actorâ€,          ,  , ,    . </p><br><p>  ,    PVRB   ,        BLS threshold signatures,     . , DFinity ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  ,  <a href=""></a>   verifiable secret sharing),  Keep.network (  random beacon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yellowpaper</a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> -,  ). </p><br><h2 id="implementaciya-pvrb">  PVRB </h2><br><p>  ,       ,    PVRB ,     .   ,    ,       .    PVRB   ,        : CPU, memory, storage, I/O.  PVRB â€”    ,     ,            .    ,      RP,      ,   proof-      ,    . </p><br><p>   ,        PVRB: </p><br><ul><li> <em> </em> .  PVRB    unbiasable,     .      ,    </li><li> <em> â€œlast actorâ€</em> .  PVRB     ,  ,     RP       . </li><li> <em>  </em> .  PVRB     ,  ,     RP ,        ,        </li><li> <em>  </em> .  RP              â€œ   ,     â€.  p2p ,   ,       </li><li> <em>  </em> .    PVRB on-chain    ,        .      -,       </li><li> <em>   liveness</em> .  PVRB      ,           RP    </li><li> <em> trusted setup    </em> .   PVRB   setup ,       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .        -   â€”   ,     </li><li> <em> </em> .     ,    , ,    .. </li></ul><br><p>    threshold BLS     â€”     ,       ,  ,      threshold.  ,           , , ,   ,  ,   ,   realtime,  ,       ,   threshold  .     ,         threshold-,    ,      (slashing)  ,   . ,  BLS       , ,    EOS  Ethereum â€”      .   â€”  WebAssembly  EVM,   .     (),         .           ,   1024  2048 bit  RSA,  4-8  ,      Bitcoin  Ethereum. </p><br><p>          â€”  ,    .           ,      Go  geth,  Rust  Parity,  C++  EOS.   JavaScript   ,    JavaScript      ,  WebAssembly,          -. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    ,              ,    ,       ,     . ,         ,     setup-   ,         whitepaper-    ,      -     â€œ ,   â€. </p><br><p> ,   PVRB    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haya</a> ,     threshold BLS signatures,   PVRB   ,     -      . ,      :   secret sharing    random_seed,               threshold BLS ,      .  ,   , , ,   ,     ,      â€”   ,            ,  .            â€”      ,        ,       governance . </p><br><p>           PVRB,      ,     ,  , ,  , ,  ,     ,   ,  -        .          ,         ,            . </p><br><p>  ,  ,   ,    ,      :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452340/">https://habr.com/ru/post/id452340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452330/index.html">Bagaimana melakukan perencanaan triwulanan tanpa kertas yang didistribusikan dan tidak mengacaukannya?</a></li>
<li><a href="../id452332/index.html">Sulit untuk menjadi pengelola proyek Sumber Terbuka</a></li>
<li><a href="../id452334/index.html">Cara menyamarkan diri Anda di Internet: membandingkan server dan proksi penduduk</a></li>
<li><a href="../id452336/index.html">Menyatukan Nginx Anda</a></li>
<li><a href="../id452338/index.html">Memperkenalkan Terminal Windows</a></li>
<li><a href="../id452342/index.html">Radiasi: tempat paling radioaktif di Moskow dan tidak hanya</a></li>
<li><a href="../id452344/index.html">5G - di mana dan siapa yang membutuhkannya?</a></li>
<li><a href="../id452348/index.html">Pertanyaan utama hackathon: tidur atau tidak tidur?</a></li>
<li><a href="../id452356/index.html">Bagaimana kami membuat sistem peringatan ancaman nuklir, atau bagaimana saya melatih jaringan saraf pada judul Habr</a></li>
<li><a href="../id452358/index.html">Dasar-Dasar Transformasi Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>