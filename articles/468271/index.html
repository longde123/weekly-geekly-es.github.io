<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧‍👦 👨🏽‍🚀 🤴🏼 Pruebas vs. Tipos: versión de óxido 👍🏾 🐙 🧕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos días, 0xd34df00d publicó la traducción del artículo , describiendo la posible información sobre alguna función si la usamos como un "recuadr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas vs. Tipos: versión de óxido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p> Hace unos días, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0xd34df00d</a> publicó la traducción del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> , describiendo la posible información sobre alguna función si la usamos como un "recuadro negro", sin tratar de leer su implementación.  Por supuesto, esta información es bastante diferente de un idioma a otro;  En el artículo original, se consideraron cuatro casos: </p><br><ul><li>  Python: escritura dinámica, casi sin información de la firma, las pruebas obtienen algunas pistas; </li><li>  C - escritura estática débil, un poco más de información; </li><li>  Haskell - fuerte tipeo estático, con funciones puras por defecto, mucha más información; </li><li>  Idris - mecanografía dependiente, el compilador puede probar la corrección de la función. </li></ul><br><p>  "Aquí está C y está Haskell, ¿y qué hay de Rust?"  - Esta fue la primera pregunta en la siguiente discusión.  La respuesta está aquí. </p><a name="habracut"></a><br><p>  Primero recordemos la tarea: </p><br><blockquote>  Dada una lista de valores y un valor, devuelve el índice del valor en la lista o significa que no está presente en la lista. </blockquote><p>  Si alguien no quiere no quiere leer todo esto, los ejemplos de código se proporcionan en el área de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juegos de Rust</a> . <br>  De lo contrario, ¡comencemos! </p><br><h4 id="simple-search">  Búsqueda simple </h4><br><p>  El primer enfoque será la firma casi ingenua, que difiere del código C solo en algunos elementos idiomáticos: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¿Qué sabemos sobre esta función?  Bueno, de hecho, no mucho.  Por supuesto, la <code>Option&lt;usize&gt;</code> como valor de retorno es una gran mejora sobre lo que sea proporcionado por C, pero no hay información sobre la semántica de la función.  En particular, no tenemos garantía de que los efectos secundarios estén ausentes y no hay forma de verificar de alguna manera el comportamiento deseado. </p><br><p>  ¿Puede una prueba mejorar esto?  Mira aquí: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Parece que nada más: todas estas comprobaciones pueden ser las mismas en Python (y, con anticipación, las pruebas serán de poca ayuda para todo el artículo). </p><br><h4 id="use-the-generics-luke">  ¡Usa los genéricos, Luke! </h4><br><p>  ¿Pero es bueno que tengamos que usar solo números con signo de 32 bits?  Arreglando: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Bueno, eso es algo!  Ahora podemos tomar cualquier porción, que consta de elementos de cualquier tipo comparable.  El polimorfismo explícito es casi siempre mejor que implícito (hola, Python) y casi siempre mejor que ningún polimorfismo (hola, C), ¿verdad? </p><br><p>  Aunque, esta función puede pasar inesperadamente esta prueba: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Esto sugiere el único punto que falta, ya que la especificación quiere que la función <code>refl</code> , de hecho, siempre devuelva <code>Some(0)</code> .  Por supuesto, todo esto se debe al comportamiento específico de los tipos parcialmente equivalentes en general y flotantes en particular. <br>  ¿Quizás queremos deshacernos de este problema?  Entonces, simplemente ajustaremos el límite en el tipo El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Ahora, estamos exigiendo que no solo el tipo sea comparable, sino que exigimos que estas comparaciones sean <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equivalencias</a> .  Esto, por supuesto, limita los tipos posibles para usar con esta función, pero ahora tanto la firma como las pruebas sugieren que el comportamiento debería encajar en la especificación. </p><br><div class="spoiler">  <b class="spoiler_title">Nota al margen: ¡queremos ser MÁS genéricos!</b> <div class="spoiler_text"><p>  Este caso no tiene relación con la tarea inicial, pero este parece ser un buen ejemplo del conocido principio: "sé liberal en lo que aceptas, conservador en lo que haces".  En otras palabras: si puede generalizar el tipo de entrada sin dañar la ergonomía y el rendimiento, probablemente debería hacerlo. </p><br><p>  Ahora, revisaremos esto: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¿Qué sabemos sobre esta función ahora?  En general, de todos modos, pero ahora acepta no solo el segmento o la lista, sino también algún objeto arbitrario, que puede generar referencias al tipo El, de modo que lo comparemos con el objeto en cuestión.  Por ejemplo, si no me equivoco, en Java este tipo sería <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="like-before-but-a-bit-more-strict">  Como antes, pero un poco más estricto </h4><br><p>  Pero ahora, tal vez necesitamos algunas garantías más.  O queremos trabajar en la pila (y no podemos usar <code>Vec</code> ), pero necesitamos generalizar nuestro código para cada tamaño de matriz posible.  O queremos compilar la función optimizada para cada tamaño de matriz concreta. </p><br><p>  De todos modos, necesitamos una matriz genérica, y hay una caja en Rust, que proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exactamente eso</a> . </p><br><p>  Ahora, aquí está nuestro código: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¿Qué sabemos de él?  Sabemos que la función tomará la matriz de un tamaño particular, reflejada en su tipo (y se compilará de forma independiente para cada tamaño).  Por ahora, esto no es casi nada: las mismas garantías fueron proporcionadas en tiempo de ejecución por la implementación anterior. </p><br><p>  Pero podemos llegar más lejos. </p><br><h4 id="type-level-arithmetic">  Aritmética de nivel de tipo </h4><br><p>  El artículo inicial mencionaba varias garantías proporcionadas por Idris que eran imposibles de obtener de otros idiomas.  Uno de ellos, y probablemente el más simple, ya que no implica ninguna prueba o prueba, solo un pequeño cambio en los tipos, afirma que el valor de retorno, si no es <code>Nothing</code> , siempre será menor que la longitud de la lista. </p><br><p>  Parece que los tipos dependientes, o algo así, son necesarios para tal garantía, y no podemos obtener lo mismo de Rust, ¿verdad? </p><br><p>  Conoce al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">typenum</a> .  Al usarlo, podemos escribir nuestra función de la siguiente manera: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  "¡¿Qué es esta magia negra ?!"  - podrías preguntar.  Y tienes razón: typenum <em>es</em> una magia negra, y cualquier intento de usarla es aún más mágica. <br><br>  Pero esta firma de función es bastante concreta. </p><br><ul><li>  Se necesita una variedad de El con la longitud Tamaño y un El más. </li><li>  Devuelve una Opción que, si es Some, <br><ul><li>  contiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de rasgo</a> , basado en el rasgo <code>UnsignedLessThan&lt;Size&gt;</code> ; </li><li>  y <code>UnsignedLessThan&lt;T&gt;</code> se implementa dondequiera que se implementen <code>Unsigned</code> e <code>IsLess&lt;T&gt;</code> y <code>IsLess&lt;T&gt;</code> devuelve B1, es decir, verdadero. </li></ul></li></ul><br><p>  En otras palabras, se <em>garantiza</em> que esta función devolverá un entero sin signo <em>menor que</em> el tamaño <em>de</em> la matriz (estrictamente hablando, devuelve el objeto rasgo, pero podemos llamar <code>as_usize</code> método <code>as_usize</code> y obtener el entero). </p><br><p>  Ahora puedo hablar de dos advertencias principales: </p><br><ol><li>  Podemos tener una pérdida de rendimiento.  Si de alguna manera esta función estará en la ruta "activa" del programa, los despachos dinámicos constantes podrían ralentizar todo el proceso.  Esto podría no ser una gran preocupación, de hecho, pero hay otra: </li><li>  Para que esta función se compile, debemos escribir la prueba de su corrección dentro de ella o engañar al sistema de tipos con algo <code>unsafe</code> .  El primero es bastante complejo, y el segundo es solo hacer trampa. </li></ol><br><h4 id="conclusion">  Conclusión </h4><br><p>  Por supuesto, en la práctica usaremos generalmente el segundo enfoque (con corte genérico) o el enfoque en spoiler (con iterador).  Probablemente, toda discusión posterior no sea de ningún interés práctico y es aquí solo como un ejercicio con tipos. </p><br><p>  De todos modos, el hecho de que el sistema de tipo Rust puede emular la característica del sistema de tipo Idris más fuerte, en mi opinión, es bastante impresionante en sí mismo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468271/">https://habr.com/ru/post/468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468259/index.html">Cinco aspectos destacados de la Helm Summit 2019 en Amsterdam</a></li>
<li><a href="../468261/index.html">Un nuevo juego con un ambiente antiguo en Three.js</a></li>
<li><a href="../468263/index.html">Saluda a la nueva terminal de Visual Studio</a></li>
<li><a href="../468265/index.html">Hacer dulces con Vim</a></li>
<li><a href="../468267/index.html">Fortalecimiento de la metodología UseCase dada en el libro de Alistair Coburn</a></li>
<li><a href="../468277/index.html">¿Es difícil el trabajo del programador? Una visión desde el punto de vista de la psicofisiología</a></li>
<li><a href="../468285/index.html">Las mejores empresas de desarrollo de software para empresas y startups</a></li>
<li><a href="../468287/index.html">Atributos de C #: sobre todos los aspectos</a></li>
<li><a href="../468291/index.html">Sinopsis del libro de Mark Gaulston "Puedo escucharte"</a></li>
<li><a href="../468293/index.html">Vive Cosmos: revisión del nuevo juego de realidad virtual de HTC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>