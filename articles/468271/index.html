<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üë®üèΩ‚ÄçüöÄ ü§¥üèº Pruebas vs. Tipos: versi√≥n de √≥xido üëçüèæ üêô üßïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos d√≠as, 0xd34df00d public√≥ la traducci√≥n del art√≠culo , describiendo la posible informaci√≥n sobre alguna funci√≥n si la usamos como un "recuadr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas vs. Tipos: versi√≥n de √≥xido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p> Hace unos d√≠as, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0xd34df00d</a> public√≥ la traducci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> , describiendo la posible informaci√≥n sobre alguna funci√≥n si la usamos como un "recuadro negro", sin tratar de leer su implementaci√≥n.  Por supuesto, esta informaci√≥n es bastante diferente de un idioma a otro;  En el art√≠culo original, se consideraron cuatro casos: </p><br><ul><li>  Python: escritura din√°mica, casi sin informaci√≥n de la firma, las pruebas obtienen algunas pistas; </li><li>  C - escritura est√°tica d√©bil, un poco m√°s de informaci√≥n; </li><li>  Haskell - fuerte tipeo est√°tico, con funciones puras por defecto, mucha m√°s informaci√≥n; </li><li>  Idris - mecanograf√≠a dependiente, el compilador puede probar la correcci√≥n de la funci√≥n. </li></ul><br><p>  "Aqu√≠ est√° C y est√° Haskell, ¬øy qu√© hay de Rust?"  - Esta fue la primera pregunta en la siguiente discusi√≥n.  La respuesta est√° aqu√≠. </p><a name="habracut"></a><br><p>  Primero recordemos la tarea: </p><br><blockquote>  Dada una lista de valores y un valor, devuelve el √≠ndice del valor en la lista o significa que no est√° presente en la lista. </blockquote><p>  Si alguien no quiere no quiere leer todo esto, los ejemplos de c√≥digo se proporcionan en el √°rea de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juegos de Rust</a> . <br>  De lo contrario, ¬°comencemos! </p><br><h4 id="simple-search">  B√∫squeda simple </h4><br><p>  El primer enfoque ser√° la firma casi ingenua, que difiere del c√≥digo C solo en algunos elementos idiom√°ticos: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¬øQu√© sabemos sobre esta funci√≥n?  Bueno, de hecho, no mucho.  Por supuesto, la <code>Option&lt;usize&gt;</code> como valor de retorno es una gran mejora sobre lo que sea proporcionado por C, pero no hay informaci√≥n sobre la sem√°ntica de la funci√≥n.  En particular, no tenemos garant√≠a de que los efectos secundarios est√©n ausentes y no hay forma de verificar de alguna manera el comportamiento deseado. </p><br><p>  ¬øPuede una prueba mejorar esto?  Mira aqu√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Parece que nada m√°s: todas estas comprobaciones pueden ser las mismas en Python (y, con anticipaci√≥n, las pruebas ser√°n de poca ayuda para todo el art√≠culo). </p><br><h4 id="use-the-generics-luke">  ¬°Usa los gen√©ricos, Luke! </h4><br><p>  ¬øPero es bueno que tengamos que usar solo n√∫meros con signo de 32 bits?  Arreglando: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Bueno, eso es algo!  Ahora podemos tomar cualquier porci√≥n, que consta de elementos de cualquier tipo comparable.  El polimorfismo expl√≠cito es casi siempre mejor que impl√≠cito (hola, Python) y casi siempre mejor que ning√∫n polimorfismo (hola, C), ¬øverdad? </p><br><p>  Aunque, esta funci√≥n puede pasar inesperadamente esta prueba: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Esto sugiere el √∫nico punto que falta, ya que la especificaci√≥n quiere que la funci√≥n <code>refl</code> , de hecho, siempre devuelva <code>Some(0)</code> .  Por supuesto, todo esto se debe al comportamiento espec√≠fico de los tipos parcialmente equivalentes en general y flotantes en particular. <br>  ¬øQuiz√°s queremos deshacernos de este problema?  Entonces, simplemente ajustaremos el l√≠mite en el tipo El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Ahora, estamos exigiendo que no solo el tipo sea comparable, sino que exigimos que estas comparaciones sean <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equivalencias</a> .  Esto, por supuesto, limita los tipos posibles para usar con esta funci√≥n, pero ahora tanto la firma como las pruebas sugieren que el comportamiento deber√≠a encajar en la especificaci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Nota al margen: ¬°queremos ser M√ÅS gen√©ricos!</b> <div class="spoiler_text"><p>  Este caso no tiene relaci√≥n con la tarea inicial, pero este parece ser un buen ejemplo del conocido principio: "s√© liberal en lo que aceptas, conservador en lo que haces".  En otras palabras: si puede generalizar el tipo de entrada sin da√±ar la ergonom√≠a y el rendimiento, probablemente deber√≠a hacerlo. </p><br><p>  Ahora, revisaremos esto: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¬øQu√© sabemos sobre esta funci√≥n ahora?  En general, de todos modos, pero ahora acepta no solo el segmento o la lista, sino tambi√©n alg√∫n objeto arbitrario, que puede generar referencias al tipo El, de modo que lo comparemos con el objeto en cuesti√≥n.  Por ejemplo, si no me equivoco, en Java este tipo ser√≠a <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="like-before-but-a-bit-more-strict">  Como antes, pero un poco m√°s estricto </h4><br><p>  Pero ahora, tal vez necesitamos algunas garant√≠as m√°s.  O queremos trabajar en la pila (y no podemos usar <code>Vec</code> ), pero necesitamos generalizar nuestro c√≥digo para cada tama√±o de matriz posible.  O queremos compilar la funci√≥n optimizada para cada tama√±o de matriz concreta. </p><br><p>  De todos modos, necesitamos una matriz gen√©rica, y hay una caja en Rust, que proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exactamente eso</a> . </p><br><p>  Ahora, aqu√≠ est√° nuestro c√≥digo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  ¬øQu√© sabemos de √©l?  Sabemos que la funci√≥n tomar√° la matriz de un tama√±o particular, reflejada en su tipo (y se compilar√° de forma independiente para cada tama√±o).  Por ahora, esto no es casi nada: las mismas garant√≠as fueron proporcionadas en tiempo de ejecuci√≥n por la implementaci√≥n anterior. </p><br><p>  Pero podemos llegar m√°s lejos. </p><br><h4 id="type-level-arithmetic">  Aritm√©tica de nivel de tipo </h4><br><p>  El art√≠culo inicial mencionaba varias garant√≠as proporcionadas por Idris que eran imposibles de obtener de otros idiomas.  Uno de ellos, y probablemente el m√°s simple, ya que no implica ninguna prueba o prueba, solo un peque√±o cambio en los tipos, afirma que el valor de retorno, si no es <code>Nothing</code> , siempre ser√° menor que la longitud de la lista. </p><br><p>  Parece que los tipos dependientes, o algo as√≠, son necesarios para tal garant√≠a, y no podemos obtener lo mismo de Rust, ¬øverdad? </p><br><p>  Conoce al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">typenum</a> .  Al usarlo, podemos escribir nuestra funci√≥n de la siguiente manera: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  "¬°¬øQu√© es esta magia negra ?!"  - podr√≠as preguntar.  Y tienes raz√≥n: typenum <em>es</em> una magia negra, y cualquier intento de usarla es a√∫n m√°s m√°gica. <br><br>  Pero esta firma de funci√≥n es bastante concreta. </p><br><ul><li>  Se necesita una variedad de El con la longitud Tama√±o y un El m√°s. </li><li>  Devuelve una Opci√≥n que, si es Some, <br><ul><li>  contiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de rasgo</a> , basado en el rasgo <code>UnsignedLessThan&lt;Size&gt;</code> ; </li><li>  y <code>UnsignedLessThan&lt;T&gt;</code> se implementa dondequiera que se implementen <code>Unsigned</code> e <code>IsLess&lt;T&gt;</code> y <code>IsLess&lt;T&gt;</code> devuelve B1, es decir, verdadero. </li></ul></li></ul><br><p>  En otras palabras, se <em>garantiza</em> que esta funci√≥n devolver√° un entero sin signo <em>menor que</em> el tama√±o <em>de</em> la matriz (estrictamente hablando, devuelve el objeto rasgo, pero podemos llamar <code>as_usize</code> m√©todo <code>as_usize</code> y obtener el entero). </p><br><p>  Ahora puedo hablar de dos advertencias principales: </p><br><ol><li>  Podemos tener una p√©rdida de rendimiento.  Si de alguna manera esta funci√≥n estar√° en la ruta "activa" del programa, los despachos din√°micos constantes podr√≠an ralentizar todo el proceso.  Esto podr√≠a no ser una gran preocupaci√≥n, de hecho, pero hay otra: </li><li>  Para que esta funci√≥n se compile, debemos escribir la prueba de su correcci√≥n dentro de ella o enga√±ar al sistema de tipos con algo <code>unsafe</code> .  El primero es bastante complejo, y el segundo es solo hacer trampa. </li></ol><br><h4 id="conclusion">  Conclusi√≥n </h4><br><p>  Por supuesto, en la pr√°ctica usaremos generalmente el segundo enfoque (con corte gen√©rico) o el enfoque en spoiler (con iterador).  Probablemente, toda discusi√≥n posterior no sea de ning√∫n inter√©s pr√°ctico y es aqu√≠ solo como un ejercicio con tipos. </p><br><p>  De todos modos, el hecho de que el sistema de tipo Rust puede emular la caracter√≠stica del sistema de tipo Idris m√°s fuerte, en mi opini√≥n, es bastante impresionante en s√≠ mismo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468271/">https://habr.com/ru/post/468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468259/index.html">Cinco aspectos destacados de la Helm Summit 2019 en Amsterdam</a></li>
<li><a href="../468261/index.html">Un nuevo juego con un ambiente antiguo en Three.js</a></li>
<li><a href="../468263/index.html">Saluda a la nueva terminal de Visual Studio</a></li>
<li><a href="../468265/index.html">Hacer dulces con Vim</a></li>
<li><a href="../468267/index.html">Fortalecimiento de la metodolog√≠a UseCase dada en el libro de Alistair Coburn</a></li>
<li><a href="../468277/index.html">¬øEs dif√≠cil el trabajo del programador? Una visi√≥n desde el punto de vista de la psicofisiolog√≠a</a></li>
<li><a href="../468285/index.html">Las mejores empresas de desarrollo de software para empresas y startups</a></li>
<li><a href="../468287/index.html">Atributos de C #: sobre todos los aspectos</a></li>
<li><a href="../468291/index.html">Sinopsis del libro de Mark Gaulston "Puedo escucharte"</a></li>
<li><a href="../468293/index.html">Vive Cosmos: revisi√≥n del nuevo juego de realidad virtual de HTC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>