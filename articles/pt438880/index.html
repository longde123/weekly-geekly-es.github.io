<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌨️ 👆🏾 🤵🏾 Quando usar var, let e const em Javascript [artigo de Tyler McGinnis] 👓 🎾 ❎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo “var vs let vs const em JavaScript” de Tyler McGinnis. 



 Neste artigo, você aprenderá duas novas ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quando usar var, let e const em Javascript [artigo de Tyler McGinnis]</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438880/"> Olá Habr!  Apresento a você a tradução do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“var vs let vs const em JavaScript”</a> de Tyler McGinnis. <br><br><img src="https://cdn-images-1.medium.com/max/2600/1*bPIf2_HXNUG4O_tSvWKYsg.png" alt="imagem"><br><br>  Neste artigo, você aprenderá duas novas maneiras de criar variáveis ​​em Javascript (ES6), let e const.  No decorrer deste artigo, examinaremos as diferenças entre <i>var</i> , <i>let</i> e <i>const</i> , além de tópicos relacionados, como: “escopo da função versus escopo do bloco”, “aumento” de variáveis ​​e imunidade. <br><a name="habracut"></a><br>  Se você preferir um vídeo, assista a este (original em inglês): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6vBYfLCE9-Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O ES2015 (ou ES6) nos apresentou duas novas maneiras de criar variáveis, <i>let</i> e <i>const</i> .  Mas antes de nos aprofundarmos nas diferenças entre <i>var</i> , <i>let</i> e <i>const</i> , existem alguns tópicos que você deve conhecer primeiro.  Estas são a declaração de variáveis ​​e sua inicialização, escopo (um escopo especial da função) e “aumento”. <br><br><h3>  Declarando e inicializando variáveis </h3><br>  Uma declaração de variável introduz um novo identificador. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration</code> </pre> <br>  Acima, criamos um novo identificador que denominamos "declaração".  Em Javascript, quando criadas, as variáveis ​​são inicializadas com um valor <i>indefinido</i> .  Isso significa que, se tentarmos gerar nossa variável de <i>declaração</i> , ficaremos <i>indefinidos</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration)</code> </pre> <br>  E assim, inferimos a variável de <i>declaração</i> e ficamos <i>indefinidos</i> . <br><br>  Comparado a declarar uma variável, inicializar uma variável é a primeira vez que você define o valor dessa variável. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration) <span class="hljs-comment"><span class="hljs-comment">// undefined declaration = '  '</span></span></code> </pre> <br>  E assim, aqui inicializamos a variável de <i>declaração</i> escrevendo uma string para ela. <br><br>  Isso nos leva ao próximo conceito, escopo. <br><cut><br><h3>  Âmbito de aplicação </h3><br>  Um escopo descreve onde a variável e as funções podem ser acessadas dentro do nosso programa.  Em Javascript, existem 2 tipos de escopos - o <b>escopo global</b> e <b>o escopo de uma função</b> .  De acordo com a especificação oficial, <br><blockquote>  "Se uma declaração de variável ocorrer dentro de uma declaração de função, a variável é definida no escopo local desta função ..." </blockquote>  Isso significa que, se você criar uma variável usando <i>var</i> , o escopo dessa variável será a função em que foi criada e estará disponível apenas dentro dessa função ou em qualquer outra função aninhada. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date } getDate() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(date) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: Reference Error</span></span></code> </pre> <br>  Acima, tentamos acessar a variável de fora da função na qual ela foi declarada.  Como o escopo da variável <i>date</i> é a função <i>getDate</i> , ela está disponível apenas dentro desta função ou em qualquer outra função aninhada em <i>getDate</i> (como mostrado abaixo). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toDateString().slice(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">// OK } return formatDate() } getDate() console.log(date) // NOT OK: Reference Error</span></span></code> </pre> <br>  Agora vamos dar uma olhada em um exemplo mais avançado.  Digamos que temos uma matriz de preços e precisamos de uma função que aceite essa matriz, bem como uma variável de <i>desconto</i> , e nos devolva uma nova matriz de preços com descontos.  O objetivo final pode ser algo como isto: <br><br><pre> <code class="javascript hljs">discountPrices([<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>], <span class="hljs-number"><span class="hljs-number">.5</span></span>)</code> </pre> <br>  E a implementação pode ser algo como isto: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discounted }</code> </pre> <br>  Parece bastante simples, mas o que isso tem a ver com o escopo do bloco?  Dê uma olhada nisso <i>para</i> loop.  As variáveis ​​declaradas dentro dele são acessíveis fora dela?  Acontece disponível. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Se o JavaScript é a única linguagem de programação que você conhece, talvez não precise se preocupar muito com isso.  No entanto, se você chegou ao JavaScript de outra linguagem de programação, em particular uma linguagem de programação que bloqueia o escopo, provavelmente está um pouco preocupado com o que está acontecendo aqui. <br><br>  Não está quebrado, apenas funciona um pouco estranho.  Realmente não há razão para ter acesso a <i>i</i> , <i>discountPrice</i> e <i>finalPrice</i> fora do loop <i>for</i> .  Não nos faz nenhum bem e pode até nos prejudicar em algumas situações.  No entanto, como as variáveis ​​são declaradas usando <i>var</i> , elas se enquadram no escopo da função e você pode acessá-las. <br><br>  Agora discutimos a declaração e a inicialização de variáveis, bem como o escopo, outra coisa com a qual precisamos lidar antes de mergulhar nas diferenças entre <i>let</i> e <i>const</i> , isso é "aumentar". <br><br><h3>  "Elevador" </h3><br>  Lembre-se, foi dito anteriormente: "No Javascript, quando criadas, as variáveis ​​são inicializadas com o valor indefinido".  Acontece que significa "elevação".  O intérprete JavaScript define as variáveis ​​declaradas como <i>indefinidas</i> durante uma fase chamada "Criação". <br><br>  Para um estudo mais detalhado da fase de criação, "Elevação" e escopos, leia este artigo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"O melhor guia para içamento, escopos e fechamentos em JavaScript"</a> . <br><br>  Vamos dar uma olhada no exemplo anterior e ver como a “elevação” afeta isso. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Observe que todas as variáveis ​​declaradas foram definidas como <i>indefinidas</i> .  Por isso, se você tentar acessar um deles antes que ele seja realmente anunciado, ficará <i>indefinido</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Agora você sabe tudo o que precisa sobre <i>var</i> , agora vamos finalmente falar sobre o principal objetivo para o qual estamos aqui: qual é a diferença entre <i>var</i> , <i>let</i> e <i>const</i> ? <br><br><h3>  var, let ou const </h3><br>  Para começar, vamos comparar <i>var</i> e <i>let</i> .  A principal diferença entre <i>var</i> e <i>let</i> é que, além do escopo global e do escopo da função, é possível definir variáveis ​​no escopo do bloco.  Isso significa que a variável criada usando a palavra-chave <i>let</i> está disponível dentro do "bloco" onde foi criada, bem como dentro de blocos aninhados.  Quando eu disse "bloquear", quis dizer algo cercado por chaves {}, como um loop for ou uma <i>declaração if</i> . <br><br>  Então, voltemos à nossa função <i>discountPrices</i> pela última vez. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Lembre-se de que temos o direito de gerar <i>i</i> , <i>discountPrice</i> e <i>finalPrice</i> fora do loop <i>for</i> , pois eles foram declarados usando <i>var</i> e as variáveis ​​declaradas usando a palavra-chave <i>var</i> são limitadas pelo escopo da função.  Mas o que acontece agora se alterarmos <i>var</i> para <i>permitir</i> e tentar executar nosso código? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted } discountPrices([100, 200, 300], .5) // NOT OK: ReferenceError: i is not defined</span></span></code> </pre> <br>  Temos o <i>ReferenceError: i não está definido</i> .  O que nos diz que a variável declarada com <i>let</i> é limitada ao escopo do bloco, não à função.  Tente chamar <i>i</i> (ou <i>DiscountPrice</i> ou <i>finalPrice</i> ) fora do "bloco" onde eles foram declarados, e isso nos dará um erro de chamada, como acabamos de ver. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>:    </code> </pre> <br>  As seguintes diferenças estão relacionadas à “elevação”.  Dissemos anteriormente que a definição de "elevação" é: "O interpretador JavaScript define as variáveis ​​declaradas como <i>indefinidas</i> durante a fase chamada" Criação "." Também vimos isso em ação chamando a variável antes que ela fosse declarada (você ficou <i>indefinido</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Não me lembro de um único caso de uso em que você realmente gostaria de acessar uma variável antes de declará-la.  Parece que obter um <i>ReferenceError</i> seria melhor do que ficar <i>indefinido</i> . <br><br>  De fato, é isso que <i>let</i> faz.  Se você tentar acessar uma variável antes de sua declaração com <i>let</i> , em vez de ficar <i>indefinido</i> (como era ao declarar com <i>var</i> ), você obterá um <i>ReferenceError</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: ReferenceError let discounted = [] for (let i = 0; i &lt; prices.length; i++) { let discountedPrice = prices[i] * (1 - discount) let finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .</code> </pre> <br><h3>  deixe ou const </h3><br>  Agora você entende a diferença entre var e let, e a const?  Acontece que const é quase o mesmo que let.  No entanto, há uma diferença: se você atribuiu um valor usando const, não poderá alterá-lo para outro. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handle = <span class="hljs-string"><span class="hljs-string">'tylermcginnis'</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler McGinnis'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK handle = '@tylermcginnis' // NOT OK: TypeError: Assignment to constant variable.</span></span></code> </pre> <br>  A conclusão do exposto acima é que variáveis ​​declaradas com <i>let</i> podem ser substituídas, e variáveis ​​declaradas com <i>const</i> não podem. <br><br>  Ótimo, agora que você deseja que sua variável seja imutável, você pode declá-la com <i>const</i> .  Ou na verdade não.  Só porque uma variável foi declarada usando <i>const</i> não significa que é imutável, tudo o que significa é que não pode ser substituída.  Abaixo está um bom exemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Kim Kardashian'</span></span> } person.name = <span class="hljs-string"><span class="hljs-string">'Kim Kardashian West'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK person = {} // NOT OK: Assignment to constant variable.</span></span></code> </pre> <br>  Observe que alterar a propriedade de um objeto não é uma substituição, portanto, mesmo que o objeto seja declarado usando <i>const</i> , isso não significa que você não pode alterar nenhuma de suas propriedades.  Isso significa apenas que você não pode substituir este objeto. <br><br>  Agora, a pergunta mais importante que ainda não foi respondida: o que devo usar <i>var</i> , <i>let</i> ou <i>const</i> ?  A opinião mais popular, e à qual eu aderi, é sempre usar <i>const</i> até que você saiba se a variável será alterada.  A razão para isso é que o uso de <i>const</i> deixa claro para você e para os futuros desenvolvedores que devem ler seu código que essa variável não deve ser alterada.  Se você precisar alterá-lo (por exemplo, em um loop <i>for</i> ), use <i>let</i> . <br><br>  Não há muitos casos entre variáveis ​​que mudam e variáveis ​​que não mudam.  Isso significa que você nunca precisará usar <i>var</i> novamente. <br><br>  Agora, a opinião impopular, embora ainda tenha justificativa, é que você nunca deve usar <i>const</i> , embora esteja tentando mostrar que essa variável é imutável, como vimos acima, isso não é totalmente verdade.  Os desenvolvedores que mantêm essa opinião sempre usam <i>let</i> , desde que não haja variáveis ​​que sejam realmente constantes, como _LOCATION_ = .... <br><br>  Vamos fazer um resumo do exposto acima, <i>var é</i> limitado pelo escopo da função e, se você tentar acessar essa variável antes da declaração, ficará <i>indefinido</i> .  <i>const</i> e <i>let são</i> limitados pelo escopo do bloco e, se você tentar acessar essas variáveis ​​antes de declará-las, obterá um <i>ReferenceError</i> .  E a diferença entre <i>const</i> e <i>let</i> é que o valor que foi atribuído a <i>const</i> não pode ser substituído, ao contrário de <i>let</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        . const:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .    </code> </pre> <br>  Este artigo foi publicado originalmente em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tylermcginnis.com</a> como parte do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modern JavaScript</a> . <br><br>  <i>Obrigado por ler esta tradução, espero que você tenha encontrado algo novo e útil para si mesmo.</i>  <i>Ficarei feliz em ver o feedback!</i> </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438880/">https://habr.com/ru/post/pt438880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438868/index.html">Semana 06 de segurança: ao vivo no FaceTime</a></li>
<li><a href="../pt438870/index.html">Lombok retorna a grandeza do Java</a></li>
<li><a href="../pt438874/index.html">Começando uma amizade com a VkNet</a></li>
<li><a href="../pt438876/index.html">Como reduzir o tempo de colocação no mercado: uma história sobre automação de testes no M. Video</a></li>
<li><a href="../pt438878/index.html">A aparição do filme em torrents após a estréia aumenta as bilheterias em 3%</a></li>
<li><a href="../pt438882/index.html">A probabilidade de ganhar uma partida com uma probabilidade conhecida de ganhar um ponto</a></li>
<li><a href="../pt438884/index.html">História verdadeira de uma agência de publicidade do interior: altos, baixos e implementação de CRM</a></li>
<li><a href="../pt438886/index.html">Morty, estamos no UltraHD! Como assistir a qualquer filme em 4K, completando-o através de uma rede neural pouco conhecida</a></li>
<li><a href="../pt438890/index.html">Postgres em retrospecto</a></li>
<li><a href="../pt438892/index.html">O que é uma blockchain corporativa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>