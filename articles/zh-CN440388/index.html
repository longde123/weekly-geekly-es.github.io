<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏻 🈲 👟 时间间隔：即将到来的C ++演变 👋🏻 🦕 👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20标准将很快出现，它可能会添加范围的概念，但是很少有人知道它们是什么以及一起吃什么。 我找不到关于这种野兽的通俗易懂的俄文资料，这就是为什么在本文中，我根据大会会议C ++ 2015-的一年。 对于那些首次遇到此概念的人，我将尽力使本文尽可能清晰，同时，对于那些已经熟悉此概念并想了解更多...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>时间间隔：即将到来的C ++演变</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/"> C ++ 20标准将很快出现，它可能会添加<i>范围</i>的概念，但是很少有人知道它们是什么以及一起吃什么。 我找不到关于这种野兽的通俗易懂的俄文资料，这就是为什么在本文中，我根据大会会议C ++ 2015-的一年。 对于那些首次遇到此概念的人，我将尽力使本文尽可能清晰，同时，对于那些已经熟悉此概念并想了解更多信息的人，我将谈论各种芯片，例如区间适配器。 <br><br><h2> 范围库 </h2><br> 在撰写本文时，有三个主要的实现间隔的库： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">升压范围</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">范围v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">智库公共图书馆</a> </li></ul><br> 实际上，第一个库就是这个概念的源头（这并不奇怪，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boost</a>库的集合中什么都没有：）。 第二个是Eric Niebler的库，稍后将对其进行描述。 最后，您可能会猜到，最后一个库是由think-cell编写的，可以说是开发和改进了Boost.Range。 <br><a name="habracut"></a><br><h2> 为什么间隔是我们的未来？ </h2><br> 对于不熟悉间隔概念的人，我们将此非平凡的概念定义为具有开始和结束（一<u>对迭代器</u> ）的概念。 <br><br> 现在让我们考虑以下任务：有一个向量，有必要从其中删除所有重复的元素。 在当前标准下，我们将这样解决： <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br> 在这种情况下，我们将向量的名称最多指定<b>6</b>次！ 但是，使用间隔的概念（将向量的开始和结束处的迭代器组合到一个对象中），只需指定<b>一次</b>所需的向量，就可以编写很多次代码： <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2> 当前哪个间隔在当前标准之内？ </h2><br> 在C ++ 11标准中，添加了基于范围的for循环和对容器的开始/结尾的通用访问，在最新的C ++ 17标准中，未添加与间隔有关的新内容。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2> 未来间隔 </h2><br> 现在让我们来谈谈前面提到的Range V3库。 其创建者Eric Nibler在其家庭项目中创建了<i>Range的技术规范</i> ，并修改了<i>算法</i>库以支持间隔。 看起来像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br> 在他的网站上有一些他想标准化的预览，这是<i>Range V3</i> 。 <br><br><h2> 可以考虑什么范围？ </h2><br> 首先， <i>容器</i> （向量，字符串，列表等），因为它们有一个开始和一个结束。 显然，容器具有它们自己的元素，也就是说，当我们引用容器时，我们将引用其所有元素。 同样，在复制和声明常量时（深度复制和一致性）。 其次， <i>视图</i>也可以视为间隔。 视图只是分别指向起点和终点的一对迭代器。 这是他们最简单的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br> 而视图仅引用元素，因此复制和一致性是惰性的（这不会影响元素）。 <br><br><h2> 间隔适配器 </h2><br> 间隔的发明者并不仅限于此，因为否则该概念将毫无用处。 因此，他们引入了范围适配器之类的概念。 <br><br><h3> 转换适配器 </h3><br> 考虑以下任务：给出一个<i>int</i>向量，其中我们需要找到等于4的第一个元素： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br> 现在想象一下，向量的类型不是int，而是某种复杂的自写结构，但是其中有一个int，并且任务是相同的： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br> 显然，这两个代码在语义上相似，但是在语法上却有很大不同，因为在后一种情况下，我们必须手动编写一个贯穿<i>int</i>字段的函数。 但是，如果您使用转换适配器（ <i>transform adapter</i> ），那么一切看起来都会更加简洁： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br> 实际上，转换适配器通过在int字段周围创建包装器类来“转换”我们的结构。 显然，指针指向<i>id</i>字段，但是如果我们希望它指向整个结构，则需要在末尾添加<i>.base（）</i> 。 此命令封装了该字段，因此指针可以在整个结构中运行： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br> 这是转换适配器的示例实现（它由迭代器组成，每个迭代器都有自己的函子）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3> 过滤器适配器 </h3><br> 并且如果在最后一个任务中我们不需要查找第一个此类元素，而是“过滤” <i>int</i>的<b>整个</b>字段以查找此类元素的存在？ 在这种情况下，我们将使用过滤器适配器： <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br> 请注意，过滤器在迭代过程中延迟执行。 <br><br> 这是他幼稚的实现（类似的东西在Boost.Range中实现）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br> 如我们所见，这里需要两个迭代器，而不是转换适配器中的一个。 为了避免在迭代过程中意外超出容器的边界，第二个迭代器是必需的。 <br><br><h2> 一些优化 </h2><br> 好的，但是从<b>tc ::过滤器（tc ::过滤器（tc ::过滤器（...）））</b>来看，迭代器是什么样的？ <br><br><h3> 升压范围 </h3><br> 作为上述实现的一部分，它看起来像这样： <br><br><div class="spoiler">  <b class="spoiler_title">胆小的人不要看！</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br> 显然，这是<u>非常</u>低效的。 <br><br><h3> 范围v3 </h3><br> 让我们考虑如何优化此适配器。  Eric Nibler的想法是在适配器对象中放入常规信息（仿函数和指向末尾的指针），然后我们可以存储指向该适配器对象和所需迭代器的链接 <br> <code>*m_rng <br> m_it <br></code> <br> 然后，在这种实现的框架中，三重过滤器将如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">泰克</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br> 尽管有时比以前的实现要快，但这仍然不是完美的。 <br><br><h3> 智库，索引概念 </h3><br> 现在考虑think-cell解决方案。 他们引入了所谓的<i>索引概念</i>来解决这个问题。 索引就是这样一种迭代器，它执行与常规迭代器相同的所有操作，但是通过引用间隔来执行此操作。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br> 我们展示了如何将索引与常规迭代器结合在一起。 <br><br> 显然，常规迭代器也可以视为索引。 在相反的方向上，兼容性可以例如这样实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br> 然后，将高效地实现三重过滤器： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br> 在这种实现的框架中，无论过滤器的深度如何，该算法都能快速工作。 <br><br><h2> 具有左值和右值容器的间隔 </h2><br> 现在，让我们看看区间如何与左值和右值容器一起工作： <br><br><h3> 左值 </h3><br> 范围V3和思考单元的行为与左值相同。 假设我们有如下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br> 在这里，我们有一个预先声明的向量位于内存（左值）中，我们需要创建一个间隔，然后以某种方式使用它。 我们使用<i>view :: filter</i>或<i>tc :: filter</i>创建一个视图，然后变得快乐，没有错误，然后可以在例如any_of中使用此视图。 <br><br><h3> 范围V3和右值 </h3><br> 但是，如果矢量还没有存储在内存中（例如，如果我们只是在创建它），并且我们将面临相同的任务，那么我们将尝试编写并面临错误： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br> 为什么会出现？ 由于我们创建了一个向量并将其直接放入过滤器中，因此View将成为rvalue的悬挂链接，也就是说，过滤器中将存在一个rvalue链接，当编译器转到下一行并发生错误时，它将指向一个未知的东西。 为了解决此问题，Range V3提出了以下<i>措施</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br> 动作同时执行所有操作，也就是说，它只需要一个向量，按谓词过滤并将其放入一个间隔中。 但是，缺点是它不再是懒惰的，因此Think-cell试图解决此问题。 <br><br><h3> 思维单元和右值 </h3><br>  Think-cell做到了，因此创建了一个容器而不是视图： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br> 结果，我们不会遇到类似的错误，因为在其实现中，过滤器会收集右值容器而不是链接，因此这种情况很懒惰。  Range V3不想这样做，因为他们担心由于过滤器以视图或容器的形式出现错误，但是think-cell确信程序员会理解过滤器的行为，并且大多数错误正是由于这种“懒惰”而产生的。 <br><br><h2> 发电机间隔 </h2><br> 我们概括了区间的概念。 实际上，存在没有迭代器的间隔。 它们称为<i>发电机范围</i> 。 假设我们有一个GUI小部件（一个界面元素），我们称之为移动小部件。 我们有一个窗口要求移动其窗口小部件，在<i>列表框中</i>还有一个按钮，另一个窗口也应在其窗口小部件之间滚动，即调用<i>traverse_widgets</i> ，它将元素连接到函子（ <i>您可以说有一个枚举函数，您可以在其中连接仿函数，该函数将列出它在仿函数中具有的所有元素</i> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br> 这在某种程度上让人联想到小部件间距，但是这里没有迭代器。 直接编写它们效率低下，最困难的是。 在这种情况下，可以说这样的结构也被视为间隔。 在这种情况下，可以使用一些有用的间隔方法，例如<i>any_of</i> ： <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell尝试实现方法，以使它们对于所有间隔都具有相同的接口： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br> 使用<i>tc :: enumerate</i>可以隐藏时间间隔之间的差异，因为这种实现遵循<i>内部迭代</i>的概念（在本讲座中将更详细地描述<i>外部</i> <i>迭代</i>和<i>内部迭代</i>的概念），但是这种实现有其缺点，即<i>std :: any_of</i>会在遇到<i>true时</i> <i>立即</i>停止。 他们尝试通过添加例外（所谓的<i>生成器间隔中断</i> ）来解决此问题。 <br><br><h2> 结论 </h2><br> 我讨厌基于范围的for循环，因为它会激励人们在需要和不需要的地方编写它，因为代码的简洁性通常会变差，例如，人们会这样写： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br> 相反： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440388/">https://habr.com/ru/post/zh-CN440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440374/index.html">Yandex函数发送邮件</a></li>
<li><a href="../zh-CN440376/index.html">20个游戏来教孩子编程</a></li>
<li><a href="../zh-CN440378/index.html">回到Istio的微服务。 第二部分</a></li>
<li><a href="../zh-CN440382/index.html">200是好是坏？</a></li>
<li><a href="../zh-CN440386/index.html">通过消除错误来释放错误处理</a></li>
<li><a href="../zh-CN440390/index.html">嵌入式系统的多样化世界以及Embox在其中的地位</a></li>
<li><a href="../zh-CN440392/index.html">您网站上的WebRTC-没有错误，也没有预算</a></li>
<li><a href="../zh-CN440394/index.html">PostgreSQL权限提升-CVE-2018-10915解析</a></li>
<li><a href="../zh-CN440398/index.html">参加2018年俄罗斯AI杯的历史（和胜利）-CodeBall</a></li>
<li><a href="../zh-CN440400/index.html">Apache Kafka + Spring Boot：您好，微服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>