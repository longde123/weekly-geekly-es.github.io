<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🤵🏼 🎻 Volltextsuche: Elasticsearch-spezifische Funktionen für komplexe Aufgaben 🎮 🍍 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, mein Name ist Andrey und ich bin Entwickler. Vor langer Zeit - anscheinend letzten Freitag - hatte unser Team ein Projekt, bei dem n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volltextsuche: Elasticsearch-spezifische Funktionen für komplexe Aufgaben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413075/"><img src="https://habrastorage.org/webt/yb/hh/1r/ybhh1rxmqt9yswla3tfbiexyluo.png" alt="Bild"><br><br>  Hallo allerseits, mein Name ist Andrey und ich bin Entwickler.  Vor langer Zeit - anscheinend letzten Freitag - hatte unser Team ein Projekt, bei dem nach den Zutaten gesucht werden musste, aus denen die Produkte bestehen.  Sagen wir die Zusammensetzung der Wurst.  Zu Beginn des Projekts war bei der Suche nicht viel erforderlich: Alle Rezepte anzuzeigen, in denen die gewünschte Zutat in einer bestimmten Menge enthalten ist;  Wiederholen Sie dies für N Zutaten. <br><a name="habracut"></a><br>  In Zukunft sollte die Anzahl der Produkte und Inhaltsstoffe jedoch erheblich erhöht werden, und die Suche sollte nicht nur dem zunehmenden Datenvolumen gerecht werden, sondern auch zusätzliche Optionen bieten - beispielsweise die automatische Erstellung einer Produktbeschreibung auf der Grundlage der vorherrschenden Inhaltsstoffe. <br><br>  <b>Anforderungen</b> <br><br><ul><li>  Erstellen Sie eine Suche in Elacsticsearch mit einer Datenbank von mindestens 50.000 Dokumenten. </li><li>  Bieten Sie eine schnelle Antwort auf Anfragen - weniger als 300 ms. </li><li>  Um sicherzustellen, dass die Anfragen klein waren und der Dienst auch unter den Bedingungen des schlechtesten mobilen Internets verfügbar war. </li><li>  Machen Sie die Suchlogik aus UX-Sicht so intuitiv wie möglich.  Es war im Wesentlichen so, dass die Schnittstelle die Suchlogik widerspiegeln würde - und umgekehrt. </li><li>  Minimieren Sie die Anzahl der Zwischenschichten zwischen Systemelementen, um eine höhere Leistung und weniger Abhängigkeiten zu erzielen. </li><li>  Sie können jederzeit die Möglichkeit bieten, den Algorithmus durch neue Bedingungen zu ergänzen (z. B. automatische Generierung einer Produktbeschreibung). </li><li>  Machen Sie die weitere Unterstützung für den Suchteil des Projekts so einfach und bequem wie möglich. </li></ul><br>  Wir beschlossen, uns nicht zu beeilen und einfach anzufangen. <br><br>  Zunächst haben wir alle Inhaltsstoffe der Produktzusammensetzung in einer Datenbank gespeichert, nachdem wir zunächst 10.000 Einträge erhalten hatten.  Leider hat das Durchsuchen der Datenbank selbst bei dieser Größe zu viel Zeit in Anspruch genommen, selbst unter Berücksichtigung der Verwendung von Joins und Indizes.  Und in naher Zukunft sollte die Anzahl der Datensätze 50.000 überschritten haben. Darüber hinaus bestand der Kunde darauf, Elasticsearch (im Folgenden: ES) zu verwenden, da er auf dieses Tool stieß und anscheinend ein warmes Gefühl für ihn hatte.  Wir haben vorher nicht mit ES gearbeitet, aber wir wussten um die Vorteile und stimmten dieser Wahl zu, da beispielsweise geplant war, dass wir häufig neue Einträge haben (nach verschiedenen Schätzungen von 50 bis 500 pro Tag), die notwendig wären sofort an den Benutzer weitergeben. <br><br>  Wir haben uns entschieden, Interlayer auf Treiberebene aufzugeben und einfach REST-Anforderungen zu verwenden, da die Synchronisierung mit der Datenbank nur zum Zeitpunkt der Erstellung des Dokuments erfolgt und nicht mehr benötigt wird.  Dies war ein weiterer Vorteil - bis zum direkten Senden von Suchanfragen von einem Browser an ES. <br><br>  Wir haben den ersten Prototyp zusammengestellt, in dem wir die Struktur aus einer Datenbank (PostgreSQL) in ES-Dokumente übertragen haben: <br><br><pre><code class="php hljs">{<span class="hljs-string"><span class="hljs-string">"mappings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_source"</span></span> : { <span class="hljs-string"><span class="hljs-string">"enabled"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"integer"</span></span>}, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"text"</span></span>}, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"nested"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-string"><span class="hljs-string">"float"</span></span> } } } } }}</code> </pre> <br>  Basierend auf dieser Zuordnung erhalten wir ungefähr das folgende Dokument (wir können den Mitarbeiter aufgrund der NDA nicht aus dem Projekt anzeigen): <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA &amp; BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 4"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } ] }</code> </pre> <br>  All dies wurde mit dem Elasticsearch PHP-Paket durchgeführt.  Erweiterungen für Laravel (Elastiquent, Laravel Scout usw.) haben sich aus einem Grund entschieden, sie nicht zu verwenden: Der Kunde benötigte eine hohe Leistung, bis zu dem oben genannten Punkt, dass „300 ms für eine Anfrage viel sind“.  Und alle Pakete für Laravel wirkten wie ein zusätzlicher Aufwand und wurden langsamer.  Es hätte direkt auf Guzzle gemacht werden können, aber wir haben uns entschieden, nicht bis zum Äußersten zu gehen. <br><br>  Zunächst wurde die einfachste Suche nach Rezepten direkt auf den Arrays durchgeführt.  Ja, all dies wurde in Konfigurationsdateien übernommen, aber die Anfrage stellte sich trotzdem als zu groß heraus.  Die Suche fand in den angehängten Dokumenten (den gleichen Bestandteilen) statt, in booleschen Ausdrücken mit "sollte" und "muss" gab es auch eine Richtlinie für die obligatorische Passage in den angehängten Dokumenten - als Ergebnis nahm die Anfrage von hundert Zeilen und ihr Volumen betrug drei Kilobyte. <br><br>  Vergessen Sie nicht die Anforderungen an Geschwindigkeit und Größe der Antwort. Zu diesem Zeitpunkt wurden die Antworten in der API so formatiert, dass die Menge nützlicher Informationen erhöht wurde: Die Schlüssel in jedem JSON-Objekt wurden auf einen Buchstaben reduziert.  Abfragen in ESs von wenigen Kilobyte wurden daher zu einem inakzeptablen Luxus. <br><br>  In diesem Moment wurde uns klar, dass das Erstellen von riesigen Abfragen in Form von assoziativen Arrays in PHP eine Art heftige Sucht ist.  Außerdem wurden die Controller völlig unlesbar, überzeugen Sie sich selbst: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.ingredient_id"</span></span> =&gt; $ingredient_id]], [<span class="hljs-string"><span class="hljs-string">"range"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span>=&gt;[ <span class="hljs-string"><span class="hljs-string">"lte"</span></span>=&gt;$percent + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"gte"</span></span>=&gt;$percent - <span class="hljs-number"><span class="hljs-number">5</span></span> ]]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>] = $conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $equal_conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span> =&gt; $percent]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'must'</span></span>] = $equal_conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;client-&gt;search($parameters); }</code> </pre> <br>  Lyrischer Exkurs: Wenn es um verschachtelte Felder im Dokument ging, stellte sich heraus, dass wir eine Abfrage des Formulars nicht erfüllen können: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ ... ] } } } }</code> </pre> <br>  Aus einem einfachen Grund können Sie in einem verschachtelten Filter keine Mehrfachsuche durchführen.  Deshalb musste ich Folgendes tun: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { ... } } }} ] } }</code> </pre> <br>  d.h.  Zuerst wurde ein Array von Soll-Bedingungen deklariert, und innerhalb jeder Bedingung wurde eine Suche durch das verschachtelte Feld aufgerufen.  Aus Sicht von Elasticsearch ist dies korrekter und logischer.  Als Ergebnis haben wir selbst gesehen, dass dies logisch war, als wir zusätzliche Suchbegriffe hinzugefügt haben. <br><br>  Und hier haben wir <s>Google-</s> Vorlagen entdeckt, die in ES integriert sind.  Die Wahl fiel auf Moustache - eine ziemlich praktische logiklose Template-Engine.  Es war möglich, den gesamten Anfragetext und alle übertragenen Daten praktisch unverändert darin abzulegen, wodurch die endgültige Anforderung die Form hatte: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"template1"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: params{} }</code> </pre> <br>  Der Hauptteil der Vorlage erwies sich als eher bescheiden und lesbar - nur JSON und die Anweisungen von Moustache selbst.  Die Vorlage wird in Elasticsearch selbst gespeichert und beim Namen aufgerufen. <br><br><pre> <code class="hljs smalltalk">/* search_similar.mustache */ { <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimum_should_match"</span></span>: {{ minimumShouldMatch }}, <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientsList</span></span>}} // mustache         ingredientsList {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredients</span></span>}} //         ingredients {<span class="hljs-comment"><span class="hljs-comment">"nested"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"path"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"score_mode"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"max"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.flavor_id"</span></span>: {{ id }} }}, {<span class="hljs-comment"><span class="hljs-comment">"range"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.percent"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: {{ lte }}, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: {{ gte }} }}} ] } } }} {{^isLast}},{{/isLast}} //    {{/ingredients}} {{/ingredientsList}} ] }} ] } } } /*  */ { <span class="hljs-comment"><span class="hljs-comment">"template"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"search_similar"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"params"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimumShouldMatch"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"ingredientsList"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"isLast"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } ] } } }</code> </pre> <br>  Als Ergebnis haben wir bei der Ausgabe eine Vorlage erhalten, in die wir einfach eine Reihe der erforderlichen Zutaten übergeben haben.  Logischerweise unterschied sich die Anforderung nicht wesentlich von den folgenden Bedingungen: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ingredients <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> recipes <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipes.id = ingredient.recipe_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.percent <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">20.0</span></span></code> </pre> <br>  aber er arbeitete schneller und es war eine fertige Basis für weitere Anfragen. <br><br>  Hier brauchten wir zusätzlich zur prozentualen Suche mehrere weitere Arten von Operationen: eine Suche nach Namen unter den Zutaten, Gruppen und Namen von Rezepten;  Suche nach Zutaten-ID unter Berücksichtigung der Toleranz des Inhalts im Rezept;  die gleiche Abfrage, jedoch mit der Berechnung der Ergebnisse unter vier Bedingungen (wurde anschließend für eine andere Aufgabe wiederholt) sowie die endgültige Abfrage. <br><br>  Die Anforderung erforderte die folgende Logik: Für jede Zutat gibt es fünf Tags, die sie mit einer beliebigen Gruppe verknüpfen.  Konventionell sind Schweinefleisch und Rindfleisch Fleisch und Huhn und Pute Geflügel.  Jedes der Tags befindet sich auf einer eigenen Ebene.  Basierend auf diesen Tags konnten wir eine bedingte Beschreibung für das Rezept erstellen, mit der wir automatisch einen Suchbaum und / oder eine Beschreibung generieren konnten.  Zum Beispiel Wurstfleisch und Milch mit Gewürzen, Leber und Soja, Hühnerhalal.  Ein einzelnes Rezept kann mehrere Zutaten mit demselben Etikett enthalten.  Dies erlaubte uns, die Etikettenkette nicht mit unseren Händen zu füllen - basierend auf der Zusammensetzung des Rezepts konnten wir es bereits klar beschreiben.  Die Struktur des angehängten Dokuments hat sich ebenfalls geändert: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"level_1"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"level_2"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"level_3"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"level_4"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-string"><span class="hljs-string">"level_5"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre> <br>  Es bestand auch die Notwendigkeit, eine Suche nach der Bedingung der „Reinheit“ des Rezepts anzugeben.  Zum Beispiel brauchten wir ein Rezept, bei dem es nur Rindfleisch, Salz und Pfeffer gab.  Dann mussten wir Rezepte aussortieren, bei denen sich nur Rindfleisch auf der ersten Ebene und nur Gewürze auf der zweiten Ebene befanden (das erste Etikett für Gewürze war Null).  Hier musste ich schummeln: Da Schnurrbart eine Vorlage ohne Logik ist, konnte von keiner Berechnung die Rede sein;  Hier musste ein Teil des Skripts in der Anforderung in der ES-Skriptsprache - Painless - implementiert werden.  Die Syntax ist so nah wie möglich an Java, daher gab es keine Schwierigkeiten.  Als Ergebnis hatten wir eine Moustache-Vorlage, die JSON generierte, in der ein Teil der Berechnungen, nämlich Sortieren und Filtern, auf Painless implementiert wurde: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levelsList}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levels}}</span></span><span class="xml"><span class="xml"> {"script": { "script": " int total=0; for (ingredient in params._source.ingredients){ if ([0,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tag}}</span></span><span class="xml"><span class="xml">].contains(ingredient.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{id}}</span></span><span class="xml"><span class="xml">)) total+=1; } return (total==params._source.ingredients.length); " }} </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levels}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levelsList}}</span></span><span class="xml"><span class="xml"> ]</span></span></code> </pre><br>  Im Folgenden wird der Hauptteil des Skripts zur besseren Lesbarkeit formatiert. Zeilenumbrüche können in Anforderungen nicht verwendet werden. <br><br>  Zu diesem Zeitpunkt haben wir die Toleranz für den Inhalt der Zutat aufgehoben und einen Engpass festgestellt - wir könnten Rindfleischwurst nur in Betracht ziehen, weil diese Zutat dort gefunden wird.  Dann fügten wir - alle in denselben schmerzlosen Skripten - Filter hinzu, unter der Bedingung, dass diese Zutat in der Komposition Vorrang haben sollte: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ {"script":{ "script": " double nest=0,rest=0; for (ingredient in params._source.ingredients){ if([</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#tags}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{tagId}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{/tags}}</span></span><span class="xml"><span class="xml">].contains(flavor.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tags.0.levelId}}</span></span><span class="xml"><span class="xml">)){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){rest = ingredient.percent} } } return(nest&gt;=rest); " }} ]</span></span></code> </pre> <br>  Wie Sie sehen, fehlten Elasticsearch viele Dinge für dieses Projekt, so dass sie aus „verfügbaren Mitteln“ zusammengesetzt werden mussten.  Dies ist jedoch nicht überraschend - das Projekt ist untypisch genug für eine Maschine, die für die Volltextsuche verwendet wird. <br><br>  In einer der Zwischenphasen des Projekts brauchten wir Folgendes: Zeigen Sie eine Liste aller verfügbaren Gruppen von Zutaten und die Anzahl der Positionen in jeder an.  Hier zeigte sich das gleiche Problem wie in der vorherrschenden Abfrage: Aus 10.000 Rezepten wurden basierend auf dem Inhalt etwa 10 Gruppen generiert.  Es stellte sich jedoch heraus, dass sich in diesen Gruppen insgesamt etwa 40.000 Rezepte befanden, die überhaupt nicht der Realität entsprachen.  Dann begannen wir, nach parallelen Abfragen zu suchen. <br><br>  Bei der ersten Anfrage haben wir eine Liste aller Gruppen erhalten, die sich auf der ersten Ebene ohne die Anzahl der Einträge befinden.  Danach wurde eine Mehrfachanfrage generiert: Für jede Gruppe wurde eine Anfrage gestellt, um die tatsächliche Anzahl von Rezepten nach dem Prinzip des vorherrschenden Prozentsatzes zu erhalten.  Alle diese Anfragen wurden in einer gesammelt und an Elasticsearch gesendet.  Die Antwortzeit für die allgemeine Anforderung entsprach der Verarbeitungszeit der langsamsten Anforderung.  Die Massenaggregation ermöglichte die Parallelisierung.  Eine ähnliche Logik (nur durch Gruppieren nach Bedingungen in einer Abfrage) in SQL dauerte etwa 15-mal länger. <br><br><pre> <code class="hljs markdown">/<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/ $params = config('elastic.params'); $params[<span class="hljs-string"><span class="hljs-string">'body'</span></span>] = config('elastic.top_list'); return (Elastic::getClient()-&gt;search($params))[<span class="hljs-string"><span class="hljs-string">'aggregations'</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">'tags'</span></span>][<span class="hljs-string"><span class="hljs-string">'buckets'</span></span>]; /<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/</code> </pre><br>  Danach mussten wir bewerten: <br><br><ol><li>  Wie viele Rezepte sind für die aktuelle Komposition verfügbar? </li><li>  Welche anderen Zutaten können wir der Zusammensetzung hinzufügen (manchmal haben wir die Zutat hinzugefügt und eine leere Probe erhalten); </li><li>  Welche Zutaten unter den ausgewählten können wir als die einzigen auf dieser Ebene markieren? </li></ol><br>  Basierend auf der Aufgabe haben wir die Logik der letzten für die Rezeptliste empfangenen Anforderung und die Logik des Erhaltens genauer Zahlen aus der Liste aller verfügbaren Gruppen kombiniert: <br><br><pre> <code class="hljs smalltalk">/*  */ <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { //      <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ //    <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } //    ,    } } /*   */ foreach (<span class="hljs-string"><span class="hljs-string">$n</span></span>ot_only as <span class="hljs-string"><span class="hljs-string">$e</span></span>lement) { <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, collect(<span class="hljs-string"><span class="hljs-string">$o</span></span>nly-&gt;all())-&gt;push(<span class="hljs-string"><span class="hljs-string">$e</span></span>lement), <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); } /*   */ <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, <span class="hljs-string"><span class="hljs-string">$o</span></span>nly, <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-string"><span class="hljs-string">$f</span></span>rom, <span class="hljs-string"><span class="hljs-string">$s</span></span>ize<span class="hljs-string"><span class="hljs-string">') ); /*     */ $parameters['</span></span>max_concurrent_searches<span class="hljs-string"><span class="hljs-string">'] = 1 + $not_only-&gt;count(); return (Elastic::getClient()-&gt;msearchTemplate($parameters))['</span></span>responses<span class="hljs-string"><span class="hljs-string">'];</span></span></code> </pre> <br>  Als Ergebnis haben wir eine Anfrage erhalten, die alle erforderlichen Rezepte und deren Gesamtzahl findet (sie wurde aus der Antwort ["Treffer"] ["Gesamt"] entnommen).  Der Einfachheit halber wurde diese Anfrage an letzter Stelle in der Liste aufgezeichnet. <br><br>  Zusätzlich haben wir durch Aggregation alle ID-Zutaten für das nächste Level erhalten.  Für jede der Zutaten, die nicht als "eindeutig" gekennzeichnet waren, haben wir eine Abfrage erstellt, in der wir sie entsprechend gekennzeichnet haben, und dann einfach die Anzahl der gefundenen Dokumente gezählt.  Wenn es größer als Null war, wurde die Zutat als verfügbar für die Zuweisung des Schlüssels "einzeln" angesehen.  Ich denke hier können Sie die gesamte Vorlage ohne mich wiederherstellen, die wir bei der Ausgabe erhalten haben: <br><br><pre> <code class="hljs smalltalk">{ <span class="hljs-comment"><span class="hljs-comment">"from"</span></span>: {{ from }}, <span class="hljs-comment"><span class="hljs-comment">"size"</span></span>: {{ size }}, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientTags</span></span>}} {{<span class="hljs-symbol"><span class="hljs-symbol">#tagList</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"level_{{ levelId }}"</span></span>: {{ tagId }} }} ] }} {{^isLast}},{{/isLast}} {{/tagList}} {{/ingredientTags}} ], <span class="hljs-comment"><span class="hljs-comment">"filter"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>:{ <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" double nest=0,rest=0; for(ingredient in params._source. ingredients){ if([{{#tags}}{{tagId}}{{^isLast}},{{/isLast}}{{/tags}}].contains(ingredient.level_{{tags.0.levelId}})){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){ rest= ingredient.percent } } } return(nest&gt;=rest); "</span></span> }} {{<span class="hljs-symbol"><span class="hljs-symbol">#levelsList</span></span>}}, {{<span class="hljs-symbol"><span class="hljs-symbol">#levels</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" int total=0; for(ingredient in params._source.ingredients){ if ([0,{{tag}}].contains(ingredient.level_{{id}})) total+=1; } return (total==params._source.ingredients.length); "</span></span> }} {{^isLast}},{{/isLast}} {{/levels}} {{/levelsList}} ] } }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } } }, <span class="hljs-comment"><span class="hljs-comment">"sort"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"_score"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"order"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"desc"</span></span>}} ] }</code> </pre><br>  Natürlich speichern wir einen Teil dieses Haufens von Vorlagen und Abfragen zwischen (z. B. die Seite aller verfügbaren Gruppen mit der Anzahl der verfügbaren Rezepte), wodurch wir auf der Hauptseite ein wenig Leistung erzielen.  Diese Entscheidung ermöglichte es, die Hauptdaten in 50 ms zu erfassen. <br><br>  <b>Projektergebnisse</b> <br><br>  Wir haben eine Suche in der Datenbank von mindestens 50.000 Dokumenten auf Elasticsearch durchgeführt, mit der Sie nach Inhaltsstoffen in Produkten suchen und eine Beschreibung des Produkts anhand der darin enthaltenen Inhaltsstoffe erhalten können.  Bald wird diese Datenbank um das Sechsfache wachsen (die Daten werden vorbereitet), daher sind wir mit unseren Ergebnissen und Elasticsearch als Suchwerkzeug sehr zufrieden. <br><br>  In Bezug auf die Leistung haben wir die Anforderungen des Projekts erfüllt und freuen uns, dass die durchschnittliche Antwortzeit auf eine Anfrage 250-300 ms beträgt. <br><br>  Drei Monate nach Beginn der Arbeit mit Elasticsearch wirkt dies nicht mehr so ​​verwirrend und ungewöhnlich.  Die Vorteile des Templating liegen auf der Hand: Wenn wir feststellen, dass die Anforderung erneut zu groß wird, übertragen wir einfach die zusätzliche Logik auf die Vorlage und senden die ursprüngliche Anforderung fast unverändert erneut an den Server. <br><br>  "Alles Gute und danke für den Fisch!"  (c) <br><br>  <b>PS</b> Im letzten Moment mussten wir auch nach russischen Zeichen im Namen sortieren.  Und dann stellte sich heraus, dass Elasticsearch das russische Alphabet nicht angemessen wahrnimmt.  Die bedingte Wurst „Ultra Mega Pork 9000 Kalorien“ verwandelte sich innerhalb der Sortierung einfach in „9000“ und stand am Ende der Liste.  Wie sich herausstellte, lässt sich dieses Problem leicht lösen, indem russische Zeichen in die Unicode-Notation der Form u042B konvertiert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413075/">https://habr.com/ru/post/de413075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413063/index.html">Testen eines hausgemachten Thermobechers an einem Phasenübergang</a></li>
<li><a href="../de413065/index.html">Geplante neue Funktionen in C # 8.0</a></li>
<li><a href="../de413069/index.html">Audiosuche, Audio-SEO und Hilfe für Podcasts - Google-Spezialisten arbeiten bereits daran</a></li>
<li><a href="../de413071/index.html">DeepMind brachte AI bei, YouTube-Videospiele zu spielen</a></li>
<li><a href="../de413073/index.html">So arbeiten Sie mit der Cloud: 30 Materialien, praktische Anleitungen und Tipps zum Thema PD, IS und IaaS</a></li>
<li><a href="../de413077/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 255 (28. Mai - 3. Juni)</a></li>
<li><a href="../de413083/index.html">Entwickler vom MIT erstellen eine bionische Prothese mit präziser Bewegungskoordination</a></li>
<li><a href="../de413087/index.html">Mann Autoassistent</a></li>
<li><a href="../de413091/index.html">Bequeme Protokollierung in SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../de413093/index.html">In Erwartung des Rennens der Weltraumhändler in den USA und in China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>