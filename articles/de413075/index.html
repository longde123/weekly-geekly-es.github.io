<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåâ ü§µüèº üéª Volltextsuche: Elasticsearch-spezifische Funktionen f√ºr komplexe Aufgaben üéÆ üçç üßëüèΩ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, mein Name ist Andrey und ich bin Entwickler. Vor langer Zeit - anscheinend letzten Freitag - hatte unser Team ein Projekt, bei dem n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volltextsuche: Elasticsearch-spezifische Funktionen f√ºr komplexe Aufgaben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413075/"><img src="https://habrastorage.org/webt/yb/hh/1r/ybhh1rxmqt9yswla3tfbiexyluo.png" alt="Bild"><br><br>  Hallo allerseits, mein Name ist Andrey und ich bin Entwickler.  Vor langer Zeit - anscheinend letzten Freitag - hatte unser Team ein Projekt, bei dem nach den Zutaten gesucht werden musste, aus denen die Produkte bestehen.  Sagen wir die Zusammensetzung der Wurst.  Zu Beginn des Projekts war bei der Suche nicht viel erforderlich: Alle Rezepte anzuzeigen, in denen die gew√ºnschte Zutat in einer bestimmten Menge enthalten ist;  Wiederholen Sie dies f√ºr N Zutaten. <br><a name="habracut"></a><br>  In Zukunft sollte die Anzahl der Produkte und Inhaltsstoffe jedoch erheblich erh√∂ht werden, und die Suche sollte nicht nur dem zunehmenden Datenvolumen gerecht werden, sondern auch zus√§tzliche Optionen bieten - beispielsweise die automatische Erstellung einer Produktbeschreibung auf der Grundlage der vorherrschenden Inhaltsstoffe. <br><br>  <b>Anforderungen</b> <br><br><ul><li>  Erstellen Sie eine Suche in Elacsticsearch mit einer Datenbank von mindestens 50.000 Dokumenten. </li><li>  Bieten Sie eine schnelle Antwort auf Anfragen - weniger als 300 ms. </li><li>  Um sicherzustellen, dass die Anfragen klein waren und der Dienst auch unter den Bedingungen des schlechtesten mobilen Internets verf√ºgbar war. </li><li>  Machen Sie die Suchlogik aus UX-Sicht so intuitiv wie m√∂glich.  Es war im Wesentlichen so, dass die Schnittstelle die Suchlogik widerspiegeln w√ºrde - und umgekehrt. </li><li>  Minimieren Sie die Anzahl der Zwischenschichten zwischen Systemelementen, um eine h√∂here Leistung und weniger Abh√§ngigkeiten zu erzielen. </li><li>  Sie k√∂nnen jederzeit die M√∂glichkeit bieten, den Algorithmus durch neue Bedingungen zu erg√§nzen (z. B. automatische Generierung einer Produktbeschreibung). </li><li>  Machen Sie die weitere Unterst√ºtzung f√ºr den Suchteil des Projekts so einfach und bequem wie m√∂glich. </li></ul><br>  Wir beschlossen, uns nicht zu beeilen und einfach anzufangen. <br><br>  Zun√§chst haben wir alle Inhaltsstoffe der Produktzusammensetzung in einer Datenbank gespeichert, nachdem wir zun√§chst 10.000 Eintr√§ge erhalten hatten.  Leider hat das Durchsuchen der Datenbank selbst bei dieser Gr√∂√üe zu viel Zeit in Anspruch genommen, selbst unter Ber√ºcksichtigung der Verwendung von Joins und Indizes.  Und in naher Zukunft sollte die Anzahl der Datens√§tze 50.000 √ºberschritten haben. Dar√ºber hinaus bestand der Kunde darauf, Elasticsearch (im Folgenden: ES) zu verwenden, da er auf dieses Tool stie√ü und anscheinend ein warmes Gef√ºhl f√ºr ihn hatte.  Wir haben vorher nicht mit ES gearbeitet, aber wir wussten um die Vorteile und stimmten dieser Wahl zu, da beispielsweise geplant war, dass wir h√§ufig neue Eintr√§ge haben (nach verschiedenen Sch√§tzungen von 50 bis 500 pro Tag), die notwendig w√§ren sofort an den Benutzer weitergeben. <br><br>  Wir haben uns entschieden, Interlayer auf Treiberebene aufzugeben und einfach REST-Anforderungen zu verwenden, da die Synchronisierung mit der Datenbank nur zum Zeitpunkt der Erstellung des Dokuments erfolgt und nicht mehr ben√∂tigt wird.  Dies war ein weiterer Vorteil - bis zum direkten Senden von Suchanfragen von einem Browser an ES. <br><br>  Wir haben den ersten Prototyp zusammengestellt, in dem wir die Struktur aus einer Datenbank (PostgreSQL) in ES-Dokumente √ºbertragen haben: <br><br><pre><code class="php hljs">{<span class="hljs-string"><span class="hljs-string">"mappings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_source"</span></span> : { <span class="hljs-string"><span class="hljs-string">"enabled"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"integer"</span></span>}, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"text"</span></span>}, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"nested"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-string"><span class="hljs-string">"float"</span></span> } } } } }}</code> </pre> <br>  Basierend auf dieser Zuordnung erhalten wir ungef√§hr das folgende Dokument (wir k√∂nnen den Mitarbeiter aufgrund der NDA nicht aus dem Projekt anzeigen): <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA &amp; BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 4"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } ] }</code> </pre> <br>  All dies wurde mit dem Elasticsearch PHP-Paket durchgef√ºhrt.  Erweiterungen f√ºr Laravel (Elastiquent, Laravel Scout usw.) haben sich aus einem Grund entschieden, sie nicht zu verwenden: Der Kunde ben√∂tigte eine hohe Leistung, bis zu dem oben genannten Punkt, dass ‚Äû300 ms f√ºr eine Anfrage viel sind‚Äú.  Und alle Pakete f√ºr Laravel wirkten wie ein zus√§tzlicher Aufwand und wurden langsamer.  Es h√§tte direkt auf Guzzle gemacht werden k√∂nnen, aber wir haben uns entschieden, nicht bis zum √Ñu√üersten zu gehen. <br><br>  Zun√§chst wurde die einfachste Suche nach Rezepten direkt auf den Arrays durchgef√ºhrt.  Ja, all dies wurde in Konfigurationsdateien √ºbernommen, aber die Anfrage stellte sich trotzdem als zu gro√ü heraus.  Die Suche fand in den angeh√§ngten Dokumenten (den gleichen Bestandteilen) statt, in booleschen Ausdr√ºcken mit "sollte" und "muss" gab es auch eine Richtlinie f√ºr die obligatorische Passage in den angeh√§ngten Dokumenten - als Ergebnis nahm die Anfrage von hundert Zeilen und ihr Volumen betrug drei Kilobyte. <br><br>  Vergessen Sie nicht die Anforderungen an Geschwindigkeit und Gr√∂√üe der Antwort. Zu diesem Zeitpunkt wurden die Antworten in der API so formatiert, dass die Menge n√ºtzlicher Informationen erh√∂ht wurde: Die Schl√ºssel in jedem JSON-Objekt wurden auf einen Buchstaben reduziert.  Abfragen in ESs von wenigen Kilobyte wurden daher zu einem inakzeptablen Luxus. <br><br>  In diesem Moment wurde uns klar, dass das Erstellen von riesigen Abfragen in Form von assoziativen Arrays in PHP eine Art heftige Sucht ist.  Au√üerdem wurden die Controller v√∂llig unlesbar, √ºberzeugen Sie sich selbst: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.ingredient_id"</span></span> =&gt; $ingredient_id]], [<span class="hljs-string"><span class="hljs-string">"range"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span>=&gt;[ <span class="hljs-string"><span class="hljs-string">"lte"</span></span>=&gt;$percent + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"gte"</span></span>=&gt;$percent - <span class="hljs-number"><span class="hljs-number">5</span></span> ]]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>] = $conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $equal_conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span> =&gt; $percent]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'must'</span></span>] = $equal_conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;client-&gt;search($parameters); }</code> </pre> <br>  Lyrischer Exkurs: Wenn es um verschachtelte Felder im Dokument ging, stellte sich heraus, dass wir eine Abfrage des Formulars nicht erf√ºllen k√∂nnen: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ ... ] } } } }</code> </pre> <br>  Aus einem einfachen Grund k√∂nnen Sie in einem verschachtelten Filter keine Mehrfachsuche durchf√ºhren.  Deshalb musste ich Folgendes tun: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { ... } } }} ] } }</code> </pre> <br>  d.h.  Zuerst wurde ein Array von Soll-Bedingungen deklariert, und innerhalb jeder Bedingung wurde eine Suche durch das verschachtelte Feld aufgerufen.  Aus Sicht von Elasticsearch ist dies korrekter und logischer.  Als Ergebnis haben wir selbst gesehen, dass dies logisch war, als wir zus√§tzliche Suchbegriffe hinzugef√ºgt haben. <br><br>  Und hier haben wir <s>Google-</s> Vorlagen entdeckt, die in ES integriert sind.  Die Wahl fiel auf Moustache - eine ziemlich praktische logiklose Template-Engine.  Es war m√∂glich, den gesamten Anfragetext und alle √ºbertragenen Daten praktisch unver√§ndert darin abzulegen, wodurch die endg√ºltige Anforderung die Form hatte: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"template1"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: params{} }</code> </pre> <br>  Der Hauptteil der Vorlage erwies sich als eher bescheiden und lesbar - nur JSON und die Anweisungen von Moustache selbst.  Die Vorlage wird in Elasticsearch selbst gespeichert und beim Namen aufgerufen. <br><br><pre> <code class="hljs smalltalk">/* search_similar.mustache */ { <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimum_should_match"</span></span>: {{ minimumShouldMatch }}, <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientsList</span></span>}} // mustache         ingredientsList {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredients</span></span>}} //         ingredients {<span class="hljs-comment"><span class="hljs-comment">"nested"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"path"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"score_mode"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"max"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.flavor_id"</span></span>: {{ id }} }}, {<span class="hljs-comment"><span class="hljs-comment">"range"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.percent"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: {{ lte }}, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: {{ gte }} }}} ] } } }} {{^isLast}},{{/isLast}} //    {{/ingredients}} {{/ingredientsList}} ] }} ] } } } /*  */ { <span class="hljs-comment"><span class="hljs-comment">"template"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"search_similar"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"params"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimumShouldMatch"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"ingredientsList"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"isLast"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } ] } } }</code> </pre> <br>  Als Ergebnis haben wir bei der Ausgabe eine Vorlage erhalten, in die wir einfach eine Reihe der erforderlichen Zutaten √ºbergeben haben.  Logischerweise unterschied sich die Anforderung nicht wesentlich von den folgenden Bedingungen: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ingredients <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> recipes <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipes.id = ingredient.recipe_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.percent <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">20.0</span></span></code> </pre> <br>  aber er arbeitete schneller und es war eine fertige Basis f√ºr weitere Anfragen. <br><br>  Hier brauchten wir zus√§tzlich zur prozentualen Suche mehrere weitere Arten von Operationen: eine Suche nach Namen unter den Zutaten, Gruppen und Namen von Rezepten;  Suche nach Zutaten-ID unter Ber√ºcksichtigung der Toleranz des Inhalts im Rezept;  die gleiche Abfrage, jedoch mit der Berechnung der Ergebnisse unter vier Bedingungen (wurde anschlie√üend f√ºr eine andere Aufgabe wiederholt) sowie die endg√ºltige Abfrage. <br><br>  Die Anforderung erforderte die folgende Logik: F√ºr jede Zutat gibt es f√ºnf Tags, die sie mit einer beliebigen Gruppe verkn√ºpfen.  Konventionell sind Schweinefleisch und Rindfleisch Fleisch und Huhn und Pute Gefl√ºgel.  Jedes der Tags befindet sich auf einer eigenen Ebene.  Basierend auf diesen Tags konnten wir eine bedingte Beschreibung f√ºr das Rezept erstellen, mit der wir automatisch einen Suchbaum und / oder eine Beschreibung generieren konnten.  Zum Beispiel Wurstfleisch und Milch mit Gew√ºrzen, Leber und Soja, H√ºhnerhalal.  Ein einzelnes Rezept kann mehrere Zutaten mit demselben Etikett enthalten.  Dies erlaubte uns, die Etikettenkette nicht mit unseren H√§nden zu f√ºllen - basierend auf der Zusammensetzung des Rezepts konnten wir es bereits klar beschreiben.  Die Struktur des angeh√§ngten Dokuments hat sich ebenfalls ge√§ndert: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"level_1"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"level_2"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"level_3"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"level_4"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-string"><span class="hljs-string">"level_5"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre> <br>  Es bestand auch die Notwendigkeit, eine Suche nach der Bedingung der ‚ÄûReinheit‚Äú des Rezepts anzugeben.  Zum Beispiel brauchten wir ein Rezept, bei dem es nur Rindfleisch, Salz und Pfeffer gab.  Dann mussten wir Rezepte aussortieren, bei denen sich nur Rindfleisch auf der ersten Ebene und nur Gew√ºrze auf der zweiten Ebene befanden (das erste Etikett f√ºr Gew√ºrze war Null).  Hier musste ich schummeln: Da Schnurrbart eine Vorlage ohne Logik ist, konnte von keiner Berechnung die Rede sein;  Hier musste ein Teil des Skripts in der Anforderung in der ES-Skriptsprache - Painless - implementiert werden.  Die Syntax ist so nah wie m√∂glich an Java, daher gab es keine Schwierigkeiten.  Als Ergebnis hatten wir eine Moustache-Vorlage, die JSON generierte, in der ein Teil der Berechnungen, n√§mlich Sortieren und Filtern, auf Painless implementiert wurde: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levelsList}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levels}}</span></span><span class="xml"><span class="xml"> {"script": { "script": " int total=0; for (ingredient in params._source.ingredients){ if ([0,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tag}}</span></span><span class="xml"><span class="xml">].contains(ingredient.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{id}}</span></span><span class="xml"><span class="xml">)) total+=1; } return (total==params._source.ingredients.length); " }} </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levels}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levelsList}}</span></span><span class="xml"><span class="xml"> ]</span></span></code> </pre><br>  Im Folgenden wird der Hauptteil des Skripts zur besseren Lesbarkeit formatiert. Zeilenumbr√ºche k√∂nnen in Anforderungen nicht verwendet werden. <br><br>  Zu diesem Zeitpunkt haben wir die Toleranz f√ºr den Inhalt der Zutat aufgehoben und einen Engpass festgestellt - wir k√∂nnten Rindfleischwurst nur in Betracht ziehen, weil diese Zutat dort gefunden wird.  Dann f√ºgten wir - alle in denselben schmerzlosen Skripten - Filter hinzu, unter der Bedingung, dass diese Zutat in der Komposition Vorrang haben sollte: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ {"script":{ "script": " double nest=0,rest=0; for (ingredient in params._source.ingredients){ if([</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#tags}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{tagId}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{/tags}}</span></span><span class="xml"><span class="xml">].contains(flavor.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tags.0.levelId}}</span></span><span class="xml"><span class="xml">)){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){rest = ingredient.percent} } } return(nest&gt;=rest); " }} ]</span></span></code> </pre> <br>  Wie Sie sehen, fehlten Elasticsearch viele Dinge f√ºr dieses Projekt, so dass sie aus ‚Äûverf√ºgbaren Mitteln‚Äú zusammengesetzt werden mussten.  Dies ist jedoch nicht √ºberraschend - das Projekt ist untypisch genug f√ºr eine Maschine, die f√ºr die Volltextsuche verwendet wird. <br><br>  In einer der Zwischenphasen des Projekts brauchten wir Folgendes: Zeigen Sie eine Liste aller verf√ºgbaren Gruppen von Zutaten und die Anzahl der Positionen in jeder an.  Hier zeigte sich das gleiche Problem wie in der vorherrschenden Abfrage: Aus 10.000 Rezepten wurden basierend auf dem Inhalt etwa 10 Gruppen generiert.  Es stellte sich jedoch heraus, dass sich in diesen Gruppen insgesamt etwa 40.000 Rezepte befanden, die √ºberhaupt nicht der Realit√§t entsprachen.  Dann begannen wir, nach parallelen Abfragen zu suchen. <br><br>  Bei der ersten Anfrage haben wir eine Liste aller Gruppen erhalten, die sich auf der ersten Ebene ohne die Anzahl der Eintr√§ge befinden.  Danach wurde eine Mehrfachanfrage generiert: F√ºr jede Gruppe wurde eine Anfrage gestellt, um die tats√§chliche Anzahl von Rezepten nach dem Prinzip des vorherrschenden Prozentsatzes zu erhalten.  Alle diese Anfragen wurden in einer gesammelt und an Elasticsearch gesendet.  Die Antwortzeit f√ºr die allgemeine Anforderung entsprach der Verarbeitungszeit der langsamsten Anforderung.  Die Massenaggregation erm√∂glichte die Parallelisierung.  Eine √§hnliche Logik (nur durch Gruppieren nach Bedingungen in einer Abfrage) in SQL dauerte etwa 15-mal l√§nger. <br><br><pre> <code class="hljs markdown">/<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/ $params = config('elastic.params'); $params[<span class="hljs-string"><span class="hljs-string">'body'</span></span>] = config('elastic.top_list'); return (Elastic::getClient()-&gt;search($params))[<span class="hljs-string"><span class="hljs-string">'aggregations'</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">'tags'</span></span>][<span class="hljs-string"><span class="hljs-string">'buckets'</span></span>]; /<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/</code> </pre><br>  Danach mussten wir bewerten: <br><br><ol><li>  Wie viele Rezepte sind f√ºr die aktuelle Komposition verf√ºgbar? </li><li>  Welche anderen Zutaten k√∂nnen wir der Zusammensetzung hinzuf√ºgen (manchmal haben wir die Zutat hinzugef√ºgt und eine leere Probe erhalten); </li><li>  Welche Zutaten unter den ausgew√§hlten k√∂nnen wir als die einzigen auf dieser Ebene markieren? </li></ol><br>  Basierend auf der Aufgabe haben wir die Logik der letzten f√ºr die Rezeptliste empfangenen Anforderung und die Logik des Erhaltens genauer Zahlen aus der Liste aller verf√ºgbaren Gruppen kombiniert: <br><br><pre> <code class="hljs smalltalk">/*  */ <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { //      <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ //    <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } //    ,    } } /*   */ foreach (<span class="hljs-string"><span class="hljs-string">$n</span></span>ot_only as <span class="hljs-string"><span class="hljs-string">$e</span></span>lement) { <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, collect(<span class="hljs-string"><span class="hljs-string">$o</span></span>nly-&gt;all())-&gt;push(<span class="hljs-string"><span class="hljs-string">$e</span></span>lement), <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); } /*   */ <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, <span class="hljs-string"><span class="hljs-string">$o</span></span>nly, <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-string"><span class="hljs-string">$f</span></span>rom, <span class="hljs-string"><span class="hljs-string">$s</span></span>ize<span class="hljs-string"><span class="hljs-string">') ); /*     */ $parameters['</span></span>max_concurrent_searches<span class="hljs-string"><span class="hljs-string">'] = 1 + $not_only-&gt;count(); return (Elastic::getClient()-&gt;msearchTemplate($parameters))['</span></span>responses<span class="hljs-string"><span class="hljs-string">'];</span></span></code> </pre> <br>  Als Ergebnis haben wir eine Anfrage erhalten, die alle erforderlichen Rezepte und deren Gesamtzahl findet (sie wurde aus der Antwort ["Treffer"] ["Gesamt"] entnommen).  Der Einfachheit halber wurde diese Anfrage an letzter Stelle in der Liste aufgezeichnet. <br><br>  Zus√§tzlich haben wir durch Aggregation alle ID-Zutaten f√ºr das n√§chste Level erhalten.  F√ºr jede der Zutaten, die nicht als "eindeutig" gekennzeichnet waren, haben wir eine Abfrage erstellt, in der wir sie entsprechend gekennzeichnet haben, und dann einfach die Anzahl der gefundenen Dokumente gez√§hlt.  Wenn es gr√∂√üer als Null war, wurde die Zutat als verf√ºgbar f√ºr die Zuweisung des Schl√ºssels "einzeln" angesehen.  Ich denke hier k√∂nnen Sie die gesamte Vorlage ohne mich wiederherstellen, die wir bei der Ausgabe erhalten haben: <br><br><pre> <code class="hljs smalltalk">{ <span class="hljs-comment"><span class="hljs-comment">"from"</span></span>: {{ from }}, <span class="hljs-comment"><span class="hljs-comment">"size"</span></span>: {{ size }}, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientTags</span></span>}} {{<span class="hljs-symbol"><span class="hljs-symbol">#tagList</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"level_{{ levelId }}"</span></span>: {{ tagId }} }} ] }} {{^isLast}},{{/isLast}} {{/tagList}} {{/ingredientTags}} ], <span class="hljs-comment"><span class="hljs-comment">"filter"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>:{ <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" double nest=0,rest=0; for(ingredient in params._source. ingredients){ if([{{#tags}}{{tagId}}{{^isLast}},{{/isLast}}{{/tags}}].contains(ingredient.level_{{tags.0.levelId}})){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){ rest= ingredient.percent } } } return(nest&gt;=rest); "</span></span> }} {{<span class="hljs-symbol"><span class="hljs-symbol">#levelsList</span></span>}}, {{<span class="hljs-symbol"><span class="hljs-symbol">#levels</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" int total=0; for(ingredient in params._source.ingredients){ if ([0,{{tag}}].contains(ingredient.level_{{id}})) total+=1; } return (total==params._source.ingredients.length); "</span></span> }} {{^isLast}},{{/isLast}} {{/levels}} {{/levelsList}} ] } }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } } }, <span class="hljs-comment"><span class="hljs-comment">"sort"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"_score"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"order"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"desc"</span></span>}} ] }</code> </pre><br>  Nat√ºrlich speichern wir einen Teil dieses Haufens von Vorlagen und Abfragen zwischen (z. B. die Seite aller verf√ºgbaren Gruppen mit der Anzahl der verf√ºgbaren Rezepte), wodurch wir auf der Hauptseite ein wenig Leistung erzielen.  Diese Entscheidung erm√∂glichte es, die Hauptdaten in 50 ms zu erfassen. <br><br>  <b>Projektergebnisse</b> <br><br>  Wir haben eine Suche in der Datenbank von mindestens 50.000 Dokumenten auf Elasticsearch durchgef√ºhrt, mit der Sie nach Inhaltsstoffen in Produkten suchen und eine Beschreibung des Produkts anhand der darin enthaltenen Inhaltsstoffe erhalten k√∂nnen.  Bald wird diese Datenbank um das Sechsfache wachsen (die Daten werden vorbereitet), daher sind wir mit unseren Ergebnissen und Elasticsearch als Suchwerkzeug sehr zufrieden. <br><br>  In Bezug auf die Leistung haben wir die Anforderungen des Projekts erf√ºllt und freuen uns, dass die durchschnittliche Antwortzeit auf eine Anfrage 250-300 ms betr√§gt. <br><br>  Drei Monate nach Beginn der Arbeit mit Elasticsearch wirkt dies nicht mehr so ‚Äã‚Äãverwirrend und ungew√∂hnlich.  Die Vorteile des Templating liegen auf der Hand: Wenn wir feststellen, dass die Anforderung erneut zu gro√ü wird, √ºbertragen wir einfach die zus√§tzliche Logik auf die Vorlage und senden die urspr√ºngliche Anforderung fast unver√§ndert erneut an den Server. <br><br>  "Alles Gute und danke f√ºr den Fisch!"  (c) <br><br>  <b>PS</b> Im letzten Moment mussten wir auch nach russischen Zeichen im Namen sortieren.  Und dann stellte sich heraus, dass Elasticsearch das russische Alphabet nicht angemessen wahrnimmt.  Die bedingte Wurst ‚ÄûUltra Mega Pork 9000 Kalorien‚Äú verwandelte sich innerhalb der Sortierung einfach in ‚Äû9000‚Äú und stand am Ende der Liste.  Wie sich herausstellte, l√§sst sich dieses Problem leicht l√∂sen, indem russische Zeichen in die Unicode-Notation der Form u042B konvertiert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413075/">https://habr.com/ru/post/de413075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413063/index.html">Testen eines hausgemachten Thermobechers an einem Phasen√ºbergang</a></li>
<li><a href="../de413065/index.html">Geplante neue Funktionen in C # 8.0</a></li>
<li><a href="../de413069/index.html">Audiosuche, Audio-SEO und Hilfe f√ºr Podcasts - Google-Spezialisten arbeiten bereits daran</a></li>
<li><a href="../de413071/index.html">DeepMind brachte AI bei, YouTube-Videospiele zu spielen</a></li>
<li><a href="../de413073/index.html">So arbeiten Sie mit der Cloud: 30 Materialien, praktische Anleitungen und Tipps zum Thema PD, IS und IaaS</a></li>
<li><a href="../de413077/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 255 (28. Mai - 3. Juni)</a></li>
<li><a href="../de413083/index.html">Entwickler vom MIT erstellen eine bionische Prothese mit pr√§ziser Bewegungskoordination</a></li>
<li><a href="../de413087/index.html">Mann Autoassistent</a></li>
<li><a href="../de413091/index.html">Bequeme Protokollierung in SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../de413093/index.html">In Erwartung des Rennens der Weltraumh√§ndler in den USA und in China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>