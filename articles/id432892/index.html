<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎈 👩🏻‍🚒 🕺🏻 Pencarian Anda kembali: implementasi pencarian fuzzy ⚽️ 👩🏻‍⚕️ ▪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua membuat kesalahan: dalam hal ini kita berbicara tentang permintaan pencarian. Jumlah situs untuk penjualan barang dan jasa semakin meningka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pencarian Anda kembali: implementasi pencarian fuzzy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432892/">  Kita semua membuat kesalahan: dalam hal ini kita berbicara tentang permintaan pencarian.  Jumlah situs untuk penjualan barang dan jasa semakin meningkat seiring dengan kebutuhan pengguna, tetapi mereka tidak selalu dapat menemukan apa yang mereka cari - hanya karena mereka salah memasukkan nama produk yang diperlukan.  Solusi untuk masalah ini dicapai dengan menerapkan pencarian fuzzy, yaitu menggunakan algoritma untuk menemukan nilai terdekat, dengan mempertimbangkan kemungkinan kesalahan atau kesalahan ketik pengguna.  Cakupan pencarian semacam itu cukup luas - kami berhasil mengerjakan pencarian untuk toko online besar di segmen ritel makanan. <br><a name="habracut"></a><br>
<h3>  Status Pencarian Awal </h3><br>  Toko online dikembangkan pada platform 1C-Bitrix: Manajemen Situs.  Untuk mengimplementasikan pencarian, kami menggunakan modul pencarian bitrix standar dan mesin teks lengkap sphinxsearch.  Dalam sphinxsearch, tipe indeks Real Time (RT) digunakan, yang tidak memerlukan sumber data statis, tetapi dapat diisi kapan saja secara real time.  Ini memungkinkan Anda memperbarui indeks pencarian secara fleksibel tanpa mengindeks ulang sepenuhnya.  Karena indeks RT hanya menggunakan SphinxQL sebagai protokol kueri, integrasi dilakukan melalui itu.  SphinxQL adalah protokol kueri seperti mysql yang mengimplementasikan kemampuan untuk terhubung melalui klien mysql standar, sambil memberikan sintaksis sql dengan beberapa batasan dan kekhasannya sendiri.  Modul pencarian menggunakan select / insert / replace / delete queries. <br><br>  Dalam sistem bitrix, proses pengindeksan data barang, kategori dan merek dilakukan.  Informasi tentang entitas ini dipindahkan ke sphinx, yang pada gilirannya memperbarui indeks RT.  Ketika data diperbarui di toko online, sebuah peristiwa dipicu yang memperbarui data di Sphinx.  Konsistensi data dilakukan melalui pengenal entitas di toko online. <br><br>  Ketika pengguna mencari di toko online, sistem membuat permintaan dengan frasa pencarian di Sphinx dan memperoleh pengidentifikasi entitas, juga memilih dari informasi database pada mereka dan membentuk halaman dengan hasil hasil pencarian. <br>  Pada saat solusi untuk masalah pencarian fuzzy dimulai, skema umum arsitektur pencarian pada proyek adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/eg/wr/zb/egwrzb1_6dhcjpe5qlshpalyyxy.jpeg"><br><br><h3>  Pemilihan teknologi </h3><br>  Tugas kami adalah menebak permintaan pengguna, yang mungkin mengandung kesalahan ketik.  Untuk melakukan ini, kita perlu menganalisis setiap kata dalam permintaan dan memutuskan apakah pengguna menulisnya dengan benar atau tidak.  Jika terjadi kesalahan, opsi yang paling cocok harus dipilih.  Menentukan ejaan kata yang benar tidak mungkin tanpa database kata dan bentuk kata dari bahasa di mana kita ingin menebaknya.  Secara sederhana, basis data seperti itu bisa disebut kamus - dialah yang kami butuhkan. <br><br>  Untuk memilih opsi substitusi kata yang dimasukkan dengan kesalahan, formula penghitungan jarak Damerau - Levenshtein yang populer dipilih.  Formula ini adalah algoritma untuk membandingkan dua kata.  Hasil perbandingan adalah jumlah operasi untuk mengubah satu kata menjadi kata lain.  Awalnya, jarak Levenshtein melibatkan penggunaan 3 operasi: <br><br><ul><li>  penyisipan </li><li>  penghapusan </li><li>  penggantian </li></ul><br>  Jarak Damerau-Levenshtein adalah versi diperpanjang dari jarak Levenshtein dan menambahkan operasi lain: transposisi, yaitu permutasi dari dua karakter yang berdekatan. <br><br>  Dengan demikian, jumlah operasi yang diterima menjadi jumlah kesalahan yang dibuat oleh pengguna saat menulis kata.  Kami memilih batasan dua kesalahan, karena jumlah yang lebih besar tidak masuk akal: dalam hal ini kami mendapatkan terlalu banyak opsi untuk penggantian, yang meningkatkan kemungkinan kehilangan. <br><br>  Untuk pencarian yang lebih relevan untuk varian kata yang mirip dalam suara, fungsi metafon digunakan - fungsi ini mengubah kata menjadi bentuk fonetisnya.  Sayangnya, metafon hanya berfungsi dengan huruf-huruf alfabet Inggris, jadi sebelum menghitung bentuk fonetisnya, kami mentransliterasikan kata tersebut.  Nilai bentuk fonetis disimpan dalam kamus, dan juga dihitung dalam permintaan pengguna.  Nilai yang dihasilkan dibandingkan dengan fungsi jarak Damerau-Levenshtein. <br><br>  Kamus disimpan dalam database MySQL.  Agar tidak memuat kamus ke dalam memori aplikasi, diputuskan untuk menghitung jarak Damerau-Levenshtein di sisi dasar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi yang ditentukan pengguna untuk menghitung jarak Damerau-Levenshtein</a> , yang ditulis berdasarkan <a href="">fungsi C yang ditulis oleh Linus Torvalds</a> , sepenuhnya memenuhi persyaratan kami.  Dibuat oleh Diego Torres. <br><br>  Setelah menghitung jarak Damerau-Levenshtein, perlu untuk mengurutkan hasil berdasarkan tingkat kesamaan untuk memilih yang paling cocok.  Untuk melakukan ini, kami menggunakan algoritma Oliver: menghitung kesamaan dua baris.  Dalam php, algoritma ini diwakili oleh fungsi similar_text.  Dua parameter pertama dari fungsi menerima garis input yang perlu dibandingkan. Urutan perbandingan string penting, karena fungsi memberikan nilai yang berbeda tergantung pada urutan di mana garis dilewatkan ke fungsi.  Parameter ketiga harus lulus variabel di mana hasil perbandingan ditempatkan.  Ini akan menjadi angka dari 0 hingga 100, yang berarti persentase kesamaan antara dua baris.  Setelah perhitungan, hasilnya diurutkan dalam urutan kesamaan, kemudian opsi dengan nilai terbaik dipilih. <br><br>  Karena perhitungan jarak Damerau-Levenshtein dilakukan sesuai dengan transkripsi kata, kata-kata dengan makna yang tidak sepenuhnya relevan masuk ke dalam hasil.  Dalam hal ini, kami membatasi pemilihan opsi dengan persentase kecocokan lebih dari 70%. <br><br>  Selama proses pengembangan, kami perhatikan bahwa algoritma kami dapat menebak kata-kata dalam tata letak yang berbeda.  Karena itu, kami perlu memperluas kamus dengan menambahkan arti kata pada tata letak terbalik.  Persyaratan pencarian hanya menampilkan dua tata letak: Rusia dan Inggris.  Kami menduplikasi setiap kata dari permintaan pencarian pengguna pada tata letak terbalik dan menambahkan pemrosesan untuk menghitung jarak Damerau-Levenshtein.  Pilihan untuk tata letak langsung dan mundur diproses secara independen satu sama lain, opsi dengan persentase kemiripan tertinggi dipilih.  Hanya untuk opsi tata letak terbalik nilai di tata letak langsung akan menjadi nilai untuk permintaan pencarian yang diperbaiki. <br><br><h3>  Algoritma pencarian fuzzy </h3><br>  Dengan demikian, algoritma tindakan 6 langkah utama dibentuk.  Selama pengujian, kami menemukan bahwa tidak semua kata dalam permintaan pengguna perlu diproses dalam bentuk aslinya atau diproses secara umum.  Untuk mengatasi kasus tersebut, langkah tambahan diperkenalkan, yang kami sebut konverter atau filter.  Alhasil, algoritma terakhir terdiri dari 7 langkah: <br><br><ol><li>  Pecahkan permintaan menjadi kata-kata yang terpisah; </li><li>  Lewati setiap kata melalui konverter (lebih lanjut tentang itu); </li><li>  Untuk setiap kata, buat formulirnya pada tata letak yang berbeda; </li><li>  Buat transkripsi; </li><li>  Buat kueri pencarian di tabel kamus, bandingkan setiap entri melalui jarak Damerau-Levenshtein; </li><li>  Hanya menyisakan catatan dengan jarak kurang dari atau sama dengan dua; </li><li>  Melalui algoritma Oliver, hanya menyisakan kata-kata dengan persentase kemiripan lebih dari 70% </li></ol><br>  Secara skematis, algoritma ini adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/jv/_e/zi/jv_ezix9ooxqmvb5qjwfdzpjho8.jpeg"><br><br><h3>  Konversi kata dan fungsi penyaringan </h3><br>  Ketika kami mulai menguji prototipe pertama tanpa konverter, menjadi jelas bahwa tidak perlu mencoba menebak semua kata dalam permintaan pengguna.  Konverter telah dibuat untuk pembatasan ini.  Ini memungkinkan Anda untuk mengubah kata ke bentuk yang kita butuhkan dan menyaring kata-kata yang, menurut pendapat kami, tidak perlu ditebak. <br><br>  Awalnya, diputuskan bahwa panjang kata minimum yang harus dilalui algoritma harus setidaknya dua karakter.  Lagipula, jika pengguna memasukkan dalih atau gabungan satu karakter, maka kemungkinan menebaknya praktis minimal.  Langkah kedua adalah untuk membagi permintaan menjadi kata-kata.  Pertama-tama, kami memilih serangkaian karakter yang dapat berisi kata-kata: huruf, angka, titik, dan tanda hubung (tanda hubung).  Spasi dan karakter lain adalah pembatas kata. <br><br>  Sangat sering, pengguna memasukkan angka untuk menunjukkan volume atau kuantitas.  Dalam hal ini, akan salah untuk memperbaiki permintaan semacam itu.  Misalnya, pengguna memasukkan kueri "air 1,1 liter".  Jika kami memperbaiki permintaannya sebesar 1,5 atau 1,0, itu akan salah.  Dalam kasus seperti itu, kami memutuskan untuk melewatkan kata dengan angka.  Mereka, melewati algoritma kami, ditransfer ke pencarian teks lengkap Sphinx. <br><br>  Konversi lain dikaitkan dengan titik-titik dalam nama merek - misalnya: Dr. Pepper atau Mr.Proper.  Dalam kasus di mana ada simbol titik di tengah kata, maka kita memecahnya menjadi dua, menambahkan spasi.  Kasus kedua dengan titik di tengah kata - di sini kita ingat merek singkatan.  Misalnya, merek ROCS - dalam hal ini kami memotong titik-titik dan mendapatkan satu kata.  Konversi ini berfungsi jika hanya ada satu huruf di antara titik-titik. <br><br>  Dalam kasus di mana tanda hubung (tanda hubung) hadir dalam kata, Anda harus memecah kata menjadi beberapa dan mencoba menebaknya secara individual, dan kemudian rekatkan opsi terbaik. <br><br>  Akibatnya, konverter dikembangkan untuk pengenalan permintaan yang paling akurat - sebagian besar pekerjaan pengaturan semua fungsi dilakukan oleh pengembangan khusus ini.  Berkat dia, penyesuaian dan penyetelan seluruh pencarian fuzzy dilakukan.  Secara singkat ulangi aturan dengan mana penyaringan dan konversi kata dilakukan: <br><br><ul><li>  kata harus lebih dari 2 karakter </li><li>  kata tersebut harus hanya berisi huruf, karakter titik, dan tanda hubung (tanda hubung) </li><li>  jika titik ada di tengah kata, spasi ditambahkan setelahnya </li><li>  jika itu adalah singkatan, titik-titik dipotong dan huruf-huruf dilem bersama </li><li>  jangan mencoba menebak kata jika ada angka di dalamnya </li><li>  jika kata tersebut berisi tanda hubung (tanda hubung), kemudian pisahkan menjadi beberapa, cari secara terpisah dan tempel di bagian akhir </li></ul><br><h3>  Kompilasi kamus </h3><br>  Seperti yang disebutkan sebelumnya, untuk memperbaiki permintaan pengguna, perlu untuk menentukan kata mana yang dieja salah dan mana yang tidak.  Untuk ini, kamus dibuat dalam sistem di mana kata-kata dengan ejaan yang benar harus dimuat. <br><br>  Pada tahap pertama, muncul pertanyaan untuk mengisi kamus - sebagai hasilnya, kami memutuskan untuk menggunakan konten katalog untuk menyusunnya.  Karena informasi barang diimpor dari waktu ke waktu dari sistem eksternal dan diindeks untuk sistem pencarian teks lengkap Sphinx, diputuskan untuk menambahkan fungsionalitas kompilasi kamus pada tahap ini.  Kami mengikuti logika berikut: jika kata itu tidak ada dalam konten barang, lalu mengapa mencoba menebaknya? <br>  Informasi produk digabungkan menjadi teks umum dan dilakukan melalui konverter.  Mode operasi konverter sedikit dimodifikasi: ketika memecah kata melalui tanda hubung (tanda hubung), masing-masing bagian disimpan dalam kamus secara terpisah, ketika mengganti titik dalam kamus, data asli dan yang diubah ditambahkan.  Dan karena ketika membandingkan kata-kata untuk menghitung jarak Damerau-Levenshtein, transkripsi kata digunakan, selain kamus, transkripsi ditambahkan. <br><br>  Ada banyak kesalahan ketik dalam konten produk, untuk tujuan ini bendera diletakkan di kamus, ketika dipasang, kata tersebut tidak lagi digunakan dalam pencarian.  Konten dari 35 ribu produk diperbolehkan membuat kamus berisi 100 ribu kata unik, yang pada akhirnya tidak cukup untuk beberapa permintaan pengguna.  Dalam hal ini, perlu untuk menyediakan fungsi pemuatan untuk pengayaannya.  Perintah konsol dibuat untuk memuat kamus.  Format file dengan data kamus harus sesuai dengan csv.  Setiap entri hanya berisi satu bidang dengan bidang kamus itu sendiri.  Untuk membedakan data yang diunduh dari data yang dihasilkan berdasarkan konten barang, bendera khusus ditambahkan. <br>  Hasilnya, tabel kamus memiliki skema berikut: <br><br><table><tbody><tr><th>  Nama bidang </th><th>  Jenis bidang </th></tr><tr><td>  Kata </td><td>  tali </td></tr><tr><td>  Transkripsi </td><td>  tali </td></tr><tr><td>  Ditambahkan secara manual </td><td>  bool </td></tr><tr><td>  Jangan gunakan </td><td>  bool </td></tr></tbody></table><br>  Sebelum pengembangan fungsi pencarian fuzzy, ada bidang dalam produk yang berisi serangkaian kata dengan kesalahan ketik.  Pada generasi pertama pembuatan kamus, mereka memasuki isinya.  Akibatnya, kamus dengan kesalahan ketik diperoleh, yang isinya tidak cocok untuk berfungsi dengan benar.  Oleh karena itu, perintah konsol lain ditambahkan yang memiliki fungsi pembuatan kamus terbalik.  Menggunakan konten dari bidang barang tertentu, tim mencari kata-kata dalam kamus dan membersihkannya dari kamus.  Setelah dibersihkan, bidang tersebut dikeluarkan dari pengindeksan. <br><br><h3>  Integrasi Bitrix </h3><br>  Untuk menerapkan fungsi minimum yang disyaratkan, tiga kelas telah dibuat: <br><br><ul><li>  DictionaryTable - sistem BitM ORM untuk bekerja dengan kamus </li><li>  Kamus - kelas pembuatan kamus </li><li>  Cari - cari kelas implementasi </li></ul><br>  Untuk integrasi ke dalam Bitrix, diperlukan untuk membuat perubahan pada 2 komponen: <br><br><ul><li>  bitrix: search.page </li><li>  bitrix.search.title </li></ul><br>  Sebelum menjalankan permintaan, metode pemrosesan dipanggil untuk mendeteksi kesalahan dan memilih opsi yang sesuai: <br><br><img src="https://habrastorage.org/webt/8r/zg/9j/8rzg9jwnaetecysp7xqbqq1px-k.jpeg"><br><br>  Untuk mengkompilasi kamus, sebuah peristiwa direkam untuk mengindeks oleh modul pencarian elemen-elemen blok informasi dengan barang-barang (pencarian: BeforeIndex). <br><br><img src="https://habrastorage.org/webt/ph/gw/ex/phgwexmqmprsu7sti7-hjn5if5s.jpeg"><br><br><img src="https://habrastorage.org/webt/a6/et/a3/a6eta39r-sxk3mwlgk4e6at4npa.jpeg"><br><br><h3>  Rencana masa depan </h3><br>  Pendekatan ini tidak ideal dalam hal kinerja.  Dengan peningkatan ukuran kamus menjadi 1M + kata, waktu respons basis data dapat meningkat secara signifikan.  Meskipun kamusnya kecil, kinerjanya cocok untuk kami.  Mungkin perlu untuk mengimplementasikan algoritma di masa depan melalui otomat Levenshtein atau pohon awalan. <br><br><h3>  Kesimpulan </h3><br>  Jadi, tidak ada mesin pencari yang dihindarkan dari penampilan kueri yang melanggar aturan ejaan yang diterima secara umum - baik itu kesalahan ketik acak atau benar-benar kurangnya pengetahuan tentang ejaan kata-kata.  Oleh karena itu, tanpa beralih ke opsi pencarian fuzzy klasik Google atau Yandex, Anda dapat membuatnya sendiri, berkat pengguna dan pemilik situs dapat memperoleh hasil yang diinginkan. <br><br>  Kode implementasi kami dapat dilihat di repositori: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/qsoft-dev/damlev-bitrix</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432892/">https://habr.com/ru/post/id432892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432880/index.html">Apa yang Anda ketahui tentang grosir dan eceran listrik?</a></li>
<li><a href="../id432882/index.html">Kepingan salju do-it-yourself dalam gaya StarWars (pembaruan 2018)</a></li>
<li><a href="../id432886/index.html">Cara meningkatkan tim produk Anda: budaya, eksperimen dan struktur</a></li>
<li><a href="../id432888/index.html">Bagaimana kabar Heisenbug</a></li>
<li><a href="../id432890/index.html">Linux, Microsoft dan Marxisme</a></li>
<li><a href="../id432894/index.html">19 Desember, Moskow - OpsFormations</a></li>
<li><a href="../id432896/index.html">AXIS P1425-LE Mk II vs IDIS DC-T3233HRXL: Bandingkan Kamera CCTV</a></li>
<li><a href="../id432898/index.html">Panorama di StereoPi</a></li>
<li><a href="../id432900/index.html">Fitur kerja dalam tim internasional. Jepang</a></li>
<li><a href="../id432902/index.html">Gagal terbang ke bulan: apa yang diketahui tentang salah satu misi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>