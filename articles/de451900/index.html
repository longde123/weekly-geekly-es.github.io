<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèº üëµüèæ üßòüèø Erster Beitrag zur Browser-API von Facebook ü§£ üì≠ üßòüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unsere Position als Eigent√ºmer einer beliebten Website und unsere Arbeit zur Unterst√ºtzung der beliebten React-Plattform bieten uns einzigartige M√∂gli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erster Beitrag zur Browser-API von Facebook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451900/"><p><img src="https://habrastorage.org/webt/ot/me/yt/otmeytc2idaafvqyj9c3dcekdw4.jpeg" alt="Abdeckung"></p><br><p> Unsere Position als Eigent√ºmer einer beliebten Website und unsere Arbeit zur Unterst√ºtzung der beliebten React-Plattform bieten uns einzigartige M√∂glichkeiten und Verst√§ndnis f√ºr die Arbeit mit dem Browser, mit dem wir das Problem der Warteschlange l√∂sen m√∂chten.  Als aktives Mitglied der Web Standards Community (W3C) haben wir an einer Diskussion √ºber viele Innovationen teilgenommen, darunter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Overscroll</a> . Bis vor kurzem haben wir jedoch keine eigenen Initiativen zur Verbesserung des Webbrowsers entwickelt.  Um eine signifikante Steigerung der Produktivit√§t zu erreichen, wurde eine neue API vorgeschlagen, die aufgrund der engen Zusammenarbeit mit unseren Kollegen von Google Chrome f√ºr eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testversion</a> bereitgestellt wurde.  <strong>Chrome v74</strong> enth√§lt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isInputPending-API</a> und kann verwendet werden, um sowohl die Gesamtausf√ºhrungszeit von JavaScript als auch die Reaktionszeit von Ereignissen zu verbessern.  Dies ist nur der erste Schritt zur Verbesserung der JavaScript-Planung im Web.  Wir hoffen, Entwickler-Feedback zu erhalten und daraus die endg√ºltige Version der API zu erstellen. </p><a name="habracut"></a><br><p>  Einer der wichtigsten Leistungsindikatoren im modernen Web ist die Zeit, die erforderlich ist, um auf ein Benutzerereignis (Klicken auf eine Schaltfl√§che oder Eingeben eines Felds) mit vollst√§ndiger Visualisierung zu reagieren.  Auf Facebook teilen und messen wir Ereignisse in vier Schritten: </p><br><ul><li>  Betriebssystem empf√§ngt Daten </li><li>  tats√§chlicher Beginn der Verarbeitung </li><li>  Zeigen Sie √Ñnderungen auf dem Bildschirm als Reaktion auf ein Ereignis an </li><li>  Die Verarbeitung ist abgeschlossen und das Ergebnis wird visualisiert </li></ul><br><p>  Bei der Bewertung unserer produktivsten Produkte wurde festgestellt, dass die Wartezeit in der Warteschlange die gr√∂√üten Verz√∂gerungen verursacht.  Mit Warteschlange ist die Zeit zwischen der Interaktion des Benutzers mit der Seite (z. B. Klicken oder Tippen) und dem Beginn der eigentlichen Verarbeitung des Ereignisses gemeint.  In einigen F√§llen kann diese Verz√∂gerung sehr bedeutend sein.  Stellen Sie sich vor, Sie klicken auf das Benachrichtigungssymbol und warten eine Minute, bevor die Schaltfl√§che antwortet.  Wahrscheinlich wird niemand auf eine Antwort warten. </p><br><h2 id="bystraya-zagruzka-ili-bystroe-reagirovanie-vyberite-odin">  Schneller Start oder schnelle Antwort: W√§hlen Sie eine aus </h2><br><p>  Es gibt einen schwierigen Kompromiss zwischen schnellem Laden von Seiten und Interaktivit√§t.  Wenn f√ºr eine Website JavaScript erforderlich ist, besteht eine Option darin, alles in einem Block auszuf√ºhren.  Dies kann jedoch zu Problemen f√ºhren.  JavaScript-Mechanismen in Webbrowsern sind normalerweise Single-Threaded-Mechanismen, dh sie k√∂nnen jeweils nur einen Vorgang pro Seite ausf√ºhren.  Wenn die Seite geladen wird, bedeutet dies, dass der Browser, wenn der Benutzer auf etwas klickt, das Klickereignis in die Warteschlange stellen muss, bis der gesamte JavaScript-Block ausgef√ºhrt wird. </p><br><p>  Wie viele andere Websites l√∂sen wir dieses Problem, indem wir JavaScript in kleine Bl√∂cke aufteilen.  W√§hrend die Seite geladen wird, starten wir JavaScript und geben dann die Kontrolle an den Browser zur√ºck.  Anschlie√üend kann der Browser die Warteschlange f√ºr Eingabeereignisse √ºberpr√ºfen und feststellen, ob etwas zu handhaben ist.  Der Browser kann dann beim Hinzuf√ºgen wieder JavaScript-Bl√∂cke ausf√ºhren.  Dies hilft, kann aber andere Probleme verursachen.  Jedes Mal, wenn wir die Steuerung an den Browser zur√ºckgeben, dauert es einige Zeit, bis die Eingabeereignisse √ºberpr√ºft, die Ereignisse verarbeitet und der n√§chste JavaScript-Block ausgew√§hlt wurden.  Obwohl der Browser schneller auf Ereignisse reagiert, m√ºssen wir dennoch ein Gleichgewicht zwischen der Gr√∂√üe der Codebl√∂cke und der H√§ufigkeit finden, mit der wir dem Browser unterlegen sind.  Wenn wir die Steuerelemente zu oft √§ndern, wird die Seite zu langsam geladen. Im Gegenteil, weniger h√§ufig ben√∂tigt der Browser mehr Zeit, um auf Benutzerereignisse zu reagieren, und die Benutzer sind entt√§uscht. </p><br><p><img src="https://habrastorage.org/webt/ta/sw/ue/taswuexpvwj5q5lpns2qmoyi0ue.jpeg" alt="lastfest"></p><br><blockquote>  Wenn wir gro√üe JavaScript-Bl√∂cke ausf√ºhren, kann der Browser Benutzerereignisse mit einer langen Verz√∂gerung senden (siehe oben).  Wenn wir kleinere Bl√∂cke ausf√ºhren, dauert das Laden der Seite l√§nger (unten). </blockquote><br><h2 id="isinputpending-reshenie">  isInputPending-L√∂sung </h2><br><p>  Als wir zum ersten Mal Verz√∂gerungen in der Warteschlange entdeckten, wandten wir uns an unsere Kollegen in Chrome.  Wir wollten sehen, wie alles aussehen w√ºrde, wenn wir einen neuen Download-Ansatz entwickeln w√ºrden, der dieses Kompromissdilemma beseitigt.  Nachdem wir mit ihnen gesprochen hatten, schlugen wir isInputPending vor.  <em>Die isInputPending-API verwendet</em> als erste das Konzept von Interrupts f√ºr Benutzerereignisse im Web. </p><br><p>  Unter der Haube lauscht <em>isInputPending</em> in der Chrome-Eingabewarteschlange auf der Compilerseite, um Ereignisse <em>abzufangen,</em> bevor sie dem Hauptstrom hinzugef√ºgt werden.  Da dieses Abh√∂ren au√üerhalb des Hauptthreads erfolgt, verbrauchen <em>isInputPending-</em> Aufrufe nicht viel Rechenressourcen und sollten sehr schnell sein.  Auf diese Weise k√∂nnen Entwickler die API h√§ufig aufrufen und die Reaktionsf√§higkeit maximieren. </p><br><p>  Sobald wir diesen Vorschlag vorbereitet hatten, wandten wir uns an die W3C Web Performance Working Group und erhielten die Zustimmung verschiedener Browser-Anbieter, dass unsere Idee es wert ist, untersucht zu werden.  In Zukunft haben wir mit unseren Kollegen in Chrome zusammengearbeitet, die neue API unabh√§ngig implementiert und die entsprechenden Codekorrekturen in Chrome gesendet.  Dank der Ingenieure von Chrome haben wir Test-Patches erhalten, mit denen wir √Ñnderungen testen und vor einer vollst√§ndigen Ver√∂ffentlichung Feedback von Entwicklern erhalten k√∂nnen.  Mit dieser Version k√∂nnen wir verstehen, wie wichtig diese API f√ºr Entwickler ist, und unsere zuk√ºnftigen Gespr√§che √ºber diese API mit Webbrowser-Anbietern bestimmen.  Dies ist das erste Mal, dass wir alle Phasen der Entwicklung einer Web-API durchlaufen haben, von der Diskussion eines Vorschlags in einem Forum bis zur √úbergabe von Code an einen Webbrowser. </p><br><h2 id="kak-rabotaet-isinputpending">  Wie isInputPending funktioniert </h2><br><p>  <em>Wie der</em> Name schon sagt, meldet <em>isInputPending</em> , ob Ereignisse f√ºr die Eingabe anstehen.  Entwickler k√∂nnen diese Informationen beim Ausf√ºhren von JavaScript verwenden, um zu entscheiden, ob sie die Kontrolle √ºber den Browser wiedererlangen m√∂chten.  Bei richtiger <em>Anwendung</em> kann <em>isInputPending</em> das Dilemma des schnellen Ladens und der Interaktivit√§t vollst√§ndig beseitigen. </p><br><p> Um mit der API zu arbeiten, wird <code>navigator.scheduling.isInputPending()</code> .  Wenn der Browser erwartet, dass das Ereignis ausgel√∂st wird, gibt diese Methode im Wesentlichen <code>true</code> .  Beim Aufruf ohne Argumente werden alle unterst√ºtzten Ereignistypen √ºberpr√ºft.  Dar√ºber hinaus ist es m√∂glich, eine Liste von Ereignistypen manuell anzugeben: Maus, Rad, Ber√ºhrung, die auf ausstehende Eingaben √ºberpr√ºft werden soll. </p><br><h3 id="primer-proverka-lyubyh-tipov-sobytiy">  Beispiel: √úberpr√ºfung auf jede Art von Ereignis </h3><br><pre> <code class="plaintext hljs">while (workQueue.length &gt; 0) { if (navigator.scheduling.isInputPending()) { //       break; } let job = workQueue.shift(); job.execute(); }</code> </pre> <br><h3 id="primer-proverka-na-konkretnye-vhodnye-sobytiya">  Beispiel: √úberpr√ºfung auf bestimmte Eingabeereignisse </h3><br><pre> <code class="plaintext hljs">while (workQueue.length &gt; 0) { if (navigator.scheduling.isInputPending(['mousedown', 'mouseup', 'keydown', 'keyup'])) { //       'mousedown'  'mouseup'  'keydown'  'keyup' break; } let job = workQueue.shift(); job.execute(); }</code> </pre> <br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  Wenn das Community-Feedback positiv ist, ist <em>isInputPending</em> m√∂glicherweise in Chrome vollst√§ndig verf√ºgbar.  Dann k√∂nnen wir diese sp√ºrbaren Verz√∂gerungen in der Warteschlange beseitigen und die Arbeit im Internet f√ºr die Benutzer unserer Websites schneller und flexibler gestalten.  F√ºr Entwickler, die auch Verz√∂gerungen in der Warteschlange beseitigen und die Interaktion und Download-Leistung verbessern m√∂chten, wird in K√ºrze eine Testversion verf√ºgbar sein.  Registrieren Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und teilen Sie Ihre Meinung zur Testversion mit, sobald diese verf√ºgbar ist. </p><br><p>  Der <em>isInputPending-</em> Portierungsprozess von Chrome ist eine neue Methode zur Entwicklung von Webstandards auf Facebook.  Wir hoffen, weiterhin neue APIs zu entwickeln und unseren Beitrag zu Open Source-Webbrowsern zu erh√∂hen.  In Zukunft k√∂nnten wir diese API m√∂glicherweise direkt in React einbetten, damit Entwickler die API sofort nutzen k√∂nnen.  Dar√ºber hinaus ist <em>isInputPending</em> jetzt Teil der gro√üartigen Arbeit beim Erstellen von <em>Grundelementen</em> f√ºr die Planung im Web.  Wir freuen uns darauf, unsere Partnerschaft mit Chrome fortzusetzen.  Am Ende hoffen wir auf Browser-Tools, mit denen Entwickler sich tiefer in die Warteschlange f√ºr Browser-Aufgaben integrieren und sogar die Browser-Priorit√§ten f√ºr verschiedene Netzwerkanforderungen und -aufgaben verstehen k√∂nnen. </p><br><h2 id="primechanie-avtora">  Anmerkung des Autors </h2><br><p>  Um die neue API zu testen, ben√∂tigen Sie: </p><br><ul><li>  Installieren Sie die Version 74-76 des Google Chrome-Browsers </li><li>  Aktivieren Sie das Flag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Experimental Web Platform-Funktionen</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Chrome v74</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/66/bb/yq/66bbyqirlqgfzupbobwovk_ozv4.png" alt="v74"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Chrome v76 (entwickeln)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/u9/1j/du/u91jdu5dbgtrt6gsrj2d-5mrbze.png" alt="v76"></p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451900/">https://habr.com/ru/post/de451900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451886/index.html">Verwenden diskreter Mathematik beim Testen</a></li>
<li><a href="../de451890/index.html">Delegierung einer Reverse-Subnetzzone von weniger als / 24 in BIND. Wie funktioniert es?</a></li>
<li><a href="../de451894/index.html">Ein kurzer und √ºbersichtlicher √úberblick √ºber die Compiler-Architektur</a></li>
<li><a href="../de451896/index.html">Eine "unzerbrechliche" eyeDisk ist durch einen Iris-Scan gesch√ºtzt, √ºbertr√§gt jedoch ein Passwort im Klartext</a></li>
<li><a href="../de451898/index.html">Innovation auf Russisch</a></li>
<li><a href="../de451902/index.html">Microsoft Azure Developer Camp Russland</a></li>
<li><a href="../de451904/index.html">Manchmal ist mehr weniger. Wenn eine Abnahme der Last zu einer Zunahme der Verz√∂gerung f√ºhrt</a></li>
<li><a href="../de451906/index.html">Exchange-Sicherheitsanf√§lligkeit: Ermitteln der Erh√∂hung der Berechtigung f√ºr einen Dom√§nenadministrator</a></li>
<li><a href="../de451908/index.html">Die Geschichte der Computer: eine Nacht im Yandex Museum</a></li>
<li><a href="../de451912/index.html">Das tiefe neuronale Netzwerk von MuseNet schreibt Musik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>