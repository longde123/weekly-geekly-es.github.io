<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèø üëÉüèæ ü§Ωüèª Lugares escorregadios em C ++ 17 üçõ ü§πüèΩ üôåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos √∫ltimos anos, o C ++ deu trancos e barrancos, e acompanhar todas as sutilezas e complexidades da linguagem pode ser muito, muito dif√≠cil. Um novo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lugares escorregadios em C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="imagem"></a> <br><br>  Nos √∫ltimos anos, o C ++ deu trancos e barrancos, e acompanhar todas as sutilezas e complexidades da linguagem pode ser muito, muito dif√≠cil.  Um novo padr√£o n√£o est√° muito longe, no entanto, a introdu√ß√£o de novas tend√™ncias n√£o √© o processo mais r√°pido e f√°cil, portanto, embora haja pouco tempo antes do C ++ 20, sugiro atualizar ou descobrir alguns lugares especialmente "escorregadios" do padr√£o atual idioma. <br><br>  Hoje, vou lhe dizer por que, se o constexpr n√£o substitui as macros, quais s√£o os "elementos internos" da liga√ß√£o estruturada e suas "armadilhas" e √© verdade que a c√≥pia elision sempre funciona agora e voc√™ pode escrever qualquer retorno sem hesita√ß√£o. <br><br>  Se voc√™ n√£o tem medo de sujar um pouco as m√£os, investigando o "interior" da sua l√≠ngua, bem-vindo ao gato. <br><a name="habracut"></a><br><hr><br><h1>  se constexpr </h1><br>  Vamos come√ßar pelo mais simples - <code>if constexpr</code> permitir descartar o ramo de express√£o condicional para o qual a condi√ß√£o desejada n√£o √© atendida, mesmo no est√°gio de compila√ß√£o. <br><br>  Parece que isso substitui a macro <code>#if</code> para desativar a l√≥gica "extra"?  N√£o.  Nem um pouco. <br><br>  Primeiro, tal <code>if</code> tem propriedades que n√£o est√£o dispon√≠veis para macros - dentro voc√™ pode contar qualquer express√£o <code>constexpr</code> que possa ser <code>constexpr</code> em <code>bool</code> .  Bem, e em segundo lugar, o conte√∫do do ramo descartado deve estar sint√°tico e semanticamente correto. <br><br>  Por causa do segundo requisito, <code>if constexpr</code> n√£o puder ser usado, por exemplo, fun√ß√µes inexistentes (o c√≥digo dependente da plataforma n√£o pode ser explicitamente separado dessa maneira) ou incorreto do ponto de vista da linguagem de constru√ß√£o (por exemplo, ‚Äú <code>void T = 0;</code> ‚Äù). <br><br>  Qual √© o sentido de usar <code>if constexpr</code> ?  O ponto principal est√° nos modelos.  Existe uma regra especial para eles: o ramo descartado n√£o √© instanciado quando o modelo √© instanciado.  Isso facilita a grava√ß√£o de c√≥digo que, de alguma forma, depende das propriedades dos tipos de modelo. <br><br>  No entanto, nos modelos, n√£o se deve esquecer que o c√≥digo dentro dos ramos deve estar correto pelo menos para algumas inst√¢ncias (mesmo que potencialmente <code>static_assert(false)</code> ) de instancia√ß√£o; portanto, √© simplesmente <code>static_assert(false)</code> escrever, por exemplo, <code>static_assert(false)</code> dentro de um dos ramos (√© necess√°rio que isso <code>static_assert</code> dependia de algum par√¢metro dependente do modelo). <br><br>  Exemplos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Coisas para lembrar </h2><br><ol><li>  O c√≥digo em todas as ramifica√ß√µes deve estar correto. <br></li><li>  Nos modelos internos, o conte√∫do das ramifica√ß√µes descartadas n√£o √© instanciado. <br></li><li>  O c√≥digo dentro de qualquer ramifica√ß√£o deve estar correto para pelo menos uma variante puramente potencial de instancia√ß√£o do modelo. <br></li></ol><br><h1>  Liga√ß√£o estruturada </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  No C ++ 17, apareceu um mecanismo bastante conveniente para decompor v√°rios objetos do tipo tupla, permitindo vincular de forma conveniente e concisa seus elementos internos a vari√°veis ‚Äã‚Äãnomeadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ‚Äî    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Por um objeto semelhante a uma tupla, entenderei um objeto para o qual seja conhecido o n√∫mero de elementos internos dispon√≠veis no momento da compila√ß√£o (a partir de "tupla" - uma lista ordenada com um n√∫mero fixo de elementos (vetor)). <br><br>  Essas defini√ß√µes se enquadram nessa defini√ß√£o como: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , matrizes no formato ‚Äú <code>T a[N]</code> ‚Äù, bem como v√°rias estruturas e classes auto-escritas. <br><br>  Pare ... Voc√™ pode usar suas pr√≥prias estruturas na liga√ß√£o estrutural?  Spoiler: voc√™ pode (embora √†s vezes precise trabalhar duro (mas mais sobre isso abaixo)). <br><br><h2>  Como isso funciona </h2><br>  O trabalho de vincula√ß√£o estrutural merece um artigo separado, mas, como estamos falando especificamente de lugares ‚Äúescorregadios‚Äù, tentarei explicar brevemente como tudo funciona. <br><br>  O padr√£o fornece a seguinte sintaxe para definir a liga√ß√£o: <br><br>  <i>attr</i> (opcional) <i>express√£o de</i> <i>cv-auto</i> <i>ref-operator</i> (opcional) [ <i>identifier-list</i> ]; <br><br><ul><li>  <code>attr</code> - lista de atributos opcional; <br></li><li>  <code>cv-auto</code> - auto com poss√≠veis modificadores const / vol√°teis; <br></li><li>  <code>ref-operator</code> - especificador de refer√™ncia opcional (&amp; ou &amp;&amp;); <br></li><li>  <code>identifier-list</code> - uma lista de nomes de novas vari√°veis; <br></li><li>  <code>expression</code> √© uma express√£o que resulta em um objeto semelhante a uma tupla usado para liga√ß√£o (a express√£o pode estar no formato " <code>= expr</code> ", " <code>{expr}</code> " ou " <code>(expr)</code> "). <br></li></ul><br>  √â importante observar que o n√∫mero de nomes na <code>identifier-list</code> deve corresponder ao n√∫mero de elementos no objeto resultante da <code>expression</code> . <br><br>  Isso tudo permite que voc√™ escreva constru√ß√µes do formul√°rio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  E aqui chegamos ao primeiro local ‚Äúescorregadio‚Äù: encontrar uma express√£o da forma ‚Äú <code>auto a = expr;</code>  ", Voc√™ normalmente quer dizer que o tipo" <code>a</code> "ser√° calculado pela express√£o" <code>expr</code> "e espera que na express√£o" <code>const auto&amp; [a,b,c] = expr;</code>  "O mesmo ser√° feito, apenas os tipos para" <code>a,b,c</code> "ser√£o os tipos <code>const&amp;</code> elemento correspondentes de" <code>expr</code> "... <br><br>  A verdade √© diferente: o especificador ‚Äú <code>cv-auto ref-operator</code> ‚Äù √© usado para calcular o tipo de uma vari√°vel invis√≠vel, na qual o resultado do c√°lculo de expr √© atribu√≠do (ou seja, o compilador substitui ‚Äú <code>const auto&amp; [a,b,c] = expr</code> ‚Äù por ‚Äú <code>const auto&amp; e = expr</code> "). <br><br>  Assim, uma nova entidade invis√≠vel aparece (a seguir denominarei {e}); no entanto, a entidade √© muito √∫til: por exemplo, ela pode materializar objetos tempor√°rios (portanto, voc√™ pode conect√°-los com seguran√ßa " <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  O segundo local escorregadio segue imediatamente a substitui√ß√£o que o compilador faz: se o tipo deduzido para {e} n√£o for uma refer√™ncia, o resultado de <code>expr</code> ser√° copiado para {e}. <br><br>  Quais tipos as vari√°veis ‚Äã‚Äãter√£o na <code>identifier-list</code> ?  Para come√ßar, essas n√£o ser√£o exatamente vari√°veis.  Sim, eles se comportam como vari√°veis ‚Äã‚Äãcomuns reais, mas apenas com a diferen√ßa de que eles se referem a uma entidade associada a eles e o tipo de <code>decltype</code> dessa vari√°vel de "refer√™ncia" produzir√° o tipo de entidade a que essa vari√°vel se refere: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) ‚Äî int, decltype(b) ‚Äî float ++a; // ,  ¬´ ¬ª,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Os pr√≥prios tipos s√£o definidos da seguinte maneira: <br><br><ol><li>  Se <b>{e}</b> for uma matriz ( <code>T a[N]</code> ), o tipo ser√° um - T, os modificadores cv coincidir√£o com os da matriz. <br></li><li>  Se <b>{e}</b> for do tipo E e suportar a interface da tupla, as estruturas ser√£o definidas: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  e fun√ß√£o: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  ent√£o o tipo de cada vari√°vel ser√° o tipo <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  Em outros casos, o tipo da vari√°vel corresponder√° ao tipo de elemento da estrutura ao qual a liga√ß√£o √© realizada. <br></li></ol><br>  Portanto, se for muito breve, as seguintes etapas s√£o executadas com o v√≠nculo estrutural: <br><br><ol><li>  C√°lculo do tipo e inicializa√ß√£o da entidade invis√≠vel {e} com base nos modificadores de tipo <code>expr</code> e <code>cv-ref</code> . <br></li><li>  Crie pseudo-vari√°veis ‚Äã‚Äãe associe-as a {e} elementos. <br></li></ol><br><h2>  Vincular estruturalmente suas classes / estruturas </h2><br>  O principal obst√°culo para vincular suas estruturas √© a falta de reflex√£o em C ++.  At√© o compilador, que, ao que parece, deve saber com certeza como essa ou aquela estrutura √© organizada, tem dificuldade: modificadores de acesso (p√∫blico / privado / protegido) e heran√ßa complicam bastante as coisas. <br><br>  Devido a essas dificuldades, as restri√ß√µes ao uso de suas classes s√£o muito r√≠gidas (pelo menos por enquanto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1096</a> ): <br><br><ol><li>  Todos os campos n√£o est√°ticos internos de uma classe devem ser da mesma classe base e devem estar dispon√≠veis no momento do uso. <br></li><li>  Ou a classe deve implementar "reflex√£o" (suporte √† interface da tupla). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ¬´¬ª  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d ‚Äî private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  A implementa√ß√£o da interface de tupla permite que voc√™ use qualquer uma de suas classes para liga√ß√£o, mas ela parece um pouco complicada e traz outra armadilha.  Vamos usar imediatamente um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Agora ligamos: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  E √© hora de pensar em quais tipos temos?  (Quem poderia responder imediatamente merece um delicioso docinho.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Resposta correta</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Por que isso aconteceu?  A resposta est√° na especializa√ß√£o padr√£o para <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> n√£o adiciona <code>const</code> aos tipos de refer√™ncia, portanto o tipo para <code>Foo</code> sempre ser√° <code>int&amp;</code> . <br><br>  Como ganhar isso?  Basta adicionar especializa√ß√£o para <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Todos os tipos ser√£o esperados: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  A prop√≥sito, o mesmo comportamento √© verdadeiro para, por exemplo, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - voc√™ pode obter uma refer√™ncia n√£o constante ao elemento interno, mesmo que o pr√≥prio objeto seja constante. <br><br><h2>  Coisas para lembrar </h2><br><ol><li>  ‚Äú <code>cv-auto ref</code> ‚Äù em ‚Äú <code>cv-auto ref [a1..an] = expr</code> ‚Äù refere-se √† vari√°vel invis√≠vel {e}. <br></li><li>  Se o tipo inferido {e} n√£o for referenciado, {e} ser√° inicializado copiando (com cuidado com classes ‚Äúpesadas‚Äù). <br></li><li>  Vari√°veis ‚Äã‚Äãvinculadas s√£o links "impl√≠citos" (eles se comportam como links, embora <code>decltype</code> retorne um tipo n√£o de refer√™ncia para eles (a menos que a vari√°vel se refira a um link)). <br></li><li>  √â necess√°rio ter cuidado ao usar tipos de refer√™ncia para encaderna√ß√£o. <br></li></ol><br><h1>  Otimiza√ß√£o do valor de retorno (rvo, c√≥pia elision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Talvez esse fosse um dos recursos mais discutidos do padr√£o C ++ 17 (pelo menos no meu c√≠rculo de amigos).  E de fato: o C ++ 11 trouxe a sem√¢ntica do movimento, que simplificou bastante a transfer√™ncia do "interno" do objeto e a cria√ß√£o de v√°rias f√°bricas, e o C ++ 17 em geral, ao que parece, tornou poss√≠vel n√£o pensar em como devolver o objeto de qualquer m√©todo de f√°brica , - agora tudo deve ficar sem copiar e, em geral, "logo tudo florescer√° em Marte" ... <br><br>  Mas vamos ser um pouco realistas: otimizar o valor de retorno n√£o √© a coisa mais f√°cil de implementar.  Eu recomendo assistir a esta apresenta√ß√£o do cppcon2018: Arthur O'Dwyer ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Otimiza√ß√£o do valor de retorno: mais dif√≠cil do que parece</a> ‚Äù, na qual o autor explica por que √© dif√≠cil. <br><br>  Spoiler curto: <br><br>  Existe um "slot para o valor de retorno".  Esse slot √© essencialmente apenas um lugar na pilha que √© alocado por quem paga e passa para o chamado.  Se o c√≥digo chamado souber exatamente qual objeto √∫nico ser√° retornado, ele poder√° simplesmente cri√°-lo imediatamente nesse slot diretamente (desde que o tamanho e o tipo do objeto e do slot sejam os mesmos). <br><br>  O que se segue disso?  Vamos desmontar com exemplos. <br><br>  Tudo vai ficar bem aqui - o NRVO funcionar√°, o objeto ser√° constru√≠do imediatamente no "slot": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Aqui n√£o √© mais poss√≠vel determinar inequivocamente qual objeto deve ser o resultado; portanto, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor de movimenta√ß√£o</a> (c ++ 11) ser√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implicitamente chamado</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Aqui est√° um pouco mais complicado ... Como o tipo do valor de retorno √© diferente do tipo declarado, n√£o √© poss√≠vel chamar implicitamente a <code>move</code> , portanto o construtor de c√≥pia √© chamado por padr√£o.  Para impedir que isso aconte√ßa, voc√™ precisa chamar explicitamente a <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Parece que √© o mesmo que <code>foo2</code> , mas o operador tern√°rio √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coisa</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">peculiar</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Semelhante ao <code>foo4</code> , mas tamb√©m um tipo diferente, portanto, <code>move</code> necess√°rio <code>move</code> exatamente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Como voc√™ pode ver nos exemplos, ainda √© preciso pensar em como retornar o significado, mesmo em casos aparentemente triviais ... Existem maneiras de simplificar um pouco a sua vida?  Existem: clang h√° algum tempo agora suporta o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagn√≥stico da</a> necessidade de chamar explicitamente a <code>move</code> , e h√° v√°rias propostas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P0527</a> ) no novo padr√£o que tornar√£o a <code>move</code> expl√≠cita menos necess√°ria. <br><br><h2>  Coisas para lembrar </h2><br><ol><li>  O RVO / NRVO funcionar√° apenas se: <br><ul><li>  √© inequivocamente conhecido qual objeto √∫nico deve ser criado no "slot de valor de retorno"; </li><li>  O objeto de retorno e os tipos de fun√ß√£o s√£o os mesmos. </li></ul></li><li>  Se houver ambiguidade no valor de retorno, ent√£o: <br><ul><li>  se os tipos do objeto e da fun√ß√£o retornados corresponderem, move ser√° chamado implicitamente; </li><li>  caso contr√°rio, voc√™ deve chamar explicitamente a movimenta√ß√£o. </li></ul></li><li>  Cuidado com o operador tern√°rio: √© conciso, mas pode exigir uma movimenta√ß√£o expl√≠cita. <br></li><li>  √â melhor usar compiladores com diagn√≥sticos √∫teis (ou pelo menos analisadores est√°ticos). <br></li></ol><br><h1>  Conclus√£o </h1><br>  E ainda assim eu amo C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465181/">https://habr.com/ru/post/pt465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465167/index.html">Planejamento de recursos. Por que isso n√£o funciona? Parte 1</a></li>
<li><a href="../pt465169/index.html">Fa√ßa voc√™ mesmo do PVS-Studio: Gamification of Achievements</a></li>
<li><a href="../pt465173/index.html">Como alterar o custo da assinatura criada no seu aplicativo. App Store Connect e Google Play Console</a></li>
<li><a href="../pt465177/index.html">Not New Relic's One: Um olhar sobre Datadog e Atatus</a></li>
<li><a href="../pt465179/index.html">A automa√ß√£o substituir√° o teste manual?</a></li>
<li><a href="../pt465185/index.html">Novos padr√µes de vigil√¢ncia por v√≠deo: cor √† noite, anti-ru√≠do, ePoE</a></li>
<li><a href="../pt465187/index.html">6 frases em ingl√™s que podem ser usadas em negocia√ß√µes salariais com empresas estrangeiras</a></li>
<li><a href="../pt465189/index.html">Equipe de desenvolvimento de uma sprint de fluxo de trabalho</a></li>
<li><a href="../pt465191/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 25. Estudo aprofundado do IPv6</a></li>
<li><a href="../pt465193/index.html">Construindo um projeto Android em um cont√™iner de docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>