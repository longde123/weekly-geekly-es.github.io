<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 👃🏾 🤽🏻 Lugares escorregadios em C ++ 17 🍛 🤹🏽 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos últimos anos, o C ++ deu trancos e barrancos, e acompanhar todas as sutilezas e complexidades da linguagem pode ser muito, muito difícil. Um novo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lugares escorregadios em C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="imagem"></a> <br><br>  Nos últimos anos, o C ++ deu trancos e barrancos, e acompanhar todas as sutilezas e complexidades da linguagem pode ser muito, muito difícil.  Um novo padrão não está muito longe, no entanto, a introdução de novas tendências não é o processo mais rápido e fácil, portanto, embora haja pouco tempo antes do C ++ 20, sugiro atualizar ou descobrir alguns lugares especialmente "escorregadios" do padrão atual idioma. <br><br>  Hoje, vou lhe dizer por que, se o constexpr não substitui as macros, quais são os "elementos internos" da ligação estruturada e suas "armadilhas" e é verdade que a cópia elision sempre funciona agora e você pode escrever qualquer retorno sem hesitação. <br><br>  Se você não tem medo de sujar um pouco as mãos, investigando o "interior" da sua língua, bem-vindo ao gato. <br><a name="habracut"></a><br><hr><br><h1>  se constexpr </h1><br>  Vamos começar pelo mais simples - <code>if constexpr</code> permitir descartar o ramo de expressão condicional para o qual a condição desejada não é atendida, mesmo no estágio de compilação. <br><br>  Parece que isso substitui a macro <code>#if</code> para desativar a lógica "extra"?  Não.  Nem um pouco. <br><br>  Primeiro, tal <code>if</code> tem propriedades que não estão disponíveis para macros - dentro você pode contar qualquer expressão <code>constexpr</code> que possa ser <code>constexpr</code> em <code>bool</code> .  Bem, e em segundo lugar, o conteúdo do ramo descartado deve estar sintático e semanticamente correto. <br><br>  Por causa do segundo requisito, <code>if constexpr</code> não puder ser usado, por exemplo, funções inexistentes (o código dependente da plataforma não pode ser explicitamente separado dessa maneira) ou incorreto do ponto de vista da linguagem de construção (por exemplo, “ <code>void T = 0;</code> ”). <br><br>  Qual é o sentido de usar <code>if constexpr</code> ?  O ponto principal está nos modelos.  Existe uma regra especial para eles: o ramo descartado não é instanciado quando o modelo é instanciado.  Isso facilita a gravação de código que, de alguma forma, depende das propriedades dos tipos de modelo. <br><br>  No entanto, nos modelos, não se deve esquecer que o código dentro dos ramos deve estar correto pelo menos para algumas instâncias (mesmo que potencialmente <code>static_assert(false)</code> ) de instanciação; portanto, é simplesmente <code>static_assert(false)</code> escrever, por exemplo, <code>static_assert(false)</code> dentro de um dos ramos (é necessário que isso <code>static_assert</code> dependia de algum parâmetro dependente do modelo). <br><br>  Exemplos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Coisas para lembrar </h2><br><ol><li>  O código em todas as ramificações deve estar correto. <br></li><li>  Nos modelos internos, o conteúdo das ramificações descartadas não é instanciado. <br></li><li>  O código dentro de qualquer ramificação deve estar correto para pelo menos uma variante puramente potencial de instanciação do modelo. <br></li></ol><br><h1>  Ligação estruturada </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  No C ++ 17, apareceu um mecanismo bastante conveniente para decompor vários objetos do tipo tupla, permitindo vincular de forma conveniente e concisa seus elementos internos a variáveis ​​nomeadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Por um objeto semelhante a uma tupla, entenderei um objeto para o qual seja conhecido o número de elementos internos disponíveis no momento da compilação (a partir de "tupla" - uma lista ordenada com um número fixo de elementos (vetor)). <br><br>  Essas definições se enquadram nessa definição como: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , matrizes no formato “ <code>T a[N]</code> ”, bem como várias estruturas e classes auto-escritas. <br><br>  Pare ... Você pode usar suas próprias estruturas na ligação estrutural?  Spoiler: você pode (embora às vezes precise trabalhar duro (mas mais sobre isso abaixo)). <br><br><h2>  Como isso funciona </h2><br>  O trabalho de vinculação estrutural merece um artigo separado, mas, como estamos falando especificamente de lugares “escorregadios”, tentarei explicar brevemente como tudo funciona. <br><br>  O padrão fornece a seguinte sintaxe para definir a ligação: <br><br>  <i>attr</i> (opcional) <i>expressão de</i> <i>cv-auto</i> <i>ref-operator</i> (opcional) [ <i>identifier-list</i> ]; <br><br><ul><li>  <code>attr</code> - lista de atributos opcional; <br></li><li>  <code>cv-auto</code> - auto com possíveis modificadores const / voláteis; <br></li><li>  <code>ref-operator</code> - especificador de referência opcional (&amp; ou &amp;&amp;); <br></li><li>  <code>identifier-list</code> - uma lista de nomes de novas variáveis; <br></li><li>  <code>expression</code> é uma expressão que resulta em um objeto semelhante a uma tupla usado para ligação (a expressão pode estar no formato " <code>= expr</code> ", " <code>{expr}</code> " ou " <code>(expr)</code> "). <br></li></ul><br>  É importante observar que o número de nomes na <code>identifier-list</code> deve corresponder ao número de elementos no objeto resultante da <code>expression</code> . <br><br>  Isso tudo permite que você escreva construções do formulário: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  E aqui chegamos ao primeiro local “escorregadio”: encontrar uma expressão da forma “ <code>auto a = expr;</code>  ", Você normalmente quer dizer que o tipo" <code>a</code> "será calculado pela expressão" <code>expr</code> "e espera que na expressão" <code>const auto&amp; [a,b,c] = expr;</code>  "O mesmo será feito, apenas os tipos para" <code>a,b,c</code> "serão os tipos <code>const&amp;</code> elemento correspondentes de" <code>expr</code> "... <br><br>  A verdade é diferente: o especificador “ <code>cv-auto ref-operator</code> ” é usado para calcular o tipo de uma variável invisível, na qual o resultado do cálculo de expr é atribuído (ou seja, o compilador substitui “ <code>const auto&amp; [a,b,c] = expr</code> ” por “ <code>const auto&amp; e = expr</code> "). <br><br>  Assim, uma nova entidade invisível aparece (a seguir denominarei {e}); no entanto, a entidade é muito útil: por exemplo, ela pode materializar objetos temporários (portanto, você pode conectá-los com segurança " <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  O segundo local escorregadio segue imediatamente a substituição que o compilador faz: se o tipo deduzido para {e} não for uma referência, o resultado de <code>expr</code> será copiado para {e}. <br><br>  Quais tipos as variáveis ​​terão na <code>identifier-list</code> ?  Para começar, essas não serão exatamente variáveis.  Sim, eles se comportam como variáveis ​​comuns reais, mas apenas com a diferença de que eles se referem a uma entidade associada a eles e o tipo de <code>decltype</code> dessa variável de "referência" produzirá o tipo de entidade a que essa variável se refere: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Os próprios tipos são definidos da seguinte maneira: <br><br><ol><li>  Se <b>{e}</b> for uma matriz ( <code>T a[N]</code> ), o tipo será um - T, os modificadores cv coincidirão com os da matriz. <br></li><li>  Se <b>{e}</b> for do tipo E e suportar a interface da tupla, as estruturas serão definidas: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  e função: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  então o tipo de cada variável será o tipo <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  Em outros casos, o tipo da variável corresponderá ao tipo de elemento da estrutura ao qual a ligação é realizada. <br></li></ol><br>  Portanto, se for muito breve, as seguintes etapas são executadas com o vínculo estrutural: <br><br><ol><li>  Cálculo do tipo e inicialização da entidade invisível {e} com base nos modificadores de tipo <code>expr</code> e <code>cv-ref</code> . <br></li><li>  Crie pseudo-variáveis ​​e associe-as a {e} elementos. <br></li></ol><br><h2>  Vincular estruturalmente suas classes / estruturas </h2><br>  O principal obstáculo para vincular suas estruturas é a falta de reflexão em C ++.  Até o compilador, que, ao que parece, deve saber com certeza como essa ou aquela estrutura é organizada, tem dificuldade: modificadores de acesso (público / privado / protegido) e herança complicam bastante as coisas. <br><br>  Devido a essas dificuldades, as restrições ao uso de suas classes são muito rígidas (pelo menos por enquanto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1096</a> ): <br><br><ol><li>  Todos os campos não estáticos internos de uma classe devem ser da mesma classe base e devem estar disponíveis no momento do uso. <br></li><li>  Ou a classe deve implementar "reflexão" (suporte à interface da tupla). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  A implementação da interface de tupla permite que você use qualquer uma de suas classes para ligação, mas ela parece um pouco complicada e traz outra armadilha.  Vamos usar imediatamente um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Agora ligamos: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  E é hora de pensar em quais tipos temos?  (Quem poderia responder imediatamente merece um delicioso docinho.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Resposta correta</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Por que isso aconteceu?  A resposta está na especialização padrão para <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> não adiciona <code>const</code> aos tipos de referência, portanto o tipo para <code>Foo</code> sempre será <code>int&amp;</code> . <br><br>  Como ganhar isso?  Basta adicionar especialização para <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Todos os tipos serão esperados: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  A propósito, o mesmo comportamento é verdadeiro para, por exemplo, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - você pode obter uma referência não constante ao elemento interno, mesmo que o próprio objeto seja constante. <br><br><h2>  Coisas para lembrar </h2><br><ol><li>  “ <code>cv-auto ref</code> ” em “ <code>cv-auto ref [a1..an] = expr</code> ” refere-se à variável invisível {e}. <br></li><li>  Se o tipo inferido {e} não for referenciado, {e} será inicializado copiando (com cuidado com classes “pesadas”). <br></li><li>  Variáveis ​​vinculadas são links "implícitos" (eles se comportam como links, embora <code>decltype</code> retorne um tipo não de referência para eles (a menos que a variável se refira a um link)). <br></li><li>  É necessário ter cuidado ao usar tipos de referência para encadernação. <br></li></ol><br><h1>  Otimização do valor de retorno (rvo, cópia elision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Talvez esse fosse um dos recursos mais discutidos do padrão C ++ 17 (pelo menos no meu círculo de amigos).  E de fato: o C ++ 11 trouxe a semântica do movimento, que simplificou bastante a transferência do "interno" do objeto e a criação de várias fábricas, e o C ++ 17 em geral, ao que parece, tornou possível não pensar em como devolver o objeto de qualquer método de fábrica , - agora tudo deve ficar sem copiar e, em geral, "logo tudo florescerá em Marte" ... <br><br>  Mas vamos ser um pouco realistas: otimizar o valor de retorno não é a coisa mais fácil de implementar.  Eu recomendo assistir a esta apresentação do cppcon2018: Arthur O'Dwyer “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Otimização do valor de retorno: mais difícil do que parece</a> ”, na qual o autor explica por que é difícil. <br><br>  Spoiler curto: <br><br>  Existe um "slot para o valor de retorno".  Esse slot é essencialmente apenas um lugar na pilha que é alocado por quem paga e passa para o chamado.  Se o código chamado souber exatamente qual objeto único será retornado, ele poderá simplesmente criá-lo imediatamente nesse slot diretamente (desde que o tamanho e o tipo do objeto e do slot sejam os mesmos). <br><br>  O que se segue disso?  Vamos desmontar com exemplos. <br><br>  Tudo vai ficar bem aqui - o NRVO funcionará, o objeto será construído imediatamente no "slot": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Aqui não é mais possível determinar inequivocamente qual objeto deve ser o resultado; portanto, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor de movimentação</a> (c ++ 11) será <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implicitamente chamado</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Aqui está um pouco mais complicado ... Como o tipo do valor de retorno é diferente do tipo declarado, não é possível chamar implicitamente a <code>move</code> , portanto o construtor de cópia é chamado por padrão.  Para impedir que isso aconteça, você precisa chamar explicitamente a <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Parece que é o mesmo que <code>foo2</code> , mas o operador ternário é uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coisa</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">peculiar</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Semelhante ao <code>foo4</code> , mas também um tipo diferente, portanto, <code>move</code> necessário <code>move</code> exatamente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Como você pode ver nos exemplos, ainda é preciso pensar em como retornar o significado, mesmo em casos aparentemente triviais ... Existem maneiras de simplificar um pouco a sua vida?  Existem: clang há algum tempo agora suporta o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagnóstico da</a> necessidade de chamar explicitamente a <code>move</code> , e há várias propostas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P0527</a> ) no novo padrão que tornarão a <code>move</code> explícita menos necessária. <br><br><h2>  Coisas para lembrar </h2><br><ol><li>  O RVO / NRVO funcionará apenas se: <br><ul><li>  é inequivocamente conhecido qual objeto único deve ser criado no "slot de valor de retorno"; </li><li>  O objeto de retorno e os tipos de função são os mesmos. </li></ul></li><li>  Se houver ambiguidade no valor de retorno, então: <br><ul><li>  se os tipos do objeto e da função retornados corresponderem, move será chamado implicitamente; </li><li>  caso contrário, você deve chamar explicitamente a movimentação. </li></ul></li><li>  Cuidado com o operador ternário: é conciso, mas pode exigir uma movimentação explícita. <br></li><li>  É melhor usar compiladores com diagnósticos úteis (ou pelo menos analisadores estáticos). <br></li></ol><br><h1>  Conclusão </h1><br>  E ainda assim eu amo C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465181/">https://habr.com/ru/post/pt465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465167/index.html">Planejamento de recursos. Por que isso não funciona? Parte 1</a></li>
<li><a href="../pt465169/index.html">Faça você mesmo do PVS-Studio: Gamification of Achievements</a></li>
<li><a href="../pt465173/index.html">Como alterar o custo da assinatura criada no seu aplicativo. App Store Connect e Google Play Console</a></li>
<li><a href="../pt465177/index.html">Not New Relic's One: Um olhar sobre Datadog e Atatus</a></li>
<li><a href="../pt465179/index.html">A automação substituirá o teste manual?</a></li>
<li><a href="../pt465185/index.html">Novos padrões de vigilância por vídeo: cor à noite, anti-ruído, ePoE</a></li>
<li><a href="../pt465187/index.html">6 frases em inglês que podem ser usadas em negociações salariais com empresas estrangeiras</a></li>
<li><a href="../pt465189/index.html">Equipe de desenvolvimento de uma sprint de fluxo de trabalho</a></li>
<li><a href="../pt465191/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 25. Estudo aprofundado do IPv6</a></li>
<li><a href="../pt465193/index.html">Construindo um projeto Android em um contêiner de docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>