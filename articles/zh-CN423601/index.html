<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖍️ 🙇🏼 🍖 工作系统和搜索路径 🐛 🗓️ 👩🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="地图 
 在上一篇文章中，我研究了新的Job系统是什么，它如何工作，如何创建任务，如何用数据填充它们并执行多线程计算，并且仅简要说明了在哪里可以使用此系统。 在本文中，我将尝试分析一个具体示例，说明可以在哪里使用此系统以获得更高的性能。 

 由于该系统最初是为处理数据而开发的，因此对于解决寻路任务...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>工作系统和搜索路径</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3> 地图 </h3><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我研究了新的<b>Job系统是</b>什么，它如何工作，如何创建任务，如何用数据填充它们并执行多线程计算，并且仅简要说明了在哪里可以使用此系统。 在本文中，我将尝试分析一个具体示例，说明可以在哪里使用此系统以获得更高的性能。 <br><a name="habracut"></a><br> 由于该系统最初是为处理数据而开发的，因此对于解决寻路任务非常有用。 <br><br>  <b>Unity</b>已经有了一个不错的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NavMesh路径查找器</a> ，但尽管在同一<i>资产</i>上有很多现成的解决方案，但它不适用于2D项目。 好吧，我们将不仅尝试创建一个系统，该系统将在创建的地图上查找路径，而且使该地图非常动态，以便每次对其进行更改时，系统都将创建一个新地图，当然我们将使用一个新的任务系统，以免加载主线程。 <br><br><div class="spoiler">  <b class="spoiler_title">系统操作示例</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="图片"><br></div></div><br> 在示例中，在地图上构建了一个网格，其中有一个机器人和一个障碍物。 每当我们更改地图的任何属性（无论大小或位置）时，都会重新构建网格。 <br><br> 对于飞机，我使用了一个简单的<b>SpriteRenderer</b> ，此组件具有出色的<b>bounds</b>属性，通过它可以轻松找出地图的大小。 <br><br> 基本上这只是一个开始，但我们不会停下来立即着手开展业务。 <br><br> 让我们从脚本开始。 第一个是障碍物脚本。 <br><br><div class="spoiler">  <b class="spoiler_title">障碍物</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br> 在<b>Obstacle</b>类中，我们将捕获地图上障碍物的所有变化，例如，更改对象的位置或大小。 <br> 接下来，您可以创建将在其上构建网格的<b>Map</b> map类，并从<b>Obstacle</b>类继承它。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  <b>Map</b>类还将跟踪<b>地图</b>上的所有更改，以便在必要时重建网格。 <br><br> 为此，用所有必需的变量和方法填充<b>Obstacle</b>基类，以跟踪对象的变化。 <br><br><div class="spoiler">  <b class="spoiler_title">障碍物</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br> 在这里， <b>renderer</b>变量将引用<b>SpriteRenderer</b>组件，并且<b>tempSize</b>和<b>tempPos变量</b>将用于跟踪对象的大小和位置的变化。 <br><br>  <b>Awake</b>虚拟方法将用于初始化变量，而<b>CheckChanges</b>虚拟方法将跟踪对象大小和位置的当前变化并返回<b>布尔</b>结果。 <br><br> 现在，让我们离开<b>Obstacle</b>脚本，继续前进到<b>Map</b> map脚本本身，在其中我们还为工作填充了必要的参数。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  <b>nodeSize</b>变量将指示地图上像元的大小，这里我将其大小限制为0.1到1，这样网格上的像元不会太小，但也太大。 构造网格时， <b>偏移量</b>变量将用于缩进地图，以使网格不会沿地图的边缘生成。 <br><br> 由于现在在地图上有两个新变量，因此事实证明，还需要跟踪它们的更改。 为此，请添加几个变量，并在<b>Map</b>类中重载<b>CheckChanges</b>方法。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br> 做完了 现在，您可以在舞台上创建一个地图精灵，并在其上放置一个<b>地图</b>脚本。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="图片"><br><br> 我们将在障碍物上做同样的事情-在舞台上创建一个简单的精灵，并在上面<b>放上Obstacle</b>脚本。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="图片"><br><br> 现在我们在舞台上有地图对象和障碍物。 <br><br>  <b>Map</b>脚本将负责跟踪地图上的所有更改，在<b>Update</b>方法中，我们将检查每个框架的更改。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br> 因此，在<b>UpdateChanges</b>方法中<b>，</b>地图将仅跟踪到目前为止的更改。 您甚至可以立即开始游戏，并尝试更改地图的大小或<b>偏移偏移</b> ，以确保跟踪所有更改。 <br><br> 现在，您需要以某种方式在地图上跟踪障碍物本身的变化。 为此，我们将每个障碍物放置在地图上的列表中，该列表又将更新<b>Update</b>方法中的每个帧。 <br><br> 在<b>Map</b>类中，创建一个<b>地图</b>上所有可能障碍物的列表以及一些用于注册它们的静态方法。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br> 在静态<b>RegisterObstacle</b>方法中，我们将在地图上注册一个新的<b>Obstacle</b>障碍物并将其添加到列表中，但首先必须考虑到地图本身也是从<b>Obstacle</b>类继承的，因此，我们需要检查是否要尝试将卡本身注册为障碍物。 <br><br> 相反，静态的<b>UnregisterObstacle</b>方法从地图上消除了障碍物，并在我们允许销毁该障碍物时将其从列表中删除。 <br><br> 同时，每次我们在地图上添加或移除障碍物时，都必须重新创建地图本身，因此在执行这些静态方法后，将<b>requireRebuild</b>变量设置为<b>true</b> 。 <br><br> 另外，为了方便地从任何脚本访问<b>Map</b>脚本，我创建了一个静态<b>Instance</b>属性，该属性将返回给我<b>Map的</b>这个实例。 <br><br> 现在，让我们回到<b>Obstacle</b>脚本中，在地图上注册障碍物，为此，请添加几个<b>OnEnable</b>和<b>OnDisable</b>方法。 <br><br><div class="spoiler">  <b class="spoiler_title">障碍物</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br> 每次我们在地图上玩游戏时创建一个新障碍物时，它将自动在<b>OnEnable</b>方法中注册，在构建新网格时会考虑到它，并在销毁或禁用它时使用<b>OnDisable</b>方法将自己从地图上<b>移开</b> 。 <br><br> 它仅用于在重载的<b>CheckChanges</b>方法中跟踪<b>Map</b>脚本中障碍本身的变化。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br> 现在，我们有了地图，遇到了障碍-一般来说，构建网格所需的一切，现在您可以继续进行最重要的事情。 <br><br><h4> 网格划分 </h4><br> 最简单的网格是点的二维数组。 要构建它，您需要知道地图的大小和其上的点的大小，经过一些计算，我们得到了水平和垂直的点数，这就是我们的网格。 <br><br> 有多种方法可以在网格上找到路径。 但是，在本文中，最主要的是要了解如何正确使用任务系统的功能，因此在这里，我将不考虑用于查找路径的各种选项，它们的优缺点，但是将采用最简单的搜索选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">A *</a> 。 <br><br> 在这种情况下，除了位置之外，网格上的所有点都应具有坐标和通畅性。 <br><br> 有了通畅性，我认为一切都清楚为什么会需要它，但是坐标将指示点在网格上的顺序，这些坐标并不专门与点在空间中的位置相关。 下图显示了一个简单的网格，显示了与位置的坐标差异。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="图片"><br>  <i>为什么要坐标？</i> <br> 事实是，为了统一表示一个对象在空间中的位置， <b>使用</b>了一个非常不准确的简单<b>浮点</b> ，它可能是分数或负数，因此很难用它来在地图上实现路径搜索。 坐标以清晰的<b>int</b>形式生成，该<b>int</b>始终为正，并且在搜索相邻点时更容易使用。 <br><br> 首先，让我们定义一个点对象，这将是一个简单的<b>Node</b>结构。 <br><br><div class="spoiler">  <b class="spoiler_title">结点</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br> 该结构将包含<b>Vector2</b>形式的<b>位置</b> ，其中使用此变量，我们将在空间中绘制一个点。  <b>Vector2Int</b>形式的<b>coords</b>坐标<b>变量</b>将指示地图上某个点的坐标，而<b>id</b>变量（其数字帐号）将使用它来比较网格上的不同点并检查是否存在点。 <br><br> 该点的开放性将以其<b>boolean</b>属性的形式表示，但是由于我们无法在任务系统中使用<i>可转换</i>数据<i>类型</i> ，因此我们将以<b>int</b>数的形式指示其开放性，为此，我使用了一个简单的枚举<b>NodeType</b> ，其中：0不是可传递的点， 1是合格的。 <br><br><div class="spoiler">  <b class="spoiler_title">NodeType和Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br> 另外，为了方便处理点，我将重载<b>Equals</b>方法，以使其更容易比较点，并补充存在点的验证方法。 <br><br><div class="spoiler">  <b class="spoiler_title">结点</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br> 由于网格上点的<b>ID</b>号以1个单位开头，因此我将检查点是否存在，以作为其<b>ID</b>大于0的条件。 <br><br> 转到<b>Map</b>类，我们将为创建地图做准备。 <br> 我们已经进行了更改地图参数的检查，现在我们需要确定如何执行构建网格的过程。 为此，创建一个新变量和几种方法。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  <b>重建</b>属性将指示<b>网格划分</b>过程是否正在进行。  <b>Rebuild</b>方法将收集用于构建网格的数据和任务，然后<b>OnRebuildStart</b>方法将启动网格构建过程，而<b>OnRebuildFinish</b>方法将从任务中收集数据。 <br><br> 现在，让我们<b>稍微</b>更改<b>UpdateChanges</b>方法，以便考虑网格条件。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br> 如您现在所看到的，在<b>UpdateChanges</b>方法中<b>存在</b>一个条件，即在构建旧网格时不会开始开始构建新的网格，在<b>Rebuild</b>方法中，第一个操作将检查网格划分过程是否已在进行中。 <br><br><h4> 解决问题 </h4><br> 现在介绍一下构建地图的过程。 <br> 由于我们将使用任务系统并并行构建网格来构建地图，因此我使用了<b>IJobParallelFor</b>任务的类型，该任务将执行一定的次数。 为了不使用任何一个单独的任务加载构建过程，我们将使用打包到一个<b>JobHandle中</b>的任务池。 <br><br> 通常，要构建网格，请使用彼此嵌套的两个循环来构建，例如水平和垂直。 在此示例中，我们还将先水平然后再垂直构建网格。 为此，我们在<b>Rebuild</b>方法中计算水平点和垂直点的数量，然后在<b>Rebuild</b>方法中沿着垂直点进行循环，然后在任务中并行构建水平点。 为了更好地想象构建过程，请看下面的动画。 <br><br><div class="spoiler">  <b class="spoiler_title">网格划分</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="图片"><br></div></div><br> 垂直点的数量将指示任务的数量，依次，每个任务将仅水平构建点，完成所有任务后，将这些点汇总到一个列表中。 这就是为什么我需要使用类似<b>IJobParallelFor</b>的任务来将网格上的点的索引水平传递到<b>Execute</b>方法中的原因。 <br><br> 因此，我们有了点结构，现在您可以创建<b>Job</b>任务的结构并从<b>IJobParallelFor</b>接口继承它，这里的一切都很简单。 <br><br><div class="spoiler">  <b class="spoiler_title">工作机会</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br> 返回到<b>Map</b>类的<b>Rebuild</b>方法，在此我们将为网格测量进行必要的计算。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br> 在<b>Rebuild</b>方法中，我们考虑缩进来计算<b>mapSize</b>地图的确切大小，然后在<b>垂直方向上垂直</b>写入点数，在<b>水平方向上水平</b>写入点数。 如果垂直点的数量为0，则我们停止构建地图，并调用<b>OnRebuildFinish</b>方法以完成该过程。  <b>origin</b>变量将指示我们将开始构建网格的位置-在示例中，这是地图上的左下角。 <br><br> 现在，您可以转到任务本身，并用数据填充它们。 <br> 在构建网格的过程中，任务将需要一个将要放置点的<b>NativeArray</b>数组，而且由于我们在地图上有障碍物，我们也需要将它们传递给任务，为此，我们将使用另一个<b>NativeArray</b>数组，然后我们需要问题中点的大小，即我们将在其上构建点的初始位置以及序列的初始坐标。 <br><br><div class="spoiler">  <b class="spoiler_title">工作机会</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br> 我用属性<b>WriteOnly</b>标记了点数组<b>，</b>因为在任务中只需要将接收到的点“ <i>写入</i> ”到数组中，相反，障碍物<b>边界</b>的数组将用<b>ReadOnly</b>属性标记，因为在任务中我们将仅从该数组中“ <i>读取</i> ”数据。 <br><br> 好了，现在让我们稍后再进行点本身的计算。 <br><br> 现在回到<b>Map</b>类，我们在其中表示任务中涉及的所有变量。 <br> 首先，我们需要一个全局<b>的</b>任务<b>句柄</b> ，一个<b>NativeArray</b>形式的障碍数组，一个任务列表，其中将包含在网格上接收到的所有点和在<b>字典</b>上具有地图上所有坐标和点的所有点，以便以后搜索它们会更加方便。 <br><br><div class="spoiler">  <b class="spoiler_title">地图</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br> 再一次，我们返回<b>Rebuild</b>方法并继续构建网格。 <br> 首先，初始化障碍的<b>bounds</b>数组以将其传递给任务。 <br><br><div class="spoiler">  <b class="spoiler_title">改建</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br> 在这里，我们通过带有三个参数的新构造函数创建<b>NativeArray</b>的实例。 我在上一篇文章中检查了前两个参数，但是第三个参数将帮助我们节省创建数组的时间。 事实是，我们将在创建数组后立即将数据写入数组，这意味着我们无需确保将其清除。 此参数对<b>NativeArray</b>很有用，它将仅在任务的<i>读取</i>模式下使用。 <br><br> 因此，然后我们用数据填充<b>bounds</b>数组。 <br><br><div class="spoiler">  <b class="spoiler_title">改建</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br> 现在我们可以继续创建任务，为此，我们将循环遍历网格的所有垂直行。 <br><br><div class="spoiler">  <b class="spoiler_title">改建</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br> 首先，在<b>xPos</b>和<b>yPos中，</b>我们获得序列的初始水平位置。 <br><br><div class="spoiler">  <b class="spoiler_title">改建</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br> 接下来，我们创建一个简单的<b>NativeArray</b> ，在该位置将放置任务中的点，在此<b>数组中，</b>您需要指定水平创建的点数和分配类型<b>Persistent</b> ，因为该任务可能需要一帧以上的时间。 <br> 之后，创建<b>Job</b>任务实例本身，将<b>startCoords</b>系列的初始坐标， <b>startPos</b>系列的初始位置， <b>nodeSize</b>点的大小，障碍的<b>边界</b>数组以及点本身的数组放在末尾。 <br> 仅保留将任务置于<b>句柄</b>和全局任务列表中。 <br><br><div class="spoiler">  <b class="spoiler_title">改建</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br> 做完了 我们有一个任务及其公共<b>句柄</b>的列表，现在我们可以<b>通过</b>在<b>OnRebuildStart</b>方法中调用其<b>Complete</b>方法来运行此<b>句柄</b> 。 <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br> 由于<b>重建</b>变量将指示<b>网格划分</b>过程正在进行中，因此<b>UpdateChanges</b>方法<b>本身</b>也必须指定此过程将使用<b>handle</b>及其<b>IsCompleted</b>属性结束的条件。 <br><br><div class="spoiler">  <b class="spoiler_title">更新变更</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br> 完成任务后，将调用<b>OnRebuildFinish</b>方法，在<b>该</b>方法中，我们已经将接收到的点收集到一个常规<b>Dictionary</b>列表中，最重要的是，清除了占用的资源。 <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们</font><font style="vertical-align: inherit;">从之前的点中</font><font style="vertical-align: inherit;">清除</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字典</font><font style="vertical-align: inherit;">，然后使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foreach循环对</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从任务中接收到的所有点</font><b><font style="vertical-align: inherit;">进行</font></b><font style="vertical-align: inherit;">排序</font><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">将它们放入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字典中</font><font style="vertical-align: inherit;">，其中键是点的坐标（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是位置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！），而值是点本身。</font><font style="vertical-align: inherit;">有了这本词典的帮助，我们将可以更轻松地在地图上搜索相邻点。</font><font style="vertical-align: inherit;">填充后，我们</font><font style="vertical-align: inherit;">使用</font><b><font style="vertical-align: inherit;">Dispose</font></b><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">清除数组</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，最后清除</font><b><font style="vertical-align: inherit;">作业</font></b><font style="vertical-align: inherit;">任务列表本身</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果它是先前创建的，</font><font style="vertical-align: inherit;">则还需要清除障碍的</font><b><font style="vertical-align: inherit;">边界</font></b><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完成所有这些操作之后，我们将获得地图上所有点的列表，现在您可以在舞台上绘制它们。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像这样</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="图片"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，请在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类中</font><font style="vertical-align: inherit;">创建</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，在该</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">中绘制点。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，通过循环绘制每个点。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成所有这些操作后，我们的地图看起来有些无聊，为了真正获得网格，您需要将各个点相互连接。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网眼</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="图片"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要搜索相邻点，我们只需要通过其在8个方向上的坐标来查找所需的点，因此在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类中，我们将</font><font style="vertical-align: inherit;">通过其</font><b><font style="vertical-align: inherit;">GetNode</font></b><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">创建一个简单的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向的静态数组</font><font style="vertical-align: inherit;">和一个单元格搜索方法</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">将按</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表中的坐标返回一个点</font><font style="vertical-align: inherit;">，但是您需要仔细进行此操作，因为如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">不正确，则会发生错误，因此在这里我们使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常绕过</font><b><font style="vertical-align: inherit;">块</font></b><font style="vertical-align: inherit;">，它将帮助绕过该异常而不是</font><font style="vertical-align: inherit;">使整个应用程序因错误</font><font style="vertical-align: inherit;">而</font><b><font style="vertical-align: inherit;">`` </font></b></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挂起</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ''。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将遍历所有方向，并尝试在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中找到相邻的点</font><font style="vertical-align: inherit;">，最重要的是，不要忘记考虑点的通畅性。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在您可以安全地开始游戏，看看发生了什么。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态地图</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="图片"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此示例中，我们仅使用任务构建了图本身，但这是在我将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法本身拧入系统后发生的事情</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">算法本身</font><font style="vertical-align: inherit;">也使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job系统</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来查找路径，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即本文结尾处的源</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图和路径搜索</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="图片"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，您可以轻松地将新任务系统用于目标并构建有趣的系统。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与上一篇文章一样，该任务系统在没有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况下使用</font><font style="vertical-align: inherit;">，但是如果将此系统与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合使用</font><font style="vertical-align: inherit;">，则可以在性能提升方面获得令人称奇的结果。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祝你好运</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径查找器项目源</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423601/">https://habr.com/ru/post/zh-CN423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423589/index.html">我们如何选择TTS作为字典中的声音示例</a></li>
<li><a href="../zh-CN423591/index.html">关于主要内容的旧歌。 Java和外发请求</a></li>
<li><a href="../zh-CN423593/index.html">Google宣布一项针对机器视觉算法的攻击竞赛</a></li>
<li><a href="../zh-CN423595/index.html">Frango Anomaly，交汇处</a></li>
<li><a href="../zh-CN423597/index.html">如何以及在客户群中分配哪些集群</a></li>
<li><a href="../zh-CN423603/index.html">RxSwift第1部分</a></li>
<li><a href="../zh-CN423607/index.html">莱纳斯·托瓦尔兹（Linus Torvalds）放弃了硬派风格并抽出时间</a></li>
<li><a href="../zh-CN423609/index.html">网站死后该去哪里？ 个人经历</a></li>
<li><a href="../zh-CN423611/index.html">一键式付款-好还是坏？</a></li>
<li><a href="../zh-CN423615/index.html">用户体验专家要求的专业技能（2018年切片）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>