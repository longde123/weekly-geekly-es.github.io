<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∞ üÜî üèôÔ∏è Blitz Engine & Battle Prime: ECS und Netzwerkcode üñïüèΩ üçª üßîüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Battle Prime ist das erste Projekt unseres Studios. Trotz der Tatsache, dass viele Mitglieder des Teams gute Erfahrung in der Entwicklung von Spielen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blitz Engine & Battle Prime: ECS und Netzwerkcode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469709/"><img src="https://habrastorage.org/webt/xi/ez/ao/xiezaordrjuxu_maz07nn1wdtqe.jpeg"><br><br>  <b>Battle Prime</b> ist das erste Projekt unseres Studios.  Trotz der Tatsache, dass viele Mitglieder des Teams gute Erfahrung in der Entwicklung von Spielen haben, hatten wir nat√ºrlich verschiedene Schwierigkeiten, als wir daran arbeiteten.  Sie entstanden sowohl bei der Arbeit an der Engine als auch bei der Entwicklung des Spiels. <br><br>  In der Gamedev-Branche gibt es eine gro√üe Anzahl von Entwicklern, die bereitwillig ihre Geschichten, Best Practices und Architekturentscheidungen in der einen oder anderen Form teilen.  Diese Erfahrung, die im √∂ffentlichen Raum in Form von Artikeln, Pr√§sentationen und Berichten pr√§sentiert wird, ist eine hervorragende Quelle f√ºr Ideen und Inspirationen.  Zum Beispiel waren die Berichte des Overwatch-Entwicklungsteams f√ºr uns bei der Arbeit am Motor sehr n√ºtzlich.  Wie das Spiel selbst sind sie sehr talentiert und ich rate jedem, der daran interessiert ist, sie zu sehen.  Verf√ºgbar im GDC-Tresor und auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouTube</a> . <br><br>  Dies ist einer der Gr√ºnde, warum wir auch zur gemeinsamen Sache beitragen wollen - und dieser Artikel ist einer der ersten, der sich mit den technischen Details der Entwicklung und des Spielens der Blitz-Engine befasst - Battle Prime. <br><br>  Der Artikel wird in zwei Teile unterteilt: <br><br><ul><li>  ECS: Implementierung des Entity-Component-System-Musters in der Blitz Engine.  Dieser Abschnitt ist wichtig f√ºr das Verst√§ndnis der Codebeispiele im Artikel und an sich ein separates interessantes Thema. </li><li>  Netcode und Gameplay: Alles √ºber den High-Level-Netzwerkteil und seine Verwendung im Spiel - Client-Server-Architektur, Client-Vorhersagen, Replikation.  Eines der wichtigsten Dinge in einem Sch√ºtzen ist das Schie√üen, daher wird mehr Zeit daf√ºr aufgewendet. </li></ul><br>  <i>Unter dem Schnitt viele Megabyte Gifs!</i> <br><a name="habracut"></a><br>  In jedem Abschnitt werde ich zus√§tzlich zu der Geschichte √ºber die Funktionalit√§t und ihre Verwendung versuchen, die M√§ngel zu beschreiben, die sie in sich tr√§gt - sei es ihre Grenzen, Unannehmlichkeiten bei der Arbeit oder nur Gedanken √ºber ihre Verbesserungen in der Zukunft. <br><br>  Ich werde auch versuchen, Codebeispiele und einige Statistiken zu geben.  Erstens ist es nur interessant, und zweitens gibt es einen kleinen Kontext zum Umfang der Verwendung dieser oder jener Funktionalit√§t und dieses Projekts. <br><br><h1>  ECS </h1><br>  Innerhalb der Engine verwenden wir den Begriff ‚ÄûWelt‚Äú, um eine Szene zu beschreiben, die eine Hierarchie von Objekten enth√§lt. <br><br>  Welten arbeiten nach der Vorlage Entity-Component-System ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung auf Wikipedia</a> ): <br><br><ul><li>  Entit√§t - ein Objekt innerhalb der Szene.  Es ist ein Repository f√ºr eine Reihe von Komponenten.  Objekte k√∂nnen verschachtelt werden und eine Hierarchie innerhalb der Welt bilden. </li><li>  Komponente - sind die Daten, die f√ºr den Betrieb einer Mechanik erforderlich sind und die das Verhalten des Objekts bestimmen.  Beispielsweise enth√§lt "TransformComponent" die Transformation des Objekts und "DynamicBodyComponent" enth√§lt Daten f√ºr die physikalische Simulation.  Einige Komponenten verf√ºgen m√∂glicherweise nicht √ºber zus√§tzliche Daten. Ihre einfache Anwesenheit im Objekt beschreibt den Status dieses Objekts.  In Battle Prime werden beispielsweise "AliveComponent" und "DeadComponent" verwendet, die lebende bzw. tote Charaktere markieren. </li><li>  System - ein regelm√§√üig genannter Satz von Funktionen, die die L√∂sung seiner Aufgabe unterst√ºtzen.  Bei jedem Aufruf verarbeitet das System Objekte, die eine bestimmte Bedingung erf√ºllen (normalerweise mit einem bestimmten Satz von Komponenten), und √§ndert sie gegebenenfalls.  Die gesamte Spielelogik und der gr√∂√üte Teil der Engine werden auf Systemebene implementiert.  In der Engine befindet sich beispielsweise ein "LodSystem", das die LOD-Indizes (Detaillierungsgrad) f√ºr ein Objekt basierend auf seiner Transformation in der Welt und anderen Daten berechnet.  Dieser in der `LodComponent` enthaltene Index wird dann von anderen Systemen f√ºr ihre Aufgaben verwendet. </li></ul><br>  Dieser Ansatz macht es einfach, verschiedene Mechaniken innerhalb eines Objekts zu kombinieren.  Sobald die Entit√§t gen√ºgend Daten f√ºr die Arbeit einiger Mechaniker erh√§lt, beginnen die f√ºr diese Mechanik verantwortlichen Systeme, dieses Objekt zu verarbeiten. <br><br>  In der Praxis reduziert sich das Hinzuf√ºgen einer neuen Funktion auf eine neue Komponente (oder einen Satz von Komponenten) und ein neues System (oder einen Satz von Systemen), die diese Funktion implementieren.  In den allermeisten F√§llen ist es praktisch, an diesem Muster zu arbeiten. <br><br><h2>  Reflexion </h2><br>  Bevor ich mit der Beschreibung von Komponenten und Systemen fortfahre, werde ich ein wenig auf den Reflexionsmechanismus eingehen, da er h√§ufig in Codebeispielen verwendet wird. <br><br>  Mit Reflection k√∂nnen Sie Informationen zu Typen empfangen und verwenden, w√§hrend die Anwendung ausgef√ºhrt wird.  Insbesondere stehen folgende Funktionen zur Verf√ºgung: <br><br><ul><li>  Holen Sie sich eine Liste von Typen nach einem bestimmten Kriterium (zum Beispiel die Erben einer Klasse oder mit einem speziellen Tag), </li><li>  Holen Sie sich eine Liste der Klassenfelder, </li><li>  Holen Sie sich eine Liste der Methoden innerhalb der Klasse, </li><li>  Holen Sie sich eine Liste der Aufz√§hlungswerte, </li><li>  Rufen Sie eine Methode auf oder √§ndern Sie den Wert eines Feldes. </li><li>  Ruft die Metadaten eines Felds oder einer Methode ab, die f√ºr eine bestimmte Funktion verwendet werden k√∂nnen. </li></ul><br>  Viele Module im Motor verwenden die Reflexion f√ºr ihre eigenen Zwecke.  Einige Beispiele: <br><br><ul><li>  Integrationen von Skriptsprachen verwenden Reflection, um mit in C ++ - Code deklarierten Typen zu arbeiten. </li><li>  Der Editor verwendet Reflection, um eine Liste der Komponenten zu erhalten, die dem Objekt hinzugef√ºgt werden k√∂nnen, sowie um deren Felder anzuzeigen und zu bearbeiten. </li><li>  Das Netzwerkmodul verwendet die Feldmetadaten in den Komponenten f√ºr eine Reihe von Funktionen: Sie geben die Parameter f√ºr das Replizieren von Feldern vom Server auf Clients, die Datenquantisierung w√§hrend der Replikation usw. an. </li><li>  Verschiedene Konfigurationen werden unter Verwendung von Reflexion in Objekte der entsprechenden Typen deserialisiert. </li></ul><br>  Wir verwenden unsere eigene Implementierung, deren Benutzeroberfl√§che sich nicht wesentlich von anderen vorhandenen L√∂sungen unterscheidet (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/rttrorg/rttr</a> ).  Am Beispiel von CapturePointComponent (das den Erfassungspunkt f√ºr den Spielmodus beschreibt) sieht das Hinzuf√ºgen von Reflexionen zum Typ folgenderma√üen aus: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     class CapturePointComponent final : public Component { //            BZ_VIRTUAL_REFLECTION(Component); public: float points_to_own = 10.0f; String visible_name; // ‚Ä¶   }; //   .cpp  BZ_VIRTUAL_REFLECTION_IMPL(CapturePointComponent) { //       ReflectionRegistrar::begin_class&lt;CapturePointComponent&gt;() [M&lt;Serializable&gt;(), M&lt;Scriptable&gt;(), M&lt;DisplayName&gt;("Capture point")] //      .field("points_to_own", &amp;CapturePointComponent::points_to_own) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Points to own")] .field("visible_name", &amp;CapturePointComponent::visible_name) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Name")] // ‚Ä¶     }</span></span></code> </pre> <br>  Ich m√∂chte besonders auf die Metadaten von Typen, Feldern und Methoden achten, die mit dem Ausdruck deklariert werden <br><br><pre> <code class="cpp hljs">M&lt;T&gt;()</code> </pre> <br>  Dabei ist "T" der Typ der Metadaten (innerhalb des Befehls verwenden wir nur den Begriff "Meta", in Zukunft werde ich ihn verwenden).  Sie werden von verschiedenen Modulen f√ºr ihre eigenen Zwecke verwendet.  Beispielsweise verwendet der Editor "DisplayName", um Typnamen und Felder im Editor anzuzeigen, und das Netzwerkmodul empf√§ngt eine Liste aller Komponenten und sucht unter anderem nach Feldern, die als "Replizierbar" gekennzeichnet sind. Diese werden vom Server an die Clients gesendet. <br><br><h2>  Beschreibung der Komponenten und deren Hinzuf√ºgung zum Objekt </h2><br>  Jede Komponente ist ein Erbe der Basisklasse "Komponente" und kann mit Hilfe der Reflexion die von ihr verwendeten Felder beschreiben (falls erforderlich). <br><br>  So wird die "AvatarHitComponent" im Spiel deklariert und beschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Component that indicates avatar hit event. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AvatarHitComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component { BZ_VIRTUAL_REFLECTION(Component); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PlayerId source_id = NetConstants::INVALID_PLAYER_ID; PlayerId target_id = NetConstants::INVALID_PLAYER_ID; HitboxType hitbox_type = HitboxType::UNKNOWN; }; BZ_VIRTUAL_REFLECTION_IMPL(AvatarHitComponent) { ReflectionRegistrar::begin_class&lt;AvatarHitComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"source_id"</span></span>, &amp;AvatarHitComponent::source_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"target_id"</span></span>, &amp;AvatarHitComponent::target_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"hitbox_type"</span></span>, &amp;AvatarHitComponent::hitbox_type)[M&lt;Replicable&gt;()]; }</code> </pre> <br>  Diese Komponente markiert ein Objekt, das erstellt wird, wenn ein Spieler einen anderen Spieler schl√§gt.  Es enth√§lt Informationen zu diesem Ereignis, z. B. die Kennungen des angreifenden Spielers und seines Ziels sowie die Art der Trefferbox, auf der der Treffer aufgetreten ist. <br>  Einfach ausgedr√ºckt wird dieses Objekt auf √§hnliche Weise im Serversystem erstellt: <br><br><pre> <code class="cpp hljs">Entity hit_entity = world-&gt;create_entity(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avatar_hit_component = hit_entity.add&lt;AvatarHitComponent&gt;(); avatar_hit_component-&gt;source_id = source_player_id; avatar_hit_component-&gt;target_id = target_player_id; avatar_hit_component-&gt;hitbox_type = hitbox_type; <span class="hljs-comment"><span class="hljs-comment">//      //      // ...</span></span></code> </pre> <br>  Das Objekt mit der "AvatarHitComponent" wird dann von verschiedenen Systemen verwendet: um die Ger√§usche von Schlagern zu spielen, Statistiken zu sammeln, Spielererfolge zu verfolgen und so weiter. <br><br><h2>  Beschreibung der Systeme und ihrer Arbeit </h2><br>  Ein System ist ein Objekt mit einem von "System" geerbten Typ, der Methoden enth√§lt, die eine bestimmte Aufgabe implementieren.  In der Regel reicht eine Methode aus.  Es sind mehrere Methoden erforderlich, wenn sie zu unterschiedlichen Zeitpunkten innerhalb desselben Frames durchgef√ºhrt werden m√ºssen. <br><br>  √Ñhnlich wie die Komponenten, die ihre Felder beschreiben, beschreibt jedes System die Methoden, die von der Welt ausgef√ºhrt werden sollten. <br><br>  Beispielsweise wird das f√ºr die Explosionen verantwortliche ExplosiveSystem wie folgt deklariert und beschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// System responsible for handling explosive components: // - tracking when they need to be exploded: by timer, trigger zone etc. // - destroying them on explosion and creating separate explosion entity class ExplosiveSystem final : public System { BZ_VIRTUAL_REFLECTION(System); public: ExplosiveSystem(World* world); private: void update(float dt); //    ,     // ... }; BZ_VIRTUAL_REFLECTION_IMPL(ExplosiveSystem) { ReflectionRegistrar::begin_class&lt;ExplosiveSystem&gt;()[M&lt;SystemTags&gt;("battle")] .ctor_by_pointer&lt;World*&gt;() .method("ExplosiveSystem::update", &amp;ExplosiveSystem::update)[M&lt;SystemTask&gt;( TaskGroups::GAMEPLAY_END, ReadAccess::set&lt; TimeSingleComponent, WeaponDescriptorComponent, BallisticComponent, ProjectileComponent, GrenadeComponent&gt;(), WriteAccess::set&lt;ExplosiveComponent&gt;(), InitAccess::set&lt;ExplosiveStatsComponent, LocalExplosionComponent, ServerExplosionComponent, EntityWasteComponent, ReplicationComponent, AbilityIdComponent, WeaponBaseStatsComponent, HitDamageStatsComponent, ClusterGrenadeStatsComponent&gt;(), UpdateType::FIXED, Vector&lt;TaskOrder&gt;{ TaskOrder::before(FastName{ "ballistic_update" }) })]; }</span></span></code> </pre> <br>  Die folgenden Daten sind in der Systembeschreibung angegeben: <br><br><ul><li>  Das Tag, zu dem das System geh√∂rt.  Jede Welt enth√§lt eine Reihe von Tags, auf denen sich die Systeme befinden, die in dieser Welt funktionieren sollten.  In diesem Fall bedeutet das "Schlacht" -Tag die Welt, in der der Kampf zwischen den Spielern stattfindet.  Andere Beispiele f√ºr Tags sind "Server" und "Client" (das System wird nur auf dem Server bzw. Client ausgef√ºhrt) und "Rendern" (das System wird nur im GUI-Modus ausgef√ºhrt). </li><li>  Die Gruppe, in der dieses System ausgef√ºhrt wird, und die Liste der Komponenten, die dieses System verwendet - zum Schreiben, Lesen und Erstellen; </li><li>  Update-Typ - Gibt an, ob dieses System bei normalen Updates, festen Updates oder anderen funktionieren soll. </li><li>  Explizite Berechtigungsabh√§ngigkeiten zwischen Systemen. </li></ul><br>  Weitere Informationen zu Systemgruppen, Abh√§ngigkeiten und Aktualisierungstypen werden nachfolgend beschrieben. <br><br>  Deklarierte Methoden werden von der Welt zum richtigen Zeitpunkt aufgerufen, um die Funktionalit√§t dieses Systems aufrechtzuerhalten.  Der Inhalt der Methode h√§ngt vom System ab. In der Regel werden jedoch alle Objekte durchlaufen, die die Kriterien dieses Systems erf√ºllen, und anschlie√üend aktualisiert.  Das "ExplosiveSystem" im Spiel wird beispielsweise wie folgt aktualisiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExplosiveSystem::update(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* time_single_component = world-&gt;get&lt;TimeSingleComponent&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Init new explosives for (Component* component : new_explosives_group-&gt;components) { auto* explosive_component = static_cast&lt;ExplosiveComponent*&gt;(component); init_explosive(explosive_component, time_single_component); } new_explosives_group-&gt;components.clear(); // Update all explosives for (ExplosiveComponent* explosive_component : explosives_group) { update_explosive(explosive_component, time_single_component, dt); } }</span></span></code> </pre> <br>  Die Gruppen im obigen Beispiel (`new_explosives_group` und` explosives_group`) sind Hilfscontainer, die die Systemimplementierung vereinfachen.  new_explosives_group ist ein Container mit neuen Objekten, die f√ºr dieses System erforderlich sind und noch nie verarbeitet wurden, und explosives_group ist ein Container mit allen Objekten, die in jedem Frame verarbeitet werden m√ºssen.  Die Welt ist direkt f√ºr das Bef√ºllen dieser Beh√§lter verantwortlich.  Ihr Empfang beim System erfolgt in seinem Konstruktor: <br><br><pre> <code class="cpp hljs">ExplosiveSystem::ExplosiveSystem(World* world) : System(world) { <span class="hljs-comment"><span class="hljs-comment">// `explosives_group`        `ExplosiveComponent` explosives_group = world-&gt;acquire_component_group&lt;ExplosiveComponent&gt;(); // `new_explosives_group`        //  `ExplosiveComponent` -       new_explosives_group = explosive_group-&gt;acquire_component_group_on_add(); }</span></span></code> </pre> <br><h2>  Welt Update </h2><br>  Die Welt, ein Objekt vom Typ "Welt", ruft in jedem Frame die notwendigen Methoden in einer Reihe von Systemen auf.  Welche Systeme aufgerufen werden, h√§ngt von ihrem Typ ab. <br><br>  Als Teil des Systems wird jeder Frame unbedingt aktualisiert (der Begriff ‚Äûnormales Update‚Äú wird in der Engine verwendet). Dieser Typ umfasst alle Systeme, die sich auf das Rendern des Frames und der Sounds auswirken: Skelettanimationen, Partikel, Benutzeroberfl√§che usw.  Der andere Teil wird mit einer festen, vorgegebenen H√§ufigkeit ausgef√ºhrt (wir verwenden den Begriff ‚Äûfestes Update‚Äú und f√ºr die Anzahl der festen Updates pro Sekunde - FFPS) - sie verarbeiten den gr√∂√üten Teil der Spiellogik und alles, was zwischen Client und Server synchronisiert werden muss - Zum Beispiel Teil der Eingabe des Spielers, Bewegung des Charakters, Schie√üen, Teil der physischen Simulation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j7/uo/wo/j7uowoyprp2hgp3lqgdy9rsotpm.png" height="1024" width="768"></div><br><br>  Die H√§ufigkeit der Ausf√ºhrung eines festen Updates sollte ausgewogen sein - ein zu kleiner Wert f√ºhrt zu einem nicht reagierenden Gameplay (z. B. wird die Eingabe des Spielers weniger h√§ufig und daher mit einer l√§ngeren Verz√∂gerung verarbeitet) und zu hoch - und zu hohen Leistungsanforderungen des Ger√§ts, auf dem die Anwendung ausgef√ºhrt wird.  Dies bedeutet auch, dass die Kosten f√ºr die Serverkapazit√§t umso h√∂her sind, je h√∂her die Frequenz ist (weniger Schlachten k√∂nnen gleichzeitig auf demselben Computer ausgef√ºhrt werden). <br><br>  Im folgenden GIF arbeitet die Welt mit einer H√§ufigkeit von 5 festen Aktualisierungen pro Sekunde.  Sie k√∂nnen die Verz√∂gerung zwischen dem Dr√ºcken der W-Taste und dem Beginn der Bewegung sowie die Verz√∂gerung zwischen dem Loslassen der Taste und dem Stoppen der Bewegung des Charakters feststellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dd/cbe/d6a/0ddcbed6a0354d56cc93efe6c2901b17.gif" alt="Bild" height="1024" width="768"></div><br>  Im n√§chsten GIF arbeitet die Welt mit einer H√§ufigkeit von 30 festen Aktualisierungen pro Sekunde, was eine wesentlich reaktionsschnellere Kontrolle erm√∂glicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/330/c42/fe9330c427acbd0bf5c807edcd9463ff.gif" alt="Bild" height="1024" width="768"></div><br>  Im Moment l√§uft die Welt im festen Update von Battle Prime 31 Mal pro Sekunde.  Ein solcher ‚Äûh√§sslicher‚Äú Wert wurde speziell ausgew√§hlt - er kann Fehler verursachen, die in anderen Situationen nicht auftreten w√ºrden, wenn die Anzahl der Aktualisierungen pro Sekunde beispielsweise eine runde Zahl oder ein Vielfaches der Bildschirmaktualisierungsrate ist. <br><br><h2>  Systemausf√ºhrungsreihenfolge </h2><br>  Eines der Dinge, die die Arbeit mit ECS erschweren, ist die Ausf√ºhrung von Systemen.  Zum Zeitpunkt des Schreibens gibt es im Battle Prime-Client w√§hrend des Kampfes zwischen den Spielern ein 251-System, und ihre Anzahl w√§chst nur. <br><br>  Ein System, das f√§lschlicherweise zur falschen Zeit ausgef√ºhrt wird, kann zu subtilen Fehlern oder zu einer Verz√∂gerung des Betriebs einiger Mechaniker f√ºr einen Rahmen f√ºhren (wenn beispielsweise das Schadenssystem am Anfang des Rahmens und das Projektilflugsystem am Ende funktioniert, wird Schaden angerichtet mit einer Verz√∂gerung von einem Frame). <br><br>  Die Ausf√ºhrungsreihenfolge von Systemen kann auf verschiedene Arten festgelegt werden, zum Beispiel: <br><br><ul><li>  Explizite Bestellung </li><li>  Angabe der numerischen ‚ÄûPriorit√§t‚Äú des Systems und anschlie√üende Sortierung nach Priorit√§t; </li><li>  Erstellen Sie automatisch ein Diagramm der Abh√§ngigkeiten zwischen Systemen und installieren Sie sie an den richtigen Stellen in der Ausf√ºhrungsreihenfolge. </li></ul><br>  Im Moment verwenden wir die dritte Option.  Jedes System gibt an, welche Komponenten es zum Lesen, welche zum Schreiben und welche Komponenten es erstellt.  Dann werden die Systeme automatisch in der erforderlichen Reihenfolge untereinander angeordnet: <br><ul><li>  Die Systemlesekomponente A kommt nach dem Systemschreiben in Komponente A; </li><li>  Das System, das in Komponente B schreibt oder diese liest, folgt dem System, das Komponente B erstellt. </li><li>  Wenn beide Systeme in Komponente C schreiben, kann die Reihenfolge beliebig sein (kann jedoch bei Bedarf manuell angegeben werden). </li></ul><br>  Theoretisch minimiert eine solche L√∂sung die Kontrolle √ºber die Ausf√ºhrungsreihenfolge. Sie m√ºssen lediglich Komponentenmasken f√ºr das System festlegen.  In der Praxis f√ºhrt dies mit dem Wachstum des Projekts zu immer mehr Zyklen zwischen den Systemen.  Wenn System-1 in Komponente A schreibt und Komponente B liest und System-2 Komponente A liest und in Komponente B schreibt, ist dies ein Zyklus, der manuell aufgel√∂st werden muss.  Oft gibt es mehr als zwei Systeme in einem Zyklus.  Ihre L√∂sung erfordert Zeit und explizite Angaben zur Beziehung zwischen ihnen. <br><br>  Daher verf√ºgt die Blitz Engine √ºber ‚ÄûGruppen‚Äú von Systemen.  Innerhalb von Gruppen werden Systeme automatisch in der gew√ºnschten Reihenfolge ausgerichtet (und Zyklen werden immer noch manuell aufgel√∂st), und die Reihenfolge der Gruppen wird explizit festgelegt.  Diese Entscheidung ist eine Kreuzung zwischen einer vollst√§ndig manuellen und einer vollautomatisierten Bestellung, und die Gr√∂√üe der Gruppen wirkt sich ernsthaft auf deren Wirksamkeit aus.  Sobald die Gruppe zu gro√ü wird, sto√üen Programmierer h√§ufig auf die Probleme von Schleifen in ihnen. <br><br>  Derzeit gibt es 10 Gruppen in Battle Prime.  Dies ist immer noch nicht genug, und wir planen, ihre Anzahl zu erh√∂hen, indem wir eine strikte logische Abfolge zwischen ihnen erstellen und die automatische Erstellung eines Diagramms in jedem von ihnen verwenden. <br><br>  Die Angabe, welche Komponenten von Systemen zum Schreiben oder Lesen verwendet werden, erm√∂glicht es in Zukunft auch, Systeme automatisch in ‚ÄûBl√∂cke‚Äú zu gruppieren, die parallel zueinander ausgef√ºhrt werden. <br><br>  Im Folgenden finden Sie ein Hilfsprogramm, das eine Liste der Systeme und die Abh√§ngigkeiten zwischen ihnen in jeder der Gruppen anzeigt (vollst√§ndige Diagramme in den Gruppen sehen einsch√ºchternd aus).  Die orange Farbe zeigt explizit definierte Abh√§ngigkeiten zwischen Systemen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/592/2a4/fae/5922a4fae880eb7c80252628a827d2a0.gif" alt="Bild" height="1024" width="768"></div><br><h2>  Kommunikation zwischen Systemen und deren Konfiguration </h2><br>  Die Aufgaben, die die Systeme in sich selbst ausf√ºhren, k√∂nnen bis zu dem einen oder anderen Grad von den Ergebnissen anderer Systeme abh√§ngen.  Beispielsweise h√§ngt ein System, das Kollisionen zweier Objekte verarbeitet, von einer Simulation der Physik ab, die diese Kollisionen registriert.  Und das Schadenssystem h√§ngt von den Ergebnissen des ballistischen Systems ab, das f√ºr die Bewegung der Granaten verantwortlich ist. <br><br>  Die einfachste und naheliegendste Art der Kommunikation zwischen Systemen ist die Verwendung von Komponenten.  Ein System f√ºgt die Ergebnisse seiner Arbeit in eine Komponente ein, und das zweite System liest diese Ergebnisse aus der Komponente und l√∂st das Problem auf ihrer Grundlage. <br><br>  Ein komponentenbasierter Ansatz kann in einigen F√§llen unpraktisch sein: <br><br><ul><li>  Was ist, wenn das Ergebnis des Systems nicht direkt an ein Objekt gebunden ist?  Zum Beispiel ein System, das Kampfstatistiken sammelt (die Anzahl der Sch√ºsse, Treffer, Todesf√§lle usw.) - sammelt sie global, basierend auf der gesamten Schlacht; </li><li>  Was ist, wenn das System auf irgendeine Weise konfiguriert werden muss?  Beispielsweise muss ein physikalisches Simulationssystem wissen, welche Objekttypen Kollisionen zwischen sich aufzeichnen sollen und welche nicht. </li></ul><br>  Um diese Probleme zu l√∂sen, verwenden wir den Ansatz, den wir vom Overwatch-Entwicklungsteam √ºbernommen haben - Einzelkomponenten. <br><br>  Einzelne Komponente ist eine Komponente, die in der Welt in einer einzigen Kopie existiert und direkt von der Welt bezogen wird.  Systeme k√∂nnen damit die Ergebnisse ihrer Arbeit addieren, die dann von anderen Systemen verwendet werden, oder ihre Arbeit konfigurieren. <br><br>  Derzeit umfasst das Projekt (Engine-Module + Spiel) etwa 120 Einzelkomponenten, die f√ºr verschiedene Zwecke verwendet werden - von der Speicherung globaler Daten der Welt bis zur Konfiguration einzelner Systeme. <br><br><h2>  "Sauberer" Ansatz </h2><br>  In seiner reinsten Form erfordert ein solcher Ansatz f√ºr Systeme und Komponenten die Verf√ºgbarkeit von Daten nur innerhalb der Komponenten und das Vorhandensein von Logik nur innerhalb der Systeme.  Meiner Meinung nach ist es in der Praxis selten sinnvoll, diese Einschr√§nkung strikt einzuhalten (obwohl die Debatten zu diesem Thema immer noch regelm√§√üig gef√ºhrt werden). <br><br>  Die folgenden Argumente f√ºr einen weniger ‚Äûstrengen‚Äú Ansatz k√∂nnen hervorgehoben werden: <br><br><ul><li>  Ein Teil des Codes sollte gemeinsam genutzt werden - und synchron von verschiedenen Systemen oder beim Festlegen einiger Eigenschaften von Komponenten ausgef√ºhrt werden.  Eine √§hnliche Logik wird separat beschrieben.  Als Teil der Engine verwenden wir den Begriff Utils.  Zum Beispiel enth√§lt "DamageUtils" im Spiel die Logik, die mit der Anwendung von Schaden verbunden ist - die von verschiedenen Systemen aus angewendet werden kann; </li><li>  Es macht keinen Sinn, die privaten Daten des Systems an einem anderen Ort als diesem System selbst aufzubewahren - niemand wird sie au√üer diesem ben√∂tigen, und das Verschieben an einen anderen Ort ist nicht besonders n√ºtzlich.  Es gibt eine Ausnahme von dieser Regel, die mit der Funktionalit√§t von Client-Vorhersagen verbunden ist. Sie wird im folgenden Abschnitt beschrieben. </li><li>  F√ºr Komponenten ist es n√ºtzlich, eine kleine Menge an Logik zu haben - zum gr√∂√üten Teil handelt es sich dabei um intelligente Getter und Setter, die die Arbeit mit der Komponente vereinfachen. </li></ul><br><h1>  Netcode </h1><br>  Battle Prime verwendet eine Architektur mit autorit√§ren Server- und Client-Vorhersagen.  Dies erm√∂glicht es dem Spieler, auch bei hohen Pings und Paketverlusten und dem gesamten Projekt sofortiges Feedback von seinen Aktionen zu erhalten - um das Betr√ºgen durch die Spieler zu minimieren, weil  Der Server diktiert alle Simulationsergebnisse innerhalb des Kampfes. <br><br>  Der gesamte Code im Spielprojekt ist in drei Teile unterteilt: <br><br><ul><li>  Client - Systeme und Komponenten, die nur auf dem Client funktionieren.  Dazu geh√∂ren Dinge wie Benutzeroberfl√§che, automatische Aufnahme und Interpolation; </li><li>  Server - Systeme und Komponenten, die nur auf dem Server funktionieren.  Zum Beispiel alles, was mit Schaden und Spawn-Charakteren zu tun hat; </li><li>  Allgemein - Dies ist alles, was sowohl auf dem Server als auch auf dem Client funktioniert.  Insbesondere alle Systeme, die die Bewegung des Charakters, den Zustand der Waffe (Anzahl der Runden, Abklingzeiten) und alles andere berechnen, was auf dem Client vorhergesagt werden muss.  Die meisten Systeme, die f√ºr visuelle Effekte verantwortlich sind, sind ebenfalls √ºblich - der Server kann optional im GUI-Modus gestartet werden (gr√∂√ütenteils nur zum Debuggen). </li></ul><br><h2>  Benutzereingabe (Eingabe) </h2><br>  Bevor Sie mit den Details der Replikation und Vorhersagen auf dem Client fortfahren, sollten Sie sich mit der Eingabe innerhalb der Engine befassen. Die Details hierzu sind in den folgenden Abschnitten wichtig. <br><br>  Alle Eingaben des Players sind in zwei Typen unterteilt: Low-Level und High-Level: <br><br><ul><li>  Low-Level-Eingabe - Dies sind Ereignisse von Eingabeger√§ten, z. B. Tastenanschl√§ge, Ber√ºhren des Bildschirms usw.  Eine solche Eingabe wird von Spielsystemen selten verarbeitet. </li><li>  High-Level-Eingabe - sind die Aktionen des Benutzers, die er im Kontext des Spiels ausgef√ºhrt hat: Schuss, Waffenwechsel, Charakterbewegung usw.  F√ºr solche Aktionen auf hoher Ebene verwenden wir den Begriff "Aktion".  Au√üerdem k√∂nnen der Aktion zus√§tzliche Daten zugeordnet werden, z. B. die Bewegungsrichtung oder der Index der ausgew√§hlten Waffe.  Die √ºberwiegende Mehrheit der Systeme arbeitet mit Aktionen. </li></ul><br>  Eine Eingabe auf hoher Ebene wird entweder auf der Basis von Bindemitteln aus einer Eingabe auf niedriger Ebene oder programmgesteuert erzeugt.  Zum Beispiel kann eine Schussaktion an einen Mausklick gebunden sein oder von dem f√ºr das automatische Schie√üen verantwortlichen System generiert werden. Sobald der Spieler auf den Feind gerichtet hat, generiert dieses System einen Aktionsschuss, wenn der Benutzer die entsprechende Einstellung aktiviert hat.  Aktionen k√∂nnen auch vom UI-System gesendet werden: zum Beispiel durch Dr√ºcken der entsprechenden Taste oder beim Bewegen des Bildschirm-Joysticks.  Ein System, das ausgel√∂st wird, spielt keine Rolle, wie diese Aktion erstellt wurde. <br><br>  Logisch verwandte Aktionen werden zusammengefasst (Objekte vom Typ "ActionSet").  Gruppen k√∂nnen getrennt werden, wenn sie im aktuellen Kontext nicht ben√∂tigt werden. In Battle Prime gibt es beispielsweise mehrere Gruppen, darunter: <br><br><ul><li>  Aktionen zur Steuerung der Bewegung des Charakters, </li><li>  Aktionen zum Abfeuern von automatischen Waffen, </li><li>  Aktionen zum Abfeuern von halbautomatischen Waffen. </li></ul><br>  Von den letzten beiden Gruppen ist je nach Art der ausgew√§hlten Waffe jeweils nur eine aktiv - sie unterscheiden sich darin, wie die FIRE-Aktion generiert wird: w√§hrend die Taste gedr√ºckt wird (f√ºr automatische Waffen) oder nur einmal, wenn die Taste gedr√ºckt wird (f√ºr halbautomatische Waffen) ) <br><br>  In √§hnlicher Weise werden Aktionsgruppen innerhalb des Spiels in einem der Systeme erstellt und konfiguriert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Map&lt;FastName, ActionSet&gt; action_sets = { { <span class="hljs-comment"><span class="hljs-comment">//     ControlModes::CHARACTER_MOVEMENT, ActionSet { { DigitalBinding{ ActionNames::JUMP, { { InputCode::KB_SPACE, DigitalState::just_pressed() } }, nullopt }, DigitalBinding{ ActionNames::MOVE, { { InputCode::KB_W, DigitalState::pressed() } }, ActionValue{ AnalogState{0.0f, 1.0f, 0.0f} } }, //    ... }, { AnalogBinding{ ActionNames::LOOK, InputCode::MOUSE_RELATIVE_POSITION, AnalogStateType::ABSOLUTE, AnalogStateBasis::LOGICAL, {} } //    ... } } }, { //       ControlModes::AUTOMATIC_FIRE, ActionSet { { // FIRE    ,      DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::pressed() } }, nullopt }, //       ... } } }, { //       ControlModes::SEMI_AUTOMATIC_FIRE, ActionSet { { // FIRE          DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::just_pressed() } }, nullopt }, //       ... } } } //   ... };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battle Prime beschreibt ungef√§hr 40 Aktionen. </font><font style="vertical-align: inherit;">Einige von ihnen werden nur zum Debuggen oder Aufzeichnen von Clips verwendet.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replikation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Replikation werden Daten von einem Server an Clients √ºbertragen. </font><font style="vertical-align: inherit;">Alle Daten werden durch Objekte in der Welt √ºbertragen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ihre Erstellung und L√∂schung, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen und L√∂schen von Komponenten f√ºr Objekte, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie die Komponenteneigenschaften. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Replikation wird mit der entsprechenden Komponente konfiguriert. </font><font style="vertical-align: inherit;">In √§hnlicher Weise richtet das Spiel beispielsweise die Replikation der Waffen des Spielers ein:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* replication_component = weapon_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;WeaponDescriptorComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponBaseStatsComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponComponent&gt;(Privacy::PRIVATE); replication_component-&gt;enable_replication&lt;BallisticsStatsComponent&gt;(Privacy::PRIVATE); <span class="hljs-comment"><span class="hljs-comment">// ...   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr jede Komponente wird der Datenschutz angegeben, der w√§hrend der Replikation verwendet wird. Private Komponenten werden vom Server nur an den Spieler gesendet, dem diese Waffe geh√∂rt. √ñffentliche Komponenten werden an alle gesendet. In diesem Beispiel sind "WeaponDescriptorComponent" und "WeaponBaseStatsComponent" √∂ffentlich - sie enthalten die Daten, die f√ºr die korrekte Anzeige anderer Spieler erforderlich sind. Beispielsweise werden der Index des Slots, in dem die Waffe liegt, und ihr Typ f√ºr Animationen ben√∂tigt. Die restlichen Komponenten werden privat an den Spieler gesendet, dem diese Waffe geh√∂rt - die Parameter der Ballistik der Granaten, Informationen √ºber die Gesamtzahl der Runden, die verf√ºgbaren Schie√ümodi usw. Es gibt speziellere Datenschutzmodi: Sie k√∂nnen beispielsweise eine Komponente nur an Verb√ºndete oder nur an Feinde senden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Komponente in ihrer Beschreibung muss angeben, welche Felder in dieser Komponente repliziert werden sollen. </font><font style="vertical-align: inherit;">Beispielsweise sind alle Felder in der "WeaponComponent" als "Replizierbar" markiert:</font></font><br><br><pre> <code class="cpp hljs">BZ_VIRTUAL_REFLECTION_IMPL(WeaponComponent) { ReflectionRegistrar::begin_class&lt;WeaponComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"owner"</span></span>, &amp;WeaponComponent::owner)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"fire_mode"</span></span>, &amp;WeaponComponent::fire_mode)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"loaded_ammo"</span></span>, &amp;WeaponComponent::loaded_ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"ammo"</span></span>, &amp;WeaponComponent::ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"shooting_cooldown_end_ms"</span></span>, &amp;WeaponComponent::shooting_cooldown_end_ms)[M&lt;Replicable&gt;()]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Mechanismus ist sehr bequem zu bedienen. </font><font style="vertical-align: inherit;">Innerhalb des Serversystems, das f√ºr das "Auswerfen" von Token von get√∂teten Gegnern verantwortlich ist (in einem speziellen Spielmodus), reicht es beispielsweise aus, "ReplicationComponent" auf einem solchen Token hinzuzuf√ºgen und zu konfigurieren. </font><font style="vertical-align: inherit;">Es sieht so aus:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component* component : added_dead_avatars-&gt;components) { Entity kill_token_entity = world-&gt;create_entity(); <span class="hljs-comment"><span class="hljs-comment">//           // ... //   auto* replication_component = kill_token_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;TransformComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;KillTokenComponent&gt;(Privacy::PUBLIC); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel wird die physische Simulation des Tokens beim Auftreten auf dem Server ausgef√ºhrt, und die endg√ºltige Transformation des Tokens wird gesendet und auf den Client angewendet. Auf dem Client arbeitet auch ein Interpolationssystem, das die Bewegung dieses Tokens unter Ber√ºcksichtigung der H√§ufigkeit von Aktualisierungen, der Qualit√§t der Verbindung zum Server usw. gl√§ttet. Andere Systeme, die diesem Spielmodus zugeordnet sind, f√ºgen Objekten mit "KillTokenComponent" einen visuellen Teil hinzu und √ºberwachen deren Auswahl.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzige Unannehmlichkeit des aktuellen Ansatzes, auf die Sie achten m√∂chten und die Sie in Zukunft beseitigen m√∂chten, ist die Unf√§higkeit, den Datenschutz f√ºr jedes Komponentenfeld festzulegen. Dies ist nicht sehr kritisch, da ein √§hnliches Problem leicht gel√∂st werden kann, indem die Komponente in mehrere aufgeteilt wird: Beispielsweise enth√§lt das Spiel "ShooterPublicComponent" und "ShooterPrivateComponent" mit der entsprechenden Privatsph√§re. Trotz der Tatsache, dass sie an einen Mechaniker gebunden sind (Schie√üen), sind zwei Komponenten erforderlich, um Verkehr zu sparen. Einige Felder werden bei Kunden, die diese Komponenten nicht besitzen, einfach nicht ben√∂tigt. Dies f√ºgt dem Programmierer jedoch Arbeit hinzu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen k√∂nnen auf einen Client replizierte Objekte Status f√ºr verschiedene Frames haben. </font><font style="vertical-align: inherit;">Daher wurde die M√∂glichkeit hinzugef√ºgt, Objekte durch Bilden von Replikationsgruppen zu gruppieren. </font><font style="vertical-align: inherit;">Alle Komponenten auf Objekten innerhalb derselben Gruppe haben immer einen Status f√ºr denselben Frame auf dem Client. Dies ist erforderlich, damit die Vorhersagen korrekt funktionieren (mehr dazu weiter unten). </font><font style="vertical-align: inherit;">Zum Beispiel geh√∂ren eine Waffe und ein Charakter, dem sie geh√∂rt, zur selben Gruppe. </font><font style="vertical-align: inherit;">Wenn sich die Objekte in verschiedenen Gruppen befinden, kann sich ihr Status in der Welt auf verschiedene Frames beziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Replikationssystem versucht, das Verkehrsaufkommen zu minimieren, indem es insbesondere die √ºbertragenen Daten komprimiert (jedes Feld innerhalb der Komponente kann optional entsprechend f√ºr die Komprimierung markiert werden) und nur die Wertdifferenz zwischen den beiden Frames √ºbertr√§gt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kundenvorhersagen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kundenvorhersagen (der Begriff clientseitige Vorhersage wird im Englischen verwendet) erm√∂glichen es dem Spieler, sofortiges Feedback zu den meisten seiner Aktionen im Spiel zu erhalten. </font><font style="vertical-align: inherit;">Da sich das letzte Wort immer hinter dem Server befindet, muss der Client es im Falle eines Fehlers in der Simulation (der Begriff Fehlvorhersage wird im Englischen verwendet, ich werde sie in Zukunft einfach als "Fehlvorhersagen" bezeichnen) beheben. </font><font style="vertical-align: inherit;">Weitere Details zu Vorhersagefehlern und wie sie korrigiert werden, werden unten beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kundenvorhersagen funktionieren nach folgenden Regeln:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Client simuliert sich vorw√§rts durch N Frames; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle vom Client generierten Eingaben werden an den Server gesendet (in Form von Aktionen, die vom Spieler ausgef√ºhrt werden). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N h√§ngt von der Qualit√§t der Verbindung zum Server ab. </font><font style="vertical-align: inherit;">Je kleiner dieser Wert ist, desto ‚Äûaktueller‚Äú ist das Bild der Welt f√ºr den Kunden (dh die Zeitl√ºcke zwischen dem lokalen Spieler und anderen Spielern ist kleiner).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen f√ºhren sowohl der Server als auch der Client die Simulation basierend auf Client-Eingaben durch. </font><font style="vertical-align: inherit;">Der Server sendet dann die Ergebnisse dieser Simulation an den Client. </font><font style="vertical-align: inherit;">Wenn der Client feststellt, dass seine Ergebnisse nicht mit denen des Servers √ºbereinstimmen, versucht er, den Fehler zu korrigieren. Er rollt sich auf den letzten bekannten Serverstatus zur√ºck und simuliert erneut N Frames voraus. </font><font style="vertical-align: inherit;">Dann geht alles nach einem √§hnlichen Schema weiter - der Client simuliert sich auch in Zukunft in Bezug auf den Server und der Server sendet ihm die Ergebnisse seiner Simulation. </font><font style="vertical-align: inherit;">Daraus folgt, dass der gesamte Code, der die Clientvorhersagen beeinflusst, zwischen Client und Server gemeinsam genutzt werden muss.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Datenverkehr zu sparen, wird die gesamte Eingabe basierend auf einem vordefinierten Schema vorkomprimiert. Dann wird es an den Server gesendet und sofort wieder an den Client dekomprimiert. Das Packen und anschlie√üende Entpacken auf dem Client ist erforderlich, um den Unterschied in den Werten zu beseitigen, die mit der Eingabe zwischen Client und Server verbunden sind. Beim Erstellen eines Schemas wird der Wertebereich f√ºr diese Aktion und die Anzahl der Bits angegeben, in die es gepackt werden soll. In √§hnlicher Weise sieht die Ank√ºndigung des Verpackungsschemas in Battle Prime wie in einem gemeinsamen System zwischen Client und Server aus:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* input_packing_sc = world-&gt;get_for_write&lt;InputPackingSingleComponent&gt;(); input_packing_sc-&gt;packing_schema = { { ActionNames::MOVE, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">8</span></span>, { <span class="hljs-number"><span class="hljs-number">-1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span> }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::LOOK, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">16</span></span>, { -PI, PI }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::JUMP, nullopt }, <span class="hljs-comment"><span class="hljs-comment">// ..    action' };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine kritische Bedingung f√ºr die Leistung von Client-Vorhersagen ist die Notwendigkeit, dass die Eingabe Zeit hat, um zum Zeitpunkt der Rahmensimulation, auf die sich diese Eingabe bezieht, zum Server zu gelangen. F√ºr den Fall, dass die Eingabe den gew√ºnschten Frame auf dem Server nicht erreicht hat (dies kann beispielsweise w√§hrend eines scharfen Ping-Sprungs passieren), versucht der Server, die Eingabe dieses Clients aus dem vorherigen Frame zu verwenden. Dies ist ein Sicherungsmechanismus, mit dessen Hilfe in einigen Situationen falsche Vorhersagen auf dem Client beseitigt werden k√∂nnen. Wenn ein Client beispielsweise einfach in eine Richtung ausgef√ºhrt wird und sich seine Eingabe f√ºr eine relativ lange Zeit nicht √§ndert, ist die Verwendung der Eingabe f√ºr den letzten Frame erfolgreich - der Server "err√§t" sie und es gibt keine Diskrepanz zwischen Client und Server. Ein √§hnliches Schema wird in Overwatch verwendet (wurde in einem Vortrag √ºber GDC erw√§hnt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=W3aieHjyNvw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit sagt der Battle Prime-Client den Status der folgenden Objekte voraus:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spieler-Avatar (Position in der Welt und alles, was sie beeinflussen kann, Stand der F√§higkeiten usw.); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle Waffen des Spielers (Anzahl der Runden im Laden, Abklingzeiten zwischen den Sch√ºssen usw.). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Verwendung von Client-Vorhersagen m√ºssen die "PredictionComponent" auf dem Client zu den gew√ºnschten Objekten hinzugef√ºgt und konfiguriert werden. </font><font style="vertical-align: inherit;">Beispielsweise wird die Vorhersage des Avatars eines Spielers in einem der Systeme auf √§hnliche Weise aktiviert:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `new_local_avatars`       , //      for (Entity avatar : new_local_avatars) { auto* avatar_prediction_component = avatar.add&lt;PredictionComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;TransformComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;CharacterControllerComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPrivateComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPublicComponent&gt;(); // ...      }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code bedeutet, dass die Felder in den oben genannten Komponenten st√§ndig mit den √§hnlichen Feldern der Serverkomponenten verglichen werden. Wenn eine Diskrepanz in den Werten innerhalb eines einzelnen Frames festgestellt wird, wird auf dem Client eine Anpassung vorgenommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Diskrepanzkriterium h√§ngt von der Art der Daten ab. In den meisten F√§llen ist dies nur ein Aufruf von "operator ==". Die Ausnahme bilden Daten, die auf float basieren. F√ºr sie ist der maximal zul√§ssige Fehler derzeit behoben und betr√§gt 0,005. In Zukunft besteht der Wunsch, die M√∂glichkeit hinzuzuf√ºgen, die Genauigkeit f√ºr jedes Komponentenfeld separat einzustellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Replikations- und Clientvorhersage-Workflow basiert auf der Tatsache, dass alle f√ºr die Simulation erforderlichen Daten in den Komponenten enthalten sind. Oben im Abschnitt √ºber ECS habe ich geschrieben, dass Systeme einen Teil der Daten enthalten d√ºrfen - dies kann in einigen F√§llen praktisch sein. Dies gilt nicht f√ºr Daten, die sich auf die Simulation auswirken. Sie m√ºssen sich immer innerhalb der Komponenten befinden, da die Client- und Server-Snapshot-Systeme nur mit den Komponenten arbeiten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der Vorhersage von Feldwerten innerhalb von Komponenten ist es m√∂glich, die Erstellung und Entfernung von Komponenten vorherzusagen. Wenn beispielsweise aufgrund der Verwendung der F√§higkeit dem Charakter eine "SpeedModifierComponent" √ºberlagert wird (die die Bewegungsgeschwindigkeit √§ndert, z. B. den Spieler beschleunigt), muss sie dem Charakter sowohl auf dem Server als auch auf dem Client im selben Frame hinzugef√ºgt werden, andernfalls wird sie hinzugef√ºgt f√ºhrt zu einer falschen Vorhersage der Position des Charakters auf dem Client. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Vorhersagen des Erstellens und L√∂schens von Objekten wird derzeit nicht unterst√ºtzt. Dies kann in einigen Situationen praktisch sein, erschwert jedoch auch Netzwerkmodule. Vielleicht werden wir in Zukunft darauf zur√ºckkommen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten sehen Sie ein GIF, in dem die Zeichensteuerung mit RTT etwa 1,5 Sekunden lang erfolgt. </font><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, wird der Charakter trotz der hohen Verz√∂gerung sofort gesteuert: Bewegen, Schie√üen, Nachladen, Granatenwerfen - alles geschieht, ohne auf Informationen vom Server zu warten. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch feststellen, dass die Erfassung eines Punkts (einer durch Dreiecke begrenzten Zone) mit einer Verz√∂gerung beginnt. Diese Mechanik funktioniert nur auf dem Server und wird vom Client nicht vorhergesagt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/224/09f/a6b22409f317a314819b0163f14f2b6e.gif" alt="Bild" height="1024" width="768"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehleinsch√§tzungen und Resimulationen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlvorhersage - Diskrepanz zwischen den Ergebnissen von Server- und Client-Simulationen. Bei der Resimulation wird diese Diskrepanz vom Kunden korrigiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Grund f√ºr das Auftreten von Fehlvorhersagen sind die scharfen Ping-Spr√ºnge, f√ºr die der Kunde keine Zeit hatte, sich anzupassen. In einer solchen Situation hat die Eingabe vom Player m√∂glicherweise keine Zeit, um zum Server zu gelangen, und der Server verwendet den oben beschriebenen Sicherungsmechanismus, wobei die letzte Eingabe f√ºr einige Zeit dupliziert wird, und nach einer Weile wird die Verwendung eingestellt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Grund ist die Interaktion des Charakters mit Objekten, die vollst√§ndig vom Server gesteuert werden und vom Client nicht lokal vorhergesagt werden. Zum Beispiel f√ºhrt eine Kollision mit einem anderen Spieler zu einer Fehlvorhersage - da diese tats√§chlich in zwei verschiedenen Zeitr√§umen leben (der lokale Charakter ist in Zukunft relativ zu einem anderen Spieler - dessen Position vom Server stammt und interpoliert wird). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der dritte und unangenehmste Grund sind Fehler im Code. Beispielsweise kann ein System f√§lschlicherweise nicht replizierte Daten verwenden, um die Simulation zu steuern, oder die Systeme arbeiten in der falschen Reihenfolge oder sogar in unterschiedlichen Reihenfolgen auf dem Server und dem Client. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Auffinden dieser Fehler dauert manchmal ziemlich lange. Um die Suche zu vereinfachen, haben wir verschiedene Hilfstools erstellt. W√§hrend die Anwendung ausgef√ºhrt wird, k√∂nnen Sie Folgendes sehen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replizierte Komponenten </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Anzahl der falschen Vorhersagen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf welchen Frames sind sie passiert, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welche Daten befanden sich auf dem Server und auf dem Client in den divergierenden Komponenten? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welche Eingabe wurde auf dem Server und auf dem Client f√ºr diesen Frame angewendet? </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9d/ym/7x/9dym7xq_wej-rqkes4zumdvkrxa.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/4i/ar/4t4iarkyqjkmgdlbabbfordysgi.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gp/zt/cy/gpztcyp0k9yobauozchbixe4suy.png" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider dauert die Suche nach den Ursachen f√ºr Resimulationen auch bei ihnen noch recht lange. </font><font style="vertical-align: inherit;">Zweifellos m√ºssen Tools und Validierungen entwickelt werden, um die Wahrscheinlichkeit von Fehlern zu verringern und deren Suche zu vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Betrieb von Resimulationen zu unterst√ºtzen, muss das System von einer bestimmten Klasse "ResimulatableSystem" erben. </font><font style="vertical-align: inherit;">In einer Situation, in der eine Fehlvorhersage auftritt, "rollt" die Welt alle Objekte auf den letzten bekannten Serverstatus zur√ºck und f√ºhrt dann die erforderliche Anzahl von Simulationen durch, um diesen Fehler zu beheben. Nur resimulierbare Systeme werden daran teilnehmen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen sollten Kunden-Resimulationen f√ºr Spieler nicht erkennbar sein. Wenn sie auftreten, werden alle Komponentenfelder reibungslos in neue Werte interpoliert, um m√∂gliche ‚ÄûZuckungen‚Äú visuell auszugleichen. Es ist jedoch wichtig, die Anzahl so gering wie m√∂glich zu halten.</font></font><br><br><h2>  Schie√üen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schaden f√ºr Spieler wird vollst√§ndig vom Server diktiert - Kunden k√∂nnen sich nicht auf eine so wichtige Mechanik verlassen, um die Wahrscheinlichkeit von Betrug zu verringern. Aber wie bei Bewegungen sollte das Schie√üen auf den Client so reaktionsschnell wie m√∂glich und ohne Verz√∂gerungen sein - der Spieler muss sofortiges Feedback in Form von Effekten und Ger√§uschen erhalten - M√ºndungsblitz, die Spur des Projektilfluges sowie die Auswirkungen des Projektils auf die Umgebung und andere Spieler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher wird der gesamte Zustand des Charakters, der mit dem Schie√üen verbunden ist, vom Kunden vorhergesagt - wie viele Runden sich im Laden befinden, die Streuung w√§hrend des Schie√üens, die Verz√∂gerung zwischen den Sch√ºssen, die Zeit des letzten Schusses und so weiter. Auf dem Client befinden sich dieselben Systeme, die f√ºr die Bewegung von Shells verantwortlich sind wie auf dem Server. Auf diese Weise k√∂nnen Sie Aufnahmen auf dem Client simulieren, ohne auf die Ergebnisse ihrer Simulation auf dem Server warten zu m√ºssen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ballistik der Schalen selbst wird nicht vorhergesagt - da sie mit sehr hoher Geschwindigkeit fliegen und ihre Bewegung in der Regel in wenigen Frames beenden, hat die Schale bereits Zeit, einen Punkt auf der Welt zu erreichen und den Effekt zu verlieren, bevor wir die Simulationsergebnisse erhalten Dies ist ein Projektil vom Server (oder das Fehlen von Ergebnissen, wenn der Client aufgrund eines Fehlers das Projektil versehentlich abgefeuert hat).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Arbeitsschema langsam fliegender Projektile ist etwas anders. </font><font style="vertical-align: inherit;">Wenn ein Spieler eine Granate wirft, sich jedoch aufgrund der falschen Vorhersage herausstellt, dass die Granate nicht geworfen wurde, wird sie auf dem Client zerst√∂rt. </font><font style="vertical-align: inherit;">Wenn ein Client die Zerst√∂rung einer Granate falsch vorhergesagt hat (sie ist bereits auf dem Server explodiert, aber noch nicht auf dem Client), wird auch die Client-Granate zerst√∂rt. </font><font style="vertical-align: inherit;">Alle Informationen zu den auf dem Client angezeigten Explosionen stammen vom Server, um Situationen zu vermeiden, in denen aufgrund eines Clientfehlers die Serverexplosion an einem Ort und auf dem Client an einem anderen Ort aufgetreten ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealerweise m√∂chte ich langsam fliegende Granaten in der Zukunft vollst√§ndig vorhersagen - nicht nur die Zeit des Lebens, sondern auch ihre Position.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verz√∂gerungskompensation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verz√∂gerungskompensation ist eine Technik, mit der Sie den Effekt der Verz√∂gerung zwischen dem Server und dem Client auf die Genauigkeit der Aufnahme ausgleichen k√∂nnen. </font><font style="vertical-align: inherit;">In diesem Abschnitt gehe ich davon aus, dass das Schie√üen immer von "Hitscan" -Waffen stammt - d. H. </font><font style="vertical-align: inherit;">Ein von einer Waffe abgefeuertes Projektil bewegt sich mit unendlicher Geschwindigkeit. </font><font style="vertical-align: inherit;">Aber alles, was hier beschrieben wird, ist auch bei anderen Waffentypen von Bedeutung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die folgenden Punkte machen es erforderlich, die Verz√∂gerung beim Schie√üen auszugleichen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der vom Spieler kontrollierte Charakter befindet sich in Zukunft relativ zum Server (Vorhersage seines Status f√ºr eine bestimmte Anzahl von Frames); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folglich ist der Rest der Spieler in der Vergangenheit in Beziehung zu ihm; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Ausl√∂sen wird die entsprechende Aktion vom Client an den Server gesendet und auf denselben Frame angewendet, auf den sie auf den Client angewendet wurde (falls m√∂glich). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir annehmen, dass der Spieler auf einen Feind zielt, der auf den Kopf zul√§uft, und den Schussknopf dr√ºckt, erhalten Sie das folgende Bild: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf dem Client: Der Sch√ºtze auf Bild N1 schie√üt auf den Kopf eines Feindes auf Bild N0 (N0 &lt;N1). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf dem Server: Der Sch√ºtze auf Bild N1 schie√üt auf den Kopf des Feindes, der sich ebenfalls auf Bild N1 befindet (auf dem Server sind alle gleichzeitig). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis ist mit hoher Wahrscheinlichkeit ein Fehlschuss w√§hrend eines Schusses. </font><font style="vertical-align: inherit;">Da der Kunde auf der Grundlage seines Weltbildes zielt, das nicht mit dem Bild der Serverwelt √ºbereinstimmt, um in den Feind zu gelangen, muss er auch mit Trefferwaffen auf ihn zielen, und die Entfernung, vor der er schie√üen muss, h√§ngt von der Qualit√§t der Verbindung mit ab Server. </font><font style="vertical-align: inherit;">Dies ist, gelinde gesagt, keine gute Erfahrung f√ºr einen Sch√ºtzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dieses Problem zu beseitigen, wird eine Verz√∂gerungskompensation verwendet. </font><font style="vertical-align: inherit;">Das Schema ihrer Arbeit ist wie folgt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Server verf√ºgt √ºber eine begrenzte Anzahl von Snapshots der Welt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn sie abgefeuert werden, ‚Äûrollen‚Äú die Feinde (oder ein Teil der Feinde) so zur√ºck, dass die Welt auf dem Server mit der Welt √ºbereinstimmt, die der Client an sich gesehen hat - der Client befindet sich in der ‚ÄûGegenwart‚Äú (dem Moment des Schusses) und die Feinde befinden sich in der Vergangenheit. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Mechanik der Treffererkennung funktioniert, Treffer werden aufgezeichnet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Welt kehrt in ihren urspr√ºnglichen Zustand zur√ºck. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Bild der Welt auf dem Client auch von der Funktionsweise des Interpolationssystems abh√§ngt, sendet der Client ihm zus√§tzliche Daten, um die Welt auf den genauesten Clientstatus auf dem Server zur√ºckzusetzen, die Differenz - den Unterschied zwischen dem aktuellen Frame des Clients und dem Frame, f√ºr den er alle anderen Spieler sieht (im Moment sind dies zwei Bytes pro Bild) sowie der Zeitpunkt der Erzeugung der Aufnahmeeingabe relativ zum Bildanfang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verz√∂gerungskompensation erfolgt auf der Ebene eines separaten Moduls im Motor und ist nicht an ein bestimmtes Projekt gebunden. </font><font style="vertical-align: inherit;">Aus Sicht des Entwicklers der Spielmechanik wird diese wie folgt verwendet:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "LagCompensationComponent" wird dem Player hinzugef√ºgt und die Liste der Trefferfelder, die im Verlauf gespeichert werden sollen, wird gef√ºllt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Schie√üen (oder bei anderen Mechaniken, die eine Kompensation erfordern - zum Beispiel bei Nahkampfangriffen) wird "LagCompensation :: invoke" aufgerufen, wobei der Funktor √ºbergeben wird, der aus Sicht eines bestimmten Spielers in der "kompensierten" Welt ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Es muss √ºber alle erforderlichen Treffererkennungen verf√ºgen.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code mit einem Beispiel f√ºr die Verwendung der Verz√∂gerungskompensation von Batle Prime beim Bewegen ballistischer Projektile: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `targets_data`    , //   ‚Äú‚Äù    , //    const auto compensated_action = [this](const Vector&lt;LagCompensation::LagCompensationData&gt;&amp; targets_data) { process_projectile(projectile, elapsed_time); }; LagCompensation::invoke( observer, // ,       projectile_component-&gt;input_time_ms, // ,      compensated_entities, // ,    compensated_action // ,       );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte auch darauf hinweisen, dass die Verz√∂gerungskompensation ein Schema ist, das die Erfahrung des Sch√ºtzen √ºber die Erfahrung des Ziels stellt, auf das er schie√üt. </font><font style="vertical-align: inherit;">Aus Sicht des Ziels kann der Feind zu einem Zeitpunkt in ihn eindringen, an dem er sich bereits hinter einem Hindernis befindet (eine h√§ufige Beschwerde in Spielforen). </font><font style="vertical-align: inherit;">Zu diesem Zweck verf√ºgt die Verz√∂gerungskompensation √ºber eine begrenzte Anzahl von Frames, f√ºr die Ziele ‚Äûabgepumpt‚Äú werden k√∂nnen. </font><font style="vertical-align: inherit;">Im Moment kann in Battle Prime ein Sch√ºtze mit einer RTT von etwa 400 Millisekunden Feinde bequem treffen. </font><font style="vertical-align: inherit;">Wenn die RTT h√∂her ist, m√ºssen Sie vorausschie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr ein Schie√üen ohne Entsch√§digung - Sie m√ºssen vorausschie√üen, um den Feind stetig zu treffen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/510/94b/f4951094b844f899b7bafc0fd2783534.gif" alt="Bild" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und mit Entsch√§digung k√∂nnen Sie bequem direkt auf den Feind zielen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/2fe/126/ffe2fe12616364feb0251847e02b3807.gif" alt="Bild" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Build-Agenten f√ºhren au√üerdem regelm√§√üig Autotests durch, bei denen die Arbeit verschiedener Mechaniker √ºberpr√ºft wird. Unter diesen gibt es auch einen Autotest f√ºr die Z√ºndgenauigkeit mit aktivierter Verz√∂gerungskompensation. Im GIF unten wird dieser Test gezeigt - der Charakter schie√üt einfach auf den Kopf eines vorbeirennenden Feindes und z√§hlt die Anzahl der Treffer auf ihn. Zum Debuggen werden zus√§tzlich die Hitboxen des Feindes angezeigt, die sich zum Zeitpunkt des Schusses auf dem Server befanden (in Wei√ü), und Hitboxen, die zur Treffererkennung in der kompensierten Welt (in Blau) verwendet wurden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f99/8cf/e30/f998cfe305878180085bb44352b36a85.gif" alt="Bild" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Faktor, der die Genauigkeit der Aufnahme beeinflusst, ist die Position der Trefferfelder auf dem Charakter. Hitboxen h√§ngen von Skelettanimationen ab und ihre Phasen sind derzeit in keiner Weise synchronisiert. Daher ist eine Situation m√∂glich, in der sich Hitboxen zwischen Client und Server unterscheiden. Die Konsequenzen h√§ngen von den Animationen selbst ab. Je gr√∂√üer der Bewegungsbereich innerhalb der Animation ist, desto gr√∂√üer ist der potenzielle Unterschied in der Position der Hitboxen zwischen Server und Client. In der Praxis ist ein solcher Unterschied f√ºr den Spieler nicht erkennbar und betrifft den Unterk√∂rper st√§rker, was im Vergleich zum Oberk√∂rper (Kopf, Rumpf, Arme) weniger kritisch ist. Dennoch m√∂chte ich in Zukunft das Problem der Synchronisierung von Animationen zwischen Server und Client genauer behandeln.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel habe ich versucht, die Grundlage zu beschreiben, auf der Battle Prime basiert - dies ist die Implementierung des ECS-Musters in der Blitz Engine sowie des Netzwerkmoduls, das f√ºr die Replikation, Client-Vorhersagen und verwandte Mechaniken verantwortlich ist. </font><font style="vertical-align: inherit;">Trotz einiger M√§ngel (an deren Behebung wir weiter arbeiten) ist die Verwendung dieser Funktionalit√§t jetzt einfach und bequem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Gesamtbild von Battle Prime zu zeigen, musste ich eine Vielzahl von Themen ansprechen. </font><font style="vertical-align: inherit;">Viele von ihnen werden m√∂glicherweise in Zukunft separaten Artikeln gewidmet sein, in denen sie ausf√ºhrlicher beschrieben werden! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel wird bereits in der T√ºrkei und auf den Philippinen getestet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere vorherigen Artikel finden Sie unter folgenden Links:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/de/post/461623</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/de/post/465343</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469709/">https://habr.com/ru/post/de469709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469691/index.html">Wo kann man im Oktober √ºber Apache Ignite und GridGain h√∂ren?</a></li>
<li><a href="../de469693/index.html">Wie man Millionen Chinesen in einer halben Stunde f√ºttert</a></li>
<li><a href="../de469697/index.html">Die Geburt neuer Technologien in traditionell hergestellten Gesch√§ftsprozessen</a></li>
<li><a href="../de469703/index.html">Regelm√§√üige Avalonia</a></li>
<li><a href="../de469707/index.html">Konfigurieren von VSCode f√ºr die Arbeit mit Scala</a></li>
<li><a href="../de469717/index.html">Lass das Licht scheinen</a></li>
<li><a href="../de469721/index.html">Dell OptiPlex 7070 Ultra: Ein modularer Computer, der jeden Monitor in einen Monoblock verwandelt</a></li>
<li><a href="../de469723/index.html">Erstellen einer Stateful-F√§higkeit f√ºr Alice in den serverlosen Funktionen von Yandex.Cloud und Python</a></li>
<li><a href="../de469725/index.html">Solar System Guide f√ºr Anhalter</a></li>
<li><a href="../de469731/index.html">Behandeln von ASP.NET-Ausnahmen mit IRO.Mvc.MvcExceptionHandler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>