<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏼 👨🏿‍🎤 🐸 Telegraff: Kotlin DSL untuk Telegram ✍🏽 👦🏿 👨🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tentang Habré, ribuan artikel tentang cara membuat bot Telegram untuk berbagai bahasa dan platform pemrograman. Topiknya jauh dari baru. 


 Tapi Tele...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Telegraff: Kotlin DSL untuk Telegram</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445072/"><p><img src="https://habrastorage.org/webt/3v/da/0z/3vda0ztz83mtq8efycve_gfyrqa.png" alt="Logo"></p><br><p>  Tentang Habré, ribuan artikel tentang cara membuat bot Telegram untuk berbagai bahasa dan platform pemrograman.  Topiknya jauh dari baru. </p><br><p>  Tapi Telegraff adalah kerangka kerja terbaik untuk menerapkan bot Telegram, dan saya akan membuktikannya di bawah potongan. </p><a name="habracut"></a><br><h2 id="preambula">  Pembukaan </h2><br><p>  Pada 2015, rubel Rusia mengalami demam.  Saya memiliki tabungan dalam dolar dan saya memeriksa kurs secara harfiah setiap lima menit untuk menjual mata uang pada kurs yang saya butuhkan.  Demam berlarut-larut, saya lelah dan menulis bot Telegram ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@TinkoffRatesBot</a> ), yang memberi tahu Anda jika nilai tukar mencapai nilai ambang (yang diharapkan). <br>  Saya sangat tersentuh dengan tugas ini.  Botha menulis dengan cukup cepat, tetapi dia tidak menerima kepuasan. </p><br><p> Integrasi dengan Telegram tidak dan tidak ada masalah.  Masalah ini teratasi dalam beberapa jam.  Dan saya bahkan terkejut bahwa ada seluruh perpustakaan di Jawa (secara subyektif, dengan kode yang menjijikkan dalam kualitas) untuk integrasi dengan Telegrams, yang telah mendapatkan lebih dari seribu bintang di Github. </p><br><p>  Tantangan utama bagi saya adalah sistem scripting: pengguna memanggil perintah, misalnya, "/ taksi", bot menanyakan serangkaian pertanyaan, setiap jawaban divalidasi dan dapat mempengaruhi urutan pertanyaan berikutnya, "bentuk" yang biasa terbentuk, diberikan kepada metode pemrosesan akhir untuk membentuk tanggapan. <br>  Saya melakukan ini, tetapi struktur kelas, tingkat abstraksi, semuanya sangat heterogen sehingga pahit untuk dilihat.  Saya tersiksa oleh pertanyaan: Bagaimana ini dapat secara ringkas dan organik ditransfer ke model berorientasi objek? </p><br><p>  Saya ingin memiliki sesuatu yang sederhana, nyaman, dan yang paling penting - untuk dapat menggambarkan seluruh skrip dalam satu file yang terisolasi sehingga saya tidak perlu melihat setengah dari proyek untuk memahami rantai interaksi pengguna. </p><br><p>  Bukan untuk mengatakan bahwa masalah itu sangat akut, karena tugasnya sudah diselesaikan.  Sebaliknya, kadang-kadang saya memikirkannya.  Pikirannya adalah Groovy DSL, tetapi ketika Kotlin tiba, pilihannya menjadi jelas.  Jadi Telegraff muncul. </p><br><p>  Ya, tentu saja, tidak ada persaingan yang akan dimenangkan Telegraff.  Dan klaim bahwa Telegraff adalah yang terbaik seharusnya tidak diterima secara harfiah.  Tapi Telegraff adalah pendekatan baru dan unik untuk tantangan ini.  Mudah untuk menjadi yang terbaik, menjadi satu-satunya. </p><br><h2 id="kak-etim-polzovatsya">  Bagaimana cara menggunakannya? </h2><br><h3 id="zavisimosti">  Ketergantungan </h3><br><p>  Langkah pertama adalah menentukan repositori tambahan untuk dependensi.  Mungkin pada titik tertentu saya akan menerbitkan Telegraff di Maven Central atau di JCenter, tetapi untuk sekarang. </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre><code class="kotlin hljs">repositories { maven { url <span class="hljs-string"><span class="hljs-string">"https://dl.bintray.com/ruslanys/maven"</span></span> } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>bintray-ruslanys-maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>bintray<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>https://dl.bintray.com/ruslanys/maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Itu tetap berlaku untuk kecil.  Untuk menggunakan Telegraff, Anda hanya perlu menentukan satu dependensi spring-boot-starter: </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">compile("me.ruslanys.telegraff:telegraff-starter:1.0.0")</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>me.ruslanys.telegraff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>telegraff-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><h3 id="konfiguraciya">  Konfigurasi </h3><br><p>  Konfigurasi proyek sederhana dan dapat dibatasi pada dua atau tiga parameter pertama: </p><br><div class="spoiler">  <b class="spoiler_title">properti aplikasi</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">telegram.access-key=123 # ① telegram.mode=webhook # ② telegram.webhook-base-url=https://ruslanys.me # ③ telegram.webhook-endpoint-url=/telegram # ④ telegram.handlers-path=handlers # ⑤ telegram.unresolved-filter.enabled=false # ⑥</code> </pre> </div></div><br><ol><li>  Kunci Anda ke API Telegram. </li><li>  Mode menerima pesan (pembaruan) dari Telegram.  Ini bisa berupa polling atau webhook. </li><li>  Jika metode untuk menerima pembaruan ditunjukkan oleh "webhook", Anda harus menentukan jalur ke aplikasi Anda. </li><li>  Jika mau, Anda dapat menentukan jalur Anda sendiri ke titik akhir.  Jika parameter ini tidak didefinisikan ulang, jalur bentuk berikut akan dihasilkan: <code>/telegram/${UUID}</code> .  Sebelum memulai aplikasi, alamat yang ditentukan ditetapkan sebagai alamat kait web.  Di akhir pekerjaan, alamat web hook ditimpa untuk dapat beralih ke polling saat berikutnya dimulai. </li><li>  Jika diinginkan, Anda dapat mengubah folder tempat skrip penangan akan ditemukan.  Secara default, ini adalah folder <code>handlers</code> . </li><li>  <code>UnresolvedFilter</code> termasuk dalam "pengiriman" dan diaktifkan secara default.  Jika tidak ada penangan yang ditemukan pada pesan pengguna, <code>UnresolvedFilter</code> merespons dengan sesuatu seperti "Maaf, saya tidak mengerti Anda :(". </li></ol><br><p>  Saatnya menulis skrip! </p><br><h3 id="obrabotchiki">  Penangan </h3><br><p>  Penangan (skrip) adalah bagian penting dari Telegraff.  Di sinilah rantai interaksi pengguna diatur.  Intinya adalah bahwa setiap perintah, seperti "/ mulai", "/ taksi", "/ bantuan", adalah skrip / skrip / penangan / penangan yang terpisah. </p><br><p>  Sebuah skrip dapat berisi serangkaian langkah (pertanyaan) yang harus dilalui pengguna untuk menjalankan perintah.  Dengan kata lain, pengguna harus mengisi formulir.  Dan karena messenger berasal dari antarmuka, Anda perlu berbicara dan bertanya kepada pengguna. </p><br><p>  Apakah saya perlu menjelaskan bahwa respons pengguna perlu divalidasi?  Hal pertama yang akan dilakukan pengguna adalah dia akan merespons secara berbeda dari yang Anda harapkan. </p><br><p>  Nah, pada akhirnya, skrip bisa bercabang, mis.  Setiap jawaban atas suatu pertanyaan dapat memengaruhi urutan jawaban berikutnya. </p><br><p>  Sebagai contoh! </p><br><p>  Untuk memulai, letakkan file dengan ekstensi <code>.kts</code> di folder dengan <code>handlers</code> sumber daya: <code>src/main/resources/handlers/ExampleHandler.kts</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Skenario panggilan taksi</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentMethod</span></span></span><span class="hljs-class"> </span></span>{ CARD, CASH } handler(<span class="hljs-string"><span class="hljs-string">"/taxi"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ① step&lt;String&gt;("locationFrom") { // ② question { // ③ MarkdownMessage(" ?") } } step&lt;String&gt;("locationTo") { question { MarkdownMessage(" ?") } } step&lt;PaymentMethod&gt;("paymentMethod") { question { state -&gt; MarkdownMessage("   ?", "", "") // ④ } validation { // ⑤ when (it.toLowerCase()) { "" -&gt; PaymentMethod.CARD "" -&gt; PaymentMethod.CASH else -&gt; throw ValidationException(",    ") // ⑥ } } next { state -&gt; null // ⑦ } } process { state, answers -&gt; // ⑧ val from = answers["locationFrom"] as String val to = answers["locationTo"] as String val paymentMethod = answers["paymentMethod"] as PaymentMethod // ⑨ // Business logic MarkdownMessage("""     #${state.chat.id}.   $from  $to.  $paymentMethod. """.trimIndent()) // ⑩ } }</span></span></code> </pre> </div></div><br><p>  Kunci-kunci stepa sengaja tidak dimasukkan ke dalam konstanta.  Dalam produksi, tentu saja, ini sebaiknya dihindari. </p><br><p>  Mari kita cari tahu: </p><br><ol><li>  Kami mendeklarasikan skrip.  Setidaknya diperlukan satu nama tim.  Dalam hal ini, ada dua tim: "/ taksi", "taksi".  Jika pesan pengguna dimulai dengan kata-kata ini, penangan yang sesuai akan dipanggil. </li><li>  Kami menentukan langkah-langkah (pertanyaan).  Nama langkah unik diperlukan karena  selanjutnya, respons pengguna dapat diakses dengan tepat dengan kunci ini ("locationFrom"). </li><li>  Setiap langkah berisi tiga bagian, yang pertama adalah pertanyaan itu sendiri.  Pertanyaannya adalah bagian wajib yang harus ada di setiap langkah.  Tidak ada artinya dalam langkah tanpa pertanyaan. </li><li>  Anda dapat mengisi pertanyaan sesuai keinginan.  Dalam hal ini, pengguna akan diminta melalui keyboard untuk memilih salah satu opsi: "Kartu" atau "Uang Tunai".  Sebagai hasil dari memanggil blok ini, harus ada objek bertipe <code>TelegramSendRequest</code> .  Maaf, saya tidak dapat menghasilkan sesuatu yang lebih baik daripada akhiran <code>SendRequest</code> , yang menggambarkan struktur sebagai permintaan keluar di Telegram. <br><img src="https://habrastorage.org/webt/zc/fg/u0/zcfgu08yo--cn3bhnrnhawcfad0.png" alt="Struktur kelas"></li><li>  Bagian langkah terpenting kedua adalah memeriksa respons pengguna.  Jenis setiap langkah adalah parameter (generik), dan oleh karena itu, blok validasi harus mengembalikan dengan tepat tipe langkahnya parameter. </li><li>  Jika respons pengguna tidak memuaskan, Anda dapat melempar <code>ValidationException</code> dengan teks klarifikasi, tetapi keyboard yang sama, jika ditunjukkan dalam pertanyaan. </li><li>  Bagian langkah terakhir adalah blok yang menunjukkan langkah selanjutnya.  Secara default, langkah-langkah akan dieksekusi dalam urutan deklarasi mereka, dari atas ke bawah.  Tetapi proses ini dapat dipengaruhi dengan mengganti blok yang sesuai.  Entah kunci langkah berikutnya ( <code>String</code> ) atau "null" dapat dikembalikan sebagai hasil dari eksekusi blok ini, yang menunjukkan bahwa tidak ada langkah lagi dan sekarang saatnya untuk melanjutkan ke pelaksanaan perintah. </li><li>  Ketika permintaan pengguna dihasilkan, pemrosesan diperlukan.  Argumen dalam lambda adalah Negara (ini seperti sesi) dan respons pengguna. </li><li>  Perhatikan bahwa respons yang gagal bukan lagi string respons pengguna, tetapi objek yang sudah diproses dari tipe yang diinginkan. </li><li>  Respons terhadap perintah dapat berupa apa saja, mirip dengan paragraf 4. Jika respons terhadap perintah tidak diperlukan, Anda dapat mengembalikan "null". </li></ol><br><p>  Seorang pawang mungkin tidak memiliki langkah sama sekali.  Dalam hal ini, Anda hanya perlu menentukan perilaku penangan untuk menjalankan perintah. </p><br><div class="spoiler">  <b class="spoiler_title">Skrip selamat datang</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">handler(<span class="hljs-string"><span class="hljs-string">"/start"</span></span>) { process { _, _ -&gt; MarkdownMessage(<span class="hljs-string"><span class="hljs-string">"!"</span></span>) } }</code> </pre> </div></div><br><h3 id="probuem">  Coba </h3><br><p>  Untuk mencoba, garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> , clone ke mesin lokal dan pergi ke folder <code>telegraff-sample</code> .  Konfigurasikan, luncurkan, sentuh! </p><br><p>  Secara umum, <code>telegraff-sample</code> adalah proyek yang sengaja independen yang tidak terkait dengan induk dan bahkan memiliki Gradle Wrapper sendiri.  Anda hanya dapat meninggalkan folder ini.  Ini adalah jenis pola dasar. </p><br><h2 id="kak-eto-ustroeno">  Bagaimana cara kerjanya? </h2><br><h3 id="telegram">  Telegram </h3><br><p>  Integrasi dengan Telegram sangat sederhana dan diterapkan di <a href=""><code>TelegramApi</code></a> . </p><br><p>  Setiap metode sengaja dilaksanakan secara individual karena sejumlah keadaan: mulai dari penggunaan Spring's RestTemplate (dan tes untuk itu), hingga kekhususan API Telegram. </p><br><p>  Seperti yang Anda lihat dari konfigurasi, ada dua jenis klien dari API ini di Telegraff: <a href="">PollingClient</a> , <a href="">WebhookClient</a> .  Bergantung pada konfigurasi, sebuah bin tertentu akan dideklarasikan. </p><br><p>  Dan meskipun metode untuk menerima pembaruan (pesan baru) berbeda dari Telegram, esensinya tidak berubah dan bermuara pada satu hal - menerbitkan acara ( <a href=""><code>TelegramUpdateEvent</code></a> ) tentang pesan baru melalui Spring's <code>EventPublisher</code> (pola “Pengamat”).  Jika mau, Anda dapat menerapkan pendengar Anda sendiri dengan berlangganan jenis acara ini.  Menurut saya, lapisan abstraksi yang logis, karena sama sekali tidak masalah bagaimana pesan itu diterima. </p><br><h3 id="filtry">  Filter </h3><br><p>  Segera setelah pesan baru diterima, diperlukan untuk memprosesnya dan menanggapi pengguna.  Untuk melakukan ini, pesan harus melalui rantai filter. </p><br><p>  Ini mirip dengan filter Java EE yang akrab dengan programmer Java.  Satu-satunya perbedaan adalah bahwa yang disebut Handler (jika kita menggambar paralel dengan Java EE, ini adalah Servlet) tidak terlepas dari filter, tetapi merupakan bagian dari mereka. </p><br><p><img src="https://habrastorage.org/webt/uo/ok/y8/uooky82zpiurpncn-szq4bdejni.png" alt="Filter antai"></p><br><p>  Jadi, filternya disederhanakan dan dapat membiarkan pesan masuk lebih jauh, mungkin tidak. </p><br><p>  <code>LoggingFilter</code> jelas merupakan filter prioritas pertama (pertama) yang akan dipanggil sebagai bagian dari pemrosesan pesan baru.  Log informasi pada pesan masuk dan mengirimkannya lebih lanjut ke rantai.  Saya sengaja menambahkan <code>LoggingFilter</code> sebagai contoh.  Bahkan, mungkin tidak masuk akal, karena  Pesan yang masuk dicatat di tingkat klien. </p><br><p>  Filter berikutnya adalah <code>CancelFilter</code> .  Ini pada dasarnya bekerja bersama dengan <code>HandlersFilter</code> dan merupakan pelengkap untuk itu.  Tugasnya sederhana: jika pengguna ingin meninggalkan skrip saat ini, ia dapat menulis "/ membatalkan", atau "membatalkan" dan Statusnya (sesi) harus dihapus.  Dia dapat memulai skenario baru tanpa menyelesaikan yang sebelumnya.  Untuk alasan ini, <code>CancelFilter</code> "lebih tinggi" (prioritas). </p><br><p>  <code>HandlersFilter</code> adalah filter utama dalam proses saat ini.  Filter inilah yang menyimpan status obrolan pengguna, menemukan dan memanggil penangan (skrip) yang diinginkan, menerapkan blok validasi, menentukan urutan langkah-langkah, dan merespons pengguna. </p><br><p>  Jika <code>HandlersFilter</code> tidak menemukan penangan yang cocok untuk pesan pengguna, baik dalam sesi atau dalam konten, pesan dikirim lebih jauh ke bawah rantai.  Filter ekstrem adalah <code>UnresolvedFilter</code> .  Ini adalah filter yang tahu bahwa itu adalah yang terakhir, oleh karena itu fungsinya sederhana: jika mereka menghubungi saya, cara menanggapi pesan tidak jelas, saya akan mengatakan bahwa saya tidak mengerti apa-apa.  Sepertinya saya lebih baik menerima setidaknya beberapa pesan dari bot jika tidak tahu bagaimana merespons, daripada tidak menerima apa pun. </p><br><p>  Untuk menambahkan filter Anda, Anda perlu mendeklarasikan Bean dari kelas <code>TelegramFilter</code> dan menentukan anotasi <code>@TelegramFilterOrder(ORDER_NUMBER)</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Contoh filter</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@TelegramFilterOrder(Integer.MIN_VALUE)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TelegramFilter { override fun handleMessage</span></span></span></span>(message: TelegramMessage, chain: TelegramFilterChain) { log.info(<span class="hljs-string"><span class="hljs-string">"New message from #{}: {}"</span></span>, message.chat.id, message.text) chain.doFilter(message) } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log = LoggerFactory.getLogger(LoggingFilter::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> </div></div><br><p>  Inilah cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@TinkoffRatesBot</a> mengimplementasikan "kalkulator".  Tanpa memanggil skrip dan perintah apa pun, Anda dapat mengirim nomor, misalnya, "1000", atau bahkan seluruh ekspresi, misalnya, "4500 * 3 - 12000".  Bot akan menghitung hasil dari ekspresi, menerapkan nilai tukar saat ini ke hasil dan menampilkan informasi tentang itu.  Sebenarnya, hasil dari tindakan tersebut adalah eksekusi <code>CalculationFilter</code> , yang berada dalam rantai di bawah <code>HandlersFilter</code> , tetapi di <code>UnresolvedFilter</code> . </p><br><h3 id="obrabotchiki-1">  Penangan </h3><br><p>  Sistem scripting Telegraff (penangan) dibangun di atas Kotlin DSL.  Singkatnya, ini tentang lambda dan tentang pembangun. </p><br><p>  Saya tidak melihat titik melihat secara terpisah Kotlin DSL, karena  ini percakapan yang sangat berbeda.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> hebat dari JetBrains dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> komprehensif dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">i_osipov</a> . </p><br><h3 id="nyuansy">  Nuansa </h3><br><p>  Bagian ini dikhususkan untuk fitur-fitur yang ada.  Semua dari mereka, menurut saya, tidak kritis, beberapa dari mereka dapat diperbaiki, beberapa tidak.  Tetapi Anda perlu tahu tentang aspek-aspek ini. </p><br><p>  Jika Anda memiliki keinginan untuk berpartisipasi atau pengetahuan tentang cara memperbaiki satu atau lain hal dari bagian ini, saya akan sangat berterima kasih. </p><br><h4 id="telegram-1">  Telegram </h4><br><p>  Lapisan integrasi dengan Telegram mungkin tidak sepenuhnya dijelaskan.  Hanya metode yang saya butuhkan yang diterapkan.  Jika ada sesuatu yang tidak Anda miliki secara pribadi, perbaiki <a href=""><code>TelegramApi</code></a> dan kirim PR! </p><br><p>  Salah satu bagian penting saat ini adalah kurangnya dukungan keyboard inline (ini adalah ketika keyboard langsung di bawah pesan di pita).  Tugas ini diperparah oleh fakta bahwa inline-keyboards harus benar "dimasukkan" ke dalam struktur yang ada sehingga tetap sederhana, nyaman, terisolasi.  Sudah ada ide bagus untuk mengimplementasikan fungsi ini, tetapi belum diimplementasikan dan diuji dalam bentuk apa pun. </p><br><h4 id="fat-jar">  Botol lemak </h4><br><p>  Sayangnya, beberapa perpustakaan, seperti <code>JRuby</code> dan mungkin <code>Kotlin Embedded Compiler</code> (diperlukan untuk menyusun skrip) dapat mengalami masalah sebagai bagian dari <code>Fat JAR</code> .  <code>Fat JAR</code> adalah ketika kode Anda dan semua dependensi Anda dikemas dalam satu file ( <code>*.jar</code> ). </p><br><p>  Untuk mengatasi masalah ini, Anda dapat membongkar dependensi dalam runtime.  Yaitu, ketika aplikasi dimulai, JAR ketergantungan dari paket utama dikerahkan di suatu tempat pada disk dan classpath ditunjukkan sebelum itu.  Ini cukup mudah dilakukan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfigurasi</a> <code>bootJar</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi plugin</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bootJar { requiresUnpack "**/**kotlin**.jar" requiresUnpack "**/**telegraff**.jar" }</code> </pre> </div></div><br><p>  Namun, untuk merujuk dari penangan (skrip) ke kacang Anda (layanan, misalnya), mereka juga harus dibongkar.  Yang pada prinsipnya menghilangkan manfaat dari pendekatan ini. </p><br><p>  Seperti yang saya lihat, menggunakan plugin <code>application</code> Gradle tetap menjadi metode yang paling dapat diandalkan, sederhana dan nyaman.  Selain itu, jika Anda menyimpan aplikasi Anda, tidak ada perbedaan dengan hasilnya. </p><br><p>  Tentang semua ini saya tulis secara rinci di <a href="">sini</a> . </p><br><h4 id="poryadok-inicializacii">  Urutan inisialisasi </h4><br><p>  Di sini saya ingin mencatat dua keadaan. </p><br><p>  Pertama, jika Anda melihat skenario panggilan taksi, Anda dapat melihat bahwa kelas <code>enum</code> didefinisikan di atas panggilan ke <code>handler(...)</code> .  Kebutuhan ini dipaksakan oleh fakta bahwa, pada kenyataannya, <code>handler</code> adalah panggilan fungsi.  Panggilan fungsi, yang hasilnya harus berupa struktur, yang akan digunakan Telegraff nanti.  Jika, menurut hasil eksekusi skrip Anda, pabrik tidak dapat membawa hasil ke tipe yang diinginkan, kesalahan akan jatuh pada tahap inisialisasi. </p><br><p>  Kedua, Anda harus ingat bahwa skrip Anda dapat diinisialisasi lebih awal dari seluruh aplikasi dan kacang.  Jika, misalnya, kami meletakkan tautan ke konteks menjadi variabel statis dan mencoba mendapatkan layanan di baris pertama dalam file skrip, mungkin konteksnya tidak akan memilikinya, karena  belum diinisialisasi.  Untuk menghindari masalah seperti itu, gunakan metode Telegraff <a href="">ini</a> .  Ini memastikan bahwa konteksnya diinisialisasi dan bahwa semua kacang yang diperlukan tersedia.  Contohnya bisa dilihat di <a href="">sini</a> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Saya ingin mencoba - garpu, <br>  Saya ingin memperbaikinya - kirim PR, <br>  Saya ingin berterima kasih - letakkan tanda bintang di Github, seperti pos dan beri tahu teman Anda! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori proyek</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445072/">https://habr.com/ru/post/id445072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445060/index.html">Mengatur pencarian data menggunakan Spring-Key Data-Value Repository</a></li>
<li><a href="../id445062/index.html">Format Presentasi Modern?</a></li>
<li><a href="../id445064/index.html">Pertempuran untuk netralitas bersih - kesempatan untuk kembali</a></li>
<li><a href="../id445066/index.html">Bagaimana saya menulis catatan matematika di LaTeX di Vim</a></li>
<li><a href="../id445070/index.html">Intisari materi menarik untuk pengembang seluler # 291 (18 Maret - 24 Maret)</a></li>
<li><a href="../id445074/index.html">Memprogram Basis LibreOffice. Bagian 1</a></li>
<li><a href="../id445076/index.html">Raksasa TI itu memperkenalkan firewall yang ditentukan layanan</a></li>
<li><a href="../id445078/index.html">Fisika kuantum kemungkinan melindungi jaringan listrik AS dari peretas</a></li>
<li><a href="../id445080/index.html">Di Rusia, akan membuat "kereta api digital"</a></li>
<li><a href="../id445082/index.html">Bulan lalu kami menyebut Zuckerberg payudara; dikoreksi: pada kenyataannya, ia dan Facebook-nya hanya memalukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>