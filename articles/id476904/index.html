<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐈 🧒🏾 ⏪ Perpustakaan tiruan lainnya 🌍 🚞 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang Saya terlibat dalam otomatisasi uji. Seperti semua insinyur otomatisasi, saya memiliki seperangkat perpustakaan dan alat yang biasanya s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perpustakaan tiruan lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476904/"><p> Selamat siang  Saya terlibat dalam otomatisasi uji.  Seperti semua insinyur otomatisasi, saya memiliki seperangkat perpustakaan dan alat yang biasanya saya pilih untuk menulis tes.  Tetapi secara berkala ada situasi di mana tidak ada perpustakaan yang dikenal dapat memecahkan masalah dengan risiko membuat autotest tidak stabil atau rapuh.  Pada artikel ini, saya ingin memberi tahu Anda bagaimana tugas standar menggunakan mock'ov membuat saya menulis modul.  Saya juga ingin membagikan keputusan saya dan mendengar umpan balik. </p><a name="habracut"></a><br><h1>  Aplikasi </h1><br><p>  Salah satu sektor yang diperlukan di sektor keuangan adalah audit.  Data perlu diperiksa secara berkala (rekonsiliasi).  Dalam hal ini, aplikasi yang saya uji muncul.  Agar tidak berbicara tentang sesuatu yang abstrak, mari kita bayangkan bahwa tim kami sedang mengembangkan aplikasi untuk memproses aplikasi dari pengirim pesan instan.  Untuk setiap aplikasi, acara yang sesuai harus dibuat di elasticsearch.  Aplikasi verifikasi akan menjadi pemantauan kami agar aplikasi tidak dilewati. </p><br><p>  Jadi, bayangkan kita memiliki sistem yang memiliki komponen berikut: </p><br><ol><li>  Server konfigurasi.  Untuk pengguna, ini adalah titik masuk tunggal di mana ia mengkonfigurasi tidak hanya aplikasi untuk verifikasi, tetapi juga komponen lain dari sistem. </li><li>  Aplikasi verifikasi. </li><li>  Data dari aplikasi memproses aplikasi yang disimpan di elasticsearch. </li><li>  Data referensi.  Format data tergantung pada messenger yang dengannya aplikasi terintegrasi. </li></ol><br><h1>  Tantangan </h1><br><p>  Pengujian otomasi dalam hal ini terlihat cukup mudah: </p><br><ol><li>  Persiapan Lingkungan: <br><ul><li>  Elasticsearch diinstal dengan konfigurasi minimal (menggunakan msi dan baris perintah). </li><li>  Aplikasi verifikasi diinstal. </li></ul></li><li>  Eksekusi uji: <br><ul><li>  Aplikasi verifikasi dikonfigurasikan. </li><li>  Elasticsearch diisi dengan data uji untuk tes yang sesuai (berapa banyak aplikasi yang diproses). </li><li>  Aplikasi menerima data "referensi" dari messenger (berapa banyak aplikasi yang seharusnya sebenarnya). </li><li>  Putusan yang dikeluarkan oleh aplikasi diperiksa: jumlah aplikasi yang berhasil diverifikasi, jumlah aplikasi yang hilang, dll. </li></ul></li><li>  Membersihkan lingkungan. </li></ol><br><p>  Masalahnya adalah kita menguji pemantauan, tetapi untuk mengkonfigurasinya, kita memerlukan data dari server konfigurasi.  Pertama, menginstal dan mengkonfigurasi server untuk setiap proses adalah operasi yang menghabiskan waktu (misalnya, memiliki basis sendiri).  Kedua, saya ingin mengisolasi aplikasi untuk menyederhanakan pelokalan masalah saat menemukan cacat.  Pada akhirnya, diputuskan untuk menggunakan mock. </p><br><p>  Ini mungkin menimbulkan pertanyaan: "Jika kita masih mengejek server, mungkin kita tidak bisa menghabiskan waktu menginstal dan mengisi elasticsearch, tetapi ganti tiruan?".  Tapi tetap saja, Anda harus selalu ingat bahwa penggunaan mock memberikan fleksibilitas, tetapi menambahkan kewajiban untuk memantau relevansi perilaku mock.  Karena itu, saya menolak untuk mengganti elasticsearch: cukup mudah untuk menginstal dan mengisinya. </p><br><h1>  Mock pertama </h1><br><p> Server mengirimkan konfigurasi ke GET permintaan dalam beberapa cara di / konfigurasi.  Kami tertarik pada dua cara.  Yang pertama adalah <code>/configuration/data_cluster</code> dengan konfigurasi cluster </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } }</code> </pre> <br><p>  Yang kedua adalah <code>/configuration/reconciliation</code> dengan konfigurasi aplikasi pengeboran </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-attr"><span class="hljs-attr">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } } }</code> </pre> <br><p>  Kesulitannya adalah Anda harus dapat mengubah respons server selama pengujian atau di antara pengujian untuk menguji bagaimana aplikasi bereaksi terhadap perubahan konfigurasi, kata sandi salah, dll. </p><br><p>  Jadi, mock dan alat statis untuk mock dalam unit test (mock, monkeypatch dari pytest, dll.) Tidak akan bekerja untuk kita.  Saya menemukan perpustakaan <code>pretenders</code> yang menurut saya tepat untuk saya.  <a href="https://pretenders.readthedocs.io/en/latest/" title="Baca dokumentasi Pretenders">Pretenders</a> menyediakan kemampuan untuk membuat server HTTP dengan aturan yang menentukan bagaimana server akan menanggapi permintaan.  Aturan disimpan dalam preset, yang memungkinkan isolasi tiruan untuk suite tes yang berbeda.  Preset dapat dihapus dan diisi ulang, memungkinkan Anda memperbarui jawaban sesuai kebutuhan.  Cukup menaikkan server itu sendiri satu kali selama persiapan lingkungan: </p><br><pre> <code class="bash hljs">python -m pretenders.server.server --host 127.0.0.1 --port 8000</code> </pre> <br><p>  Dan dalam tes kita perlu menambahkan penggunaan klien.  Dalam kasus paling sederhana, ketika jawaban benar-benar dikodekan dalam tes, itu mungkin terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPMock <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.common.constants <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FOREVER @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> mock = HTTPMock(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">8000</span></span>, name=<span class="hljs-string"><span class="hljs-string">"server"</span></span>) request.addfinalizer(mock.reset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/data_cluster"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/reconciliation"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) <span class="hljs-comment"><span class="hljs-comment"># test application</span></span></code> </pre> <br><p>  Tapi itu belum semuanya.  Dengan fleksibilitasnya, <code>pretenders</code> memiliki dua keterbatasan yang harus diingat dan harus ditangani dalam kasus kami: </p><br><ol><li>  Aturan tidak bisa dihapus satu per satu.  Untuk mengubah jawaban, Anda harus menghapus seluruh pra-atur dan membuat ulang semua aturan lagi. </li><li>  Semua jalur yang digunakan dalam aturan relatif.  Preset memiliki lintasan unik dari form / mockhttp / &lt;preset_name&gt;, dan lintasan ini adalah awalan umum untuk semua lintasan yang dibuat dalam aturan.  Aplikasi yang diuji hanya menerima nama host, dan tidak bisa tahu tentang awalan. </li></ol><br><p>  Keterbatasan pertama sangat tidak menyenangkan, tetapi dapat diselesaikan dengan menulis modul yang merangkum pekerjaan dengan konfigurasi.  Misalnya saja </p><br><pre> <code class="python hljs">configuration.data_cluster.port = <span class="hljs-number"><span class="hljs-number">443</span></span></code> </pre> <br><p>  atau (untuk membuat permintaan pembaruan lebih jarang) </p><br><pre> <code class="python hljs">data_cluster_config = get_default_data_cluster_config() data_cluster_config.port = <span class="hljs-number"><span class="hljs-number">443</span></span> configuration.update_data_cluster(data_cluster_config)</code> </pre> <br><p>  Enkapsulasi semacam itu memungkinkan kami memperbarui semua jalur hampir tanpa kesulitan.  Anda juga dapat membuat preset individu untuk setiap titik akhir individu dan preset umum (utama), mengarahkan (melalui 307 atau 308) ke masing-masing.  Maka Anda hanya dapat menghapus satu preset untuk memperbarui aturan. </p><br><p>  Untuk menyingkirkan awalan, Anda dapat menggunakan pustaka <a href="https://mitmproxy.org/" title="Pergi ke situs web mitmproxy">mitmproxy</a> .  Ini adalah alat yang ampuh yang memungkinkan, antara lain, untuk mengarahkan permintaan.  Kami akan menghapus awalan sebagai berikut: </p><br><pre> <code class="bash hljs">mitmdump --mode reverse:http://127.0.0.1:8000 --replacements :~http:^/:/mockhttp/server/ --listen-host 127.0.01 --listen-port 80</code> </pre> <br><p>  Parameter dari perintah ini melakukan hal berikut: </p><br><ol><li>  <code>--listen-host 127.0.0.1</code> dan <code>--listen-port 80</code> jelas.  Mitmproxy menaikkan servernya, dan dengan parameter ini kami menentukan antarmuka dan port yang akan didengarkan server ini. </li><li>  <code>--mode reverse:http://127.0.0.1:8000</code> berarti permintaan ke server mitproxy akan dialihkan ke <code>http://127.0.0.1:8000</code> .  Baca lebih lanjut di <a href="https://docs.mitmproxy.org/stable/concepts-modes/" title="Dokumentasi berbagai mode">sini</a> . </li><li>  <code>--replacements :~http:^/:/mockhttp/server/</code> mendefinisikan templat dengan mana permintaan akan diubah.  Ini terdiri dari tiga bagian: filter permintaan ( <code>~http</code> untuk permintaan HTTP), template untuk mengubah ( <code>^/</code> untuk mengganti awal jalan), dan benar-benar mengganti ( <code>/mockhttp/server</code> ).  Baca lebih lanjut di <a href="https://docs.mitmproxy.org/stable/overview-features/" title="Dokumentasi Fungsi">sini</a> . </li></ol><br><p>  Dalam kasus kami, kami menambahkan <code>mockhttp/server</code> ke semua permintaan HTTP dan mengalihkannya ke <code>http://127.0.0.1:8000</code> , i.e.  ke server pretenders kami.  Sebagai hasilnya, kami telah mencapai bahwa sekarang konfigurasi dapat diperoleh dengan permintaan GET ke <code>http://127.0.0.1/configuration/data_cluster</code> . </p><br><p>  Secara umum, saya puas dengan desain dengan <code>pretenders</code> dan <code>mitmproxy</code> .  Dengan kompleksitas yang jelas - setelah semua, 2 server bukan satu yang nyata - persiapan terdiri dari menginstal 2 paket dan mengeksekusi 2 perintah pada baris perintah untuk memulainya.  Tidak semuanya begitu sederhana dalam mengelola mock, tetapi semua kompleksitas hanya ada di satu tempat (mengelola preset) dan diselesaikan dengan cukup sederhana dan andal.  Namun, keadaan baru muncul dalam masalah yang membuat saya berpikir tentang solusi baru. </p><br><h1>  Mock kedua </h1><br><p>  Sampai saat itu, saya hampir tidak mengatakan dari mana data referensi berasal.  Pembaca yang penuh perhatian mungkin memperhatikan bahwa dalam contoh di atas, jalur ke sistem file digunakan sebagai alamat sumber data.  Dan itu benar-benar berfungsi seperti ini, tetapi hanya untuk salah satu vendor.  Vendor lain menyediakan API untuk menerima aplikasi, dan di situlah timbul masalah.  Sulit untuk meningkatkan API vendor selama pengujian, jadi saya berencana untuk menggantinya dengan tiruan sesuai dengan skema yang sama seperti sebelumnya.  Tetapi untuk menerima aplikasi, permintaan formulir </p><br><pre> <code class="plaintext hljs">GET /application-history?page=2&amp;size=5&amp;start=1569148012&amp;end=1569148446</code> </pre> <br><p>  Ada 2 poin di sini.  Pertama, beberapa opsi.  Faktanya adalah bahwa parameter dapat ditentukan dalam urutan apa pun, yang sangat menyulitkan ekspresi reguler untuk aturan <code>pretenders</code> .  Perlu juga diingat bahwa parameternya opsional, tetapi ini bukan masalah seperti urutan acak.  Kedua, parameter terakhir (mulai dan akhir) menentukan interval waktu untuk memfilter pesanan.  Dan masalah dalam hal ini adalah bahwa kita tidak dapat memprediksi terlebih dahulu interval mana (bukan besarnya, tetapi waktu mulai) yang akan digunakan oleh aplikasi untuk membentuk respon tiruan.  Sederhananya, kita perlu tahu dan menggunakan nilai-nilai parameter untuk membentuk jawaban "masuk akal".  “Masuk akal” dalam hal ini penting, misalnya, sehingga kami dapat menguji bahwa aplikasi melewati semua halaman pagination: jika kami menjawab semua permintaan dengan cara yang sama, maka kami tidak akan dapat menemukan cacat karena fakta bahwa hanya satu halaman dari lima yang diminta. . </p><br><p>  Saya mencoba mencari solusi alternatif, tetapi pada akhirnya saya memutuskan untuk mencoba menulis sendiri.  Jadi ada <a href="https://github.com/KillAChicken/loose-server" title="Pergi ke repositori dan dokumentasi">server yang longgar</a> .  Ini adalah aplikasi <a href="https://palletsprojects.com/p/flask/" title="Pergi ke halaman proyek">Flask</a> di mana jalur dan respons dapat dikonfigurasikan setelah dimulai.  Di luar kotak, ia tahu cara bekerja dengan aturan untuk tipe permintaan (GET, POST, dll.) Dan untuk path.  Ini memungkinkan Anda untuk mengganti <code>pretenders</code> dan <code>mitmproxy</code> dalam tugas asli.  Saya juga akan menunjukkan bagaimana itu dapat digunakan untuk membuat tiruan untuk API vendor. </p><br><p>  Aplikasi membutuhkan 2 jalur utama: </p><br><ol><li>  Titik akhir dasar.  Ini adalah awalan yang sama yang akan digunakan untuk semua aturan yang dikonfigurasi. </li><li>  Titik akhir konfigurasi.  Ini adalah awalan dari permintaan tersebut yang dengannya Anda dapat mengkonfigurasi server tiruan itu sendiri. </li></ol><br><pre> <code class="bash hljs">python -m looseserver.default.server.run --host 127.0.0.1 --port 80 --base-endpoint / --configuration-endpoint /_mock_configuration/</code> </pre> <br><p>  Secara umum, yang terbaik adalah tidak mengkonfigurasi titik akhir basis dan titik akhir konfigurasi sehingga satu adalah induk dari yang lain.  Kalau tidak, ada risiko bahwa jalur untuk konfigurasi dan untuk pengujian akan bertentangan.  Titik akhir konfigurasi akan diutamakan, karena aturan Flask ditambahkan untuk konfigurasi lebih awal daripada untuk jalur dinamis.  Dalam kasus kami, kami dapat menggunakan <code>--base-endpoint /configuration/</code> jika kami tidak akan memasukkan vendor API dalam tiruan ini. </p><br><p>  Versi paling sederhana dari tes tidak banyak berubah </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPClient <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PathRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.response <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FixedResponse @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockFactory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._client = HTTPClient(configuration_url=<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1/_mock_configuration/"</span></span>) self._rule_ids = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, json_response)</span></span></span><span class="hljs-function">:</span></span> rule = self._client.create_rule(PathRule(path=path)) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, status=<span class="hljs-number"><span class="hljs-number">200</span></span>, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_delete_rules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._rule_ids: self._client.remove_rule(rule_id=rule_id) mock = MockFactory() request.addfinalizer(mock._delete_rules) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/data_cluster"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, } ) configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/reconciliation"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///applications"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, } )</code> </pre> <br><p>  Fixture menjadi lebih sulit, tetapi aturan sekarang dapat dihapus satu per satu, yang menyederhanakan pekerjaan dengannya.  Menggunakan <code>mitmproxy</code> tidak lagi diperlukan. </p><br><p>  Mari kita kembali ke API vendor.  Kami akan membuat jenis aturan baru untuk server longgar, yang, tergantung pada nilai parameter, akan memberikan jawaban yang berbeda.  Selanjutnya kita akan menggunakan aturan ini untuk parameter halaman. </p><br><p>  Aturan dan jawaban baru perlu dibuat untuk server dan klien.  Mari kita mulai dengan server: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ServerRule <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ServerRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(ServerParameterRule, self).__init__(rule_type=rule_type) self._parameter_name = parameter_name self._parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_match_found</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._parameter_value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._parameter_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.args <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.args.get(self._parameter_name) == self._parameter_value</code> </pre> <br><p>  Setiap aturan harus mendefinisikan metode <code>is_match_found</code> , yang menentukan apakah itu harus bekerja untuk permintaan yang diberikan atau tidak.  Parameter input untuk itu adalah objek permintaan.  Setelah aturan baru dibuat, perlu "mengajar" server untuk menerimanya dari klien.  Untuk melakukan ini, gunakan <code>RuleFactory</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.application <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> configure_application <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base_endpoint, configuration_endpoint)</span></span></span><span class="hljs-function">:</span></span> server_rule_factory = create_rule_factory(base_endpoint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_parse_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule_type, parameters)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServerParameterRule( rule_type=rule_type, parameter_name=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>], parameter_value=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>], ) server_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=_parse_param_rule, serializer=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, rule: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> configure_application( rule_factory=server_rule_factory, base_endpoint=base_endpoint, configuration_endpoint=configuration_endpoint, ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: application = _create_application(base_endpoint=<span class="hljs-string"><span class="hljs-string">"/"</span></span>, configuration_endpoint=<span class="hljs-string"><span class="hljs-string">"/_mock_configuration"</span></span>) application.run(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">80</span></span>)</code> </pre> <br><p>  Di sini kami membuat pabrik untuk aturan secara default, sehingga berisi aturan yang kami gunakan sebelumnya, dan mendaftarkan tipe baru.  Dalam hal ini, klien tidak memerlukan informasi aturan, sehingga <code>serializer</code> sebenarnya tidak melakukan apa pun.  Selanjutnya pabrik ini ditransfer ke aplikasi.  Dan itu sudah bisa dijalankan seperti aplikasi Flask biasa. </p><br><p>  Situasi dengan klien serupa: kami membuat aturan dan pabrik.  Tetapi untuk klien, pertama, tidak perlu mendefinisikan metode <code>is_match_found</code> , dan kedua, serializer dalam hal ini diperlukan untuk mengirim aturan ke server. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ClientRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ClientRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rule_id=None)</span></span></span><span class="hljs-function">:</span></span> super(ClientParameterRule, self).__init__(rule_type=rule_type, rule_id=rule_id) self.parameter_name = parameter_name self.parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_serialize_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>: rule.parameter_name, <span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>: rule.parameter_value, } client_rule_factory = create_rule_factory() client_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, parameters: ClientParameterRule(rule_type=rule_type, parameter_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>), serializer=_serialize_param_rule, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTPClient(configuration_url=configuration_url, rule_factory=client_rule_factory)</code> </pre> <br><p>  Masih menggunakan <code>_create_client</code> untuk membuat klien, dan aturan dapat digunakan dalam pengujian.  Dalam contoh di bawah ini, saya menambahkan penggunaan aturan default lain: <code>CompositeRule</code> .  Ini memungkinkan Anda untuk menggabungkan beberapa aturan menjadi satu sehingga hanya berfungsi jika masing-masing mengembalikan True untuk memanggil <code>is_match_found</code> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture def configuration_server_mock(request): class MockFactory: def __init__(self): self._client = _create_client("http://127.0.0.1/_mock_configuration/") self._rule_ids = [] def create_paged_rule(self, path, page, json_response): rule_prototype = CompositeRule( children=[ PathRule(path=path), ClientParameterRule(parameter_name="page", parameter_value=page), ] ) rule = self._client.create_rule(rule_prototype) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={"Content-Type": "application/json"}, status=200, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) ... mock = MockFactory() request.addfinalizer(mock._delete_rules) return mock def test_something(configuration_server_mock): ... configuration_server_mock.create_paged_rule( path="application-history", page=None, json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="1", json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="2", json_response=["4", "5"], )</span></span></code> </pre> <br><h1>  Kesimpulan </h1><br><p>  <code>mitmproxy</code> <code>pretenders</code> dan <code>mitmproxy</code> menyediakan alat yang cukup kuat dan fleksibel untuk membuat tiruan.  Keuntungannya: </p><br><ol><li>  Pengaturan mudah. </li><li>  Kemampuan untuk mengisolasi set kueri menggunakan preset. </li><li>  Menghapus seluruh set yang terisolasi sekaligus. </li></ol><br><p>  Dengan kontra meliputi: </p><br><ol><li>  Kebutuhan untuk membuat ekspresi reguler untuk aturan. </li><li>  Ketidakmampuan untuk mengubah aturan secara individual. </li><li>  Kehadiran awalan untuk semua jalur yang dibuat atau penggunaan pengalihan menggunakan <code>mitmproxy</code> . </li></ol><br><p>  Tautan dokumentasi: <br>  <a href="https://pretenders.readthedocs.io/en/latest/">Pretenders</a> <br>  <a href="https://docs.mitmproxy.org/stable/">Mitmproxy</a> <br>  <a href="https://github.com/KillAChicken/loose-server/wiki">Server longgar</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476904/">https://habr.com/ru/post/id476904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476880/index.html">Boks Keselamatan: CSRF</a></li>
<li><a href="../id476888/index.html">Apa tren desain UX untuk diikuti pada tahun 2020</a></li>
<li><a href="../id476890/index.html">Bagi mereka yang bekerja di Houdini. Tentang program Nature of Vex dan Bites of Python</a></li>
<li><a href="../id476900/index.html">Perangkat otonom pada Arduino, menandakan peningkatan (penurunan) suhu</a></li>
<li><a href="../id476902/index.html">Barrymore, apa kabar di sekitar Voximplant? Soket web yang diterapkan, Pak</a></li>
<li><a href="../id476906/index.html">Apa yang Baru di SOLIDWORKS 2020</a></li>
<li><a href="../id476908/index.html">Apakah Hadoop Mati? Bagian 2</a></li>
<li><a href="../id476910/index.html">Antiquities: pilihan kartu suara yang sulit untuk game DOS</a></li>
<li><a href="../id476912/index.html">Hak kode perusahaan untuk programmer</a></li>
<li><a href="../id476914/index.html">Instal Powershell Module dari Github Repository</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>