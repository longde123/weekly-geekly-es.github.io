<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåâ üë¥ üï∂Ô∏è Front-End-Domain basierend auf TLS 1.3. Teil 2 üò¢ üé§ üí∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 
 Im ersten Teil des Artikels haben wir den verschl√ºsselten SNI-Mechanismus (eSNI) kurz beschrieben. Sie zeigten, wie es auf dieser Basis m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Front-End-Domain basierend auf TLS 1.3. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477696/"><h3>  Einleitung </h3><br>  Im ersten Teil des <a href="https://habr.com/ru/post/475372/">Artikels haben</a> wir den verschl√ºsselten SNI-Mechanismus (eSNI) kurz beschrieben.  Sie zeigten, wie es auf dieser Basis m√∂glich ist, die Erkennung durch moderne DPI-Systeme (am Beispiel von Beeline DPI und verbotenem ILV-Rutracker) zu umgehen und eine neue Version des Domain-Frontends zu untersuchen, die auf diesem Mechanismus basiert. <br><br>  Im zweiten Teil des Artikels werden wir uns weiteren praktischen Dingen zuwenden, die RedTeam f√ºr Spezialisten bei ihrer schwierigen Arbeit von Nutzen sein werden.  Letztendlich ist es unser Ziel, keinen Zugriff auf blockierte Ressourcen zu erhalten (f√ºr solche allt√§glichen Dinge haben wir ein gutes altes VPN).  Gl√ºcklicherweise gibt es sehr viele VPN-Anbieter f√ºr jeden Geschmack, jede Farbe und jedes Budget. <br><br>  Wir werden versuchen, den Domain-Fronting-Mechanismus auf moderne RedTeam-Tools wie Cobalt Strike, Empire usw. anzuwenden und ihnen zus√§tzliche M√∂glichkeiten zur Nachahmung und Umgehung moderner Inhaltsfiltersysteme zu bieten. <br><a name="habracut"></a><br>  Beim letzten Mal haben wir den eSNI-Mechanismus in der OpenSSL-Bibliothek implementiert und ihn erfolgreich im bekannten Dienstprogramm curl verwendet.  Aber eine Locke, wie sie sagen, wird nicht voll sein.  Nat√ºrlich m√∂chte ich etwas √Ñhnliches in Hochsprachen implementieren.  Leider entt√§uscht uns eine fl√ºchtige Suche nach der Weite des Netzwerks, da die Unterst√ºtzung des eSNI-Mechanismus nur in GOLANG vollst√§ndig implementiert ist.  Daher ist unsere Auswahl nicht sehr gro√ü: Entweder schreiben wir in reinem C oder C ++ mit der gepatchten OpenSSL-Bibliothek, oder wir verwenden eine separate GOLANG-Verzweigung von CloudFlare und versuchen, unser Toolkit dort zu portieren.  Grunds√§tzlich gibt es eine andere Option, die klassischer, aber auch zeitaufw√§ndiger ist - die Implementierung der eSNI-Unterst√ºtzung f√ºr Python.  Schlie√ülich verwendet Python auch OpenSSL, um mit https zu arbeiten.  Aber wir werden diese Option f√ºr die Entwicklung jemand anderem √ºberlassen und uns mit der Implementierung auf dem Golang begn√ºgen, zumal unser geliebter Cobalt Strike perfekt mit einem Kommunikationskanal arbeiten kann, der von Tools von Drittanbietern (externer C2-Kanal) erstellt wurde - wir werden am Ende des Artikels dar√ºber sprechen. <br><br><h3>  Versuchen Sie es noch einmal ... </h3><br>  Eines der auf Go implementierten Tools ist unsere Entwicklung f√ºr das Pivoting innerhalb des Netzwerks - der rsockstun- <a href="https://github.com/mis-team/rsockstun">Tuner</a> , der von Microsoft- und Symantec-Tools jetzt √ºbrigens als sehr b√∂sartige Software erkannt wird, die die Stabilit√§t der Welt verletzen soll ... <br><br><img src="https://habrastorage.org/webt/fg/mu/z4/fgmuz4c7bq1aazvf6su5qjbh32o.png"><br><br>  Es w√§re gro√üartig, die vorherige Entwicklung in diesem Fall zu verwenden.  Aber hier tritt ein kleines Problem auf.  Tatsache ist, dass rsockstun zun√§chst die Verwendung eines synchronen SSL-Kommunikationskanals mit dem Server impliziert.  Dies bedeutet, dass die Verbindung einmal hergestellt wird und f√ºr die gesamte Dauer des Tunnelbetriebs besteht.  Und wie Sie verstehen, ist das https-Protokoll nicht f√ºr diesen Betriebsmodus ausgelegt - es funktioniert im Anforderungs-Antwort-Modus, in dem jede neue http-Anforderung im Rahmen einer neuen TCP-Verbindung vorhanden ist. <br><br>  Der Hauptnachteil dieses Schemas besteht darin, dass der Server keine Daten an den Client √ºbertragen kann, bis der Client eine neue http-Anforderung sendet.  Aber zum Gl√ºck gibt es viele M√∂glichkeiten, dieses Problem zu l√∂sen - das Streaming von Daten √ºber das http-Protokoll (am Ende schaffen wir es irgendwie, unsere Lieblingssendungen im Fernsehen zu sehen und Musik von Portalen zu h√∂ren, die auf https laufen, und die Video- und Audio√ºbertragung ist das nicht andere als Streaming-Daten).  Eine der Technologien zur Emulation des Betriebs einer vollwertigen TCP-Verbindung √ºber das HTTP-Protokoll ist die WebSockets-Technologie, deren Hauptbestandteil die Organisation einer vollwertigen Netzwerkverbindung zwischen dem Client und dem Webserver ist. <br><br>  Zu unserem Gl√ºck (hurra hurra !!!) ist diese Technologie standardm√§√üig in allen CloudFlare-Tarifpl√§nen enthalten und funktioniert hervorragend in Kombination mit eSNI.  Dies ist genau das, was wir verwenden werden, um unserem Tunnel beizubringen, Domain-Fronts zu verwenden und sich vor modernen DPIs zu verstecken. <br><br><h3>  Ein bisschen √ºber WebSockets </h3><br>  Zun√§chst werden wir kurz und in einfachen Worten √ºber Web-Sockets berichten, damit jeder eine Vorstellung davon hat, womit wir arbeiten werden. <br><br>  Mithilfe der Web-Socket-Technologie k√∂nnen Sie vor√ºbergehend von einer HTTP-Verbindung zu Standard-Streaming-Daten √ºber ein Netzwerk-Socket wechseln, ohne die hergestellte TCP-Verbindung zu unterbrechen.  Wenn ein Client zu einem Web-Socket wechseln m√∂chte, legt er in seiner http-Anforderung mehrere http-Header fest.  Zwei erforderliche Header sind <i><b>Connection: Upgrade</b></i> und <i><b>Upgrade: Websocket</b></i> .  Es kann auch die Version <i><b>des Websocket-</b></i> Protokolls ( <i><b>Sec-Websockset-Version: 13</b></i> ) und so etwas wie die Base64-Web-Socket <i><b>-ID</b></i> ( <i><b>Sec-WebSocket-Key: DAGDJSiREI3 + KjDfwxm1FA ==</b></i> ) <i><b>erzwingen</b></i> .  Der Server antwortet mit dem HTTP-Code 101 Switching Protocols und setzt auch die Header <i><b>Connection, Upgrade</b></i> und <i><b>Sec-WebSocket-Accept</b></i> .  Der Umschaltvorgang ist im folgenden Screenshot dargestellt: <br><br><img src="https://habrastorage.org/webt/ci/tp/bg/citpbgee5m4fyv9-w5akwwq5t8q.png"><br><br>  Danach kann die WebSocket-Verbindung als abgeschlossen betrachtet werden.  Alle Daten sowohl vom Client als auch vom Server werden jetzt nicht mehr mit http, sondern mit WebSocket-Headern versorgt (sie beginnen mit Byte 0x82).  Jetzt muss der Server nicht mehr auf eine Anfrage vom Client warten, um Daten zu √ºbertragen, wie  TCP-Verbindung ist nicht unterbrochen. <br><br>  Es gibt mehrere Bibliotheken in der Gruppe der Web-Sockets.  Die beliebtesten davon sind <a href="https://github.com/gorilla/websocket">Gorilla WebSocket</a> und Standard <a href="https://godoc.org/golang.org/x/net/websocket">WebSocket</a> .  Wir werden letztere verwenden, weil  es ist einfacher, kleiner und arbeitet, wie man sagt, etwas schneller. <br><br>  Im rsockstun-Clientcode m√ºssen die Aufrufe von net.dial oder tls.dial durch die entsprechenden WebSocket-Aufrufe ersetzt werden: <br><br><img src="https://habrastorage.org/webt/ye/dw/vy/yedwvync3yktwhl_ssd2vm8eniy.png"><br><br><img src="https://habrastorage.org/webt/mw/j3/fw/mwj3fwfivbj7aqqsbg7whlkt9ai.png"><br><br>  Wir m√∂chten, dass der Client Teil unseres Tunnels wird und sowohl √ºber eine direkte SSL-Verbindung als auch √ºber das WebSockset-Protokoll funktioniert.  Dazu erstellen wir analog zu <i><b>connectForSocks ()</b></i> eine separate Funktion <i><b>func connectForWsSocks (Adresszeichenfolge, Proxy-Zeichenfolge) error {...}</b></i> und verwenden sie f√ºr die Arbeit mit Web-Sockets, wenn die beim Start des Clients angegebene Serveradresse mit beginnt ws: oder wss: (im Fall von Secure WebSocket). <br><br>  F√ºr die Serverseite des Tunnels werden wir auch eine separate Funktion f√ºr die Arbeit mit Web-Sockets erstellen.  Darin wird eine Instanz der http-Klasse erstellt und ein http-Verbindungshandler (wsHandler-Funktion) festgelegt: <br><br><img src="https://habrastorage.org/webt/2a/r7/cv/2ar7cvjzjc7wauwsb45ursxie2q.png"><br><br>  Die gesamte Logik f√ºr die Verarbeitung der Verbindung (Autorisierung des Clients mit einem Kennwort, Installation und Beendigung der Yamux-Sitzung) wird im WebSocket-Verbindungshandler abgelegt: <br><br><img src="https://habrastorage.org/webt/6r/kz/ay/6rkzays7haarsd9vyhak3xe4kbw.png"><br><br>  Wir kompilieren das Projekt, starten den Serverteil: <br><br><pre><code class="go hljs">./rsockstun ‚Äìlisten ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> ‚Äìpass P@ssw0rd</code> </pre> <br>  Und dann der Client-Teil: <br><br><pre> <code class="go hljs">./rsockstun -connect ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> ‚Äìpass P@ssw0rd</code> </pre> <br>  Und wir √ºberpr√ºfen die Arbeit auf dem lokalen Host: <br><br><img src="https://habrastorage.org/webt/ci/tl/jh/citljhc7govgdkorfy6xm--c-dw.png"><br><br><img src="https://habrastorage.org/webt/cp/6m/mu/cp6mmuhm2xk5iaupu2wh0kato2s.png"><br><br><h3>  Wir gehen zum Domain-Fronting √ºber </h3><br>  Wir scheinen die Web-Sockets gekl√§rt zu haben.  Gehen wir jetzt direkt zu eSNI und Domain-Fronts.  Wie bereits erw√§hnt, m√ºssen wir, um mit DoH und eSNI arbeiten zu k√∂nnen, einen speziellen Zweig des Golangs von <a href="https://github.com/cloudflare/tls-tris">CloudFlare √ºbernehmen</a> .  Wir brauchen eine Filiale mit eSNI-Unterst√ºtzung (pwu / esni). <br><br>  Wir klonen es lokal f√ºr uns oder laden die entsprechende Zip herunter und erweitern sie: <br><br><pre> <code class="plaintext hljs">git clone -b pwu/esni https://github.com/cloudflare/tls-tris.git</code> </pre> <br>  Dann m√ºssen wir das GOROOT-Verzeichnis kopieren, die entsprechenden Dateien aus dem geklonten Zweig ersetzen und als Hauptverzeichnis festlegen.  Um dem Entwickler diese Kopfschmerzen zu ersparen, haben die Leute von CloudFlare ein spezielles Skript vorbereitet - _dev / go.sh.  Lass es einfach laufen.  Das Skript zusammen mit dem Makefile erledigt alles selbst.  Zum Spa√ü - Sie k√∂nnen im Makefile nach Details suchen. <br><br>  Nach dem Ausarbeiten des Skripts m√ºssen wir beim Kompilieren des Projekts das vom Skript vorbereitete lokale Verzeichnis als GOROOT angeben.  In unserem Fall sieht es so aus: <br><br><pre> <code class="plaintext hljs">GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" go build ‚Ä¶.</code> </pre> <br>  Als n√§chstes m√ºssen wir im Tunnel die Funktionalit√§t implementieren, √∂ffentliche eSNI-Schl√ºssel f√ºr die gew√ºnschte Domain anzufordern und zu analysieren.  In unserem Fall sind dies √∂ffentliche eSNI-Schl√ºssel von CloudFlare-Front-End-Servern.  Dazu erstellen wir drei Funktionen: <br><br><pre> <code class="plaintext hljs">func makeDoTQuery(dnsName string) ([]byte, error) func parseTXTResponse(buf []byte, wantName string) (string, error) func QueryESNIKeysForHost(hostname string) ([]byte, error)</code> </pre> <br>  Die Namen der Funktionen sprechen grunds√§tzlich f√ºr sich.  Wir werden die F√ºllung der Datei esni_query.go entnehmen, die Teil von tls-tris ist.  Die erste Funktion erstellt ein Netzwerkpaket mit einer Anforderung an den CloudFlare-DNS-Server unter Verwendung des DoH-Protokolls (DNS-over-HTTPS), die zweite Funktion analysiert die Abfrageergebnisse und empf√§ngt die Werte der √∂ffentlichen Dom√§nenschl√ºssel, und die dritte Funktion ist ein Container f√ºr die ersten beiden. <br><br>  Als N√§chstes f√ºhren wir <i><b>die</b></i> Funktion zum Anfordern von eSNI-Schl√ºsseln f√ºr die Dom√§ne in unsere neu erstellte Verbindungsfunktion f√ºr den Web-Socket <i><b>connectForWsSocks ein</b></i> .  Wenn der Serverteil funktioniert, legen Sie die TLS-Parameter und den Namen der gef√§lschten "Cover-Domain" fest: <br><br><img src="https://habrastorage.org/webt/s0/kk/vu/s0kkvu24eh0wc7olaeffffknrck.png"><br><br>  Hierbei ist zu beachten, dass der tls-tris-Zweig zun√§chst nicht f√ºr die Verwendung von Domain-Fronting ausgelegt war.  Daher wird der falsche Name des Servers nicht ber√ºcksichtigt (ein leeres Feld serverName wird als Teil des Client-Hallo-Pakets √ºbertragen).  Um dies zu beheben, m√ºssen wir der TlsConfig-Struktur das entsprechende FakeServerName-Feld hinzuf√ºgen.  Wir k√∂nnen das Standardfeld ServerName der Struktur nicht verwenden, weil  es wird von internen tls-mechanismen verwendet und wenn es vom original abweicht, endet der tls-handshake mit einem fehler.  Die Beschreibung der TlsConfig-Struktur ist in der <b>Datei tls / common.go enthalten</b> - wir m√ºssen sie <b>korrigieren</b> : <br><br><img src="https://habrastorage.org/webt/pu/2l/f4/pu2lf425co5cex8zfa-h2ewdbw8.png"><br><br><img src="https://habrastorage.org/webt/q1/jk/2i/q1jk2iiwpohss6nhr1uanlnkqp8.png"><br><br>  Au√üerdem m√ºssen wir √Ñnderungen an der Datei <b>tls / handshake_client.go vornehmen</b> , um unser Feld FakeServerName beim Generieren des TLS-Handshakes zu verwenden: <br><br><img src="https://habrastorage.org/webt/fy/nq/ln/fynqlnmskvfz0exd4im58vzpwfi.png"><br><br>  Das ist alles!  Sie k√∂nnen das Projekt kompilieren und die Arbeit √ºberpr√ºfen.  Bevor Sie den Test ausf√ºhren, m√ºssen Sie jedoch Ihr CloudFlare-Konto konfigurieren.  Nun, wie sagen Sie zum Einrichten - erstellen Sie einfach ein Cloudflare-Konto und binden Sie Ihre Domain daran.  Alle mit DoH, WebSocket und ESNI verbundenen Chips sind standardm√§√üig in CloudFlare enthalten.  Nachdem die DNS-Eintr√§ge aktualisiert wurden, k√∂nnen Sie die Dom√§ne √ºberpr√ºfen, indem Sie die eSNI-Schl√ºsselanforderung ausf√ºhren: <br><br><pre> <code class="plaintext hljs">dig +short txt _esni.df13tester.info</code> </pre> <br><img src="https://habrastorage.org/webt/xh/9a/6g/xh9a6gmmlc1jg-deqesdliip09a.png"><br><br>  Wenn Sie f√ºr Ihre Domain etwas √Ñhnliches sehen, funktioniert alles f√ºr Sie und Sie k√∂nnen mit dem Testen fortfahren. <br><br>  Starten Sie Ubuntu VPS beispielsweise auf DigitalOcean.  PS In unserem Fall stand die gerade vom Provider vergebene VPS-IP-Adresse auf der ILV-Sperrliste.  Wundern Sie sich also nicht, wenn Ihnen etwas √Ñhnliches passiert.  Ich musste ein VPN verwenden, um zu meinem VPS zu gelangen. <br><br>  Wir kopieren das kompilierte rsockstun nach VPS (das ist √ºbrigens ein weiterer Reiz des Golangs - Sie k√∂nnen das Projekt selbst kompilieren und es unter jedem Linux ausf√ºhren, wobei Sie nur die Bitkapazit√§t des Systems beachten) und starten den Serverteil: <br><br><img src="https://habrastorage.org/webt/kx/-w/th/kx-wth7rif35is4bd5_flfmkjzq.png"><br><br>  Und dann der Client-Teil: <br><br><img src="https://habrastorage.org/webt/sf/er/7d/sfer7dpqq1lumfaxmzzxn1n_pfs.png"><br><br>  Wie wir sehen k√∂nnen, hat der Client √ºber den CloudFlare-Front-End-Server √ºber einen Web-Socket erfolgreich eine Verbindung zum Server hergestellt.  Um zu √ºberpr√ºfen, ob der Tunnel genau wie ein Tunnel funktioniert, k√∂nnen Sie √ºber die auf dem Server ge√∂ffneten lokalen Socks5 eine Aufrollanforderung stellen: <br><br><img src="https://habrastorage.org/webt/qg/na/ti/qgnati8zvd8jc9okh4bei0kbihm.png"><br><br>  Nun wollen wir sehen, was DPI im Kommunikationskanal sieht: <br><br><img src="https://habrastorage.org/webt/0p/ph/av/0pphavhdhhnrtfxfkzxsf7vjcxs.png"><br><br>  Zun√§chst greift der Tunnel-Tuner mithilfe des DoH-Mechanismus auf den Cloudflare-DNS-Server f√ºr eSNI-Schl√ºssel f√ºr die Zieldom√§ne (Pakete Nr. 1-19) zu, greift dann auf den Front-End-Server zu und stellt eine TLS-Verbindung her, die sich unter der Domain <a href="http://www.google.com/">www.google.com</a> (dieser Wert) versteckt Standardm√§√üig, wenn beim Client-Start keine gef√§lschte Dom√§ne festgelegt wurde.  Um Ihre gef√§lschte Domain anzugeben, m√ºssen Sie den Parameter -fronfDomain verwenden: <br><br><img src="https://habrastorage.org/webt/zp/8l/0_/zp8l0_a_cktaz6rrrgao4qo8c2g.png"><br><br><img src="https://habrastorage.org/webt/cq/gn/wn/cqgnwnp9bzo7hzjpb8gcgvqfd6i.png"><br><br>  Nun noch eine Sache.  Standardm√§√üig sind die Kontoeinstellungen von CloudFalre auf Flexible SSL eingestellt.  Dies bedeutet, dass https-Anforderungen von Clients an Cloudflare-Front-End-Server unverschl√ºsselt (http) an unseren Server umgeleitet werden.  Aus diesem Grund haben wir den Serverteil des Tunnels im Nicht-SSL-Modus gestartet (-listen ws: 0.0.0.0) und nicht (-listen wss: 0.0.0.0). <br><br><img src="https://habrastorage.org/webt/4j/fy/5n/4jfy5nl5csmeqc6bxd7vbgdhm7a.png"><br><br>  Um in den vollst√§ndigen Verschl√ºsselungsmodus zu wechseln, m√ºssen Sie <b>Vollst√§ndig</b> oder <b>Vollst√§ndig (streng)</b> ausw√§hlen, wenn dieses Zertifikat auf dem Server vorhanden ist.  Nach dem Umschalten des Modus k√∂nnen wir Verbindungen von CloudFlare √ºber das https-Protokoll akzeptieren.  Denken Sie daran, ein selbstsigniertes Zertifikat f√ºr die Serverseite des Tunnels zu generieren. <br><br><img src="https://habrastorage.org/webt/ou/9x/9i/ou9x9ihogwotva8y-xwda5v12ps.png"><br><br>  Ein nerviger Leser fragt: ‚ÄûWas ist mit dem Kundenkonto unter Windows?  In der Tat besteht die Hauptanwendung des Tunnels darin, die Verbindung von Unternehmenscomputern und -servern aus wiederherzustellen. In der Regel handelt es sich dabei immer um Windows.  Wie kann ich einen Tunnel f√ºr Windows und sogar mit einem bestimmten TLS-Stack kompilieren? ‚ÄúUnd jetzt werden wir einen weiteren Chip vorstellen, der zeigt, wie praktisch der Golang ist.  Wir kompilieren Fenster direkt aus Kali, indem wir einfach den Parameter GOOS = windows hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">GOARCH=amd64 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  Oder eine 32-Bit-Option: <br><br><pre> <code class="plaintext hljs">GOARCH=386 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  Das ist alles!  Und es sind keine Probleme mehr n√∂tig.  Das funktioniert wirklich! <br><br><img src="https://habrastorage.org/webt/hq/cc/qf/hqccqf4y2sim1yutlrdduo3kmom.png"><br><br>  Die Compiler-Flags ‚Äìw und ‚Äìs werden ben√∂tigt, um √ºbersch√ºssigen Datenm√ºll aus der ausf√ºhrbaren Datei zu entfernen und um einige Megabyte zu reduzieren.  Au√üerdem kann es dann mit UPX verpackt werden, um die Gr√∂√üe weiter zu verringern. <br><br><h3>  Anstelle einer Schlussfolgerung </h3><br>  In dem Artikel haben wir anhand eines auf einem Golang geschriebenen Tuner-Beispiels die Verwendung der neuen Technologie des Domain-Fronting demonstriert, die auf einem ziemlich interessanten Merkmal des TLS 1.3-Protokolls implementiert ist.  In √§hnlicher Weise k√∂nnen Sie das vorhandene Toolkit, das auf dem Golang geschrieben ist, so anpassen, dass es √ºber den CloudFlare-Server funktioniert, z. B. <a href="https://github.com/Ne0nd0g/merlin">Merlin</a> , das bekannte C2, oder CobaltStrike Beacon zur Verwendung von eSNI-Dom√§nenfronten zwingen, wenn Sie mit Teamserver √ºber den auf dem Golang implementierten <a href="https://github.com/ryhanson/ExternalC2">externen C2-Kanal</a> oder unter Verwendung von Standard C ++ arbeiten die gepatchte Version von OpenSSL, √ºber die wir im letzten Teil des Artikels gesprochen haben.  Der Fantasie sind im Allgemeinen keine Grenzen gesetzt. <br><br>  Das Beispiel des Tunnels und von CloudFlare wird in Form eines Konzepts dargestellt, und es ist immer noch schwer zu sagen, wie weit die Aussichten f√ºr diese Art von Domain-Front-Facing sind.  Derzeit ist die Unterst√ºtzung f√ºr eSNI nur bei CloudFlare verf√ºgbar. Grunds√§tzlich hindert sie nichts daran, diese Art von Front-End zu deaktivieren und z. B. die tls-Verbindungen zu trennen, wenn SNI und eSNI nicht √ºbereinstimmen.  Im Allgemeinen wird die Zukunft zeigen.  Aber im Moment scheint die Aussicht, unter dem Deckmantel von kremlin.ru zu arbeiten, ziemlich attraktiv zu sein.  Oder? <br><br>  Der aktualisierte <a href="https://github.com/mis-team/rsockstun">Tunnelcode</a> sowie kompilierte ausf√ºhrbare EXE-Dateien befinden sich in einem separaten Projektzweig auf <a href="https://github.com/mis-team/rsockstun">Github</a> .  Es ist besser, ein Problem mit allen m√∂glichen Tunnelproblemen auf der Projektseite von GitHub zu schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477696/">https://habr.com/ru/post/de477696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477684/index.html">Angular: Der beste Begleiter f√ºr interaktive Apps</a></li>
<li><a href="../de477686/index.html">Unsere auf der AI Journey Konferenz</a></li>
<li><a href="../de477688/index.html">Dezember IT Events Digest</a></li>
<li><a href="../de477692/index.html">Erfahrung mit ZGC und Shenandoah GC in der Produktion</a></li>
<li><a href="../de477694/index.html">JavaScript muss nicht durch irgendetwas ersetzt werden - auch andere Sprachen haben die gleichen Probleme</a></li>
<li><a href="../de477700/index.html">Hollywood-Prinzip (IoC)</a></li>
<li><a href="../de477706/index.html">Gemischte Inhalte beim Herunterladen von HTTPS: So finden und √ºberwinden Sie</a></li>
<li><a href="../de477710/index.html">Was sie in der Schule nicht unterrichten: Wie wir Techniker ausbilden</a></li>
<li><a href="../de477712/index.html">Objekte versus Datenstrukturen</a></li>
<li><a href="../de477716/index.html">Mathematiker berechnen anhand des Beispiels "Tag", wie Zuf√§lligkeiten auftreten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>