<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😔 👨🏿‍🤝‍👨🏼 🖲️ C＃和JavaScript的比较。 基础知识 🚒 🍋 🎼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我或多或少认真的编程道路始于用C＃编写程序，有时我尝试使用JavaScript编写，然后在我错误地输入变量名并在后来发现它的情况下陷入混乱。  很多很多年  一个小时的调试时间，因为我不在编译器附近，这将在困难时期帮助我。 一段时间之后，除了C＃外，我还开始编写许多JavaScript代码，现在我可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃和JavaScript的比较。 基础知识</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414593/"><p><img src="https://habrastorage.org/webt/kk/qk/mh/kkqkmhvelvgdfaantf2jkxvzyky.png" alt="C＃和JavaScript"></p><br><p> 我或多或少认真的编程道路始于用C＃编写程序，有时我尝试使用JavaScript编写，然后在我错误地输入变量名并在后来发现它的情况下陷入混乱。 <del> 很多很多年 </del> 一个小时的调试时间，因为我不在编译器附近，这将在困难时期帮助我。 一段时间之后，除了C＃外，我还开始编写许多JavaScript代码，现在我可以毫无困难地做到这一点，我不再对隐式类型转换和动态类型感到困惑。 </p><br><p>在本文中，我想将我对这些语言的基本知识进行系统化，并考虑它们的异同。 本文可以作为希望学习JavaScript的C＃开发人员的指南，反之亦然。 我还想指出，由于我没有Node.js的开发经验，因此本文介绍了客户端JS的功能。 因此，如果您仍然没有失去兴趣，那就开始吧。 </p><a name="habracut"></a><br><h2 id="namespace-i-js-moduli"> 命名空间和js模块 </h2><br><p> 在每个程序中，为了避免变量，函数，类或其他对象的名称冲突，我们在某些区域将它们组合在一起。 因此，如果两个不同区域包含具有相同名称的元素，则不会发生冲突。 </p><br><p>在C＃中，名称空间用于将程序拆分为多个部分。 关键字<code>namespace</code>用于声明它们。 例如，如果我们要创建一组用户界面组件，将它们全部放在一个名称空间（例如<code>Components</code>是合乎逻辑的。 通常，命名空间具有以下命名： <code>[AssemblyName].[DirectoryName].[DirectoryName].[...]</code> 。 在每个文件中，用户界面组件的类必须放置在名称空间内： </p><br><p>  <code>ComboBox.cs</code>文件的内容： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AssemblyName.Components</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ComboBox</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p> 为了开始使用组件，您需要<code>using AssemblyName.Components</code>如下从名称空间导入它们。 使用这种单行连接方法，我们将所有对象导入到当前文件中。 </p><br><p>  JS将ES模块用于相同的目的。 使用它们时，我们在某种程度上通过编写其他代码来模拟名称空间的行为。 考虑带有组件库的相同示例。 假设我们有一个<code>Components</code>文件夹，其中包含用户界面<code>ComboBox.js</code> ， <code>Button.js</code> ， <code>Button.js</code>等的组件。 为了获得与<code>Components</code>文件夹中的名称空间相比类似的行为，您需要创建一个<code>index.js</code>文件，其中将包含以下代码： </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Dialog } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ComboBox'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Checkbox } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Checkbox'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p> 为了使用这些组件，您需要将它们导入到当前文件中。 这可以通过以下方式完成： <code>import * as Components from './../Components'</code> ，在from关键字之后，我们需要指定所有描述的组件所在的文件夹的路径。 </p><br><h2 id="sposoby-obyavleniya-peremennyh"> 声明变量的方法 </h2><br><h3 id="klyuchevoe-slovo-var">  <code>var</code>关键字 </h3><br><p> 如您所知，C＃是一种强类型化的编程语言，因此，在声明变量时，编译器必须知道其类型，为此，通常在其名称之前进行指示。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br><p> 但是我们也可以告诉编译器，它必须根据分配符号后的表达式自行推断类型。 通过在C＃3.0中引入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>var</code></a>关键字，可以做到这一点。 </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// i - int var i = 5; // a - int[] var a = new[] { 0, 1, 2 };</span></span></code> </pre> <br><p> 使用<code>var</code>我们可以创建匿名类型的对象： </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// anon -      var anon = new { Name = "Terry", Age = 34 }; var type = anon.GetType();//"&lt;&gt;f__AnonymousType0`2"</span></span></code> </pre> <br><p> 在JavaScript中，还可以使用<code>var</code>关键字声明变量，但是，与C＃不同，如果在函数外部声明变量，则这些变量的范围将是整个函数或<code>window</code>对象。 </p><br><pre> <code class="hljs powershell">var a = <span class="hljs-number"><span class="hljs-number">5</span></span> //   - window <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var a = <span class="hljs-number"><span class="hljs-number">6</span></span> //   -  go // ... }</code> </pre><br><p> 尽管您可以在JavaScript中使用<code>var</code>声明变量，但现在不建议这样做，在ES6标准发布后，添加了<code>let</code>关键字，它还允许您声明变量，但其优点是它们的作用域为在其中声明它们的块，而不是整个函数。 </p><br><h3 id="konstanty"> 常数 </h3><br><p>  C＃和JavaScript都使用<code>const</code>关键字来声明一个常量字段。 的确，值得注意的是，在这种情况下，常量的概念对于这些语言而言是不同的。 </p><br><p> 在C＃中，常数是一个可以在编译阶段完全评估的表达式，即 常量可以是数字，布尔值，字符串或null引用。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(firstName); <span class="hljs-comment"><span class="hljs-comment">//,  </span></span></code> </pre> <br><p> 在JavaScript中，常量的值也不能更改，但是，与C＃中一样，该值没有限制，您可以为其分配任何值/对象/数组。 但是，如果将一个对象分配给一个常量，则可以保护常量本身不受更改，但不受其内部属性的更改： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { name: <span class="hljs-string"><span class="hljs-string">""</span></span> }; user.name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  user = 5; // ,  </span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-void">  <code>void</code>关键字 </h2><br><p> 在撰写本文时，我在控制台中尝试了一些函数，并且出于习惯开始将其描述为C＃ <code>void SomeFunction...</code> ，当我发现JavaScript关键字为<code>void</code>时，这让我感到非常惊讶。 事实证明，JavaScript中的<code>void</code>是一元运算符，用于计算操作数的值，然后将其丢弃并返回<code>undefined</code> 。 </p><br><pre> <code class="hljs ruby">alert(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> alert(void <span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> undefined</code> </pre> <br><p> 因此，我们可以说<code>void</code>的使用清楚地表明没有返回值；有关其使用示例的更多详细信息，请参见下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a> 。 </p><br><p> 在C＃中， <code>void</code>不是运算符，但实质上具有相似的含义。 在这里，它指示不存在函数返回值： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 但是，如您在上面的示例中所看到的，通常在通常指示返回值的类型的位置使用<code>void</code> ，这绝非偶然，因为在C＃中<code>void</code>也是一种类型。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); t.Name <span class="hljs-comment"><span class="hljs-comment">// System.Void</span></span></code> </pre> <br><p> 作为指针，只能在不安全的上下文中使用<code>void</code>作为类型。 </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* identifier; <span class="hljs-comment"><span class="hljs-comment">//,    }</span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-new">  <code>new</code>关键字 </h2><br><p> 在JavaScript中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>new</code></a>关键字是一个运算符，通常用于许多类似C的语言来创建对象。 </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { //... } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p> 在C＃中， <code>new</code>可用于以下目的： </p><br><ul><li> 创建对象； </li><li> 隐藏基类的继承成员； </li><li> 将可用作参数的类型限制为泛型类中的类型参数。 </li></ul><br><p> 第一种情况类似于在JavaScript中使用<code>new</code> 。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } var animal = new Animal();</span></span></code> </pre> <br><h2 id="osnovnye-tipy-dannyh"> 基本数据类型 </h2><br><p> 每种语言都有数据类型-基于构建其他数据类型的基元，让我们看一下C＃和JavaScript提供给我们的数据类型。 </p><br><p> 原始C＃类型： </p><br><ul><li>  <code>sbyte</code>整数： <code>sbyte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> </li><li> 无符号整数： <code>byte</code> ， <code>ushort</code> ， <code>uint</code> ， <code>ulong</code> </li><li>  Unicode字符： <code>char</code> </li><li>  Unicode字符集： <code>char</code> </li><li> 浮点数： <code>float</code> ， <code>double</code> </li><li> 十进制小数： <code>decimal</code> </li><li> 布尔值： <code>bool</code> </li></ul><br><p> 基类是<code>Object</code> 。 </p><br><p> 对于JS： </p><br><p> 基本数据类型： </p><br><ul><li> 号码<code>number</code> </li><li>  <code>string</code> </li><li> 布尔布尔 </li><li> 特殊<code>null</code> </li><li> 特殊含义<code>undefined</code> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>symbol</code></a> </li> </ul><br><p> 基本类型是<code>Object</code> 。 </p><br><p> 在研究了两种语言的原始语之后，我们可以得出以下结论： </p><br><ul><li>  JavaScript没有一个足够大的数字类型集，而是具有一个单一的<code>number</code> ； </li><li>  JavaScript没有<code>char</code>类型；而是使用<code>string</code>类型； </li><li> 在两种语言中，基本类型都是<code>Object</code> ； </li><li>  JS的一个独特功能是将<code>null</code>和<code>undefined</code>分为不同的类型，而在C＃中， <code>null</code>是指示缺少值的关键字。 </li><li>  JS具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>symbol</code></a>类型，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>symbol</code></a>类型主要在JavaScript标准本身内部使用，以便能够添加新功能而不与现有代码库冲突。 </li></ul><br><p> 通常，现在有越来越多的应用程序需要在客户端上处理数据，这需要更高的计算精度。  JavaScript当前缺乏内置的处理大量数据的能力，但是在不久的将来，它计划添加一种新型的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>BigInt</code></a> 。 为了解决C＃中的类似问题，有一个类<code>System.Numerics.BigInteger</code> 。 </p><br><h2 id="proverka-tipa-obekta"> 对象类型检查 </h2><br><p> 对于大多数编程语言，类型检查是相当典型的操作。 根据类型，我们可以执行各种操作。 例如，考虑一个生活的例子：您听到门铃，如果一个醉酒的邻居来找你借钱（ <em>邻居</em>为<em>醉汉</em> ），那么您不太可能为他打开门，但是如果您最好的朋友在门后（那个对象为<em>最好</em>的对象） <em>朋友</em> ），那么您会毫不犹豫地让他进入公寓。  C＃和JavaScript还提供了用于检查对象类型的工具。 </p><br><h3 id="operator-typeof">  <code>typeof</code>运算符 </h3><br><p> 对于类型信息，C＃和JavaScript都具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>typeof</code></a>运算符。 让我们看看它在两种语言中如何工作： </p><br><p> 在C＃中，将<code>typeof</code>运算符应用于类型，并返回<code>Type</code>类的对象，该对象包含所有类型信息。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Zoo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> {} } Type t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Animal); t.Name <span class="hljs-comment"><span class="hljs-comment">// 'Animal' t.FullName // 'Zoo.Animall' t.GetMethods //    t.GetFields //     // ...</span></span></code> </pre> <br><p> 在JS中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>typeof</code></a>返回一个指示操作数类型的字符串。 </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> // <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Symbol() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'symbol'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'undefined'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> function() {} <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'function'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {} // '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">';</span></span></code> </pre> <br><p> 在上面的示例中，您可以注意到此运算符的某些功能。 如果<code>typeof new Animal()</code>的表达式<code>typeof new Animal()</code>将返回字符串<code>'Animal'</code>和<code>typeof [1,2,3]</code> -字符串<code>Array</code> ，这似乎是合乎逻辑的，但是矛盾的是，在两种情况下，结果都是<code>'object'</code> 。 同样，由于JS中的类是函数的包装器，因此<code>typeof class C {}</code>的表达式<code>typeof class C {}</code>将返回<code>'function'</code>而不是<code>'class'</code> 。 另一个有趣的事实是<code>typeof null</code>表达式将返回<code>'object'</code> 。 在JavaScript中，此运算符有一个很大的缺点：所有非原始对象看起来都一样，它们都具有相同的<code>object</code>类型。 </p><br><p> 值得注意的是，在JavaScript中<code>typeof</code>可以应用于任何对象：对象，函数，类等。在C＃中，此运算符仅适用于类型。 </p><br><h3 id="ishttpsdocsmicrosoftcomru-rudotnetcsharplanguage-referencekeywordsis-i-instanceofhttpslearnjavascriptruinstanceof">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">instanceof</a> </h3><br><p> 除了获取有关类型的信息之外，有时验证对象是否属于特定类型也很有用。 </p><br><p> 在C＃中，出于这些目的有一个<code>is</code>运算符。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// Programmer  Person class Programmer : Person { } var person = new Person(); var programmer = new Programmer(); person is Person //true person is Programmer //false programmer is Person //true programmer is Programmer //true</span></span></code> </pre> <br><p> 在JavaScript中，为了找出对象属于什么类型，您需要使用operator- <code>instanceof</code> 。 </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Programmer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} // Programmer  Person Programmer.prototype = Object.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(Person.prototype); var person = new Person(); var programmer = new Programmer(); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">false</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2 id="logicheskie-znacheniya-i-proverka-na-null"> 布尔和空值检查 </h2><br><p> 为了不获取<code>Null reference exception</code> ，几乎在所有地方，在使用变量之前，都要检查它是否为<code>null</code> ，对于JavaScript，还要检查其<code>undefined</code> 。 </p><br><p> 在C＃中，我们不断看到类似的代码： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; String.IsNullOrEmpty(user.name)) { user.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p> 在JavaScript中，此结构可以写得短一些。 这是由于这样的事实，与C＃不同，在JavaScript中，铸造时除<code>false</code>以外的许多值也被视为<code>false</code> ： </p><br><ol><li> <code>null</code> </li> <li> <code>undefined</code> </li> <li>  “”（空行） </li><li> <code>0</code> </li> <li>  <code>NaN</code> （不是数字） </li></ol><br><p> 因此，上面的C＃代码可以编写如下： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name) { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName(""); }</code> </pre> <br><p> 或 </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName("");</code> </pre> <br><p> 由于<code>null</code>检查无处不在，因此在C＃6.0中添加了<em>空传播运算符</em> <code>.?</code>  。 </p><br><p>  C＃代码： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { user.parent.parent.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p> 在其帮助下，该代码节可以按如下方式重写： </p><br><pre> <code class="cs hljs">user?.parent?.parent?.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><p> 在JavaScript中，通常按以下步骤进行： </p><br><pre> <code class="hljs mel">user &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.setName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><h2 id="ustanovka-znacheniy-po-umolchaniyu"> 设定默认值 </h2><br><p> 另一个常见的操作是设置默认值，从C＃中<em>出现的</em> 2.0版<em>Null合并运算符- <code>??</code></em>  。 </p><br><p> 以下两行C＃代码是等效的： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.name != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? user.name : <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user?.name ?? <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p> 在JavaScript中，通常按以下步骤进行类似的操作。 </p><br><pre> <code class="hljs pgsql">var <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name || "";</code> </pre> <br><p> 但是，我们可以使用运算符<code>&amp;&amp;</code>和<code>||</code> 仅当<code>0</code> ， <code>false</code>和<em>空字符串</em>不是有效值时。 </p><br><p> 在可预见的将来，运营商<code>?.</code>  ， <code>??</code> 应该出现在JavaScript中（它们现在已经通过<a href="">Stage0</a>阶段），有关这些JavaScript中的运算符的更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> 。 </p><br><h2 id="klyuchevoe-slovo-this"> 这个关键词 </h2><br><p>  C＃和JavaScript都具有<code>this</code> 。 通常，在C＃中，了解此操作的目的很简单，但是在JavaScript中，这是最复杂的语言概念之一。 此外，我们将考虑<code>this</code>示例应用于示例。 </p><br><p> 在C＃中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>this</code></a>指向该类的当前实例。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintEmployee</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee(); E1.PrintEmployee();</code> </pre> <br><p> 在此示例中，在<code>Console.WriteLine(this.name)</code>表达式中， <code>this</code>指向<code>employee</code>变量。 </p><br><p> 由于<code>this</code>是该类的当前实例，因此不能在未绑定到特定类型的方法中使用它，例如，在静态方法中。 </p><br><p> 在JavaScript中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>this</code></a>称为调用<em>上下文，将在调用</em>函数时确定。 如果在不同对象的上下文中运行相同的函数，它将收到不同的<code>this</code> ： </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; function <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert( this.firstName ); } user.f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">; // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  admin.g(); //  func();// undefined -    this -   window</span></span></code> </pre> <br><p> 另外，在JavaScript中，可以使用以下函数显式指定<code>this</code>的值： <code>call</code> ， <code>bind</code>和<code>apply</code> 。 例如，上面的示例可以重写如下： </p><br><pre> <code class="hljs matlab">var user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; var admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( this.firstName )</span></span></span><span class="hljs-function">; } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;//  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;// </span></span></code> </pre> <br><h2 id="destrukturizaciya"> 改制 </h2><br><p> 通常需要将对象的多个字段分配给局部变量。 例如，您多久观察一次类似的代码？ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName = user.FirstName; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName = user.LastName; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p> 为此，可以使用解构。 两种语言都不同程度地支持此功能。 </p><br><p>  C＃7.0引入了一种称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解构</a>函数的新功能来支持解构。 为了声明一个解构函数，我们需要定义一个称为<code>Deconstruct</code>的方法，该方法的所有参数都必须使用<code>out</code>修饰符声明： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   public void Deconstruct(out string firstName, out string lastName) { firstName = this.FirstName; lastName = this.LastName; } } ... Person person = new Person { FirstName = "", LastName = "" }; (string firstName, string lastName) = person; (string firstName, _ ) = person;</span></span></code> </pre> <br><p> 第六个EcmaScript标准中出现了对JavaScript进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>解构</em>或<em>（解构分配）的</em></a>支持。 在她的帮助下 您可以一次将数组或对象分配给多个变量，将其分成多个部分。 </p><br><pre> <code class="hljs powershell">let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">lastName</span></span>] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">_</span></span> ] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let { firstName, lastName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; let { firstName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> };</code> </pre> <br><p> 值得注意的是，JavaScript中的重组比C＃中具有更多功能： </p><br><ul><li> 更改变量的顺序； </li><li> 无需显式声明解构函数； </li><li> 阵列解构支持； </li><li> 设置默认值； </li><li> 将对象的属性分配给具有不同名称的变量； </li><li> 支持嵌套解构。 </li></ul><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 在本文中，我们仅讨论了C＃和JavaScript语言的最基本概念。 但是许多方面仍然不受影响： </p><br><ul><li> 馆藏 </li><li> 功能 </li><li> 类 </li><li> 多线程 </li></ul><br><p> 这些主题中的每个主题都相当广泛，稍后将在另一篇文章中进行介绍。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414593/">https://habr.com/ru/post/zh-CN414593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414579/index.html">Google AI已学会预测患者何时死亡（但并非一切都如此严峻）</a></li>
<li><a href="../zh-CN414581/index.html">他的按钮在哪里？ 一个简单的人如何从Kibana和Elasticsearch卸载数据而不会给开发人员带来压力</a></li>
<li><a href="../zh-CN414583/index.html">RIT ++，Tech RaDarts和所有所有</a></li>
<li><a href="../zh-CN414585/index.html">我的String.getBytes（UTF_8）如何损坏以及如何处理</a></li>
<li><a href="../zh-CN414587/index.html">DIY可控制互联网的独立无人机。 关于软件的第2部分</a></li>
<li><a href="../zh-CN414597/index.html">问伊森：外星文明可以接近多远？</a></li>
<li><a href="../zh-CN414601/index.html">当山高而笔记本电脑大时：更多的IT历史</a></li>
<li><a href="../zh-CN414605/index.html">迷你帝国</a></li>
<li><a href="../zh-CN414609/index.html">2018 PWA（Progressive Web Apps）能否与本地应用程序抗衡？</a></li>
<li><a href="../zh-CN414611/index.html">我在Unity和C＃中为一个女儿创建一个激励应用程序（iOS和Android）的故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>