<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèº üÜò ü§¶üèΩ Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8 üõ§Ô∏è üëí üìø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren habe ich einen Wecker auf dem ATmega8-Mikrocontroller erstellt, auf dem ich einen einfachen Melodie-Synthesizer mit einem einzigen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454514/">  Vor einigen Jahren habe ich einen Wecker auf dem ATmega8-Mikrocontroller erstellt, auf dem ich einen einfachen Melodie-Synthesizer mit einem einzigen Ton (mit einer Stimme) implementiert habe.  Es gibt viele Artikel im Internet f√ºr Anf√§nger zu diesem Thema.  In der Regel wird ein 16-Bit-Timer verwendet, um die Frequenz (Noten) zu erzeugen, die auf bestimmte Weise konfiguriert ist, und auf Hardwareebene gezwungen, ein Signal in Form eines M√§anders an einem bestimmten Pin des MC auszugeben.  Der zweite (8-Bit-) Timer wird verwendet, um die Dauer einer Note oder Pause zu implementieren.  Noten nach bekannten Formeln werden mit Frequenzen verglichen und sie werden wiederum mit bestimmten 16-Bit-Zahlen verglichen, die umgekehrt proportional zu den Frequenzen sind, die die Timer-Z√§hlperioden angeben. <br><a name="habracut"></a><br>  In meinem Entwurf habe ich drei Melodien bereitgestellt, die in derselben Tonart und Tonleiter geschrieben wurden.  Daher musste ich eine begrenzte und bestimmte Anzahl von Noten verwenden, was das Modellieren erleichterte.  Au√üerdem wurden alle drei St√ºcke im gleichen Tempo gespielt.  Der Notencode und sein Dauercode passen leicht in ein Byte.  Der einzige Nachteil dieses Modells war die mangelnde Vielseitigkeit, die F√§higkeit, die Melodie schnell zu bearbeiten, zu ersetzen oder zu erg√§nzen.  Um eine Melodie aufzunehmen, skizzierte ich sie zuerst in einem Musikeditor auf einem Computer, kopierte dann die Noten und ihre Dauer, deren Nummerierung ich im Voraus festgelegt hatte, und bildete dann die resultierenden Bytes.  Ich habe die letzten Operationen mit dem Excel-Programm durchgef√ºhrt. <br><br>  In Zukunft wollte ich den oben genannten Nachteil beseitigen, dem Design eine gewisse Universalit√§t verraten und die Zeit f√ºr die Implementierung der Melodie verk√ºrzen.  Es gab eine solche Idee, dass das MK-Programm die Bytes eines der ber√ºhmten Musikformate las.  Am beliebtesten und gebr√§uchlichsten ist das MIDI-Format.  Im wahrsten Sinne des Wortes ist dies weniger ein Format als eine ganze ‚ÄûWissenschaft‚Äú, √ºber die im Internet gelesen werden kann.  Die MIDI-Spezifikation definiert das Protokoll f√ºr die √úbertragung von Echtzeitnachrichten √ºber die entsprechende physikalische Schnittstelle und beschreibt, wie die MIDI-Dateien angeordnet sind, in denen diese Nachrichten gespeichert werden k√∂nnen.  Das Midi-Format ist musikorientiert und findet daher Anwendung auf dem entsprechenden Gebiet.  Dies ist eine synchrone Steuerung von Tonausr√ºstung, Farbmusik, Musiksynthesizern und Robotern usw.  Im h√§uslichen Bereich wurde das Midi-Format in der √Ñra des Beginns der Entwicklung von Mobiltelefonen angetroffen.  In diesem Fall werden Nachrichten √ºber die Aufnahme oder Deaktivierung einer bestimmten Note, Informationen √ºber ein Musikinstrument, die Lautst√§rke der klingenden Noten usw. in der MIDI-Datei aufgezeichnet.  Das Mobiltelefon, das eine solche Datei abspielt, enth√§lt einen Synthesizer, der die MIDI-Nachrichten in dieser Datei in Echtzeit interpretiert und die Melodie abspielt.  In den fr√ºhesten Stadien konnten Telefone nur Einzeltonmelodien abspielen.  Im Laufe der Zeit trat die sogenannte Polyphonie auf. <br><br>  Im Internet traf ich Artikel √ºber die Implementierung eines polyphonen Synthesizers auf MK, der MIDI-Dateien liest.  In diesem Fall wird mindestens eine vorgeformte "Wellentabelle" (eine Liste von Schallwellenformen) f√ºr jedes Musikinstrument verwendet, das im Speicher von MK gespeichert ist.  In meinem speziellen Fall konzentrieren wir uns auf die Implementierung eines einfacheren Modells: eines Single-Tone-Synthesizers (Single-Voice). <br><br>  Zun√§chst habe ich die Struktur der MIDI-Datei sorgf√§ltig untersucht und festgestellt, dass sie zus√§tzlich zu den erforderlichen Informationen zu Noten zus√§tzliche redundante Informationen enth√§lt.  Daher wurde beschlossen, ein einfaches Programm zu schreiben, um eine MIDI-Datei in ein eigenes Format zu konvertieren.  Das Programm, das mit vielen MIDI-Dateien arbeitet, konvertiert Formate nicht nur, sondern organisiert sie auch auf eine bestimmte Weise.  Im Voraus habe ich beschlossen, die Speicherung vieler Musikst√ºcke im ROM-Speicher (EEPROM 24XX512) zu organisieren.  Zur Vereinfachung der Visualisierung im HEX-Editor habe ich sichergestellt, dass jede Melodie am Anfang des Sektors beginnt.  Im Gegensatz zu einer SD-Karte (zum Beispiel) ist das Konzept eines Sektors nicht auf das verwendete ROM anwendbar, daher dr√ºcke ich mich bedingt aus.  Die Sektorgr√∂√üe betr√§gt 512 Bytes.  Und der erste Sektor des ROM ist f√ºr die Adressen der Sektoren der Anf√§nge jeder Melodie reserviert.  Es wird angenommen, dass die Melodie mehrere Sektoren umfassen kann. <br><br>  Eine vollst√§ndige Beschreibung des Midi-Dateiformats lohnt sich hier nat√ºrlich nicht.  Ich werde nur auf die notwendigsten und notwendigsten Punkte eingehen.  Eine Midi-Datei enth√§lt 16 Kan√§le, die in der Regel dem einen oder anderen Musikinstrument entsprechen.  In unserem Fall spielt es keine Rolle, um welche Art von Instrument es sich handelt, und es wird nur ein Kanal ben√∂tigt.  Der Inhalt jedes Kanals wird zusammen mit dem Header in einer Midi-Datei nach einem Prinzip erstellt, das der Organisation der Speicherung von Video- und Audiostreams in einem AVI-Container sehr √§hnlich ist.  Ich habe dar√ºber fr√ºher in einem meiner Artikel geschrieben.  Der Midi-Datei-Header besteht aus einigen Parametern.  Ein solcher Parameter ist die Zeitaufl√∂sung.  Sie wird in der Anzahl der ‚ÄûTicks‚Äú (eine Art Pixel) pro Quartal (PPQN) ausgedr√ºckt.  Ein Viertel ist eine Zeitspanne, in der eine Viertelnote gespielt wird.  Je nach Tempo der Melodie kann die Dauer des Viertels unterschiedlich sein.  Daher h√§ngt die Dauer eines ‚ÄûPixels‚Äú (Abtastperiode) vom Tempo und PPQN ab.  Alle Informationen zum Zeitpunkt eines Ereignisses werden mit Genauigkeit auf diese Dauer ermittelt. <br><br>  Dar√ºber hinaus enth√§lt der Header den Typ der MIDI-Datei (Typ 0 oder Typ 1) und die Anzahl der Kan√§le.  Ohne auf Details einzugehen, werden wir mit Typ 1, der Anzahl der Kan√§le 2, arbeiten. Eine MIDI-Datei mit einer Einzeltonmelodie enth√§lt logischerweise einen Kanal.  In der Midi-Datei ‚ÄûTyp 1‚Äú gibt es jedoch neben dem Hauptkanal einen weiteren ‚Äûnicht-musikalischen‚Äú Kanal, in dem zus√§tzliche Informationen aufgezeichnet werden, die keine Noten enthalten.  Dies sind die sogenannten Metadaten.  Es besteht auch keine Notwendigkeit, auf Details einzugehen.  Die einzigen Informationen, die wir dort ben√∂tigen, sind Informationen √ºber das Tempo und in einem ungew√∂hnlichen Format: Mikrosekunden pro Quartal.  In Zukunft wird gezeigt, wie diese Informationen zusammen mit PPQN verwendet werden, um den MK-Timer zu konfigurieren, der f√ºr das Tempo verantwortlich ist. <br><br>  Im Hauptkanalblock mit Notizen interessieren uns nur Informationen √ºber die Ereignisse beim Ein- und Ausschalten von Notizen.  Ein Notenaktivierungsereignis hat zwei Parameter: Notennummer und Lautst√§rke.  Insgesamt stehen 128 Noten und 128 Lautst√§rken zur Verf√ºgung.  Wir interessieren uns nur f√ºr den ersten Parameter, da es keine Rolle spielt, wie laut die Note ist: Alle Noten beim Spielen der MK-Melodie klingen mit der gleichen Lautst√§rke.  Und nat√ºrlich sollte die Melodie keine ‚Äû√ºberspielten‚Äú Noten enthalten, dh es sollte zu keinem Zeitpunkt mehr als eine Note gleichzeitig erklingen.  Der Code des Ereignisses, bei dem die Notizen aufgenommen (eingeschaltet) werden, lautet 0x90.  Der Hinweis f√ºr den Ereigniscode lautet 0x80.  Zumindest der Cakewalk Pro Audio 9-Editor verwendet das Ereignis mit dem 0x80-Code jedoch nicht, wenn die Komposition in das Midi-Format exportiert wird.  Stattdessen findet das 0x90-Ereignis w√§hrend des gesamten musikalischen Teils statt, und die Note, bei der die Note ausgeschaltet ist, hat die Lautst√§rke Null.  Das hei√üt, das Ereignis "Note ausschalten" entspricht dem Ereignis "Note mit Lautst√§rke Null einschalten".  Vielleicht geschieht dies aus wirtschaftlichen Gr√ºnden.  Gem√§√ü der Spezifikation kann der Ereigniscode nicht neu geschrieben werden, wenn dieses Ereignis wiederholt wird.  Zwischen Ereignissen werden Informationen √ºber das Zeitintervall in einem Format variabler L√§nge aufgezeichnet.  Dies sind die ganzzahligen Werte der oben genannten Anzahl von "Ticks".  Meistens reicht ein Byte aus, um das Zeitintervall aufzuzeichnen.  Wenn zwei Ereignisse nacheinander folgen, ist das Zeitintervall zwischen ihnen offensichtlich gleich Null.  Dies deaktiviert beispielsweise die erste und die Aufnahme der darauf folgenden zweiten Note, wenn zwischen ihnen keine Pause (Leerzeichen) steht. <br><br>  Versuchen wir, mit dem Programm ‚ÄûCakewalk Pro Audio 9‚Äú eine Notenfolge zu schreiben.  Es gibt viele Redakteure, aber ich habe mich f√ºr den ersten entschieden, der mir begegnet ist. <br><br><img src="https://habrastorage.org/webt/x2/rs/ig/x2rsigockegfkqq_xux3wgiesly.png"><br><br>  Zuerst m√ºssen Sie die Projekteinstellungen konfigurieren.  In diesem Editor k√∂nnen Sie die zeitliche Aufl√∂sung (PPQN) einstellen.  Ich w√§hle den Mindestwert gleich 48. Ein zu gro√üer Wert ist bedeutungslos, da Sie mit gro√üen Zahlen arbeiten m√ºssen, die gr√∂√üer als 1 Byte sind.  Der Mindestwert von 48 ist jedoch durchaus zufriedenstellend.  In fast jeder Melodie werden keine Noten gefunden, die k√ºrzer als 1/32 sind.  Und wenn die Anzahl der ‚ÄûTicks‚Äú pro Quartal 48 betr√§gt, hat die Note oder Pause 1/32 eine Dauer von 48 / (32/4) = 6 ‚ÄûTicks‚Äú.  Das hei√üt, es gibt eine theoretische M√∂glichkeit, 1/32 Note vollst√§ndig durch 2 und sogar durch 3 zu teilen. Die verbleibenden Parameter bleiben standardm√§√üig im Projekteigenschaftenfenster. <br><br><img src="https://habrastorage.org/webt/q-/e8/1j/q-e81jrcz7-g-doa-oberdoezju.png"><br><br>  √ñffnen Sie als N√§chstes die Eigenschaft des ersten Titels und weisen Sie ihm eine Kanalnummer gleich 1 zu. W√§hlen Sie nach Ihrem Geschmack einen Patch aus, der einem Musikinstrument entspricht, wenn Sie eine Melodie im Editor abspielen.  Die Patch-Nummer hat nat√ºrlich keinen Einfluss auf das Endergebnis. <br><br><img src="https://habrastorage.org/webt/y-/2o/xn/y-2oxnmqemoxj3hwtflnanivyyk.png"><br><br>  Das Melodietempo wird in der Anzahl der Viertel pro Minute in der Editor-Symbolleiste festgelegt.  Der Standardtempowert ist 100 Schl√§ge pro Minute. <br><br>  Der Mikrocontroller verf√ºgt √ºber einen 8-Bit-Timer, mit dem, wie bereits erw√§hnt, die Dauer der klingenden Noten und Pausen gesteuert wird.  Es wurde entschieden, dass das Zeitintervall zwischen benachbarten Operationen (Unterbrechungen) eines solchen Zeitgebers dem Intervall eines "Ticks" entsprechen w√ºrde.  Abh√§ngig vom Tempo der Melodie ist der Wert dieses Zeitintervalls unterschiedlich.  Ich entschied mich f√ºr Interflow-Timer-Interrupts.  Abh√§ngig vom anf√§nglichen Timer-Initialisierungsparameter ist es m√∂glich, dasselbe Zeitintervall einzustellen, das vom Tempo der Melodie abh√§ngt.  Fahren wir nun mit den Berechnungen fort. <br><br>  In der Praxis liegt das Tempo der Songs in der Regel im Durchschnitt in der Gr√∂√üenordnung von 50 bis 200. Es wurde bereits gesagt, dass das Tempo in der Midi-Datei in Mikrosekunden um ein Viertel eingestellt ist.  F√ºr Tempo 50 betr√§gt dieser Wert 60.000.000 / 50 = 1.200.000 und f√ºr Tempo 250 240.000. Da laut Projekt ein Viertel 48 Ticks enth√§lt, betr√§gt die Tickl√§nge f√ºr das Mindesttempo 1.200.000 / 48 = 25.000 Œºs.  Und f√ºr das maximale Tempo, wenn Sie auf die gleiche Weise berechnen, - 5000 Œºs.  F√ºr MK mit einer Quarzfrequenz von 8 MHz und einem maximalen vorl√§ufigen Zeitgeberteiler von 1024 erhalten wir Folgendes.  F√ºr das Mindesttempo muss der Timer 25000 / (1024/8) = 195 mal berechnet werden.  Das Ergebnis wird auf den n√§chsten ganzzahligen Wert gerundet, der Rundungsfehler hat praktisch keinen Einfluss auf das Ergebnis.  F√ºr das maximale Tempo - 5000 / (1024/8) = 39.  Hier wirkt sich der Rundungsfehler nicht mehr aus, da auch f√ºr benachbarte Tempowerte von 248 bis 253 ein gerundeter Wert von 39 erhalten wird. Dementsprechend muss der Timer mit einem inversen Wert initialisiert werden: f√ºr das minimale Tempo - (256-195) = 61 und f√ºr das maximale - (256) -39) = 217.  Das Mindesttempo, mit dem der Timer in der aktuellen MK-Konfiguration bereitgestellt wird, betr√§gt 39 Schl√§ge pro Minute.  Mit diesem Wert muss der Timer 250 Mal gez√§hlt werden.  Und mit einem Wert von 38 - bereits 257, was √ºber die Grenzen des Timers hinausgeht.  Ich entschied mich f√ºr den Wert von 40 Schl√§gen pro Minute f√ºr das minimale Tempo und 240 f√ºr das Maximum. <br><br>  Um die Anzahl der Ticks zu berechnen, wird ein virtueller Timer verwendet, der auf dem Vorstehenden basiert.  Es ist die Anzahl der Ticks, die die Dauer einer Note oder Pause festlegt, wie oben bereits erw√§hnt. <br><br>  Um die Wiedergabe von Noten zu implementieren, wird ein zweiter 16-Bit-Timer verwendet.  Gem√§√ü der MIDI-Spezifikation werden insgesamt 128 Noten bereitgestellt.  In der Praxis werden sie jedoch viel weniger verwendet.  Dar√ºber hinaus werden die Noten der niedrigsten (mit Frequenzen von ungef√§hr 50 Hz) und der h√∂chsten (mit Frequenzen von ungef√§hr 8 kHz) Oktaven vom Mikrocontroller nicht harmonisch wiedergegeben.  Trotzdem deckt ein 16-Bit-Timer mit festem Teiler fast den gesamten Notenbereich von Midi ab, n√§mlich ohne die ersten 35.  Aber ich habe als Anfang die Notiz mit der Nummer 37 gew√§hlt (ihr Code ist 36, da die Codierung von Null kommt).  Dies geschieht der Einfachheit halber, da diese Zahl der Note ‚ÄûC‚Äú entspricht, wie die erste Note in einer traditionellen Skala.  Es entspricht einer Frequenz von 65,4 Hz und der Halbzyklus betr√§gt - 1 / 65,4 / 2 = 0,00764 s.  Diese Zeitspanne bei einer MK-Frequenz von 8 MHz und einem Teiler 1 (dh ohne Teiler) z√§hlt den Timer ungef√§hr insgesamt f√ºr 0,00764 / (1/8000000) = 61156-mal.  Wenn Sie f√ºr die 35. Note z√§hlen, betr√§gt dieser Wert 68645, was au√üerhalb des Bereichs des 16-Bit-Timers liegt.  Aber selbst wenn es notwendig war, Noten unter dem 36. zu spielen, k√∂nnen Sie den ersten verf√ºgbaren Timer-Teiler eingeben, der gleich 8 ist. Dies ist jedoch praktisch nicht erforderlich, ebenso wie es keinen gibt, der die obersten Noten spielt.  F√ºr die oberste 128. Note, "G" -Note mit einer Frequenz von 12.543,85 Hz, betr√§gt der Timer-Wert bei √§hnlicher Z√§hlung 319. Die Besonderheiten aller obigen Berechnungen werden durch die spezifische Konfiguration des Timer-Modus bestimmt, die sp√§ter gezeigt wird. <br><br>  Jetzt habe ich eine nicht weniger wichtige Frage: Wie erhalte ich die Beziehung zwischen der Notennummer und dem Code f√ºr den Timer?  Es gibt eine bekannte Formel zur Berechnung der Frequenz einer Note anhand ihrer Nummer.  Und der Zeitgebercode f√ºr eine bekannte Frequenz kann leicht berechnet werden, wie oben in den Beispielen gezeigt.  Die Wurzel des 12. Grades erscheint jedoch in der Formel f√ºr die Abh√§ngigkeit der Frequenz von der Note, und im Allgemeinen m√∂chte ich den Controller nicht mit solchen Berechnungsverfahren laden.  Andererseits ist es auch nicht rational, ein Array von Timer-Codes f√ºr alle Noten zu erstellen.  Und ich entschied mich f√ºr Folgendes und w√§hlte einen Mittelweg.  Es reicht aus, ein Array von Timer-Codes f√ºr die ersten 12 Noten zu erstellen, die eine Oktave umfassen.  Und die Noten der folgenden Oktaven sollten erhalten werden, indem die Frequenzen der Noten der ersten Oktave nacheinander mit 2 multipliziert werden. Oder das gleiche, indem die Werte der Timer-Codes nacheinander durch 2 geteilt werden. Eine weitere Annehmlichkeit besteht darin, dass die Oktavzahl zuf√§llig ein Argument bei der bitweisen Verschiebung nach rechts ist ( ¬ª), Die als Operation der Division durch Zweierpotenzen verwendet wird.  Ich habe diesen Operator nicht zuf√§llig gew√§hlt, da sein Argument den Exponenten der Potenz des Divisors widerspiegelt (die Anzahl der Divisionen durch 2).  Und das ist die Oktavzahl.  F√ºr meine Noten sind insgesamt 8 Oktaven beteiligt (die letzte Oktave ist unvollst√§ndig).  Eine Note in einer MIDI-Datei wird mit einem Byte, genauer gesagt 7 Bit, codiert.  Um Noten in MK zu spielen, m√ºssen Sie gem√§√ü der obigen Idee zuerst die Oktavnummer und die Notennummer in der Oktave mit dem Notencode berechnen.  Dieser Vorgang wird in der Phase der Konvertierung der MIDI-Datei in ein vereinfachtes Format ausgef√ºhrt.  Acht Oktaven k√∂nnen in drei Bits codiert werden, und 12 Noten in einer Oktave k√∂nnen in vier Bits codiert werden.  Insgesamt stellt sich heraus, dass die Note in den gleichen sieben Bits wie in der Midi-Datei codiert ist, jedoch nur in einer anderen f√ºr MK geeigneten Darstellung.  Aufgrund der Tatsache, dass 16 Bits mit 4 Bits und Noten in einer Oktave von 12 codiert werden k√∂nnen, gibt es nicht verwendete Bytes. <br><br>  Das letzte achte Bit kann als Marker zum Aktivieren oder Deaktivieren von Noten verwendet werden.  Im Fall von MK sind aufgrund der Einstimmigkeit der Melodie Informationen √ºber die ged√§mpfte Note √ºberfl√ºssig.  Bei einem direkten Notenwechsel in der Melodie gibt es kein "Ausschalten-Einschalten", sondern einen "Schalter" der Note.  Und im Falle einer Pause wird "Stille ist aktiviert", f√ºr die Sie ein spezielles Byte aus dem Satz nicht verwendeter Bytes ausw√§hlen k√∂nnen und die Informationen zum Ausschalten der Note √ºberhaupt nicht verwenden.  Eine solche Idee ist insofern gut, als sie die Gr√∂√üe der resultierenden Melodie nach der Konvertierung speichert, das Modell jedoch im Allgemeinen kompliziert.  Ich bin dieser Idee nicht gefolgt, da es bereits viel Ged√§chtnis gibt. <br><br>  Informationen zu den Melodienoten in der Midi-Datei werden im Block des entsprechenden Kanals in der Ansicht ‚ÄûIntervall-Ereignis-Intervall-Ereignis ...‚Äú gespeichert.  Im konvertierten Format gilt genau das gleiche Prinzip.  Um ein Ereignis aufzuzeichnen (eine Notiz ein- oder auszuschalten), wie oben erw√§hnt, wird ein Byte verwendet.  Das erste Bit (das h√∂chstwertige Bit 7) codiert den Ereignistyp.  Der Wert "1" ist die Note ein und der Wert "0" ist die Note aus.  Die n√§chsten drei Bits codieren die Oktavnummer und die niedrigsten vier Bits codieren die Notennummer in der Oktave.  Ein Byte wird auch zum Aufzeichnen des Zeitintervalls verwendet.  Im urspr√ºnglichen Midi-Format wird hierf√ºr ein Format variabler L√§nge verwendet.  Sein kleiner Nachteil ist, dass nur 7 Bits das Zeitintervall (die Anzahl der "Ticks") codieren und das achte Bit ein Zeichen der Fortsetzung ist.  Das hei√üt, mit einem Byte k√∂nnen Sie tats√§chlich ein Intervall von bis zu 128 Ticks codieren.  Da die Zeitintervalle zwischen Ereignissen in realen und einfachen Melodien manchmal 128, aber fast nie 256 √ºberschreiten, habe ich das Format variabler L√§nge aufgegeben und mit einem Byte verwaltet.  Es codiert ein Zeitintervall von bis zu 256 Ticks.  Da das Projekt 48 Ticks pro Quartal oder 48 * 4 = 192 Ticks pro Zyklus verwendet, kann ein Byte verwendet werden, um ein Intervall von 256/192 = 1 Dauer zu codieren. (3) (ein ganzes und ein Drittel) Zyklen, die ganz genug. <br><br>  In dem nativen Format, in das die Midi-Datei konvertiert wird, habe ich auch einen kleinen Header mit einer Gr√∂√üe von 16 Bytes angewendet.  Die ersten 14 Bytes enthalten den Namen der Melodie.  Nat√ºrlich sollte der Name 14 Zeichen nicht √ºberschreiten.  Dann kommt ein Nullraum.  Das vorletzte Byte spiegelt das Tempo der Melodie in einer f√ºr MK geeigneten Ansicht wider.  Dieser Wert wird in der Konvertierungsphase berechnet und dient zur Initialisierung des MK-Timers, der f√ºr das Tempo verantwortlich ist.  Wie es berechnet wird, wird in einigen Abs√§tzen oben erl√§utert. <br><br>  Ab dem 17. Byte folgt der Inhalt der Melodie.  Jedes ungerade Byte entspricht einem Zeitintervall und jedes gerade Byte entspricht einem Ereignis (Anmerkung).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Byte ist Null, wenn die Melodie mit einer Note vom Anfang der Midi-Datei ohne vorl√§ufige Pause beginnt. Ein Zeichen f√ºr das Ende der Melodie ist eine Bezeichnung von zwei Bytes 0xFF. Die Aufgabe beinhaltet die zyklische Wiedergabe einer Melodie durch einen Mikrocontroller. Damit die Melodie in der Schleife aus rhythmischer Sicht harmonisch klingt, muss sie korrekt geloopt werden. Um dies zu tun, m√ºssen Sie nach einer letzten Note bei Bedarf eine bestimmte L√§nge pausieren, normalerweise bis der letzte Takt gef√ºllt ist. Und daf√ºr m√ºssen Sie das entsprechende Ereignis umleiten. Ich habe das Byte 0x0F verwendet, das beim Codieren von Notizen nicht verwendet wird. Dies entspricht dem Deaktivieren der 16. Note in der ersten Oktave, was absurd ist, da die Oktave nur 12 Noten enth√§lt. Wir haben oben √ºber nicht verwendete Bytes gesprochen. Somit codiert dieses Byte eine "stille Note",Das hohe Bit kann trotz der Redundanz der Informationen auch in diesem Fall auch als Zeichen f√ºr das Ein- und Ausschalten dienen. Um diese Note im Midi-Editor einzustellen, habe ich die erste oder zweite Note (eine davon) genommen. Ich m√∂chte Sie daran erinnern, dass die ersten 36 Noten im Modell nicht verwendet werden. Daher wird die erste (oder zweite) Note nach Bedarf f√ºr die korrekte Vervollst√§ndigung der Melodie verwendet, damit der Rhythmus beim Spielen in einer Schleife nicht unterbrochen wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden weiterhin im Editor von ‚ÄûCakewalk Pro Audio 9‚Äú arbeiten und eine beliebige Melodie komponieren. Die folgenden Abbildungen zeigen die Melodienotizen, die ich von einem der Bilder im Internet umgeschrieben habe. Notenbilder werden in zwei Stilen pr√§sentiert: im Stil der ‚ÄûPianorolle‚Äú und im klassischen Stil. Die erste ist sehr praktisch zum Schreiben und Bearbeiten von Melodien mit einer Computermaus. Das ist was ich benutze. </font></font><br><br><img src="https://habrastorage.org/webt/lr/-r/hy/lr-rhyphwp5xckftmq8fbwhlchc.png"><br><br><img src="https://habrastorage.org/webt/ot/qf/d7/otqfd7db-6wj0o9dscmg60tp5d8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie der Abbildung entnehmen k√∂nnen, wird am Ende die niedrigste (erste) Note f√ºr das Zeichen der Stille im richtigen Zeitintervall angewendet, um das zyklische Muster korrekt zu organisieren. Und ganz am Anfang der Melodie befindet sich angesichts des Vorhandenseins einer Ber√ºhrung ein Einzug von einem Viertel vor der ersten Note. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Editor bietet einen Modus zum Anzeigen von Ereignissen in Tabellenform.</font></font><br><br><img src="https://habrastorage.org/webt/vy/gu/n1/vygun1nauiacc6-zjbq66whb7qg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie der Abbildung entnehmen k√∂nnen, enth√§lt die Liste der Ereignisse nichts √úberfl√ºssiges, au√üer Notizen zu machen, wie dies manchmal bei unn√∂tigen Manipulationen an einem Musikprojekt der Fall ist. Wenn jedoch unn√∂tige Ereignisse, die sich nicht auf Notizen beziehen, aus irgendeinem Grund in der Liste enthalten sind, k√∂nnen sie durch Dr√ºcken der Entf-Taste gel√∂scht werden. Obwohl in der Phase der Konvertierung alle unn√∂tigen Ereignisse ignoriert werden und sich die Deltazeit ‚Äûansammelt‚Äú. √úbrigens habe ich diese Funktion dem Programm in der Debugging-Phase hinzugef√ºgt. Wie Sie vielleicht erraten haben, spiegelt die Tabelle die P√ºnktlichkeit und Dauer jeder Note zusammen mit anderen Eigenschaften wider, die wir nicht ben√∂tigen. Das hei√üt, mit einer Zeile in der Tabelle werden zwei Midi-Ereignisse gleichzeitig ausgedr√ºckt: Ein- und Ausschalten von Noten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie die Melodie im ‚ÄûMidi 1‚Äú -Format, wie in der Abbildung gezeigt.</font></font><br><br><img src="https://habrastorage.org/webt/l6/gx/uf/l6gxufg_2kmfge81godpmmhieki.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie die gespeicherte Datei im HEX-Editor. Es sollte sofort beachtet werden, dass im Gegensatz zu denselben AVI-Dateien (wie ich zuvor geschrieben habe) Bytes mit numerischen Werten in einer Midi-Datei nicht in umgekehrter Reihenfolge, sondern nach Dienstalter (Big Endian) dargestellt werden.</font></font><br><br><img src="https://habrastorage.org/webt/wj/oi/cn/wjoicnlzwx4ixajswxz3m3_jj5i.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Abbildung habe ich nur die gew√ºnschten Bytes mit Markierungen markiert. Zun√§chst umrei√üt ein fetter roter Rahmen drei Gruppen mit jeweils zwei Bytes. Dies ist jeweils die Art des MIDI-Formats (1), die Anzahl der Kan√§le (2) und die Anzahl der Ticks pro Quartal (48). Diese Werte m√ºssen diese drei Konstanten f√ºr die weitere Arbeit des Transformationsprogramms haben. Lila B√∂gen markieren den Anfang jedes der beiden Kan√§le. Im ersten Kanal sind 6 Bytes mit einem grauen Rahmen markiert, innerhalb dessen drei Bytes mit einem blauen Rahmen hervorgehoben sind. Diese 6 Bytes beziehen sich auf ein Metaereignis (Markierungsmarker 0xFF) mit einem Code von 0x51 und einer Inhaltsl√§nge von 0x03 Bytes. Drei Bytes weiter - der Inhalt des Ereignisses. Dieses Ereignis legt das Tempo der Melodie mit nur diesen drei Bytes in einem blauen Rahmen fest. Das letzte niedrige Byte kann sicher verworfen werden, da die Supergenauigkeit nicht wichtig ist. Ich werde nicht alle Bytes in der Datei detailliert und gr√ºndlich beschreiben.In der zweiten Spur - in der Spur mit Noten - sind die Werte der Zeitintervalle in einem blauen Rahmen eingekreist. √úbrigens haben sie in diesem Beispiel ein Byte nicht √ºberschritten, mit Ausnahme des einzigen Falls mit der vorletzten Note. Es ist die vorletzte Note der Melodie (einschlie√ülich der zus√§tzlichen Pseudonote des Endes), die drei Viertel eines Takts dauert, was 48 * 3 = 144 Ticks entspricht und 128 √ºberschreitet. Daf√ºr m√ºssen Sie je nach Format mit variabler L√§nge zwei Bytes verwenden. Und um das Zeitintervall im konvertierten Format darzustellen, kann der Wert 144 leicht mit einem Byte codiert werden. Ich umkreiste diesen Sonderfall in einem doppelten blauen Rahmen. Notizen sind in einem gr√ºnen Rahmen oder besser gesagt in ihren Codes eingekreist. Die Lautst√§rke jeder Note ist in einem grauen Rahmen eingekreist. Wie bereits erw√§hnt, ist ein Volumen von Null ein Zeichen f√ºr die Stummschaltung (Freigabe) der Note, und in der gesamten Komposition gibt es ein Ereignis:Notizen einschalten. Der Code f√ºr dieses Ereignis, 0x90, ist gelb markiert. Ich habe nicht alle Noten bis zum Ende der Melodie umrissen. Die einzige Ausnahme ist der doppelte blaue Rahmen f√ºr ein einzelnes Zeitintervall, der den Schwellenwert von 128 Ticks √ºberschreitet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben erw√§hnt, arbeitet das Programm zum Konvertieren einer MIDI-Datei in ein eigenes Format f√ºr MK tats√§chlich mit einer Gruppe von mehreren MIDI-Dateien und erstellt am Ausgang eine Bilddatei f√ºr das EEPROM. Betrachten Sie ein Fragment aus dieser Datei, das sich auf den Inhalt der konvertierten Melodie aus dem obigen Beispiel bezieht. Ich habe es in einem anderen HEX-Editor ge√∂ffnet, um das Bild nach Sektoren anzuzeigen und darauf zu achten. Jede neue Melodie beginnt mit einem neuen Sektor.</font></font><br><br><img src="https://habrastorage.org/webt/9p/e5/h1/9pe5h1qaetdg-kjk-abaxvlk6am.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das letzte Byte aus der ersten Zeile (die ersten 16 Bytes), das in einem roten Rahmen eingekreist ist, legt das Tempo der Melodie fest. Berechnungen zufolge f√§llt der Wert 0xC1 (193) auf das Tempo 154, 155 und 156. Gerade im Projekt habe ich das Melodietempo auf 155 Schl√§ge pro Minute eingestellt, was in einem der Screenshots zuvor zu sehen war. Die ersten Bytes (bis zum 14.), die in einem blauen Rahmen eingekreist sind, bestimmen den Namen der Komposition. In diesem Beispiel "Klassisch". F√ºr MK sind diese Informationen nicht erforderlich, sie werden nur zur Orientierung im HEX-Editor ben√∂tigt. Wenn Sie mit dem Display ein komplexeres Projekt auf dem MK erstellen, k√∂nnen Sie diese Informationen verwenden, indem Sie den Namen der gespielten Melodie anzeigen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Zeile (ab dem 17. Byte) beginnt den Inhalt der Melodie. Wie bei der urspr√ºnglichen Midi-Datei habe ich nicht alle Noten gemalt, sondern nur einen Teil. Die ungeraden blau hervorgehobenen Bytes sind Zeitintervalle. Sogar Bytes, die mit einem gr√ºnen Rahmen markiert sind, sind Notizen zusammen mit Zeichen ihres Ein / Aus. Beispielsweise beziehen sich die ersten beiden gr√ºnen Bytes, 0xB4 und 0x34, auf dieselbe Notiz mit dem Code 0x34, und die Bytes unterscheiden sich nur in einem h√∂herwertigen Bit. In Byte 0xB4 (0b10110100) ist das High-Bit eins, was ein Zeichen f√ºr das Einschalten einer Note ist, und in Byte 0x34 (0b00110100) ist das High-Bit Null, was ein Zeichen f√ºr das Ausschalten einer Note ist. Byte 0x34 codierte eine Note mit den folgenden Parametern: Oktavcode 0b011 und Notencode in einer Oktave - 0b0100. Oder in Dezimalform 3 bzw. 4. Wenn Sie nicht von Null z√§hlen,es stellt sich heraus, dass die erste Note in der Melodie zur vierten Oktave geh√∂rt und die f√ºnfte darin ist. Die Oktavnummerierung wird hier willk√ºrlich gew√§hlt, ohne die Standardnummerierung zu ber√ºcksichtigen. Die vereinbarte Note ist nach meiner Berechnungstabelle Excel die Note mit dem Code 76 (0x4C) f√ºr das Midi-Format, dh die Note E6 (Note ‚Äûe‚Äú der 6. Mitteloktave). So ist es: Die Komposition beginnt mit dieser Note.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte ein Sonderfall in der Musiksequenz beachtet werden, wenn dieselbe Note ohne Pause wiederholt wird. In unserem Beispiel sind alle benachbarten Noten, die pausenfrei sind, unterschiedlich. Es gibt jedoch Melodien, bei denen sich die Note ohne Pause wiederholt. Das hei√üt, das Zeitintervall zwischen dem Ausschalten einer und dem Einschalten der n√§chsten exakt gleichen Note ist Null. Angesichts der Besonderheit einer komplexen Musiksynthese wird eine solche Sequenz jedem Synthesizer bekannt vorkommen. Im Fall von MK klingt es jedoch so zusammenh√§ngend, dass es schwierig ist, den Unterschied zwischen zwei identischen Noten zu h√∂ren. In der Praxis wird es nat√ºrlich keine eindeutige Verschmelzung aufgrund von Zwischenberechnungen im MC geben, aber dennoch ist dieses Zeitintervall h√∂chstwahrscheinlich viel k√ºrzer als die Dauer von nur einem Tick. F√ºr solche Sonderf√§lle befindet sich das Programm in der Konvertierungsphase,Wenn Sie auf eine solche Kombination sto√üen, wird eine Pause zwischen Noten mit einer Tick-L√§nge eingeleitet und die Dauer einer Note links von der Note um dasselbe Zeitintervall verringert. Eine minimale ‚ÄûL√ºcke‚Äú von 1 Tick ist v√∂llig ausreichend, wie die Praxis gezeigt hat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem doppelten blauen Rahmen umkreiste ich den Wert des Zeitintervalls (0x90), der 128 √ºberschreitet und f√ºr den ich je nach Format mit variabler L√§nge zwei Bytes in der Midi-Datei ausgeben musste. Gr√ºne Kreise sind Bytes auf und neben derselben Pseudonote, um die Komposition auszurichten. Wenn das MK-Programm diese Bytes sieht, interpretiert es sie als eingeschaltete Stille. Schlie√ülich markieren zwei 0xFF-Bytes, die in einem fetten blauen Rahmen eingekreist sind, das Ende der Melodie. Die Werte aller folgenden Bytes innerhalb des aktuellen Speichersektors k√∂nnen beliebig sein, sie werden ignoriert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie den allerersten Sektor der Ausgabe-EEPROM-Bilddatei. Wie ich bereits geschrieben habe, dient es als Liste von Adressen von Sektoren des Beginns von Melodien. Das Programm hat erfolgreich 8 Melodien ohne Fehler gescannt (zum Zeitpunkt des Schreibens hatte ich 8 Melodien aufgenommen). Der Wert der Anzahl der Melodien wird im letzten 512. Byte des Sektors aufgezeichnet. Und von Anfang an werden Adressen geschrieben. F√ºr die erste Melodie lautet die Adresse 0x01, was dem zweiten Sektor entspricht (der erste, wenn Sie von Grund auf neu z√§hlen). Die dritte und vierte Melodie (zwei von acht) erwiesen sich als lang und passten nicht in einen Sektor. Daher werden L√ºcken in der Adresssequenz beobachtet. Wenn Sie 64 KB Speicher z√§hlen, k√∂nnen Sie nicht mehr als 127 Musikst√ºcke aufnehmen, sodass ein Sektor f√ºr die Adressierung v√∂llig ausreicht.</font></font><br><br><img src="https://habrastorage.org/webt/t7/fm/g-/t7fmg-97qcqphlojly3l8xcpnru.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle vorl√§ufigen Sch√§tzungen und Berechnungen, die im Artikel enthalten sind, habe ich in Excel durchgef√ºhrt. </font><font style="vertical-align: inherit;">Die folgenden Screenshots zeigen Screenshots der resultierenden Tabellen (im Dual-Window-Modus). </font></font><br><br><img src="https://habrastorage.org/webt/31/cb/my/31cbmycwzmmfr_noks7sifxpaps.png"><br><br><img src="https://habrastorage.org/webt/jn/tm/1f/jntm1fp2sga5erx_xmtqq3bbhcy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wen k√ºmmert es, unten unter dem Spoiler befindet sich der Text eines C-Programms, das MIDI-Dateien in eine Datei f√ºr den Mikrocontroller konvertiert. </font><font style="vertical-align: inherit;">Aus dem Text habe ich die zus√§tzlichen Zeilen entfernt, die zum Debuggen verwendet wurden. </font><font style="vertical-align: inherit;">Das Programm funktioniert bisher und gibt nicht vor, lesbar zu sein und Code zu schreiben.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptdatei 1.cpp</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;string.h&gt; #define SPACE 1 HANDLE openInputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_READ, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } void filepos(HANDLE f, unsigned int p){ LONG LPos; LPos = p; SetFilePointer (f, LPos, NULL, FILE_BEGIN); //FILE_CURRENT //https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer } DWORD wr; DWORD ww; unsigned long int read32(HANDLE f){ unsigned char b3,b2,b1,b0; ReadFile(f, &amp;b3, 1, &amp;wr, NULL); ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b3&lt;&lt;24|b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned long int read24(HANDLE f){ unsigned char b2,b1,b0; ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned int read16(HANDLE f){ unsigned char b1,b0; ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b1&lt;&lt;8|b0; } unsigned char read8(HANDLE f){ unsigned char b0; ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b0; } void message(unsigned char e){ printf("Error %d: ",e); switch(e){ case 1: // -   -; printf("In track0 event is not FF\n"); break; case 2: // -  127 printf("Len of FF &gt;127\n"); break; case 3: //  ; printf("Midi is incorrect\n"); break; case 4: //   ; printf("Delta&gt;255\n"); break; case 5: //    RPN  NRPN; printf("RPN or NRPN is detected\n"); break; case 6: //   ; printf("Note in 1...35 range\n"); break; case 7: //    ; printf("Long of name of midi file &gt;18\n"); break; } system("PAUSE"); } int main(){ HANDLE in; HANDLE out; unsigned int i,j; unsigned int inpos; unsigned int outpos=0; unsigned char byte; // ; unsigned char byte1; //  1  ; unsigned char byte2; //  2  ; unsigned char status; //- ( ); unsigned char sz0; // -; unsigned long int bsz0; //    -; unsigned short int format, ntrks, ppqn; //  ; unsigned long int bsz1; //    ; unsigned long int bpm; // ( .  ); unsigned long int time=0; //    ( ); unsigned char scale; //    ,  ; unsigned char oct; //    ; unsigned char nt; // ; unsigned char outnote; //      ; unsigned char prnote=0; //  ; unsigned char tdt; // ()   ; unsigned int dt; //    ( ); unsigned int outdelta=0; //    ( ); unsigned char prdelta=0; //  ; char fullname[30]; //    ; char name[16]; // ; WIN32_FIND_DATA fld; //   mid; HANDLE hf; unsigned short int csz; //  ; unsigned char nfile=0; // ; unsigned char adr[128]; //    ; out=openOutputFile("IMAGE.out"); outpos=512; //   ; filepos(out,outpos); hf=FindFirstFile(".\\midi\\*.mid",&amp;fld); do{ printf("\n***** %s *****\n",fld.cFileName); if(strlen(fld.cFileName)&gt;18){ //   ; message(7); } sprintf(name,"%s",fld.cFileName); name[strlen(fld.cFileName)-4]=0; // ; sprintf(fullname,".\\midi\\%s",fld.cFileName); //    ; WriteFile(out, name, strlen(name), &amp;ww, NULL); //    ; in=openInputFile(fullname); //    ; #include "process.cpp" //     ; outpos+=((csz/512)+1)*512; //    ; adr[nfile]=(outpos/512)-((csz/512)+1); //  ()   ; filepos(out,outpos); CloseHandle(in); nfile+=1; }while(FindNextFile(hf,&amp;fld)); //   ,    ; FindClose(hf); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); outpos=0; //   ; filepos(out,outpos); WriteFile(out, adr, nfile, &amp;ww, NULL); outpos=511; //  ; filepos(out,outpos); WriteFile(out, &amp;nfile, 1, &amp;ww, NULL); CloseHandle(out); system("PAUSE"); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Process.cpp-Dateianhang</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">0</span></span>; inpos=<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ; filepos(in,inpos); format=read16(in); ntrks=read16(in); ppqn=read16(in); if(format!=1 || ntrks!=2 || ppqn!=48){ message(3); } inpos+=10; filepos(in,inpos); //    -; bsz0=read32(in); inpos+=4; while(inpos&lt;22+bsz0){ //      ; tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } byte=read8(in); inpos+=1; if(byte==0xFF){ //  ,  -    -; byte=read8(in); //  -; sz0=read8(in); //  , ,     127 ( ); if(sz0&amp;0x80){ message(2); } inpos+=2; switch(byte){ case 0x51: //   "Set Tempo"; bpm=read24(in); scale=256-(bpm/(ppqn*128)); printf("scale=%d\n",scale); filepos(out,outpos+15); // ; WriteFile(out, &amp;scale, 1, &amp;ww, NULL); csz=16; break; default: break; } inpos+=sz0; filepos(in,inpos); // ,     0x51; }else{ message(1); } } //    ; outdelta=0; inpos+=4; filepos(in,inpos); bsz1=read32(in); inpos+=4; while(inpos&lt;30+bsz0+bsz1){ tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } outdelta+=dt; //  ; // ,      , ; time+=dt; //  ; byte=read8(in); //    ,  ; inpos+=1; if(byte&amp;0x80){ //  ; status=byte; // ; if(byte==0xFF){ //   -; byte=read8(in); //    ,    ; sz0=read8(in); inpos+=(2+sz0); filepos(in,inpos); }else{ //    ; byte1=read8(in); inpos+=1; } }else{ //    ,        ; byte1=byte; } switch(status&amp;0xF0){ // ,      ; case 0xF0: //   ,  -; break; case 0x80: // ; byte2=read8(in); //     ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } outnote=(oct&lt;&lt;4)|nt; //  ; prnote=outnote; prdelta=outdelta; if(outdelta&gt;255){ //     255 (  ); message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; //  ; break; case 0x90: //   ; byte2=read8(in); //    ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } if(byte2){ //  ,   ; outnote=0x80|(oct&lt;&lt;4)|nt; //  = 1; //   ; if(!outdelta &amp;&amp; (outnote&amp;0x7F)==prnote){ //     ; prdelta-=SPACE; // -; filepos(out,outpos+csz-2); //    ; WriteFile(out, &amp;prdelta, 1, &amp;ww, NULL); // ; filepos(out,outpos+csz); outdelta=SPACE; //  -  ; } }else{ //  ,    ; outnote=(oct&lt;&lt;4)|nt; prnote=outnote; //  ; prdelta=outdelta; //  -; } if(outdelta&gt;255){ //   -    ; message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; // -   ; break; //   () ; case 0xA0: // ; byte2=read8(in); inpos+=1; break; case 0xB0: //   ; if(byte1&gt;=98&amp;&amp;byte1&gt;=101){ //     NRPN  RPN; message(5); //  ; } byte2=read8(in); inpos+=1; break; case 0xC0: //  (.  ); // , ,    ; break; case 0xD0: //; break; case 0xE0: // ; byte2=read8(in); inpos+=1; break; default: //  (   ); break; } } //     0xFFFF,    ; outdelta=255; outnote=255; WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; //   ,     ; printf("Length: %i (%i:%02i)\n",time,time/192,time%192);</span></span></code> </pre><br></div></div><br>  Der grundlegende Teil des Programms f√ºr MK ist in der Tat sehr einfach.  Betrachten Sie eine der Optionen f√ºr die Implementierung, genauer gesagt den Hauptteil. <br><br>  Timer 1, der zum Erzeugen des Tons von Noten verwendet wird, ist wie folgt konfiguriert.  Zum Aktivieren und Deaktivieren von Notizen werden jeweils die folgenden Ersetzungen verwendet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENT1 TCCR1B=0x09;TCCR1A=0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIST1 TCCR1B=0x00;TCCR1A=0x00;PORTB.1=0</span></span></code> </pre><br>  Bevor Sie den Timer starten, m√ºssen Sie dem OCR1A-Register einen 16-Bit-Wert zuweisen, der der gespielten Frequenz entspricht.  Dies wird sp√§ter gezeigt.  Wenn der Timer eingeschaltet ist, wird dem TCCR1B-Register der Wellenformgenerierungsmodus mit einem Timer-Teiler von 1 zugewiesen, und das TCCR1A-Register wird beim Vergleichen der √úbereinstimmung auf OC1A umschalten gesetzt.  In diesem Fall wird das Signal vom speziell daf√ºr vorgesehenen Ausgang von MK ‚ÄûOC1A‚Äú entfernt.  Beim ATmega8 im SMD-Paket ist dies Pin 13, der mit PORTB.1 identisch ist.  Wenn der Timer ausgeschaltet wird, werden beide Register zur√ºckgesetzt und der Ausgang von PORTB.1 wird auf Null gesetzt.  Dies ist notwendig, um w√§hrend der Stille das Ausgeben einer konstanten Spannung zu verhindern, was f√ºr den Eingang des VLF unerw√ºnscht w√§re.  Sie k√∂nnen zwar einen Kondensator in die Schaltung einbauen, aber Sie k√∂nnen den Ausgang auch programmgesteuert deaktivieren.  An diesem Ausgang kann eine konstante Spannung auftreten, wenn die Note zum Zeitpunkt der entsprechenden Phase des Signals ausgeschaltet wird, und dies ist in 50% der F√§lle der Fall. <br><br>  Erstellen Sie ein Array von Timer-Werten f√ºr 12 Noten der ersten Oktave.  Diese Werte wurden im Voraus berechnet. <br><br><pre> <code class="cpp hljs">freq[]={<span class="hljs-number"><span class="hljs-number">61156</span></span>,<span class="hljs-number"><span class="hljs-number">57724</span></span>,<span class="hljs-number"><span class="hljs-number">54484</span></span>,<span class="hljs-number"><span class="hljs-number">51426</span></span>,<span class="hljs-number"><span class="hljs-number">48540</span></span>,<span class="hljs-number"><span class="hljs-number">45815</span></span>,<span class="hljs-number"><span class="hljs-number">43244</span></span>,<span class="hljs-number"><span class="hljs-number">40817</span></span>,<span class="hljs-number"><span class="hljs-number">38526</span></span>,<span class="hljs-number"><span class="hljs-number">36364</span></span>,<span class="hljs-number"><span class="hljs-number">34323</span></span>,<span class="hljs-number"><span class="hljs-number">32396</span></span>};</code> </pre><br>  Die Noten anderer Oktaven werden, wie gesagt, durch Teilen durch zwei Grad erhalten. <br><br>  Die Konfiguration von Timer 0 ist noch einfacher.  Es arbeitet st√§ndig mit einem √úberlauf-Interrupt und wird jedes Mal neu mit dem Wert initialisiert, der dem Tempo der Melodie entspricht.  Der Timer-Teiler ist 5: TCCR0 = 0x05.  Basierend auf diesem Timer wird ein virtueller Timer erstellt, der die Tics (Zeiten) in der Melodie z√§hlt.  Die Verarbeitung der Antwort dieses Timers wird in den Hauptprogrammzyklus gestellt. <br><br>  Die Timer 0-Interrupt-Funktion ist wie folgt. <br><br><pre> <code class="cpp hljs">interrupt [TIM0_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer0_ovf_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ent01){ vt01+=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT0=top0; }</code> </pre><br>  Hier ist die Variable ent01 f√ºr die Aktivierung des virtuellen Timers verantwortlich.  Mit dieser Variablen kann sie bei Bedarf ein- oder ausgeschaltet werden.  Die Variable vt01 ist die z√§hlbare prim√§re Variable des virtuellen Timers.  Die Zeile TCNT0 = top0 zeigt die Initialisierung des Timers 0 auf den gew√ºnschten Wert top0 an, der vor dem Abspielen aus dem Titel der Melodie gelesen wird. <br><br>  Die Nummer der zu spielenden Melodie entspricht der Variablen alm.  Es dient auch als Flagge f√ºr den Beginn der Reproduktion.  Sie muss je nach Aufgabe auf eine der verschiedenen Arten eine Melodienummer zuweisen.  Danach wird der n√§chste Block des Hauptzyklus aktiv. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alm){ <span class="hljs-comment"><span class="hljs-comment">//     ; adr=eepr(alm-1)&lt;&lt;9; //     (&lt;&lt;9    512); adr+=15; //   ,      ; top0=eepr(adr); //  ; adr+=1; //     ; adr0=adr; //      (  ); top01=eepr(adr); //      " "  ; adr+=1; //   ; note=eepr(adr); // ; adr+=1; //    -; vt01=0; //    ; ent01=1; //  ; TCNT0=0; //  ; alm=0; //        ,   ; }</span></span></code> </pre><br>  Das weitere Umschalten von Note zu Note erfolgt in der Verarbeitungseinheit des virtuellen Timers, die sich ebenfalls in der Hauptschleife befindet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(vt01&gt;=top01){ <span class="hljs-comment"><span class="hljs-comment">//   ,    ; vt01=0; //  ; if(note&amp;0x80){ //     ""; nt=note&amp;15; //    ; oct=(note&amp;0x7F)&gt;&gt;4; //  ; if(nt!=15){ //       15,   ; OCR1A=freq[nt]&gt;&gt;oct; //     ; //         ; ENT1; // ; }else{ //  " "   ; DIST1; // ; } }else{ //     ""; DIST1; // ; } top01=eepr(adr); //      " "; adr+=1; //   ; note=eepr(adr); //   ; adr+=1; // ; if(note==255 &amp;&amp; top01==255){ //      ; top01=eepr(adr0); //   ,   ; note=eepr(adr0+1); //   ; adr=adr0+2; //   ; } }</span></span></code> </pre><br>  Aus den Kommentaren im Programmtext sollte alles klar und verst√§ndlich sein. <br><br>  Verwenden Sie zum Stoppen der Melodie die folgende Einf√ºgung der Hauptschleife. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stop){ <span class="hljs-comment"><span class="hljs-comment">//  ; DIST1; //  ; ent01=0; //  ; vt01=0; //  ; }</span></span></code> </pre><br>  Es gibt eine kleine Bemerkung zur Implementierung der Melodienwiedergabe.  Bevor jede neue Note zu ert√∂nen beginnt, verbringt der Mikrocontroller einige Zeit damit, das gelesene Byte der Note in einen Timerwert umzuwandeln.  Diese Zeit ist, wie sich in der Praxis herausstellte, relativ gering und beeintr√§chtigt die Wiedergabequalit√§t nicht.  Aber ich hatte Zweifel, dass diese Operation unsichtbar bleiben w√ºrde.  In diesem Fall w√ºrden vor jeder Note zus√§tzliche Pausen erscheinen und der Rhythmus der Melodie w√ºrde unterbrochen.  Dieses Problem ist aber auch l√∂sbar.  Es reicht aus, die Timer-Werte der n√§chsten Note im Voraus zu berechnen, w√§hrend die aktuelle Note ert√∂nt.  Diese Prozedur muss getrennt von der Verarbeitung des virtuellen Timers in der Hauptprogrammschleife unter Verwendung eines speziell bezeichneten Flags durchgef√ºhrt werden.  Aufgrund der Tatsache, dass die Berechnungszeit die Spielzeit selbst der k√ºrzesten Note wahrscheinlich nicht √ºberschreitet, ist eine solche L√∂sung angemessen. <br><br>  Fahren wir nun mit dem Testen des Programms fort. <br><br>  Zus√§tzlich zu den obigen Codefragmenten habe ich dem MK-Programm Schaltfl√§chenverarbeitungsfunktionen hinzugef√ºgt, mit denen ich die Aufnahme oder Deaktivierung einer bestimmten Melodie steuern kann.  Das EEPROM ist √ºber einen I2C-Bus mit MK verbunden, dessen Arbeit auf Softwareebene implementiert wird.  Das Projekt wurde mit Hilfe von ‚ÄûCodeVisionAVR‚Äú zusammen mit ‚ÄûCodeWizardAVR‚Äú durchgef√ºhrt.  Ich gebe MK von Pin 13 √ºber den Teiler auf die PC-Soundkarte aus und nehme den Klang der Melodie im Soundeditor auf.  Ich habe den EEPROM-Speicher mit Hilfe der Firmware geflasht, √ºber die ich in einem der vorherigen Artikel geschrieben habe.  Aufgrund der Tatsache, dass nicht alle Bytes der Bilddatei n√ºtzlich sind, kann die Speicherfirmware nur durch n√ºtzliche Bytes (bis zu den Endmarkierungen von Melodien) implementiert werden, um Aufnahmezeit und Chipressourcen zu sparen.  Zu diesem Zweck k√∂nnen Sie ein separates Programm erstellen oder w√§hrend der Konvertierung direkt Bytes auf den Chip schreiben und dem Hauptprogramm hinzuf√ºgen. <br><br>  Unter den acht Melodien gibt es drei Testmelodien, mit deren Hilfe ich den Frequenzbereich nach Geh√∂r, den Klang der Zusammenf√ºhrung identischer Noten, den Klang der k√ºrzesten Noten, schnelle √úberg√§nge usw. bewerten werde.  Ich m√∂chte Sie daran erinnern, dass das Zusammenf√ºhren derselben Noten tats√§chlich mit einer Pause von einem Tick klingt und die erste Note bei der Fusion einen Tick weniger dauert. <br><br>  Eine der Testmelodien ist eine Folge von Noten vom ersten bis zum letzten mit einer Dauer von einer Note in einem Viertel und einem Melodietempo von 40 Schl√§gen pro Minute. <br><br><img src="https://habrastorage.org/webt/d7/sr/hx/d7srhxannedgrv63owftqzeaf7k.png"><br><br>  In diesem Szenario klingt eine Note etwas l√§nger als eine Sekunde. Daher k√∂nnen Sie detailliert h√∂ren, wie der gesamte Notenbereich klingt.  Im Frequenzspektrum des Audio-Editors "Adobe Audition" werden die Hauptfrequenzkomponenten und ihre oberen Harmonischen aufgrund der entsprechenden S√§gezahnwellenform beobachtet.  Auff√§llig ist die logarithmische Beziehung zwischen Notennummer und Frequenz. <br><br><img src="https://habrastorage.org/webt/sn/_2/xn/sn_2xnmlyxsmmfo23beniaqvzki.png"><br><br>  Bei der Analyse der Zeitintervalle ist deutlich zu erkennen, dass die tats√§chliche Pause zwischen aufeinanderfolgenden Noten durchschnittlich etwa 145 Abtastwerte (bei einer Abtastfrequenz der Audioaufzeichnung von 44100 Hz) betr√§gt, was etwa 3 ms entspricht.  Dies ist die Zeit, in der der MK die erforderlichen Berechnungen durchf√ºhrt.  Diese Beilagen sind regelm√§√üig vor jeder Note vorhanden.  Ich habe speziell die Bedeutung in den Beispielen geschrieben, da diese Informationen origineller und genauer sind, obwohl dies nicht sehr wichtig ist. <br><br><img src="https://habrastorage.org/webt/ue/t6/pg/uet6pgd-e0iac2m2imj3m4fa5o4.png"><br><br>  Und die L√§nge eines Ticks bei einem durchschnittlichen Melodietempo von 120 Schl√§gen pro Minute betr√§gt etwa 10 ms.  Daraus folgt, dass es im Prinzip m√∂glich w√§re, nicht dieselbe Korrektur in einem Tick einzuf√ºhren, wenn zwei identische Noten ohne Pause nacheinander gehen.  Ich denke, dass das regelm√§√üige Einf√ºgen von 3 ms zwischen Noten v√∂llig ausreichend w√§re.  Beim Anh√∂ren einer Melodie fallen diese regul√§ren Einf√ºgungen √ºberhaupt nicht auf und die Melodien klingen gleichm√§√üig.  Daher muss der Timer-Wert f√ºr die n√§chste Note nicht besonders berechnet werden, w√§hrend die aktuelle Note abgespielt wird. <br><br>  Eine andere Testmelodie mit einem Tempo von 200 Schl√§gen pro Minute enth√§lt nacheinander die gleichen 1/32 Noten aus dem mittleren Bereich ohne Pause.  In diesem Fall gibt es nach der Verarbeitung beim Spielen zwischen ihnen eine Pause von 1 Tick, die bei diesem schnellen Tempo von 310 Samples (ca. 6 ms) des aufgezeichneten Signals. <br><br><img src="https://habrastorage.org/webt/ms/on/m_/msonm__-e7svpb38fq22xhul7dm.png"><br><br>  Die L√§nge dieser Pause ist √ºbrigens vergleichbar mit der Periode des Signals, die ein hohes Tempo der Melodie anzeigt.  Und sein Klang erinnert an einen Triller. <br><br>  Grunds√§tzlich kann dies beendet werden.  Ich war mit dem Ergebnis des Ger√§tes zufrieden, es hat alle Erwartungen √ºbertroffen.  Die meiste Zeit widmete ich mich dem Studium des Midi-Formats und dem Debuggen des Konvertierungsprogramms.  In einem der folgenden Artikel werde ich mich auch einem Thema im Zusammenhang mit MIDI widmen, in dem es um die Anwendung dieses Formats in anderen interessanten Anwendungen geht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454514/">https://habr.com/ru/post/de454514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454498/index.html">Die Aufgabe mit Sternchen: Wir sammeln Elektromagnete am Beispiel von Twitter Mantis-E0</a></li>
<li><a href="../de454500/index.html">Douglas Engelbart: ‚ÄûErweiterung des menschlichen Intellekts: Ein konzeptioneller Rahmen‚Äú (Schritt 2)</a></li>
<li><a href="../de454506/index.html">Entropic - Neue Registrierung f√ºr verteilte Pakete f√ºr Node.js.</a></li>
<li><a href="../de454508/index.html">Portieren von Desktop-Anwendungen nach .NET Core</a></li>
<li><a href="../de454512/index.html">Fr√ºhst√ºcksbericht mit Charles Weatherly, Autor des Kultbuchs Etudes for Programmers</a></li>
<li><a href="../de454516/index.html">Wie man guten Text f√ºr 200 Rubel bekommt</a></li>
<li><a href="../de454518/index.html">Wasmer: Die schnellste Go-Bibliothek zum Ausf√ºhren von WebAssembly-Code</a></li>
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454522/index.html">Node.js: Verwalten des Speichers, der f√ºr Anwendungen verf√ºgbar ist, die in Containern ausgef√ºhrt werden</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnb√§ndern Samsung Level On Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>