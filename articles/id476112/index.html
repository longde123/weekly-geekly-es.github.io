<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 🈲 🥇 Elixir sebagai tujuan pengembangan untuk python async 👉🏽 🧑🏿‍🤝‍🧑🏾 🛠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam buku "Python. Menuju puncak keunggulan ”Luciano Ramallo menggambarkan satu kisah. Pada tahun 2000, Luciano mengambil kursus, dan suatu kali Guid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixir sebagai tujuan pengembangan untuk python async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/">  Dalam buku "Python.  Menuju puncak keunggulan ”Luciano Ramallo menggambarkan satu kisah.  Pada tahun 2000, Luciano mengambil kursus, dan suatu kali Guido van Rossum melihat ke arah hadirin.  Begitu acara seperti itu muncul, semua orang mulai bertanya kepadanya.  Ketika ditanya fungsi apa yang dipinjam Python dari bahasa lain, Guido menjawab: "Semua yang baik dalam Python dicuri dari bahasa lain." <br><br>  Memang benar.  Python telah lama hidup dalam konteks bahasa pemrograman lain dan menyerap konsep-konsep dari lingkungannya: asyncio dipinjam, berkat ungkapan Lisp lambda muncul, dan Tornado disalin dari libevent.  Tetapi jika ada yang meminjam ide, itu adalah Erlang.  Itu dibuat 30 tahun yang lalu, dan semua konsep dalam Python yang saat ini sedang dilaksanakan atau baru saja diuraikan telah lama bekerja di Erlang: multi-core, pesan sebagai dasar komunikasi, pemanggilan metode dan introspeksi di dalam sistem produksi langsung.  Ide-ide ini, dalam satu atau lain bentuk, menemukan ekspresinya dalam sistem seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  Jika Anda tidak memperhitungkan Ilmu Data, di mana Python sekarang keluar dari persaingan, maka semua yang lain sudah diterapkan di Erlang: bekerja dengan jaringan, menangani HTTP dan soket web, bekerja dengan basis data.  Oleh karena itu, penting bagi pengembang Python untuk memahami ke mana bahasa akan bergerak: di sepanjang jalan yang telah melewati 30 tahun yang lalu. <br><br>  Untuk memahami sejarah pengembangan bahasa lain dan memahami di mana kemajuan sedang berlangsung, kami mengundang <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">erlyvideo</a> ), penulis proyek Erlyvideo.ru, ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> . <br><br>  Di bawah cut adalah versi teks dari laporan ini, yaitu: ke arah mana sistem dipaksa untuk berkembang, yang terus bermigrasi dari kode linier sederhana ke libevent dan seterusnya, yang umum dan apa perbedaan antara Elixir dan Python.  Kami akan memberikan perhatian khusus pada cara mengelola soket, utas, dan data dalam berbagai bahasa dan platform pemrograman. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Erlyvideo.ru memiliki sistem pengawasan video di mana kontrol akses untuk kamera ditulis dengan Python.  Ini adalah tugas klasik untuk bahasa ini.  Ada pengguna dan kamera, video yang dapat mereka tonton: seseorang melihat beberapa kamera, sementara yang lain melihat situs biasa. <br><br>  Python dipilih karena nyaman untuk menulis layanan seperti itu: ada kerangka kerja, ORM, programmer, setelah semua.  Perangkat lunak yang dikembangkan dikemas dan dijual kepada pengguna.  Erlyvideo.ru adalah perusahaan yang menjual perangkat lunak, dan tidak hanya menyediakan layanan. <br><br>  Masalah apa dengan Python yang ingin saya pecahkan. <br><br>  <strong>Mengapa ada masalah dengan multicore?</strong>  Kami menjalankan Flussonic di komputer stadia bahkan sebelum Intel melakukannya.  Tapi Python mengalami kesulitan dengan ini: mengapa masih tidak menggunakan semua 80 core server kami untuk bekerja? <br><br>  <strong>Bagaimana tidak menderita soket terbuka?</strong>  Memantau jumlah soket terbuka adalah masalah besar.  Ketika sudah mencapai batas, tutup dan cegah kebocoran juga. <br><br>  <strong>Apakah variabel global yang dilupakan punya solusi?</strong>  Membocorkan variabel global adalah neraka bagi bahasa pengumpulan sampah seperti Java atau C #. <br><br>  <strong>Bagaimana cara menggunakan besi tanpa membuang sumber daya?</strong>  Bagaimana bertahan tanpa menjalankan 40 pekerja Jung dan 64 GB RAM jika kita ingin menggunakan server secara efisien dan tidak membuang ratusan ribu dolar per bulan pada perangkat keras yang tidak perlu? <br><br><h3>  Mengapa multicore dibutuhkan </h3><br>  <strong>Agar semua inti dapat dimanfaatkan sepenuhnya,</strong> dibutuhkan lebih banyak pekerja daripada inti.  Misalnya, untuk 40 inti prosesor, diperlukan 100 pekerja: satu pekerja pergi ke basis data, yang lain sibuk dengan hal lain. <br><br>  <strong>Satu pekerja dapat mengkonsumsi 300-400 MB</strong> .  Kami masih menulis ini dalam Python, dan tidak di Ruby on Rails, yang dapat mengkonsumsi beberapa kali lebih banyak dan 40 GB RAM akan dengan mudah dan mudah sia-sia.  Ini tidak terlalu mahal, tetapi mengapa membeli memori di mana Anda tidak dapat membeli. <br><br>  <strong>Multi-core membantu meraba-raba data bersama dan mengurangi konsumsi memori</strong> , menjalankan banyak proses independen dengan mudah dan aman.  Jauh lebih mudah diprogram, tetapi lebih mahal dari memori. <br><br><h3>  Manajemen soket </h3><br>  Di soket web, kami melakukan polling data runtime kamera dari backend.  Perangkat lunak Python terhubung ke Flussonic dan polling data status kamera: apakah mereka berfungsi atau tidak, apakah ada peristiwa baru. <br><br>  Di sisi lain, klien terhubung, dan melalui soket web kami mengirim data ini ke browser.  Kami ingin mentransfer data klien secara real time: kamera dihidupkan dan dimatikan, kucing makan, tidur, merobek sofa, menekan tombol dan mengusir kucing pergi. <br><br>  Tetapi, misalnya, beberapa jenis masalah terjadi: database tidak menanggapi permintaan, semua kode jatuh, ada dua soket terbuka.  Kami mulai memuat ulang, melakukan sesuatu, lagi-lagi masalah ini - ada dua soket.  Kesalahan DB diproses secara tidak benar dan dua koneksi terbuka terhenti.  Seiring waktu, ini menyebabkan kebocoran soket. <br><br><h3>  Variabel Global yang Terlupakan </h3><br>  Membuat dikte global untuk daftar browser yang terhubung melalui soket web.  Seseorang masuk ke situs, kami membuka soket web untuknya.  Lalu kami menempatkan soket web dengan pengenalnya dalam semacam dikt global, dan ternyata beberapa jenis kesalahan terjadi. <br><br>  Sebagai contoh, mereka merekam tautan koneksi dict untuk mengirim data.  <strong>Pengecualian berhasil, lupa menghapus tautan dan data digantung</strong> .  Jadi setelah beberapa waktu, 64 GB mulai terlewatkan, dan saya ingin menggandakan memori di server.  Ini bukan solusi, karena data akan bocor. <br><blockquote>  Kami selalu melakukan kesalahan - kami adalah orang-orang dan kami tidak dapat melacak semuanya. </blockquote>  Pertanyaannya adalah bahwa beberapa kesalahan terjadi, bahkan kesalahan yang tidak kami harapkan. <br><br><h2>  Wisata sejarah </h2><br>  Untuk sampai ke topik utama, mari selami cerita ini.  Semua yang kita bicarakan tentang Python, Go, dan Erlang tentang sekarang, orang lain telah melakukan sejauh ini sekitar 30 tahun yang lalu.  Kita dengan Python berjalan jauh dan mengisi benjolan yang telah berlalu puluhan tahun yang lalu.  Jalan itu berulang dengan cara yang menakjubkan. <br><br><h3>  Dos </h3><br>  Pertama, mari kita beralih ke DOS, yang terdekat.  Sebelum dia ada hal-hal yang sangat berbeda dan tidak semua orang hidup yang mengingat komputer sebelum DOS. <br><br>  <strong>Program DOS menempati komputer (hampir) secara eksklusif</strong> .  Saat game, misalnya, sedang berjalan, tidak ada lagi yang dieksekusi.  Anda tidak akan pergi di Internet - itu belum ada di sana, dan Anda bahkan tidak akan sampai ke mana pun.  Itu menyedihkan, tetapi ingatannya hangat, karena dikaitkan dengan masa muda. <br><br><h3>  Multitasking kooperatif </h3><br>  Karena sangat menyakitkan dengan DOS, tantangan baru muncul, komputer menjadi lebih kuat.  <strong>Beberapa dekade yang lalu, mereka mengembangkan konsep multitasking kooperatif</strong> , bahkan sebelum Windows 3.11. <br><br>  <strong>Data dipisahkan oleh proses, dan setiap proses dilakukan secara terpisah:</strong> mereka entah bagaimana dilindungi satu sama lain.  Kode yang salah dalam satu proses tidak akan dapat merusak kode di browser (maka browser pertama sudah muncul). <br><br>  Pertanyaan selanjutnya adalah: bagaimana waktu komputasi akan didistribusikan antara proses yang berbeda?  Maka bukan karena tidak ada lebih dari satu inti, sistem prosesor ganda jarang terjadi.  Skemanya adalah ini: ketika satu proses pergi, misalnya, ke disk untuk data, proses kedua menerima kontrol dari OS.  Yang pertama akan bisa mendapatkan kontrol ketika yang kedua sendiri secara sukarela memberi.  Saya sangat menyederhanakan situasi, tetapi <strong>prosesnya entah bagaimana secara sukarela diizinkan untuk menghapusnya dari prosesor</strong> . <br><br><h3>  Preemptive Multitasking </h3><br>  Multitasking kooperatif menyebabkan masalah berikut: proses bisa saja hang karena ditulis dengan buruk.  <strong>Jika prosesor membutuhkan waktu lama untuk diproses, prosesor akan memblokir sisanya</strong> .  Dalam hal ini, komputer macet, dan tidak ada yang bisa dilakukan dengan itu, misalnya, mengganti jendela. <br><br>  Menanggapi masalah ini, multitasking preemptive diciptakan.  OS sekarang drive itu sendiri sulit: menghapus proses dari eksekusi, benar-benar memisahkan data mereka, melindungi memori proses dari satu sama lain dan memberi semua orang sejumlah waktu komputasi.  <strong>OS mengalokasikan interval waktu yang sama untuk setiap proses</strong> . <br><br>  Masalah penjadwalan waktu masih terbuka.  Saat ini, pengembang OS masih menghasilkan apa yang benar, dalam urutan apa, kepada siapa dan berapa banyak waktu untuk manajemen.  Hari ini kita melihat perkembangan ide-ide ini. <br><br><h3>  Streaming </h3><br>  Tetapi ini tidak cukup.  Proses perlu bertukar data: melalui jaringan itu mahal, entah bagaimana masih rumit.  Oleh karena itu, <strong>konsep aliran</strong> diciptakan. <br><blockquote>  Thread adalah proses ringan yang berbagi memori bersama. <br></blockquote>  Streaming dibuat dengan harapan bahwa semuanya akan mudah, sederhana, dan menyenangkan.  Sekarang <strong>pemrograman multi-threaded dianggap antipattern</strong> .  Jika logika bisnis ditulis dalam utas, kode ini kemungkinan besar harus dibuang, karena mungkin ada kesalahan di dalamnya.  Jika menurut Anda tidak ada kesalahan, berarti Anda belum menemukannya. <br><br>  Pemrograman multithreaded adalah hal yang sangat kompleks.  Ada beberapa orang yang benar-benar mengabdikan diri pada kemampuan untuk menulis di utas dan mereka mendapatkan sesuatu yang benar-benar berfungsi. <br><br>  Sementara itu, <strong>komputer multi-core</strong> muncul.  Mereka membawa hal-hal buruk bersama mereka.  Butuh pendekatan yang sama sekali berbeda untuk data, pertanyaan muncul dengan lokalitas data, sekarang Anda perlu memahami dari kernel mana Anda pergi ke data mana. <br><br>  Satu inti perlu meletakkan data di sini, yang lain di sana, dan dalam hal apapun tidak membingungkan hal ini, karena cluster sebenarnya muncul di dalam komputer.  Di dalam komputer modern, ada sebuah cluster ketika bagian dari memori disolder ke satu inti dan yang lainnya ke yang lain.  Waktu transit antara data ini dapat bervariasi berdasarkan pesanan besarnya. <br><br><h2>  Contoh python </h2><br>  Pertimbangkan contoh sederhana "Layanan untuk membantu pelanggan."  Dia memilih harga terbaik untuk barang-barang di beberapa platform: kami berkendara atas nama barang dan mencari lantai perdagangan dengan harga minimum. <br><br>  Ini adalah kode dalam Django lama, Python 2. Hari ini tidak terlalu populer, hanya sedikit orang yang memulai proyek. <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  Permintaan datang, kami pergi ke satu backend, lalu ke yang lain.  Di tempat-tempat di mana <code>http_fetch_price</code> , utas diblokir.  Pada saat ini, seluruh pekerja memulai perjalanan ke Yandex.Market, lalu ke eBay, lalu sebelum batas waktu di Taobao, dan pada akhirnya memberikan jawaban.  <strong>Selama ini seluruh pekerja berdiri</strong> . <br><br>  Sangat sulit untuk mensurvei beberapa backend pada saat yang bersamaan.  Ini adalah situasi yang buruk: memori dikonsumsi, peluncuran sejumlah besar pekerja dan pemantauan seluruh layanan diperlukan.  Penting untuk melihat seberapa sering permintaan seperti itu, apakah Anda masih perlu menjalankan pekerja atau ada lagi yang ekstra.  Ini adalah masalah yang saya bicarakan.  <strong>Penting untuk menginterogasi beberapa backend pada gilirannya</strong> . <br><br>  Apa yang kita lihat dengan Python?  <strong>Satu proses per tugas,</strong> dengan Python masih belum ada multicore.  Situasinya jelas: dalam bahasa-bahasa di kelas ini sulit untuk membuat multicore sederhana yang aman, karena itu <strong>akan mematikan kinerja</strong> . <br><br>  Jika Anda pergi ke dict dari utas yang berbeda, maka akses ke data dapat ditulis seperti ini: merekatkan dua instance Python dalam memori sehingga mereka mencari-cari data - mereka cukup memecahnya.  Misalnya, untuk beralih ke dikt dan tidak merusak apa pun, Anda harus meletakkan mutex di depannya.  Jika ada mutex sebelum setiap diktekan, maka sistem akan melambat sekitar 1000 kali - itu hanya akan merepotkan.  Sulit untuk menyeretnya ke multicore. <br><br>  Kami <strong>hanya</strong> memiliki <strong>satu utas eksekusi</strong> dan <strong>hanya proses yang dapat menskala</strong> .  Bahkan, kami menciptakan kembali DOS di dalam proses - bahasa scripting 2010.  Di dalam proses ada sesuatu yang menyerupai DOS: sementara kita melakukan sesuatu, semua proses lain tidak berfungsi.  Tidak ada yang menyukai pembengkakan biaya besar dan respons yang lambat. <br><br>  <b>Socket reaktor</b> muncul di Python beberapa waktu lalu, meskipun konsepnya sendiri sudah lahir sejak lama.  Sekarang Anda bisa mengharapkan kesiapan beberapa soket sekaligus. <br><br>  Pada awalnya, reaktor menjadi permintaan di server seperti nginx.  Termasuk karena penggunaan yang benar dari teknologi ini, telah menjadi populer.  Kemudian konsepnya dirayapi ke dalam bahasa scripting seperti Python dan Ruby. <br><blockquote>  Ide reaktor adalah bahwa kami pindah ke pemrograman berorientasi peristiwa. </blockquote><br><h2>  Pemrograman Berorientasi Acara </h2><br>  Satu konteks eksekusi menghasilkan permintaan.  Sambil menunggu jawaban, konteks yang berbeda sedang dieksekusi.  Patut dicatat bahwa kami hampir melewati tahap evolusi yang sama dengan transisi dari DOS ke Windows 3.11.  Hanya orang yang melakukan ini 20 tahun sebelumnya, dan dalam Python dan Ruby itu muncul 10 tahun yang lalu. <br><br><h3>  Bengkok </h3><br>  Ini adalah kerangka kerja yang digerakkan oleh peristiwa.  Itu muncul pada tahun 2002 dan ditulis dalam Python.  Saya mengambil contoh di atas dan menulis ulang di Twisted. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  Mungkin ada kesalahan, ketidakakuratan, dan penanganan kesalahan yang terkenal tidak cukup.  Tetapi skema perkiraannya adalah ini: kami tidak membuat permintaan, tetapi meminta untuk mengajukan permintaan ini beberapa waktu kemudian, ketika ada waktu.  Sejalan dengan <code>defer.DeferredList</code> kami ingin mengumpulkan tanggapan dari beberapa pertanyaan. <br><br>  Padahal, kodenya terdiri dari dua bagian.  Pada bagian pertama, apa yang terjadi sebelum permintaan, dan di bagian kedua, apa yang terjadi setelahnya. <br><blockquote>  Seluruh sejarah pemrograman berorientasi peristiwa jenuh dengan rasa sakit karena melanggar kode linear pada "sebelum permintaan" dan "setelah permintaan". </blockquote>  Ini menyakitkan karena potongan-potongan kode dicampur: baris terakhir masih dieksekusi dalam permintaan asli, dan fungsi <code>reply</code> akan dipanggil setelah. <br><br>  Tidak mudah untuk mengingatnya tepat karena kita memecahkan kode linier, tetapi itu harus dilakukan.  Tanpa merinci, kode yang telah ditulis ulang dari Django ke Twisted <strong>akan menghasilkan akselerasi semu yang benar-benar luar biasa</strong> . <br><br><h3>  Gagasan memutar </h3><blockquote>  Objek dapat diaktifkan ketika soket sudah siap. </blockquote>  Kami mengambil objek tempat kami mengumpulkan data yang diperlukan dari konteks dan mengikat aktivasi mereka ke soket.  Ketersediaan soket sekarang menjadi salah satu kontrol paling penting untuk keseluruhan sistem.  Objek akan menjadi konteks kita. <br><br>  Tetapi pada saat yang sama, bahasa tersebut masih memisahkan konsep konteks eksekusi yang menjadi pengecualian.  <strong>Konteks eksekusi hidup terpisah dari objek dan terhubung secara longgar dengan mereka</strong> .  Di sini masalah muncul dengan fakta bahwa kami mencoba untuk mengumpulkan data di dalam objek: tidak ada jalan tanpa mereka, tetapi bahasa tidak mendukungnya. <br><br>  Semua ini mengarah ke neraka panggilan balik klasik.  Untuk apa, misalnya, mereka mencintai Node.js - hingga saat ini, tidak ada metode lain sama sekali, tetapi masih muncul dengan Python.  Masalahnya adalah bahwa ada <strong>pemutusan kode pada titik-titik IO eksternal</strong> yang mengarah ke panggilan balik. <br><br>  Ada banyak pertanyaan.  Apakah mungkin untuk "merekatkan" tepi celah dalam kode?  Apakah mungkin untuk kembali ke kode manusia normal?  Apa yang harus dilakukan jika objek logis berfungsi dengan dua soket dan salah satunya ditutup?  Bagaimana tidak lupa untuk menutup yang kedua?  Apakah mungkin entah bagaimana menggunakan semua core? <br><br><h3>  Async io </h3><br>  Jawaban yang bagus untuk pertanyaan-pertanyaan ini adalah Async IO.  Ini adalah langkah maju yang curam, meskipun tidak mudah.  Async IO adalah hal yang rumit, di bawah kapnya ada banyak nuansa yang menyakitkan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  Kesenjangan kode disembunyikan di bawah sintaksis <code>async/await</code> .  Kami mengambil semua yang sebelumnya, tetapi tidak pergi ke jaringan dalam kode ini.  Kami menghapus <code>Callback(reply)</code> , yang ada dalam contoh sebelumnya, dan menyembunyikannya di belakang <code>await</code> - tempat kode akan dipotong dengan gunting.  Ini akan dibagi menjadi dua bagian: bagian panggilan dan bagian panggilan balik, yang memproses hasilnya. <br><br>  Ini adalah <strong>gula sintaksis yang hebat</strong> .  Ada beberapa metode untuk menempelkan banyak harapan menjadi satu.  Ini keren, tetapi ada nuansa: <strong>semuanya bisa dipecahkan oleh soket "klasik"</strong> .  Dalam Python, masih ada sejumlah besar perpustakaan yang pergi ke soket secara serempak, membuat <code>timer library</code> dan merusak segalanya untuk Anda.  Cara debug ini, saya tidak tahu. <br><br>  Tetapi <strong>asyncio tidak membantu dengan kebocoran dan multicore</strong> .  Karena itu, tidak ada perubahan mendasar, walaupun sudah menjadi lebih baik. <br><br>  Kami masih memiliki semua masalah yang kami bicarakan di awal: <br><br><ul><li>  mudah bocor dengan soket; </li><li>  tautan yang mudah ditinggalkan dalam variabel global; </li><li>  penanganan kesalahan yang sangat melelahkan; </li><li>  masih sulit untuk melakukan multi-core. </li></ul><br><h3>  Apa yang harus dilakukan </h3><br>  Apakah ini semua akan berkembang, saya tidak tahu, tetapi saya akan menunjukkan implementasinya dalam bahasa dan platform lain. <br><br>  <strong>Konteks eksekusi yang terisolasi.</strong>  Dalam konteks eksekusi, hasil diakumulasikan, soket dipegang: objek logis tempat kami biasanya menyimpan semua data tentang panggilan balik dan soket.  Satu konsep: ambil konteks eksekusi, tempelkan ke untaian eksekusi, dan pisahkan sepenuhnya dari satu sama lain. <br><br>  <strong>Paradigma pergeseran objek.</strong>  Mari kita hubungkan konteks ke utas eksekusi.  Ada analog, ini bukan sesuatu yang segar.  Jika seseorang mencoba mengedit kode sumber Apache dan menulis modul kepada mereka, maka dia tahu bahwa ada kumpulan Apache.  <strong>Tidak ada tautan yang diizinkan di</strong> antara kolam Apache.  Data dari satu kumpulan Apache - kumpulan yang terkait dengan permintaan, terletak di dalamnya, dan Anda tidak bisa mendapatkan apa pun darinya. <br><br>  Secara teoritis, itu mungkin, tetapi jika Anda melakukannya, seseorang akan memarahi, atau mereka tidak akan menerima tambalan, atau mereka akan mengalami debugging yang panjang dan menyakitkan pada produksi.  Setelah itu, tidak ada yang akan melakukan ini dan membiarkan orang lain melakukan hal seperti itu.  Sangat tidak mungkin untuk merujuk data antar konteks lagi, isolasi penuh diperlukan. <br><br>  Bagaimana cara bertukar kegiatan?  Yang dibutuhkan bukanlah monad-monad kecil, yang tertutup di dalam diri mereka sendiri dan tidak saling berkomunikasi.  Kami membutuhkan mereka untuk berkomunikasi.  Salah satu pendekatan adalah olahpesan.  Ini kira-kira jalur yang diambil Windows saat bertukar pesan antar proses.  Dalam OS normal, Anda tidak dapat memberikan tautan ke memori proses lain, tetapi Anda dapat memberi sinyal melalui jaringan, seperti pada UNIX, atau melalui pesan, seperti pada Windows. <br><br>  <strong>Semua sumber daya dalam proses dan konteks menjadi utas eksekusi</strong> .  Kami direkatkan bersama: <br><br><ul><li>  runtime data di mesin virtual di mana pengecualian terjadi; </li><li>  utas eksekusi, seperti apa yang sedang dieksekusi pada prosesor; </li><li>  Objek di mana semua data dikumpulkan secara logis. </li></ul><br>  Selamat - kami menemukan UNIX di dalam bahasa pemrograman!  Ide ini ditemukan sekitar tahun 1969.  Sejauh ini, ia belum menggunakan Python, tetapi Python kemungkinan akan mencapai ini.  Dan mungkin dia tidak akan datang - saya tidak tahu. <br><br><h3>  Apa yang diberikannya </h3><br>  Pertama-tama, <strong>kontrol otomatis atas sumber daya</strong> .  Di Moscow Python Conf ++ 2019 mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa Anda dapat menulis sebuah program di Go dan memproses semua kesalahan.  Program ini akan berdiri seperti sarung tangan dan bekerja selama berbulan-bulan.  Ini benar, tetapi kami tidak menangani semua kesalahan. <br><br>  Kami adalah orang-orang yang hidup, kami selalu memiliki tenggat waktu, keinginan untuk melakukan sesuatu yang bermanfaat, dan tidak menangani kesalahan ke-535 untuk hari ini.  Kode yang penuh dengan penanganan kesalahan tidak pernah menyebabkan perasaan hangat pada siapa pun. <br><br>  Oleh karena itu, kita semua menulis "jalan bahagia", dan kemudian kita akan mencari tahu tentang produksi.  Jujur saja: hanya ketika Anda perlu memproses sesuatu, maka kami mulai memproses.  Pemrograman defensif sedikit berbeda, dan ini bukan pengembangan komersial. <br><br>  Karena itu, <strong>ketika kami memiliki kontrol otomatis untuk kesalahan - ini baik-baik saja</strong> .  Tetapi sistem operasi muncul dengan itu 50 tahun yang lalu: jika beberapa proses mati, maka semua yang dibuka akan secara otomatis ditutup.  Hari ini tidak ada yang perlu menulis kode yang akan membersihkan file di balik proses yang terbunuh.  Ini belum ada selama 50 tahun dalam OS apa pun, tetapi dengan Python Anda masih harus mengikuti ini dengan hati-hati dan hati-hati dengan tangan Anda.  Ini aneh. <br><br>  <strong>Anda dapat mengambil komputasi berat ke dalam konteks yang berbeda</strong> , tetapi itu sudah bisa pergi ke inti lain.  Kami berbagi data, kami tidak lagi membutuhkan mutex.  Anda dapat mengirim data dalam konteks yang berbeda, katakan: "Anda akan melakukannya di suatu tempat, dan beri tahu saya bahwa Anda telah selesai dan melakukan sesuatu." <br><br>  <strong>Implementasi asyncio tanpa kata "async / await"</strong> .  Selanjutnya sedikit bantuan dari mesin virtual, dari runtime.  Inilah yang kami bicarakan dengan <code>async/await</code> : Anda juga dapat mengonversi ke pesan, menghapus <code>async/await</code> dan mendapatkannya di tingkat mesin virtual. <br><br><h2>  Proses Erlang </h2><br>  Erlang ditemukan 30 tahun lalu.  Orang-orang berjanggut, yang tidak terlalu berjanggut saat itu, memandang UNIX dan memindahkan semua konsep ke bahasa pemrograman.  Mereka memutuskan bahwa sekarang mereka akan memiliki benda mereka sendiri untuk tidur di malam hari dan dengan tenang pergi memancing tanpa komputer.  Lalu belum ada laptop, tetapi orang-orang berjanggut sudah tahu bahwa ini harus dipikirkan terlebih dahulu. <br><br>  <strong>Kami mendapat Erlang (Elixir) - konteks aktif yang mengeksekusi sendiri</strong> .  Selanjutnya contoh saya di Erlang.  Pada Elixir, tampilannya hampir sama, dengan beberapa variasi. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  Kami meluncurkan beberapa penjemput - ini adalah beberapa konteks baru terpisah yang kami tunggu-tunggu.  Mereka menunggu, mengumpulkan data dan mengembalikan hasilnya sebagai harga minimum.  Semua ini mirip dengan <code>async/await</code> , tetapi tanpa kata-kata "async / tunggu". <br><br><h3>  Fitur dari Elixir </h3><br>  Elixir terletak di pangkalan Erlang, dan semua konsep bahasa diam-diam dipindahkan ke Elixir.  Apa saja fitur-fiturnya? <br><br>  <strong>Larangan tautan lintas prosesor.</strong>  Maksud saya adalah proses ringan di dalam konteks mesin virtual.  Sederhana, jika porting ke Python, tautan data di dalam objek lain dilarang di Erlang.  Anda dapat memiliki tautan ke seluruh objek sebagai kotak tertutup, tetapi Anda tidak dapat merujuk data di dalamnya.  Anda bahkan tidak bisa secara sintaksis mendapatkan pointer ke data yang ada di dalam objek lain.  Anda hanya bisa tahu tentang objek itu sendiri. <br><br>  <strong>Tidak ada mutex di dalam proses (objek).</strong>  Ini penting - secara pribadi, saya tidak pernah ingin dalam hidup saya bersinggungan dengan sejarah men-debug penerbangan multi-thread ke produksi.  Saya tidak berharap ini kepada siapa pun. <br><br>  <strong>Proses dapat bergerak di sekitar inti, aman.</strong>  Kita tidak perlu lagi memotong, seperti di Jawa, sekelompok <code>pointer</code> lain dan menulis ulang ketika memindahkan data dari satu tempat ke tempat lain: kita tidak memiliki data umum dan tautan internal.  Sebagai contoh, dari mana masalah hip sparseness berasal?  Karena kenyataan bahwa seseorang merujuk pada data ini. <br><br>  Jika kita mentransfer data di dalam tumpukan ke lokasi lain untuk pemadatan, kita harus melalui seluruh sistem.  Ia dapat menempati puluhan gigabyte dan memperbarui semua petunjuk - ini gila. <br><br>  <strong>Keamanan utas penuh</strong> , karena semua komunikasi melewati pesan.  Atas penyerahan semua ini, kami mengalami <strong>proses crowding-out shedding</strong> .  Dia mendapatkannya dengan mudah dan murah. <br><br>  <strong>Pesan sebagai dasar komunikasi.</strong>  Objek di dalam, panggilan fungsi biasa, dan di antara objek pesan.  Kedatangan data dari jaringan adalah pesan, respons objek lain adalah pesan, sesuatu di luar juga pesan dalam satu antrian yang masuk.  Ini bukan pada UNIX karena belum berakar. <br><br>  <strong>Metode panggilan.</strong>  Kami memiliki objek yang kami sebut proses.  Metode pada proses dipanggil melalui pesan. <br><br>  <strong>Metode panggilan juga mengirim pesan.</strong>  Sangat menyenangkan bahwa sekarang dapat dilakukan dengan batas waktu.  Jika sesuatu menjawab dengan lambat, kami memanggil metode pada objek lain.  Tetapi pada saat yang sama kami mengatakan bahwa kami siap untuk menunggu tidak lebih dari 60 detik, karena saya memiliki klien dengan batas waktu 70 detik.  Saya harus pergi dan memberitahunya "503" - datang besok, sekarang mereka tidak menunggu Anda. <br><br>  Selain itu, <strong>jawaban untuk panggilan tersebut dapat ditunda</strong> .  Di dalam objek, Anda dapat menerima permintaan untuk memanggil metode, dan berkata: "Ya, ya, saya akan menurunkan Anda sekarang, kembali dalam setengah jam, saya akan menjawab Anda."  Anda tidak bisa berbicara, tetapi diam-diam menyisihkan.  Kami terkadang menggunakannya. <br><br><h3>  Bagaimana cara bekerja dengan jaringan? </h3><br>  Anda dapat menulis kode linier, panggilan balik, atau dengan gaya <code>asyncio.gather</code> .  Contoh bagaimana ini akan terlihat. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  Dalam fungsi <code>wait4</code> dari contoh sebelumnya, kita <code>wait4</code> pada daftar orang-orang dari siapa kita masih menunggu jawaban.  Jika menggunakan metode <code>receive</code> kami mendapatkan pesan dari proses itu, kami menulisnya ke daftar.  Jika daftar sudah selesai, kami kembalikan semua yang tadinya dan mengakumulasi daftar.  Kami meminta tiga objek sekaligus untuk mengarahkan kami data.  Jika mereka tidak berhasil bersama dalam 60 detik, dan setidaknya satu dari mereka tidak menjawab OK, kita akan memiliki daftar kosong.  Tetapi penting bahwa kami membuat batas waktu umum untuk permintaan segera ke sejumlah objek. <br><br>  Seseorang mungkin berkata, "Pikirkan, libcurl memiliki hal yang sama."  Tapi di sini penting bahwa di sisi lain tidak hanya ada perjalanan HTTP, tetapi juga perjalanan DB, serta beberapa perhitungan, misalnya, menghitung beberapa jenis angka optimal untuk klien. <br><br><h3>  Menangani kesalahan </h3><br>  <strong>Kesalahan telah berpindah dari aliran ke objek, yang sekarang satu dan sama</strong> .  Sekarang kesalahan itu sendiri menjadi melekat bukan pada utas, tetapi pada objek di mana ia dieksekusi. <br><br>  Ini jauh lebih logis.  Biasanya, ketika kita menggambar semua jenis kotak dan lingkaran kecil di papan dengan harapan mereka akan hidup kembali dan mulai membawa kita hasil dan uang, kita biasanya menggambar objek, bukan aliran di mana objek ini akan dieksekusi.  Misalnya, pada pengiriman kami dapat menerima <strong>pesan</strong> otomatis <strong>tentang kematian objek lain</strong> . <br><br><h3>  Introspeksi atau debugging dalam produksi </h3><br>  Apa yang bisa lebih baik daripada pergi ke prod dan mendebit, terutama jika kesalahan hanya terjadi di bawah beban selama jam sibuk.  Pada jam sibuk kami katakan: <br><br>  <em>- Ayo, saya akan mulai lagi sekarang!</em> <br>  <em>- Pergi keluar pintu dan ada restart pada orang lain!</em> <br><br>  Di sini kita bisa masuk ke dalam sistem kehidupan yang sedang berjalan sekarang dan tidak dipersiapkan secara khusus untuk ini.  Untuk melakukan ini, Anda tidak perlu me-restart dengan profiler, dengan debugger, buat kembali. <br><br>  <strong>Tanpa kehilangan kinerja dalam sistem produksi langsung,</strong> kita dapat melihat daftar proses: apa yang ada di dalamnya, cara kerjanya, buang, periksa apa yang terjadi pada mereka.  Semua ini gratis di luar kotak. <br><br><h3>  Bonus </h3><br>  <strong>Kode ini sangat andal.</strong>  Sebagai contoh, Python memiliki kerapuhan dengan yang <code>old vs async</code> , dan itu akan tetap selama lima tahun, tidak kurang.  Mempertimbangkan kecepatan implementasi Python 3, Anda seharusnya tidak berharap bahwa itu akan cepat. <br><br>  <strong>Membaca dan melacak pesan lebih mudah daripada men-debug panggilan balik</strong> .  Ini penting.  Tampaknya jika kita masih memiliki panggilan balik untuk memproses pesan yang dapat kita lihat, lalu apa yang lebih baik?  Dengan fakta bahwa pesan adalah sepotong data dalam memori.  Anda dapat melihatnya dengan mata dan memahami apa yang telah terjadi di sini.  Itu dapat ditambahkan ke pelacak, dapatkan daftar pesan dalam file teks.  Ini lebih nyaman daripada panggilan balik. <br><br>  <strong>Multi-core yang cantik</strong> , manajemen memori, dan <strong>introspeksi di dalam sistem</strong> produksi <strong>langsung</strong> . <br><br><h3>  Masalahnya </h3><br>  Secara alami, Erlang juga memiliki masalah. <br><br>  <strong>Kehilangan kinerja maksimum</strong> karena kita tidak bisa lagi merujuk ke data dalam proses atau objek lain.  Kita harus memindahkan mereka, tetapi ini tidak gratis. <br><br>  <strong>Overhead menyalin data antar proses.</strong>  Kita dapat menulis sebuah program dalam C yang akan berjalan pada semua 80 core dan memproses satu array data, dan kita akan berasumsi bahwa ia melakukannya dengan benar dan benar.  Di Erlang, Anda tidak bisa melakukan ini: Anda perlu memotong data dengan hati-hati, mendistribusikannya ke banyak proses, melacak semuanya.  Komunikasi ini membutuhkan sumber daya - siklus prosesor. <br><br>  <strong>Seberapa cepat atau lambat itu?</strong>  Kami telah menulis kode Erlang selama 10 tahun.  Satu-satunya pesaing yang bertahan 10 tahun ini ditulis di Jawa.  Bersamanya, kami memiliki paritas kinerja yang hampir lengkap: seseorang mengatakan bahwa kami lebih buruk, seseorang yang seperti itu.  Tetapi mereka memiliki Java dengan semua masalahnya, dimulai dengan JIT. <br><br>  Kami menulis sebuah program yang melayani puluhan ribu soket dan memompa puluhan GB data melalui itu sendiri.  Tiba-tiba ternyata dalam hal ini <strong>kebenaran dari algoritma dan kemampuan untuk debug semua ini dalam produksi lebih penting daripada roti Java potensial</strong> .  Miliaran dolar telah diinvestasikan di dalamnya, tetapi ini tidak memberikan manfaat ajaib pada Java JIT. <br><br>  Tetapi jika kita ingin mengukur tolok ukur bodoh dan tidak berarti, seperti "menghitung angka-angka Fibonacci", maka di sini Erlang mungkin akan lebih buruk daripada Python atau sebanding. <br><br>  <strong>Overhead alokasi pesan.</strong>  Terkadang sakit.  Sebagai contoh, kami memiliki beberapa bagian dalam kode C, dan di tempat-tempat ini tidak berfungsi sama sekali dengan Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     —   ,   .   <strong> ,   ,    </strong> . <br><br><h2>      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476112/">https://habr.com/ru/post/id476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476102/index.html">Ketik aman bekerja dengan array PHP</a></li>
<li><a href="../id476104/index.html">Jangan gunakan MTProxy gratis dan jenis proxy gratis lainnya ...</a></li>
<li><a href="../id476106/index.html">"Cryptosystems Protocols": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../id476108/index.html">Otak yang bisa berubah</a></li>
<li><a href="../id476110/index.html">Mengapa TI membutuhkan merek pribadi</a></li>
<li><a href="../id476114/index.html">Bagaimana jika tanpa Python? Julia untuk pembelajaran mesin dan umumnya</a></li>
<li><a href="../id476118/index.html">Desain antarmuka untuk game, menggambar cincin Havel dari Dark Souls 3</a></li>
<li><a href="../id476122/index.html">“Dengarkan” kosmos: dari materi gelap hingga komet Churyumov - Gerasimenko</a></li>
<li><a href="../id476126/index.html">Cara menguji kinerja server: pemilihan beberapa tolok ukur sumber terbuka</a></li>
<li><a href="../id476128/index.html">Ivan Osipov dan Yuri Artamonov tentang Kotlin dan plugin untuk IntelliJ IDEA di pertemuan jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>