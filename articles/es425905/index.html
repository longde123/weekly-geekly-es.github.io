<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚂 🙁 🥒 Cómo escribir código de ensamblador con instrucciones superpuestas (otra técnica para ofuscar el código de bytes) 😥 🚴🏽 💃🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Presentamos a su atención la técnica de crear programas ensambladores con instrucciones superpuestas, para proteger el bytecode compilado del desmonta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo escribir código de ensamblador con instrucciones superpuestas (otra técnica para ofuscar el código de bytes)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425905/"><p>  Presentamos a su atención la técnica de crear programas ensambladores con instrucciones superpuestas, para proteger el bytecode compilado del desmontaje.  Esta técnica es capaz de soportar análisis de bytecode estáticos y dinámicos.  La idea es seleccionar una secuencia de bytes que, cuando se desmonta de dos desplazamientos diferentes, da como resultado dos cadenas de instrucciones diferentes, es decir, dos formas diferentes de ejecutar el programa.  Para hacer esto, tomamos instrucciones de ensamblador multibyte y ocultamos el código protegido en las partes variables del bytecode de estas instrucciones.  Para engañar al desensamblador colocándolo en un camino falso (de acuerdo con una cadena de instrucciones de enmascaramiento) y para proteger de sus ojos una cadena oculta de instrucciones. </p><br><p><img src="https://habrastorage.org/webt/iu/f0/nj/iuf0njjfado7wk-bt05rlxz5l2w.png"></p><a name="habracut"></a><br><h2 id="tri-neobhodimyh-usloviya-dlya-sozdaniya-effektivnogo-perekrytiya">  Tres requisitos previos para crear una "superposición" efectiva </h2><br><p>  Para engañar al desensamblador, el código superpuesto debe cumplir las siguientes tres condiciones: 1) Las instrucciones de la cadena de enmascaramiento y la cadena oculta siempre deben cruzarse entre sí, es decir.  no deben alinearse entre sí (sus primeros y últimos bytes no deben coincidir).  De lo contrario, parte del código oculto será visible en la cadena de enmascaramiento.  2) Ambas cadenas deben consistir en instrucciones de montaje plausibles.  De lo contrario, el enmascaramiento ya se detectará en la etapa de análisis estático (habiendo tropezado con un código inadecuado para la ejecución, el desensamblador corregirá el puntero del comando y expondrá el enmascaramiento).  3) Todas las instrucciones de ambas cadenas deben ser no solo plausibles, sino también ejecutadas correctamente (para evitar que esto suceda, el programa se bloqueó cuando intenta ejecutarlas).  De lo contrario, durante el análisis dinámico, las fallas atraerán la atención del reverso y se revelará la máscara. </p><br><h2 id="opisanie-tehniki-perekrytiya-assemblernyh-instrukciy">  Descripción de la técnica de instrucciones de ensamblador "superpuestas" </h2><br><p>  Para que el proceso de creación de código superpuesto sea lo más flexible posible, es necesario seleccionar solo las instrucciones multibyte, para las cuales la mayor cantidad posible de bytes puede tomar cualquier valor.  Estas instrucciones multibyte constituirán una cadena de instrucciones de enmascaramiento. </p><br><p>  En la búsqueda del objetivo de crear código superpuesto que satisfaga las tres condiciones anteriores, consideramos cada instrucción de enmascaramiento como una secuencia de bytes de la forma: XX YY ZZ. </p><br><p>  Aquí XX es el prefijo de instrucción (código de instrucción y otros bytes estáticos, que no se pueden cambiar). </p><br><p>  YY son bytes que pueden cambiarse arbitrariamente (como regla, estos bytes almacenan el valor numérico directo pasado a la instrucción; o la dirección del operando almacenado en la memoria).  Debe haber tantos bytes YY como sea posible para que entren más instrucciones ocultas en ellos. </p><br><p>  ZZ: estos también son bytes que se pueden cambiar arbitrariamente, con la única diferencia de que la combinación de bytes ZZ con los bytes XX posteriores (ZZ XX) debe formar una instrucción válida que satisfaga las tres condiciones formuladas al comienzo del artículo.  Idealmente, ZZ debería ocupar solo un byte, de modo que en YY (esta es esencialmente la parte más importante, nuestro código oculto se coloca aquí) debería haber tantos bytes como sea posible.  La última instrucción oculta debe terminar en ZZ, creando un punto de convergencia para las dos cadenas de ejecución. </p><br><h2 id="skleivayuschie-instrukcii">  Instrucciones de encolado </h2><br><p>  La combinación ZZ XX: llamaremos a las instrucciones de pegado.  Se necesita una instrucción de pegado, en primer lugar, para unir las instrucciones ocultas que se encuentran en las instrucciones de enmascaramiento adyacentes y, en segundo lugar, para cumplir la primera condición necesaria indicada al principio del artículo: las instrucciones de ambas cadenas siempre deben cruzarse entre sí (por lo tanto, la instrucción de pegado siempre ubicado en la intersección de dos instrucciones de enmascaramiento). </p><br><p>  La instrucción de pegado se ejecuta en una cadena oculta de comandos y, por lo tanto, debe seleccionarse de manera que imponga la menor cantidad posible de restricciones sobre el código oculto.  Suponga que cuando se ejecuta, se cambian los registros de propósito general y el registro EFLAGS, entonces el código oculto no podrá usar efectivamente los registros correspondientes y los comandos condicionales (por ejemplo, si la instrucción de pegado está precedida por el operador de comparación, y la instrucción de pegado misma cambia el valor del registro EFLAGS, luego la transición condicional, que se encuentra después de las instrucciones de pegado no funcionará correctamente). </p><br><p>  La descripción anterior de la técnica de superposición se ilustra en la siguiente figura.  Si la ejecución comienza con los bytes de inicio (XX), se activa una cadena de instrucciones de enmascaramiento.  Y si desde bytes YY, se activa una cadena de instrucciones ocultas. </p><br><p><img src="https://habrastorage.org/webt/a8/yq/f-/a8yqf-uukfw3fgzvlkqmmjjxiao.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-maskiruyuschih-instrukciy">  Instrucciones de ensamblador adecuadas para el papel de "instrucciones de enmascaramiento" </h2><br><p>  La más larga de las instrucciones, que a primera vista nos conviene más, es una versión de 10 bytes de MOV, donde el desplazamiento especificado por el registro y la dirección de 32 bits se transfiere como el primer operando, y el número de 32 bits como el segundo operando.  Esta instrucción contiene la mayoría de los bytes que se pueden cambiar arbitrariamente (hasta 8 piezas). </p><br><p><img src="https://habrastorage.org/webt/0k/8b/ph/0k8bphb01jec2f1t7dy1bupi_c0.png"></p><br><p>  Sin embargo, aunque esta instrucción parece plausible (en teoría, se puede ejecutar correctamente), todavía no nos conviene, porque su primer operando, como regla, indicará una dirección inaccesible y, por lo tanto, al intentar ejecutar dicho MOV, el programa colapsará  T.O.  este MOV de 10 bytes no cumple la tercera condición necesaria: todas las instrucciones de ambas cadenas deben ejecutarse correctamente. </p><br><p>  Por lo tanto, elegiremos para el papel de enmascarar instrucciones solo aquellos solicitantes que no presenten un riesgo de colapso del programa.  Esta condición reduce significativamente el rango de instrucciones adecuadas para crear código superpuesto, pero todavía hay otras adecuadas.  A continuación hay cuatro de ellos.  Cada una de estas cuatro instrucciones contiene cinco bytes, que pueden cambiarse arbitrariamente, sin el riesgo de un bloqueo del programa. </p><br><ul><li>  <strong>LEA</strong>  Esta instrucción calcula la dirección de memoria especificada por la expresión en el segundo operando y almacena el resultado en el primer operando.  Como podemos referirnos a la memoria sin acceso real a ella (y, en consecuencia, sin el riesgo de un bloqueo del programa), los últimos cinco bytes de esta instrucción pueden tomar valores arbitrarios. </li></ul><br><p><img src="https://habrastorage.org/webt/nt/j4/qt/ntj4qtax25h_ztuizjq-aokjpbu.png"></p><br><ul><li>  <strong>CMOVcc.</strong>  Esta instrucción realiza la operación MOV si se cumple la condición "cc".  Para que esta instrucción satisfaga el tercer requisito, la condición debe seleccionarse de modo que, bajo ninguna circunstancia, tenga el valor FALSO.  De lo contrario, esta instrucción puede intentar acceder a una dirección de memoria inaccesible, etc.  derribar el programa. </li></ul><br><p><img src="https://habrastorage.org/webt/np/me/fn/npmefnc43igcj9aqvw9omgyofae.png"></p><br><ul><li>  <strong>SETcc</strong>  Funciona según el mismo principio que CMOVcc: establece el byte en uno si se cumple la condición "cc".  Esta instrucción tiene el mismo problema que CMOVcc: acceder a una dirección no válida hará que el programa se bloquee.  Por lo tanto, la elección de la condición "cc" debe abordarse con mucho cuidado. </li></ul><br><p><img src="https://habrastorage.org/webt/sn/yc/xt/snycxte6lqjzorjwdqcvsppfdri.png"></p><br><ul><li>  <strong>NOP.</strong>  Los NOP pueden tener diferentes longitudes (de 2 a 15 bytes), según los operandos que se indiquen en ellos.  En este caso, no habrá riesgo de bloquear el programa (debido al acceso a una dirección de memoria no válida).  Debido a que lo único que hacen los NOP es aumentar el contador de instrucciones (no realizan ninguna operación en los operandos).  Por lo tanto, los bytes NOP en los que se especifican los operandos pueden tomar un valor arbitrario.  Para nuestros propósitos, un NOP de 9 bytes es el más adecuado. </li></ul><br><p><img src="https://habrastorage.org/webt/_i/sh/8k/_ish8ks2qosezlkfzpgzx43jk2k.png"></p><br><p>  Como referencia, aquí hay algunas otras opciones de NOP. </p><br><p><img src="https://habrastorage.org/webt/0k/iq/n7/0kiqn7dtu1yzrrmawbtw8yfwep0.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-skleivayuschih-instrukciy">  Instrucciones del ensamblador adecuadas para el papel de "instrucciones de pegado" </h2><br><p>  La lista de instrucciones adecuadas para el papel de una instrucción de pegado es única para cada instrucción de enmascaramiento específica.  A continuación se muestra una lista (generada por el algoritmo que se muestra en la siguiente figura) utilizando NOP de 9 bytes como ejemplo. </p><br><p><img src="https://habrastorage.org/webt/zh/9o/ja/zh9ojaw9sezcyr9milmugd3pihm.png"></p><br><p>  Al formar esta lista, tomamos en cuenta solo aquellas opciones en las que ZZ toma 1 byte (de lo contrario, quedará poco espacio para el código oculto).  Aquí hay una lista de instrucciones adhesivas adecuadas para un NOP de 9 bytes. </p><br><p><img src="https://habrastorage.org/webt/wm/kv/uj/wmkvujcabiyqgy-ysdg1750mp7k.png"></p><br><p>  Entre esta lista de instrucciones, no hay una que esté libre de efectos secundarios.  Cada uno de ellos cambia EFLAGS, o registros de propósito general, o ambos a la vez.  Esta lista se divide en 4 categorías, según el efecto secundario que tenga la instrucción. </p><br><p>  <strong>La primera categoría</strong> incluye instrucciones que cambian el registro EFLAGS, pero no cambian los registros de propósito general.  Las instrucciones de esta categoría se pueden usar cuando no hay saltos condicionales o cualquier instrucción en la cadena de instrucciones ocultas basadas en la evaluación de la información del registro EFLAGS.  En este caso, en este caso (para un NOP de 9 bytes) solo hay dos instrucciones: TEST y CMP. </p><br><p><img src="https://habrastorage.org/webt/vx/6k/nz/vx6knzdkeafykou6rrga4kjtjrc.png"></p><br><p>  El siguiente es un ejemplo simple de código oculto que usa TEST como una instrucción de pegado.  Este ejemplo realiza una llamada al sistema de salida, que devuelve un valor de 1 para cualquier versión de Linux. Para formar correctamente la instrucción TEST para nuestras necesidades, necesitaremos establecer el último byte del primer NOP en 0xA9.  Este byte, cuando se combina con los primeros cuatro bytes del próximo NOP (66 0F 1F 84), se convertirá en una instrucción TEST EAX, 0x841F0F66.  Las siguientes dos figuras muestran el código de ensamblador correspondiente (para la cadena de enmascaramiento y la cadena oculta).  La cadena oculta se activa cuando el control se transfiere al cuarto byte del primer NOP. </p><br><p><img src="https://habrastorage.org/webt/sv/ok/v9/svokv9pvujkp3sz1mzgcpfumlx4.png"></p><br><p><img src="https://habrastorage.org/webt/ky/bd/-b/kybd-bm02hdj6lka_rnkemfrnj8.png"></p><br><p>  <strong>La segunda categoría</strong> incluye instrucciones que cambian los valores de los registros generales o la memoria disponible (pila, por ejemplo), pero no cambian el registro EFLAGS.  Al ejecutar una instrucción PUSH o cualquier variante MOV, donde se especifica un valor inmediato como el segundo operando, el registro EFLAGS permanece sin cambios.  T.O.  las instrucciones de pegado de la segunda categoría pueden incluso ubicarse entre la instrucción de comparación (TEST, por ejemplo) y la instrucción que evalúa el registro EFLAGS.  Sin embargo, las instrucciones en esta categoría limitan el uso del registro que aparece en las instrucciones de pegado correspondientes.  Por ejemplo, si MOV EBP, 0x841F0F66 se usa como una instrucción de pegado, entonces las posibilidades de usar el registro EBP (del resto del código oculto) son significativamente limitadas. </p><br><p>  <strong>La tercera categoría</strong> incluye instrucciones que cambian el registro EFLAGS, y los registros de propósito general (o memoria) cambian.  Estas instrucciones no tienen ventajas obvias sobre las instrucciones de las dos primeras categorías.  Sin embargo, también se pueden usar, ya que no contradicen las tres condiciones formuladas al principio del artículo.  La cuarta categoría incluye instrucciones, cuya implementación no garantiza que el programa no se bloquee; existe el riesgo de acceso ilegal a la memoria.  Es extremadamente indeseable usarlos, porque  No satisfacen la tercera condición. </p><br><h2 id="assemblernye-instrukcii-kotorye-mozhno-ispolzovat-v-skrytoy-cepochke">  Instrucciones de ensamblador que se pueden usar en una cadena oculta </h2><br><p>  En nuestro caso (cuando los NOP de 9 bytes se usan como instrucciones de enmascaramiento), la longitud de cada instrucción de la cadena oculta no debe exceder los cuatro bytes (esta restricción no se aplica a las instrucciones fijas que ocupan 5 bytes).  Sin embargo, esta no es una limitación muy crítica, porque la mayoría de las instrucciones que tienen más de cuatro bytes se pueden descomponer en varias instrucciones más cortas.  El siguiente es un ejemplo de un MOV de 5 bytes que es demasiado grande para caber en una cadena oculta. </p><br><p><img src="https://habrastorage.org/webt/oo/97/yx/oo97yx0fsovio-agsdn-spiejre.png"></p><br><p>  Sin embargo, este MOV de cinco bytes se puede descomponer en tres instrucciones, cuya longitud no supera los cuatro bytes. </p><br><p><img src="https://habrastorage.org/webt/yx/zd/oc/yxzdocctpxhzvy13td7fpkqnwi0.png"></p><br><h2 id="usilenie-maskirovki-putyom-rasseivaniya-maskiruyuschih-nopov-po-vsey-programme">  Mejora del enmascaramiento mediante la dispersión de los NOP de enmascaramiento en todo el programa </h2><br><p>  Un gran número de NOP consecutivos parece, desde el punto de vista inverso, muy sospechoso.  Enfocando su interés en estos NOP sospechosos, un inversor experimentado puede llegar al fondo del código oculto en ellos.  Para evitar esta exposición, los NOP enmascarados se pueden dispersar por todo el programa. </p><br><p>  La cadena correcta de ejecución del código oculto en este caso puede ser apoyada por instrucciones de doble byte de salto incondicional.  En este caso, los dos últimos bytes de cada NOP ocuparán un JMP de 2 bytes. </p><br><p>  Este truco le permite dividir una secuencia larga de NOP en varias cortas (o incluso usar un NOP cada una).  En el último NOP de una secuencia tan corta, solo se pueden asignar 3 bytes de la carga útil (la instrucción de salto incondicional tomará el cuarto byte).  T.O.  Aquí hay una restricción adicional sobre el tamaño de las instrucciones válidas.  Sin embargo, como se mencionó anteriormente, se pueden establecer instrucciones largas en una cadena de instrucciones más cortas.  A continuación se muestra un ejemplo del mismo MOV de 5 bytes, que ya presentamos para que se ajuste al límite de 4 bytes.  Sin embargo, ahora descomponemos este MOV de tal manera que se ajuste al límite de 3 bytes. </p><br><p><img src="https://habrastorage.org/webt/lr/6g/bz/lr6gbzoo5qnjgocu3zzkoblxqsc.png"></p><br><p>  Después de descomponer todas las instrucciones largas en otras más cortas de acuerdo con el mismo principio, podemos, para enmascarar más, generalmente usar solo NOPs dispersos en todo el programa.  Las instrucciones JMP de dos bytes pueden avanzar y retroceder 127 bytes, lo que significa que dos NOP consecutivos (consecutivos, en términos de una cadena de instrucciones ocultas) deben estar dentro de 127 bytes. </p><br><p>  Este truco tiene otra ventaja significativa (además del enmascaramiento mejorado): con su ayuda, puede colocar código oculto en los NOP existentes del archivo binario compilado (es decir, insertar una carga útil en el binario después de compilarlo).  En este caso, no es necesario que estos NOP huérfanos sean de 9 bytes.  Por ejemplo, si hay varios NOP de un solo byte en una fila en el binario, entonces se pueden convertir en NOP de varios bytes, sin interrumpir la funcionalidad del programa.  A continuación se muestra un ejemplo de una técnica para dispersar NOP (este código es funcionalmente equivalente al ejemplo discutido anteriormente). </p><br><p><img src="https://habrastorage.org/webt/t6/cj/fn/t6cjfn6ctjsqubp6setuf324nui.png"></p><br><p>  Dicho código oculto, oculto en NOP dispersos por todo el programa, ya es mucho más difícil de detectar. </p><br><p>  Un lector atento debe haber notado que el primer NOP no tiene el último byte.  Sin embargo, no hay nada de qué preocuparse.  Porque este byte no reclamado está precedido por un salto incondicional.  T.O.  el control nunca será transferido a él.  Entonces todo está en orden. </p><br><p>  Aquí hay una técnica para crear código superpuesto.  Uso en salud.  Esconde tu precioso código de miradas indiscretas.  Pero simplemente adopte alguna otra instrucción, no un NOP de 9 bytes.  Porque los inversores probablemente también leerán este artículo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425905/">https://habr.com/ru/post/es425905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425893/index.html">"Flutter está comenzando a atraer a la comunidad, pero aún no a los clientes": Entrevista con Paulina Szklarska</a></li>
<li><a href="../es425897/index.html">Características del uso de la biblioteca RxJs en un sistema bancario en línea</a></li>
<li><a href="../es425899/index.html">Hormiguero o fortaleza? Estoy construyendo una casa por el precio de un apartamento. 1 parte</a></li>
<li><a href="../es425901/index.html">Estación meteorológica en Arduino de la A a la Z. Parte 1</a></li>
<li><a href="../es425903/index.html">Las vacaciones nos llegan: SCRF duplicó la banda ISM de 868 MHz</a></li>
<li><a href="../es425907/index.html">Estamos haciendo un proyecto de aprendizaje automático en Python. Parte 2</a></li>
<li><a href="../es425911/index.html">Transferir CRM en la nube a la versión en caja</a></li>
<li><a href="../es425915/index.html">Cómo las comunicaciones transfronterizas pueden reemplazar los semáforos y acortar el camino al trabajo</a></li>
<li><a href="../es425917/index.html">Justice Fighter evita que Waymo patente la tecnología LIDAR clave</a></li>
<li><a href="../es425919/index.html">Mapas hexagonales en Unity: guardar y cargar, texturas, distancias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>