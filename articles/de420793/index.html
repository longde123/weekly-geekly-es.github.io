<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèº üêç üì† Debuggen als Prozess üì° üò° üßìüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es wird angenommen, dass die Entwicklung etwa 10% der Zeit und das Debuggen 90% der Zeit in Anspruch nimmt. Vielleicht ist diese Aussage √ºbertrieben, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debuggen als Prozess</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420793/"> Es wird angenommen, dass die Entwicklung etwa 10% der Zeit und das Debuggen 90% der Zeit in Anspruch nimmt.  Vielleicht ist diese Aussage √ºbertrieben, aber jeder Entwickler wird zustimmen, dass das Debuggen ein √§u√üerst ressourcenintensiver Prozess ist, insbesondere in gro√üen Multithread-Systemen. <br><br>  Die Optimierung und Systematisierung des Debugging-Prozesses kann daher erhebliche Vorteile in Form von eingesparten Arbeitsstunden bringen, die Geschwindigkeit der Probleml√∂sung erh√∂hen und letztendlich die Loyalit√§t Ihrer Benutzer erh√∂hen. <br><br><img src="https://habrastorage.org/webt/lm/eb/rk/lmebrkzzdxjbw-vsbub7ybrlxjq.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sergey Shchegrikovich</a> (dotmailer) schlug auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext 2018 Piter-</a> Konferenz vor, das Debuggen als einen Prozess zu betrachten, der beschrieben und optimiert werden kann.  Wenn Sie immer noch keinen klaren Plan zum Auffinden von Fehlern haben - unter dem geschnittenen Video- und Textprotokoll von Sergeys Bericht. <br><br>  (Und am Ende des Beitrags haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">John Skeets</a> Appell an alle Partner hinzugef√ºgt. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Paxi4K5Om1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Mein Ziel ist es, die Frage zu beantworten: Wie k√∂nnen Fehler effizient behoben werden und worauf sollte der Schwerpunkt liegen?  Ich denke, die Antwort auf diese Frage ist ein Prozess.  Der Debugging-Prozess, der aus sehr einfachen Regeln besteht und Sie kennen sie gut, aber Sie verwenden ihn wahrscheinlich unwissentlich.  Daher ist es meine Aufgabe, sie zu systematisieren und anhand eines Beispiels zu zeigen, wie man effektiver wird. <br><br>  Wir werden eine gemeinsame Sprache f√ºr die Kommunikation w√§hrend des Debuggens entwickeln und einen direkten Weg finden, um die Hauptprobleme zu finden.  An meinen Beispielen werde ich zeigen, was aufgrund eines Versto√ües gegen diese Regeln passiert ist. <br><br><h2>  Debug-Dienstprogramme </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/292/518/f94/292518f94ecd468e034d8ec952398980.png"><br>  Nat√ºrlich ist ein Debuggen ohne Debugging-Dienstprogramme nicht m√∂glich.  Meine Favoriten sind: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windbg</a> , das neben dem Debugger selbst √ºber umfangreiche Funktionen zum Studieren von Speicherabbildern verf√ºgt.  Ein Speicherauszug ist ein Ausschnitt aus dem Status eines Prozesses.  Darin finden Sie den Wert der Felder von Objekten, Call-Stacks, aber leider ist der Speicherauszug statisch. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfView</a> ist ein Profiler, der auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETW-Technologie basiert</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysinternals</a> ist ein von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Russinovich</a> geschriebenes Dienstprogramm, mit dem Sie etwas weiter in das Ger√§t des Betriebssystems eintauchen k√∂nnen. <br></li></ul><br><h2>  Fallender Dienst </h2><br>  Beginnen wir mit einem Beispiel aus meinem Leben, in dem ich zeigen werde, wie die unsystematische Natur des Debugging-Prozesses zu Ineffizienz f√ºhrt. <br><br>  Wahrscheinlich ist dies allen passiert, wenn Sie f√ºr ein neues Projekt zu einem neuen Unternehmen in einem neuen Team kommen und dann vom ersten Tag an irreparable Vorteile erzielen m√∂chten.  So war es bei mir.  Zu dieser Zeit hatten wir einen Dienst, der HTML zur Eingabe und Ausgabe von Bildern zur Ausgabe erhielt. <br><br>  Der Dienst wurde unter .Net 3.0 geschrieben und ist schon sehr lange her.  Dieser Dienst hatte eine kleine Funktion - er st√ºrzte ab.  Fiel oft, etwa alle zwei bis drei Stunden.  Wir haben dies elegant behoben - setzen Sie die Neustarteigenschaften in den Eigenschaften des Dienstes nach dem Herbst. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/b02/1a2/0ccb021a20b6c50d1639cd3e2bef7c28.png"><br><br>  Der Service war f√ºr uns nicht kritisch und wir konnten es √ºberleben.  Aber ich habe mich dem Projekt angeschlossen und als erstes habe ich beschlossen, es zu reparieren. <br><br>  Wohin gehen .NET-Entwickler, wenn etwas nicht funktioniert?  Sie gehen zu EventViewer.  Aber dort fand ich nichts au√üer der Aufzeichnung, dass der Dienst fiel.  Es gab keine Nachrichten √ºber den nativen Fehler oder einen Aufrufstapel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be3/bdf/2fe/be3bdf2fe39777092ad0f2989e35d92e.png"><br><br>  Es gibt ein bew√§hrtes Tool f√ºr die n√§chsten Schritte - wir verpacken die gesamte <code>main</code> in <code>try-catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); }</code> </pre><br>  Die Idee ist einfach: <code>try-catch</code> wird funktionieren, es wird uns nerven, wir werden es lesen und den Service reparieren.  Wir kompilieren, stellen f√ºr die Produktion bereit, der Service st√ºrzt ab, es gibt keinen Fehler.  F√ºgen Sie einen weiteren <code>catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); }</code> </pre><br>  Wir wiederholen den Vorgang: Der Dienst st√ºrzt ab, es gibt keine Fehler in den Protokollen.  Das Letzte, was helfen kann, ist <code>finally</code> , was immer aufgerufen wird. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { LogEndOfExecution(); }</code> </pre><br>  Wir kompilieren, implementieren, der Service st√ºrzt ab, es gibt keine Fehler.  Drei Tage vergehen hinter diesem Prozess, jetzt kommen bereits Gedanken, dass wir endlich anfangen m√ºssen, etwas anderes zu denken und zu tun.  Sie k√∂nnen viele Dinge tun: Versuchen Sie, den Fehler auf dem lokalen Computer zu reproduzieren, Speicherausz√ºge zu √ºberwachen usw.  Es schien noch zwei Tage und ich werde diesen Fehler beheben ... <br><br>  Zwei Wochen sind vergangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1eb/f02/0c3/1ebf020c3dde595f5423fd8247c3137b.png"><br><br>  Ich habe in PerformanceMonitor nachgesehen, wo ich einen Dienst gesehen habe, der abst√ºrzt, dann steigt und dann wieder f√§llt.  Dieser Zustand wird <i>Verzweiflung genannt</i> und sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/e07/904/98be07904a35b99130ba9ddf871af47f.png"><br><br>  Versuchen Sie bei dieser Vielzahl von Etiketten herauszufinden, wo das Problem wirklich liegt?  Nach mehreren Stunden Meditation tritt pl√∂tzlich das Problem auf: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/379/2ba/caa/3792bacaa7c418f5fcffa318729bf1a0.png"><br><br>  Die rote Linie gibt die Anzahl der nativen Handles an, die dem Prozess geh√∂ren.  Ein natives Handle ist ein Verweis auf eine Betriebssystemressource: Datei, Registrierung, Registrierungsschl√ºssel, Mutex usw.  F√ºr eine seltsame Kombination von Umst√§nden f√§llt der R√ºckgang der Anzahl der Griffe mit den Momenten zusammen, in denen der Service fiel.  Dies f√ºhrt zu der Idee, dass irgendwo ein Griffleck vorhanden ist. <br><br>  Wir nehmen einen Speicherauszug und √∂ffnen ihn in WinDbg.  Wir beginnen Befehle auszuf√ºhren.  Versuchen wir, die Finalisierungswarteschlange der Objekte anzuzeigen, die von der Anwendung freigegeben werden sollen. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">000</span></span>&gt; !FinalizeQueue</code> </pre><br>  Ganz am Ende der Liste fand ich einen Webbrowser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6f/aa5/eb3/d6faa5eb38c3b7a4429e55d7f8af655e.png"><br>  Die L√∂sung ist einfach: Nehmen Sie WebBrowser und rufen Sie <code>dispose</code> daf√ºr auf: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webBrowser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebBrowser()) { <span class="hljs-comment"><span class="hljs-comment">// Processing ... } }</span></span></code> </pre><br>  Die Schlussfolgerungen aus dieser Geschichte k√∂nnen wie folgt gezogen werden: Zwei Wochen sind zu lang und zu lang, um eine ungebetene <code>dispose</code> zu finden;  dass wir eine L√∂sung f√ºr das Problem gefunden haben - Gl√ºck, da es keinen spezifischen Ansatz gab, gab es keinen systematischen Charakter. <br><br>  Danach hatte ich eine Frage: Wie kann man effektiv deb√ºtieren und was tun? <br><br>  Dazu m√ºssen Sie nur drei Dinge wissen: <br><br><ol><li>  Debugging-Regeln <br></li><li>  Algorithmus zum Auffinden von Fehlern. <br></li><li>  Proaktive Debugging-Techniken. <br></li></ol><br><h2>  Debugging-Regeln </h2><br><ol><li>  Wiederholen Sie den Fehler. <br></li><li>  Wenn Sie den Fehler nicht behoben haben, ist er nicht behoben. <br></li><li>  Verstehe das System. <br></li><li>  √úberpr√ºfen Sie den Stecker. <br></li><li>  Teilen und erobern. <br></li><li>  Erfrischen Sie sich. <br></li><li>  Das ist dein Fehler. <br></li><li>  F√ºnf warum. <br></li></ol><br>  Dies sind ziemlich klare Regeln, die sich selbst beschreiben. <br><br>  Wiederholen Sie den Fehler.  Eine sehr einfache Regel, denn wenn Sie keinen Fehler machen k√∂nnen, gibt es nichts zu beheben.  Es gibt jedoch verschiedene F√§lle, insbesondere bei Fehlern in einer Umgebung mit mehreren Threads.  Wir hatten irgendwie einen Fehler, der nur auf Itanium-Prozessoren und nur auf Produktionsservern auftrat.  Daher besteht die erste Aufgabe im Debugging-Prozess darin, eine Konfiguration des Pr√ºfstands zu finden, auf dem der Fehler reproduziert werden w√ºrde. <br><br>  Wenn Sie den Fehler nicht behoben haben, ist er nicht behoben.  Manchmal passiert dies: Ein Bug-Tracker enth√§lt einen Bug, der vor einem halben Jahr aufgetreten ist, niemand hat ihn lange gesehen, und es besteht der Wunsch, ihn einfach zu schlie√üen.  Aber in diesem Moment verpassen wir die Chance zu wissen, die Chance zu verstehen, wie unser System funktioniert und was wirklich damit passiert.  Daher ist jeder Fehler eine neue Gelegenheit, etwas zu lernen und mehr √ºber Ihr System zu erfahren. <br><br>  Verstehe das System.  Brian Kernighan hat einmal gesagt, wenn wir so schlau w√§ren, dieses System zu schreiben, m√ºssten wir doppelt schlau sein, um es zu deb√ºtieren. <br><br>  Ein kleines Beispiel f√ºr die Regel.  Unsere √úberwachung zeichnet Diagramme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/bfa/85b/4cfbfa85be2cf375741646b55aa373e6.png"><br>  Dies ist eine grafische Darstellung der Anzahl der von unserem Service bearbeiteten Anfragen.  Nachdem wir es uns angesehen hatten, kamen wir auf die Idee, dass es m√∂glich sein w√ºrde, die Geschwindigkeit des Dienstes zu erh√∂hen.  In diesem Fall steigt der Zeitplan und es kann m√∂glich sein, die Anzahl der Server zu reduzieren. <br><br>  Die Optimierung der Webleistung erfolgt einfach: Wir nehmen PerfView, f√ºhren es auf dem Produktionscomputer aus, entfernen den Trace innerhalb von 3-4 Minuten, bringen diesen Trace zum lokalen Computer und beginnen mit dem Studium. <br><br>  Eine der Statistiken, die PerfView anzeigt, ist der Garbage Collector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/ed0/c3f/d3aed0c3f4d3c6de77840aa9ffc10004.png"><br><br>  Bei Betrachtung dieser Statistiken haben wir festgestellt, dass der Dienst 85% seiner Zeit damit verbringt, M√ºll zu sammeln.  In PerfView k√∂nnen Sie genau sehen, wo diese Zeit verbracht wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/cd2/e4a/bb5cd2e4a54d4f71d832482217233281.png"><br><br>  In unserem Fall werden dadurch Zeichenfolgen erstellt.  Die Korrektur selbst bietet sich an: Wir ersetzen alle Strings durch StringBuilders.  Vor Ort erzielen wir eine Produktivit√§tssteigerung von 20-30%.  In der Produktion bereitstellen, sehen Sie die Ergebnisse im Vergleich zum alten Zeitplan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/d63/21d/060d6321d41fa993d80d7b9d19d2d95c.png"><br><br>  Bei der Regel "System verstehen" geht es nicht nur darum zu verstehen, wie Interaktionen in Ihrem System ablaufen, wie Nachrichten ablaufen, sondern auch darum, Ihr System zu modellieren. <br><br>  Im Beispiel zeigt das Diagramm die Bandbreite.  Wenn Sie jedoch das gesamte System unter dem Gesichtspunkt der Warteschlangentheorie betrachten, stellt sich heraus, dass der Durchsatz unseres Systems nur von einem Parameter abh√§ngt - der Geschwindigkeit des Eintreffens neuer Nachrichten.  Tats√§chlich hatte das System einfach nicht mehr als 80 Nachrichten gleichzeitig, sodass es keine M√∂glichkeit gibt, diesen Zeitplan zu optimieren. <br><br>  √úberpr√ºfen Sie den Stecker.  Wenn Sie die Dokumentation eines Haushaltsger√§ts √∂ffnen, wird diese auf jeden Fall dort geschrieben: Wenn das Ger√§t nicht funktioniert, √ºberpr√ºfen Sie, ob der Stecker in die Steckdose gesteckt ist.  Nach einigen Stunden im Debugger denke ich oft, dass ich nur die neueste Version neu kompilieren oder einfach abholen musste. <br><br>  Bei der Regel ‚ÄûCheck the Plug‚Äú geht es um Fakten und Daten.  Das Debuggen beginnt nicht mit der Ausf√ºhrung von WinDbg oder PerfView auf Produktionsmaschinen, sondern mit der √úberpr√ºfung von Fakten und Daten.  Wenn der Dienst nicht antwortet, wird er m√∂glicherweise nicht ausgef√ºhrt. <br><br>  Teilen und erobern.  Dies ist die erste und wahrscheinlich einzige Regel, die das Debuggen als Prozess umfasst.  Es geht um Hypothesen, deren F√∂rderung und Pr√ºfung. <br><br>  Einer unserer Dienste wollte nicht aufh√∂ren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f2/cff/169/4f2cff1697473f917e815384d773149a.png"><br><br>  Wir stellen eine Hypothese auf: Vielleicht gibt es einen Zyklus im Projekt, der etwas endlos verarbeitet. <br><br>  Sie k√∂nnen die Hypothese auf verschiedene Arten testen. Eine M√∂glichkeit besteht darin, einen Speicherauszug zu erstellen.  Wir ziehen Call-Stacks mit dem <code>~*e!ClrStack</code> aus dem Dump und allen Threads.  Wir fangen an, drei Str√∂me zu sehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a54/35b/1d3a5435b697646daaf802e2bd838c7e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f3/185/6b2/2f31856b23147722d7b3e534689572f8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/ac7/760/d0fac7760f4e8e201d0f028c4deae23e.png"><br><br>  Der erste Thread befindet sich in Main, der zweite im <code>OnStop()</code> Handler und der dritte Thread wartete auf einige interne Aufgaben.  Daher ist unsere Hypothese nicht gerechtfertigt.  Es gibt keine Schleife, alle Threads warten auf etwas.  H√∂chstwahrscheinlich Deadlock. <br><br>  Unser Service funktioniert wie folgt.  Es gibt zwei Aufgaben - Initialisierung und Arbeiten.  Durch die Initialisierung wird eine Verbindung zur Datenbank hergestellt, der Worker beginnt mit der Verarbeitung der Daten.  Die Kommunikation zwischen ihnen erfolgt √ºber ein gemeinsames Flag, das mithilfe von <code>TaskCompletionSource</code> implementiert <code>TaskCompletionSource</code> . <br><br>  Wir stellen die zweite Hypothese auf: Vielleicht haben wir einen Stillstand einer Aufgabe f√ºr die zweite.  Um dies zu √ºberpr√ºfen, k√∂nnen Sie jede Aufgabe separat √ºber WinDbg anzeigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/536/1cf/c0f5361cf09ba6cd40d9a72e6d5dfb06.png"><br><br>  Es stellt sich heraus, dass eine der Aufgaben fiel und die zweite nicht.  Im Projekt haben wir den folgenden Code gesehen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  <code>TaskCompletionSource</code> bedeutet, dass die Initialisierungsaufgabe die Verbindung √∂ffnet und danach <code>TaskCompletionSource</code> auf true setzt.  Aber was ist, wenn hier eine Ausnahme f√§llt?  Dann haben wir keine Zeit, <code>SetResult</code> auf true zu setzen, daher war die Behebung dieses Fehlers wie <code>SetResult</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { _initLock.SetException(ex); }</code> </pre><br>  In diesem Beispiel stellen wir zwei Hypothesen auf: die Endlosschleife und den Deadlock.  Die Regel "Teilen und Erobern" hilft, den Fehler zu lokalisieren.  Aufeinanderfolgende N√§herungen l√∂sen solche Probleme. <br><br>  Das Wichtigste in dieser Regel sind Hypothesen, da sie sich im Laufe der Zeit in Muster verwandeln.  Und je nach Hypothese verwenden wir unterschiedliche Aktionen. <br><br>  Erfrischen Sie sich.  Diese Regel besagt, dass Sie nur vom Tisch aufstehen und gehen, Wasser, Saft oder Kaffee trinken, alles tun m√ºssen, aber das Wichtigste ist, von Ihrem Problem abzulenken. <br><br>  Es gibt eine sehr gute Methode namens Ente.  Nach der Methode m√ºssen wir √ºber das Problem des <i>Entens</i> erz√§hlen.  Sie k√∂nnen einen Kollegen als <i>Ente verwenden</i> .  Au√üerdem muss er nicht antworten, nur zuh√∂ren und zustimmen.  Und oft finden Sie nach dem ersten Gespr√§ch √ºber das Problem selbst eine L√∂sung. <br><br>  Das ist dein Fehler.  Ich werde anhand eines Beispiels √ºber diese Regel berichten. <br><br>  Bei einer <code>AccessViolationException</code> ein Problem <code>AccessViolationException</code> .  Im Call-Stack habe ich festgestellt, dass es aufgetreten ist, als wir die LinqToSql-Abfrage im SQL-Client generiert haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd2/849/7a6/fd28497a66853c5bcf17eaa9d978524a.png"><br><br>  Aus diesem Fehler wurde deutlich, dass irgendwo die Integrit√§t des Speichers verletzt wird.  Gl√ºcklicherweise haben wir zu diesem Zeitpunkt bereits ein √Ñnderungsmanagementsystem verwendet.  Als Ergebnis wurde nach ein paar Stunden klar, was passiert ist: Wir haben .Net 4.5.2 auf unseren Produktionsmaschinen installiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/bc8/438/f24bc84388e43df0ad4e7af27c0bbc24.png"><br><br>  Dementsprechend senden wir den Fehler an Microsoft, sie untersuchen ihn, wir kommunizieren mit ihnen, sie beheben den Fehler in .Net 4.6.1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/c39/535/44ac39535a874ff0ea0f599a55f07252.png"><br><br>  F√ºr mich f√ºhrte dies nat√ºrlich zu einer elfmonatigen Zusammenarbeit mit dem Microsoft-Support, nicht jeden Tag, aber die Reparatur dauerte von Anfang an elf Monate.  Au√üerdem haben wir ihnen Dutzende von Gigabyte Speicherausz√ºgen gesendet und Hunderte von privaten Assemblys platziert, um diesen Fehler abzufangen.  Und die ganze Zeit konnten wir unseren Kunden nicht sagen, dass Microsoft schuld war, nicht wir.  Daher liegt der Fehler immer bei Ihnen. <br><br>  F√ºnf warum.  Wir in unserer Firma verwenden Elastic.  Elastic ist gut f√ºr die Protokollaggregation. <br><br>  Du kommst morgens zur Arbeit und Elastic l√ºgt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/c80/09b/1a1c8009b49f9c288b3c4b29daf194cc.png"><br><br>  Die erste Frage ist, warum Elastic ist?  Fast sofort wurde klar - Master Nodes fielen.  Sie koordinieren die Arbeit des gesamten Clusters und wenn sie fallen, reagiert der gesamte Cluster nicht mehr.  Warum sind sie nicht aufgestanden?  Vielleicht sollte es einen Autostart geben?  Nach der Suche nach der Antwort haben wir festgestellt, dass die Plugin-Version nicht √ºbereinstimmt.  Warum sind Master Nodes √ºberhaupt gefallen?  Sie wurden von OOM Killer get√∂tet.  Dies ist auf Linux-Rechnern der Fall, die bei Speichermangel unn√∂tige Prozesse schlie√üen.  Warum gibt es nicht genug Speicher?  Weil der Update-Prozess gestartet wurde, der aus den Systemprotokollen folgt.  Warum hat es fr√ºher funktioniert, aber jetzt nicht?  Und da wir eine Woche zuvor neue Knoten hinzugef√ºgt haben, ben√∂tigten Master-Knoten entsprechend mehr Speicher zum Speichern von Indizes und Cluster-Konfigurationen. <br><br>  Die Fragen "warum?"  helfen Sie, die Wurzel des Problems zu finden.  In diesem Beispiel k√∂nnten wir den richtigen Pfad oft ausschalten, aber die vollst√§ndige Korrektur sieht folgenderma√üen aus: Wir aktualisieren das Plugin, starten Dienste, erh√∂hen den Speicher und notieren uns f√ºr die Zukunft, dass wir beim n√§chsten Hinzuf√ºgen neuer Knoten zum Cluster sicherstellen m√ºssen, dass auf dem Master gen√ºgend Speicher vorhanden ist Knoten <br><br>  Durch die Anwendung dieser Regeln k√∂nnen Sie echte Probleme aufdecken, sich auf die L√∂sung dieser Probleme konzentrieren und zur Kommunikation beitragen.  Aber es w√§re noch besser, wenn diese Regeln ein System bilden w√ºrden.  Und es gibt ein solches System, das als Debugging-Algorithmus bezeichnet wird. <br><br><h2>  Debugging-Algorithmus </h2><br>  Zum ersten Mal las ich √ºber den Debugging-Algorithmus in John Robbins 'Buch Debugging-Anwendungen.  Es beschreibt den Debugging-Prozess wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/2af/a07/f1e2afa078f2ab8587467660b25df052.png"><br><br>  Dieser Algorithmus ist n√ºtzlich f√ºr seine innere Schleife - Arbeiten mit einer Hypothese. <br><br>  Mit jeder Umdrehung des Zyklus k√∂nnen wir uns selbst √ºberpr√ºfen: Wissen wir mehr √ºber das System oder nicht?  Wenn wir Hypothesen aufstellen, pr√ºfen, ob sie nicht funktionieren, wir nichts Neues √ºber den Betrieb des Systems erfahren, ist es wahrscheinlich an der Zeit, sich zu erfrischen.  Zwei aktuelle Fragen an dieser Stelle: Welche Hypothesen haben Sie getestet und welche Hypothese testen Sie jetzt? <br><br>  Dieser Algorithmus stimmt sehr gut mit den Debugging-Regeln √ºberein, √ºber die wir oben gesprochen haben: Wiederholen Sie den Fehler - dies ist Ihr Fehler, beschreiben Sie das Problem - verstehen Sie das System, formulieren Sie eine Hypothese - teilen und erobern Sie, testen Sie die Hypothese - √ºberpr√ºfen Sie den Stecker, stellen Sie sicher, dass er behoben ist - f√ºnf warum. <br><br>  Ich habe ein gutes Beispiel f√ºr diesen Algorithmus.  Eine Ausnahme bildete einer unserer Webdienste. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/a57/d71/206a57d711a7c783c9f22389120d1bf8.png"><br><br>  Unser erster Gedanke ist nicht unser Problem.  Aber nach den Regeln ist dies immer noch unser Problem. <br><br>  Wiederholen Sie zun√§chst den Fehler.  F√ºr jeweils tausend Anfragen gibt es ungef√§hr eine <code>StructureMapException</code> , sodass wir das Problem reproduzieren k√∂nnen. <br><br>  Zweitens versuchen wir, das Problem zu beschreiben: Wenn der Benutzer zu dem Zeitpunkt, zu dem StructureMap versucht, eine neue Abh√§ngigkeit herzustellen, eine http-Anfrage f√ºr unseren Dienst stellt, tritt eine Ausnahme auf. <br><br>  Drittens nehmen wir an, dass StructureMap ein Wrapper ist und etwas darin eine interne Ausnahme ausl√∂st.  Wir testen die Hypothese mit procdump.exe. <br><br><pre> <code class="hljs powershell">procdump.exe <span class="hljs-literal"><span class="hljs-literal">-ma</span></span> <span class="hljs-literal"><span class="hljs-literal">-e</span></span> <span class="hljs-operator"><span class="hljs-operator">-f</span></span> StructureMap w3wp.exe</code> </pre><br>  Es stellt sich heraus, dass im Inneren eine <code>NullReferenceException</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/773/500/2da773500ffd18d1c28b91f6ff5b45e3.png"><br><br>  Wenn wir den Aufrufstapel dieser Ausnahme untersuchen, verstehen wir, dass dies innerhalb des Objekt-Builders in der StructureMap selbst geschieht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fd/347/8fc/5fd3478fc54df6295244471a33560a3d.png"><br><br>  <code>NullReferenceException</code> ist jedoch nicht das Problem selbst, sondern die Konsequenz.  Sie m√ºssen verstehen, wo es auftritt und wer es generiert. <br><br>  Wir stellen die folgende Hypothese auf: Aus irgendeinem Grund gibt unser Code eine Nullabh√§ngigkeit zur√ºck.  Angesichts der Tatsache, dass sich in .Net alle Objekte im Speicher nacheinander befinden, werden die Objekte auf dem Heap, die vor der <code>NullReferenceException</code> , wahrscheinlich auf den Code verweisen, der die Ausnahme <code>NullReferenceException</code> hat. <br><br>  In WinDbg gibt es einen Befehl - List Near Objects <code>!lno</code> .  Es zeigt, dass das Objekt, an dem wir interessiert sind, die Lambda-Funktion ist, die im folgenden Code verwendet wird. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompoundInterceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindInterceptor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { CompoundInterceptop interceptor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_locker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interceptorArray = _interceptors.FindAll(i =&gt; i.MatchesType(type)); interceptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompoundInterceptor(interceptorArray); _analyzedInterceptors.Add(type, interceptor); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor; }</code> </pre><br>  In diesem Code pr√ºfen wir zun√§chst, ob der Wert im <code>Dictionary</code> in <code>_analyzedInterceptors</code> ist. Wenn wir ihn nicht finden, f√ºgen wir einen neuen Wert in die <code>lock</code> . <br><br>  Theoretisch kann dieser Code niemals null zur√ºckgeben.  Das Problem liegt hier jedoch in <code>_analyzedInterceptors</code> , die ein regul√§res <code>Dictionary</code> in einer Umgebung mit mehreren Threads verwenden, kein <code>ConcurrentDictionary</code> . <br><br>  Die Wurzel des Problems wurde gefunden. Wir haben auf die neueste Version von StructureMap aktualisiert, bereitgestellt und sichergestellt, dass alles behoben wurde.  Der letzte Schritt unseres Algorithmus ist ‚Äûlernen und erz√§hlen‚Äú.  In unserem Fall war es eine Suche im Code aller <code>Dictionary</code> , die im Schloss verwendet werden, und die √úberpr√ºfung, ob alle korrekt verwendet werden. <br><br>  Der Debugging-Algorithmus ist also ein intuitiver Algorithmus, der erheblich Zeit spart.  Er konzentriert sich auf die Hypothese - und dies ist das Wichtigste beim Debuggen. <br><br><h2>  Proaktives Debuggen </h2><br>  Im Kern beantwortet proaktives Debuggen die Frage "Was passiert, wenn ein Fehler auftritt?". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/718/900/7aa71890010a8c32900fa5b01e0b690a.png"><br><br>  Die Bedeutung proaktiver Debugging-Techniken zeigt das Fehlerlebenszyklusdiagramm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be0/f6f/06c/be0f6f06cb0c810ca6b19cb861d998c4.png"><br><br>  Das Problem ist, dass je l√§nger der Fehler lebt, desto mehr Ressourcen (Zeit) wir daf√ºr aufwenden. <br><br>  Die Debugging-Regeln und der Debugging-Algorithmus konzentrieren uns auf den Moment, in dem der Fehler gefunden wird, und wir k√∂nnen herausfinden, was als n√§chstes zu tun ist.  Tats√§chlich m√∂chten wir unseren Fokus zum Zeitpunkt der Erstellung des Fehlers verschieben.  Ich bin der Meinung, dass wir das Minimum Debuggable Product (MDP) durchf√ºhren sollten, dh ein Produkt, das √ºber die minimal erforderliche Infrastruktur f√ºr ein effizientes Debugging in der Produktion verf√ºgt. <br><br>  MDP besteht aus zwei Dingen: Fitnessfunktion und USE-Methode. <br><br>  Fitnessfunktionen.  Sie wurden von Neil Ford und Co-Autoren in dem Buch Building Evolutionary Architectures popul√§r gemacht.  Im Kern sehen Fitnessfunktionen laut den Autoren des Buches folgenderma√üen aus: Es gibt eine Anwendungsarchitektur, die wir aus verschiedenen Winkeln schneiden k√∂nnen, wobei architektonische Eigenschaften wie <i>Wartbarkeit</i> , <i>Leistung</i> usw. erhalten werden, und f√ºr jeden dieser Abschnitte m√ºssen wir einen Test schreiben - Fitness -Funktion.  Eine Fitnessfunktion ist also ein Architekturtest. <br><br>  Bei MDP ist die Fitnessfunktion ein Debuggbarkeitstest.  Sie k√∂nnen alles verwenden, was Sie m√∂chten, um solche Tests zu schreiben: NUnit, MSTest und so weiter.  Da das Debuggen jedoch h√§ufig mit externen Tools funktioniert, werde ich anhand von Pester (Powershell Unit Testing Framework) als Beispiel demonstrieren.  Das Plus hier ist, dass es gut mit der Kommandozeile funktioniert. <br><br>  Innerhalb des Unternehmens stimmen wir beispielsweise zu, dass wir bestimmte Bibliotheken f√ºr die Protokollierung verwenden werden.  Bei der Protokollierung werden bestimmte Muster verwendet.  PDF-Zeichen sollten immer an den Symbolserver √ºbergeben werden.  Dies sind die Konventionen, die wir in unseren Tests testen werden. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains line numbers in PDBs'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Include</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>(<span class="hljs-string"><span class="hljs-string">"*.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"*. dll "</span></span>) ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { &amp;symchk.exe /v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> /s <span class="hljs-string"><span class="hljs-string">"\\network\"</span></span> *&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*Line nubmers: TRUE*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  Dieser Test √ºberpr√ºft, ob alle PDF-Zeichen an den Symbolserver √ºbergeben wurden und korrekt angegeben wurden, dh diejenigen, die Zeilennummern enthalten.  Nehmen Sie dazu die kompilierte Version der Produktion, suchen Sie alle exe- und dll-Dateien und √ºbergeben Sie alle diese Bin√§rdateien √ºber das Dienstprogramm syschk.exe, das im Paket Debugging-Tools f√ºr Windows enthalten ist.  Das Dienstprogramm syschk.exe √ºberpr√ºft die Bin√§rdatei mit dem Symbolserver und druckt einen Bericht dar√ºber, wenn es dort eine PDF-Datei findet.  Im Bericht suchen wir nach der Zeile ‚ÄûZeilennummern: WAHR‚Äú.  Und im Finale pr√ºfen wir, ob das Ergebnis nicht ‚Äûnull oder leer‚Äú ist. <br><br>  Diese Tests m√ºssen in eine kontinuierliche Bereitstellungspipeline integriert werden.  Nachdem die Integrationstests und Komponententests bestanden wurden, werden die Fitnessfunktionen gestartet. <br><br>  Ich werde ein weiteres Beispiel mit der √úberpr√ºfung der erforderlichen Bibliotheken im Code zeigen. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains package for logging'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Name</span></span> <span class="hljs-string"><span class="hljs-string">"packages.config"</span></span> ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-Content</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*nlog*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  Im Test nehmen wir alle packages.config-Dateien und versuchen, die darin enthaltenen nlog-Bibliotheken zu finden.  In √§hnlicher Weise k√∂nnen wir √ºberpr√ºfen, ob das Korrelations-ID-Feld innerhalb des nlog-Felds verwendet wird. <br><br>  USE-Methoden.  Das Letzte, woraus MDP besteht, sind die Metriken, die Sie sammeln m√ºssen. <br><br>  Ich werde am Beispiel der USE-Methode demonstrieren, die von Brendan Gregg popul√§r gemacht wurde.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee ist einfach: Wenn der Code ein Problem aufweist, reichen drei Metriken aus: Auslastung (S√§ttigung), Fehler (Fehler), um zu verstehen, wo das Problem liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Unternehmen, z. B. Circonus (sie √ºberwachen Soft), </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">ihre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dashboards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Form von festgelegten Metriken. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/f58/382/70af583826e562f796fb0473c520db15.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich beispielsweise den Speicher genauer ansehen, ist die Verwendung die Menge an freiem Speicher, die S√§ttigung die Anzahl der Festplattenzugriffe und Fehler alle aufgetretenen Fehler. </font><font style="vertical-align: inherit;">Um Produkte f√ºr das Debuggen bequem zu machen, m√ºssen Sie daher USE-Metriken f√ºr alle Funktionen und alle Teile des Subsystems erfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Gesch√§ftsfunktion verwenden, k√∂nnen Sie h√∂chstwahrscheinlich drei Metriken darin unterscheiden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwendung - Anforderungsverarbeitungszeit. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die S√§ttigung ist die L√§nge der Warteschlange. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler - alle Ausnahmesituationen. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns als Beispiel ein Diagramm der Anzahl der verarbeiteten Anforderungen an, die eines unserer Systeme stellt. </font><font style="vertical-align: inherit;">Wie Sie sehen, hat der Dienst in den letzten drei Stunden keine Anfragen bearbeitet. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/f89/7ab/6ccf897ab0758b344dfc940eb9be548b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Hypothese, die wir aufgestellt haben, ist, dass der Dienst gesunken ist und wir ihn neu starten m√ºssen. </font><font style="vertical-align: inherit;">Bei der √úberpr√ºfung stellt sich heraus, dass der Dienst funktioniert und 4-5% der CPU verbraucht. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9a3/f4a/7e19a3f4a52547627e150401b0f1e7e7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Hypothese ist, dass ein Fehler in den Dienst f√§llt, den wir nicht sehen. </font><font style="vertical-align: inherit;">Wir werden das Dienstprogramm etrace verwenden.</font></font><br><br><pre> <code class="hljs powershell">etrace -<span class="hljs-literal"><span class="hljs-literal">-kernel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-where</span></span> ProcessName=Ex5<span class="hljs-literal"><span class="hljs-literal">-Service</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-clr</span></span> Exception</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Dienstprogramm k√∂nnen Sie ETW-Ereignisse in Echtzeit abonnieren und auf dem Bildschirm anzeigen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/d13/52b/f1ad1352bc6e02e3a660f64ce90fdc87.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen, dass es f√§llt </font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber die zweite Frage, warum ist es nicht in den Protokollen? </font><font style="vertical-align: inherit;">Die Antwort ist schnell - wir fangen sie ab, versuchen den Speicher aufzur√§umen, warten ein bisschen und beginnen wieder zu arbeiten.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ShouldContinue()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Do(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException) { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); GC.CollectionCount(<span class="hljs-number"><span class="hljs-number">2</span></span>); GC.WaitForPendingFinalizers(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die n√§chste Hypothese ist, dass jemand die gesamte Erinnerung auffrisst. </font><font style="vertical-align: inherit;">Laut Speicherauszug befinden sich die meisten Objekte im Cache.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, String&gt; _items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime _nextClearTime = DateTime.UtcNow; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_nextClearTime &lt; DateTime.UtcNow) { _nextClearTime = DateTime.UtcNow.AddHours(<span class="hljs-number"><span class="hljs-number">1</span></span>); _items.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[key]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code zeigt, dass der Cache st√ºndlich geleert werden sollte. </font><font style="vertical-align: inherit;">Aber die Erinnerung war nicht genug, sie erreichten nicht einmal die Reinigung. </font><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel f√ºr die USE-Cache-Metrik an. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/174/634/0c6174634447a3bd1af03adf10c14cbe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laut Zeitplan ist es sofort sichtbar - der Speicher hat zugenommen, Fehler haben sofort begonnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also Schlussfolgerungen dar√ºber, was proaktives Debuggen ist.</font></font><br><br><ul><li>  ‚Äî    .  , ,    ‚Äî    .    ‚Äî    ,      -.     ,       . <br></li><li>     .             ;  Exception ,   ,     -   . <br></li><li> Minimum Debuggable Product ‚Äî  ,          . <br></li></ul><br><h2> ,    ? </h2><br><ol><li>   . <br></li><li>  . <br></li><li>  . <br></li></ol><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diesmal ist Jon Skeet der Sponsor unserer Anzeige. </font><font style="vertical-align: inherit;">Auch wenn Sie nicht f√ºr den neuen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach Moskau </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">fahren</font></a><font style="vertical-align: inherit;"> , ist das Video einen Blick wert (John hat sich sehr bem√ºht).</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p2SQbq-umy4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420793/">https://habr.com/ru/post/de420793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420777/index.html">Anmelden in Android Studio ohne Code</a></li>
<li><a href="../de420779/index.html">Boring Mask Company: Tunnel zum Stadion und Er√∂ffnung des Tunnels</a></li>
<li><a href="../de420785/index.html">Arbeit als IT-Spezialist im Fernen Osten - Oblast Sachalin</a></li>
<li><a href="../de420789/index.html">(A | a) Architektur: Warum ist dies ein nicht standardm√§√üiger Mitap f√ºr Entwickler hoch belasteter Systeme?</a></li>
<li><a href="../de420791/index.html">Heimroboter: Was Sie kaufen k√∂nnen. √úbersicht der verf√ºgbaren kommerziellen Heimroboter</a></li>
<li><a href="../de420795/index.html">Missverst√§ndnisse des Analytikers</a></li>
<li><a href="../de420797/index.html">Lernen kann nicht verschoben werden</a></li>
<li><a href="../de420799/index.html">MPS 2018.2: Generatortests, GitHub-Plugin, VCS-Aspekt, Migrationsbenachrichtigungen und mehr</a></li>
<li><a href="../de420803/index.html">3D-Druckunterricht. Speichern von Kunststoff beim Drucken nicht funktionsf√§higer Modelle aus 3Dtool</a></li>
<li><a href="../de420805/index.html">[√úbersetzung] Wann werden parallele Streams verwendet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>