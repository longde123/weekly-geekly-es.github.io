<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 ⛱️ 💷 Les structures de données de l'état de la blockchain Plasma Cash 🎐 🦊 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers utilisateurs Habr! Cet article concerne le Web 3.0 - l'Internet décentralisé. Le Web 3.0 introduit le concept de décentralisation comme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les structures de données de l'état de la blockchain Plasma Cash</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455988/"><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><br>  Bonjour, chers utilisateurs Habr!  Cet article concerne le Web 3.0 - l'Internet décentralisé.  Le Web 3.0 introduit le concept de décentralisation comme fondement de l'Internet moderne.  De nombreux systèmes et réseaux informatiques nécessitent des fonctionnalités de sécurité et de décentralisation pour répondre à leurs besoins.  Un registre distribué utilisant la technologie blockchain fournit des solutions efficaces pour la décentralisation. <br><a name="habracut"></a><br>  Blockchain est un registre distribué.  Vous pouvez le considérer comme une énorme base de données qui dure éternellement, sans jamais changer au fil du temps.  La blockchain fournit la base d'applications et de services Web décentralisés. <br><br>  Cependant, la blockchain est plus qu'une simple base de données.  Il sert à accroître la sécurité et la confiance entre les membres du réseau, améliorant les transactions commerciales en ligne. <br><br>  Le consensus byzantin augmente la fiabilité du réseau et résout le problème de cohérence. <br><br>  L'évolutivité fournie par DLT modifie les réseaux d'entreprise existants. <br><br>  La blockchain offre de nouveaux avantages très importants: <br><br><ol><li>  Empêche les erreurs coûteuses. </li><li>  Assure des transactions transparentes. </li><li>  Numérise les biens réels. </li><li>  Applique les contrats intelligents. </li><li>  Augmente la vitesse et la sécurité des paiements. </li></ol><br>  Nous avons développé un PoE spécial pour rechercher des protocoles cryptographiques et améliorer les solutions DLT et blockchain existantes. <br><br>  La plupart des systèmes de registres publics n'ont pas la propriété de l'évolutivité, ce qui rend leur débit plutôt faible.  Par exemple, Ethereum ne traite que ~ 20 tx / s. <br><br>  De nombreuses solutions ont été développées pour augmenter l'évolutivité tout en maintenant la décentralisation.  Cependant, seuls 2 avantages sur 3 - évolutivité, sécurité et décentralisation - peuvent être obtenus simultanément. <br><br>  L'utilisation de sidechains fournit l'une des solutions les plus efficaces. <br><br><h2>  Le concept plasma </h2><br>  Le concept Plasma se résume à l'idée qu'une chaîne racine traite un petit nombre de validations à partir de chaînes enfants, agissant ainsi comme la couche la plus sûre et finale pour stocker tous les états intermédiaires.  Chaque chaîne enfant fonctionne comme sa propre blockchain avec son propre algorithme de consensus, mais il y a quelques mises en garde importantes. <br><br><ul><li>  Les contrats intelligents sont créés dans une chaîne racine et agissent comme des points de contrôle pour les chaînes enfants au sein de la chaîne racine. </li><li>  Une chaîne enfant est créée et fonctionne comme sa propre blockchain avec son propre consensus.  Tous les États de la chaîne enfant sont protégés par des preuves de fraude qui garantissent que toutes les transitions entre États sont valides et appliquent un protocole de retrait. </li><li>  Les contrats intelligents spécifiques à DApp ou à la logique d'application de la chaîne enfant peuvent être déployés dans la chaîne enfant. </li><li>  Les fonds peuvent être transférés de la chaîne racine à la chaîne enfant. </li></ul><br>  Les validateurs reçoivent des incitations économiques pour agir honnêtement et envoyer des engagements à la chaîne racine - la couche finale de règlement des transactions. <br><br>  Par conséquent, les utilisateurs DApp travaillant dans la chaîne enfant n'ont pas du tout à interagir avec la chaîne racine.  De plus, ils peuvent placer leur argent dans la chaîne racine quand ils le souhaitent, même si la chaîne enfant est piratée.  Ces sorties de la chaîne enfant permettent aux utilisateurs de stocker en toute sécurité leurs fonds avec des preuves Merkle, confirmant la propriété d'un certain montant de fonds. <br><br>  Les principaux avantages du plasma sont liés à sa capacité à faciliter considérablement les calculs qui surchargent la chaîne principale.  De plus, la blockchain Ethereum peut gérer des ensembles de données plus étendus et parallèles.  Le temps retiré de la chaîne racine est également transféré aux nœuds Ethereum, qui ont des exigences de traitement et de stockage plus faibles. <br><br>  <b>Plasma Cash</b> attribue des numéros de série uniques aux jetons en ligne.  Les avantages de ce système incluent pas besoin de confirmations, une prise en charge plus simple pour tous les types de jetons (y compris les jetons non fongibles) et l'atténuation contre les sorties massives d'une chaîne enfant. <br><br>  Le concept de «sorties massives» d'une chaîne enfant est un problème rencontré par Plasma.  Dans ce scénario, des retraits simultanés coordonnés d'une chaîne enfant pourraient potentiellement conduire à une puissance de calcul insuffisante pour retirer tous les fonds.  En conséquence, les utilisateurs peuvent perdre des fonds. <br><br><h2>  Options pour implémenter Plasma </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Basic Plasma a beaucoup d'options d'implémentation. <br><br>  Les principales différences concernent: <br><br><ul><li>  l'archivage des informations sur les méthodes de stockage et de présentation de l'état; </li><li>  types de jetons (divisibles, indivisibles); </li><li>  sécurité des transactions; </li><li>  type d'algorithme de consensus. </li></ul><br>  Les principales variations du plasma comprennent: <br><br><ul><li>  Plasma basé sur UTXO - chaque transaction se compose d'entrées et de sorties.  Une transaction peut être effectuée et dépensée.  La liste des transactions non dépensées est l'état d'une chaîne enfant elle-même. </li><li>  Plasma basé sur les comptes - cette structure contient la réflexion et le solde de chaque compte.  Il est utilisé dans Ethereum, car chaque compte peut être de deux types: un compte d'utilisateur et un compte de contrat intelligent.  La simplicité est un avantage important du Plasma basé sur les comptes.  Dans le même temps, le manque d'évolutivité est un inconvénient.  Une propriété spéciale, "nonce", est utilisée pour empêcher l'exécution d'une transaction deux fois. </li></ul><br>  Afin de comprendre les structures de données utilisées dans la blockchain Plasma Cash et le fonctionnement des engagements, il est nécessaire de clarifier le concept de Merkle Tree. <br><br><h2>  Les arbres Merkle et leur utilisation dans le plasma </h2><br>  Merkle Tree est une structure de données extrêmement importante dans le monde de la blockchain.  Il nous permet de capturer un certain ensemble de données et de masquer les données, tout en prouvant que certaines informations étaient dans l'ensemble.  Par exemple, si nous avons dix nombres, nous pourrions créer une preuve pour ces nombres, puis prouver qu'un certain nombre était dans cet ensemble.  Cette preuve aurait une petite taille constante, ce qui la rend peu coûteuse à publier dans Ethereum. <br><br>  Vous pouvez utiliser ce principe pour un ensemble de transactions et prouver qu'une transaction particulière se trouve dans cet ensemble.  C'est précisément ce que fait un opérateur.  Chaque bloc se compose d'un ensemble de transactions qui se transforme en arbre Merkle.  La racine de cet arbre est une preuve publiée dans Ethereum avec chaque bloc de plasma. <br><br>  Les utilisateurs devraient pouvoir retirer leurs fonds de la chaîne Plasma.  Pour cela, ils envoient une transaction de «sortie» à Ethereum. <br><br>  Plasma Cash utilise un arbre Merkle spécial qui élimine la nécessité de valider un bloc entier.  Il suffit de valider uniquement les branches qui correspondent au jeton de l'utilisateur. <br><br>  Pour transférer un jeton, il est nécessaire d'analyser son historique et d'analyser uniquement les jetons dont un certain utilisateur a besoin.  Lors du transfert d'un jeton, l'utilisateur envoie simplement tout l'historique à un autre utilisateur, qui peut ensuite authentifier tout l'historique et, surtout, le faire très rapidement. <br><br><img src="https://habrastorage.org/webt/l7/tg/iw/l7tgiwwibxyks4m-tv6lmw3cs_a.png"><br><br><h2>  Structures de données Plasma Cash pour le stockage de l'état et de l'historique </h2><br>  Il est conseillé d'utiliser uniquement des arbres Merkle sélectionnés, car il est nécessaire d'obtenir des preuves d'inclusion et de non-inclusion pour une transaction dans un bloc.  Par exemple: <br><br><ul><li>  Arbre de merkle clairsemé </li><li>  Arbre de Patricia </li></ul><br>  Nous avons développé nos propres implémentations Sparse Merkle Tree et Patricia Tree pour notre client. <br><br>  Un arbre Merkle clairsemé est similaire à un arbre Merkle standard, sauf que ses données sont indexées et que chaque point de données est placé sur une feuille qui correspond à l'index de ce point de données. <br><br>  Supposons que nous ayons un arbre Merkle à quatre feuilles.  Remplissons cet arbre avec les lettres A et D, pour démonstration.  La lettre A est la première lettre de l'alphabet, nous allons donc la placer sur la première feuille.  De même, nous placerons D sur la quatrième feuille. <br><br>  Que se passe-t-il donc sur les deuxième et troisième feuilles?  Ils doivent être laissés vides.  Plus précisément, une valeur spéciale (par exemple, zéro) est utilisée à la place d'une lettre. <br><br>  L'arbre ressemble finalement à ceci: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  La preuve d'inclusion fonctionne de la même manière que dans un arbre Merkle normal.  Que se passe-t-il si nous voulons prouver que C ne fait pas partie de cet arbre de Merkle?  Élémentaire!  Nous savons que si C fait partie d'un arbre, ce serait sur la troisième feuille.  Si C ne fait pas partie de l'arbre, alors la troisième feuille doit être nulle. <br><br>  Tout ce qui est nécessaire est une preuve d'inclusion de Merkle standard montrant que la troisième feuille est nulle. <br><br>  La meilleure caractéristique d'un arbre Merkle clairsemé est qu'il fournit des référentiels pour les valeurs-clés à l'intérieur de l'arbre Merkle! <br><br>  Une partie du code du protocole PoE construit un arbre de Merkle clairsemé: <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  Ce code est assez trivial.  Nous avons un référentiel de valeurs-clés avec une preuve d'inclusion / non-inclusion. <br><br>  À chaque itération, un niveau spécifique d'un arbre final est rempli, en commençant par le dernier.  Selon que la clé de la feuille courante est paire ou impaire, nous prenons deux feuilles adjacentes et comptons le hachage du niveau actuel.  Si nous atteignons la fin, nous écririons un seul merkleRoot - un hachage commun. <br><br>  Vous devez comprendre que cet arbre est rempli de valeurs initialement vides.  Si nous stockions une énorme quantité d'ID de jeton, nous aurions une taille d'arbre énorme, et ce serait long! <br><br>  Il existe de nombreux remèdes à cette non-optimisation, mais nous avons décidé de changer cet arbre en arbre Patricia. <br><br>  Un arbre Patricia est une combinaison de Radix Tree et Merkle Tree. <br><br>  Une clé de données Radix Tree stocke le chemin d'accès aux données elles-mêmes, ce qui nous permet de créer une structure de données optimisée pour la mémoire. <br><br><img src="https://habrastorage.org/webt/ox/cz/gc/oxczgcwvxvl2jas44sbtbqophda.png"><br><br>  Voici une implémentation développée pour notre client: <br><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre> <br>  Nous nous sommes déplacés récursivement et avons construit les sous-arbres gauche et droit séparés.  Une clé a été créée comme chemin dans cet arbre. <br><br>  Cette solution est encore plus banale.  Il est bien optimisé et fonctionne plus rapidement.  En fait, un arbre Patricia peut être optimisé encore plus en introduisant de nouveaux types de nœuds - nœud d'extension, nœud de branche, etc., comme cela est fait dans le protocole Ethereum.  Mais l'implémentation actuelle répond à toutes nos exigences - nous avons une structure de données rapide et optimisée en mémoire. <br><br>  En mettant en œuvre ces structures de données dans le projet de notre client, nous avons rendu possible la mise à l'échelle de Plasma Cash.  Cela nous permet de vérifier l'historique d'un jeton et l'inclusion / non-inclusion du jeton dans un arbre, accélérant considérablement la validation des blocs et de la chaîne enfant plasma elle-même. <br><br><h3>  Liens: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plasma papier blanc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Git hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cas d'utilisation et description de l'architecture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Papier réseau Lightning</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455988/">https://habr.com/ru/post/fr455988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455978/index.html">Lambdas: de C ++ 11 à C ++ 20. 2e partie</a></li>
<li><a href="../fr455980/index.html">iOS Digest n ° 7 (31 mai - 13 juin)</a></li>
<li><a href="../fr455982/index.html">Il est temps de remplacer GIF par la vidéo AV1</a></li>
<li><a href="../fr455984/index.html">Comment comprendre que les liens fonctionnent: mesures et création de liens KPI</a></li>
<li><a href="../fr455986/index.html">Pourquoi un technicien informatique devrait-il retirer un cerveau?</a></li>
<li><a href="../fr455990/index.html">CTT dans les solutions serveur - à quoi ressemble-t-il?</a></li>
<li><a href="../fr455994/index.html">L'évolution de l'outil le plus populaire de tout développeur (dans Visual Studio)</a></li>
<li><a href="../fr455996/index.html">Transformation numérique de la publicité dans le réseau de vente au détail. Sur les traces de l'analytique vidéo dans le commerce de détail</a></li>
<li><a href="../fr456000/index.html">Création d'un jeu Tic-Tac-Toe avec TypeScript, React et Mocha</a></li>
<li><a href="../fr456002/index.html">Mémoire dédiée au foyer et intervention OOM Killer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>