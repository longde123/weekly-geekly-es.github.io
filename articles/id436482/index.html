<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôëÔ∏è ü§´ üî∂ Lanjutan Three.js: bahan shader dan pasca-pemrosesan ‚è≥ üñãÔ∏è ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada beberapa pengantar tentang dasar-dasar bekerja dengan Three.js di web, tetapi Anda mungkin melihat kekurangan bahan pada topik yang lebih maju. Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lanjutan Three.js: bahan shader dan pasca-pemrosesan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436482/"><p><img src="https://habrastorage.org/webt/hh/qv/5o/hhqv5okcynxdjke-qqhtmvokjsw.jpeg"></p><br><p>  Ada beberapa pengantar tentang dasar-dasar bekerja dengan Three.js di web, tetapi Anda mungkin melihat kekurangan bahan pada topik yang lebih maju.  Dan salah satu topik ini adalah kombinasi shader dan adegan dengan model tiga dimensi.  Di mata banyak pengembang pemula, ini tampaknya hal-hal yang tidak sesuai dari dunia yang berbeda.  Hari ini, dengan contoh sederhana dari ‚Äúbola plasma‚Äù, kita akan melihat apa itu ShaderMaterial dan dimakan dengan apa, Efek Efek apa itu, dan seberapa cepat mungkin untuk melakukan pasca-pemrosesan untuk adegan yang diberikan. </p><a name="habracut"></a><br><p>  Diasumsikan bahwa pembaca akrab dengan dasar-dasar bekerja dengan Three.js dan memahami cara kerja shader.  Jika Anda belum pernah mengalami ini sebelumnya, maka saya sangat merekomendasikan membaca ini dulu: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Pemrograman Shader untuk Tata Letak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oleskan masker Voronoi mosaik dan geometris di shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi produk tiga dimensi di Three.js untuk yang terkecil</a> </li></ul><br><p>  Tapi mari kita mulai ... </p><br><h2 id="shadermaterial--chto-eto">  ShaderMaterial - apa itu? </h2><br><p>  Kita telah melihat bagaimana tekstur datar digunakan dan bagaimana ia direntangkan pada objek tiga dimensi.  Karena tekstur ini adalah gambar biasa.  Ketika kami memeriksa penulisan fragmen shader, semuanya juga datar di sana.  Jadi: jika kita dapat menghasilkan gambar datar menggunakan shader, lalu mengapa tidak menggunakannya sebagai tekstur? </p><br><p>  Ide inilah yang membentuk dasar untuk bahan shader.  Saat membuat bahan untuk objek tiga dimensi, kami menunjukkan shader alih-alih tekstur untuknya.  Dalam bentuk dasarnya, tampilannya seperti ini: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// ... }, vertexShader: '...', fragmentShader: '...' });</span></span></code> </pre> <br><p>  Shader fragmen akan digunakan untuk membuat tekstur material, dan Anda, tentu saja, bertanya, apa yang akan dilakukan vertex shader?  Apakah dia akan lagi melakukan penghitungan ulang koordinat yang dangkal?  Ya, kami akan mulai dengan opsi sederhana ini, tetapi kami juga dapat mengatur offset atau melakukan manipulasi lain untuk setiap titik objek tiga dimensi - sekarang tidak ada batasan pada pesawat.  Tetapi lebih baik untuk melihat semua ini dengan sebuah contoh.  Dengan kata-kata, sedikit yang dipahami.  Buat adegan dan buat satu bola di tengah. </p><br><p><img src="https://habrastorage.org/webt/ot/0n/zj/ot0nzjfc89iiwsqqdc2isam_woo.jpeg"></p><br><p>  Sebagai bahan untuk bola, kami akan menggunakan ShaderMaterial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereBufferGeometry(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// . . . }, vertexShader: document.getElementById('sphere-vertex-shader').textContent, fragmentShader: document.getElementById('sphere-fragment-shader').textContent }); const sphere = new THREE.Mesh(geometry, shaderMaterial); SCENE.add(sphere);</span></span></code> </pre> <br><p>  Vertex shader akan menjadi netral: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Perhatikan bahwa Three.js melewati variabel seragamnya.  Kami tidak harus melakukan apa pun, mereka tersirat.  Dalam dirinya sendiri, mereka mengandung semua jenis matriks, yang sudah dapat kita akses dari JS, serta posisi kamera.  Bayangkan bahwa di awal shaders sendiri ada sesuatu yang dimasukkan: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// = object.matrixWorld uniform mat4 modelMatrix; // = camera.matrixWorldInverse * object.matrixWorld uniform mat4 modelViewMatrix; // = camera.projectionMatrix uniform mat4 projectionMatrix; // = camera.matrixWorldInverse uniform mat4 viewMatrix; // = inverse transpose of modelViewMatrix uniform mat3 normalMatrix; // = camera position in world space uniform vec3 cameraPosition;</span></span></code> </pre> <br><p>  Selain itu, beberapa variabel atribut diteruskan ke vertex shader: </p><br><pre> <code class="cpp hljs">attribute vec3 position; attribute vec3 normal; attribute vec2 uv;</code> </pre> <br><p>  Dengan namanya jelas apa itu - posisi puncak saat ini, normal ke permukaan pada titik ini, dan koordinat pada tekstur yang sesuai dengan titik tersebut. </p><br><p>  Secara tradisional, koordinat dalam ruang ditetapkan sebagai (x, y, z), dan koordinat pada bidang tekstur sebagai (u, v).  Karenanya nama variabel.  Anda akan sering bertemu dengannya dalam berbagai contoh.  Secara teori, kita perlu mentransfer koordinat ini ke shader fragmen untuk bekerja dengannya di sana.  Kami akan melakukannya. </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Sebagai permulaan, shader fragmen harus seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSILON 0.02 varying vec2 vUv; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((fract(vUv.x * 10.0) &lt; EPSILON) || (fract(vUv.y * 10.0) &lt; EPSILON)) { gl_FragColor = vec4(vec3(0.0), 1.0); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { gl_FragColor = vec4(1.0); } }</span></span></code> </pre> <br><p>  Cukup buat mesh.  Jika Anda berpikir sedikit, maka di pesawat itu hanya akan menjadi kotak kotak, tetapi karena kita menempatkannya pada bola, itu terdistorsi, berubah menjadi bola dunia.  Ada gambar bagus di Wikipedia yang menggambarkan apa yang terjadi: </p><br><p><img src="https://habrastorage.org/webt/uc/uq/us/ucuqusdhqwfubpgtrpujvwq7uww.png"></p><br><p>  Yaitu, dalam fragmen shader kami membuat tekstur rata, seperti di tengah dalam ilustrasi ini, dan Three.js kemudian menariknya pada bola.  Sangat nyaman </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/EGzKOd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tentu saja, untuk model yang lebih kompleks, sapuan akan lebih rumit.  Tetapi biasanya ketika membuat berbagai situs desain kami bekerja dengan bentuk geometris yang sederhana dan mudah untuk membayangkan sapuan di kepala Anda. </p><br><h2 id="ok-a-chto-s-etim-mozhno-delat">  Oke, apa yang bisa Anda lakukan? </h2><br><p>  Fitur utamanya adalah bahan shader dapat berubah seiring waktu.  Ini bukan hal statis yang kita gambar sekali dan lupa, kita bisa menghidupkannya.  Apalagi dalam warna (dalam fragmen shader) dan dalam bentuk (di vertex).  Ini adalah alat yang sangat kuat. </p><br><p>  Dalam contoh kita, kita akan membuat api yang menyelimuti sebuah bola.  Akan ada dua bola - satu biasa (di dalam), dan yang kedua dari bahan shader (di luar, dengan jari-jari besar).  Menambahkan bola lain tidak akan berkomentar. </p><br><p><img src="https://habrastorage.org/webt/ti/_q/4m/ti_q4mo843ywt0fbjdmd8nmrcmy.jpeg"></p><br><p>  Pertama, tambahkan waktu sebagai variabel seragam untuk shader dalam materi kami.  Tidak ada tempat tanpa waktu.  Kami sudah melakukan ini dalam JS murni, tetapi dalam Three.js itu sama sederhana.  Biarkan waktu di shader disebut uTime, dan disimpan dalam variabel TIME: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUniforms</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE.traverse(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh &amp;&amp; child.material.type === <span class="hljs-string"><span class="hljs-string">'ShaderMaterial'</span></span>) { child.material.uniforms.uTime.value = TIME; child.material.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); }</code> </pre> <br><p>  Kami memperbarui semuanya dengan setiap panggilan ke fungsi animate: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); TIME += <span class="hljs-number"><span class="hljs-number">0.005</span></span>; updateUniforms(); render(); }</code> </pre> <br><h2 id="ogon">  Api </h2><br><p>  Menciptakan api pada dasarnya sangat mirip dengan menghasilkan lanskap, tetapi bukannya ketinggian, warna.  Atau transparansi, seperti dalam kasus kami. </p><br><p>  Fungsi untuk keacakan dan kebisingan yang telah kita lihat, kita tidak akan menganalisisnya secara rinci.  Yang perlu kita lakukan adalah membuat suara pada frekuensi yang berbeda untuk menambah variasi, dan membuat masing-masing suara ini bergerak dengan kecepatan yang berbeda.  Anda akan mendapatkan sesuatu seperti api, yang besar bergerak perlahan, yang kecil bergerak lebih cepat: </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 position1 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime); vec2 position2 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">2.0</span></span>); vec2 position3 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color = ( noise(position1 * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + noise(position2 * <span class="hljs-number"><span class="hljs-number">10.0</span></span>) + noise(position3 * <span class="hljs-number"><span class="hljs-number">15.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, color - smoothstep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, vUv.y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 position)</span></span></span><span class="hljs-function"> </span></span>{ vec2 blockPosition = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topLeftValue = rand(blockPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomLeftValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computedValue = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(position)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix(topLeftValue, topRightValue, computedValue.x) + (bottomLeftValue - topLeftValue) * computedValue.y * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - computedValue.x) + (bottomRightValue - topRightValue) * computedValue.x * computedValue.y; }</code> </pre> <br><p>  Agar nyala api tidak menutupi seluruh bola, kami bermain dengan parameter warna keempat - transparansi - dan mengikatnya ke koordinat y.  Dalam kasus kami, opsi ini sangat nyaman.  Dalam istilah yang lebih umum, kami menerapkan gradien dengan transparansi ke noise. </p><br><blockquote>  Pada saat-saat seperti ini, penting untuk mengingat fungsi smoothstep. </blockquote><p>  Secara umum, pendekatan untuk menciptakan api menggunakan shader adalah klasik.  Anda akan sering bertemu dengannya di berbagai tempat.  Ini akan berguna untuk bermain dengan angka-angka ajaib - mereka secara acak diatur dalam contoh, dan bagaimana plasma akan terlihat tergantung pada mereka. </p><br><p>  Untuk membuat api lebih menarik, mari kita beralih ke vertex shader dan sedikit dukun ... </p><br><p>  Bagaimana membuat nyala api sedikit "dituangkan" di ruang angkasa?  Untuk pemula, pertanyaan ini dapat menyebabkan kesulitan besar, meskipun sederhana.  Saya melihat pendekatan yang sangat kompleks untuk memecahkan masalah ini, tetapi pada dasarnya - kita perlu dengan lancar memindahkan simpul pada bola di sepanjang garis "dari pusatnya".  Ke sana kemari, ke sana kemari.  Three.js telah melewati kami pada posisi saat ini dan normal - kami akan menggunakannya.  Untuk "bolak-balik" beberapa fungsi terbatas akan cocok, misalnya, sinus.  Anda tentu saja dapat bereksperimen, tetapi sinus adalah opsi default. </p><br><blockquote>  Tidak tahu apa yang harus diambil - ambil sinus.  Lebih baik lagi, jumlah sinus dengan frekuensi yang berbeda. </blockquote><p>  Kami menggeser koordinat normal ke nilai yang diperoleh dan menghitung ulang sesuai dengan rumus yang diketahui sebelumnya. </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; vec3 delta = normal * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(position.x * position.y * uTime / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); vec3 newPosition = position + delta; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Apa yang kita dapatkan bukan lagi sebuah bidang.  Ini ... Saya bahkan tidak tahu apakah ini memiliki nama.  Tapi, sekali lagi, jangan lupa untuk bermain-main dengan peluang - mereka banyak mempengaruhi.  Ketika membuat efek seperti itu, seringkali sesuatu dipilih dengan cara coba-coba dan sangat berguna untuk mengembangkan "intuisi matematika" dalam diri sendiri - kemampuan untuk sedikit banyak membayangkan bagaimana suatu fungsi berperilaku, bagaimana hal itu tergantung pada variabel mana. </p><br><p>  Pada tahap ini, kita memiliki gambar yang menarik, tapi agak canggung.  Jadi pertama-tama, mari kita lihat post-processing, dan kemudian beralih ke contoh hidup. </p><br><h2 id="postobrabotka">  Pemrosesan pos </h2><br><p>  Kemampuan untuk melakukan sesuatu dengan gambar Three.js yang diberikan adalah hal yang sangat berguna, sementara dilupakan dalam berbagai pelajaran.  Secara teknis, ini diimplementasikan sebagai berikut: gambar yang diberikan renderer kami dikirim ke EffectComposer (selama itu adalah kotak hitam), yang meredam sesuatu dalam dirinya sendiri dan menampilkan gambar akhir di kanvas.  Yaitu, setelah renderer, satu modul lagi ditambahkan.  Kami mentransfer parameter ke komposer ini - apa yang harus dilakukan dengan gambar yang diterima.  Salah satu parameter tersebut disebut pass.  Dalam arti tertentu, komposer bekerja seperti beberapa Gulp - tidak melakukan apa-apa, kami memberikan plugin yang sudah melakukan pekerjaan.  Mungkin tidak sepenuhnya benar untuk mengatakannya, tetapi idenya harus jelas. </p><br><p>  Segala sesuatu yang akan kita gunakan lebih lanjut tidak termasuk dalam struktur dasar Three.js, jadi kami menghubungkan beberapa dependensi dan dependensi dari dependensi itu sendiri: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/EffectComposer.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/RenderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/ShaderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/CopyShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/LuminosityHighPassShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/UnrealBloomPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote>  Ingat bahwa skrip ini termasuk dalam tiga paket dan Anda dapat memasukkan semua ini ke dalam satu bundel menggunakan paket web atau analog. </blockquote><p>  Dalam bentuk dasarnya, komposer dibuat seperti ini: </p><br><pre> <code class="javascript hljs">COMPOSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.EffectComposer(RENDERER); COMPOSER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.RenderPass(SCENE, CAMERA); renderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(renderPass);</code> </pre> <br><p>  RenderPass tidak benar-benar melakukan sesuatu yang baru.  Itu hanya membuat apa yang kita dapatkan dari penyaji biasa.  Bahkan, jika Anda melihat kode sumber RenderPass, maka Anda dapat menemukan renderer standar di sana.  Karena sekarang rendering sedang terjadi di sana, kita perlu mengganti renderer dengan komposer dalam skrip kita: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// RENDERER.render(SCENE, CAMERA); COMPOSER.render(SCENE, CAMERA); }</span></span></code> </pre> <br><p>  Pendekatan ini menggunakan RenderPass sebagai pass pertama adalah praktik standar saat bekerja dengan EffectComposer.  Biasanya kita perlu terlebih dahulu mendapatkan gambar yang diberikan dari adegan itu, kemudian melakukan sesuatu dengannya. </p><br><p>  Pada contoh dari Three.js, di bagian postprocessing, Anda dapat menemukan sesuatu yang disebut UnrealBloomPass.  Ini adalah skrip porting dari mesin Unreal.  Ini menambahkan sedikit cahaya yang dapat digunakan untuk menciptakan pencahayaan yang lebih indah.  Seringkali ini akan menjadi langkah pertama untuk meningkatkan gambar. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bloomPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.UnrealBloomPass( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight), <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); bloomPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(bloomPass);</code> </pre> <br><p>  Harap dicatat: opsi renderToScreen diatur hanya untuk Lulus terakhir yang kami lewati ke komposer. </p><br><p>  Tapi mari kita lihat seperti apa cahaya yang diberikan bloomPass ini dan bagaimana ini cocok dengan bola: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdegG" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Setuju, ini jauh lebih menarik daripada hanya bola dan sumber cahaya biasa, karena biasanya ditunjukkan dalam pelajaran awal di Three.js. </p><br><p>  Tapi kita akan melangkah lebih jauh ... </p><br><h2 id="bolshe-sheyderov-bogu-sheyderov">  Lebih banyak shader ke dewa shader! </h2><br><p><img src="https://habrastorage.org/webt/kk/ap/ks/kkapksi_a_secwfoh81jjxkgtx4.jpeg"></p><br><p>  Sangat berguna untuk menggunakan console.log dan melihat struktur komposer.  Di dalamnya, Anda dapat menemukan beberapa elemen dengan nama renderTarget1, renderTarget2, dll., Di mana angka-angka tersebut sesuai dengan indeks pass yang dilewati.  Dan kemudian menjadi jelas mengapa EffectComposer disebut.  Ini bekerja berdasarkan prinsip filter dalam SVG.  Ingat, di sana Anda dapat menggunakan hasil melakukan beberapa filter di orang lain?  Di sini hal yang sama - Anda dapat menggabungkan efek. </p><br><blockquote>  Menggunakan console.log untuk memahami struktur internal objek Three.js dan banyak perpustakaan lainnya sangat berguna.  Gunakan pendekatan ini lebih sering untuk lebih memahami apa itu apa. </blockquote><p>  Tambahkan pass lain.  Kali ini adalah ShaderPass. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = { <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-attr"><span class="hljs-attr">uRender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: COMPOSER.renderTarget2 }, <span class="hljs-attr"><span class="hljs-attr">uTime</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: TIME } }, <span class="hljs-attr"><span class="hljs-attr">vertexShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-vertex-shader'</span></span>).textContent, <span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-fragment-shader'</span></span>).textContent }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderPass(shader); shaderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(shaderPass);</code> </pre> <br><p>  RenderTarget2 berisi hasil dari pass sebelumnya - bloomPass (itu yang kedua berturut-turut), kami menggunakannya sebagai tekstur (ini pada dasarnya adalah gambar yang diberikan datar) dan meneruskannya sebagai variabel seragam ke shader baru. </p><br><p>  Mungkin perlu direm dan menyadari semua keajaiban di sini ... </p><br><p>  Selanjutnya, buat shader vertex sederhana.  Dalam kebanyakan kasus, pada tahap ini, kita tidak perlu melakukan apa pun dengan simpul, kita hanya meneruskan koordinat (u, v) ke shader fragmen: </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Dan secara terpisah kita bisa bersenang-senang dengan selera dan warna kita.  Misalnya, kita dapat menambahkan efek kesalahan cahaya, membuat semuanya hitam dan putih dan bermain dengan kecerahan / kontras: </p><br><pre> <code class="cpp hljs">uniform sampler2D uRender; uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randomValue = rand(vec2(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(vUv.y * <span class="hljs-number"><span class="hljs-number">7.0</span></span>), uTime / <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec4 color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomValue &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { color = texture2D(uRender, vec2(vUv.x + randomValue - <span class="hljs-number"><span class="hljs-number">0.01</span></span>, vUv.y)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { color = texture2D(uRender, vUv); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightness = (color.r + color.g + color.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; color.rgb = vec3(smoothstep(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, lightness)); gl_FragColor = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre> <br><p>  Mari kita lihat hasilnya: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdeKB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Seperti yang Anda lihat, filter ditumpangkan di bola.  Itu masih tiga dimensi, tidak ada yang rusak, tetapi di kanvas kami memiliki gambar yang diproses. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Bahan shader dan pasca-pemrosesan di Three.js adalah dua alat kecil namun sangat kuat yang pasti layak digunakan.  Ada banyak opsi untuk penggunaannya - semuanya dibatasi oleh imajinasi Anda.  Bahkan adegan paling sederhana dengan bantuan mereka dapat diubah tanpa bisa dikenali. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436482/">https://habr.com/ru/post/id436482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436468/index.html">Eksperimen legislatif dengan inovasi digital</a></li>
<li><a href="../id436472/index.html">Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows. Bagian 1</a></li>
<li><a href="../id436474/index.html">Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows. Bagian 2</a></li>
<li><a href="../id436476/index.html">Cloud untuk perusahaan asuransi</a></li>
<li><a href="../id436480/index.html">Saya membuat bot yang berkomunikasi dengan perekrut untuk saya, dan saya suka</a></li>
<li><a href="../id436484/index.html">Di mana menemukan pengaturan DNS pada MacOS</a></li>
<li><a href="../id436486/index.html">Apa yang terjadi di pasar podcast audio</a></li>
<li><a href="../id436488/index.html">Aplikasi kari dan sebagian dalam C ++ 14</a></li>
<li><a href="../id436490/index.html">Motorola berencana untuk memperkenalkan inkarnasi Razr v3</a></li>
<li><a href="../id436492/index.html">Kami mencari pembicara di Mitap DIY ke-10 17 Februari 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>