<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤑 📊 👩🏿‍🤝‍👩🏼 Hash-Tabellen in Go. Implementierungsdetails 🚦 🕺 ▫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden die Implementierung von Map in einer Sprache ohne Generika diskutieren, überlegen, was eine Hash-Tabelle ist, wie sie in Go angeordnet ist,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hash-Tabellen in Go. Implementierungsdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="Bild" width="400" height="400"></div><br><br>  Wir werden die Implementierung von Map in einer Sprache ohne Generika diskutieren, überlegen, was eine Hash-Tabelle ist, wie sie in Go angeordnet ist, welche Vor- und Nachteile diese Implementierung hat und worauf Sie bei der Verwendung dieser Struktur achten sollten. <br><br>  Details unter dem Schnitt. <br><a name="habracut"></a><br><hr><br>  Achtung!  Wenn Sie bereits mit Hash-Tabellen in Go vertraut sind, empfehle ich Ihnen, die Grundlagen zu überspringen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher zu</a> gehen. Andernfalls besteht die Gefahr, dass Sie den interessantesten Moment satt haben. <br><br><h4>  Was ist eine Hash-Tabelle? </h4><br>  Zunächst möchte ich Sie daran erinnern, was eine Hash-Tabelle ist.  Dies ist eine Datenstruktur, mit der Sie Schlüssel-Wert-Paare speichern können und in der Regel über folgende Funktionen verfügen: <br><br><ul><li>  Zuordnung: <code>map(key) → value</code> <br></li><li>  <code>insert(map, key, value)</code> : <code>insert(map, key, value)</code> <br></li><li>  Löschungen: <code>delete(map, key)</code> <br></li><li>  Suche: <code>lookup(key) → value</code> <br></li></ul><br><h4>  Hash-Tabelle in Go-Sprache </h4><br>  Eine Hash-Tabelle in der Sprache go wird durch das Schlüsselwort map dargestellt und kann auf eine der folgenden Arten deklariert werden (dazu später mehr): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Die Hauptoperationen werden wie folgt ausgeführt: <br><br><ul><li>  Einfügen: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Entfernung: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  Suche: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  oder <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Gehen Sie um einen Tisch herum </h4><br>  Betrachten Sie das folgende Programm: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Start 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Lauf 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Wie Sie sehen können, variiert die Ausgabe von Lauf zu Lauf.  Und das alles, weil die Karte in Go ungeordnet ist, dh nicht geordnet.  Dies bedeutet, dass Sie sich beim Herumlaufen nicht auf Ordnung verlassen müssen.  Der Grund kann im Quellcode der Sprachlaufzeit gefunden werden: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  Der Suchort wird <b>zufällig</b> bestimmt, denken Sie daran!  Gerüchten zufolge zwingen Laufzeitentwickler Benutzer dazu, sich nicht auf die Reihenfolge zu verlassen. <br><br><h4>  Gehen Sie zur Tabellensuche </h4><br>  Schauen wir uns noch einmal einen Code an.  Angenommen, wir möchten Paare "Nummer" - "Nummer mal 10" erstellen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Wir starten: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Und wir sehen, dass wir beim Versuch, den Wert von zwei zu erhalten (den wir vergessen haben zu setzen), 0 erhalten haben. In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> finden wir Zeilen, die dieses Verhalten erklären: „Ein Versuch, einen Kartenwert mit einem Schlüssel abzurufen, der nicht in der Karte vorhanden ist, gibt den Wert Null für zurück der Typ der Einträge in der Karte. “, aber ins Russische übersetzt, bedeutet dies, dass wir, wenn wir versuchen, den Wert von der Karte zu erhalten, aber nicht vorhanden sind, einen„ Wert vom Typ Null “erhalten, der im Fall der Zahl 0 gilt. ob wir zwischen den Fällen 0 und 2 unterscheiden wollen?  Zu diesem Zweck haben wir eine spezielle Form der "Mehrfachzuweisung" entwickelt - eine Form, bei der die Karte anstelle des üblichen Einzelwerts ein Paar zurückgibt: den Wert selbst und einen anderen Booleschen Wert, der die Frage beantwortet, ob der angeforderte Schlüssel in der Karte vorhanden ist oder nicht. <br><br>  Richtig sieht der vorherige Code folgendermaßen aus: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Und beim Start bekommen wir: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Erstellen Sie eine Tabelle in Go. </h4><br>  Angenommen, wir möchten die Anzahl der Vorkommen jedes Wortes in einer Zeichenfolge zählen, ein Wörterbuch dafür starten und es durchgehen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  Sehen Sie einen <s>Gopher-</s> Fang?  - Und er ist! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="Bild" width="200" height="400"></div><br>  Wenn wir versuchen, ein solches Programm zu starten, bekommen wir eine Panik und die Meldung "Zuordnung zum Eintrag in keine Karte".  Und alles, da mapa ein Referenztyp ist und es nicht ausreicht, eine Variable zu deklarieren, müssen Sie sie initialisieren: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Etwas tiefer wird klar, warum dies so funktioniert.  Zu Beginn wurden bereits vier Möglichkeiten zum Erstellen einer Karte vorgestellt, von denen zwei von uns untersucht wurden - diese Deklaration als Variable und die Erstellung durch make.  Sie können auch mit dem Design " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammengesetzte Literale</a> " erstellen <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  Wenn Sie möchten, können Sie diese Methode auch sofort mit Werten initialisieren.  Was die Erstellung mit new betrifft, ist dies meiner Meinung nach nicht sinnvoll, da diese Funktion Speicher für eine Variable reserviert und einen Zeiger darauf zurückgibt, der mit einem Nullwert des Typs gefüllt ist, der im Fall von map null ist (wir erhalten das gleiche Ergebnis wie in var genauer gesagt ein Zeiger darauf). <br><a name="GoMap"></a><br><h4>  Wie wird die Karte an eine Funktion übergeben? </h4><br>  Angenommen, wir haben eine Funktion, die versucht, die an sie übergebene Nummer zu ändern.  Mal sehen, was vor und nach dem Anruf passiert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Ein Beispiel, denke ich, ist ziemlich offensichtlich, enthält aber immer noch die Schlussfolgerung: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Wie Sie wahrscheinlich vermutet haben, wurde die Funktion n nach Wert und nicht nach Referenz angegeben, sodass sich die ursprüngliche Variable nicht geändert hat. <br><br>  Machen wir einen ähnlichen Mapa-Trick: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Und siehe da: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Der Wert hat sich geändert.  "Nun, Mapa wird als Referenz übergeben?", Fragen Sie.  <b>Nein.</b>  Es gibt keine Links in Go.  Es ist unmöglich, 2 Variablen mit 1 Adresse zu erstellen, wie zum Beispiel in C ++.  Dann können Sie jedoch zwei Variablen erstellen, die auf dieselbe Adresse verweisen (dies sind jedoch Zeiger, und sie befinden sich in Go). <br><br>  Angenommen, wir haben eine Funktion fn, die die Karte m initialisiert.  In der Hauptfunktion deklarieren wir einfach eine Variable, senden sie zur Initialisierung und schauen, was danach passiert ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Fazit: <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Die Variable m wurde also als <b>Wert übergeben</b> , daher änderte sie sich nicht, wie im Fall der Übergabe eines regulären int an die Funktion (die lokale Kopie des Werts in fn wurde geändert).  Warum ändert sich dann der in m selbst liegende Wert?  Betrachten Sie zur Beantwortung dieser Frage den Code aus der Sprachlaufzeit: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go ist nur ein Zeiger auf die hmap-Struktur.  Dies ist die Antwort auf die Frage, warum sich die Werte selbst ändern, obwohl die Karte als Wert an die Funktion übergeben wird - es geht nur um den Zeiger.  Die hmap-Struktur enthält außerdem Folgendes: die Anzahl der Elemente, die Anzahl der „Buckets“ (dargestellt als Logarithmus zur Beschleunigung der Berechnungen), Startwert für die Randomisierung von Hashes (um das Hinzufügen zu erschweren - versuchen Sie, Schlüssel so aufzunehmen, dass es zu kontinuierlichen Kollisionen kommt), alle Arten von Servicefeldern und vor allem ein Zeiger auf Buckets, in denen die Werte gespeichert sind.  Schauen wir uns das Bild an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="Bild"><br><br>  Das Bild zeigt ein schematisches Bild der Struktur im Speicher - es gibt einen hmap-Header, dessen Zeiger eine Karte in Go ist (sie wird erstellt, wenn sie mit var deklariert wird, aber nicht initialisiert, was dazu führt, dass das Programm beim Versuch, sie einzufügen, abstürzt).  Das Buckets-Feld ist ein Repository von Schlüssel-Wert-Paaren. Es gibt mehrere solcher Buckets, die jeweils 8 Paare enthalten.  Zuerst im "Bucket" befinden sich Slots für zusätzliche Hash-Bits (e0..e7 heißt e - weil <i>zusätzliche</i> Hash-Bits).  Als nächstes werden die Schlüssel und Werte zuerst als Liste aller Schlüssel und dann als Liste aller Werte angezeigt. <br><br>  Der Hash der Funktion bestimmt, in welchen Bucket wir den Wert eingeben. In jedem Bucket können bis zu 8 Kollisionen auftreten. Am Ende jedes Buckets befindet sich ein Zeiger auf einen weiteren, wenn der vorherige überläuft. <br><br><h4>  Wie wächst die Karte? </h4><br>  Im Quellcode finden Sie die Zeile: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  Das heißt, wenn in jedem Bucket durchschnittlich mehr als 6,5 Elemente vorhanden sind, tritt eine Erhöhung des Buckets-Arrays auf.  In diesem Fall wird das Array zweimal mehr zugewiesen, und die alten Daten werden bei jedem Einfügen oder Löschen in kleinen Abschnitten in das Array kopiert, um keine sehr großen Verzögerungen zu verursachen.  Daher werden alle Vorgänge beim Evakuieren von Daten etwas langsamer sein (auch bei der Suche müssen wir an zwei Stellen suchen).  Nach einer erfolgreichen Evakuierung werden neue Daten verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="Bild" width="300" height="300"></div><br><h4>  Nehmen Sie die Adresse des Kartenelements. </h4><br>  Ein weiterer interessanter Punkt - ganz am Anfang der Verwendung der Sprache, die ich so machen wollte: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Aber Go sagt: "Ich kann die Adresse von m [1] nicht annehmen."  Die Erklärung, warum es unmöglich ist, die Adresse des Wertes zu ermitteln, liegt im Datenevakuierungsverfahren.  Stellen Sie sich vor, wir haben die Adresse des Werts genommen, und dann ist die Mapa gewachsen, neuer Speicher wurde zugewiesen, die Daten wurden evakuiert, die alten wurden gelöscht, der Zeiger wurde falsch, sodass solche Vorgänge verboten sind. <br><br><h4>  Wie wird Map ohne Generika implementiert? </h4><br>  Weder eine leere Schnittstelle noch die Codegenerierung haben etwas damit zu tun. Das Ganze besteht darin, sie beim Kompilieren zu ersetzen.  Überlegen Sie, was aus den bekannten Funktionen von Go wird: <br><br><pre> <code class="plaintext hljs">v := m["k"] → func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] → func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 → func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") → func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Wir sehen, dass es Mapaccess-Funktionen für Zugriffe zum Schreiben und Löschen von Mapassign bzw. Mapdelete gibt.  Alle Operationen verwenden unsafe.Pointer, wobei es egal ist, auf welchen Typ er zeigt, und Informationen zu jedem Wert werden durch einen Typdeskriptor beschrieben. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType speichert die Deskriptoren (_type) des Schlüssels und des Werts.  Für einen Typdeskriptor werden Vergleichsoperationen (typeAlg) definiert, die einen Hash, eine Größe usw. verwenden, sodass wir immer wissen, wie sie erstellt werden. <br><br>  Ein bisschen mehr darüber, wie es funktioniert.  Wenn wir v = m [k] schreiben (versuchen, den Wert von v aus dem Schlüssel k zu erhalten), generiert der Compiler Folgendes: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Das heißt, wir nehmen einen Zeiger auf einen Schlüssel, die mapType-Struktur, aus der wir herausfinden, welche Deskriptoren des Schlüssels und des Werts, den Zeiger auf hmap selbst (dh map), und übergeben alles an mapaccess1, wodurch ein Zeiger auf den Wert zurückgegeben wird.  Wir setzen den Zeiger auf den gewünschten Typ, dereferenzieren und erhalten den Wert. <br><br>  Schauen wir uns nun den Suchcode aus der Laufzeit an (der zum Lesen leicht angepasst ist): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  Die Funktion sucht nach dem Schlüssel in der Zuordnung und gibt einen Zeiger auf den entsprechenden Wert zurück. Die Argumente sind uns bereits bekannt. Dies ist mapType, in dem Deskriptoren der Schlüsseltypen und -werte gespeichert werden, map selbst (mapHeader) und ein Zeiger auf den Speicher, in dem der Schlüssel gespeichert ist.  Wir geben einen Zeiger auf den Speicher zurück, in dem der Wert gespeichert ist. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  Als nächstes prüfen wir, ob der Zeiger auf den Map-Header nicht null ist, wenn dort 0 Elemente vorhanden sind, und geben gegebenenfalls einen Nullwert zurück. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Wir berechnen den Schlüssel-Hash (wir wissen, wie man für einen bestimmten Schlüssel aus einem Typdeskriptor berechnet).  Dann versuchen wir zu verstehen, welchen „Eimer“ Sie sehen müssen (der Rest der Division durch die Anzahl der „Eimer“ wird nur geringfügig beschleunigt).  Dann berechnen wir den zusätzlichen Hash (wir nehmen die 8 höchstwertigen Bits des Hash) und bestimmen die Position des „Buckets“ im Speicher (Adressarithmetik). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  Die Suche ist nicht so kompliziert: Wir gehen die Ketten der "Eimer" durch und fahren mit der nächsten fort, wenn Sie sie nicht gefunden haben.  Die Suche im "Bucket" beginnt mit einem schnellen Vergleich des zusätzlichen Hashs (deshalb sind diese e0 ... e7 am Anfang eines jeden ein "Mini" -Hash des Paares für einen schnellen Vergleich).  Wenn es nicht übereinstimmt, gehen Sie weiter, wenn dies der Fall ist, überprüfen wir es genauer - wir bestimmen, wo der Schlüssel, nach dem gesucht wird, im Speicher liegt, und vergleichen, ob er dem entspricht, was angefordert wurde.  Wenn gleich, bestimmen Sie die Position des Werts im Speicher und kehren Sie zurück.  Wie Sie sehen können, nichts Übernatürliches. <br><br><h4>  Fazit </h4><br>  Verwenden Sie Karten, aber wissen und verstehen Sie, wie sie funktionieren!  Sie können den Rake vermeiden, indem Sie einige der Feinheiten verstehen - warum Sie die Adresse des Werts nicht übernehmen können, warum während der Deklaration alles ohne Initialisierung fällt, warum es besser ist, Speicher im Voraus zuzuweisen, wenn die Anzahl der Elemente bekannt ist (wir werden Evakuierungen vermeiden) und vieles mehr. <br><br><hr><br>  Referenzliste: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Go Maps in Aktion", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Wie die Go-Laufzeit Karten effizient implementiert“, sagt Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Typ in go verstehen", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Innerhalb der Kartenimplementierung Keith Randall</a> <br>  <a href="">Kartenquellcode, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang spec</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">effektiv gehen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gopher-Bilder</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457728/">https://habr.com/ru/post/de457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457714/index.html">Stapelüberlauf in Englisch: Community Kill Guide</a></li>
<li><a href="../de457718/index.html">HyperCard, das verlorene Glied in der Entwicklung des Web</a></li>
<li><a href="../de457720/index.html">Autodesk Maya: Nützliche Grundfunktionen für die Arbeit mit 3D-Modellen</a></li>
<li><a href="../de457722/index.html">SQL: Zeiterfassung Problem: Nachbesprechung</a></li>
<li><a href="../de457724/index.html">OpenCV auf STM32F7-Discovery</a></li>
<li><a href="../de457730/index.html">Im Büro gibt es eine Illusion der Kontrolle - es ist nicht auf der Fernbedienung. Gespräch mit Devhab</a></li>
<li><a href="../de457734/index.html">Italien Open Source Revolution beginnt</a></li>
<li><a href="../de457736/index.html">"Tools sind nicht so wichtig wie die Fähigkeit, über die von ihnen erstellten Systeme nachzudenken." Tolles Interview mit Martin Kleppman</a></li>
<li><a href="../de457738/index.html">Wie wir SD-Access implementiert haben und warum es benötigt wurde</a></li>
<li><a href="../de457742/index.html">Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden für hohe Verfügbarkeit und Verfügbarkeit der Infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>