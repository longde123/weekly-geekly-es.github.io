<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ë üìä üë©üèø‚Äçü§ù‚Äçüë©üèº Hash-Tabellen in Go. Implementierungsdetails üö¶ üï∫ ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden die Implementierung von Map in einer Sprache ohne Generika diskutieren, √ºberlegen, was eine Hash-Tabelle ist, wie sie in Go angeordnet ist,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hash-Tabellen in Go. Implementierungsdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="Bild" width="400" height="400"></div><br><br>  Wir werden die Implementierung von Map in einer Sprache ohne Generika diskutieren, √ºberlegen, was eine Hash-Tabelle ist, wie sie in Go angeordnet ist, welche Vor- und Nachteile diese Implementierung hat und worauf Sie bei der Verwendung dieser Struktur achten sollten. <br><br>  Details unter dem Schnitt. <br><a name="habracut"></a><br><hr><br>  Achtung!  Wenn Sie bereits mit Hash-Tabellen in Go vertraut sind, empfehle ich Ihnen, die Grundlagen zu √ºberspringen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher zu</a> gehen. Andernfalls besteht die Gefahr, dass Sie den interessantesten Moment satt haben. <br><br><h4>  Was ist eine Hash-Tabelle? </h4><br>  Zun√§chst m√∂chte ich Sie daran erinnern, was eine Hash-Tabelle ist.  Dies ist eine Datenstruktur, mit der Sie Schl√ºssel-Wert-Paare speichern k√∂nnen und in der Regel √ºber folgende Funktionen verf√ºgen: <br><br><ul><li>  Zuordnung: <code>map(key) ‚Üí value</code> <br></li><li>  <code>insert(map, key, value)</code> : <code>insert(map, key, value)</code> <br></li><li>  L√∂schungen: <code>delete(map, key)</code> <br></li><li>  Suche: <code>lookup(key) ‚Üí value</code> <br></li></ul><br><h4>  Hash-Tabelle in Go-Sprache </h4><br>  Eine Hash-Tabelle in der Sprache go wird durch das Schl√ºsselwort map dargestellt und kann auf eine der folgenden Arten deklariert werden (dazu sp√§ter mehr): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Die Hauptoperationen werden wie folgt ausgef√ºhrt: <br><br><ul><li>  Einf√ºgen: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Entfernung: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  Suche: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  oder <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Gehen Sie um einen Tisch herum </h4><br>  Betrachten Sie das folgende Programm: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Start 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Lauf 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Wie Sie sehen k√∂nnen, variiert die Ausgabe von Lauf zu Lauf.  Und das alles, weil die Karte in Go ungeordnet ist, dh nicht geordnet.  Dies bedeutet, dass Sie sich beim Herumlaufen nicht auf Ordnung verlassen m√ºssen.  Der Grund kann im Quellcode der Sprachlaufzeit gefunden werden: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  Der Suchort wird <b>zuf√§llig</b> bestimmt, denken Sie daran!  Ger√ºchten zufolge zwingen Laufzeitentwickler Benutzer dazu, sich nicht auf die Reihenfolge zu verlassen. <br><br><h4>  Gehen Sie zur Tabellensuche </h4><br>  Schauen wir uns noch einmal einen Code an.  Angenommen, wir m√∂chten Paare "Nummer" - "Nummer mal 10" erstellen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Wir starten: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Und wir sehen, dass wir beim Versuch, den Wert von zwei zu erhalten (den wir vergessen haben zu setzen), 0 erhalten haben. In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> finden wir Zeilen, die dieses Verhalten erkl√§ren: ‚ÄûEin Versuch, einen Kartenwert mit einem Schl√ºssel abzurufen, der nicht in der Karte vorhanden ist, gibt den Wert Null f√ºr zur√ºck der Typ der Eintr√§ge in der Karte. ‚Äú, aber ins Russische √ºbersetzt, bedeutet dies, dass wir, wenn wir versuchen, den Wert von der Karte zu erhalten, aber nicht vorhanden sind, einen‚Äû Wert vom Typ Null ‚Äúerhalten, der im Fall der Zahl 0 gilt. ob wir zwischen den F√§llen 0 und 2 unterscheiden wollen?  Zu diesem Zweck haben wir eine spezielle Form der "Mehrfachzuweisung" entwickelt - eine Form, bei der die Karte anstelle des √ºblichen Einzelwerts ein Paar zur√ºckgibt: den Wert selbst und einen anderen Booleschen Wert, der die Frage beantwortet, ob der angeforderte Schl√ºssel in der Karte vorhanden ist oder nicht. <br><br>  Richtig sieht der vorherige Code folgenderma√üen aus: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Und beim Start bekommen wir: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Erstellen Sie eine Tabelle in Go. </h4><br>  Angenommen, wir m√∂chten die Anzahl der Vorkommen jedes Wortes in einer Zeichenfolge z√§hlen, ein W√∂rterbuch daf√ºr starten und es durchgehen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  Sehen Sie einen <s>Gopher-</s> Fang?  - Und er ist! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="Bild" width="200" height="400"></div><br>  Wenn wir versuchen, ein solches Programm zu starten, bekommen wir eine Panik und die Meldung "Zuordnung zum Eintrag in keine Karte".  Und alles, da mapa ein Referenztyp ist und es nicht ausreicht, eine Variable zu deklarieren, m√ºssen Sie sie initialisieren: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Etwas tiefer wird klar, warum dies so funktioniert.  Zu Beginn wurden bereits vier M√∂glichkeiten zum Erstellen einer Karte vorgestellt, von denen zwei von uns untersucht wurden - diese Deklaration als Variable und die Erstellung durch make.  Sie k√∂nnen auch mit dem Design " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammengesetzte Literale</a> " erstellen <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  Wenn Sie m√∂chten, k√∂nnen Sie diese Methode auch sofort mit Werten initialisieren.  Was die Erstellung mit new betrifft, ist dies meiner Meinung nach nicht sinnvoll, da diese Funktion Speicher f√ºr eine Variable reserviert und einen Zeiger darauf zur√ºckgibt, der mit einem Nullwert des Typs gef√ºllt ist, der im Fall von map null ist (wir erhalten das gleiche Ergebnis wie in var genauer gesagt ein Zeiger darauf). <br><a name="GoMap"></a><br><h4>  Wie wird die Karte an eine Funktion √ºbergeben? </h4><br>  Angenommen, wir haben eine Funktion, die versucht, die an sie √ºbergebene Nummer zu √§ndern.  Mal sehen, was vor und nach dem Anruf passiert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Ein Beispiel, denke ich, ist ziemlich offensichtlich, enth√§lt aber immer noch die Schlussfolgerung: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Wie Sie wahrscheinlich vermutet haben, wurde die Funktion n nach Wert und nicht nach Referenz angegeben, sodass sich die urspr√ºngliche Variable nicht ge√§ndert hat. <br><br>  Machen wir einen √§hnlichen Mapa-Trick: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Und siehe da: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Der Wert hat sich ge√§ndert.  "Nun, Mapa wird als Referenz √ºbergeben?", Fragen Sie.  <b>Nein.</b>  Es gibt keine Links in Go.  Es ist unm√∂glich, 2 Variablen mit 1 Adresse zu erstellen, wie zum Beispiel in C ++.  Dann k√∂nnen Sie jedoch zwei Variablen erstellen, die auf dieselbe Adresse verweisen (dies sind jedoch Zeiger, und sie befinden sich in Go). <br><br>  Angenommen, wir haben eine Funktion fn, die die Karte m initialisiert.  In der Hauptfunktion deklarieren wir einfach eine Variable, senden sie zur Initialisierung und schauen, was danach passiert ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Fazit: <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Die Variable m wurde also als <b>Wert √ºbergeben</b> , daher √§nderte sie sich nicht, wie im Fall der √úbergabe eines regul√§ren int an die Funktion (die lokale Kopie des Werts in fn wurde ge√§ndert).  Warum √§ndert sich dann der in m selbst liegende Wert?  Betrachten Sie zur Beantwortung dieser Frage den Code aus der Sprachlaufzeit: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go ist nur ein Zeiger auf die hmap-Struktur.  Dies ist die Antwort auf die Frage, warum sich die Werte selbst √§ndern, obwohl die Karte als Wert an die Funktion √ºbergeben wird - es geht nur um den Zeiger.  Die hmap-Struktur enth√§lt au√üerdem Folgendes: die Anzahl der Elemente, die Anzahl der ‚ÄûBuckets‚Äú (dargestellt als Logarithmus zur Beschleunigung der Berechnungen), Startwert f√ºr die Randomisierung von Hashes (um das Hinzuf√ºgen zu erschweren - versuchen Sie, Schl√ºssel so aufzunehmen, dass es zu kontinuierlichen Kollisionen kommt), alle Arten von Servicefeldern und vor allem ein Zeiger auf Buckets, in denen die Werte gespeichert sind.  Schauen wir uns das Bild an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="Bild"><br><br>  Das Bild zeigt ein schematisches Bild der Struktur im Speicher - es gibt einen hmap-Header, dessen Zeiger eine Karte in Go ist (sie wird erstellt, wenn sie mit var deklariert wird, aber nicht initialisiert, was dazu f√ºhrt, dass das Programm beim Versuch, sie einzuf√ºgen, abst√ºrzt).  Das Buckets-Feld ist ein Repository von Schl√ºssel-Wert-Paaren. Es gibt mehrere solcher Buckets, die jeweils 8 Paare enthalten.  Zuerst im "Bucket" befinden sich Slots f√ºr zus√§tzliche Hash-Bits (e0..e7 hei√üt e - weil <i>zus√§tzliche</i> Hash-Bits).  Als n√§chstes werden die Schl√ºssel und Werte zuerst als Liste aller Schl√ºssel und dann als Liste aller Werte angezeigt. <br><br>  Der Hash der Funktion bestimmt, in welchen Bucket wir den Wert eingeben. In jedem Bucket k√∂nnen bis zu 8 Kollisionen auftreten. Am Ende jedes Buckets befindet sich ein Zeiger auf einen weiteren, wenn der vorherige √ºberl√§uft. <br><br><h4>  Wie w√§chst die Karte? </h4><br>  Im Quellcode finden Sie die Zeile: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  Das hei√üt, wenn in jedem Bucket durchschnittlich mehr als 6,5 Elemente vorhanden sind, tritt eine Erh√∂hung des Buckets-Arrays auf.  In diesem Fall wird das Array zweimal mehr zugewiesen, und die alten Daten werden bei jedem Einf√ºgen oder L√∂schen in kleinen Abschnitten in das Array kopiert, um keine sehr gro√üen Verz√∂gerungen zu verursachen.  Daher werden alle Vorg√§nge beim Evakuieren von Daten etwas langsamer sein (auch bei der Suche m√ºssen wir an zwei Stellen suchen).  Nach einer erfolgreichen Evakuierung werden neue Daten verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="Bild" width="300" height="300"></div><br><h4>  Nehmen Sie die Adresse des Kartenelements. </h4><br>  Ein weiterer interessanter Punkt - ganz am Anfang der Verwendung der Sprache, die ich so machen wollte: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Aber Go sagt: "Ich kann die Adresse von m [1] nicht annehmen."  Die Erkl√§rung, warum es unm√∂glich ist, die Adresse des Wertes zu ermitteln, liegt im Datenevakuierungsverfahren.  Stellen Sie sich vor, wir haben die Adresse des Werts genommen, und dann ist die Mapa gewachsen, neuer Speicher wurde zugewiesen, die Daten wurden evakuiert, die alten wurden gel√∂scht, der Zeiger wurde falsch, sodass solche Vorg√§nge verboten sind. <br><br><h4>  Wie wird Map ohne Generika implementiert? </h4><br>  Weder eine leere Schnittstelle noch die Codegenerierung haben etwas damit zu tun. Das Ganze besteht darin, sie beim Kompilieren zu ersetzen.  √úberlegen Sie, was aus den bekannten Funktionen von Go wird: <br><br><pre> <code class="plaintext hljs">v := m["k"] ‚Üí func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] ‚Üí func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 ‚Üí func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") ‚Üí func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Wir sehen, dass es Mapaccess-Funktionen f√ºr Zugriffe zum Schreiben und L√∂schen von Mapassign bzw. Mapdelete gibt.  Alle Operationen verwenden unsafe.Pointer, wobei es egal ist, auf welchen Typ er zeigt, und Informationen zu jedem Wert werden durch einen Typdeskriptor beschrieben. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType speichert die Deskriptoren (_type) des Schl√ºssels und des Werts.  F√ºr einen Typdeskriptor werden Vergleichsoperationen (typeAlg) definiert, die einen Hash, eine Gr√∂√üe usw. verwenden, sodass wir immer wissen, wie sie erstellt werden. <br><br>  Ein bisschen mehr dar√ºber, wie es funktioniert.  Wenn wir v = m [k] schreiben (versuchen, den Wert von v aus dem Schl√ºssel k zu erhalten), generiert der Compiler Folgendes: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Das hei√üt, wir nehmen einen Zeiger auf einen Schl√ºssel, die mapType-Struktur, aus der wir herausfinden, welche Deskriptoren des Schl√ºssels und des Werts, den Zeiger auf hmap selbst (dh map), und √ºbergeben alles an mapaccess1, wodurch ein Zeiger auf den Wert zur√ºckgegeben wird.  Wir setzen den Zeiger auf den gew√ºnschten Typ, dereferenzieren und erhalten den Wert. <br><br>  Schauen wir uns nun den Suchcode aus der Laufzeit an (der zum Lesen leicht angepasst ist): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  Die Funktion sucht nach dem Schl√ºssel in der Zuordnung und gibt einen Zeiger auf den entsprechenden Wert zur√ºck. Die Argumente sind uns bereits bekannt. Dies ist mapType, in dem Deskriptoren der Schl√ºsseltypen und -werte gespeichert werden, map selbst (mapHeader) und ein Zeiger auf den Speicher, in dem der Schl√ºssel gespeichert ist.  Wir geben einen Zeiger auf den Speicher zur√ºck, in dem der Wert gespeichert ist. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  Als n√§chstes pr√ºfen wir, ob der Zeiger auf den Map-Header nicht null ist, wenn dort 0 Elemente vorhanden sind, und geben gegebenenfalls einen Nullwert zur√ºck. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Wir berechnen den Schl√ºssel-Hash (wir wissen, wie man f√ºr einen bestimmten Schl√ºssel aus einem Typdeskriptor berechnet).  Dann versuchen wir zu verstehen, welchen ‚ÄûEimer‚Äú Sie sehen m√ºssen (der Rest der Division durch die Anzahl der ‚ÄûEimer‚Äú wird nur geringf√ºgig beschleunigt).  Dann berechnen wir den zus√§tzlichen Hash (wir nehmen die 8 h√∂chstwertigen Bits des Hash) und bestimmen die Position des ‚ÄûBuckets‚Äú im Speicher (Adressarithmetik). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  Die Suche ist nicht so kompliziert: Wir gehen die Ketten der "Eimer" durch und fahren mit der n√§chsten fort, wenn Sie sie nicht gefunden haben.  Die Suche im "Bucket" beginnt mit einem schnellen Vergleich des zus√§tzlichen Hashs (deshalb sind diese e0 ... e7 am Anfang eines jeden ein "Mini" -Hash des Paares f√ºr einen schnellen Vergleich).  Wenn es nicht √ºbereinstimmt, gehen Sie weiter, wenn dies der Fall ist, √ºberpr√ºfen wir es genauer - wir bestimmen, wo der Schl√ºssel, nach dem gesucht wird, im Speicher liegt, und vergleichen, ob er dem entspricht, was angefordert wurde.  Wenn gleich, bestimmen Sie die Position des Werts im Speicher und kehren Sie zur√ºck.  Wie Sie sehen k√∂nnen, nichts √úbernat√ºrliches. <br><br><h4>  Fazit </h4><br>  Verwenden Sie Karten, aber wissen und verstehen Sie, wie sie funktionieren!  Sie k√∂nnen den Rake vermeiden, indem Sie einige der Feinheiten verstehen - warum Sie die Adresse des Werts nicht √ºbernehmen k√∂nnen, warum w√§hrend der Deklaration alles ohne Initialisierung f√§llt, warum es besser ist, Speicher im Voraus zuzuweisen, wenn die Anzahl der Elemente bekannt ist (wir werden Evakuierungen vermeiden) und vieles mehr. <br><br><hr><br>  Referenzliste: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Go Maps in Aktion", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWie die Go-Laufzeit Karten effizient implementiert‚Äú, sagt Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Typ in go verstehen", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Innerhalb der Kartenimplementierung Keith Randall</a> <br>  <a href="">Kartenquellcode, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang spec</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">effektiv gehen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gopher-Bilder</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457728/">https://habr.com/ru/post/de457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457714/index.html">Stapel√ºberlauf in Englisch: Community Kill Guide</a></li>
<li><a href="../de457718/index.html">HyperCard, das verlorene Glied in der Entwicklung des Web</a></li>
<li><a href="../de457720/index.html">Autodesk Maya: N√ºtzliche Grundfunktionen f√ºr die Arbeit mit 3D-Modellen</a></li>
<li><a href="../de457722/index.html">SQL: Zeiterfassung Problem: Nachbesprechung</a></li>
<li><a href="../de457724/index.html">OpenCV auf STM32F7-Discovery</a></li>
<li><a href="../de457730/index.html">Im B√ºro gibt es eine Illusion der Kontrolle - es ist nicht auf der Fernbedienung. Gespr√§ch mit Devhab</a></li>
<li><a href="../de457734/index.html">Italien Open Source Revolution beginnt</a></li>
<li><a href="../de457736/index.html">"Tools sind nicht so wichtig wie die F√§higkeit, √ºber die von ihnen erstellten Systeme nachzudenken." Tolles Interview mit Martin Kleppman</a></li>
<li><a href="../de457738/index.html">Wie wir SD-Access implementiert haben und warum es ben√∂tigt wurde</a></li>
<li><a href="../de457742/index.html">Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden f√ºr hohe Verf√ºgbarkeit und Verf√ºgbarkeit der Infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>