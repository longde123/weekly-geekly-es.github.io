<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÖ ‚ÜòÔ∏è üçç Multithreading lernen Gehen Sie mit Bildern programmieren üöé ‚òùüèø üíÉüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√∂chstwahrscheinlich haben Sie bereits von der Programmiersprache Go geh√∂rt, deren Beliebtheit st√§ndig zunimmt, was durchaus vern√ºnftig ist. Diese Spr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multithreading lernen Gehen Sie mit Bildern programmieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  H√∂chstwahrscheinlich haben Sie bereits von der Programmiersprache Go geh√∂rt, deren Beliebtheit st√§ndig zunimmt, was durchaus vern√ºnftig ist.  Diese Sprache ist einfach, schnell und basiert auf einer gro√üartigen Community.  Einer der merkw√ºrdigsten Aspekte der Sprache ist das Multithread-Programmiermodell.  Mit den zugrunde liegenden Grundelementen k√∂nnen Sie einfach und einfach Multithread-Programme erstellen.  Dieser Artikel richtet sich an diejenigen, die diese Grundelemente lernen m√∂chten: Goroutinen und Kan√§le.  Und anhand der Abbildungen werde ich zeigen, wie man mit ihnen arbeitet.  Ich hoffe, dass dies eine gute Hilfe f√ºr Sie in Ihrem weiteren Studium sein wird. <br><a name="habracut"></a><br><h4>  Einzel- und Multithread-Programme </h4><br>  Sie haben h√∂chstwahrscheinlich bereits Single-Thread-Programme geschrieben.  Normalerweise sieht es so aus: Es gibt eine Reihe von Funktionen zum Ausf√ºhren verschiedener Aufgaben. Jede Funktion wird nur aufgerufen, wenn die vorherige Daten darauf vorbereitet hat.  Somit l√§uft das Programm nacheinander. <br><br>  Das wird unser erstes Beispiel sein - das Erzabbauprogramm.  Unsere Funktionen werden Erz suchen, abbauen und verarbeiten.  Das Erz in der Mine in unserem Beispiel wird durch Listen von Strings dargestellt, Funktionen nehmen sie als Parameter und geben eine Liste von ‚Äûverarbeiteten‚Äú Strings zur√ºck.  F√ºr ein Single-Thread-Programm wird unsere Anwendung wie folgt gestaltet: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  In diesem Beispiel wird die gesamte Arbeit von einem Thread (Garys Gopher) ausgef√ºhrt.  Drei Hauptfunktionen: Suche, Produktion und Verarbeitung werden nacheinander ausgef√ºhrt. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Wenn wir das Ergebnis jeder Funktion drucken, erhalten wir Folgendes: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  Einfaches Design und einfache Implementierung sind ein Plus eines Single-Threaded-Ansatzes.  Was aber, wenn Sie Funktionen unabh√§ngig voneinander ausf√ºhren und ausf√ºhren m√∂chten?  Hier hilft Ihnen die Multithread-Programmierung. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Dieser Ansatz f√ºr den Erzabbau ist viel effizienter.  Jetzt arbeiten mehrere Threads (Gophers) unabh√§ngig voneinander, und Gary macht nur einen Teil der Arbeit.  Ein Gopher sucht nach Erz, der andere produziert und der dritte schmilzt, und all dies ist m√∂glicherweise gleichzeitig.  Um diesen Ansatz zu implementieren, ben√∂tigen wir zwei Dinge im Code: Gopher-Prozessoren unabh√§ngig voneinander zu erstellen und Erz zwischen ihnen zu √ºbertragen.  Go hat daf√ºr Goroutinen und Kan√§le. <br><br><h4>  Gorutins </h4><br>  Goroutinen k√∂nnen als "leichte Threads" betrachtet werden. Um Goroutinen zu erstellen, m√ºssen Sie nur das Schl√ºsselwort <b>go</b> vor den Funktionsaufrufcode setzen.  Um zu demonstrieren, wie einfach es ist, erstellen wir zwei Suchfunktionen, rufen sie mit dem Schl√ºsselwort <b>go auf</b> und drucken jedes Mal eine Nachricht, wenn sie das ‚ÄûErz‚Äú in ihrer Mine finden. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  Die Ausgabe unseres Programms wird wie folgt sein: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Wie Sie sehen k√∂nnen, gibt es keine Reihenfolge, in der die Funktion zuerst Erz findet.  Suchfunktionen arbeiten gleichzeitig.  Wenn Sie das Beispiel mehrmals ausf√ºhren, ist die Reihenfolge anders.  Jetzt k√∂nnen wir Multithread-Programme (Multi-Sphere-Programme) ausf√ºhren, und dies ist ein schwerwiegender Fortschritt.  Aber was tun, wenn wir eine Verbindung zwischen unabh√§ngigen Goroutinen herstellen m√ºssen?  Die Zeit f√ºr die Magie der Kan√§le kommt. <br><br><h4>  Kan√§le </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  √úber Kan√§le k√∂nnen Goroutinen Daten austauschen.  Dies ist eine Art Rohr, durch das Goroutins Informationen von anderen Goroutinen senden und empfangen k√∂nnen. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  Das Lesen und Schreiben in den Kanal erfolgt mit dem Pfeiloperator (&lt;-), der die Richtung der Datenbewegung angibt. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Jetzt muss unser Gopher-Scout kein Erz mehr ansammeln, er kann es sofort √ºber Kan√§le weiter √ºbertragen. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  Ich habe das Beispiel aktualisiert, jetzt ist der Code des Erzfinders und Bergmanns anonyme Funktionen.  Machen Sie sich nicht zu viele Sorgen, wenn Sie ihnen noch nicht begegnet sind. Denken Sie jedoch daran, dass jeder von ihnen mit dem Schl√ºsselwort <b>go</b> aufgerufen wird. Daher wird er in seiner eigenen Goroutine ausgef√ºhrt.  Das Wichtigste dabei ist, dass Goroutinen Daten √ºber den <b>oreChan-</b> Kanal untereinander √ºbertragen.  Und wir werden uns n√§her am Ende mit anonymen Funktionen befassen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{‚Äúore1‚Äù, ‚Äúore2‚Äù, ‚Äúore3‚Äù} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(‚ÄúMiner: Received ‚Äú + foundOre + ‚Äú from finder‚Äù) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  Die folgende Schlussfolgerung zeigt deutlich, dass unser Bergmann dreimal eine Portion nach der anderen vom Kanal erh√§lt. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Jetzt k√∂nnen wir Daten zwischen verschiedenen Goroutinen (Gophern) √ºbertragen. Bevor wir jedoch mit dem Schreiben eines komplexen Programms beginnen, wollen wir uns einige wichtige Eigenschaften von Kan√§len ansehen. <br><br><h4>  Schl√∂sser </h4><br>  In einigen Situationen kann Goroutin beim Arbeiten mit Kan√§len blockiert sein.  Dies ist notwendig, damit die Goroutinen miteinander synchronisiert werden k√∂nnen, bevor sie beginnen oder weiterarbeiten. <br><br><h4>  Schreibsperre </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Wenn Goroutine (Gopher) Daten an einen Kanal sendet, werden diese blockiert, bis eine andere Goroutine Daten aus dem Kanal liest. <br><br><h4>  Sperre lesen </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  √Ñhnlich wie beim Sperren beim Schreiben in einen Kanal kann Goroutin beim Lesen von einem Kanal gesperrt werden, bis nichts mehr darauf geschrieben wird. <br>  Wenn Ihnen die Schl√∂sser auf den ersten Blick kompliziert erscheinen, k√∂nnen Sie sie sich als ‚ÄûGeldtransfer‚Äú zwischen zwei Goroutinen (Gophers) vorstellen.  Wenn ein Gopher Geld √ºberweisen oder erhalten m√∂chte, muss er auf den zweiten Teilnehmer der Transaktion warten. <br><br>  Nachdem wir uns mit Goroutine-Sperren f√ºr Kan√§le befasst haben, wollen wir zwei verschiedene Arten von Kan√§len diskutieren: gepuffert und ungepuffert.  Wenn wir diesen oder jenen Typ w√§hlen, bestimmen wir weitgehend das Verhalten des Programms. <br><br><h4>  Ungepufferte Kan√§le </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  In allen vorherigen Beispielen haben wir nur solche Kan√§le verwendet.  Auf solchen Kan√§len kann jeweils nur ein Datenelement √ºbertragen werden (mit Blockierung, wie oben beschrieben). <br><br><h4>  Gepufferte Kan√§le </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Streams in einem Programm k√∂nnen nicht immer perfekt synchronisiert werden.  Angenommen, in unserem Beispiel hat ein Gopher-Scout drei Teile Erz gefunden, und ein Gopher-Bergmann hat es geschafft, nur einen Teil der gefundenen Reserven gleichzeitig zu gewinnen.  Damit die Gopher-Aufkl√§rung nicht die meiste Zeit damit verbringt, darauf zu warten, dass der Bergmann seine Arbeit beendet, werden wir gepufferte Kan√§le verwenden.  Beginnen wir mit der Erstellung eines Kanals mit einer Kapazit√§t von 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir k√∂nnen mehrere Daten an den gepufferten Kanal senden, ohne sie mit einer anderen Goroutine lesen zu m√ºssen.  Dies ist der Hauptunterschied zu ungepufferten Kan√§len. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  Die Ausgabereihenfolge in einem solchen Programm ist wie folgt: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Um unn√∂tige Komplikationen zu vermeiden, werden wir in unserem Programm keine gepufferten Kan√§le verwenden.  Es ist jedoch wichtig zu bedenken, dass diese Kanaltypen auch zur Verwendung verf√ºgbar sind. <br>  Es ist auch wichtig zu beachten, dass gepufferte Kan√§le Sie nicht immer vor dem Blockieren bewahren.  Wenn beispielsweise ein Gopher-Scout zehnmal schneller als ein Gopher-Miner ist und √ºber einen gepufferten Kanal mit einer Kapazit√§t von 2 verbunden ist, wird der Gopher-Scout bei jedem Senden blockiert, wenn sich bereits zwei Daten im Kanal befinden. <br><br><h4>  Alles zusammenf√ºgen </h4><br>  Mit Goroutinen und Kan√§len k√∂nnen wir also ein Programm schreiben, das alle Vorteile der Multithread-Programmierung in Go nutzt. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Ein solches Programm gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Im Vergleich zu unserem ersten Beispiel ist dies eine wesentliche Verbesserung. Jetzt werden alle Funktionen unabh√§ngig voneinander ausgef√ºhrt, jede in ihrer eigenen Goroutine.  Au√üerdem haben wir einen F√∂rderer aus Kan√§len bekommen, durch den das Erz unmittelbar nach der Verarbeitung transportiert wird.  Um mich weiterhin auf ein grundlegendes Verst√§ndnis der Funktionsweise von Kan√§len und Goroutinen zu konzentrieren, habe ich einige Punkte weggelassen, die zu Schwierigkeiten beim Start des Programms f√ºhren k√∂nnen.  Abschlie√üend m√∂chte ich auf diese Merkmale der Sprache eingehen, da sie bei der Arbeit mit Goroutinen und Kan√§len helfen. <br><br><h4>  Anonyme Gorutinen </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  So wie wir eine regul√§re Funktion in goroutine ausf√ºhren, k√∂nnen wir eine anonyme Funktion unmittelbar nach dem Schl√ºsselwort <b>go</b> deklarieren und sie mit der folgenden Syntax aufrufen: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Wenn wir also eine Funktion nur an einer Stelle aufrufen m√ºssen, k√∂nnen wir sie in einer separaten Goroutine ausf√ºhren, ohne uns vorher um ihre Deklaration k√ºmmern zu m√ºssen. <br><br><h4>  Die Hauptfunktion ist Goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Ja, die <b>Hauptfunktion</b> funktioniert in einer eigenen Goroutine.  Und was noch wichtiger ist, nach seiner Fertigstellung enden auch alle anderen Goroutinen.  Aus diesem Grund haben wir am Ende unserer <b>Hauptfunktion</b> einen Timer-Aufruf get√§tigt.  Dieser Aufruf erstellt einen Kanal und sendet nach 5 Sekunden Daten an diesen. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Denken Sie daran, dass die Goroutine beim Lesen aus dem Kanal blockiert wird, bis etwas an ihn gesendet wird?  Dies ist genau das, was passiert, wenn der angegebene Code hinzugef√ºgt wird.  Die Hauptgoroutine wird blockiert, so dass die anderen Goroutien 5 Sekunden Zeit zum Arbeiten haben.  Diese Methode funktioniert gut, aber normalerweise wird ein anderer Ansatz verwendet, um zu √ºberpr√ºfen, ob alle Goroutinen ihre Arbeit abgeschlossen haben.  Um ein Signal √ºber den Abschluss der Arbeit zu senden, wird ein spezieller Kanal erstellt, die Hauptgoroutine wird daran gehindert, daraus zu lesen, und sobald die Tochtergoroutine ihre Arbeit beendet hat, schreibt sie in diesen Kanal.  Die Hauptgoroutine ist entsperrt und das Programm endet. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- ‚ÄúI'm all done!‚Äù }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Lesen Sie aus einer Pipe in einer For-Range-Schleife </h4><br>  In unserem Beispiel haben wir in der Funktion des Goffer-Getters die <b>for-</b> Schleife verwendet, um drei Elemente aus dem Kanal auszuw√§hlen.  Aber was tun, wenn nicht im Voraus bekannt ist, wie viele Daten sich im Kanal befinden k√∂nnen?  In solchen F√§llen k√∂nnen Sie den Kanal wie bei Sammlungen als Argument f√ºr die <b>for-range-</b> Schleife verwenden.  Die aktualisierte Funktion sieht m√∂glicherweise folgenderma√üen aus: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(‚ÄúMiner: Received ‚Äú + foundOre + ‚Äú from finder‚Äù) } }()</span></span></code> </pre><br>  Auf diese Weise liest der Erzbergmann alles, was der Scout ihm sendet, und die Verwendung des Kanals im Zyklus garantiert dies.  Bitte beachten Sie, dass der Zyklus nach dem Verarbeiten aller Daten vom Kanal beim Lesen gesperrt wird.  Um ein Blockieren zu vermeiden, m√ºssen Sie den Kanal <b>schlie√üen,</b> indem Sie <b>close (channel)</b> aufrufen. <br><br><h4>  Nicht blockierendes Kanallesen </h4><br>  Mit dem <b>Select-Case-</b> Konstrukt kann das Blockieren von Lesevorg√§ngen aus der Pipe vermieden werden.  Das folgende Beispiel zeigt die Verwendung dieser Konstruktion: goroutine liest Daten aus dem Kanal, wenn sie nur vorhanden sind, andernfalls wird der <b>Standardblock</b> ausgef√ºhrt: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- ‚ÄúMessage!‚Äù }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚ÄúNo Msg‚Äù) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚ÄúNo Msg‚Äù) }</code> </pre><br>  Nach dem Start gibt dieser Code Folgendes aus: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Nicht blockierende Kanalaufzeichnung </h4><br>  Sperren beim Schreiben in einen Kanal k√∂nnen vermieden werden, indem dasselbe <b>Select-Case-</b> Konstrukt verwendet wird.  Nehmen wir eine kleine √Ñnderung am vorherigen Beispiel vor: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- ‚Äúmessage‚Äù: fmt.Println(‚Äúsent the message‚Äù) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚Äúno message sent‚Äù) }</code> </pre><br><h4>  Was weiter zu studieren </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  Es gibt eine gro√üe Anzahl von Artikeln und Berichten, die die Arbeit mit Kan√§len und Goroutinen viel detaillierter behandeln.  Mit dem Code haben Sie eine klare Vorstellung davon, warum und wie diese Tools verwendet werden. So k√∂nnen Sie die folgenden Materialien optimal nutzen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google I / O 2012 - Go Concurrency Patterns</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rob Pike - "Parallelit√§t ist keine Parallelit√§t"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Vielen Dank, dass Sie sich die Zeit zum Lesen genommen haben.  Ich hoffe, ich habe Ihnen geholfen, die Kan√§le, Goroutinen und die Vorteile von Multithread-Programmen zu verstehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412715/">https://habr.com/ru/post/de412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412703/index.html">Bei einer Konferenz mit Veeam: ein R√ºckblick auf VeeamON 2018 und eine Einladung zum VeeamON-Forum in Moskau</a></li>
<li><a href="../de412705/index.html">Das System gehackt: Wie wir die Auswahl und Anpassung von Entwicklern ge√§ndert haben</a></li>
<li><a href="../de412709/index.html">Oh, mein Code: Maschinelles Lernen und Analytik bei Klassenkameraden</a></li>
<li><a href="../de412711/index.html">Um Einsteins Gleichungen zu √ºberpr√ºfen, m√ºssen Sie ein Schwarzes Loch treten</a></li>
<li><a href="../de412713/index.html">Ein √úberblick √ºber die interessantesten Innovationen aus dem May Power BI-Update</a></li>
<li><a href="../de412717/index.html">Hallo Aliens; Bitte t√∂te uns nicht</a></li>
<li><a href="../de412719/index.html">MDG k√ºndigt Sprachsynthesewettbewerb an</a></li>
<li><a href="../de412721/index.html">Drei Hoffnungen der Menschheit auf die Entdeckung von Au√üerirdischen</a></li>
<li><a href="../de412723/index.html">Auf der Suche nach einer neuen Milliarden-Dollar-Farbe</a></li>
<li><a href="../de412725/index.html">So machen Sie Ihre IT-Infrastruktur langweilig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>