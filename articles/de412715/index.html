<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 ↘️ 🍍 Multithreading lernen Gehen Sie mit Bildern programmieren 🚎 ☝🏿 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Höchstwahrscheinlich haben Sie bereits von der Programmiersprache Go gehört, deren Beliebtheit ständig zunimmt, was durchaus vernünftig ist. Diese Spr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multithreading lernen Gehen Sie mit Bildern programmieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  Höchstwahrscheinlich haben Sie bereits von der Programmiersprache Go gehört, deren Beliebtheit ständig zunimmt, was durchaus vernünftig ist.  Diese Sprache ist einfach, schnell und basiert auf einer großartigen Community.  Einer der merkwürdigsten Aspekte der Sprache ist das Multithread-Programmiermodell.  Mit den zugrunde liegenden Grundelementen können Sie einfach und einfach Multithread-Programme erstellen.  Dieser Artikel richtet sich an diejenigen, die diese Grundelemente lernen möchten: Goroutinen und Kanäle.  Und anhand der Abbildungen werde ich zeigen, wie man mit ihnen arbeitet.  Ich hoffe, dass dies eine gute Hilfe für Sie in Ihrem weiteren Studium sein wird. <br><a name="habracut"></a><br><h4>  Einzel- und Multithread-Programme </h4><br>  Sie haben höchstwahrscheinlich bereits Single-Thread-Programme geschrieben.  Normalerweise sieht es so aus: Es gibt eine Reihe von Funktionen zum Ausführen verschiedener Aufgaben. Jede Funktion wird nur aufgerufen, wenn die vorherige Daten darauf vorbereitet hat.  Somit läuft das Programm nacheinander. <br><br>  Das wird unser erstes Beispiel sein - das Erzabbauprogramm.  Unsere Funktionen werden Erz suchen, abbauen und verarbeiten.  Das Erz in der Mine in unserem Beispiel wird durch Listen von Strings dargestellt, Funktionen nehmen sie als Parameter und geben eine Liste von „verarbeiteten“ Strings zurück.  Für ein Single-Thread-Programm wird unsere Anwendung wie folgt gestaltet: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  In diesem Beispiel wird die gesamte Arbeit von einem Thread (Garys Gopher) ausgeführt.  Drei Hauptfunktionen: Suche, Produktion und Verarbeitung werden nacheinander ausgeführt. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Wenn wir das Ergebnis jeder Funktion drucken, erhalten wir Folgendes: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  Einfaches Design und einfache Implementierung sind ein Plus eines Single-Threaded-Ansatzes.  Was aber, wenn Sie Funktionen unabhängig voneinander ausführen und ausführen möchten?  Hier hilft Ihnen die Multithread-Programmierung. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Dieser Ansatz für den Erzabbau ist viel effizienter.  Jetzt arbeiten mehrere Threads (Gophers) unabhängig voneinander, und Gary macht nur einen Teil der Arbeit.  Ein Gopher sucht nach Erz, der andere produziert und der dritte schmilzt, und all dies ist möglicherweise gleichzeitig.  Um diesen Ansatz zu implementieren, benötigen wir zwei Dinge im Code: Gopher-Prozessoren unabhängig voneinander zu erstellen und Erz zwischen ihnen zu übertragen.  Go hat dafür Goroutinen und Kanäle. <br><br><h4>  Gorutins </h4><br>  Goroutinen können als "leichte Threads" betrachtet werden. Um Goroutinen zu erstellen, müssen Sie nur das Schlüsselwort <b>go</b> vor den Funktionsaufrufcode setzen.  Um zu demonstrieren, wie einfach es ist, erstellen wir zwei Suchfunktionen, rufen sie mit dem Schlüsselwort <b>go auf</b> und drucken jedes Mal eine Nachricht, wenn sie das „Erz“ in ihrer Mine finden. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  Die Ausgabe unseres Programms wird wie folgt sein: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Wie Sie sehen können, gibt es keine Reihenfolge, in der die Funktion zuerst Erz findet.  Suchfunktionen arbeiten gleichzeitig.  Wenn Sie das Beispiel mehrmals ausführen, ist die Reihenfolge anders.  Jetzt können wir Multithread-Programme (Multi-Sphere-Programme) ausführen, und dies ist ein schwerwiegender Fortschritt.  Aber was tun, wenn wir eine Verbindung zwischen unabhängigen Goroutinen herstellen müssen?  Die Zeit für die Magie der Kanäle kommt. <br><br><h4>  Kanäle </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  Über Kanäle können Goroutinen Daten austauschen.  Dies ist eine Art Rohr, durch das Goroutins Informationen von anderen Goroutinen senden und empfangen können. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  Das Lesen und Schreiben in den Kanal erfolgt mit dem Pfeiloperator (&lt;-), der die Richtung der Datenbewegung angibt. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Jetzt muss unser Gopher-Scout kein Erz mehr ansammeln, er kann es sofort über Kanäle weiter übertragen. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  Ich habe das Beispiel aktualisiert, jetzt ist der Code des Erzfinders und Bergmanns anonyme Funktionen.  Machen Sie sich nicht zu viele Sorgen, wenn Sie ihnen noch nicht begegnet sind. Denken Sie jedoch daran, dass jeder von ihnen mit dem Schlüsselwort <b>go</b> aufgerufen wird. Daher wird er in seiner eigenen Goroutine ausgeführt.  Das Wichtigste dabei ist, dass Goroutinen Daten über den <b>oreChan-</b> Kanal untereinander übertragen.  Und wir werden uns näher am Ende mit anonymen Funktionen befassen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{“ore1”, “ore2”, “ore3”} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  Die folgende Schlussfolgerung zeigt deutlich, dass unser Bergmann dreimal eine Portion nach der anderen vom Kanal erhält. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Jetzt können wir Daten zwischen verschiedenen Goroutinen (Gophern) übertragen. Bevor wir jedoch mit dem Schreiben eines komplexen Programms beginnen, wollen wir uns einige wichtige Eigenschaften von Kanälen ansehen. <br><br><h4>  Schlösser </h4><br>  In einigen Situationen kann Goroutin beim Arbeiten mit Kanälen blockiert sein.  Dies ist notwendig, damit die Goroutinen miteinander synchronisiert werden können, bevor sie beginnen oder weiterarbeiten. <br><br><h4>  Schreibsperre </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Wenn Goroutine (Gopher) Daten an einen Kanal sendet, werden diese blockiert, bis eine andere Goroutine Daten aus dem Kanal liest. <br><br><h4>  Sperre lesen </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  Ähnlich wie beim Sperren beim Schreiben in einen Kanal kann Goroutin beim Lesen von einem Kanal gesperrt werden, bis nichts mehr darauf geschrieben wird. <br>  Wenn Ihnen die Schlösser auf den ersten Blick kompliziert erscheinen, können Sie sie sich als „Geldtransfer“ zwischen zwei Goroutinen (Gophers) vorstellen.  Wenn ein Gopher Geld überweisen oder erhalten möchte, muss er auf den zweiten Teilnehmer der Transaktion warten. <br><br>  Nachdem wir uns mit Goroutine-Sperren für Kanäle befasst haben, wollen wir zwei verschiedene Arten von Kanälen diskutieren: gepuffert und ungepuffert.  Wenn wir diesen oder jenen Typ wählen, bestimmen wir weitgehend das Verhalten des Programms. <br><br><h4>  Ungepufferte Kanäle </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  In allen vorherigen Beispielen haben wir nur solche Kanäle verwendet.  Auf solchen Kanälen kann jeweils nur ein Datenelement übertragen werden (mit Blockierung, wie oben beschrieben). <br><br><h4>  Gepufferte Kanäle </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Streams in einem Programm können nicht immer perfekt synchronisiert werden.  Angenommen, in unserem Beispiel hat ein Gopher-Scout drei Teile Erz gefunden, und ein Gopher-Bergmann hat es geschafft, nur einen Teil der gefundenen Reserven gleichzeitig zu gewinnen.  Damit die Gopher-Aufklärung nicht die meiste Zeit damit verbringt, darauf zu warten, dass der Bergmann seine Arbeit beendet, werden wir gepufferte Kanäle verwenden.  Beginnen wir mit der Erstellung eines Kanals mit einer Kapazität von 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir können mehrere Daten an den gepufferten Kanal senden, ohne sie mit einer anderen Goroutine lesen zu müssen.  Dies ist der Hauptunterschied zu ungepufferten Kanälen. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  Die Ausgabereihenfolge in einem solchen Programm ist wie folgt: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Um unnötige Komplikationen zu vermeiden, werden wir in unserem Programm keine gepufferten Kanäle verwenden.  Es ist jedoch wichtig zu bedenken, dass diese Kanaltypen auch zur Verwendung verfügbar sind. <br>  Es ist auch wichtig zu beachten, dass gepufferte Kanäle Sie nicht immer vor dem Blockieren bewahren.  Wenn beispielsweise ein Gopher-Scout zehnmal schneller als ein Gopher-Miner ist und über einen gepufferten Kanal mit einer Kapazität von 2 verbunden ist, wird der Gopher-Scout bei jedem Senden blockiert, wenn sich bereits zwei Daten im Kanal befinden. <br><br><h4>  Alles zusammenfügen </h4><br>  Mit Goroutinen und Kanälen können wir also ein Programm schreiben, das alle Vorteile der Multithread-Programmierung in Go nutzt. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Ein solches Programm gibt Folgendes aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Im Vergleich zu unserem ersten Beispiel ist dies eine wesentliche Verbesserung. Jetzt werden alle Funktionen unabhängig voneinander ausgeführt, jede in ihrer eigenen Goroutine.  Außerdem haben wir einen Förderer aus Kanälen bekommen, durch den das Erz unmittelbar nach der Verarbeitung transportiert wird.  Um mich weiterhin auf ein grundlegendes Verständnis der Funktionsweise von Kanälen und Goroutinen zu konzentrieren, habe ich einige Punkte weggelassen, die zu Schwierigkeiten beim Start des Programms führen können.  Abschließend möchte ich auf diese Merkmale der Sprache eingehen, da sie bei der Arbeit mit Goroutinen und Kanälen helfen. <br><br><h4>  Anonyme Gorutinen </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  So wie wir eine reguläre Funktion in goroutine ausführen, können wir eine anonyme Funktion unmittelbar nach dem Schlüsselwort <b>go</b> deklarieren und sie mit der folgenden Syntax aufrufen: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Wenn wir also eine Funktion nur an einer Stelle aufrufen müssen, können wir sie in einer separaten Goroutine ausführen, ohne uns vorher um ihre Deklaration kümmern zu müssen. <br><br><h4>  Die Hauptfunktion ist Goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Ja, die <b>Hauptfunktion</b> funktioniert in einer eigenen Goroutine.  Und was noch wichtiger ist, nach seiner Fertigstellung enden auch alle anderen Goroutinen.  Aus diesem Grund haben wir am Ende unserer <b>Hauptfunktion</b> einen Timer-Aufruf getätigt.  Dieser Aufruf erstellt einen Kanal und sendet nach 5 Sekunden Daten an diesen. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Denken Sie daran, dass die Goroutine beim Lesen aus dem Kanal blockiert wird, bis etwas an ihn gesendet wird?  Dies ist genau das, was passiert, wenn der angegebene Code hinzugefügt wird.  Die Hauptgoroutine wird blockiert, so dass die anderen Goroutien 5 Sekunden Zeit zum Arbeiten haben.  Diese Methode funktioniert gut, aber normalerweise wird ein anderer Ansatz verwendet, um zu überprüfen, ob alle Goroutinen ihre Arbeit abgeschlossen haben.  Um ein Signal über den Abschluss der Arbeit zu senden, wird ein spezieller Kanal erstellt, die Hauptgoroutine wird daran gehindert, daraus zu lesen, und sobald die Tochtergoroutine ihre Arbeit beendet hat, schreibt sie in diesen Kanal.  Die Hauptgoroutine ist entsperrt und das Programm endet. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- “I'm all done!” }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Lesen Sie aus einer Pipe in einer For-Range-Schleife </h4><br>  In unserem Beispiel haben wir in der Funktion des Goffer-Getters die <b>for-</b> Schleife verwendet, um drei Elemente aus dem Kanal auszuwählen.  Aber was tun, wenn nicht im Voraus bekannt ist, wie viele Daten sich im Kanal befinden können?  In solchen Fällen können Sie den Kanal wie bei Sammlungen als Argument für die <b>for-range-</b> Schleife verwenden.  Die aktualisierte Funktion sieht möglicherweise folgendermaßen aus: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }()</span></span></code> </pre><br>  Auf diese Weise liest der Erzbergmann alles, was der Scout ihm sendet, und die Verwendung des Kanals im Zyklus garantiert dies.  Bitte beachten Sie, dass der Zyklus nach dem Verarbeiten aller Daten vom Kanal beim Lesen gesperrt wird.  Um ein Blockieren zu vermeiden, müssen Sie den Kanal <b>schließen,</b> indem Sie <b>close (channel)</b> aufrufen. <br><br><h4>  Nicht blockierendes Kanallesen </h4><br>  Mit dem <b>Select-Case-</b> Konstrukt kann das Blockieren von Lesevorgängen aus der Pipe vermieden werden.  Das folgende Beispiel zeigt die Verwendung dieser Konstruktion: goroutine liest Daten aus dem Kanal, wenn sie nur vorhanden sind, andernfalls wird der <b>Standardblock</b> ausgeführt: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- “Message!” }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) }</code> </pre><br>  Nach dem Start gibt dieser Code Folgendes aus: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Nicht blockierende Kanalaufzeichnung </h4><br>  Sperren beim Schreiben in einen Kanal können vermieden werden, indem dasselbe <b>Select-Case-</b> Konstrukt verwendet wird.  Nehmen wir eine kleine Änderung am vorherigen Beispiel vor: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- “message”: fmt.Println(“sent the message”) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“no message sent”) }</code> </pre><br><h4>  Was weiter zu studieren </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  Es gibt eine große Anzahl von Artikeln und Berichten, die die Arbeit mit Kanälen und Goroutinen viel detaillierter behandeln.  Mit dem Code haben Sie eine klare Vorstellung davon, warum und wie diese Tools verwendet werden. So können Sie die folgenden Materialien optimal nutzen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google I / O 2012 - Go Concurrency Patterns</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rob Pike - "Parallelität ist keine Parallelität"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Vielen Dank, dass Sie sich die Zeit zum Lesen genommen haben.  Ich hoffe, ich habe Ihnen geholfen, die Kanäle, Goroutinen und die Vorteile von Multithread-Programmen zu verstehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412715/">https://habr.com/ru/post/de412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412703/index.html">Bei einer Konferenz mit Veeam: ein Rückblick auf VeeamON 2018 und eine Einladung zum VeeamON-Forum in Moskau</a></li>
<li><a href="../de412705/index.html">Das System gehackt: Wie wir die Auswahl und Anpassung von Entwicklern geändert haben</a></li>
<li><a href="../de412709/index.html">Oh, mein Code: Maschinelles Lernen und Analytik bei Klassenkameraden</a></li>
<li><a href="../de412711/index.html">Um Einsteins Gleichungen zu überprüfen, müssen Sie ein Schwarzes Loch treten</a></li>
<li><a href="../de412713/index.html">Ein Überblick über die interessantesten Innovationen aus dem May Power BI-Update</a></li>
<li><a href="../de412717/index.html">Hallo Aliens; Bitte töte uns nicht</a></li>
<li><a href="../de412719/index.html">MDG kündigt Sprachsynthesewettbewerb an</a></li>
<li><a href="../de412721/index.html">Drei Hoffnungen der Menschheit auf die Entdeckung von Außerirdischen</a></li>
<li><a href="../de412723/index.html">Auf der Suche nach einer neuen Milliarden-Dollar-Farbe</a></li>
<li><a href="../de412725/index.html">So machen Sie Ihre IT-Infrastruktur langweilig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>