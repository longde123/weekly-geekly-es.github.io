<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏾 🧖🏾 🎁 Discovery.js指南：快速入门 🥔 🧗🏽 🗼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本指南和以下指南将指导您完成基于Discovery.js项目的解决方案的创建过程。 我们的目标是为NPM依赖关系创建一个检查器，即用于检查node_modules结构的node_modules 。 



 注意：Discovery.js处于开发的早期阶段，因此随着时间的流逝，某些事情将会简化并变得...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Discovery.js指南：快速入门</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/469115/"><p>本指南和以下指南将指导您完成基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Discovery.js</a>项目的解决方案的创建过程。 我们的目标是为NPM依赖关系创建一个检查器，即用于检查<code>node_modules</code>结构的<code>node_modules</code> 。 </p><br><p><img src="https://habrastorage.org/webt/ih/d_/sc/ihd_schofzsmx1xbptuvltrxmu8.png"></p><br><blockquote> 注意：Discovery.js处于开发的早期阶段，因此随着时间的流逝，某些事情将会简化并变得更加有用。 如果您有关于如何改进的想法，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">给我们写信</a> 。 </blockquote><br><h2 id="annotaciya"> 注解 </h2><br><p> 您将在下面找到Discovery.js关键概念的概述。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上的存储库中</a>了解整个手册代码，也可以尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在线使用它</a> 。 </p><a name="habracut"></a><br><h2 id="nachalnye-usloviya"> 初始条件 </h2><br><p> 首先，我们需要选择一个项目进行分析。 这可以是新创建的项目，也可以是现有的项目，主要是它包含<code>node_modules</code> （我们分析的对象）。 </p><br><p> 首先，安装<code>discoveryjs</code>核心软件包及其控制台工具： </p><br><pre> <code class="bash hljs">npm install @discoveryjs/discovery @discoveryjs/cli</code> </pre> <br><p> 接下来，启动Discovery.js服务器： </p><br><pre> <code class="plaintext hljs">&gt; npx discovery No config is used Models are not defined (model free mode is enabled) Init common routes ... OK Server listen on http://localhost:8123</code> </pre> <br><p> 如果在浏览器中打开<code>http://localhost:8123</code> ，则可以看到以下内容： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4e6/fc9/228/4e6fc922872955e6a2f3355e2856b3d1.png" alt="无需配置即可发现"></p><br><p> 这是没有模型的模式，即没有任何配置的模式。 但是现在，使用“加载数据”按钮，您可以选择任何JSON文件，也可以将其拖到页面上并开始分析。 </p><br><p> 但是，我们需要一些特定的东西。 特别是，我们需要获取<code>node_modules</code>结构的视图。 为此，请添加配置。 </p><br><h2 id="dobavlyaem-konfiguraciyu"> 添加配置 </h2><br><p> 您可能已经注意到，服务器启动时会显示消息<code>No config is used</code> 。 让我们创建一个<code>.discoveryrc.js</code>配置文件，其中包含以下内容： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Node modules structure'</span></span>, data() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }; } };</code> </pre> <br><p> 注意：如果您在当前工作目录（即项目的根目录）中创建文件，则不需要任何其他操作。 否则，您需要使用<code>--config</code>选项将路径传递到配置文件，或在<code>package.json</code>设置路径： </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"discovery"</span></span>: <span class="hljs-string"><span class="hljs-string">"path/to/discovery/config.js"</span></span>, ... }</code> </pre> <br><p> 重新启动服务器，以便应用配置： </p><br><pre> <code class="plaintext hljs">&gt; npx discovery Load config from .discoveryrc.js Init single model default Define default routes ... OK Cache: DISABLED Init common routes ... OK Server listen on http://localhost:8123</code> </pre> <br><p> 如您所见，现在使用了我们创建的文件。 并且应用了我们描述的默认模型（发现可以在许多模型的模式下工作，我们将在以下手册中讨论此功能）。 让我们看看浏览器中发生了什么变化： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/16f/f45/ac8/16ff45ac8eef467b6ccd0ff5624c9652.png" alt="基本配置"></p><br><p> 在这里可以看到： </p><br><ul><li>  <code>name</code>用作页面标题； </li><li> 调用<code>data</code>方法的结果显示为页面的主要内容。 </li></ul><br><blockquote> 注意： <code>data</code>方法必须返回data或Promise，然后解析为data。 </blockquote><p> 基本设置已完成，您可以继续。 </p><br><h2 id="kontekst"> 语境 </h2><br><p> 让我们看一下自定义报告页面（点击生成<code>Make report</code> ）： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/def/52b/57a/def52b57a6be174730f07fe55273517a.png" alt="报告页"></p><br><p> 乍一看，这与开始页面并没有太大的区别……但是您可以在此处进行所有更改！ 例如，我们可以轻松地重新创建起始页面的外观： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c6c/919/de1/c6c919de17d2fed5bdb0501fe1ff9dae.png" alt="重新创建起始页"></p><br><p> 请注意标题的定义方式： <code>"h1:#.name"</code> 。 这是具有<code>#.name</code>内容的第一级标头，这是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jora</a>请求。  <code>#</code>表示请求上下文。 要查看其内容，只需在查询编辑器中输入<code>#</code>并使用默认显示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/524/7a6/2cc/5247a62cc6194ab9bd4797c21ab084b9.png" alt="上下文值"></p><br><p> 现在，您知道如何获取当前页面的ID，其参数和其他有用的值。 </p><br><h2 id="sbor-dannyh"> 资料收集 </h2><br><p> 现在，我们在项目中使用存根而不是真实数据，但是我们需要真实数据。 为此，请创建一个模块并在配置中更改<code>data</code>值（顺便说一下，在进行这些更改之后，无需重新启动服务器）： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Node modules structure'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./collect-node-modules-data'</span></span>) };</code> </pre> <br><p>  <code>collect-node-modules-data.js</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scanFs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@discoveryjs/scan-fs'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packages = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scanFs({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>], <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\/package.json$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">extract</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, content</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pkg = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(content); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pkg.name &amp;&amp; pkg.version) { packages.push({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: pkg.name, <span class="hljs-attr"><span class="hljs-attr">version</span></span>: pkg.version, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.dirname(file.filename), <span class="hljs-attr"><span class="hljs-attr">dependencies</span></span>: pkg.dependencies }); } } }] }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> packages); };</code> </pre> <br><p> 我使用了<code>@discoveryjs/scan-fs</code>软件包，该软件包简化了文件系统扫描。 在自述文件中描述了使用该软件包的示例，我以此示例为基础并根据需要最终确定。 现在我们有了一些有关<code>node_modules</code>内容的<code>node_modules</code> ： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d0c/f24/64c/d0cf2464cadda8a8bc0433871200ae9b.png" alt="收集资料"></p><br><p> 你需要什么！ 尽管这是普通的JSON，但我们已经可以对其进行分析并得出一些结论。 例如，使用数据结构的弹出窗口，您可以找出数据包的数量，并找出其中有多个物理实例的数据包（由于版本差异或重复数据删除问题）。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f3/93e/5e0/8f393e5e05a1385aa11aad92d8ad15a0.png" alt="数据结构研究"></p><br><p> 尽管我们已经有了一些数据，但我们需要更多详细信息。 例如，很高兴知道哪个物理实例可以解析特定模块的每个声明的依赖关系。 但是，改进数据提取的工作不在本指南的范围之内。 因此，我们将其替换为<code>@discoveryjs/node-modules</code>程序包（它也基于<code>@discoveryjs/scan-fs</code> ）以检索数据并获取有关程序包的必要详细信息。 结果，大大简化了<code>collect-node-modules-data.js</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchNodeModules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@discoveryjs/node-modules'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchNodeModules(); };</code> </pre> <br><p> 现在，有关<code>node_modules</code>的信息如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f5/1c2/187/1f51c2187d527694cbf71089e8d74ba8.png" alt="新数据结构"></p><br><h2 id="skript-podgotovki"> 准备脚本 </h2><br><p> 您可能已经注意到，一些描述软件包的对象包含<code>deps</code>依赖关系列表。 每个依赖项都有一个可<code>resolved</code>字段，其值是对包物理实例的引用。 这样的链接是包之一的<code>path</code>值，它是唯一的。 要解析到包的链接，您需要使用其他代码（例如， <code>#.data.pick(&lt;path=resolved&gt;)</code> ）。 当然，如果这样的链接已被解析为对象引用，将会更加方便。 </p><br><p> 不幸的是，在数据收集阶段，我们无法解析链接，因为这将导致循环连接，这将产生以JSON形式传输此类数据的问题。 但是，有一个解决方案：这是一个特殊的<code>prepare</code>脚本。 它在配置中定义，并在每次将新数据分配给发现实例时调用。 让我们从配置开始： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { ... prepare: __dirname + <span class="hljs-string"><span class="hljs-string">'/prepare.js'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// :   ,    ... };</span></span></code> </pre> <br><p> 定义<code>prepare.js</code> ： </p><br><pre> <code class="javascript hljs">discovery.setPrepare(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  data /   discovery });</span></span></code> </pre> <br><p> 在此模块中，我们为发现实例定义了<code>prepare</code>函数。 每次在将数据应用于发现实例之前都会调用此函数。 这是允许在对象引用中使用值的好地方： </p><br><pre> <code class="javascript hljs">discovery.setPrepare(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packageIndex = data.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map, pkg</span></span></span><span class="hljs-function">) =&gt;</span></span> map.set(pkg.path, pkg), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>()); data.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pkg</span></span></span><span class="hljs-function"> =&gt;</span></span> pkg.deps.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep</span></span></span><span class="hljs-function"> =&gt;</span></span> dep.resolved = packageIndex.get(dep.resolved) ) ); });</code> </pre> <br><p> 在这里，我们创建了一个包索引，其中的键是包<code>path</code>值（唯一）。 然后，我们遍历所有包及其依赖项，并在依赖项中将<code>resolved</code>值替换为对包对象的引用。 结果： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/95b/277/dd6/95b277dd63dc3aff1fdf3716c6881356.png" alt="转换后的deps.resolved"></p><br><p> 现在，进行依赖关系图查询要容易得多。 这是如何获取特定程序包的依赖项群集（即依赖项，依赖项依赖项等）的方法： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c64/793/a78/c64793a78d40961af1b234fc111e4dc2.png" alt="依赖关系群集示例"></p><br><blockquote> 一个出乎意料的成功故事：在编写本手册期间研究数据时，我在<code>@discoveryjs/cli</code>发现了一个问题（使用查询<code>.[deps.[not resolved]]</code> ），该问题在peerDependencies中有错字。 该问题立即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">得到解决</a> 。 该案例是此类工具如何提供帮助的一个很好的例子。 </blockquote><p> 也许现在是时候在首页上显示几个编号和包装的价格。 </p><br><h2 id="nastraivaem-startovuyu-stranicu"> 自定义起始页 </h2><br><p> 首先，我们需要创建一个页面模块，例如<code>pages/default.js</code> 。 我们使用<code>default</code> ，因为这是起始页面的标识符，我们可以覆盖它（在Discovery.js中，您可以覆盖很多东西）。 让我们从简单的例子开始，例如： </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'h1:#.name'</span></span>, <span class="hljs-string"><span class="hljs-string">'text:"Hello world!"'</span></span> ]);</code> </pre> <br><p> 现在，在配置中，您需要连接页面模块： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Node modules structure'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./collect-node-modules-data'</span></span>), <span class="hljs-attr"><span class="hljs-attr">view</span></span>: { <span class="hljs-attr"><span class="hljs-attr">assets</span></span>: [ <span class="hljs-string"><span class="hljs-string">'pages/default.js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ] } };</span></span></code> </pre> <br><p> 签入浏览器： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e0c/d07/8d5/e0cd078d55637ef62a697809544909b9.png" alt="覆盖的起始页"></p><br><p> 有效！ </p><br><p> 现在让我们得到一些计数器。 为此，请更改<code>pages/default.js</code> ： </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'h1:#.name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'inline-list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">item</span></span>: <span class="hljs-string"><span class="hljs-string">'indicator'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">`[ { label: 'Package entries', value: size() }, { label: 'Unique packages', value: name.size() }, { label: 'Dup packages', value: group(&lt;name&gt;).[value.size() &gt; 1].size() } ]`</span></span> } ]);</code> </pre> <br><p> 在这里，我们定义了指标的内联列表。  <code>data</code>值是创建记录数组的Jora查询。 软件包列表（数据根）用作查询的基础，因此我们获得列表长度（ <code>size()</code> ），唯一软件包名称的数量（ <code>name.size()</code> ）和重复的软件包名称的数量（ <code>group(&lt;name&gt;).[value.size() &gt; 1].size()</code> ）。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ebf/c97/8a2/ebfc978a2b2da44214a99a8382e17107.png" alt="将指标添加到起始页"></p><br><p> 还不错 尽管如此，最好还有链接到相应样本的链接： </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'h1:#.name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'inline-list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'Package entries'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'Unique packages'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'Dup packages'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'group(&lt;name&gt;).[value.size() &gt; 1]'</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">item</span></span>: <span class="hljs-string"><span class="hljs-string">`indicator:{ label, value: value.query(#.data, #).size(), href: pageLink('report', { query: value, title: label }) }`</span></span> } ]);</code> </pre> <br><p> 首先，我们更改了<code>data</code>的值，现在它是带有某些对象的常规数组。 此外， <code>size()</code>方法已从值请求中删除。 </p><br><p> 此外，子查询已添加到<code>indicator</code>视图。 这些类型的查询会为其中计算了<code>value</code>和<code>href</code>每个元素创建一个新对象。 对于<code>value</code> ，将使用<code>query()</code>方法执行<code>query()</code> ，从上下文将数据传输到该查询，然后将<code>size()</code>方法应用于查询结果。 对于<code>href</code> ，使用<code>pageLink()</code>方法，该方法生成具有特定请求和标题的报告页面的链接。 在完成所有这些更改之后，指示器变为可单击的（请注意，其值已变为蓝色），并且更具功能性。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e72/104/33c/e7210433ca45798701f34c6625cae050.gif" alt="可点击的指标"></p><br><p> 为了使起始页更有用，请添加包含重复包的表。 </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [ <span class="hljs-comment"><span class="hljs-comment">// ...      'h2:"Packages with more than one physical instance"', { view: 'table', data: ` group(&lt;name&gt;) .[value.size() &gt; 1] .sort(&lt;value.size()&gt;) .reverse() `, cols: [ { header: 'Name', content: 'text:key' }, { header: 'Version &amp; Location', content: { view: 'list', data: 'value.sort(&lt;version&gt;)', item: [ 'badge:version', 'text:path' ] } } ] } ]);</span></span></code> </pre> <br><p> 该表使用与“ <code>Dup packages</code>指示器相同的数据。 软件包列表按组大小反向排列。 其余设置与列相关（顺便说一下，通常无需配置）。 对于“ <code>Version &amp; Location</code>列，我们定义了一个嵌套列表（按版本排序），其中每个元素都是一对版本号和实例路径。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a50/5fd/4ab/a505fd4aba48f6a0d025fc5cd4b84b24.png" alt="添加了具有多个物理实例的包的表"></p><br><h2 id="stranica-paketov"> 套餐页面 </h2><br><p> 现在，我们只有软件包的一般概述。 但是，提供一个页面，其中包含有关特定软件包的详细信息将很有用。 为此，创建一个新的模块<code>pages/package.js</code>并定义一个新页面： </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'context'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">`{ name: #.id, instances: .[name = #.id] }`</span></span>, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: [ <span class="hljs-string"><span class="hljs-string">'h1:name'</span></span>, <span class="hljs-string"><span class="hljs-string">'table:instances'</span></span> ] });</code> </pre> <br><p> 在此模块中，我们使用标识符<code>package</code>定义了页面。  <code>context</code>组件用作初始表示。 这是一个非可视的组件，可以帮助您定义嵌套映射的数据。 请注意，我们使用<code>#.id</code>来获取包的名称，该包的名称是从类似<code>http://localhost:8123/#package:{id}</code>的URL中检索的。 </p><br><p> 不要忘记在配置中包括新模块： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { ... view: { <span class="hljs-attr"><span class="hljs-attr">assets</span></span>: [ <span class="hljs-string"><span class="hljs-string">'pages/default.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'pages/package.js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ] } };</span></span></code> </pre> <br><p> 结果在浏览器中： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3ee/698/da0/3ee698da0907aebaa1ace032942c0575.png" alt="包页面示例"></p><br><p> 不太令人印象深刻，但现在。 我们将在后续手册中创建更复杂的映射。 </p><br><h2 id="bokovaya-panel"> 侧板 </h2><br><p> 由于我们已经有了一个软件包页面，因此拥有所有软件包的列表将是一件很不错的事情。 为此，您可以定义一个特殊的视图<code>sidebar</code> ，如果已定义，则会显示该视图（默认情况下未定义）。 创建一个新的模块<code>views/sidebar.js</code> ： </p><br><pre> <code class="javascript hljs">discovery.view.define(<span class="hljs-string"><span class="hljs-string">'sidebar'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'name.sort()'</span></span>, <span class="hljs-attr"><span class="hljs-attr">item</span></span>: <span class="hljs-string"><span class="hljs-string">'link:{ text: $, href: pageLink("package") }'</span></span> });</code> </pre> <br><p> 现在，我们有了所有软件包的列表： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/503/326/a02/503326a020869af76a3b2076c5df2394.png" alt="添加了侧边栏"></p><br><p> 看起来不错 但是有了过滤器，效果会更好。 我们扩展<code>sidebar</code>的定义： </p><br><pre> <code class="javascript hljs">discovery.view.define(<span class="hljs-string"><span class="hljs-string">'sidebar'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'content-filter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'name.[no #.filter or $~=#.filter].sort()'</span></span>, <span class="hljs-attr"><span class="hljs-attr">item</span></span>: { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'link'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'{ text: $, href: pageLink("package"), match: #.filter }'</span></span>, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: <span class="hljs-string"><span class="hljs-string">'text-match'</span></span> } } });</code> </pre> <br><p> 在这里，我们将列表包装在<code>content-filter</code>组件中，该组件将输入字段中的输入值转换为正则表达式（如果该字段为空，则为<code>null</code> ）并将其另存为上下文中的<code>filter</code>值（可以使用<code>name</code>选项更改<code>name</code> ）。 同样，为了过滤列表中的数据，我们使用<code>#.filter</code> 。 最后，我们应用链接映射来突出显示具有<code>text-match</code>匹配部分。 结果： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d55/74f/67e/d5574f67e7a2dd222194c66f5ecf0673.png" alt="筛选清单"></p><br><p> 如果您不喜欢默认设计，则可以根据需要自定义样式。 假设您要更改侧边栏的宽度，为此，您需要创建一个样式文件（例如， <code>views/sidebar.css</code> ）： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.discovery-sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br><p> 并在配置中添加指向该文件以及JavaScript模块的链接： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { ... view: { <span class="hljs-attr"><span class="hljs-attr">assets</span></span>: [ ... <span class="hljs-string"><span class="hljs-string">'views/sidebar.css'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  assets    *.css  'views/sidebar.js' ] } };</span></span></code> </pre> <br><h2 id="avtossylki"> 自动连结 </h2><br><p> 本指南的最后一章专门介绍链接。 之前，使用<code>pageLink()</code>方法，我们链接到了包页面。 但是，除了链接之外，还必须设置链接文本。 但是，我们如何使它变得更容易呢？ </p><br><p> 为了简化链接的工作，我们需要定义一个生成链接的规则。 最好在<code>prepare</code>脚本中完成此操作： </p><br><pre> <code class="javascript hljs">discovery.setPrepare(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ ... const packageIndex = data.reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map, item</span></span></span><span class="hljs-function">) =&gt;</span></span> map .set(item, item) <span class="hljs-comment"><span class="hljs-comment">// key is item itself .set(item.name, item), // and `name` value new Map() ); discovery.addEntityResolver(value =&gt; { value = packageIndex.get(value) || packageIndex.get(value.name); if (value) { return { type: 'package', id: value.name, name: value.name }; } }); });</span></span></code> </pre> <br><p> 我们添加了新的程序包映射（索引），并将其用于实体解析器。 如果可能，实体解析器尝试将传递给它的值转换为实体描述符。 描述符包含： </p><br><ul><li>  <code>type</code> -实体类型 </li><li>  <code>id</code>对链接中用作ID的实体实例的唯一引用 </li><li>  <code>name</code> -用作链接文字 </li></ul><br><p> 最后，您需要将此类型分配给特定的页面（链接应指向某个地方，对吗？）。 </p><br><pre> <code class="javascript hljs">discovery.page.define(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, { ... }, { <span class="hljs-attr"><span class="hljs-attr">resolveLink</span></span>: <span class="hljs-string"><span class="hljs-string">'package'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    `package`    });</span></span></code> </pre> <br><p> 这些更改的第一个结果是，现在在<code>struct</code>视图中的某些值已标记为指向软件包页面的链接： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eb2/dcd/502/eb2dcd5024f589a3ba8180f2b1ec538f.png" alt="结构中的自动链接"></p><br><p> 现在，您还可以将<code>auto-link</code>组件应用于对象或包名称： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/64d/3c2/f24/64d3c2f244164a22c55ff433409f6e22.png" alt="使用自动链接"></p><br><p> 并且，例如，您可以对侧边栏稍做修改： </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   item: { view: 'link', data: '{ text: $, href: pageLink("package"), match: #.filter }', content: 'text-match' }, //   `auto-link` item: { view: 'auto-link', content: 'text-match:{ text, match: #.filter }' }</span></span></code> </pre> <br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 现在，您对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Discovery.js</a>的关键概念有了基本的了解。 在以下指南中，我们将仔细研究所涵盖的主题。 </p><br><p> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库中查看</a>该指南的完整源代码，也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试在线上工作</a> 。 </p><br><p> 在Twitter上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关注@js_discovery</a>以了解最新消息！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469115/">https://habr.com/ru/post/zh-CN469115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469097/index.html">具有php7，node.js和Redis的CentOS 8 Web服务器</a></li>
<li><a href="../zh-CN469099/index.html">在开发人员面试中测试任务-是否有意义？</a></li>
<li><a href="../zh-CN469101/index.html">学习英语：如何学习以英语为母语</a></li>
<li><a href="../zh-CN469109/index.html">木制玩具，第三部分-1989年</a></li>
<li><a href="../zh-CN469111/index.html">用var替换Object：可能出什么问题？</a></li>
<li><a href="../zh-CN469117/index.html">根据BC 0010于2019年进行编程</a></li>
<li><a href="../zh-CN469119/index.html">RIPE中的IPv4地址已结束。 完全结束...</a></li>
<li><a href="../zh-CN469125/index.html">雷鸟的黑暗主题是运行代码分析器的原因</a></li>
<li><a href="../zh-CN469127/index.html">优化或如何不让自己陷入困境</a></li>
<li><a href="../zh-CN469129/index.html">由于主题黑暗，Thunderbird必须运行代码分析器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>