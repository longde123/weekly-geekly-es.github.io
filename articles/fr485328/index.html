<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏻 🧀 🍀 Spécifications sur les stéroïdes 👩🏻‍🏫 🤚🏽 🤰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le thème des abstractions et de toutes sortes de beaux motifs est un bon terrain pour le développement d'holivars et de conflits éternels: d'une part,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spécifications sur les stéroïdes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/485328/">  Le thème des abstractions et de toutes sortes de beaux motifs est un bon terrain pour le développement d'holivars et de conflits éternels: d'une part, nous suivons le courant dominant, toutes sortes de mots à la mode et un code propre, d'autre part, nous avons une pratique et une réalité qui dictent toujours leurs propres règles. <br><br>  Que faire si les abstractions commencent à «fuir», comment utiliser les puces de langue et ce que vous pouvez retirer du modèle de «spécification» - voir sous la coupe. <br><a name="habracut"></a><br>  Alors, passons aux choses sérieuses.  L'article contiendra les sections suivantes: pour commencer, nous examinerons ce qu'est le modèle de «spécification» et pourquoi son application à des échantillons de la base de données dans sa forme pure pose des problèmes. <br><br>  Ensuite, nous nous tournons vers les arbres d'expression, qui sont un outil très puissant, et voyons comment ils peuvent nous aider. <br><br>  Enfin, je vais démontrer ma mise en œuvre de la «spécification» sur les stéroïdes. <br><br>  Commençons par les choses de base.  Je pense que tout le monde a entendu parler du modèle de «spécification», mais pour ceux qui ne l'ont pas entendu, voici sa définition de <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B5%25D1%2586%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia</a> : <br><br><blockquote>  Une «spécification» en programmation est un modèle de conception par lequel la représentation des règles de logique métier peut être transformée en une chaîne d'objets connectés par des opérations de logique booléenne. <br><br>  Ce modèle met en évidence de telles spécifications (règles) dans la logique métier qui peuvent être «couplées» avec d'autres.  Un objet de logique métier hérite ses fonctionnalités de la classe d'agrégat abstraite CompositeSpecification, qui contient une seule méthode IsSatisfiedBy qui renvoie une valeur booléenne.  Après l'instanciation, l'objet est enchaîné avec d'autres objets.  Par conséquent, sans perdre la flexibilité de configurer la logique métier, nous pouvons facilement ajouter de nouvelles règles. </blockquote><br>  En d'autres termes, une spécification est un objet qui implémente l'interface suivante (suppression des méthodes de construction de chaînes): <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Ici, tout est simple et clair.  Mais maintenant, regardons un exemple du monde réel dans lequel, en plus du domaine, il y a une infrastructure qui est aussi une personne impitoyable: tournons-nous vers le cas de l'utilisation d'ORM, un SGBD et des spécifications pour filtrer les données dans une base de données. <br><br>  Afin de ne pas être infondé et de ne pas pointer du doigt, nous prenons comme exemple le sujet suivant: supposons que nous développons des MMORPG, nous avons des utilisateurs, chaque utilisateur a 1 ou plusieurs caractères, et chaque personnage a un ensemble d'éléments ( nous faisons l'hypothèse que les éléments sont uniques à chaque utilisateur), et pour chacun des éléments, à leur tour, des runes d'amélioration peuvent être appliquées.  Au total, sous forme de diagramme (nous considérerons la classe ReadCharacter un peu plus tard lorsque nous parlerons de requêtes imbriquées): <br><br><img src="https://habrastorage.org/webt/k5/bx/iw/k5bxiwkvgl5vghoog71-9w6vqdo.png" alt="image"><br><br>  Ce modèle est vaguement connecté au monde réel, et il contient également des champs qui reflètent une certaine connexion avec l'ORM utilisé, mais cela nous suffira pour démontrer le travail. <br><br>  Supposons que nous voulons filtrer tous les caractères créés après la date spécifiée. <br>  Pour ce faire, nous écrivons une spécification du formulaire suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DateTime _target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { _target = target; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> character = candidate <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Character; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(character == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> character.CreatedAt &gt; target; } }</code> </pre><br>  Eh bien, pour appliquer cette spécification, nous faisons ce qui suit (ci-après, je considérerai le code basé sur NHibernate): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> characters = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> session.Query&lt;Character&gt;().ToListAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newCharacters = characters.Where(x =&gt; filter.IsSatisfiedBy(x)).ToArray();</code> </pre><br>  Tant que notre base est petite, tout fonctionnera magnifiquement et rapidement, mais si notre jeu devient plus ou moins populaire et gagne quelques dizaines de milliers d'utilisateurs, tout ce charme consommera de la mémoire, du temps et de l'argent, et il vaut mieux tirer sur cette bête tout de suite parce que  il n'est pas locataire.  Sur cette triste note, nous allons reporter la spécification et nous tournerons un peu vers ma pratique. <br><br>  Il était une fois, dans un projet très, très éloigné, j'avais des classes dans mon code qui contenaient une logique pour récupérer des données de la base de données.  Ils ressemblaient à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ICharacterDal</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBetween</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, DateTime to</span></span></span><span class="hljs-function">)</span></span>; ... }</code> </pre><br>  et leur utilisation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterDal(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdCharacters = dal.GetCharactersCreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  À l'intérieur des classes se trouvait la logique de travail avec le SGBD (à l'époque c'était ADO.NET). <br><br>  Tout semblait bien, mais avec l'expansion du projet, ces classes se sont également développées, devenues des objets difficiles à entretenir.  De plus, il y avait un arrière-goût désagréable - cela semble être une règle commerciale, mais ils étaient stockés au niveau de l'infrastructure, car ils étaient liés à une implémentation spécifique. <br><br>  Cette approche a été remplacée par le référentiel <i>IQueryable &lt;T&gt;</i> , qui a permis de prendre toutes les règles directement dans la couche domaine. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRepository</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  qui a été utilisé quelque chose comme ça: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdUsers = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> repository.List().Where(x =&gt; x.CreatedAd &gt; targetDate).ToListAsync();</code> </pre><br>  Un peu plus agréable, mais le problème est que les règles se glissent le long du code, et la même vérification peut se produire dans des centaines d'endroits, et il est facile d'imaginer ce que cela peut entraîner en modifiant les exigences. <br><br>  Cette approche cache un autre problème - si vous ne matérialisez pas la requête, c'est-à-dire une chance de répondre à plusieurs requêtes dans la base de données au lieu d'une, ce qui, bien sûr, affecte négativement les performances du système. <br><br>  Et ici, sur l'un des projets, un collègue a suggéré d'utiliser une <a href="https://github.com/rjperes/DevelopmentWithADot.NHibernateSpecifications">bibliothèque</a> qui a suggéré la mise en œuvre du modèle de «spécification» basé sur des arbres d'expression. <br><br>  Bref, sur la base de cette bibliothèque, nous avons filmé des spécifications qui nous ont permis de créer des filtres pour les entités et de construire des filtres plus complexes basés sur des concaténations de règles simples.  Par exemple, nous avons une spécification pour les personnages créés après la nouvelle année et il y a une spécification pour choisir les personnages avec un certain élément - puis en combinant ces règles, nous pouvons construire une demande pour une liste de personnages créés après la nouvelle année et ayant l'élément spécifié.  Et si à l'avenir nous changerons la règle pour déterminer de nouveaux caractères (par exemple, nous utiliserons la date du nouvel an chinois), nous la corrigerons uniquement dans la spécification elle-même et il n'est pas nécessaire de rechercher toutes les utilisations de cette logique par code! <br><br>  Ce projet a été mené à bien et l'expérience de l'utilisation de cette approche a été très réussie.  Mais je ne voulais pas rester immobile, et il y avait quelques problèmes dans la mise en œuvre, à savoir: <br><br><ul><li>  l'opérateur de collage OR n'a pas fonctionné; </li><li>  l'union ne fonctionne que pour les requêtes qui contiennent des filtres de type Where, mais je voulais des règles plus riches (requêtes imbriquées, sauter / prendre, obtenir des projections); <br></li><li>  le code de spécification dépendait de l'ORM sélectionné; </li><li>  il n’a pas été possible d’utiliser les fonctions ORM,  cela a conduit à l'inclusion de dépendances sur celui-ci dans la couche logique métier (par exemple, il était impossible de faire une extraction). <br></li></ul><br>  Le résultat de la résolution de ces problèmes a été le mini-framework <i>Singularis.Secification</i> , qui se compose de plusieurs assemblages: <br><br><ul><li>  Singularis.Specification.Definition - définit l'objet de spécification et contient également l'interface IQuery avec laquelle la règle est formée. </li><li>  Singularis.Specification.Executor. * - implémente un référentiel et un objet pour exécuter des spécifications pour des ORM spécifiques (actuellement pris en charge par ef.core et NHibernate, dans le cadre des expériences, j'ai également fait une implémentation pour mongodb, mais ce code n'est pas entré en production). </li></ul><br>  Examinons de plus près la mise en œuvre. <br><br>  L'interface de spécification définit la propriété publique que contient la règle de spécification: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { IQuery Query { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Type ResultType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpefication</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { }</code> </pre><br>  De plus, l'interface contient la propriété <i>ResultType</i> , qui renvoie le type d'entité obtenu à la suite de la requête. <br><br>  Son implémentation est contenue dans la classe <i>Specification &lt;T&gt;</i> , qui implémente la propriété <i>ResultType</i> , la calculant en fonction de la règle stockée dans Query, ainsi que de deux méthodes: <i>Source ()</i> et <i>Source &lt;TSource&gt; ()</i> .  Ces méthodes servent à former la source de la règle.  <i>Source ()</i> crée une règle avec un type qui correspond à l'argument de la classe de spécifications, et <i>Source &lt;TSource&gt; ()</i> vous permet de créer une règle pour une classe arbitraire (utilisée lors de la génération de requêtes imbriquées). <br><br>  En outre, il existe également la classe <i>SpecificationExtension</i> , qui contient des méthodes d'extension pour chaîner les demandes. <br><br>  Deux types de jonction sont pris en charge: la concaténation (peut être considérée comme la jonction par la condition «ET») et la jonction par la condition «OU». <br><br>  Revenons à notre exemple et implémentons nos deux règles: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &gt; target); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedBefore</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &lt; target); } }</code> </pre><br>  et trouvez tous les utilisateurs qui satisfont aux deux règles: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Combine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification);</code> </pre><br>  La combinaison avec la méthode <i>Combine</i> prend en charge des règles arbitraires.  L'essentiel est que le type résultant du côté gauche coïncide avec le type d'entrée du côté droit.  Ainsi, vous pouvez créer des règles contenant des projections, ignorer / prendre pour la pagination, les règles de tri, récupérer, etc. <br><br>  La règle Ou est plus restrictive - elle ne prend en charge que les chaînes contenant des conditions de filtrage Where.  Prenons l'exemple: on retrouve tous les personnages créés avant 2000 ou après 2020: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Or(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification );</code> </pre><br>  L'interface <i>IQuery</i> répète largement l'interface <i>IQueryable</i> , donc il ne devrait pas y avoir de questions spéciales.  Arrêtons-nous uniquement sur des méthodes spécifiques: <br><br>  <i>Fetch / ThenFetch</i> - vous permet d'inclure des données connexes dans la requête générée à des fins d'optimisation.  Bien sûr, c'est un peu tordu lorsque nous avons des caractéristiques de la mise en œuvre de l'infrastructure qui affectent les règles commerciales, mais, comme je l'ai dit, la réalité est des abstractions dures et pures - c'est une chose plutôt théorique. <br><br>  <i>Où</i> - <i>IQuery</i> déclare deux surcharges de cette méthode, l'une prend juste une expression lambda pour le filtrage sous la forme <i>Expression &lt;Func &lt;T, bool &gt;&gt;</i> , et la seconde prend également des paramètres supplémentaires <i>IQueryContext</i> , qui vous permet d'exécuter des sous-requêtes imbriquées.  Regardons un exemple. <br><br>  Nous avons la classe ReadCharacter dans le modèle - supposons que notre modèle est présenté comme une partie en lecture qui contient des données dénormalisées et sert à un retour rapide, et une partie en écriture qui contient des liens, des données normalisées, etc.  Nous voulons afficher tous les caractères pour lesquels l'utilisateur a du courrier sur un domaine spécifique. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ReadCharacter</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> domain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersQuery = Source&lt;User&gt;(x =&gt; x.Email.Contains(domain)).Projection(x =&gt; x.Id); Query = Source().Where((x, ctx) =&gt; ctx.GetQueryResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(usersQuery).Contains(x.Id)); } }</code> </pre><br>  À la suite de l'exécution, la requête SQL suivante sera générée: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> readcharac0_.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id1_3_, readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> userid2_3_, readcharac0_.Name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> name3_3_ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ReadCharacters readcharac0_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> user1_.Id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Users</span></span> user1_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> user1_.Email <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> (<span class="hljs-string"><span class="hljs-string">'%'</span></span>+@p0+<span class="hljs-string"><span class="hljs-string">'%'</span></span>) ); @p0 = '@inmagna.ca' [Type: String (4000:0:0)]</code> </pre><br>  Pour remplir toutes ces merveilleuses règles, l'interface <i>IRepository</i> est <i>définie</i> , ce qui vous permet de recevoir des éléments par identifiant, de recevoir un (le premier approprié) ou une liste d'objets selon la spécification, ainsi que d'enregistrer et de supprimer des éléments du référentiel. <br>  Avec la définition des requêtes, nous avons compris, maintenant il reste à apprendre à notre ORM à comprendre cela. <br>  Pour ce faire, nous analyserons l'assemblage de <i>Singularis.Infrastructure.NHibernate</i> (pour ef.core tout se ressemble, uniquement avec les spécificités d'ef.core). <br><br>  Le point d'accès aux données est l'objet Repository, qui implémente l'interface <i>IRepository</i> .  En cas de réception d'un objet par identifiant, ainsi que de modification du stockage (sauvegarde / suppression), cette classe termine une session et masque une implémentation spécifique de la couche métier.  Dans le cas de l'utilisation de spécifications, il forme un objet <i>IQueryable</i> qui reflète notre requête en termes d' <i>IQuery</i> , puis l'exécute sur l'objet session. <br><br>  La magie principale et le code le plus laid se trouvent dans la classe responsable de la conversion d' <i>IQuery</i> en <i>IQueryable</i> - SpecificationExecutor.  Cette classe contient beaucoup de réflexion, qui appelle des méthodes Queryable ou des méthodes d'extension d'un ORM spécifique (EagerFetchingExtensionsMethods pour NHiberante). <br><br>  Cette bibliothèque est activement utilisée dans nos projets (pour être honnête, une bibliothèque déjà mise à jour est utilisée pour nos projets, mais progressivement tous ces changements seront présentés dans le domaine public) est en constante évolution.  Il y a quelques semaines à peine, la prochaine version est sortie, qui est passée aux méthodes asynchrones, des bogues ont été corrigés dans executor'e pour ef.core, des tests et des échantillons ont été ajoutés.  Il est probable que la bibliothèque contienne des erreurs et une centaine de points d'optimisation - elle est née en tant que projet parallèle dans le cadre des travaux sur les principaux projets, donc je serai heureux de suggérer des suggestions d'amélioration.  De plus, vous ne devez pas vous précipiter pour l'utiliser - il est probable que dans votre cas particulier, cela sera inutile ou inapplicable. <br><br>  Quand vaut-il la peine d'utiliser la solution décrite?  Il est probablement plus facile de partir de la question «quand ne devrait pas»: <br><br><ul><li>  highload - si vous avez besoin de hautes performances, l'utilisation de l'ORM lui-même soulève une question.  Bien sûr, personne n'interdit d'implémenter un exécuteur qui traduira les requêtes en SQL et les exécutera ... </li><li>  de très petits projets - c'est très subjectif, mais, vous devez l'admettre, tirer l'ORM et tout le zoo qui l'accompagne dans le projet "todo list" ressemble à tirer des moineaux à partir d'un canon. </li></ul><br>  En tout cas, qui a maîtrisé la lecture jusqu'à la fin - merci pour votre temps.  J'espère avoir des commentaires pour un développement futur! <br><br>  J'ai presque oublié - le code du projet est disponible sur GitHub'e - <a href="https://github.com/SingularisLab/singularis.specification">https://github.com/SingularisLab/singularis.specification</a> <br><br><div class="spoiler">  <b class="spoiler_title">Les assemblages sont disponibles pour téléchargement via nuget</b> <div class="spoiler_text"><ul><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Definition/">https://www.nuget.org/packages/Singularis.Specification.Definition/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/">https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Common/">https://www.nuget.org/packages/Singularis.Specification.Executor.Common/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/">https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485328/">https://habr.com/ru/post/fr485328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485316/index.html">Tous les SERP Google ressemblent désormais à des publicités</a></li>
<li><a href="../fr485318/index.html">Ajout de beauté et d'interactivité aux ordinateurs portables Jupyter</a></li>
<li><a href="../fr485322/index.html">Parlez de PostgreSQL. Entretien avec Alexei Lesovsky dans le podcast Zinc Prod. Première partie</a></li>
<li><a href="../fr485324/index.html">Multithreading dans les widgets Qt</a></li>
<li><a href="../fr485326/index.html">Création de micro frontends à l'aide d'éléments angulaires: guide du débutant</a></li>
<li><a href="../fr485330/index.html">Comment battre au hasard sans âme dans les jeux roguelike</a></li>
<li><a href="../fr485334/index.html">Sondage de session</a></li>
<li><a href="../fr485336/index.html">L'ITMO University: conférences, ateliers, concours et divertissements</a></li>
<li><a href="../fr485338/index.html">Comment surmonter la peur et commencer à utiliser Azure Machine Learning</a></li>
<li><a href="../fr485342/index.html">Comment s'est passé 2019 dans le domaine des mathématiques et de l'informatique?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>