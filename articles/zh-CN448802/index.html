<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌡️ 👨🏻‍🚒 📡 关于门户网站的思考：在虚幻引擎4中创建门户网站 👨🏽‍🍳 🖍️ 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将告诉您如何在虚幻引擎4中创建门户。我没有找到任何详细描述此类系统的资源（通过门户进行监视并通过门户），因此我决定编写自己的系统。 

 什么是门户？ 
 让我们从门户的示例和解释开始。 将门户网站描述为从一个空间到另一个空间的通道的最简单方法。 在某些流行游戏中，此概念用于视觉效果，甚...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于门户网站的思考：在虚幻引擎4中创建门户网站</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="图片"></div><br> 在本文中，我将告诉您如何在虚幻引擎4中创建门户。我没有找到任何详细描述此类系统的资源（通过门户进行监视并通过门户），因此我决定编写自己的系统。 <br><br><h2> 什么是门户？ </h2><br> 让我们从门户的示例和解释开始。 将门户网站描述为从一个空间到另一个空间的通道的最简单方法。 在某些流行游戏中，此概念用于视觉效果，甚至用于游戏机制： <br><br><div class="spoiler">  <b class="spoiler_title">游戏入口范例（GIF）</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber（2013）和Portal（2007）</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>猎物，2006年</i> </div></div><br> 在这三款游戏中，最著名的可能是《传送门》，但我个人一直很喜欢《猎物》，我想复制的就是她。 曾经尝试在Unreal Engine 4中实现自己的版本，但由于引擎缺乏功能，因此并没有真正成功。 不过，我设法进行了以下实验： <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"> 您的浏览器不支持HTML5视频。 <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br> 但是，只有在新版本的虚幻引擎中，我才最终设法达到预期的效果： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2> 门户-它们如何工作？ </h2><br> 在继续具体操作之前，让我们看一下门户如何工作的一般情况。 <br><br> 实际上，门户网站是一个没有外在，而是到另一个地方的窗口，也就是说，我们在本地设置了相对于对象的特定视点，并将该视点复制到其他位置。 使用此原理，即使两个空间彼此距离很远，我们也可以将它们连接起来。 窗口就像一个遮罩，使我们可以找出何时何地显示另一个空间而不是原始空间。 由于视图的起点已复制到其他地方，因此给了我们连续性的错觉。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br> 在此图像中，捕获设备（UE4中的SceneCapture）位于与从玩家的角度看到的空间相对应的空间的前面。 该行之后可见的所有内容都将替换为捕获内容。 由于捕获设备可以位于门和其他物体之间，因此使用所谓的“裁剪平面”很重要。 对于门户，我们希望封闭的剪切平面遮盖门户前面可见的对象。 <br><br> 总结一下。 我们需要： <br><br><ul><li> 玩家位置 </li><li> 门户入口点 </li><li> 门户出口点 </li><li> 带有剪切平面的剪切装置 </li></ul><br> 如何在虚幻引擎中实现呢？ <br><br> 我基于<b>PlayerController</b>和<b>Character</b>管理的两个主要类构建了系统。  <b>Portal</b>类是一个真实的门户入口点，其视图/出口点是Target actor。 还有一个<b>Portal Manager</b> ，由PlayerController生成并由Character更新，以在级别上管理每个门户并对其进行更新，以及操作SceneCapture对象（所有门户网站都通用）。 <br><br><blockquote> 请记住，本教程希望您可以从代码访问Character和PlayerController类。 就我而言，它们称为ExedreCharacter和ExedrePlayerController。 </blockquote><br><h2> 创建门户网站演员类 </h2><br> 让我们从门户网站的参与者开始，它将用于设置“窗口”，通过这些窗口我们可以查看关卡。 演员的任务是提供有关玩家的信息，以计算各种位置和转弯。 他还将从事识别玩家是否穿过门户及其传送的活动。 <br><br> 在开始对参与者进行详细讨论之前，让我解释一下我为管理门户网站系统而创建的一些概念： <br><br><ul><li> 为了方便拒绝计算，门户网站处于活动/不活动状态。 此状态由Portal Manager更新。 </li><li> 门户的正面和背面由其位置和方向（正向向量）确定。 </li><li> 为了找出玩家是否跨过门户，他存储了玩家的先前位置并将其与当前位置进行比较。 如果在以前的衡量标准中，玩家位于门户的前面，而当前玩家位于门户后面，那么我们认为玩家越过了门户。 反向行为将被忽略。 </li><li> 门户网站有一个限制数量，以便在玩家进入此数量之前不进行计算和检查。 示例：如果玩家实际上没有触摸门户，则忽略路口。 </li><li> 播放器的位置是根据摄像头的位置计算得出的，以确保当视点穿过门户而不是播放器的身体时正确的行为。 </li><li> 门户接收一个“渲染目标”，如果下次纹理不正确并且需要替换，则在每个度量中显示一个不同的视点。 </li><li> 门户网站存储到另一个名为Target的actor的链接，以便知道要在何处联系其他空间。 </li></ul><br> 使用这些规则，我创建了一个新的ExedrePortal类，该类继承自AActor。 这是它的标题： <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br> 如您所见，这里描述了大多数行为。 现在，让我们看看它们是如何在体内（.cpp）处理的。 <br><br><hr><br> 设计人员正在准备根组件。 我决定创建两个根组件，因为门户网站参与者将结合图形效果和碰撞/识别。 因此，我需要一种简单的方法来确定窗口/门户平面的位置，而无需蓝牙功能或其他技巧。  PortalRootComponent将成为与门户相关的所有计算的基础。 <br><br> 如果Blueprint类将其动画化（例如，使用打开/关闭动画），则门户网站根设置为动态。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br> 只有Get和Set函数，仅此而已。 我们将从另一个地方管理活动状态。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br> 蓝图事件，我在C ++类中不做任何事情。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br> 目标角色的获取和设置功能。 这部分也没有什么更复杂的。 <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br> 使用此功能，我们可以轻松地检查点是否在平面前面，在我们的情况下，该点是入口。 该函数使用UE4引擎的FPlane结构执行计算。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br> 此功能检查该点是否已穿过门平面。 在这里，我们使用旧位置来找出该点的行为。 此功能很常见，因此可以与任何演员一起使用，但在我的情况下，仅与播放器一起使用。 <br><br> 该函数在先前位置和当前位置之间创建方向/线段，然后检查它们是否与平面相交。 如果是这样，则我们检查它是否沿正确的方向交叉（从前到后？）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2> 传送演员 </h2><br> 我们将讨论的门户网站参与者的最后一部分是<b>TeleportActor（）</b>函数。 <br><br> 将角色从A点传送到B点时，您需要复制其移动和位置。 例如，如果玩家进入门户，然后结合适当的视觉效果，在他看来他就穿过了普通的门。 <br><br> 门户的交集感觉就像是直线移动，但是实际上发生了完全不同的事情。 退出门户网站后，玩家可能会处于完全不同的环境中。 考虑一个来自门户网站的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br> 如您所见，穿过门户时，摄像机相对于其前向矢量旋转（旋转）。 这是因为起点和终点平行于不同的平面： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br> 因此，为了使其正常工作，我们需要将玩家的动作转换为门户的相对空间，以便将其转换为目标空间。 通过执行此操作，我们可以确保进入门户并从另一侧退出之后，播放器将相对于空间正确对齐。 这不仅适用于演员的位置和旋转，还适用于他的<b>速度</b> 。 <br><br><blockquote> 如果我们不做任何改变就传送一个角色，将其转换为局部旋转，那么结果是，该角色可以倒立。 这可能适用于对象，但不适用于角色或玩家本人。 您需要更改actor的位置，如上面Portal示例中所示。 </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br> 您可能已经注意到，要调用旋转/位置，我要调用外部函数。 从UTool用户类中调用它们，该类定义了可以在任何地方（包括蓝图）调用的静态函数。 它们的代码如下所示，您可以按照最合适的方式实现它们（将它们放在Portal actor类中可能会更容易）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br> 这里的变换是通过计算向量的标量积来确定不同角度来执行的。 方向向量未归一化，也就是说，我们可以再次将点结果与目标向量相乘，以在目标角色的局部空间中获得完全相同距离的位置。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br> 转变转型有点难以实施。 最后，最好的解决方案是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">四元数</a> ，因为这比使用正常的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">欧拉角</a>更精确，并且只需要几行代码。 四元数的旋转使用乘法进行，因此在我们的示例中，将Inverse（）应用于要转换的旋转，我们会将其移动到局部空间。 接下来，我们只需要将其再乘以目标转弯数即可获得最后一转弯。 <br><br><h2> 创建门户网格 </h2><br> 为了从玩家的角度看起来很漂亮，我的门户网站系统使用了特定的网格。 网格划分为两个不同的平面： <br><br><ul><li>  <b>平面1</b> ：显示门户网站渲染目标的主平面。 这架飞机有一种非常不寻常的行为，因为它的任务是在玩家接近时将其向后推一点，以免被相机夹住。 由于平面的边界不移动，而仅其中间峰移动，因此允许玩家叠加渲染门户而没有视觉伪像。 边缘的边缘在上半部分具有自己的UV，而内部边缘的下半部分具有自己的UV，这使在着色器中轻松遮罩它们成为可能。 </li><li>  <b>平面2</b> ：此平面仅用于扩展网格的标准边界框。 顶点的法线朝下，因此，即使在非平面地面上，默认情况下也将看不到网格（因为渲染材料将不会是双面的）。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br> 为什么要使用这样的网格？ <br><br> 我决定随着玩家的接近，“平面1”将伸展。 这允许播放器重叠门户并通过它而不会修剪（剪切）。 例如，如果摄像头尚未越过门户的平面，但玩家的脚已经触摸过门户，则可能发生这种情况。 这样一来，您就无需切断播放器并复制网格。 <br><br>  “平面2”任务是扩展网格的标准边界框。 由于“平面1”是平坦的，因此一轴上的边界框的厚度为0，并且如果摄影机在其后方，则引擎会将其切除（即，它将不会渲染）。 平面1的尺寸为128×128，因此可以使用引擎轻松缩放。 平面2稍大且在地板下方（0之下）。 <br><br> 创建网格后，我们只需从第三方3D编辑器中将其导出并导入到Unreal中即可。 它将在下一步中使用。 <br><br><h2> 创建门户资料 </h2><br> 要显示门户的另一侧，我们需要创建自己的材料。 在内容浏览器中创建新材料（我称之为<b>MAT_PortalBase</b> ）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br> 现在打开它并创建以下图形： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br> 材料的工作方式如下： <br><br><ul><li>  <b>FadeColor</b>是当其距离很远时将通过门户可见的颜色。 这是必需的，因为我们并不总是渲染所有门户，因此当播放器/摄像机距离很远时，我们会遮挡渲染。 </li><li> 为了找出玩家离门户有多远，我确定了摄像机位置和演员位置之间的<b>距离</b> 。 然后，我将距离除以要进行比较的最大值。 例如，如果我设置的最大值为2000，而距播放器的距离为1000，则得到0.5。 如果玩家走得更远，那么我会得到一个大于1的值，所以我使用饱和节点对其进行限制。 接下来是Smoothstep节点，用于将距离缩放为渐变并更精确地控制门户着色。 例如，我想要在玩家关闭时阴影完全消失。 </li><li> 我将距离计算用作<b>Lerp</b>节点的Alpha通道值，以混合阴影颜色和将渲染门户目标的<b>纹理</b> 。 </li><li> 最后，我隔离UV坐标的Y分量以创建一个遮罩，使您知道将推动网格的哪些顶点。 我将此面罩乘以我所需的排斥力。 我使用一个负值，以便当顶点的法线与顶点相乘时，它们沿相反的方向移动。 </li></ul><br> 完成所有这些之后，我们创建了即用型材料。 <br><br><h2> 在钝器中创建门户网站参与者 </h2><br> 让我们建立一个新的继承自Portal actor的蓝图类。 右键单击内容浏览器，然后选择Blueprint类： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br> 现在，在搜索字段中输入“门户”以选择门户类别： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br> 如果尚未打开蓝牙，请打开它。 在组件列表中，您将看到以下层次结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br> 如我们所料，有一个根组件和门户网站根。 让我们向PortalRootComponent添加一个静态网格物体组件，并将上一步中创建的网格物体加载到其中： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br> 我们还添加了“碰撞盒”，该盒将用于确定玩家是否在门户区域内： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br> 碰撞框位于与主根相关联的场景组件下方，而不位于门户网站根下方。 我还添加了一个图标（广告牌）和一个箭头组件，以使门户在各个级别上更加可见。 当然，这不是必需的。 <br><br> 现在，让我们在蓝图中设置材料。 <br><br> 首先，我们需要两个变量-一个变量为<b>Actor</b>类型，名称为<b>PortalTarget</b> ，第二个变量为<b>Dynamic Material Instance</b>类型，并称为<b>MaterialInstance</b> 。  PortalTarget将是对门户窗口正在查看的位置的引用（因此，该变量是常见的，带有睁开的眼睛图标），以便我们可以在将actor放置在水平位置时对其进行更改。  MaterialInstance将存储到动态材质的链接，以便将来我们可以动态分配门户的渲染目标。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br> 我们还需要添加我们自己的事件节点。 最好在“ <b>事件图”中</b>打开右键单击菜单，然后找到<b>事件</b>的名称： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br> 在这里创建下图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>开始播放</b> ：在这里，我们调用门户网站的父函数SetTarget（）为其分配到演员的链接，该链接随后将用于SceneCapture。 然后，我们创建一个新的动态材质，并为其指定MaterialInstance变量的值。 使用这种新材料，我们可以将其分配给“静态网格物体组件”。 我还为材质提供了虚拟纹理，但这是可选的。 </li><li>  <b>清除RTT</b> ：此功能的目的是清除分配给门户材料的“渲染目标”纹理。 它由门户网站管理器启动。 </li><li>  <b>设置RTT</b> ：此功能的目的是设置门户网站的渲染目标材料。 它由门户网站管理器启动。 </li></ul><br> 到目前为止，我们已经完成了蓝牙的工作，但是稍后将返回到蓝牙以实现Tick功能。 <br><br><h2> 门户网站经理 </h2><br> 因此，现在我们有了创建从AActor继承的新类（即Portal Manager）所需的所有基本元素。 您的项目中可能不需要Portal Manager类，但就我而言，它极大地简化了某些方面的工作。 这是门户网站管理器执行的任务列表： <br><br><ul><li> 门户管理器是<b>由玩家控制器创建</b>并附加到其上的角色，用于跟踪游戏级别内玩家的状态和演变。 </li><li> 创建并销毁<b>渲染目标门户</b> 。 该想法是动态创建与播放器的屏幕分辨率匹配的渲染目标纹理。 此外，在游戏过程中更改分辨率时，经理将自动将其转换为所需的大小。 </li><li> 门户网站管理器<b>查找并更新</b>门户网站参与者级别，以为他们提供渲染目标。 以确保与级别流兼容的方式执行此任务。 当新演员出现时，他应该得到一个纹理。 此外，如果“渲染”目标发生变化，则管理者还可以自动分配一个新对象。 这使管理系统更加容易，而不是让每个Portal actor手动联系管理员。 </li><li>  <b>SceneCapture</b>组件<b>已</b>附加到门户网站管理器，以便不为每个门户网站创建一个副本。 此外，它使您每次我们在级别上切换到特定门户网站参与者时都可以重用它。 </li><li> 门户决定<b>传送</b>播放器时，它将向门户管理器发送请求。 为了同时更新源门户和目标门户（如果有），这是必需的，这样过渡就可以实现。 </li><li> 在“ <b>角色”勾号（）</b>函数的末尾会<b>更新</b>门户网站管理器，以便正确更新所有内容，包括玩家的相机。 这样可以确保屏幕上的所有内容都同步，并避免引擎渲染期间延迟一帧。 </li></ul><br> 让我们看一下Portal Manager标头： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br> 在详细介绍之前，我将展示如何从PlayerController类（从BeginPlay（）函数调用）创建actor： <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br> 因此，我们创建一个actor，将其附加到播放器的控制器（this），然后保存链接并调用Init（）函数。 <br><br> 还需要注意的是，我们从Character类中手动更新actor： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br> 这是Portal Manager的构造函数。 请注意，由于我们将通过播放器手动更新Portal Manager，因此Tick被禁用。 <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br> 这是get / set Portal Manager的功能（此后，我们将继续介绍更有趣的事情）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br> 显然，首先要开始的是<b>Init（）</b>函数。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此功能的主要目的是创建SceneCapture组件（即上述捕获设备）并正确配置它。</font><font style="vertical-align: inherit;">首先创建一个新对象，并将其注册为该参与者的组件。</font><font style="vertical-align: inherit;">然后，我们继续设置与此捕获有关的属性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要提到的属性：</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我们不希望在不需要捕获时打开捕获。</font><font style="vertical-align: inherit;">我们将手动对其进行管理。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一个非常重要的属性，用于正确呈现门户捕获。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：这使我们可以根据玩家的观点将Capture投影替换为我们自己的。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：此模式有点昂贵，但是必须呈现足够数量的信息。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其余属性主要与后处理参数有关。</font><font style="vertical-align: inherit;">它们是控制质量并因此捕获性能的便捷方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一部分调用创建渲染目标的函数，我们将在下面看到。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当您需要为门户网站创建新的“渲染目标”纹理时，</font><b><font style="vertical-align: inherit;">GeneratePortalTexture（）</font></b><font style="vertical-align: inherit;">是在必要时调用的函数。</font><font style="vertical-align: inherit;">这发生在初始化功能中，但也可以在Portal Manager升级期间调用。</font><font style="vertical-align: inherit;">这就是为什么此功能具有内部检查以更改视口分辨率的原因。</font><font style="vertical-align: inherit;">如果未发生，则不执行更新。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就我而言，我为UCanvasRenderTarget2D创建了一个包装器类。我称它为ExedreScriptedTexture，它是可以附加到actor的组件。我创建了此类，以便与具有渲染任务的角色方便地管理渲染目标。他对渲染目标进行了正确的初始化，并且与我自己的UI系统兼容。但是，在门户网站的上下文中，常规的RenderTarget2D纹理绰绰有余。因此，您可以简单地使用它。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，我创建了自己的类，因此此处设置的属性必须适应通常的“渲染目标”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要了解捕获将在何处显示。</font><font style="vertical-align: inherit;">由于渲染目标将显示在游戏中，因此这将在整个后期处理之前发生，因此我们需要使用足够的信息渲染场景（存储大于1的值以创建Bloom）。</font><font style="vertical-align: inherit;">这就是为什么我选择RGBA16格式的原因（请注意，它具有自己的Enum，您将需要使用ETextureRenderTargetFormat）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关更多信息，请参见以下资源：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，我们将考虑更新功能。</font><font style="vertical-align: inherit;">基本功能非常简单，导致更复杂。</font><font style="vertical-align: inherit;">调用GeneratePortalTexture（）函数之前有一个延迟，以避免在调整视口大小时（例如，在编辑器中）重新创建渲染目标。</font><font style="vertical-align: inherit;">在游戏发行期间，可以消除此延迟。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来查找当前世界中存在的所有门户（包括所有已加载的级别）并进行更新。</font><font style="vertical-align: inherit;">该功能还确定哪个是“活动的”，即 </font><font style="vertical-align: inherit;">对玩家可见。</font><font style="vertical-align: inherit;">如果找到活动的门户，则调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它控制SceneCapture组件。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是世界更新在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld（）中的工作方式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定传送门正确性的检查很简单：我们将最接近玩家的传送门作为优先级，因为从他的角度来看，他很可能是最可见的。</font><font style="vertical-align: inherit;">要放下亲戚，但例如，放置在玩家身后的门户，则需要进行更复杂的检查，但我不想在本教程中着重介绍这一点，因为这可能会变得非常困难。</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在该考虑</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数了</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一项升级功能，可捕获门户的另一端。</font><font style="vertical-align: inherit;">从注释中，所有内容都应该清楚，但是这里有一个简短描述：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们获得</font><font style="vertical-align: inherit;">了角色和玩家控制器的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切是否正确</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Portal，SceneCapture组件，Player）。</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如我们所见，在传送玩家时，SceneCapture自然无瑕的行为的关键要素是将门户的位置和旋转正确转换到本地目标空间。 </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有关ConvertLocationToActorSpace（）的定义，请参见“传送角色”。 </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在类的默认的PlayerController不存在，我说我自己。</font><font style="vertical-align: inherit;">如下图所示：</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们需要实现对Teleport函数的调用。</font><font style="vertical-align: inherit;">通过门户网站管理器进行部分传送处理的原因是，必须保证必要门户的更新，因为只有管理器才具有有关场景中所有门户的信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们有两个已连接的门户，那么从一个门户切换到另一个门户时，我们需要在一个标记中更新两个门户。</font><font style="vertical-align: inherit;">否则，播放器将进行传送并位于传送门的另一侧，但是目标传送门将在下一帧/小节之前处于活动状态。</font><font style="vertical-align: inherit;">这将与我们在上面看到的平面网格的偏移材质产生视觉间隙。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 就是这样，我们终于完成了Portal Manager！ </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成蓝图 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成Portal Manager之后，我们只需要完成Portal actor本身，然后系统即可工作。</font><font style="vertical-align: inherit;">唯一缺少的是刻度线功能：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运作方式如下： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们正在更新</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以使其不会保持活动状态。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果门户网站当前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处于非活动状态</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则其余度量将被丢弃。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们获得了Character类来访问</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera Location</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一部分检查摄像头是否在门户的冲突框中。</font><font style="vertical-align: inherit;">如果是这样，那么我们用其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偏移门户网格</font><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二部分是重新检查碰撞盒内的位置。</font><font style="vertical-align: inherit;">如果执行了该命令，那么我们将调用一个函数来检查</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否穿越门户</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我的图表的屏幕截图中，您可以注意到两个有趣的地方：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盒子里面是点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取门户网站管理器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我还没有解释这两个功能。这些是我在自己的类中定义的静态函数，因此您可以从任何地方调用它们。这是一种帮助程序类。这些功能的代码如下所示，您可以自行决定将它们插入到哪里。如果不需要在门户网站系统之外使用它们，可以将它们直接插入Portal演员类中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起初，我想使用碰撞系统来确定碰撞盒内的门户网站演员是否在门户网站中，但是在我看来这不够可靠。另外，在我看来，这种方法使用起来更快，并且具有一个优点：它考虑了actor的旋转。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝图演员的最后一部分是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请记住，当玩家越过一个门户并且与Portal Manager强制对其进行更新的另一个门户相邻时，将调用Force Tick。</font><font style="vertical-align: inherit;">由于我们只是传送，因此不必使用相同的代码，您可以使用其简化版本：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该过程大约与Tick函数同时开始，但是我们只执行序列的第一部分，从而更新材料。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成了吗 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差不多了 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果以这种形式实现门户网站系统，那么很可能会遇到以下问题：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是怎么回事</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此gif中，游戏的帧频限制为6 FPS，以便更清楚地显示问题。在一个帧中，该多维数据集消失了，因为</font><font style="vertical-align: inherit;">虚幻引擎</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剪辑系统</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认为它是不可见的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是因为发现是在当前帧中执行的，然后在下一个帧中使用。这样会造成</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">延迟</font></b><font style="vertical-align: inherit;">。通常可以通过展开对象的边界框来解决它，以便在它变得可见之前就对其进行注册。但是，这在这里不起作用，因为当我们穿越门户网站时，我们从一个地方传送到一个完全不同的地方。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁用裁剪系统也是不可能的，尤其是因为在具有许多对象的级别上，这会降低性能。另外，我尝试了许多使用Unreal引擎的团队，但没有得到积极的结果：在所有情况下，都只延迟了一帧。幸运的是，在详细研究了虚幻引擎源代码之后，我设法找到了一个解决方案（路径很长-花了一个多星期的时间）！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与SceneCapture组件一样，您可以告诉播放器的相机我们进行了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跳跃剪切</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-摄像机位置跳到了两帧之间，这意味着我们不能依赖前一帧的信息。</font><font style="vertical-align: inherit;">当使用Matinee或Sequencer时，例如在切换相机时，可以观察到此行为：运动模糊或平滑不能依赖于前一帧的信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们需要考虑两个方面：</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：此类处理各种信息（例如，玩家的视口），并与PlayerController关联。</font><font style="vertical-align: inherit;">在这里我们可以影响播放器相机的渲染过程。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：当玩家进行传送时，由于可以访问LocalPlayer，因此此类开始拼接。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该解决方案的最大优势在于，引擎渲染过程中的干预最少，并且易于在将来的虚幻引擎更新中进行维护。 </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从创建一个继承自LocalPlayer的新类开始。</font><font style="vertical-align: inherit;">下面的标题标识了两个主要组件：重新定义“场景视口”计算和用于调用相机胶合的新功能。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是所有事情的实现方式： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是使用布尔值启动Camera Cut。</font><font style="vertical-align: inherit;">当引擎调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数时</font><font style="vertical-align: inherit;">，我们首先运行原始函数。</font><font style="vertical-align: inherit;">然后我们检查，我们需要执行粘合。</font><font style="vertical-align: inherit;">如果是这样，我们将在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构中重新定义Camera Cut布尔变量</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">将由引擎渲染​​过程使用，然后重置该布尔变量（使用它）。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在播放器控制器方面，更改很小。</font><font style="vertical-align: inherit;">您需要在标头中添加一个变量，以存储指向LocalPlayer本机类的链接：</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我还添加了一个功能来快速启动Cut： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，在门户网站管理器函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal（）中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以在Camera Cut隐形传送期间执行：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅此而已！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须在更新SceneCapture之前调用Camera Cut，这就是为什么它在函数的开头。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最终结果 </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经学会了在门户中思考。</font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果系统运行良好，那么我们应该能够创建以下内容：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果遇到问题，请检查以下内容： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 验证正确创建和初始化了Portal Manager。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正确创建了渲染目标（可以使用在内容浏览器中创建的渲染目标开始使用）。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 门户已正确激活和停用。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 门户网站已在编辑器中正确设置了目标参与者。 </font></font></li></ul><br><h2> 问与答 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有人问我关于本教程的最流行的问题：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否可以用钝器而不是C ++来实现？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了以下两个方面，大部分代码都可以用钝器实现：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝图中不提供用于获取投影矩阵</font><font style="vertical-align: inherit;">的LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝图中没有</font><font style="vertical-align: inherit;">LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，这对于解决裁剪系统问题至关重要。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，您需要使用C ++实现来访问这两个函数，或者修改引擎源代码以使其可以通过蓝图进行访问。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可以在VR中使用此系统吗？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，在大多数情况下。</font><font style="vertical-align: inherit;">但是，某些部分将必须进行修改，例如：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要使用两个渲染目标（每只眼睛一个），并在门户材料中对其进行遮罩，以在屏幕空间中并排显示。</font><font style="vertical-align: inherit;">每个渲染目标应为VR设备分辨率的一半。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您需要使用两个SceneCapture来以正确的距离（眼睛之间的距离）渲染目标，以创建立体效果。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要问题将是性能，因为门户的另一侧将必须呈现两次。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个对象可以穿过门户吗？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的代码中没有。但是，使其更通用并不是那么困难。为此，门户网站需要跟踪有关附近所有物体的更多信息，以检查它们是否越过。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统是否支持递归（门户内部的门户）？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本教程不是。对于递归，您需要其他渲染目标和SceneCapture。还需要确定首先渲染哪个RenderTarget，依此类推。这是相当困难的，并且我不想这样做，因为对于我的项目而言，这是没有必要的。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可以穿过墙附近的入口吗？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，没有。</font><font style="vertical-align: inherit;">但是，我看到了两种方法（理论上）：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁用玩家的碰撞，以便他可以穿过墙壁。</font><font style="vertical-align: inherit;">它很容易实现，但是会带来很多副作用。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破解一个碰撞系统以动态创建一个洞，这将允许玩家通过。</font><font style="vertical-align: inherit;">为此，您需要修改引擎的物理系统。</font><font style="vertical-align: inherit;">但是，据我所知，加载关卡后，静态物理无法更新。</font><font style="vertical-align: inherit;">因此，支持此功能将需要大量的工作。</font><font style="vertical-align: inherit;">如果您的门户网站是静态的，则可以使用级别流在不同的冲突之间切换来解决此问题。</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448802/">https://habr.com/ru/post/zh-CN448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448788/index.html">使用pytest进行Python测试。 第2章，编写测试函数</a></li>
<li><a href="../zh-CN448790/index.html">SpaceVIL-用于在.Net Core，.Net Standard和JVM上开发的跨平台GUI框架</a></li>
<li><a href="../zh-CN448796/index.html">使用pytest进行Python测试。 配置，第6章</a></li>
<li><a href="../zh-CN448798/index.html">使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章</a></li>
<li><a href="../zh-CN448800/index.html">使用.vsconfig在整个组织中配置Visual Studio</a></li>
<li><a href="../zh-CN448804/index.html">为macOS的强化运行时和公证做好准备</a></li>
<li><a href="../zh-CN448806/index.html">在Qt库上创建扩展系统</a></li>
<li><a href="../zh-CN448808/index.html">关于简单的事情，复杂的。 “睡觉的钢。” 如何用单个螺栓对生锈的螺栓或非WD-40螺栓润滑</a></li>
<li><a href="../zh-CN448810/index.html">我如何抓到黑客</a></li>
<li><a href="../zh-CN448812/index.html">“ Bereshit”登月任务-承运人事故发生后搜寻第一个登月库</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>