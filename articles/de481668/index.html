<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üç† Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS üë®üèø‚Äçüî¨ üò® üßëüèº‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="George schloss seinen Laptop und rieb sich die roten Augen. "Kunden beschweren sich weiterhin √ºber das Einfrieren von Streams. Das neue Fix-Paket hat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/481668/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  George schloss seinen Laptop und rieb sich die roten Augen.  "Kunden beschweren sich weiterhin √ºber das Einfrieren von Streams. Das neue Fix-Paket hat √ºberhaupt nicht geholfen. Was mache ich mit diesem (zensierten) HLS?"  sagte er. </p><br><h2 id="the-browser-is-not-only-hypertext-but-also-a-streamer">  Der Browser ist nicht nur Hypertext, sondern auch ein Streamer </h2><br><p>  Browser haben schon lange Player, aber die Geschichte ist anders mit dem Video-Encoder und dem Streaming.  Jetzt k√∂nnen wir in fast jedem Browser der neuesten Version Module zum Codieren, Streamen, Decodieren und Wiedergeben finden.  Diese Funktionen sind √ºber die JavaScript-API verf√ºgbar, und die Implementierung wird als Web Real Time Communications oder WebRTC bezeichnet.  Diese in Browser integrierte Bibliothek kann eine ganze Menge: Videos von einer integrierten, virtuellen oder USB-Kamera aufnehmen, mit den H.264-, VP8- und VP9-Codecs komprimieren und √ºber das SRTP-Protokoll an das Netzwerk senden.  Das hei√üt, es fungiert als Software-Streamer-Video-Encoder.  Als Ergebnis sehen wir einen Browser, der etwas √§hnliches wie ffmpeg oder gstreamer hat, Video gut komprimiert, Streams auf RTP und Video-Streams wiedergibt. </p><a name="habracut"></a><br><p>  Mit WebRTC k√∂nnen wir eine Vielzahl von Streaming-F√§llen in JavaScript implementieren: </p><br><ul><li>  Stream vom Browser zum Server zur Aufzeichnung und anschlie√üenden Verteilung </li><li>  Peer-to-Peer-Streams verteilen </li><li>  Spiele den Stream eines anderen Benutzers ab und sende den eigenen (Video-Chat) </li><li>  Konvertieren Sie andere Protokolle vom Server, z. B. RTMP, RTSP usw., und spielen Sie sie im Browser als WebRTC ab </li></ul><br><p>  Verbesserte Flusskontrollskripte k√∂nnten so aussehen: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Launching broadcast from browser to server session.createStream({name:‚Äùmystream‚Äù}).publish(); //Playing broadcast by the browser session.createStream({name:‚Äùmystream‚Äù}).play();</span></span></code> </pre> <br><h2 id="hls-works-where-webrtc-does-not-work">  HLS funktioniert dort, wo WebRTC nicht funktioniert </h2><br><p>  WebRTC wird in den neuesten Versionen von Browsern ausgef√ºhrt. Es gibt jedoch die folgenden zwei Faktoren: 1) Nicht alle Nutzer aktualisieren ihre Browser rechtzeitig und verwenden m√∂glicherweise die alte Version von Chrome drei Jahre lang.  2) Updates und neue Browser, WebView sowie andere Clients und Instant Messenger, die Benutzern das Surfen im Internet erleichtern, werden fast einmal pro Woche ver√∂ffentlicht.  Es ist unn√∂tig zu erw√§hnen, dass nicht alle von ihnen WebRTC-Unterst√ºtzung haben, und falls doch, kann dies eingeschr√§nkt sein.  Sehen Sie, wie es jetzt ist: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Die Lieblingsger√§te von Apple k√∂nnen Kopfschmerzen bereiten.  Sie haben erst vor kurzem damit begonnen, WebRTC zu unterst√ºtzen, und manchmal scheint ihr Verhalten im Vergleich zu Webkit-Browsern √ºberraschend.  Wenn WebRTC nicht oder nicht sehr gut funktioniert, funktioniert HLS einwandfrei.  In dieser Hinsicht ist Kompatibilit√§t erforderlich und so etwas wie ein Konverter, mit dem wir WebRTC in HLS konvertieren und auf fast jedem Ger√§t abspielen k√∂nnen. </p><br><p>  HLS war urspr√ºnglich nicht f√ºr Echtzeit-Streams konzipiert.  Wie k√∂nnen wir Echtzeitvideos √ºber HTTP streamen?  Die Aufgabe von HLS ist es, das Video in St√ºcke zu schneiden und es ruckelfrei an den Player zu liefern, indem Sie es nacheinander herunterladen.  Ein HLS-Player erwartet einen streng geformten und reibungslosen Videostream.  Hier besteht ein Konflikt, da es sich WebRTC im Gegenteil leisten kann, Pakete aufgrund von Echtzeitanforderungen und geringer Latenzzeit zu verlieren und eine schwebende FPS / GOP und eine variable Bitrate zu haben - in Bezug auf die Vorhersagbarkeit das genaue Gegenteil von HLS und Regelm√§√üigkeit des Stroms. </p><br><p>  Ein naheliegender Ansatz: Die WebRTC-Depaketisierung (SRTP) und die anschlie√üende <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Konvertierung in HLS</a> funktionieren m√∂glicherweise nicht in einem systemeigenen HLS-Player von Apple oder arbeiten mit Freezing, einer f√ºr die Produktion ungeeigneten Form.  Der native Player ist ein Player, der in Apple iOS Safari, Mac OS Safari und Apple TV verwendet wird. </p><br><p>  Wenn Sie feststellen, dass HLS im nativen Player einfriert, ist dies m√∂glicherweise der Fall, und die Quelle des Streams ist WebRTC oder ein anderer dynamischer Stream mit ungleichm√§√üigem Markup.  Dar√ºber hinaus gibt es bei der Implementierung der nativen Apple-Player ein Verhalten, das nur empirisch verstanden werden kann.  Beispielsweise sollte der Server sofort nach der R√ºckgabe der m3u8-Wiedergabeliste mit dem Senden von HLS-Segmenten beginnen.  Eine Verz√∂gerung von 1 Sekunde kann zum Einfrieren f√ºhren.  Wenn sich die Bitstream-Konfiguration w√§hrend des Vorgangs √§ndert (was beim WebRTC-Streaming h√§ufig vorkommt), kommt es ebenfalls zum Einfrieren. </p><br><h2 id="fighting-freezing-in-native-players">  Kampf gegen das Einfrieren bei einheimischen Spielern </h2><br><p>  Daher funktionieren die WebRTC-Depaketisierung und die HLS-Paketierung im Allgemeinen nicht.  Beim Streaming-Videoserver <a href="https://flashphoner.com/">Web Call Server (WCS)</a> l√∂sen wir das Problem auf zwei Arten und bieten die dritte als Alternative an: </p><br><p>  1) Umcodierung. </p><br><p>  Dies ist die zuverl√§ssigste Methode, um einen WebRTC-Stream an HLS-Anforderungen anzupassen, die gew√ºnschte GOP, FPS usw. festzulegen.  In einigen F√§llen ist das Umcodieren jedoch keine gute L√∂sung.  Zum Beispiel das Transcodieren von 4k-Streams <br>  von VR Video ist in der Tat eine schlechte Idee.  Solche gewichtigen Streams sind in Bezug auf CPU-Zeit oder GPU-Ressourcen sehr teuer in der Transcodierung. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Anpassen und Ausrichten des WebRTC-Flusses f√ºr unterwegs, um den HLS-Anforderungen zu entsprechen. </p><br><p>  Hierbei handelt es sich um spezielle Parser, die den H.264-Bitstream analysieren und an die Funktionen / Fehler der nativen HLS-Player von Apple anpassen.  Zugegebenerma√üen sind nicht native Player wie video.js und hls.js toleranter gegen√ºber Streams <br>  mit einer dynamischen Bitrate und FPS, die auf WebRTC ausgef√ºhrt werden, und verlangsamen Sie nicht, wenn die Referenzimplementierung von Apple HLS im Wesentlichen zum Einfrieren f√ºhrt. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Verwenden von RTMP als Stream-Quelle anstelle von WebRTC. </p><br><p>  Obwohl Flash Player bereits veraltet ist, wird das RTMP-Protokoll aktiv f√ºr das Streaming verwendet.  Nehmen Sie zum Beispiel OBS Studio.  Wir m√ºssen anerkennen, dass RTMP-Encoder im Allgemeinen gleichm√§√üiger produzieren <br>  Streams als WebRTC verursachen praktisch kein Einfrieren in HLS, d. h. eine RTMP&gt; HLS-Konvertierung scheint im Hinblick auf das Einfrieren viel geeigneter zu sein, auch in nativen HLS-Playern.  Deshalb, wenn Streaming ist <br>  Wenn Sie den Desktop und OBS verwenden, ist es besser, ihn f√ºr die Konvertierung in HLS zu verwenden.  Wenn die Quelle der Chrome-Browser ist, kann RTMP nicht ohne die Installation von Plugins verwendet werden, und in diesem Fall funktioniert nur WebRTC. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"><br>  Alle drei oben beschriebenen Methoden wurden getestet und funktionieren, sodass Sie sie je nach Aufgabe ausw√§hlen k√∂nnen. </p><br><h2 id="webrtc-to-hls-on-cdn">  WebRTC zu HLS auf CDN </h2><br><p>  Es gibt einige unerw√ºnschte Ereignisse, die in einem verteilten System auftreten k√∂nnen, wenn sich zwischen der WebRTC-Stream-Quelle und dem HLS-Player, in unserem Fall <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN</a> , basierend auf einem WCS-Server, mehrere WebRTC-Stream-Delivery-Server befinden.  Es sieht so aus: Es gibt Origin - einen Server, der WebRTC-Stream akzeptiert, und es gibt Edge-Server, die diesen Stream auch √ºber HLS verteilen.  Es k√∂nnen viele Server vorhanden sein, was eine horizontale Skalierung des Systems erm√∂glicht.  Beispielsweise k√∂nnen 1000 HLS-Server mit einem Origin-Server verbunden werden.  In diesem Fall wird die Systemkapazit√§t 1000-mal skaliert. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  Das Problem ist bereits oben hervorgehoben worden;  Dies tritt normalerweise bei nativen Playern auf: iOS Safari, Mac OS Safari und Apple TV.  Mit native meinen wir einen Player, der mit einer direkten Anzeige der Playlist-URL arbeitet <br>  das Tag, zum Beispiel <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Sobald der Spieler eine Wiedergabeliste angefordert hat - und diese Aktion ist eigentlich der erste Schritt beim Abspielen des HLS-Streams - muss der Server sofort darauf verzichten <br>  Verz√∂gerung, beginnen Sie HLS-Videosegmente auszusenden.  Wenn der Server nicht sofort beginnt, Segmente zu senden, entscheidet der Player, dass er betrogen wurde, und beendet die Wiedergabe.  Dieses Verhalten ist typisch f√ºr native HLS-Player von Apple, aber wir k√∂nnen den Nutzern nicht nur sagen, dass sie zum Abspielen von HLS-Streams kein iPhone, keinen Mac oder Apple TV verwenden sollen. </p><br><p>  Wenn Sie also versuchen, einen HLS-Stream auf dem Edgeserver abzuspielen, sollte der Server sofort beginnen, Segmente zur√ºckzugeben. Wie soll er dies tun, wenn er keinen Stream hat?  In der Tat, wenn Sie versuchen, es zu spielen, gibt <br>  ist kein Stream auf diesem Server.  Die CDN-Logik funktioniert nach dem Prinzip des verz√∂gerten Ladens - der Stream wird erst auf den Server geladen, wenn jemand diesen Stream auf diesem Server anfordert.  Es ist ein Problem des ersten verbunden <br>  Benutzer;  Der erste Benutzer, der den HLS-Stream vom Edge-Server angefordert hat und die Unklugheit hatte, dies √ºber den Standard-Apple-Player zu tun, friert ein, da die Bestellung dieses Streams einige Zeit in Anspruch nimmt <br>  Rufen Sie es vom Origin-Server auf Edge ab und beginnen Sie mit dem HLS-Slicing.  Auch wenn es drei Sekunden dauert, hilft dies nicht.  Es wird einfrieren. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Hier haben wir zwei m√∂gliche L√∂sungen: Eine ist in Ordnung und die andere weniger.  Man k√∂nnte den Lazy Loading-Ansatz im CDN aufgeben und Datenverkehr an alle Knoten senden, unabh√§ngig davon, ob es Zuschauer gibt oder nicht.  Eine L√∂sung, die m√∂glicherweise f√ºr diejenigen geeignet ist, die in Bezug auf Verkehr und Rechenressourcen keine Einschr√§nkungen aufweisen.  Origin sendet Datenverkehr an alle Edgeserver, wodurch alle Server und das Netzwerk zwischen ihnen st√§ndig geladen werden.  Vielleicht w√§re dieses Schema nur f√ºr einige spezifische L√∂sungen mit einer kleinen Anzahl von eingehenden Fl√ºssen geeignet.  Bei der Replikation einer gro√üen Anzahl von Streams ist ein solches Schema eindeutig <br>  ineffizient in Bezug auf Ressourcen.  Und wenn Sie sich daran erinnern, dass wir nur das ‚ÄûProblem des ersten verbundenen Benutzers im nativen Browser‚Äú l√∂sen, wird klar, dass es sich nicht lohnt. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  Die zweite Option ist eleganter, aber es ist auch nur ein Ende.  Wir geben dem ersten verbundenen Benutzer ein Videobild, aber dies ist immer noch nicht der Stream, den er sehen m√∂chte - dies ist ein Preloader.  Da wir ihnen bereits etwas geben m√ºssen und es sofort tun m√ºssen, aber wir nicht √ºber den Quelldatenstrom verf√ºgen (dieser wird noch von Origin bestellt und geliefert), bitten wir den Kunden, etwas zu warten und ihnen ein Video des zu zeigen <br>  Preloader mit bewegter Animation.  Der Benutzer wartet einige Sekunden, w√§hrend sich der Preloader dreht, und wenn der reale Stream endlich kommt, beginnt der Benutzer, den realen Stream abzurufen.  Infolgedessen sieht der erste Benutzer die <br>  preloader und diejenigen, die sich danach verbinden, werden endlich den regul√§ren HLS-Stream vom CDN sehen, der nach dem Prinzip des Lazy Loading arbeitet.  Damit ist das Engineering-Problem gel√∂st. </p><br><h2 id="but-not-yet-fully-solved">  Aber noch nicht vollst√§ndig gel√∂st </h2><br><p>  Es scheint, dass alles gut funktioniert.  Das CDN funktioniert, die HLS-Streams werden von den Edgeservern geladen und das Problem des ersten verbundenen Benutzers ist behoben.  Und hier ist eine weitere Falle - wir geben die <br>  Preloader in einem festen Seitenverh√§ltnis von 16: 9, w√§hrend Streams aller Formate in das CDN: 16: 9, 4: 3, 2: 1 (VR-Video) eingegeben werden k√∂nnen.  Und das ist ein Problem, denn wenn Sie einen Preloader im 16: 9-Format an den Player senden und der bestellte Stream 4: 3 ist, wird der native Player erneut vor dem Einfrieren stehen. </p><br><p>  Daher entsteht eine neue Aufgabe: Sie m√ºssen wissen, mit welchem ‚Äã‚ÄãSeitenverh√§ltnis der Stream in das CDN eingeht, und dem Preloader dasselbe Verh√§ltnis zuweisen.  Ein Merkmal von WebRTC-Streams ist die Beibehaltung des Seitenverh√§ltnisses bei <br>  √Ñndern der Aufl√∂sung und der Umcodierung - Wenn der Browser die Aufl√∂sung verringert, verringert er sie im gleichen Verh√§ltnis.  Wenn der Server beschlie√üt, den Stream zu transkodieren, beh√§lt er das Seitenverh√§ltnis im gleichen Verh√§ltnis bei.  Daher ist es sinnvoll, den Preloader f√ºr HLS in demselben Seitenverh√§ltnis anzuzeigen, in dem der Stream eingeht. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  Das CDN funktioniert folgenderma√üen: Wenn Datenverkehr auf den Origin-Server gelangt, werden andere Server im Netzwerk, einschlie√ülich Edgeserver, √ºber den neuen Stream informiert.  Das Problem ist, dass an dieser Stelle die Aufl√∂sung des <br>  Quellstream ist m√∂glicherweise noch nicht bekannt.  Die Aufl√∂sung wird von den H.264-Bitstream-Konfigurationen zusammen mit dem Schl√ºsselbild √ºbernommen.  Daher empf√§ngt der Edgeserver m√∂glicherweise Informationen zu einem Stream, wei√ü jedoch nichts √ºber den Stream <br>  Aufl√∂sung und Seitenverh√§ltnis, wodurch der Preloader nicht korrekt generiert werden kann.  In diesem Zusammenhang ist es nur erforderlich, das Vorhandensein des Streams im CDN zu signalisieren, wenn ein Schl√ºsselframe vorhanden ist. Dies gibt garantiert die Informationen zur Gr√∂√üe des Edge-Servers an und erm√∂glicht die Generierung des richtigen Preloaders, um ein Problem mit dem ersten verbundenen Viewer zu vermeiden . " </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="summary">  Zusammenfassung </h2><br><p>  Das Konvertieren von WebRTC in HLS f√ºhrt in der Regel zu einem Einfrieren, wenn es in Apple-Standardplayern abgespielt wird.  Das Problem wird gel√∂st, indem der H.264-Bitstream analysiert und an die HLS-Anforderungen von Apple angepasst wird. <br>  oder Migration auf das RTMP-Protokoll und den Encoder als Stream-Quelle.  In einem verteilten Netzwerk mit Lazy Loading von Streams besteht das Problem des ersten verbundenen Viewers, der mithilfe des Preloaders gel√∂st wird und die Aufl√∂sung auf der Origin-Serverseite bestimmt - dem Eintrittspunkt des Streams im CDN. </p><br><h2 id="links">  Links </h2><br><p>  <a href="https://flashphoner.com/">Webanrufserver</a> - WebRTC-Server </p><br><p>  <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN f√ºr WebRTC-Streaming mit geringer Latenz</a> - WCS-basiertes CDN </p><br><p>  <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Wiedergabe von WebRTC- und RTMP-Videostreams √ºber HLS</a> - Serverfunktionen zum Konvertieren von Streams aus verschiedenen Quellen in HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481668/">https://habr.com/ru/post/de481668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481654/index.html">Die Geschichte, wie Ihnen QA Engineer mithilfe von Test IT mithilfe des Bot Frameworks das Leben erleichtert hat</a></li>
<li><a href="../de481656/index.html">PagerDuty oder warum die Operationsabteilung nachts m√∂glicherweise nicht schl√§ft</a></li>
<li><a href="../de481662/index.html">Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481672/index.html">Mobilfunkautomaten im Browser</a></li>
<li><a href="../de481674/index.html">Autoverkaufstrichter oder wie man Kunden nicht zusammenf√ºhrt und sogar mit denen zusammenarbeitet, die Ihre Dienste verweigert haben?</a></li>
<li><a href="../de481676/index.html">Sicherheitswoche 52: Sicherheit f√ºr intelligente Lautsprecher und IP-Kameras</a></li>
<li><a href="../de481678/index.html">Pre-Holiday Review: N6IIT01 Player und YB04 Armature Headphones - Hi-Fi aus S√ºdchina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>