<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧 👩🏾‍🤝‍👩🏽 🍠 Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS 👨🏿‍🔬 😨 🧑🏼‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="George schloss seinen Laptop und rieb sich die roten Augen. "Kunden beschweren sich weiterhin über das Einfrieren von Streams. Das neue Fix-Paket hat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/481668/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  George schloss seinen Laptop und rieb sich die roten Augen.  "Kunden beschweren sich weiterhin über das Einfrieren von Streams. Das neue Fix-Paket hat überhaupt nicht geholfen. Was mache ich mit diesem (zensierten) HLS?"  sagte er. </p><br><h2 id="the-browser-is-not-only-hypertext-but-also-a-streamer">  Der Browser ist nicht nur Hypertext, sondern auch ein Streamer </h2><br><p>  Browser haben schon lange Player, aber die Geschichte ist anders mit dem Video-Encoder und dem Streaming.  Jetzt können wir in fast jedem Browser der neuesten Version Module zum Codieren, Streamen, Decodieren und Wiedergeben finden.  Diese Funktionen sind über die JavaScript-API verfügbar, und die Implementierung wird als Web Real Time Communications oder WebRTC bezeichnet.  Diese in Browser integrierte Bibliothek kann eine ganze Menge: Videos von einer integrierten, virtuellen oder USB-Kamera aufnehmen, mit den H.264-, VP8- und VP9-Codecs komprimieren und über das SRTP-Protokoll an das Netzwerk senden.  Das heißt, es fungiert als Software-Streamer-Video-Encoder.  Als Ergebnis sehen wir einen Browser, der etwas ähnliches wie ffmpeg oder gstreamer hat, Video gut komprimiert, Streams auf RTP und Video-Streams wiedergibt. </p><a name="habracut"></a><br><p>  Mit WebRTC können wir eine Vielzahl von Streaming-Fällen in JavaScript implementieren: </p><br><ul><li>  Stream vom Browser zum Server zur Aufzeichnung und anschließenden Verteilung </li><li>  Peer-to-Peer-Streams verteilen </li><li>  Spiele den Stream eines anderen Benutzers ab und sende den eigenen (Video-Chat) </li><li>  Konvertieren Sie andere Protokolle vom Server, z. B. RTMP, RTSP usw., und spielen Sie sie im Browser als WebRTC ab </li></ul><br><p>  Verbesserte Flusskontrollskripte könnten so aussehen: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Launching broadcast from browser to server session.createStream({name:”mystream”}).publish(); //Playing broadcast by the browser session.createStream({name:”mystream”}).play();</span></span></code> </pre> <br><h2 id="hls-works-where-webrtc-does-not-work">  HLS funktioniert dort, wo WebRTC nicht funktioniert </h2><br><p>  WebRTC wird in den neuesten Versionen von Browsern ausgeführt. Es gibt jedoch die folgenden zwei Faktoren: 1) Nicht alle Nutzer aktualisieren ihre Browser rechtzeitig und verwenden möglicherweise die alte Version von Chrome drei Jahre lang.  2) Updates und neue Browser, WebView sowie andere Clients und Instant Messenger, die Benutzern das Surfen im Internet erleichtern, werden fast einmal pro Woche veröffentlicht.  Es ist unnötig zu erwähnen, dass nicht alle von ihnen WebRTC-Unterstützung haben, und falls doch, kann dies eingeschränkt sein.  Sehen Sie, wie es jetzt ist: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Die Lieblingsgeräte von Apple können Kopfschmerzen bereiten.  Sie haben erst vor kurzem damit begonnen, WebRTC zu unterstützen, und manchmal scheint ihr Verhalten im Vergleich zu Webkit-Browsern überraschend.  Wenn WebRTC nicht oder nicht sehr gut funktioniert, funktioniert HLS einwandfrei.  In dieser Hinsicht ist Kompatibilität erforderlich und so etwas wie ein Konverter, mit dem wir WebRTC in HLS konvertieren und auf fast jedem Gerät abspielen können. </p><br><p>  HLS war ursprünglich nicht für Echtzeit-Streams konzipiert.  Wie können wir Echtzeitvideos über HTTP streamen?  Die Aufgabe von HLS ist es, das Video in Stücke zu schneiden und es ruckelfrei an den Player zu liefern, indem Sie es nacheinander herunterladen.  Ein HLS-Player erwartet einen streng geformten und reibungslosen Videostream.  Hier besteht ein Konflikt, da es sich WebRTC im Gegenteil leisten kann, Pakete aufgrund von Echtzeitanforderungen und geringer Latenzzeit zu verlieren und eine schwebende FPS / GOP und eine variable Bitrate zu haben - in Bezug auf die Vorhersagbarkeit das genaue Gegenteil von HLS und Regelmäßigkeit des Stroms. </p><br><p>  Ein naheliegender Ansatz: Die WebRTC-Depaketisierung (SRTP) und die anschließende <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Konvertierung in HLS</a> funktionieren möglicherweise nicht in einem systemeigenen HLS-Player von Apple oder arbeiten mit Freezing, einer für die Produktion ungeeigneten Form.  Der native Player ist ein Player, der in Apple iOS Safari, Mac OS Safari und Apple TV verwendet wird. </p><br><p>  Wenn Sie feststellen, dass HLS im nativen Player einfriert, ist dies möglicherweise der Fall, und die Quelle des Streams ist WebRTC oder ein anderer dynamischer Stream mit ungleichmäßigem Markup.  Darüber hinaus gibt es bei der Implementierung der nativen Apple-Player ein Verhalten, das nur empirisch verstanden werden kann.  Beispielsweise sollte der Server sofort nach der Rückgabe der m3u8-Wiedergabeliste mit dem Senden von HLS-Segmenten beginnen.  Eine Verzögerung von 1 Sekunde kann zum Einfrieren führen.  Wenn sich die Bitstream-Konfiguration während des Vorgangs ändert (was beim WebRTC-Streaming häufig vorkommt), kommt es ebenfalls zum Einfrieren. </p><br><h2 id="fighting-freezing-in-native-players">  Kampf gegen das Einfrieren bei einheimischen Spielern </h2><br><p>  Daher funktionieren die WebRTC-Depaketisierung und die HLS-Paketierung im Allgemeinen nicht.  Beim Streaming-Videoserver <a href="https://flashphoner.com/">Web Call Server (WCS)</a> lösen wir das Problem auf zwei Arten und bieten die dritte als Alternative an: </p><br><p>  1) Umcodierung. </p><br><p>  Dies ist die zuverlässigste Methode, um einen WebRTC-Stream an HLS-Anforderungen anzupassen, die gewünschte GOP, FPS usw. festzulegen.  In einigen Fällen ist das Umcodieren jedoch keine gute Lösung.  Zum Beispiel das Transcodieren von 4k-Streams <br>  von VR Video ist in der Tat eine schlechte Idee.  Solche gewichtigen Streams sind in Bezug auf CPU-Zeit oder GPU-Ressourcen sehr teuer in der Transcodierung. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Anpassen und Ausrichten des WebRTC-Flusses für unterwegs, um den HLS-Anforderungen zu entsprechen. </p><br><p>  Hierbei handelt es sich um spezielle Parser, die den H.264-Bitstream analysieren und an die Funktionen / Fehler der nativen HLS-Player von Apple anpassen.  Zugegebenermaßen sind nicht native Player wie video.js und hls.js toleranter gegenüber Streams <br>  mit einer dynamischen Bitrate und FPS, die auf WebRTC ausgeführt werden, und verlangsamen Sie nicht, wenn die Referenzimplementierung von Apple HLS im Wesentlichen zum Einfrieren führt. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Verwenden von RTMP als Stream-Quelle anstelle von WebRTC. </p><br><p>  Obwohl Flash Player bereits veraltet ist, wird das RTMP-Protokoll aktiv für das Streaming verwendet.  Nehmen Sie zum Beispiel OBS Studio.  Wir müssen anerkennen, dass RTMP-Encoder im Allgemeinen gleichmäßiger produzieren <br>  Streams als WebRTC verursachen praktisch kein Einfrieren in HLS, d. h. eine RTMP&gt; HLS-Konvertierung scheint im Hinblick auf das Einfrieren viel geeigneter zu sein, auch in nativen HLS-Playern.  Deshalb, wenn Streaming ist <br>  Wenn Sie den Desktop und OBS verwenden, ist es besser, ihn für die Konvertierung in HLS zu verwenden.  Wenn die Quelle der Chrome-Browser ist, kann RTMP nicht ohne die Installation von Plugins verwendet werden, und in diesem Fall funktioniert nur WebRTC. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"><br>  Alle drei oben beschriebenen Methoden wurden getestet und funktionieren, sodass Sie sie je nach Aufgabe auswählen können. </p><br><h2 id="webrtc-to-hls-on-cdn">  WebRTC zu HLS auf CDN </h2><br><p>  Es gibt einige unerwünschte Ereignisse, die in einem verteilten System auftreten können, wenn sich zwischen der WebRTC-Stream-Quelle und dem HLS-Player, in unserem Fall <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN</a> , basierend auf einem WCS-Server, mehrere WebRTC-Stream-Delivery-Server befinden.  Es sieht so aus: Es gibt Origin - einen Server, der WebRTC-Stream akzeptiert, und es gibt Edge-Server, die diesen Stream auch über HLS verteilen.  Es können viele Server vorhanden sein, was eine horizontale Skalierung des Systems ermöglicht.  Beispielsweise können 1000 HLS-Server mit einem Origin-Server verbunden werden.  In diesem Fall wird die Systemkapazität 1000-mal skaliert. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  Das Problem ist bereits oben hervorgehoben worden;  Dies tritt normalerweise bei nativen Playern auf: iOS Safari, Mac OS Safari und Apple TV.  Mit native meinen wir einen Player, der mit einer direkten Anzeige der Playlist-URL arbeitet <br>  das Tag, zum Beispiel <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Sobald der Spieler eine Wiedergabeliste angefordert hat - und diese Aktion ist eigentlich der erste Schritt beim Abspielen des HLS-Streams - muss der Server sofort darauf verzichten <br>  Verzögerung, beginnen Sie HLS-Videosegmente auszusenden.  Wenn der Server nicht sofort beginnt, Segmente zu senden, entscheidet der Player, dass er betrogen wurde, und beendet die Wiedergabe.  Dieses Verhalten ist typisch für native HLS-Player von Apple, aber wir können den Nutzern nicht nur sagen, dass sie zum Abspielen von HLS-Streams kein iPhone, keinen Mac oder Apple TV verwenden sollen. </p><br><p>  Wenn Sie also versuchen, einen HLS-Stream auf dem Edgeserver abzuspielen, sollte der Server sofort beginnen, Segmente zurückzugeben. Wie soll er dies tun, wenn er keinen Stream hat?  In der Tat, wenn Sie versuchen, es zu spielen, gibt <br>  ist kein Stream auf diesem Server.  Die CDN-Logik funktioniert nach dem Prinzip des verzögerten Ladens - der Stream wird erst auf den Server geladen, wenn jemand diesen Stream auf diesem Server anfordert.  Es ist ein Problem des ersten verbunden <br>  Benutzer;  Der erste Benutzer, der den HLS-Stream vom Edge-Server angefordert hat und die Unklugheit hatte, dies über den Standard-Apple-Player zu tun, friert ein, da die Bestellung dieses Streams einige Zeit in Anspruch nimmt <br>  Rufen Sie es vom Origin-Server auf Edge ab und beginnen Sie mit dem HLS-Slicing.  Auch wenn es drei Sekunden dauert, hilft dies nicht.  Es wird einfrieren. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Hier haben wir zwei mögliche Lösungen: Eine ist in Ordnung und die andere weniger.  Man könnte den Lazy Loading-Ansatz im CDN aufgeben und Datenverkehr an alle Knoten senden, unabhängig davon, ob es Zuschauer gibt oder nicht.  Eine Lösung, die möglicherweise für diejenigen geeignet ist, die in Bezug auf Verkehr und Rechenressourcen keine Einschränkungen aufweisen.  Origin sendet Datenverkehr an alle Edgeserver, wodurch alle Server und das Netzwerk zwischen ihnen ständig geladen werden.  Vielleicht wäre dieses Schema nur für einige spezifische Lösungen mit einer kleinen Anzahl von eingehenden Flüssen geeignet.  Bei der Replikation einer großen Anzahl von Streams ist ein solches Schema eindeutig <br>  ineffizient in Bezug auf Ressourcen.  Und wenn Sie sich daran erinnern, dass wir nur das „Problem des ersten verbundenen Benutzers im nativen Browser“ lösen, wird klar, dass es sich nicht lohnt. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  Die zweite Option ist eleganter, aber es ist auch nur ein Ende.  Wir geben dem ersten verbundenen Benutzer ein Videobild, aber dies ist immer noch nicht der Stream, den er sehen möchte - dies ist ein Preloader.  Da wir ihnen bereits etwas geben müssen und es sofort tun müssen, aber wir nicht über den Quelldatenstrom verfügen (dieser wird noch von Origin bestellt und geliefert), bitten wir den Kunden, etwas zu warten und ihnen ein Video des zu zeigen <br>  Preloader mit bewegter Animation.  Der Benutzer wartet einige Sekunden, während sich der Preloader dreht, und wenn der reale Stream endlich kommt, beginnt der Benutzer, den realen Stream abzurufen.  Infolgedessen sieht der erste Benutzer die <br>  preloader und diejenigen, die sich danach verbinden, werden endlich den regulären HLS-Stream vom CDN sehen, der nach dem Prinzip des Lazy Loading arbeitet.  Damit ist das Engineering-Problem gelöst. </p><br><h2 id="but-not-yet-fully-solved">  Aber noch nicht vollständig gelöst </h2><br><p>  Es scheint, dass alles gut funktioniert.  Das CDN funktioniert, die HLS-Streams werden von den Edgeservern geladen und das Problem des ersten verbundenen Benutzers ist behoben.  Und hier ist eine weitere Falle - wir geben die <br>  Preloader in einem festen Seitenverhältnis von 16: 9, während Streams aller Formate in das CDN: 16: 9, 4: 3, 2: 1 (VR-Video) eingegeben werden können.  Und das ist ein Problem, denn wenn Sie einen Preloader im 16: 9-Format an den Player senden und der bestellte Stream 4: 3 ist, wird der native Player erneut vor dem Einfrieren stehen. </p><br><p>  Daher entsteht eine neue Aufgabe: Sie müssen wissen, mit welchem ​​Seitenverhältnis der Stream in das CDN eingeht, und dem Preloader dasselbe Verhältnis zuweisen.  Ein Merkmal von WebRTC-Streams ist die Beibehaltung des Seitenverhältnisses bei <br>  Ändern der Auflösung und der Umcodierung - Wenn der Browser die Auflösung verringert, verringert er sie im gleichen Verhältnis.  Wenn der Server beschließt, den Stream zu transkodieren, behält er das Seitenverhältnis im gleichen Verhältnis bei.  Daher ist es sinnvoll, den Preloader für HLS in demselben Seitenverhältnis anzuzeigen, in dem der Stream eingeht. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  Das CDN funktioniert folgendermaßen: Wenn Datenverkehr auf den Origin-Server gelangt, werden andere Server im Netzwerk, einschließlich Edgeserver, über den neuen Stream informiert.  Das Problem ist, dass an dieser Stelle die Auflösung des <br>  Quellstream ist möglicherweise noch nicht bekannt.  Die Auflösung wird von den H.264-Bitstream-Konfigurationen zusammen mit dem Schlüsselbild übernommen.  Daher empfängt der Edgeserver möglicherweise Informationen zu einem Stream, weiß jedoch nichts über den Stream <br>  Auflösung und Seitenverhältnis, wodurch der Preloader nicht korrekt generiert werden kann.  In diesem Zusammenhang ist es nur erforderlich, das Vorhandensein des Streams im CDN zu signalisieren, wenn ein Schlüsselframe vorhanden ist. Dies gibt garantiert die Informationen zur Größe des Edge-Servers an und ermöglicht die Generierung des richtigen Preloaders, um ein Problem mit dem ersten verbundenen Viewer zu vermeiden . " </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="summary">  Zusammenfassung </h2><br><p>  Das Konvertieren von WebRTC in HLS führt in der Regel zu einem Einfrieren, wenn es in Apple-Standardplayern abgespielt wird.  Das Problem wird gelöst, indem der H.264-Bitstream analysiert und an die HLS-Anforderungen von Apple angepasst wird. <br>  oder Migration auf das RTMP-Protokoll und den Encoder als Stream-Quelle.  In einem verteilten Netzwerk mit Lazy Loading von Streams besteht das Problem des ersten verbundenen Viewers, der mithilfe des Preloaders gelöst wird und die Auflösung auf der Origin-Serverseite bestimmt - dem Eintrittspunkt des Streams im CDN. </p><br><h2 id="links">  Links </h2><br><p>  <a href="https://flashphoner.com/">Webanrufserver</a> - WebRTC-Server </p><br><p>  <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN für WebRTC-Streaming mit geringer Latenz</a> - WCS-basiertes CDN </p><br><p>  <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Wiedergabe von WebRTC- und RTMP-Videostreams über HLS</a> - Serverfunktionen zum Konvertieren von Streams aus verschiedenen Quellen in HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481668/">https://habr.com/ru/post/de481668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481654/index.html">Die Geschichte, wie Ihnen QA Engineer mithilfe von Test IT mithilfe des Bot Frameworks das Leben erleichtert hat</a></li>
<li><a href="../de481656/index.html">PagerDuty oder warum die Operationsabteilung nachts möglicherweise nicht schläft</a></li>
<li><a href="../de481662/index.html">Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481672/index.html">Mobilfunkautomaten im Browser</a></li>
<li><a href="../de481674/index.html">Autoverkaufstrichter oder wie man Kunden nicht zusammenführt und sogar mit denen zusammenarbeitet, die Ihre Dienste verweigert haben?</a></li>
<li><a href="../de481676/index.html">Sicherheitswoche 52: Sicherheit für intelligente Lautsprecher und IP-Kameras</a></li>
<li><a href="../de481678/index.html">Pre-Holiday Review: N6IIT01 Player und YB04 Armature Headphones - Hi-Fi aus Südchina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>