<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥝 🙇🏾 🅿️ Asinkron desinkronisasi: antipatterns dalam bekerja dengan async / menunggu di .NET 👕 🕸️ 🤶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siapakah di antara kita yang tidak memotong? Saya secara teratur menemukan kesalahan dalam kode asinkron dan melakukannya sendiri. Untuk menghentikan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asinkron desinkronisasi: antipatterns dalam bekerja dengan async / menunggu di .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/435666/"><p>  Siapakah di antara kita yang tidak memotong?  Saya secara teratur menemukan kesalahan dalam kode asinkron dan melakukannya sendiri.  Untuk menghentikan roda Samsara ini, saya berbagi dengan Anda kusen yang paling khas dari mereka yang kadang-kadang cukup sulit untuk ditangkap dan diperbaiki. </p><br><img src="https://habrastorage.org/webt/os/oz/lt/osozltujeowuulzfvdaxvehuvpg.png"><br><a name="habracut"></a><br><blockquote>  Teks ini terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Stephen Clary</a> , seorang pria yang tahu segalanya tentang daya saing, asinkron, multithreading, dan kata-kata menakutkan lainnya.  Dia adalah penulis buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Concurrency di C # Cookbook</a> , yang telah mengumpulkan sejumlah besar pola untuk bekerja dengan kompetisi. </blockquote><br><h2>  Kebuntuan Asinkron Klasik </h2><br><p>  Untuk memahami kebuntuan tidak sinkron, sebaiknya cari tahu utas mana yang mengeksekusi metode yang dipanggil menggunakan kata kunci tunggu. </p><br><p>  Pertama, metode ini akan menyelidiki rantai panggilan metode async hingga menemukan sumber asinkron.  Bagaimana tepatnya sumber asynchrony diimplementasikan adalah topik yang berada di luar cakupan artikel ini.  Sekarang untuk kesederhanaan, kami menganggap bahwa ini adalah operasi yang tidak memerlukan alur kerja sambil menunggu hasilnya, misalnya, permintaan basis data atau permintaan HTTP.  Awal yang sinkron dari operasi semacam itu berarti bahwa sambil menunggu hasilnya di sistem akan ada setidaknya satu untai tertidur yang menghabiskan sumber daya tetapi tidak melakukan pekerjaan yang bermanfaat. </p><br><p> Dalam panggilan asinkron, kami jenis memecah aliran eksekusi perintah pada "sebelum" dan "setelah" operasi asinkron, dan dalam. NET tidak ada jaminan bahwa kode yang terletak setelah menunggu akan dieksekusi di utas yang sama dengan kode sebelum menunggu.  Dalam kebanyakan kasus, ini tidak perlu, tetapi apa yang harus dilakukan ketika perilaku seperti itu penting bagi program untuk bekerja?  Perlu menggunakan <code>SynchronizationContext</code> .  Ini adalah mekanisme yang memungkinkan Anda untuk menerapkan batasan tertentu pada utas di mana kode dieksekusi.  Selanjutnya, kita akan membahas dua konteks sinkronisasi ( <code>WindowsFormsSynchronizationContext</code> dan <code>AspNetSynchronizationContext</code> ), tetapi Alex Davis menulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukunya</a> bahwa ada sekitar selusin dari mereka di .NET.  Tentang <code>SynchronizationContext</code> ditulis dengan baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> penulis telah menerapkan sendiri, yang sangat ia hormati. </p><br><p>  Jadi, segera setelah kode tiba di sumber asynchrony, ia menyimpan konteks sinkronisasi, yang berada di properti thread-static dari <code>SynchronizationContext.Current</code> , maka operasi asinkron memulai dan membebaskan utas saat ini.  Dengan kata lain, saat kami menunggu penyelesaian operasi asinkron, kami tidak memblokir satu utas dan ini adalah keuntungan utama dari operasi asinkron dibandingkan dengan yang sinkron.  Setelah menyelesaikan operasi asinkron, kita harus mengikuti instruksi yang terletak setelah sumber asinkron, dan di sini, untuk memutuskan di mana utas untuk mengeksekusi kode setelah operasi asinkron, kita perlu berkonsultasi dengan konteks sinkronisasi yang disimpan sebelumnya.  Seperti yang dia katakan, kami akan melakukannya.  Dia akan memberitahu Anda untuk mengeksekusi di utas yang sama dengan kode sebelum menunggu - kami akan mengeksekusi di utas yang sama, tidak akan mengatakan - kami akan mengambil utas pertama dari kolam. </p><br><p>  Tetapi bagaimana jika, dalam kasus khusus ini, penting bagi kami bahwa kode setelah menunggu dijalankan di utas gratis dari kumpulan utas?  Anda perlu menggunakan mantra <code>ConfigureAwait(false)</code> .  Nilai palsu diteruskan ke parameter <code>continueOnCapturedContext</code> memberi tahu sistem bahwa utas apa pun dari kumpulan dapat digunakan.  Dan apa yang terjadi jika pada saat pelaksanaan metode dengan menunggu tidak ada konteks sinkronisasi sama sekali ( <code>SynchronizationContext.Current == null</code> ), seperti misalnya dalam aplikasi konsol.  Dalam hal ini, kami tidak memiliki batasan pada utas di mana kode harus dieksekusi setelah menunggu dan sistem akan mengambil utas pertama dari kumpulan, seperti dalam kasus <code>ConfigureAwait(false)</code> . </p><br><p>  Jadi apa itu kebuntuan asinkron? </p><br><h4>  Jalan buntu di WPF dan WinForms </h4><br><p>  Perbedaan antara aplikasi WPF dan WinForms adalah konteks sinkronisasi yang sangat.  Konteks sinkronisasi WPF dan WinForms memiliki utas khusus - utas antarmuka pengguna.  Ada satu utas UI per <code>SynchronizationContext</code> dan hanya dari utas ini yang dapat berinteraksi dengan elemen antarmuka pengguna.  Secara default, kode yang mulai bekerja di utas UI melanjutkan operasi setelah operasi asinkron di dalamnya. </p><br>  Sekarang mari kita lihat sebuah contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  Apa yang terjadi ketika Anda memanggil <code>StartWork().Wait()</code> : <br><br><ol><li>  Utas panggilan (dan ini adalah utas antarmuka pengguna) akan masuk ke metode <code>StartWork</code> dan <code>StartWork</code> ke <code>await Task.Delay(100)</code> . </li><li>  Utas UI akan memulai operasi <code>Task.Delay(100)</code> asynchronous, dan itu akan mengembalikan kontrol ke metode <code>Button_Click</code> , dan di sana metode <code>Wait()</code> dari kelas <code>Task</code> akan menunggu untuk itu.  Ketika metode <code>Wait()</code> dipanggil, utas UI akan memblokir hingga akhir operasi asinkron, dan kami berharap bahwa segera setelah selesai, utas UI akan segera mengambil eksekusi dan melangkah lebih jauh di sepanjang kode, namun, semuanya akan salah. </li><li>  Segera setelah <code>Task.Delay(100)</code> selesai, utas UI pertama-tama harus terus menjalankan metode <code>StartWork()</code> dan untuk ini diperlukan utas persis di mana eksekusi dimulai.  Tetapi utas UI sekarang menunggu hasil operasi. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> tidak dapat melanjutkan eksekusi dan mengembalikan hasilnya, dan <code>Button_Click</code> sedang menunggu hasil yang sama, dan karena fakta bahwa eksekusi dimulai pada utas antarmuka pengguna, aplikasi hanya hang tanpa kesempatan untuk terus bekerja. </li></ol><br>  Situasi ini dapat ditangani dengan cukup sederhana dengan mengubah panggilan ke <code>Task.Delay(100)</code> menjadi <code>Task.Delay(100).ConfigureAwait(false)</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  Kode ini akan bekerja tanpa kebuntuan, karena sekarang utas dari kumpulan dapat digunakan untuk menyelesaikan metode <code>StartWork()</code> , daripada utas UI yang diblokir.  Stephen Clary merekomendasikan menggunakan <code>ConfigureAwait(false)</code> di semua "metode perpustakaan" di blog-nya, tetapi secara khusus menekankan bahwa menggunakan <code>ConfigureAwait(false)</code> untuk mengobati kebuntuan bukanlah praktik yang baik.  Sebagai gantinya, ia menyarankan TIDAK untuk menggunakan metode pemblokiran seperti <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> dan <code>GetAwaiter().GetResult()</code> semua metode untuk menggunakan async / tunggu, jika mungkin (yang disebut Async all the way principle). </p><br><h4>  Jalan buntu di ASP.NET </h4><br><p>  ASP.NET juga memiliki konteks sinkronisasi, tetapi memiliki batasan yang sedikit berbeda.  Ini memungkinkan Anda untuk menggunakan hanya satu utas per permintaan sekaligus dan juga mengharuskan kode setelah menunggu dieksekusi di utas yang sama dengan kode sebelum menunggu. </p><br>  Contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  Kode ini juga akan menyebabkan kebuntuan, karena pada saat panggilan ke <code>StartWork().Wait()</code> utas yang dibolehkan hanya akan diblokir dan akan menunggu operasi <code>StartWork()</code> , dan itu tidak akan pernah berakhir, karena utas di mana eksekusi harus dilanjutkan sedang sibuk menunggu. </p><br><p>  Ini semua diperbaiki oleh <code>ConfigureAwait(false)</code> sama <code>ConfigureAwait(false)</code> . </p><br><h4>  Jalan buntu di ASP.NET Core (sebenarnya tidak) </h4><br><p>  Sekarang mari kita coba menjalankan kode dari contoh untuk ASP.NET dalam proyek untuk ASP.NET Core.  Jika kita melakukan ini, kita akan melihat bahwa tidak akan ada jalan buntu.  Ini karena ASP.NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak memiliki konteks sinkronisasi</a> .  Hebat!  Dan sekarang Anda dapat menutupi kode dengan memblokir panggilan dan tidak takut kebuntuan?  Sebenarnya, ya, tapi ingat bahwa ini menyebabkan utas tertidur saat menunggu, yaitu, utas menghabiskan sumber daya, tetapi tidak melakukan pekerjaan yang bermanfaat. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>Ingat bahwa penggunaan panggilan pemblokiran menghilangkan semua keuntungan pemrograman asinkron mengubahnya menjadi sinkron</b> .  Ya, kadang-kadang tanpa menggunakan <code>Wait()</code> itu tidak akan berhasil untuk menulis sebuah program, tetapi alasannya harus serius. </blockquote><br><h2>  Penggunaan Task.Run () yang salah </h2><br><p>  Metode <code>Task.Run()</code> dibuat untuk memulai operasi di utas baru.  Seperti layaknya metode yang ditulis dalam pola TAP, itu mengembalikan <code>Task</code> atau <code>Task&lt;T&gt;</code> dan orang-orang yang dihadapkan dengan async / menunggu untuk pertama kalinya memiliki keinginan yang besar untuk membungkus kode sinkron di <code>Task.Run()</code> dan melihat hasil dari metode ini.  Kode sepertinya menjadi tidak sinkron, tetapi pada kenyataannya, tidak ada yang berubah.  Mari kita lihat apa yang terjadi dengan penggunaan <code>Task.Run()</code> . </p><br>  Contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Hasil dari kode ini adalah: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Di sini <code>Thread.Sleep(1000)</code> adalah semacam operasi sinkron yang membutuhkan utas untuk menyelesaikan.  Misalkan kita ingin membuat solusi kita asinkron dan agar operasi ini dapat di-eutanasia, kita membungkusnya dalam <code>Task.Run()</code> . </p><br><p>  Segera setelah kode mencapai metode <code>Task.Run()</code> , utas lain diambil dari kumpulan utas dan kode yang kami <code>Task.Run()</code> ke <code>Task.Run()</code> dijalankan di dalamnya.  Utas lama, seperti layaknya utas yang layak, kembali ke kolam dan menunggu untuk dipanggil lagi untuk melakukan pekerjaan.  Thread baru mengeksekusi kode yang ditransmisikan, mencapai operasi sinkron, menjalankannya secara sinkron (menunggu hingga operasi selesai) dan melangkah lebih jauh di sepanjang kode.  Dengan kata lain, operasi tetap sinkron: kami, seperti sebelumnya, menggunakan aliran selama pelaksanaan operasi sinkron.  Satu-satunya perbedaan adalah bahwa kami menghabiskan waktu untuk mengganti konteks saat memanggil <code>Task.Run()</code> dan kembali ke <code>ExecuteOperation()</code> .  Semuanya menjadi sedikit lebih buruk. </p><br><p>  Harus dipahami bahwa meskipun pada baris <code>Inside after sleep: 3</code> dan <code>After: 3</code> kita melihat Id yang sama dari stream, konteks eksekusi benar-benar berbeda di tempat-tempat ini.  ASP.NET lebih pintar dari kami dan mencoba menghemat sumber daya saat mengalihkan konteks dari kode di dalam <code>Task.Run()</code> ke kode eksternal.  Di sini dia memutuskan untuk tidak mengubah setidaknya aliran eksekusi. </p><br><p>  Dalam kasus seperti itu, tidak masuk akal untuk menggunakan <code>Task.Run()</code> .  Sebaliknya, Clary <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyarankan agar</a> semua operasi tidak sinkron, yaitu, dalam kasus kami, mengganti <code>Thread.Sleep(1000)</code> dengan <code>Task.Delay(1000)</code> , tetapi ini, tentu saja, tidak selalu memungkinkan.  Apa yang harus dilakukan jika kami menggunakan perpustakaan pihak ketiga yang kami tidak bisa atau tidak ingin menulis ulang dan menjadikannya tidak sinkron sampai akhir, tetapi karena satu dan lain alasan kami memerlukan metode async?  Lebih baik menggunakan <code>Task.FromResult()</code> untuk membungkus hasil metode vendor di Task.  Ini, tentu saja, tidak akan membuat kode asinkron, tetapi setidaknya kita akan menghemat pada pengalihan konteks. </p><br><p></p><blockquote>  <b>Lalu mengapa menggunakan Task.Run ()?</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jawabannya sederhana:</a> untuk operasi yang terikat CPU, ketika Anda perlu mempertahankan responsif UI atau memparalelkan perhitungan.  Harus dikatakan di sini bahwa operasi yang terikat CPU bersifat sinkron.  Itu untuk meluncurkan operasi sinkron dalam gaya asinkron yang <code>Task.Run()</code> ditemukan. </blockquote><br><h2>  Penyalahgunaan batal async </h2><br>  Kemampuan untuk menulis metode asinkron yang mengembalikan <code>void</code> ditambahkan untuk menulis pengendali event asinkron.  Mari kita lihat mengapa mereka dapat menyebabkan kebingungan jika digunakan untuk tujuan lain: <br><br><ol><li>  Anda tidak bisa menunggu hasilnya. </li><li>  Penanganan pengecualian melalui try-catch tidak didukung. </li><li>  Tidak mungkin untuk menggabungkan panggilan melalui <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> dan metode serupa lainnya. </li></ol><br><p>  Dari semua alasan ini, poin paling menarik adalah penanganan pengecualian.  Faktanya adalah bahwa dalam metode async yang mengembalikan <code>Task</code> atau <code>Task&lt;T&gt;</code> , pengecualian ditangkap dan dibungkus dalam objek <code>Task</code> , yang kemudian akan diteruskan ke metode pemanggilan.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya untuk MSDN,</a> Clary menulis bahwa karena tidak ada nilai balik dalam metode async-void, tidak ada yang membungkus pengecualian dan mereka dilemparkan langsung dalam konteks sinkronisasi.  Hasilnya adalah pengecualian yang tidak tertangani karena prosesnya macet, memiliki waktu untuk, mungkin, menulis kesalahan ke konsol.  Anda bisa mendapatkan dan memesan pengecualian seperti itu dengan berlangganan acara <code>AppDomain.UnhandledException</code> , tetapi Anda tidak akan lagi dapat menghentikan proses crash bahkan di pawang acara ini.  Perilaku ini tipikal hanya untuk event handler, tetapi tidak untuk metode biasa, dari mana kami mengharapkan kemungkinan penanganan pengecualian standar melalui try-catch. </p><br>  Misalnya, jika Anda menulis seperti ini di aplikasi ASP.NET Core, proses dijamin jatuh: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  Tapi ada baiknya mengubah jenis <code>ThrowAsynchronously</code> metode <code>ThrowAsynchronously</code> ke <code>Task</code> (bahkan tanpa menambahkan kata kunci menunggu) dan pengecualian akan ditangkap oleh penangan kesalahan standar ASP.NET Core, dan proses akan terus hidup meskipun eksekusi. </p><br><p></p><blockquote>  <b>Hati-hati dengan metode async-void</b> - mereka dapat menempatkan Anda dalam prosesnya. </blockquote><br><h2>  menunggu dalam metode garis tunggal </h2><br><p>  Antipattern terakhir tidak seseram yang sebelumnya.  Intinya adalah bahwa tidak masuk akal untuk menggunakan async / menunggu dalam metode yang, misalnya, hanya meneruskan hasil dari metode async lainnya lebih lanjut, dengan kemungkinan pengecualian menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunggu dalam menggunakan</a> . </p><br>  Alih-alih kode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  akan sangat mungkin (dan lebih disukai) untuk menulis: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Mengapa ini berhasil?  Karena kata kunci yang menunggu dapat diterapkan ke objek seperti Tugas, dan tidak untuk metode yang ditandai dengan kata kunci async.  Pada gilirannya, kata kunci async hanya memberi tahu kompiler bahwa metode ini perlu digunakan untuk mesin negara, dan membungkus semua nilai kembali dalam <code>Task</code> (atau di objek seperti Tugas lain). </p><br><p>  Dengan kata lain, hasil dari versi pertama dari metode ini adalah <code>Task</code> , yang akan <code>Completed</code> segera setelah menunggu <code>Task.Delay(1000)</code> berakhir, dan hasil dari versi kedua dari metode ini adalah <code>Task</code> , dikembalikan oleh <code>Task.Delay(1000)</code> , yang akan menjadi <code>Completed</code> secepat 1000 milidetik berlalu . </p><br><p>  Seperti yang Anda lihat, kedua versi itu setara, tetapi pada saat yang sama, yang pertama membutuhkan lebih banyak sumber daya untuk membuat "body kit" yang tidak sinkron. </p><br><p></p><blockquote>  Alex Davis menulis bahwa <b>biaya untuk menggunakan metode asinkron secara langsung dapat sepuluh kali lipat dari biaya untuk menggunakan metode sinkron</b> , jadi ada sesuatu yang dapat dicoba. </blockquote><br><br>  <b>UPD:</b> <br>  Seperti yang ditunjukkan oleh komentar dengan tepat, melihat async / menunggu dari metode garis tunggal menyebabkan efek samping negatif.  Misalnya, saat melempar pengecualian, metode yang melempar Tugas tidak akan terlihat di tumpukan.  Oleh karena itu, <b>menghapus default tidak direkomendasikan secara default</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posting Clary</a> dengan parsing. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435666/">https://habr.com/ru/post/id435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435652/index.html">Cara tidak menggunakan kata sandi dalam skrip Python</a></li>
<li><a href="../id435654/index.html">Jebakan properti CSS khusus</a></li>
<li><a href="../id435656/index.html">Scooter Rolls Royce - Ninebot KickScooter ES4 oleh Segway</a></li>
<li><a href="../id435662/index.html">“Keandalan dan keandalan seperti di Google” - dan tidak hanya: terjemahan artikel “Penghitungan keandalan layanan”</a></li>
<li><a href="../id435664/index.html">Spoofing mesin pencari Google</a></li>
<li><a href="../id435668/index.html">Undang-undang Musim Semi lainnya: wakil mengusulkan agar polisi melacak lokasi anak-anak menggunakan geolokasi</a></li>
<li><a href="../id435670/index.html">Supreme algoritma - distribusi algoritma berdasarkan tingkat kesulitan</a></li>
<li><a href="../id435672/index.html">Bagaimana melatih kembali dalam intelijen bisnis</a></li>
<li><a href="../id435678/index.html">Jangan percaya informasi memori di Task Manager</a></li>
<li><a href="../id435680/index.html">AWS menunjukkan jari tengah open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>