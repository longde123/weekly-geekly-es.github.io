<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóûÔ∏è üö¥üèø üë®üèæ‚Äç‚öïÔ∏è OpenGLESv2-Texturen √ºber DMABUF neu laden ‚öîÔ∏è üå± ‚ú≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich dar√ºber sprechen, wie einfach es ist, OpenGLES-Texturen √ºber DMABUF zu aktualisieren. Ich habe in Habr nachgesehen und zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGLESv2-Texturen √ºber DMABUF neu laden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In diesem Artikel m√∂chte ich dar√ºber sprechen, wie einfach es ist, OpenGLES-Texturen √ºber DMABUF zu aktualisieren.  Ich habe in Habr nachgesehen und zu meiner √úberraschung keinen einzigen Artikel zu diesem Thema gefunden.  In Habr Q &amp; A habe ich auch nichts davon gefunden.  Und das ist ein bisschen komisch f√ºr mich.  Die Technologie erschien vor einiger Zeit, obwohl es im Netzwerk nicht viele Informationen dar√ºber gibt, ist alles vage und widerspr√ºchlich. <br><br>  Ich habe all diese Informationen St√ºck f√ºr St√ºck aus verschiedenen Quellen zusammengetragen, bevor ich einen solchen Videoplayer wie in der obigen Demo schreiben konnte.  In dieser Demo l√§dt mein selbst erstellter Videoplayer, der auf der gstreamer-Bibliothek basiert, jedes Mal vor dem Rendern Videobilder in die OpenGLESv2-Textur.  Angetrieben von Raspberry Pi4.  Frames werden einfach in einen speziell zugewiesenen Speicher kopiert - und DMA √ºbertr√§gt sie in den GPU-Speicher, in die Textur.  Als n√§chstes erz√§hle ich Ihnen, wie ich es gemacht habe. <br><a name="habracut"></a><br>  In der Regel erstellt ein Programmierer, der OpenGLESv2 verwendet, eine Textur nur einmal und rendert sie dann einfach in Szenenobjekte.  Dies passiert, weil sich die Kost√ºme der Charaktere selten √§ndern und manchmal das Neuladen der Textur mit glTexSubImage2D () nicht schwierig ist.  Die eigentlichen Probleme treten jedoch auf, wenn die Textur dynamisch ist und Sie sie w√§hrend des Renderns fast bei jedem Frame aktualisieren m√ºssen.  Die Funktion glTexSubImage2D () ist sehr langsam.  Nun, wie langsam - nat√ºrlich h√§ngt alles vom Computer und von der Grafikkarte ab.  Ich wollte eine L√∂sung finden, die auch auf schwachen Single-Board-Karten wie Raspberry funktioniert. <br><br>  Die Architektur vieler moderner Computer, einschlie√ülich SoC-Single-Board-Computern, ist derart, dass der Prozessorspeicher vom GPU-Speicher getrennt ist.  Normalerweise haben Benutzerprogramme keinen direkten Zugriff auf den GPU-Speicher, und Sie m√ºssen verschiedene API-Funktionen wie das gleiche glTexSubImage2D () verwenden.  Au√üerdem habe ich irgendwo gelesen, dass die interne Darstellung der Textur von der herk√∂mmlichen Darstellung von Bildern als Folge von Pixeln abweichen kann.  Ich wei√ü nicht, wie wahr das ist.  M√∂glicherweise. <br><br>  Was bringt mir die DMABUF-Technologie?  Der Speicher wird speziell zugewiesen und ein Prozess aus einem beliebigen Thread kann dort einfach Pixel schreiben, wann immer er m√∂chte.  DMA selbst √ºbertr√§gt alle √Ñnderungen an der Textur im Speicher der GPU.  Ist das nicht h√ºbsch <br><br>  Ich muss gleich sagen, dass ich √ºber PBO - Pixel Buffer Object Bescheid wei√ü, in der Regel mit Hilfe von PBO wird die dynamische Texturaktualisierung durchgef√ºhrt, DMA scheint auch dort verwendet zu werden, aber PBO erschien nur in OpenGLESv3 und nicht in allen Implementierungen.  Also nein, leider ist das nicht mein Weg. <br><br>  Der Artikel k√∂nnte sowohl f√ºr Raspberry-Programmierer als auch f√ºr Spieleentwickler und wahrscheinlich sogar f√ºr Android-Programmierer von Interesse sein, da OpenGLES auch dort verwendet wird und ich sicher bin, dass diese DMABUF-Technologie auch dort vorhanden ist (zumindest bin ich sicher, dass Sie sie von Android aus verwenden k√∂nnen) NDK). <br><br>  Ich werde ein Programm mit DMABUF auf einem Raspberry Pi4 schreiben.  Das Programm sollte (und wird) auch auf normalen Intel x86 / x86_64-Computern funktionieren, etwa unter Ubuntu. <br><br>  In diesem Artikel gehe ich davon aus, dass Sie bereits wissen, wie Grafiken mit der OpenGLESv2-API programmiert werden.  Allerdings wird es nicht viele dieser Herausforderungen geben.  Meistens werden wir ioctl Magie haben. <br><br>  Als Erstes m√ºssen Sie sicherstellen, dass die auf der Plattform verf√ºgbare API DMABUF unterst√ºtzt.  √úberpr√ºfen Sie dazu die Liste der EGL-Erweiterungen: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br>  Wir werden also sofort verstehen, ob es Hoffnung gibt, DMABUF zu verwenden, oder ob es keine Hoffnung gibt.  Zum Beispiel gibt es auf Raspberry Pi3 und allen vorherigen Boards keine Hoffnung.  Dort wird in der Regel sogar OpenGLESv2 durch spezielle Bibliotheken mit der BRCM-Brosche reduziert.  Und jetzt gibt es auf Raspberry Pi4 ein echtes OpenGLES, die Erweiterung EGL_EXT_image_dma_buf_import ist, Hurra. <br><br>  Ich werde sofort notieren, welches Betriebssystem ich auf einem Single-Board-Pi4 habe, andernfalls kann es auch Probleme damit geben: <br><br><pre> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br>  Ich stelle auch fest, dass sich die EGL_EXT_image_dma_buf_import-Erweiterung auf dem Orange Pi PC (Mali-400) / PC2 (Mali-450) befindet, es sei denn, Sie k√∂nnen die Mali-GPU auf diesen Boards ausf√ºhren (in offiziellen Assemblys ist sie nicht vorhanden, ich habe sie auf Armbian installiert und ich habe es selbst gemacht) Kernel-Treiber-Assembly).  Das hei√üt, DMABUF ist fast √ºberall.  Es ist nur notwendig, zu nehmen und zu verwenden. <br><br>  Als n√§chstes m√ºssen Sie die Datei / dev / dri / card0 oder / dev / dri / card1 √∂ffnen - eine davon h√§ngt von der Plattform ab, es passiert anders, Sie m√ºssen nach der Datei suchen, die DRM_CAP_DUMB_BUFFER unterst√ºtzt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br>  Hier gibt es √ºbrigens eine unerkl√§rliche Subtilit√§t f√ºr mich.  Einige Plattformen verf√ºgen nicht √ºber Bibliotheken, die die DRI2Authenticate () - Funktion bereitstellen.  Zum Beispiel ist es nicht am Riss und in der 32-Bit-Version f√ºr Orange Pi PC.  Das ist alles seltsam.  Aber ich habe ein solches Repository auf GITHUB gefunden: <a href="https://github.com/robclark/libdri2">github.com/robclark/libdri2</a> es kann genommen, zusammengebaut und installiert werden, dann ist alles in Ordnung.  Es ist seltsam, dass es bei meinem Ubuntu 18 (64 Bit) auf einem Laptop kein Problem gibt. <br><br>  Wenn Sie / dev / dri / cardX finden und √∂ffnen k√∂nnten, k√∂nnten Sie weitermachen.  Sie m√ºssen auf die drei wichtigsten Funktionen von KHR (Khronos) zugreifen: <br><br><pre> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br>  Jetzt brauchen wir eine Funktion, die einen Speicherbereich f√ºr DMABUF erstellt.  Die Funktion akzeptiert Parameter als Bitmapbreite, -h√∂he sowie Zeiger, auf die der DmaFd-Dateideskriptorhandler und ein Zeiger auf den Plane-Bitmapspeicher zur√ºckgegeben werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br>  Jetzt m√ºssen wir ein EGL-Image erstellen, das dem DmaFd-Handler zugeordnet ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Und schlie√ülich sind unsere Pr√ºfungen fast vorbei, und wir m√ºssen das EGL-Image und das OpenGLESv2-Image verkn√ºpfen.  Die Funktion gibt einen Zeiger auf den Speicher im Adressraum des Prozesses zur√ºck.  Dort k√∂nnen Sie einfach von jedem Prozessorthread aus schreiben und alle √Ñnderungen im Laufe der Zeit erscheinen automatisch in der GPU-Textur √ºber DMABUF. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  Die Funktion GlEGLImageTargetTexture2DOES (..) nimmt diese Bindung nur vor.  Es verwendet die √ºbliche Textur-ID-Erstellung glGenTextures (..) und ordnet sie dem zuvor erstellten esContext-&gt; ImageKHR EGL-Bild zu.  Danach kann die Textur userData-&gt; textureV in regul√§ren Shadern verwendet werden.  Der Zeiger esContext-&gt; Plane ist ein Zeiger auf den Bereich im Speicher, in den Sie schreiben m√ºssen, um die Textur zu aktualisieren. <br><br>  Hier ist ein Codeausschnitt, der ein Videobild kopiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Diese Funktion wird von gstreamer selbst jedes Mal aufgerufen, wenn ein neues Videobild erscheint.  Wir rufen es mit gst_app_sink_pull_sample () ab.  Diese Funktion hat memcpy (), das den Frame in den DMABUF-Speicher kopiert.  Dann wird das frame_ready-Flag gesetzt und durch std :: condition_variable update_cv.notify_one () der gerenderte Stream aufgeweckt. <br><br>  Das ist wahrscheinlich alles ... <br><br>  Obwohl nein, ich l√ºge.  Es gibt immer noch Probleme bei der Synchronisierung. <br><br>  Das erste ist, dass der Prozessor in den Speicher schreibt, diese Datens√§tze jedoch m√∂glicherweise im Cache des Prozessors gespeichert werden. Nach der Aufzeichnung m√ºssen Sie einen Cache-Cache erstellen.  Die zweite - es w√§re nicht schlecht, genau zu wissen, wann der DMA bereits funktioniert hat und Sie k√∂nnen mit dem Rendern beginnen.  Mal ehrlich, wenn ich mir beim ersten noch vorstelle, wie es geht, dann beim zweiten - nein.  Wenn Sie Ideen haben, schreiben Sie in die Kommentare. <br><br>  Und noch eine Sache.  Ich benutze gstreamer, der eine Videodatei abspielt.  Ich habe der Pipeline einen generischen Appsink hinzugef√ºgt, der Videoframes empf√§ngt.  Ich nehme die Pixel aus den Videoframes und kopiere sie einfach memcpy () in den DMABUF-Speicherbereich.  Das Rendern erfolgt in einem separaten Thread, main ().  Aber ich m√∂chte diese Kopie loswerden.  Jede Kopie ist b√∂se.  Es gibt sogar einen solchen Begriff Nullkopie.  Und nach der Dokumentation scheint es, dass gstreamer selbst Frames in DMABUF sofort rendern kann.  Leider habe ich kein einziges echtes Beispiel gefunden.  Ich habe mir die Quellen von gstreamer angesehen - da ist etwas dran, aber wie man es genau benutzt, ist nicht klar.  Wenn Sie wissen, wie Sie mit gstreamer in OpenGLESv2-Textur echte Zero-Copy-Frames erstellen k√∂nnen, schreiben Sie. <br><br>  Vielleicht der letzte Punkt: In meinem Projekt verwende ich 32-Bit-Bitmaps, was in meinem Fall nicht gut ist.  Es w√§re viel vern√ºnftiger, YUV von gstreamer zu nehmen, dann ist die Videorahmengr√∂√üe viel kleiner, aber die Logik ist kompliziert - ich m√ºsste 3 DMABUF f√ºr drei Texturen separat ausf√ºhren. Y, U, V. Nun, der Shader ist auch kompliziert, Sie m√ºssen YUV in ARGB konvertieren direkt im Shader. <br><br>  Sie k√∂nnen das gesamte Projekt <a href="https://github.com/random-prj/video-cube">auf Github anzeigen</a> .  Ich entschuldige mich jedoch im Voraus bei Liebhabern von sauberem und korrektem Code / Stil.  Ich gebe zu, dass es mit Hilfe von Google-Mine-Paste nachl√§ssig geschrieben wurde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481540/">https://habr.com/ru/post/de481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481530/index.html">Nevanger: Feed f√ºr Geschwindigkeit</a></li>
<li><a href="../de481532/index.html">Memory Forensics, Rubber Duck und GPO-Passw√∂rter. Probleml√∂sung mit r0ot-mi. Teil 2</a></li>
<li><a href="../de481534/index.html">Stirbt Delphi - Falsch</a></li>
<li><a href="../de481536/index.html">Die Geschichte des Domain Name Systems: "Krieg" -Protokolle</a></li>
<li><a href="../de481538/index.html">20 SEO-Mythen, die 2020 sterben werden</a></li>
<li><a href="../de481542/index.html">√úberpr√ºfung von digitalen Schaltkreisen. R√ºckblick</a></li>
<li><a href="../de481544/index.html">Verwenden eines neuronalen Faltungsnetzwerks zum Spielen von Life (auf Keras)</a></li>
<li><a href="../de481546/index.html">Die Geschichte des Mikroprozessors und des Personalcomputers: 1947-1974</a></li>
<li><a href="../de481548/index.html">Symbol.iterator in Javascript</a></li>
<li><a href="../de481550/index.html">Inmarsat: Empfang und Dekodierung eines Satellitensignals zu Hause</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>