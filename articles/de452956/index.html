<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚ÄçüöÄ üé£ üö¶ Benchmark f√ºr den CPU-Verbrauch f√ºr Istio und Linkerd üçµ ü§üüèº ‚úäüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Wir bei Shopify haben Istio als Service-Mesh bereitgestellt. Im Prinzip passt alles, bis auf eines: Es ist teuer . 


 Die ver√∂ffentlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmark f√ºr den CPU-Verbrauch f√ºr Istio und Linkerd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/452956/"><p><img src="https://habrastorage.org/webt/wz/yt/na/wzytna1lrwbgmf_076egdwjcoi4.png"></p><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shopify haben</a> Istio als Service-Mesh bereitgestellt.  Im Prinzip passt alles, bis auf eines: <strong>Es ist teuer</strong> . </p><br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ver√∂ffentlichten Benchmarks</a> f√ºr Istio lauten: </p><br><blockquote>  Mit Istio 1.1 verbraucht der Proxy ungef√§hr 0,6 vCPUs (virtuelle Kerne) pro 1000 Anforderungen pro Sekunde. </blockquote><p> F√ºr die erste Region im Service-Mesh (2 Proxys auf jeder Seite der Verbindung) stehen 1200 Kerne nur f√ºr Proxys mit einer Rate von einer Million Anforderungen pro Sekunde zur Verf√ºgung.  Laut dem Kostenrechner von Google erhalten Sie f√ºr die <code>n1-standard-64</code> Konfiguration etwa 40 US-Dollar pro Monat und Kern, <code>n1-standard-64</code> allein diese Region kostet uns mehr als 50.000 US-Dollar pro Monat f√ºr 1 Million Anfragen pro Sekunde. </p><br><p>  Ivan Sim ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ivan Sim</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat die</a> Verz√∂gerungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beim</a> Service-Mesh im letzten Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klar verglichen</a> und dasselbe f√ºr den Speicher und den Prozessor versprochen, ist jedoch gescheitert: </p><br><blockquote>  Anscheinend wird values-istio-test.yaml die Prozessoranforderungen ernsthaft erh√∂hen.  Wenn ich alles richtig berechnet habe, ben√∂tigen Sie ungef√§hr 24 Prozessorkerne f√ºr das Bedienfeld und 0,5 CPU f√ºr jeden Proxy.  Ich habe nicht so viel.  Ich werde die Tests wiederholen, wenn mir mehr Ressourcen zugewiesen werden. </blockquote><p>  Ich wollte selbst sehen, wie √§hnlich Istios Leistung einem anderen Open-Source-Service-Mesh ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linkerd</a> . </p><a name="habracut"></a><br><h3 id="ustanovka-service-mesh">  Installation des Servicegitters </h3><br><p>  Das erste, was ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SuperGloo-</a> Cluster installiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe, war</a> : </p><br><pre> <code class="plaintext hljs">$ supergloo init installing supergloo version 0.3.12 using chart uri https://storage.googleapis.com/supergloo-helm/charts/supergloo-0.3.12.tgz configmap/sidecar-injection-resources created serviceaccount/supergloo created serviceaccount/discovery created serviceaccount/mesh-discovery created clusterrole.rbac.authorization.k8s.io/discovery created clusterrole.rbac.authorization.k8s.io/mesh-discovery created clusterrolebinding.rbac.authorization.k8s.io/supergloo-role-binding created clusterrolebinding.rbac.authorization.k8s.io/discovery-role-binding created clusterrolebinding.rbac.authorization.k8s.io/mesh-discovery-role-binding created deployment.extensions/supergloo created deployment.extensions/discovery created deployment.extensions/mesh-discovery created install successful!</code> </pre> <br><p>  Ich habe SuperGloo verwendet, weil es den Start des Service-Mesh erheblich vereinfacht.  Ich hatte fast nichts zu tun.  In der Produktion verwenden wir kein SuperGloo, aber es ist ideal f√ºr eine √§hnliche Aufgabe.  Ich musste nur ein paar Befehle auf jedes Service-Mesh anwenden.  Ich habe zwei Cluster zur Isolation verwendet - einen f√ºr Istio und Linkerd. </p><br><p>  Das Experiment wurde mit der Google Kubernetes Engine durchgef√ºhrt.  Ich habe Kubernetes <code>1.12.7-gke.7</code> und den <code>1.12.7-gke.7</code> <code>n1-standard-4</code> mit automatischer <code>1.12.7-gke.7</code> (Minimum 4, Maximum 16) verwendet. </p><br><p>  Dann habe ich beide Service-Mesh √ºber die Kommandozeile installiert. </p><br><p>  Linkerd zuerst: </p><br><pre> <code class="plaintext hljs">$ supergloo install linkerd --name linkerd +---------+--------------+---------+---------------------------+ | INSTALL | TYPE | STATUS | DETAILS | +---------+--------------+---------+---------------------------+ | linkerd | Linkerd Mesh | Pending | enabled: true | | | | | version: stable-2.3.0 | | | | | namespace: linkerd | | | | | mtls enabled: true | | | | | auto inject enabled: true | +---------+--------------+---------+---------------------------+</code> </pre> <br><p>  Dann Istio: </p><br><pre> <code class="plaintext hljs">$ supergloo install istio --name istio --installation-namespace istio-system --mtls=true --auto-inject=true +---------+------------+---------+---------------------------+ | INSTALL | TYPE | STATUS | DETAILS | +---------+------------+---------+---------------------------+ | istio | Istio Mesh | Pending | enabled: true | | | | | version: 1.0.6 | | | | | namespace: istio-system | | | | | mtls enabled: true | | | | | auto inject enabled: true | | | | | grafana enabled: true | | | | | prometheus enabled: true | | | | | jaeger enabled: true | +---------+------------+---------+---------------------------+</code> </pre> <br><p>  Die Crash-Schleife dauerte einige Minuten, und dann stabilisierten sich die Bedienfelder. </p><br><p>  <em>(Hinweis: SuperGloo unterst√ºtzt derzeit nur Istio 1.0.x. Ich habe das Experiment mit Istio 1.1.3 wiederholt, aber keinen merklichen Unterschied festgestellt.)</em> </p><br><h3 id="nastroyka-avtomaticheskogo-vnedreniya-istio">  Einrichten der automatischen Bereitstellung von Istio </h3><br><p>  Damit Istio den Sidecar Envoy installieren kann, verwenden wir den Sidecar-Injektor - <code>MutatingAdmissionWebhook</code> .  Wir werden in diesem Artikel nicht √ºber ihn sprechen.  Ich kann nur sagen, dass dies ein Controller ist, der den Zugriff aller neuen Pods √ºberwacht und dynamisch einen Beiwagen und initContainer hinzuf√ºgt, der f√ºr <code>iptables</code> Aufgaben verantwortlich ist. </p><br><p>  Wir bei Shopify haben unseren Zugangscontroller geschrieben, um den Beiwagen zu implementieren, aber in diesem Benchmark habe ich den Controller genommen, der mit Istio geliefert wird.  Der Controller injiziert standardm√§√üig einen Beiwagen, wenn im Namespace eine Verkn√ºpfung mit <code>istio-injection: enabled</code> : </p><br><pre> <code class="plaintext hljs">$ kubectl label namespace irs-client-dev istio-injection=enabled namespace/irs-client-dev labeled $ kubectl label namespace irs-server-dev istio-injection=enabled namespace/irs-server-dev labeled</code> </pre> <br><h3 id="nastroyka-avtomaticheskogo-vnedreniya-linkerd">  Konfigurieren Sie die automatische Bereitstellung von Linkerd </h3><br><p>  Um die Implementierung von Linkerd-Beiwagen zu konfigurieren, verwenden wir Anmerkungen (ich habe sie manuell √ºber <code>kubectl edit</code> hinzugef√ºgt): </p><br><pre> <code class="plaintext hljs">metadata: annotations: linkerd.io/inject: enabled</code> </pre> <br><pre> <code class="plaintext hljs">$ k edit ns irs-server-dev namespace/irs-server-dev edited $ k get ns irs-server-dev -o yaml apiVersion: v1 kind: Namespace metadata: annotations: linkerd.io/inject: enabled name: irs-server-dev spec: finalizers: - kubernetes status: phase: Active</code> </pre> <br><h3 id="simulyator-otkazoustoychivosti-istio">  Fehlertoleranzsimulator Istio </h3><br><p>  Wir haben den Istio-Fehlertoleranzsimulator entwickelt, um mit dem f√ºr Shopify einzigartigen Datenverkehr zu experimentieren.  Wir brauchten ein Tool, um eine beliebige Topologie zu erstellen, die einen bestimmten Teil des Diagramms unseres Dienstes mit dynamischer Optimierung darstellt, um bestimmte Workloads zu simulieren. </p><br><p>  Die Shopify-Infrastruktur ist w√§hrend des Flash-Verkaufs stark ausgelastet.  Gleichzeitig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empfiehlt</a> Shopify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Verk√§ufern, solche Verk√§ufe h√§ufiger durchzuf√ºhren</a> .  Gro√ükunden warnen manchmal vor einem geplanten Flash-Verkauf.  Andere geben sie zu jeder Tages- und Nachtzeit unerwartet f√ºr uns aus. </p><br><p>  Wir wollten, dass unser Fehlertoleranzsimulator Workflows modelliert, die den Topologien und Workloads entsprechen, die die Shopify-Infrastruktur in der Vergangenheit √ºberlastet haben.  Das Hauptziel der Verwendung des Service-Meshs besteht darin, dass wir Zuverl√§ssigkeit und Fehlertoleranz auf Netzwerkebene ben√∂tigen. F√ºr uns ist es wichtig, dass das Service-Mesh die Lasten effektiv bew√§ltigt, die zuvor den Betrieb von Services unterbrochen haben. </p><br><p>  Der Failover-Simulator basiert auf einem Arbeitsknoten, der als Service-Mesh-Knoten fungiert.  Der Arbeitsknoten kann beim Start statisch oder dynamisch √ºber die REST-API konfiguriert werden.  Wir verwenden die dynamische Optimierung von Arbeitsknoten, um Workflows in Form von Regressionstests zu erstellen. </p><br><p>  Hier ist ein Beispiel f√ºr einen solchen Prozess: </p><br><ul><li>  Wir starten 10 Server als <code>bar</code> , der nach 100 ms eine <code>200/OK</code> Antwort zur√ºckgibt. </li><li>  Wir starten 10 Clients - jeder sendet 100 Anfragen pro Sekunde an <code>bar</code> . </li><li>  Alle 10 Sekunden entfernen wir 1 Server und √ºberwachen <code>5xx</code> Fehler auf dem Client. </li></ul><br><p>  Am Ende des Workflows untersuchen wir die Protokolle und Metriken und pr√ºfen, ob der Test erfolgreich ist.  Auf diese Weise lernen wir die Leistung unseres Service-Netzes kennen und f√ºhren einen Regressionstest durch, um unsere Annahmen zur Fehlertoleranz zu testen. </p><br><p>  <em>(Hinweis: Wir erw√§gen, den Quellcode f√ºr den Istio-Fehlertoleranzsimulator zu √∂ffnen, sind jedoch noch nicht bereit daf√ºr.)</em> </p><br><h3 id="simulyator-otkazoustoychivosti-istio-dlya-benchmarka-service-mesh">  Istio-Fehlertoleranzsimulator f√ºr Service-Mesh-Benchmark </h3><br><p>  Wir konfigurieren mehrere Arbeitsknoten des Simulators: </p><br><ul><li>  <code>irs-client-loadgen</code> : 3 Replikate, die 100 Anforderungen pro Sekunde an <code>irs-client</code> senden. </li><li>  <code>irs-client</code> : 3 Replikate, die die Anfrage empfangen, warten 100 ms und leiten die Anfrage an den <code>irs-server</code> . </li><li>  <code>irs-server</code> : 3 Replikate, die nach 100 ms <code>200/OK</code> zur√ºckgeben. </li></ul><br><p>  Mit dieser Konfiguration k√∂nnen wir einen stabilen Verkehrsfluss zwischen 9 Endpunkten messen.  Beiwagen in <code>irs-client-loadgen</code> und <code>irs-server</code> empfangen 100 Anfragen pro Sekunde und <code>irs-client</code> - 200 (eingehend und ausgehend). </p><br><p>  Wir verfolgen die Ressourcennutzung √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DataDog,</a> da wir keinen Prometheus-Cluster haben. </p><br><h2 id="rezultaty">  Ergebnisse </h2><br><h3 id="paneli-upravleniya">  Bedienfelder </h3><br><p>  Zuerst haben wir den CPU-Verbrauch untersucht. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/wd/bb/md/wdbbmdzr0sx8tlfhmyinyglsr0i.png"></a> <br>  <em>Linkerd Control Panel ~ 22M</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/nr/1p/ag/nr1pagqdpichos1evmok6jafn7w.png"></a> <br>  <em>Istio Control Panel: ~ 750 Millionen Kerne</em> </p><br><p>  Das Istio-Bedienfeld verwendet ungef√§hr <strong>35-mal mehr Prozessorressourcen</strong> als Linkerd.  Nat√ºrlich ist standardm√§√üig alles eingestellt, und die Istio-Telemetrie verbraucht viele Prozessorressourcen (Sie k√∂nnen sie deaktivieren, indem Sie einige Funktionen aufgeben).  Wenn Sie diese Komponente entfernen, stellt sich heraus, dass es sich immer noch um mehr als 100 Multicore handelt, das ist <strong>viermal mehr</strong> als bei Linkerd. </p><br><h3 id="sidecar-proksi">  Beiwagen-Proxy </h3><br><p>  Dann haben wir die Verwendung von Proxies √ºberpr√ºft.  Es sollte eine lineare Abh√§ngigkeit von der Anzahl der Anforderungen bestehen, aber f√ºr jeden Beiwagen gibt es einige Gemeinkosten, die sich auf die Kurve auswirken. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ve/ky/bw/vekybwloc_ffg8_pmrm6cf56tqq.png"></a> <br>  <em>Linkerd: ~ 100Mnuclear f√ºr irs-client, ~ 50Mnuclear f√ºr irs-client-loadgen</em> </p><br><p>  Die Ergebnisse sehen logisch aus, da der Client-Proxy doppelt so viel Datenverkehr empf√§ngt wie der Loadgen-Proxy: F√ºr jede ausgehende Anforderung von Loadgen verf√ºgt der Client √ºber einen eingehenden und einen ausgehenden. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/81/wh/lo/81whlom3ym23hp7cisg3tsgu8qs.png"></a> <br>  <em>Istio / Gesandter: ~ 155 Million√§re f√ºr irs-client, ~ 75 Million√§re f√ºr irs-client-loadgen</em> </p><br><p>  Wir sehen √§hnliche Ergebnisse f√ºr den Istio-Beiwagen. </p><br><p>  Insgesamt verbrauchen Istio / Envoy-Proxys jedoch <strong>etwa 50% mehr Prozessorressourcen</strong> als Linkerd. </p><br><p>  Wir sehen das gleiche Schema auf der Serverseite: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ou/xl/bw/ouxlbwvtilchju4qykltpesfz58.png"></a> <br>  <em>Linkerd: ~ 50 Multicore f√ºr IRS-Server</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/cd/1p/ia/cd1pia4q2sniccgybpy-uipuubu.png"></a> <br>  <em>Istio / Envoy: ~ 80 Multicore f√ºr IRS-Server</em> </p><br><p>  Auf der Serverseite verbraucht der Istio / Envoy-Beiwagen <strong>etwa 60% mehr Prozessorressourcen</strong> als Linkerd. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Der Istio Envoy-Proxy verbraucht bei unserer simulierten Arbeitslast 50 +% mehr CPU als Linkerd.  Das Linkerd-Bedienfeld verbraucht viel weniger Ressourcen als Istio, insbesondere f√ºr die Hauptkomponenten. </p><br><p>  Wir denken immer noch dar√ºber nach, wie wir diese Kosten senken k√∂nnen.  Wenn Sie Ideen haben, teilen Sie! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452956/">https://habr.com/ru/post/de452956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452942/index.html">GeekBrains h√§lt 12 kostenlose Online-Meetings mit Programmierexperten ab</a></li>
<li><a href="../de452944/index.html">Was wird der "Dialog" von Linguisten und Datenanalysespezialisten sein?</a></li>
<li><a href="../de452946/index.html">Lou Greenaws ‚ÄûWindows 95 / NT-Programmierphilosophie‚Äú erneut lesen</a></li>
<li><a href="../de452952/index.html">JetBrains Tag der offenen T√ºr in St. Petersburg</a></li>
<li><a href="../de452954/index.html">Aufbau von Zeit, Netzwerkgeschwindigkeit und Routing: Wie wir unser Mesh-Netzwerk verbessert haben und ein bisschen √ºber neuronale Netzwerke</a></li>
<li><a href="../de452958/index.html">JMAP - Ein offenes Protokoll ersetzt IMAP beim Austausch von E-Mails</a></li>
<li><a href="../de452960/index.html">Sie werden f√ºr alles antworten! Verbrauchergesteuerte Vertr√§ge mit den Augen des Entwicklers</a></li>
<li><a href="../de452962/index.html">Die Hauptursache f√ºr Unf√§lle in Rechenzentren ist das Verlegen zwischen Computer und Stuhl</a></li>
<li><a href="../de452964/index.html">Eine erschwingliche Erkl√§rung der Riemannschen Hypothese</a></li>
<li><a href="../de452966/index.html">Der Mythos der Achtsamkeit: eine ‚Äûneurozentrische‚Äú Sicht der Meditation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>