<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüîß üë®üèª‚ÄçüöÄ üë®üèΩ‚Äçüî¨ ¬øQu√© hay dentro de asyncio? üõ¥ üëåüèº üç®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, invito al lector a realizar un viaje moderadamente emocionante en las entra√±as de asyncio para comprender c√≥mo implementa la ejecuci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© hay dentro de asyncio?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453348/"><p>  En este art√≠culo, invito al lector a realizar un viaje moderadamente emocionante en las entra√±as de <em><strong>asyncio</strong></em> para comprender c√≥mo implementa la ejecuci√≥n de c√≥digo asincr√≥nico.  Ensillamos las devoluciones de llamadas y corremos a trav√©s de una serie de eventos a trav√©s de un par de abstracciones clave directamente en la corutina.  Si su mapa de Python a√∫n no tiene estas atracciones, bienvenido a cat. </p><a name="habracut"></a><br><h2 id="dlya-zatravki--kratkaya-spravka-o-raskinuvsheysya-pered-nami-mestnosti">  Para empezar, una breve referencia sobre el √°rea se extendi√≥ ante nosotros. </h2><br><p> <em><strong>asyncio</strong></em> es una biblioteca de E / S as√≠ncrona que, seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pep3153</a> , se cre√≥ para proporcionar un marco estandarizado para crear marcos asincr√≥nicos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pep3156</a> tambi√©n le atribuye la necesidad de proporcionar una integraci√≥n extremadamente simple en marcos asincr√≥nicos ya existentes (Twisted, Tornado, Gevent).  Como podemos observar ahora, estos objetivos se lograron con √©xito: apareci√≥ un nuevo marco basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/aio-libs/aio">asincio</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/aio-libs/aio">aiohttp</a> , en Tornado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AsyncioMainLoop</a> es el bucle de eventos predeterminado de la versi√≥n 5.0, en Twisted <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asyncioreactor</a> est√° disponible desde la versi√≥n 16.5.0, y hay una biblioteca de aiogevent de terceros para Gevent . </p><br><p>  <em><strong>asyncio</strong></em> es una biblioteca h√≠brida que utiliza simult√°neamente dos enfoques para implementar la ejecuci√≥n de c√≥digo as√≠ncrono: cl√°sico en devoluciones de llamada y, relativamente nuevo, (al menos para python) en las rutinas.  Se basa en tres abstracciones principales, que son an√°logas a las abstracciones que existen en los marcos de terceros: </p><br><ul><li>  <strong>Bucle de eventos enchufable</strong> <br>  Bucle de eventos enchufable.  Conectable significa que se puede reemplazar en dos l√≠neas de c√≥digo con otra que implemente la misma interfaz.  Ahora hay implementaciones de cython encima de libuv ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uvloop</a> ) <del>  y en Rust ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asyncio-tokio</a> ) </del>  . </li><li>  <strong>Futuro</strong> <br>  El resultado de la operaci√≥n, que estar√° disponible en el futuro.  Es necesario obtener el resultado de la ejecuci√≥n de devoluciones de llamada en las rutinas. </li><li>  <strong>Tarea</strong> <br>  Una subclase especial de Future para ejecutar la rutina en un bucle de eventos. </li></ul><br><h2 id="poehali">  Vamos! </h2><br><p>  El ciclo de eventos es el componente principal de la biblioteca, a lo largo de las carreteras que lo atraviesan, los datos se entregan a cualquiera de sus componentes.  Es grande y complejo, as√≠ que primero considere su versi√≥n simplificada. </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py import collections import random class Loop: def __init__(self): #     self.ready = collections.deque() def call_soon(self, callback, *args): #          self.ready.append((callback, args)) def run_until_complete(self, callback, *args): #         self.call_soon(callback, *args) #    -   #       while self.ready: ntodo = len(self.ready) #      #          for _ in range(ntodo): #       #        callback, args = self.ready.popleft() callback(*args) def callback(loop): print('') loop.call_soon(print, '') loop = Loop() loop.run_until_complete(callback, loop)</span></span></code> </pre> <br><p>  Montando nuestra peque√±a devoluci√≥n de llamada, salimos a la carretera a trav√©s de <strong>call_soon</strong> , <strong>entramos</strong> en la cola y despu√©s de una breve espera se nos mostrar√°. </p><br><h4 id="epizod-pro-plohie-kollbeki">  Episodio Bad Callback </h4><br><p>  Vale la pena mencionar que las devoluciones de llamada son caballos peligrosos: si te arrojan a la mitad del camino, el int√©rprete de Python no podr√° ayudarte a entender d√≥nde sucedi√≥ esto.  Si no <strong>me</strong> cree, <strong>viaje de</strong> la misma manera en la devoluci√≥n de <strong>llamada</strong> maybe_print, que llega a la meta aproximadamente la mitad del tiempo. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def maybe_print(msg): if random.randint(0, 1): raise Exception(msg) else: print(msg) def starting_point(loop): #   print('') loop.call_soon(maybe_print, '') def main(loop): loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) loop = Loop() loop.run_until_complete(main, loop)</span></span></code> </pre><br><p>  A continuaci√≥n se muestra el rastreo completo del ejemplo anterior.  Debido al hecho de que la funci√≥n <strong>maybe_print</strong> fue iniciada por un bucle de eventos, y no directamente desde el <strong>punto</strong> de <strong>inicio</strong> , el rastreo finaliza en el m√©todo <strong>run_until_complete</strong> .  Es imposible determinar d√≥nde est√° el <strong>punto de inicio</strong> en el c√≥digo utilizando dicho rastreo, lo que complicar√° en gran medida la depuraci√≥n si el <strong>punto de inicio</strong> se encuentra en varios lugares de la base de c√≥digo. </p><br><pre> <code class="bash hljs">$: python3 base_loop.py &gt;&gt;  <span class="hljs-comment"><span class="hljs-comment">#    &gt;&gt;  #    &gt;&gt;  #    &gt;&gt; Traceback (most recent call last): &gt;&gt; File "base_loop.py", line 42, in &lt;module&gt; &gt;&gt; loop.run_until_complete(main, loop) &gt;&gt; File "base_loop.py", line 17, in run_until_complete &gt;&gt; callback(*args) &gt;&gt; File "base_loop.py", line 29, in maybe_print &gt;&gt; raise Exception(msg) &gt;&gt; Exception:  #    </span></span></code> </pre> <br><p>  Se necesita una pila continua de llamadas no solo para mostrar el rastreo completo, sino tambi√©n para implementar otras caracter√≠sticas del lenguaje.  Por ejemplo, el manejo de excepciones se basa en ello.  El siguiente ejemplo no funcionar√°, porque para el momento en que comienza el punto_inicio, la funci√≥n <strong>principal</strong> ya se habr√° ejecutado: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): try: loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) except: pass Loop().run_until_complete(main, loop)</span></span></code> </pre> <br><p>  El siguiente ejemplo tampoco funcionar√°.  El administrador de contexto en la funci√≥n <strong>principal</strong> abrir√° y cerrar√° el archivo antes de que se inicie su procesamiento. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): with open('file.txt', 'rb') as f: loop.call_soon(process_file, f) Loop().run_until_complete(main, loop) #       ,    =(</span></span></code> </pre> <br><p>  La falta de una pila continua de llamadas limita el uso de funciones de lenguaje familiares.  Para evitar parcialmente este inconveniente en asyncio, tuve que agregar una gran cantidad de c√≥digo adicional que no estaba directamente relacionado con la tarea que estaba resolviendo.  Este c√≥digo, en su mayor parte, falta en los ejemplos; son bastante complicados sin √©l. </p><br><h4 id="iz-cikla-sobytiy-vo-vneshniy-mir-i-obratno">  Del ciclo de eventos al mundo exterior y viceversa. </h4><br><p>  El bucle de eventos se comunica con el mundo exterior a trav√©s del sistema operativo a trav√©s de eventos.  El c√≥digo que sabe c√≥mo trabajar con √©l lo proporciona un m√≥dulo de biblioteca est√°ndar llamado <strong>selectores</strong> .  Le permite decirle al sistema operativo que estamos esperando alg√∫n tipo de evento y luego preguntar si sucedi√≥.  En el siguiente ejemplo, el evento esperado ser√° la disponibilidad del socket de lectura. </p><br><div class="spoiler">  <b class="spoiler_title">Bucle de eventos</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/event_loop.py import selectors import socket import collections from future import Future from handle import Handle from task import Task class EventLoop: def __init__(self): self.ready = collections.deque() #   self.selector = selectors.DefaultSelector() def add_reader(self, sock, callback): #       # : # , #         #           self.selector.register( sock, socket.EVENT_READ, (self._accept_conn, sock, callback) ) def _accept_conn(self, sock, callback): #    conn, addr = sock.accept() conn.setblocking(False) #      self.selector.register( conn, socket.EVENT_READ, (callback, conn) ) def run_until_complete(self, callback, *args): self.call_soon(callback, *args) #           -  while self.ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self.ready.popleft() callback(*args) #       for key, events in self.selector.select(timeout=0): #          callback, *args = key.data #       self.call_soon(callback, *args) def call_soon(self, callback, *args): self.ready.append((callback, args)) def print_data(conn): print(conn.recv(1000)) def main(loop): #   sock = socket.socket() #     8086  sock.bind(('localhost', 8086)) sock.listen(100) sock.setblocking(False) #      loop.add_reader(sock, print_data) loop = EventLoop() #    loop.run_until_complete(main, loop)</span></span></code> </pre> </div></div><br><p>  Un mensajero del mundo exterior deja su mensaje o paquete en el selector, y el selector se lo pasa al destinatario.  Ahora es posible leer desde el socket utilizando un bucle de eventos.  Si ejecuta este c√≥digo y se conecta usando netcat, mostrar√° fielmente todo lo que se le enviar√°. </p><br><pre> <code class="bash hljs">$: nc localhost 8086 $: python3 event_loop.py <span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hi there!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hello!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Answer me, please!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Answer me, please!"\n'</span></span></code> </pre> <br><p>  Al comienzo del art√≠culo, se dec√≠a que asyncio es una biblioteca h√≠brida en la que las corutinas funcionan adem√°s de las devoluciones de llamada.  Para implementar esta funcionalidad, se utilizan dos abstracciones principales restantes: <strong>Tarea</strong> y <strong>Futuro</strong> .  A continuaci√≥n, se mostrar√° el c√≥digo de estas abstracciones, y luego, utilizando su ciclo de eventos, se ejecutar√°n las rutinas. </p><br><h4 id="future">  Futuro </h4><br><p>  A continuaci√≥n se muestra el c√≥digo para la clase Future.  Es necesario para que en corutina pueda esperar hasta que se complete la devoluci√≥n de llamada y obtener su resultado. </p><br><div class="spoiler">  <b class="spoiler_title">Futuro</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future.py import sys from asyncio import events, CancelledError class Future: #        _state = 'PENDING' # FINISHED, CANCELLED #          Future #          _source_traceback = None #            _callbacks = [] #           _exception = None #           _loop = None #     _result = None def __init__(self, loop): self._loop = loop self._source_traceback = events.extract_stack(sys._getframe(1)) def add_done_callback(self, callback): #        self._callbacks.append(callback) def _schedule_callbacks(self): #         for callback in self._callbacks: self._loop.call_soon(callback, self) self._callbacks[:] = [] #            Future #    -     def set_exception(self, exception): #       self._exception = exception #   self._state = 'FINISHED' #      self._schedule_callbacks() def set_result(self, result): #         self._result = result self._state = 'FINISHED' self._schedule_callbacks() def cancel(self): #       self._state = 'CANCELLED' self._schedule_callbacks() def result(self): #     #         if self._state == 'CANCELLED': raise CancelledError #         if self._exception is not None: raise self._exception #    return self._result def __await__(self): #  ,    await #        if self._state == 'PENDING': yield self #     return self.result()</span></span></code> </pre></div></div><br><h4 id="task">  Tarea </h4><br><p>  Esta es una subclase especial de <strong>Future</strong> .  Es necesario ejecutar corutinas en el bucle de eventos de devoluci√≥n de llamada. </p><br><div class="spoiler">  <b class="spoiler_title">Tarea</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/task.py from asyncio import futures from future import Future class Task(Future): def __init__(self, coro, *, loop=None): super().__init__(loop=loop) #    self._coro = coro def _step(self, exc=None): #    ,     try: if exc is None: #        None #        result = self._coro.send(None) else: #        self._coro.throw(exc) except StopIteration: result = None except Exception as exc: self.set_exception(exc) else: #   Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) #     step     elif result is None: self._loop.call_soon(self._step) def _wakeup(self, future): #     Future       Task #   try: future.result() except Exception as exc: self._step(exc) #        Future else: self._step()</span></span></code> </pre> </div></div><br><h4 id="cikl-sobytiy-umeyuschiy-rabotat-s-future">  Un ciclo de eventos que pueden funcionar con Future </h4><br><div class="spoiler">  <b class="spoiler_title">EventLoop con futuros</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future_event_loop.py import selectors from selectors import EVENT_READ, EVENT_WRITE import socket import collections from future import Future from task import Task class EventLoop: def __init__(self): self._ready = collections.deque() self.selector = selectors.DefaultSelector() def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): callback, *args = key.data self.call_soon(callback, *args) def call_soon(self, callback, *args): self._ready.append((callback, args)) #      Future def sock_accept(self, sock, fut=None): #       #  Future     fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: #    #   Future    fut.set_result((conn, address)) self.selector.unregister(sock) return fut def sock_recv(self, sock, n, fut=None): #       #      , #     ,      fut = fut if fut else Future(loop=self) try: data = sock.recv(n) except (BlockingIOError, InterruptedError): self.selector.register( sock, EVENT_READ, (self.sock_recv, sock, n, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: fut.set_result(data) self.selector.unregister(sock) return fut async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    conn, addr = await loop.sock_accept(sock) #     result = await loop.sock_recv(conn, 1000) print(result) loop = EventLoop() #    Task task = Task(coro=main(loop), loop=loop) #         loop.run_until_complete(task._step)</span></span></code> </pre> </div></div><br><h4 id="dvinemsya-dalshe">  Sigamos adelante </h4><br><p>  Ahora veamos c√≥mo se ejecutar√° la corutina <strong>principal</strong> : </p><br><div class="spoiler">  <b class="spoiler_title">Cumplimiento</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">__________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): # task._step    self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #     callback(*args) # task._step() ___________________________________________________________________ clsss Task: def _step(self, exc=None): try: if exc is None: #  None   result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): #      #   sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #         conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): #   Future fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: -------------------------------------------- self.selector.unregister(sock) #  Future   return fut ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __await__  Future conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): #   Future         if self._state == 'PENDING': yield self return self.result() ___________________________________________________________________ class Task(Future): def _step(self, exc=None): try: if exc is None: #           None result = self._coro.send(None) # result = fut -------------------------------- else: #  Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) elif result is None: self._loop.call_soon(self._step) #      -    Task  Future #    #               ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): #    callback, *args = key.data self.call_soon(callback, *args) # loop.sock_accept(sock, fut) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): fut = fut if fut else Future(loop=self) try: #    conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): -------------------------------- else: #   Future fut.set_result((conn, address)) self.selector.unregister(sock) return fut ___________________________________________________________________ class Future: def set_result(self, result): #   self._result = result #   self._state = 'FINISHED' #      self._schedule_callbacks() def _schedule_callbacks(self): for callback in self._callbacks: #         task.wakeup self._loop.call_soon(callback, self) # (task.wakeup, fut) self._callbacks[:] = [] ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #      #    task.wakeup callback(*args) # task.wakeup(fut) ___________________________________________________________________ class Task(Future): def _wakeup(self, future): try: future.result() except Exception as exc: self._step(exc) else: #   Future      task._step self._step() def _step(self, exc=None): try: if exc is None: #       None result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __awai__   conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): if self._state == 'PENDING': yield self #   Future    return self.result() ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    Future    conn  addr conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result)</code> </pre> </div></div><br><p>  De esta manera simple, asyncio realiza corutinas. </p><br><h4 id="itogi">  Resumen </h4><br><p>  El objetivo de crear asyncio se ha logrado con √©xito.  No solo resolvi√≥ el problema de compatibilidad, sino que tambi√©n caus√≥ un gran aumento en el inter√©s en la programaci√≥n competitiva en la comunidad.  Nuevos art√≠culos y bibliotecas comenzaron a aparecer, como hongos despu√©s de la lluvia.  Adem√°s, el asincio influy√≥ en el lenguaje en s√≠: se le agregaron corutinas nativas y nuevas palabras clave <strong>as√≠ncronas</strong> / en <strong>espera</strong> .  La √∫ltima vez que se agreg√≥ una nueva palabra clave en 2003, fue la palabra clave de <strong>rendimiento</strong> . </p><br><p>  Uno de los objetivos de crear asyncio era proporcionar una integraci√≥n extremadamente simple en frameworks asincr√≥nicos ya existentes (Twisted, Tornado, Gevent).  La elecci√≥n de las herramientas se deriva l√≥gicamente de este objetivo: si no existiera un requisito de compatibilidad, probablemente se asignar√≠a a las corutinas el papel principal.  Debido al hecho de que al programar devoluciones de llamada es imposible mantener una pila continua de llamadas, se tuvo que crear un sistema adicional en el l√≠mite entre ellas y las rutinas para admitir las caracter√≠sticas del lenguaje basadas en √©l. </p><br><p>  Ahora la pregunta principal.  ¬øPor qu√© un simple usuario de la biblioteca deber√≠a saber todo esto, que sigue las recomendaciones de la documentaci√≥n y usa solo rutinas y una API de alto nivel? <br>  Aqu√≠ hay una parte de la documentaci√≥n de la clase StreamWriter </p><br><p><img src="https://habrastorage.org/webt/td/ou/jb/tdoujbeh0soadfwdveuowwbvvny.png"></p><br><p>  Su instancia es devuelta por la funci√≥n <strong>asyncio.open_connection</strong> y es la API <strong>async</strong> / <strong>await</strong> en la parte superior de la API de devoluci√≥n de llamada.  Y estas devoluciones de llamada sobresalen.  Las <strong>funciones de</strong> <strong>escritura</strong> y <strong>l√≠neas de</strong> <strong>escritura</strong> <strong>son</strong> s√≠ncronas, intentan escribir en el socket y, si eso falla, vuelcan los datos en el b√∫fer subyacente y agregan devoluciones de llamada al registro.  El <strong>drenaje de</strong> corutina <strong>es</strong> necesario para proporcionar la oportunidad de esperar hasta que la cantidad de datos en el b√∫fer caiga al valor especificado. </p><br><p>  Si olvida llamar al <strong>drenaje</strong> entre llamadas de <strong>escritura</strong> , entonces el b√∫fer interno puede crecer a tama√±os indecentes.  Sin embargo, si tiene esto en cuenta, quedan algunos momentos desagradables.  Primero: si la devoluci√≥n de llamada en el registro "se rompe", entonces la rutina que usa esta API no lo sabr√° de ninguna manera y, en consecuencia, no podr√° procesarla.  Segundo: si la rutina se "rompe", la devoluci√≥n de llamada al registro no lo sabr√° de ninguna manera y continuar√° escribiendo datos desde el b√∫fer. </p><br><p>  Por lo tanto, incluso utilizando solo corutinas, prep√°rese para el hecho de que las devoluciones de llamada se recordar√°n a s√≠ mismas. </p><br><p>  Puede leer sobre c√≥mo trabajar con bases de datos a partir de c√≥digo as√≠ncrono en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo de</a> nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog corporativo Antida software</a> . </p><br><p>  PD: Gracias por la informaci√≥n sobre errores tipogr√°ficos e inexactitudes a los usuarios de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">eirnym</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">kurb</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">rasswet</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453348/">https://habr.com/ru/post/453348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453336/index.html">Gu√≠a de selecci√≥n de m√°quinas de quemado CNC</a></li>
<li><a href="../453338/index.html">Lanzamiento de Rust 1.35.0: implementaciones de rasgos funcionales y otras innovaciones</a></li>
<li><a href="../453340/index.html">Perl 5.30 lanzado</a></li>
<li><a href="../453342/index.html">Mitos sobre empleados remotos que nos destruimos</a></li>
<li><a href="../453346/index.html">Tecnolog√≠as de almacenamiento y protecci√≥n de datos: el tercer d√≠a en VMware EMPOWER 2019</a></li>
<li><a href="../453350/index.html">Transmisi√≥n abierta de la sala principal de RIT ++ 2019</a></li>
<li><a href="../453352/index.html">C√≥mo los drones entregan medicamentos vitales en Ghana</a></li>
<li><a href="../453354/index.html">Clasificaci√≥n de la cobertura del suelo utilizando eo-learn. Parte 3</a></li>
<li><a href="../453356/index.html">Tendencias actuales y recomendaciones sobre aglomeraci√≥n de grandes instituciones financieras</a></li>
<li><a href="../453360/index.html">Ciudad sin atascos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>