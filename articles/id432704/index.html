<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè´ üë®üèø‚Äçüéì üßñüèª Menggunakan Termometer Nirkabel Buro H999 Eksternal dengan Perangkat Buatan Rumah üë®‚Äç‚öïÔ∏è üë®üèΩ‚Äç‚öïÔ∏è üïµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua orang jago di stasiun cuaca Buro H146G dengan termometer nirkabel eksternal H999. Tetapi hanya untuk melihat pembacaan pada LCD pudarnya membutu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan Termometer Nirkabel Buro H999 Eksternal dengan Perangkat Buatan Rumah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432704/"> Semua orang jago di stasiun cuaca Buro H146G dengan termometer nirkabel eksternal H999.  Tetapi hanya untuk melihat pembacaan pada LCD pudarnya membutuhkan pencahayaan yang baik.  Dan akan lebih baik bagi saya jika suhu dan kelembaban output di luar jendela ditampilkan pada indikator yang cukup cerah (misalnya, menggabungkan tampilan suhu dan kelembaban dengan jam pada indikator debit gas IN-12).  Tidak sulit untuk membuat kerajinan seperti itu, tetapi Anda harus mengetahui protokol pertukaran dengan termometer nirkabel.  Sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada artikel</a> tentang penggunaan termometer stasiun cuaca nirkabel untuk mendapatkan suhu dan kelembaban di udara.  Tetapi untuk stasiun Buro, protokol pertukaran belum dijelaskan.  Jadi, kita perlu memperbaikinya: mungkin seseorang bisa berguna. <br><a name="habracut"></a><br>  Di Internet, saya tidak menemukan deskripsi protokol untuk bertukar stasiun BURO.  Dan ini berarti Anda harus membuka protokol pertukaran sensor nirkabel ini. <br><br>  Termometer eksternal saya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/o3/y4/ex/o3y4exet3g-ru6d1bdhpwrqiakm.jpeg"><br><br>  Dengan menghubungkan receiver 433,92 MHz super-regeneratif Tiongkok ke osiloskop dan menekan tombol TEST pada termometer, terlihat jelas bagaimana pulsa transmisi bekerja.  Nah, karena frekuensinya kecil, output penerima terhubung ke input kartu suara melalui pembagi resistif.  Setelah memproses file suara yang direkam, pembanding menghasilkan gambar berikut: <br><br><img src="https://habrastorage.org/webt/kp/gh/sv/kpghsvyozbxt9dtkqfk4ap-f9hw.gif"><br><br>  Seperti stasiun cuaca lainnya, modulasi dilakukan dengan mengubah siklus tugas.  Transmisi dimulai dari blok jam, kemudian ada sinyal jam lain, dan kemudian ada data, setelah itu sinyal jam terakhir berjalan.  Dua nol setelah sinyal jam, tampaknya, adalah pengidentifikasi awal data - dalam hal apa pun, saya tidak pernah memperhatikan perubahannya.  Data dengan jam mulai dan berakhir digandakan enam kali.  Pertukaran data dilakukan oleh camilan. <br><br>  Untuk decoding, saya memutuskan untuk mulai menerima pada jam pertama dan dua nol, dan selesai pada jam terakhir. <br><br>  Untuk memecahkan kode sinyal seperti itu, cukup untuk menghitung durasi antara penurunan sinyal. <br><br>  Untuk ini, saya menulis program pengujian sederhana untuk pengontrol Atmega8: <br><br><div class="spoiler">  <b class="spoiler_title">Program untuk Atmega8</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- #include &lt;avr/io.h&gt; #include &lt;util/delay.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;avr/pgmspace.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdint.h&gt; //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- #define F_CPU 8000000UL //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //   UART, / #define UART_SPEED 9600UL //---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- //  enum BLOCK_TYPE { BLOCK_TYPE_UNKNOW,//  BLOCK_TYPE_DIVIDER,// BLOCK_TYPE_SYNCHRO,// BLOCK_TYPE_ONE,// BLOCK_TYPE_ZERO// }; //  enum MODE { MODE_WAIT_SYNCHRO,//  MODE_WAIT_ZERO_FIRST,//   MODE_WAIT_ZERO_SECOND,//   MODE_RECEIVE_DATA//  }; //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- static const uint16_t MAX_TIMER_INTERVAL_VALUE=0xFFFF;//    static volatile bool TimerOverflow=false;//    static uint8_t Buffer[20];//   static uint8_t BitSize=0;//   static uint8_t Byte=0;//  //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void InitAVR(void);//  void UART_Write(unsigned char byte);//   COM- void SendText(const char *text);//   COM- void RF_Init(void);// void RF_SetTimerOverflow(void);//    void RF_ResetTimerOverflow(void);//    bool RF_IsTimerOverflow(void);//,     uint16_t RF_GetTimerValue(void);//   void RF_ResetTimerValue(void);//   BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value);//   void RF_AddBit(bool state);//   void RF_ResetData(void);//    void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode);//  //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- int main(void) { InitAVR(); _delay_ms(200); SendText("Thermo unit\r\n"); _delay_ms(200); sei(); while(1); cli(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void InitAVR(void) { //  DDRB=0; DDRD=0; DDRC=0; //   PORTB=0; PORTD=0; PORTC=0; //    UART UCSRB=(1&lt;&lt;RXEN)|(1&lt;&lt;TXEN)|(0&lt;&lt;RXCIE); //RXCIE=1    ( I=1   SREG) :      UART  //TXCIE=1    ( I=1   SREG) :      UART  //UDRIE=1    ( I=1   SREG) :      UART  //RXEN=1 :  ,  D0   UART. //TXEN=1 :  ,  D1   UART. //CHR9=1 :       11  (9   + -  + -). //RXB8- - //TXB8- - //      unsigned long speed=F_CPU/(16UL); speed=(speed/UART_SPEED)-1UL; UBRRH=(speed&gt;&gt;8)&amp;0xff; UBRRL=speed&amp;0xFF; RF_Init(); } //---------------------------------------------------------------------------------------------------- //   COM- //---------------------------------------------------------------------------------------------------- void UART_Write(unsigned char byte) { while(!(UCSRA&amp;(1&lt;&lt;UDRE))); UDR=byte; } //---------------------------------------------------------------------------------------------------- //   COM- //---------------------------------------------------------------------------------------------------- void SendText(const char *text) { while((*text)) { UART_Write(*text); text++; } } //---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- void RF_Init(void) { //   ACSR=(0&lt;&lt;ACD)|(1&lt;&lt;ACBG)|(0&lt;&lt;ACO)|(0&lt;&lt;ACI)|(1&lt;&lt;ACIE)|(0&lt;&lt;ACIC)|(0&lt;&lt;ACIS1)|(0&lt;&lt;ACIS0); //ACD -   (0 - !) //ACBG -       ' //ACO -   ( ) //ACI -     //ACIE -     //ACIC -       T1 //ACIS1,ACID0 -      //  T1   31250  TCCR1A=(0&lt;&lt;WGM11)|(0&lt;&lt;WGM10)|(0&lt;&lt;COM1A1)|(0&lt;&lt;COM1A0)|(0&lt;&lt;COM1B1)|(0&lt;&lt;COM1B0); //COM1A1-COM1A0 -   OC1A //COM1B1-COM1B0 -   OC1B //WGM11-WGM10 -    TCCR1B=(0&lt;&lt;WGM13)|(0&lt;&lt;WGM12)|(1&lt;&lt;CS12)|(0&lt;&lt;CS11)|(0&lt;&lt;CS10)|(0&lt;&lt;ICES1)|(0&lt;&lt;ICNC1); //WGM13-WGM12 -    //CS12-CS10 -    (      256 (  31250 )) //ICNC1 -       //ICES1 -      TCNT1=0;//   TIMSK|=(1&lt;&lt;TOIE1);//    ( T1 ) } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_SetTimerOverflow(void) { cli(); TimerOverflow=true; sei(); } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_ResetTimerOverflow(void) { cli(); TimerOverflow=false; sei(); } //---------------------------------------------------------------------------------------------------- //,     //---------------------------------------------------------------------------------------------------- bool RF_IsTimerOverflow(void) { cli(); bool ret=TimerOverflow; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- uint16_t RF_GetTimerValue(void) { cli(); uint16_t ret=TCNT1; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- void RF_ResetTimerValue(void) { cli(); TCNT1=0; sei(); RF_ResetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value) { static const uint32_t DIVIDER_MIN=(31250UL*12)/44100UL; static const uint32_t DIVIDER_MAX=(31250UL*25)/44100UL; static const uint32_t ZERO_MIN=(31250UL*80)/44100UL; static const uint32_t ZERO_MAX=(31250UL*100)/44100UL; static const uint32_t ONE_MIN=(31250UL*160)/44100UL; static const uint32_t ONE_MAX=(31250UL*200)/44100UL; static const uint32_t SYNCHRO_MIN=(31250UL*320)/44100UL; static const uint32_t SYNCHRO_MAX=(31250UL*400)/44100UL; if (counter&gt;DIVIDER_MIN &amp;&amp; counter&lt;DIVIDER_MAX) return(BLOCK_TYPE_DIVIDER);// if (counter&gt;ZERO_MIN &amp;&amp; counter&lt;ZERO_MAX) return(BLOCK_TYPE_ZERO);// if (counter&gt;ONE_MIN &amp;&amp; counter&lt;ONE_MAX) return(BLOCK_TYPE_ONE);// if (counter&gt;SYNCHRO_MIN &amp;&amp; counter&lt;SYNCHRO_MAX) return(BLOCK_TYPE_SYNCHRO);// return(BLOCK_TYPE_UNKNOW);//  } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- void RF_AddBit(bool state) { if ((BitSize&gt;&gt;2)&gt;=19) return;//  Byte&lt;&lt;=1; if (state==true) Byte|=1; BitSize++; if ((BitSize&amp;0x03)==0) { Buffer[(BitSize&gt;&gt;2)-1]=Byte; Byte=0; } } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_ResetData(void) { BitSize=0; Byte=0; } //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode) { //   BLOCK_TYPE type=RF_GetBlockType(counter,value); if (type==BLOCK_TYPE_UNKNOW) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (type==BLOCK_TYPE_DIVIDER) return;//    //      if (mode==MODE_WAIT_SYNCHRO)//  { if (type==BLOCK_TYPE_SYNCHRO) { mode=MODE_WAIT_ZERO_FIRST; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (mode==MODE_WAIT_ZERO_FIRST || mode==MODE_WAIT_ZERO_SECOND)//   { if (type==BLOCK_TYPE_SYNCHRO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) return;//  if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) { mode=MODE_WAIT_ZERO_SECOND; return; } if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_SECOND) { mode=MODE_RECEIVE_DATA; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  if (type==BLOCK_TYPE_SYNCHRO)//  { uint8_t size=(BitSize&gt;&gt;2); char str[30]; if (size!=10) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  for(uint8_t n=0;n&lt;size;n++) { uint8_t b=Buffer[n]; uint8_t mask=(1&lt;&lt;3); for(uint8_t m=0;m&lt;4;m++,mask&gt;&gt;=1) { if (b&amp;mask) SendText("1"); else SendText("0"); } SendText(" "); } uint8_t channel=Buffer[2]&amp;0x03; uint8_t key=(Buffer[8]&gt;&gt;3)&amp;0x01; uint8_t h=(Buffer[7]&lt;&lt;4)|(Buffer[6]);// int16_t temp=(Buffer[5]&lt;&lt;8)|(Buffer[4]&lt;&lt;4)|(Buffer[3]);// int16_t k=18; int16_t t=(10*(temp-1220))/k; sprintf(str,"%i",key); SendText("Key:"); SendText(str); sprintf(str,"%i",channel+1); SendText(" Ch:"); SendText(str); sprintf(str,"%i",h); SendText(" H:"); SendText(str); SendText("%, T:"); if (t&lt;0) { t=-t; sprintf(str,"-%i.%i",(int)(t/10),(int)(t%10)); } else { sprintf(str,"%i.%i",(int)(t/10),(int)(t%10)); } SendText(str); SendText(" C\r\n"); mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  if (type==BLOCK_TYPE_ONE) { RF_AddBit(true); return; } if (type==BLOCK_TYPE_ZERO) { RF_AddBit(false); return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //   //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //    T1 (16-  )   //---------------------------------------------------------------------------------------------------- ISR(TIMER1_OVF_vect) { RF_SetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //     //---------------------------------------------------------------------------------------------------- ISR(ANA_COMP_vect) { ACSR&amp;=0xFF^(1&lt;&lt;ACIE);//  ACSR|=(1&lt;&lt;ACI);//    static MODE mode=MODE_WAIT_SYNCHRO; //   uint16_t length=RF_GetTimerValue(); if (RF_IsTimerOverflow()==true) length=MAX_TIMER_INTERVAL_VALUE;// ,    RF_ResetTimerValue(); //   bool value=true; if (ACSR&amp;(1&lt;&lt;ACO)) value=false; RF_AnalizeCounter(length,value,mode); ACSR|=(1&lt;&lt;ACIE);//  }</span></span></code> </pre> <br></div></div><br>  Output penerima terhubung ke pin 13 (AIN1).  Atmega terhubung melalui max232 ke port COM komputer (atau ke adaptor USB-COM).  Kecepatan port 9600 baud. <br><br>  Setelah decoding, kita mendapatkan aliran data berikut (saya membuang dua nol terkemuka): <br><br>  // tanpa tombol, saluran 1 <br>  1100 1100 0000 1110 1000 0110 1100 0001 0000 1001 Kelembaban: 28% Suhu: 25,4 <br>  // tidak ada tombol, saluran 2 <br>  1100 1100 0001 1110 1000 0110 1101 0001 0000 0110 Kelembaban: 29% Suhu: 25,4 <br><br>  Total paket terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/dq/mj/iu/dqmjiuixxbenuwzxubzgfftypow.png"><br><br>  I0-I7 - pengidentifikasi termometer.  Setiap kali termometer dihidupkan, pengenal berubah. <br><br>  C0-C1 - saluran (ada 3 kemungkinan total).  Saluran diberi nomor dari awal. <br><br>  H0-H7 - kelembaban.  Kelembaban sebagai persentase dibaca apa adanya, tetapi suhu (T0-T11) karena alasan tertentu diatur dalam format yang tidak biasa untuk stasiun cuaca.  Dilihat oleh deskripsi protokol pertukaran berbagai stasiun cuaca yang saya temukan, orang akan mengharapkan suhu dalam sepersepuluh derajat dan dengan pergeseran batas bawah termometer.  Jadi tidak.  Percobaan menunjukkan bahwa kode suhu stasiun cuaca ini diterjemahkan ke derajat Celcius sebagai (T-1220) / 18.  Bagaimana angka ajaib ini hanya tahu orang Cina yang datang dengan protokol pertukaran ini. <br><br>  Seperti yang disarankan oleh wolowizard dalam komentar, stasiun mentransfer suhu dalam sepersepuluh derajat Fahrenheit, sehingga terjemahan yang bermakna dalam derajat Celcius akan menjadi 0,1 * (T-320) * 5 / 9-500 = 0,1 * (T-1220) /1,8. <br><br>  Bit K berhubungan dengan menekan tombol TEST. <br><br>  Penugasan bidang yang tersisa tidak dapat ditetapkan, tetapi ternyata nilai sakelar Fahrenheit / Celsius pada termometer tidak masuk ke protokol pertukaran.  Agaknya gigitan terakhir (atau mungkin bagian dari yang kedua dari belakang) juga CRC, tapi saya belum dapat menghitung algoritme (ada kecurigaan bahwa baris dan kolom yang menggigit terlibat dalam perhitungan).  Jika ada yang bisa memecahkan teka-teki ini, beri tahu kami algoritma penghitungan. <br>  Bagi mereka yang ingin memeras otak mereka, tetapi tidak memiliki termometer seperti itu, saya memberikan tabel data yang diterima. <br><br><div class="spoiler">  <b class="spoiler_title">Meja</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1001 0110 0101 1011 1000 0110 1000 0010 0001 1111 Key:0 Ch:2 H:40%, T:25.2 C 1001 1001 0000 1101 1010 0100 0101 0101 0000 0110 Key:0 Ch:1 H:85%, T:-1.2 C 1001 0110 0101 1100 1000 0110 1010 0010 0001 0100 Key:0 Ch:2 H:42%, T:25.3 C 1001 0110 1001 0110 0111 0110 1101 0001 0010 1111 Key:0 Ch:2 H:29%, T:24.1 C 1001 0110 1001 0000 0111 0110 1101 0001 0010 1000 Key:0 Ch:2 H:29%, T:23.7 C 1001 0110 1001 0010 0101 0110 1110 0001 0010 1111 Key:0 Ch:2 H:30%, T:22.1 C 1001 0110 1001 1001 0011 0110 1110 0001 0010 1100 Key:0 Ch:2 H:30%, T:20.7 C 1001 0110 1001 1111 0001 0110 1111 0001 0010 1010 Key:0 Ch:2 H:31%, T:19.2 C 1001 0110 0101 1001 0000 0110 0001 0010 0010 1000 Key:0 Ch:2 H:33%, T:18.0 C 1001 0110 0101 0010 1111 0101 0010 0010 0010 0111 Key:0 Ch:2 H:34%, T:16.7 C 1001 0110 0101 0100 1110 0101 0010 0010 0010 0010 Key:0 Ch:2 H:34%, T:16.0 C 1001 0110 0101 0100 1101 0101 0011 0010 0010 0001 Key:0 Ch:2 H:35%, T:15.1 C 1001 0110 0101 1100 1100 0101 0100 0010 0010 1110 Key:0 Ch:2 H:36%, T:14.6 C 1001 0110 0101 1111 1011 0101 0101 0010 0010 1111 Key:0 Ch:2 H:37%, T:13.9 C 1001 0110 0101 0011 1011 0101 0101 0010 0010 0001 Key:0 Ch:2 H:37%, T:13.2 C 1001 0110 0101 1001 1010 0101 0110 0010 0010 0101 Key:0 Ch:2 H:38%, T:12.7 C 1001 0110 0101 0100 1010 0101 0111 0010 0010 1000 Key:0 Ch:2 H:39%, T:12.4 C 1001 0110 0101 1011 1001 0101 0111 0010 0010 1010 Key:0 Ch:2 H:39%, T:11.9 C 1001 0110 0101 0011 1001 0101 1000 0010 0010 1001 Key:0 Ch:2 H:40%, T:11.5 C 1001 0110 0101 1011 1000 0101 1000 0010 0010 1110 Key:0 Ch:2 H:40%, T:11.0 C 1001 0110 0101 0111 1000 0101 1001 0010 0010 0101 Key:0 Ch:2 H:41%, T:10.8 C 1001 0110 0101 1111 0111 0101 1001 0010 0010 1101 Key:0 Ch:2 H:41%, T:10.3 C 1001 0110 0101 0111 0111 0101 1010 0010 0010 0111 Key:0 Ch:2 H:42%, T:9.9 C 1001 0110 0101 0001 0111 0101 1011 0010 0010 0101 Key:0 Ch:2 H:43%, T:9.6 C 1001 0110 0101 1011 0110 0101 1100 0010 0010 0110 Key:0 Ch:2 H:44%, T:9.2 C 1001 0110 0101 1000 0110 0101 1100 0010 0010 1100 Key:0 Ch:2 H:44%, T:9.1 C 1001 0110 0101 0011 0110 0101 1101 0010 0010 0110 Key:0 Ch:2 H:45%, T:8.8 C 1001 0110 0101 1001 0101 0101 1110 0010 0010 0110 Key:0 Ch:2 H:46%, T:8.2 C 1001 0110 0101 0101 0101 0101 1111 0010 0010 1101 Key:0 Ch:2 H:47%, T:8.0 C 1001 0110 0101 0010 0101 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.8 C 1001 0110 0101 1110 0100 0101 1111 0010 0010 0000 Key:0 Ch:2 H:47%, T:7.6 C 1001 0110 0101 1100 0100 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.5 C</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432704/">https://habr.com/ru/post/id432704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432692/index.html">Meluncurkan proyek pembersihan lautan terbesar</a></li>
<li><a href="../id432696/index.html">nomoregoogle.com - kompilasi baru alternatif untuk layanan raksasa teknologi</a></li>
<li><a href="../id432698/index.html">Timlids yang fantastis dan di mana mereka tinggal</a></li>
<li><a href="../id432700/index.html">Ayo! @ # Dengan "racun" Anda</a></li>
<li><a href="../id432702/index.html">Konten 2018: lihat lebih luas, gali lebih dalam</a></li>
<li><a href="../id432706/index.html">Tim Satu-ke-Banyak pada Keberhasilan Pelanggan: Mengapa Anda Membutuhkannya?</a></li>
<li><a href="../id432708/index.html">Cascading SFUs: Meningkatkan skalabilitas dan kualitas media dalam aplikasi WebRTC</a></li>
<li><a href="../id432710/index.html">Panggilan spam. Apakah mungkin untuk melawan mereka?</a></li>
<li><a href="../id432712/index.html">Agile bukan proses pengembangan, tetapi pendekatan untuk menciptakan produk</a></li>
<li><a href="../id432714/index.html">Minggu Keamanan 50: Prediksi 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>