<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏻 👏🏿 📺 Histoire de Vim et un guide pour son utilisation efficace ✨ 🥗 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note du traducteur: il s'agit de la première partie de l'article monumental (en fait monumental) sur Vim et ses capacités du développeur de Minneapoli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Histoire de Vim et un guide pour son utilisation efficace</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/477768/">  <i>Note du traducteur: il s'agit de la première partie de l'article monumental (en fait monumental) sur Vim et ses capacités du développeur de Minneapolis et de l'auteur du projet <a href="http://postgrest.org/en/v6.0/">PostgREST,</a> Joe <a href="https://github.com/begriffs">begriffs</a> Nelson.</i> <i><br><br></i>  <i>La première partie de l'article est consacrée à se familiariser avec l'histoire de Vim en tant qu'éditeur, et l'auteur parle d'un certain nombre de faits intéressants sur les capacités de Vim.</i>  <i>Dans la deuxième partie de la traduction, tous les jetons et hacks de vie que Joe a décidé de partager avec le public seront concentrés, là le récit, en tant que tel, s'estompe et il ne reste qu'un ensemble de lignes directrices pour l'action.</i>  <i>Comme le texte original a des dimensions totalement inacceptables, nous avons divisé cette histoire en deux articles de taille approximativement égale.</i>  <i>Aujourd'hui est la première de deux publications.</i>  <i>Bonne lecture.</i> <br><br><hr><br>  Cet article est basé sur des recherches sur l'histoire de Vim et sur la lecture de son guide d'utilisation.  J'espère que ces notes vous aideront à découvrir (ou à redécouvrir?) Les fonctionnalités de base de cet éditeur, ainsi qu'à vous permettre d'abandonner l'utilisation des fichiers vimrc avertis et d'utiliser les plugins de manière plus réfléchie. <br><br><img src="https://habrastorage.org/webt/hn/0g/5q/hn0g5qskcbqwtg_kauayaurqcak.png"><br><br><h3>  Les références </h3><br>  Pour aller au-delà des sujets habituels, je recommanderais d'obtenir une copie papier de ce manuel et une référence de poche volumineuse.  Je n'ai pas pu trouver une copie imprimée du guide de l'utilisateur de Vim, donc à la fin je viens d'imprimer le <a href="https://begriffs.com/pdf/vim-user-manual.pdf">fichier PDF</a> fourni avec l'éditeur en utilisant printme1.com.  <code>$VIMRUNTIME/doc/usr_??</code> il avec un logiciel dans <code>$VIMRUNTIME/doc/usr_??</code>  .  En tant que liste pratique de commandes, je peux vous conseiller le livre de référence <a href="https://www.goodreads.com/book/show/9787030-vi-and-vim-editors-pocket-reference">«Vi and Vim Editors Pocket»</a> . <br><br>  <b>Table des matières</b> <br><br><ul><li>  L'histoire </li><li>  Hiérarchie de configuration </li><li>  Plugins tiers </li><li>  Sauvegardes et ristournes </li><li>  Inclure et chemin </li><li>  Édition et compilation d'une boucle </li><li>  Diffs et patchs </li><li>  Tampon d'entrée / sortie </li><li>  Types de fichiers </li><li>  N'oubliez pas la souris </li><li>  Divers </li></ul><br><h2>  L'histoire </h2><br><h3>  Naissance vi </h3><br>  Les commandes et fonctions Vi existent depuis plus de cinquante ans, à commencer par l'éditeur QED.  Voici sa chronologie: <br><a name="habracut"></a><br><ul><li>  1966: QED (Quick Editor) au Berkeley Timesharing System </li><li>  Juillet 1969: avec son aide, ils ont atterri sur la lune (enfin, pour référence) </li><li>  Août 1969: QED → ed at AT&amp;T </li><li>  1976 fév: ed → em («Editor for Mortals») au Queen Mary's College </li><li>  1976: em → ex ("EXtended") à l'Université de Californie, Berkeley </li><li>  1977 Oct: ex reçoit le mode visuel, vi - terminal texte </li></ul><br>  Si vous lisez le manuel <a href="https://begriffs.com/pdf/qed-editor.pdf">QED</a> et <a href="https://begriffs.com/pdf/ex-manual.pdf">ex</a> , vous pouvez trouver des similitudes entre eux.  Les deux éditeurs utilisent une grammaire similaire pour indiquer et travailler avec des plages de lignes. <br><br>  Des éditeurs tels que QED ed et em ont été conçus pour les terminaux d'impression, qui étaient pour la plupart des machines à écrire électriques ordinaires avec un modem connecté.  De tels terminaux "à copieur complet" affichaient des commandes sur papier et, évidemment, une fois entrés, il était impossible de faire des corrections.  Par conséquent, le processus d'édition consistait à éditer manuellement les commandes utilisateur sur papier, puis à les saisir à nouveau. <br><br>  En 1976, des terminaux vidéo, par exemple ADM-3A, sont apparus.  Un «mode ouvert» a été ajouté à l'éditeur Ex, ce qui a permis d'éditer via un terminal vidéo sur une seule page.  Un mode visuel a été ajouté pour s'orienter sur les lignes du terminal à l'aide du curseur.  Le mode visuel a été activé par la commande «vi» et a constamment mis à jour le fichier affiché à l'écran, tout en conservant le positionnement de la ligne de commande en bas de l'écran.  Fait intéressant: des flèches ont été placées sur les touches h, j, k, l de l'ADM-3A, ce qui nous a permis de déplacer le curseur sur vi. <br><br>  Vous pouvez en savoir plus sur cette transition de ed à ex / vi dans <a href="https://begriffs.com/pdf/unix-review-bill-joy.pdf">une interview avec Bill Joy</a> .  Dans ce document, il parle de la façon dont il a créé ex / vi et de certaines choses qui l'ont finalement déçu. <br><br>  Classic vi est juste un alter est ex.  Les deux sont représentés par le même fichier binaire, qui peut être exécuté à la fois en ex-mode et en vi-mode, selon le nom du fichier exécutable.  L'héritage de toute cette histoire est que ex / vi «se déplie» lorsqu'il est utilisé, ne nécessite presque pas de ressources système et peut fonctionner dans des conditions de bande passante limitée.  Il est également disponible sur la plupart des systèmes existants et est <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/vi.html">entièrement décrit</a> dans POSIX. <br><br><h3>  Vi à vim </h3><br>  Dérivé d'ed, l'éditeur ex / vi était la propriété intellectuelle d'AT &amp; T.  Pour utiliser vi sur des plateformes autres qu'Unix, les gens devaient écrire des clones qui avaient une base de code source différente. <br><br>  En voici quelques uns: <br><br><ul><li>  nvi - 1980 pour 4BSD </li><li>  calvin - 1987 pour DOS </li><li>  vil - 1990 pour DOS </li><li>  stevie - 1987 pour Atari ST </li><li>  elvis - 1990 pour Minix et 386BSD </li><li>  vim - 1991 pour Amiga </li><li>  viper - 1995 pour Emacs </li><li>  elwin - 1995 pour Windows </li><li>  lemmy - 2002 pour Windows </li></ul><br>  Nous allons nous concentrer sur le clone du centre de la liste - Vim.  Bram Mulenaar voulait utiliser vi sur Amiga et a commencé à porter avec Atari et à développer le clone vi stevie.  Et il a nommé sa version du port «Vi Imitation».  Si vous voulez en savoir plus sur ce processus, regardez son interview pour Free Software Magazine. <br><br>  Dans la version 1.22, Vim a été renommé «Vi IMproved», ce qui indique la supériorité de la copie sur l'original.  Voici un graphique des principales versions suivantes avec des descriptions de certaines fonctionnalités: <br><br><img src="https://habrastorage.org/webt/n-/gw/lu/n-gwlulgvi4i6rrmjqfzvmvpwbi.png"><br><br>  Pour plus d'informations sur chaque version, l'aide doit être utilisée, par exemple, pour vim8.  Pour voir les mises à jour prévues, ainsi qu'une liste des erreurs connues, vous devez vous tourner vers todo.txt. <br><br>  Par exemple, la huitième version incluait une prise en charge des travaux asynchrones en raison de la pression sur le projet de NeoVim.  Les développeurs de ce dernier <a href="https://groups.google.com/forum/">souhaitaient</a> lancer le débogage et REPL pour les scripts Web directement dans l'éditeur. <br><br>  Généralement, Vim est superportable.  Adaptant toute l'histoire de son existence pour travailler sur des plateformes complètement différentes, cet éditeur a été contraint de rester dans le cadre de la culture «facile» du codage.  Vim fonctionne sur OS / 390, Amiga, BeOS et BeBox, Macintosh Classic, Atari MiNT, MS-DOS, OS / 2, QNX, RISC-OS, BSD, Linux, OS X, VMS et MS-Windows.  Vous pouvez compter sur Vim n'importe où et ne vous souciez pas de l'équipement que vous utilisez. <br><br>  À la fin du chemin vi original, en 2002, le code source ex / vi était toujours publié sous la licence de logiciel libre BSD.  Les sorciers sont disponibles sur <a href="http://ex-vi.sourceforge.net/">ex-vi.sourceforge.net</a> . <br><br>  Mais passons aux choses sérieuses.  Avant de commencer à analyser Vim, il est utile de savoir comment il organise et lit ses fichiers de configuration. <br><br><h2>  Hiérarchie de configuration </h2><br>  Auparavant, je croyais à tort que Vim obtient tous ses paramètres et scripts uniquement à partir du fichier .vimrc.  La visualisation de référentiels de «fichiers dot» aléatoires ne peut que renforcer cette opinion.  Très souvent, les gens téléchargent des fichiers .vimrc monstrueux par essence, dont la tâche est de contrôler tous les aspects de l'éditeur.  Ces énormes configurations sont aussi parfois appelées «distributions vim». <br><br>  En fait, Vim a une structure soignée dans laquelle .vimrc n'est qu'un des nombreux «points d'entrée».  En fait, vous pouvez vous-même demander à Vim quels scripts il charge.  Pour ce faire, modifiez du code source pour un projet aléatoire sur votre machine, téléchargez-le puis exécutez la commande <br><br><pre> <code class="xml hljs">:scriptnames</code> </pre> <br>  Cette liste mérite d'être lue.  Essayez de deviner ce que font ces scripts et notez les répertoires dans lesquels ils se trouvent. <br><br>  La liste était plus longue que prévu?  Si vous avez installé de nombreux plugins, l'éditeur a beaucoup à faire.  Vérifiez qu'il ralentit au démarrage en exécutant la commande de création start.log suivante: <br><br><pre> <code class="xml hljs">vim --startuptime start.log name-of-your-file</code> </pre> <br>  Comparez simplement la vitesse de démarrage de Vim: <br><br><pre> <code class="xml hljs">vim --clean --startuptime clean.log name-of-your-file</code> </pre> <br>  Pour déterminer quels scripts doivent être chargés au démarrage ou pendant le chargement de la mémoire tampon, vous devez vérifier le chemin d'exécution Vim.  Ce chemin est représenté par une liste de répertoires séparés par des virgules, chacun contenant une structure commune.  Vim vérifie ces structures dans chaque répertoire pour trouver ses scripts de démarrage.  Les répertoires sont traités strictement dans l'ordre dans lequel ils se trouvent dans la liste. <br><br>  Vérifiez le chemin d'exécution sur votre système via cette commande: <br><br><pre> <code class="xml hljs">:set runtimepath</code> </pre> <br>  Mon système contient les répertoires suivants spécifiés par défaut pour la vérification runtimepath.  Ils n'existent pas tous, mais Vim essaiera toujours d'y accéder et vérifiera le contenu s'ils sont toujours en place: <br><br> <code>~/.vim</code> <br>  Répertoire personnel, conçu pour les profils créés. <br><br> <code>/usr/local/share/vim/vimfiles</code> <br>  Répertoire Vim à l'échelle du système, pour les profils avec des privilèges d'administrateur système. <br><br> <code>/usr/local/share/vim/vim81</code> <br>  Aka $ VIMRUNTIME, pour les fichiers distribués avec Vim. <br><br> <code>/usr/local/share/vim/vimfiles/after</code> <br>  Dans le répertoire Vim à l'échelle du système, il y a aussi le répertoire after.  Il est destiné à ajouter les paramètres personnels de l'administrateur système «par défaut». <br><br> <code>~/.vim/after</code> <br>  Le répertoire «après» du répertoire personnel.  Ceci est nécessaire pour que les configurations personnelles n'annulent pas ou ne chevauchent pas les paramètres à l'échelle du système ou «par défaut». <br><br>  En général, les répertoires sont traités dans le même ordre dans lequel ils sont écrits dans start.log, une exception n'est faite que pour «après».  Celui-ci est toujours en fin de liste et est traité en dernier. <br><br>  Lors du traitement de chaque répertoire, Vim y recherche des sous-dossiers avec des noms spécifiques.  Pour en savoir plus à ce sujet, consultez l'aide runtimepath.  Voici une brève description de ceux que nous examinerons plus loin dans le texte: <br><br> <code>plugin /</code> <br>  Ici se trouvent les fichiers de script Vim qui sont automatiquement chargés lors de la modification de tout type de fichier.  Ils sont également appelés «mondiaux». <br><br> <code>autoload /</code> <br>  (A ne pas confondre avec "plugin").  Ces scripts de démarrage contiennent des fonctions qui ne sont resserrées qu'à la demande d'autres scripts. <br><br> <code>ftdetect /</code> <br>  Scripts pour déterminer les types de fichiers.  Dans leur travail, ils s'appuient sur l'extension, l'emplacement ou le contenu interne du fichier. <br><br> <code>ftplugin /</code> <br>  Scripts exécutés lors de la modification de fichiers d'un type connu. <br><br> <code>compiler /</code> <br>  Détermine comment exécuter divers compilateurs ou vérifications de peluches et comment analyser leur sortie.  Il peut être divisé entre plusieurs plugins ft en même temps.  Le compilateur n'est pas exécuté automatiquement et doit être appelé par une commande. <br><br> <code>pack /</code> <br>  Un conteneur pour les packages natifs Vim 8, le successeur de la gestion des packages de type Pathogen.  Il a son propre système d'emballage, ne nécessite pas de code tiers pour fonctionner. <br><br>  Et enfin, <code>~ / .vimrc</code> est un piège pour les paramètres généraux de l'éditeur.  Utilisé pour configurer les paramètres par défaut, qui peuvent être attribués à un type de fichier spécifique.  Pour afficher la liste entière, vous pouvez sélectionner .vimrc et exécuter la commande d'options. <br><br><h2>  Plugins tiers </h2><br>  Les plugins ne sont que des scripts Vim, pour lesquels il suffit de les placer aux bons endroits dans le runtimepath.  En général, le processus d'installation est extrêmement simple: il suffit de télécharger le (s) fichier (s).  Le problème est que certains plugins sont assez difficiles à mettre à jour ou à supprimer, car ils sont dispersés dans différents sous-répertoires et obstruent les chemins d'exécution avec leurs scripts.  Autrement dit, à la fin, il est difficile de déterminer quel fichier appartient à quel plugin. <br><br>  Pour résoudre ce problème, les «gestionnaires de plugins» ont commencé à se développer.  Sur vim.org, il y avait un registre de plugins au moins jusqu'en 2003 inclus (si l'archive ne ment pas).  Cependant, les «gestionnaires de plugins» en tant qu'entités ne sont entrés dans la mode qu'en 2008. <br><br>  Ces outils ajoutent des répertoires spéciaux pour les plugins pour suivre les chemins d'exécution et organiser les balises par lesquelles les plugins peuvent être suivis.  La plupart des gestionnaires récupèrent également les mises à jour des plugins depuis le réseau. <br><br>  Ci-dessous, j'ai construit des gestionnaires de plugins en fonction de la chronologie de leur occurrence.  Basé sur les plages de dates de sortie de la première et de la dernière version.  S'il n'y avait pas de versions officielles, j'ai pris comme base les premières dates de sortie et la dernière mise à jour. <br><br><ul><li>  Mars 2006 - Juil 2014: Vimball </li><li>  Oct 2008 - Dec 2015: Pathogène </li><li>  Août 2009 - déc 2009: Vimana </li><li>  Déc 2009 - déc 2014: VAM </li><li>  Août 2010 - Nov 2010: Jolt </li><li>  Oct 2010 - Nov 2012: tplugin </li><li>  Octobre 2010 - février 2014: Vundle </li><li>  Mar 2012 - Mar 2018: vim-flavour </li><li>  Avril 2012 - mars 2016: NeoBundle </li><li>  Janvier 2013 - août 2017: infect </li><li>  Fév 2013 - août 2016: vimogen </li><li>  Oct 2013 - Jan 2015: dégroupage vim </li><li>  Déc 2013 - juil 2015: Vizardry </li><li>  Fév 2014 - Oct 2018: vim-plug </li><li>  Jan 2015 - Oct 2015: facilitateur </li><li>  Août 2015 - avril 2016: Vizardry 2 </li><li>  Janvier 2016 - juin 2018: dein.vim </li><li>  Sept 2016 - Présent: originaire de Vim 8 </li><li>  Fév 2017 - Sept 2018: minpac </li><li>  Mars 2018 - mars 2018: autopac </li><li>  Février 2017 - juin 2018: pack </li><li>  Mars 2017 - sept. 2017: vim-pck </li><li>  Sept 2017 - Sept 2017: pack vim8 </li><li>  Sept 2017 - Mai 2019: volt </li><li>  Sep 2018 - Feb 2019: vim-packager </li><li>  Fév 2019 - Fév 2019: plugpac.vim </li></ul><br>  La première chose à laquelle vous devez prêter attention dans la liste ci-dessus est la grande variété.  La seconde - chacun des outils présentés «vit» depuis environ quatre ans, puis, très probablement, se démode. <br><br>  Le chemin de moindre résistance dans la gestion des plugins est simplement d'utiliser la fonctionnalité intégrée de Vim 8, qui ne nécessite pas de récupérer un code tiers.  Voyons comment procéder. <br><br>  Pour commencer, créez deux répertoires dans votre runtimepath: opt et start. <br><br><pre> <code class="xml hljs">mkdir -p ~/.vim/pack/foobar/{opt,start}</code> </pre> <br>  Faites attention à l'espace réservé «foobar» (le nom peut être changé).  Il classe entièrement tous les packages qui entrent.  La plupart des utilisateurs transfèrent simplement tous leurs plugins dans une seule catégorie et, en général, c'est normal.  Choisissez n'importe quel nom que vous aimez;  Je continuerai à utiliser foobar.  En théorie, vous pouvez également créer plusieurs catégories, par exemple <code>~/.vim/pack/navigation</code> et <code>~/.vim/pack/linting</code> .  Veuillez noter que Vim ne reconnaît pas la duplication entre les catégories et télécharge les doublons deux fois s'ils existent. <br><br>  Les packages dans "start" sont chargés automatiquement, tandis que les packages dans "opt" ne sont pas chargés tant qu'ils ne proviennent pas de Vim en utilisant la commande <code>:packadd</code> .  Cette option est bonne pour les packages rarement utilisés et est prise en charge par Vim prête à l'emploi, sans avoir à exécuter de scripts.  Notez que <code>:packadd</code> pas d'équivalent pour décharger les paquets. <br><br>  Pour revoir cet exemple, nous ajouterons le plugin de recherche floue ctrlp à opt.  Téléchargez et décompressez sa dernière version sur: <br><br><pre> <code class="xml hljs">curl -L https://github.com/kien/ctrlp.vim/archive/1.79.tar.gz \ | tar zx -C ~/.vim/pack/foobar/opt</code> </pre> <br>  Cette commande créera le <code>~ / .vim / pack / foobar / opt / ctrlp.vim-1.79</code> package prêt à l'emploi.  Revenez à vim et créez les pointeurs de balises d'aide (index helptags) pour le nouveau package: <br><br><pre> <code class="xml hljs">:helptags ~/.vim/pack/foobar/opt/ctrlp.vim-1.79/doc</code> </pre> <br>  Cette commande créera un fichier appelé «balises» dans le dossier avec les tris de packages, qui rendra les thèmes disponibles pour la visualisation dans le système interne de Vim.  Autre moyen: exécutez helptags ALL après avoir téléchargé le package, et la commande prendra en charge tous les fichiers et leurs chemins d'exécution. <br>  Lorsque vous souhaitez utiliser un package, téléchargez-le simplement et n'oubliez pas que dans ce cas, la résiliation fonctionne à l'aide d'onglets, vous n'avez donc pas besoin d'entrer le nom complet: <br><br><pre> <code class="xml hljs">:packadd ctrlp.vim-1.79</code> </pre> <br>  Le répertoire de base de Packadd se trouve dans le runtimepath, ce qui lui permet d'utiliser les scripts de son plugin et ftdetect.  Après avoir chargé ctrlp, vous pouvez utiliser la commande CTRL-P pour ouvrir la recherche de fichiers par correspondance partielle. <br><br>  Certaines personnes gardent une trace de leur répertoire ~ / .vim et utilisent git pour contrôler la version de chaque paquet.  Pour ma part, je viens de décompresser les packages des archives tar et de les suivre manuellement via le référentiel.  Si vous utilisez des packages suffisamment matures qui ne nécessitent pas de mises à jour fréquentes, ainsi que des scripts, ils sont assez petits et n'encombrent pas l'historique git. <br><br><h2>  Sauvegardes et restaurations de versions </h2><br>  En fonction de vos préférences utilisateur, Vim peut vous protéger contre quatre causes possibles de perte de données: <br><br><ol><li>  Crash lors de l'édition (entre les sauvegardes).  Vim peut se protéger contre cela en enregistrant périodiquement les modifications apportées au fichier d'échange. </li><li>  Protection contre la modification du même fichier avec deux instances Vim, protection contre l'écrasement des modifications apportées via une ou plusieurs instances.  Cela se fait également via le fichier d'échange. </li><li>  Échec lors du processus d'enregistrement lui-même après la modification du fichier final, mais jusqu'à ce que le nouveau contenu soit complètement écrit.  Vim peut vous en protéger grâce à la fonction d'écriture différée.  Pour ce faire, il crée en cours de sauvegarde un nouveau fichier, qui remplace ensuite l'original, si tout s'est bien passé.  La méthode de remplacement est déterminée par le paramètre de copie de sauvegarde. </li><li>  Sauvegarde du nouveau contenu du fichier à condition que l'original soit restauré.  Vim vous permet d'enregistrer une copie de sauvegarde d'un fichier après avoir apporté des modifications. </li></ol><br>  Mais avant de commencer à explorer ces paramètres intelligents, que diriez-vous de quelques blagues?  Voici quelques exemples de commentaires provenant de fichiers vimrc sur GitHub: <br><br>  «Ne créez pas de fichier d'échange.  Gérez tout grâce au contrôle de version. » <br>  «Sauvegardes pour les exilés.  Utilisez le contrôle de version. " <br>  "Seul contrôle de version!"  Seulement hardcore! ” <br>  "Nous vivons dans un monde de contrôle de version, donc les échanges et les sauvegardes sont à la poubelle." <br>  "Pourquoi avez-vous besoin de fichiers de sauvegarde si le contrôle de version est suffisant." <br>  "Je n'ai jamais utilisé de fichiers de sauvegarde Vim ... Utilisez le contrôle de version." <br>  "La plupart des choses peuvent être trouvées grâce au contrôle de version." <br>  Msgstr "Désactivez les sauvegardes de fichiers, car vous utilisez toujours le système de contrôle de version;)". <br>  "Et le contrôle de version est venu, et Git nous a sauvés." <br>  «Désactiver les fichiers d'échange et le système de sauvegarde.  Utilisez toujours le contrôle de version!  TOUJOURS! ” <br>  "Je n'ai pas besoin d'une sauvegarde, car je travaille avec le contrôle de version." <br><br>  L'ironie est que les commentaires ci-dessus ne reflètent qu'une compréhension du quatrième et, en partie, du troisième type d'échec.  Si vous refusez le fichier d'échange et la sauvegarde, vous perdrez la protection dans le cas décrit aux paragraphes 1 et 2. <br><br>  Voici un exemple de configuration que je recommande pour un fonctionnement sûr: <br><br><pre> <code class="xml hljs">" Protect changes between writes. Default values of " updatecount (200 keystrokes) and updatetime " (4 seconds) are fine set swapfile set directory^=~/.vim/swap// " protect against crash-during-write set writebackup " but do not persist backup after successful write set nobackup " use rename-and-write-new method whenever safe set backupcopy=auto " patch required to honor double slash at end if has("patch-8.1.0251") " consolidate the writebackups -- not a big " deal either way, since they usually get deleted set backupdir^=~/.vim/backup// end " persist the undo tree for each file set undofile set undodir^=~/.vim/undo//</code> </pre> <br>  Ces paramètres incluent des sauvegardes pour les enregistrements incomplets, mais n'enregistrent pas les fichiers une fois l'opération terminée avec succès, car nous avons le contrôle de version, le meilleur contrôle de version, bla bla bla, etc.  etc.  Veuillez noter que vous pourriez avoir besoin de mkdir ~ / .vim / {swap, undodir, backup}, sinon Vim accèdera au prochain dossier lisible.  Vous devrez également probablement exécuter la commande chmod sur les dossiers cibles afin que leur contenu soit privé, car les fichiers d'échange et l'historique de sauvegarde peuvent contenir des informations sensibles. <br><br>  Il convient de noter que la caractéristique de nos chemins de configuration est qu'ils se ferment toujours avec une barre oblique.  Cette orthographe permet à la fonction d'éliminer toute ambiguïté possible dans les chemins des fichiers de pagination et de sauvegarde pour les fichiers portant les mêmes noms, qui se trouvent dans des répertoires différents.  Par exemple, le fichier d'échange pour / foo / bar sera enregistré dans ~ / .vim / swap /% foo% bar.swp (j'ai échappé aux barres obliques avec des signes de pourcentage).  Il y avait un bogue dans le correctif Vim récent qui empêchait la barre oblique d'être prise en compte pour backupdir, donc la protection contre celle-ci est montrée ci-dessus. <br><br>  Notre Vim enregistre également l'historique de restauration pour chaque fichier, vous pouvez donc restaurer la version correcte même après avoir quitté le mode d'édition.  Bien qu'une telle fonction puisse sembler redondante dans le contexte du fichier d'échange que nous avons déjà, l'historique de restauration est une ligne de défense supplémentaire pendant l'enregistrement du fichier. <br><br>  Lorsque nous parlons de restauration, il convient de rappeler que Vim prend en charge une arborescence complète de l'historique des modifications de fichiers.  Cela signifie que vous pouvez apporter une modification, l'annuler, puis répéter les mêmes modifications à nouveau, et tout cela correspondra à trois points de récupération différents.  L'heure et l'étendue des modifications apportées peuvent être vérifiées à l'aide de la commande undolist, mais il est problématique d'en extraire l'arborescence.                 :     5 ,      .     ,        —  ,  undotree —  . <br><br>              .                .   :        .       ,    . <br><br>     :      ,      ,vim         .       nowritebackup,        ,      .     ,   Vim      ,     .    backupskip        . <br><br>  «patchmode» Vim      .      ,     . ,     tar-,        ,     git.  set patchmod = .orig   foo-      foo.orig. <br><br><h2> Include  path </h2><br>      (include)      . Vim     path, include, suffixesadd,  includeexpr.    (. help include-search) —       ctags   . <br><br>         .    ,       .           ,     <code>help include</code> . <br><br>    ,    <code>[i</code>  ,    ,    <code>[d</code>    .    <code>gf</code>    Vim     .       :find,      <code>**/*</code>         ,    .       , ..   ,       . <br><br>        ,      .     (      )         CTRL-D.    . <br><br><pre> <code class="xml hljs">" fuzzy-find lite nmap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Leader</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">space</span></span></span><span class="hljs-tag">&gt;</span></span> :e ./**/</code> </pre> <br>   :  path     (headers) .     ,   : checkpath,  ,   .     C   checkpath.     ,     ,       .   ,  checkpath      ,   . <br><br>      <code>«., / Usr / include ,,»</code> .  ,     —  /usr/include,        .       ,     <code>:help file-searching</code> . <br><br>   ftplugin   (  )      ,    . : ./src/include  ./include. <br><br><pre> <code class="xml hljs">setlocal path=.,,*/include/**3,./*/include/**3 setlocal path+=/usr/include</code> </pre> <br>   <code>«**3»</code> —      .    ,    .  ,      . <br><br>     ,        ,  :checkpath ,      . , ,       . <br><br>   : <code>:he [, :he gf, :he :find</code> . <br><br><hr><br> <i>  .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477768/">https://habr.com/ru/post/fr477768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477754/index.html">Comparez micro: bit avec Arduino. Et comment obtenir gratuitement micro: bit si vous n'êtes pas étudiant en anglais?</a></li>
<li><a href="../fr477756/index.html">Comment nous avons épousé deux systèmes CRM bancaires</a></li>
<li><a href="../fr477758/index.html">«Docteur, retirez cela du projet de loi»: comment nous avons cherché des services illégaux à VHI</a></li>
<li><a href="../fr477760/index.html">SberX RamblerFront & Meet Up: comment c'était</a></li>
<li><a href="../fr477766/index.html">Application du mode de cryptage des cartes SL3 MIfare sur l'exemple d'une entreprise</a></li>
<li><a href="../fr477770/index.html">Allumez la lumière par le pouvoir de la pensée, enfin presque</a></li>
<li><a href="../fr477774/index.html">Réunion de conception au bureau de Saint-Pétersbourg de Wrike le 5 décembre</a></li>
<li><a href="../fr477778/index.html">Historique du processeur vidéo, partie 2: 3Dfx Voodoo</a></li>
<li><a href="../fr477780/index.html">Écrire votre propre CLI pour React</a></li>
<li><a href="../fr477782/index.html">DJI Mavic Mini et la loi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>