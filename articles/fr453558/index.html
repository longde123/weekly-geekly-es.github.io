<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¨ üåº üò• Introduction √† l'apprentissage automatique ü•ù üõ•Ô∏è üë©üèæ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le cours complet de russe se trouve sur ce lien . 
 Le cours d'anglais original est disponible sur ce lien . 



 De nouvelles conf√©rences sont pr√©vue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction √† l'apprentissage automatique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  Le cours complet de russe se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br>  Le cours d'anglais original est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>De nouvelles conf√©rences sont pr√©vues tous les 2-3 jours.</i> <br><br><h2>  Entretien avec Sebastian Trun, PDG Udacity </h2><br>  "Bonjour encore, je suis Paige et vous √™tes mon invit√© aujourd'hui, Sebastian." <br>  - Salut, je suis Sebastian! <br>  - ... un homme qui a une carri√®re incroyable, qui a r√©ussi √† faire beaucoup de choses incroyables!  Vous √™tes co-fondateur d'Udacity, vous avez fond√© Google X, vous √™tes professeur √† Stanford.  Vous avez fait des recherches incroyables et un apprentissage approfondi tout au long de votre carri√®re.  Qu'est-ce qui vous a apport√© le plus de satisfaction et dans quels domaines avez-vous re√ßu le plus de r√©compenses pour le travail accompli? <br>  - Franchement, j'aime vraiment √™tre dans la Silicon Valley!  J'aime √™tre pr√®s de gens beaucoup plus intelligents que moi, et j'ai toujours consid√©r√© la technologie comme un outil qui change les r√®gles du jeu de diverses mani√®res - de l'√©ducation √† la logistique, aux soins de sant√©, etc.  Tout cela change si vite, et il y a une incroyable envie de participer √† ces changements, de les observer.  Vous regardez votre environnement et comprenez que la plupart de ce que vous voyez autour de vous ne fonctionne pas comme il se doit - vous pouvez toujours inventer quelque chose de nouveau! <br>  - Eh bien, c'est une vision tr√®s optimiste de la technologie!  Quelle a √©t√© la plus grande eureka de votre carri√®re? <br>  - Seigneur, il y en avait tellement!  Je me souviens d'un des jours o√π Larry Page m'a appel√© et m'a sugg√©r√© de cr√©er des voitures √† pilote automatique qui pourraient traverser toutes les rues de Californie.  √Ä ce moment-l√†, j'√©tais consid√©r√© comme un expert, j'√©tais class√© parmi ceux-l√† et j'√©tais la personne m√™me qui disait "non, cela ne peut pas √™tre fait".  Apr√®s cela, Larry m'a convaincu que, en principe, il est possible de le faire, il suffit de commencer et d'essayer.  Et nous l'avons fait!  C'√©tait le moment o√π j'ai r√©alis√© que m√™me les experts se trompaient et en disant ¬´non¬ª, nous sommes 100% pessimistes.  Je pense que nous devrions √™tre plus ouverts au nouveau. <br>  - Ou, par exemple, si Larry Page vous appelle et vous dit: ¬´H√©, faites quelque chose de cool comme Google X¬ª et vous obtenez quelque chose d'assez cool! <br>  - Oui, c'est s√ªr, pas besoin de se plaindre!  Je veux dire, tout cela est un processus qui passe par beaucoup de discussions sur le chemin de la mise en ≈ìuvre.  J'ai vraiment de la chance de travailler et j'en suis fier, sur Google X et sur d'autres projets. <br>  - G√©nial!  Donc, ce cours est enti√®rement consacr√© √† l'utilisation de TensorFlow.  Avez-vous de l'exp√©rience avec TensorFlow ou peut-√™tre le connaissez-vous? <br>  - Oui!  J'adore litt√©ralement TensorFlow, bien s√ªr!  Dans mon propre laboratoire, nous l'utilisons souvent et beaucoup, l'un des travaux les plus importants bas√©s sur TensorFlow a √©t√© publi√© il y a environ deux ans.  Nous avons appris que l'iPhone et Android peuvent √™tre plus efficaces pour d√©tecter le cancer de la peau que les meilleurs dermatologues du monde.  Nous avons publi√© nos recherches dans Nature et cela a cr√©√© une sorte d'agitation en m√©decine. <br>  - Cela semble incroyable!  Vous connaissez et aimez donc TensorFlow, ce qui est g√©nial en soi!  Avez-vous d√©j√† travaill√© avec TensorFlow 2.0? <br>  - Non, malheureusement je n'ai pas encore eu le temps. <br>  - Il sera juste incroyable!  Tous les √©tudiants de ce cours travailleront avec cette version. <br>  - Je les envie!  Je vais certainement l'essayer! <br>  - G√©nial!  Dans notre cours, il y a beaucoup d'√©tudiants qui dans leur vie n'ont jamais √©t√© impliqu√©s dans l'apprentissage automatique, du mot "compl√®tement".  Pour eux, le domaine peut √™tre nouveau, peut-√™tre pour quelqu'un qui se programme lui-m√™me sera nouveau.  Quels conseils leur donnez-vous? <br>  - Je souhaite qu'ils restent ouverts - √† de nouvelles id√©es, techniques, solutions, positions.  L'apprentissage automatique est en fait plus facile que la programmation.  Dans le processus de programmation, vous devez prendre en compte chaque cas dans les donn√©es source, adapter la logique du programme et les r√®gles pour cela.  En ce moment m√™me, en utilisant TensorFlow et l'apprentissage automatique, vous formez essentiellement l'ordinateur √† l'aide d'exemples, laissant l'ordinateur trouver les r√®gles lui-m√™me. <br>  - C'est incroyablement int√©ressant!  J'ai h√¢te d'en dire un peu plus sur l'apprentissage automatique aux √©tudiants de ce cours!  Sebastian, merci d'avoir pris le temps de venir nous voir aujourd'hui! <br>  - Merci!  Restez en contact! <br><br><h2>  Qu'est-ce que l'apprentissage automatique? </h2><br>  Commen√ßons donc par la t√¢che suivante - des valeurs d'entr√©e et de sortie donn√©es. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Lorsque vous avez la valeur 0 comme valeur d'entr√©e, puis 32 comme valeur de sortie Lorsque vous avez 8 comme valeur d'entr√©e, puis 46,4 comme valeur de sortie.  Lorsque vous avez 15 comme valeur d'entr√©e, puis 59 comme valeur de sortie, etc. <br><br>  Examinez ces valeurs de plus pr√®s et laissez-moi vous poser une question.  Pouvez-vous d√©terminer quelle sera la sortie si nous obtenons 38 √† l'entr√©e? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Si vous avez r√©pondu 100,4, vous aviez raison! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Alors, comment pourrions-nous r√©soudre ce probl√®me?  Si vous regardez attentivement les valeurs, vous pouvez voir qu'elles sont li√©es par l'expression: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  O√π C - degr√©s Celsius (valeurs d'entr√©e), F - Fahrenheit (valeurs de sortie). <br><br>  Ce que votre cerveau vient de faire - a compar√© les valeurs d'entr√©e et les valeurs de sortie et a trouv√© un mod√®le commun (connexion, d√©pendance) entre elles - c'est ce que fait l'apprentissage automatique. <br><br>  Sur la base des valeurs d'entr√©e et de sortie, les algorithmes d'apprentissage automatique trouveront un algorithme appropri√© pour convertir les valeurs d'entr√©e en valeurs de sortie.  Cela peut √™tre repr√©sent√© comme suit: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Regardons un exemple.  Imaginez que nous voulons d√©velopper un programme qui convertira les degr√©s Celsius en degr√©s Fahrenheit en utilisant la formule <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  La solution, √† l'approche du point de vue du d√©veloppement logiciel traditionnel, peut √™tre impl√©ment√©e dans n'importe quel langage de programmation en utilisant la fonction: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Alors qu'avons-nous?  La fonction prend une valeur d'entr√©e de C, puis calcule la valeur de sortie de F √† l'aide d'un algorithme explicite, puis renvoie la valeur calcul√©e. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  D'un autre c√¥t√©, dans l'approche d'apprentissage automatique, nous n'avons que des valeurs d'entr√©e et de sortie, mais pas l'algorithme lui-m√™me: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  L'approche d'apprentissage automatique repose sur l'utilisation de r√©seaux de neurones pour trouver la relation entre les valeurs d'entr√©e et de sortie. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Vous pouvez consid√©rer les r√©seaux de neurones comme une pile de couches, chacune √©tant constitu√©e de math√©matiques (formules) et de variables internes pr√©c√©demment connues.  La valeur d'entr√©e p√©n√®tre dans le r√©seau neuronal et traverse une pile de couches de neurones.  En passant √† travers les couches, la valeur d'entr√©e est convertie selon les math√©matiques (formules donn√©es) et les valeurs des variables internes des couches, produisant une valeur de sortie. <br><br>  Pour que le r√©seau de neurones puisse apprendre et d√©terminer la relation correcte entre les valeurs d'entr√©e et de sortie, nous devons le former - le former. <br><br>  Nous formons le r√©seau neuronal par des tentatives r√©p√©t√©es de faire correspondre les valeurs d'entr√©e √† celles de sortie. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  Dans le processus de formation, l'ajustement (s√©lection) des valeurs des variables internes dans les couches du r√©seau neuronal a lieu jusqu'√† ce que le r√©seau apprenne √† g√©n√©rer les valeurs de sortie correspondantes aux valeurs d'entr√©e correspondantes. <br><br>  Comme nous le verrons plus loin, afin de former un r√©seau de neurones et lui permettre de s√©lectionner les valeurs les plus adapt√©es des variables internes, des milliers ou des dizaines de milliers d'it√©rations (formations) sont effectu√©es. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  En tant que version simplifi√©e de la compr√©hension de l'apprentissage automatique, vous pouvez imaginer des algorithmes d'apprentissage automatique comme des fonctions qui s√©lectionnent les valeurs des variables internes afin que les valeurs d'entr√©e correctes correspondent aux valeurs de sortie correctes. <br><br>  Il existe de nombreux types d'architectures de r√©seaux de neurones.  Cependant, quelle que soit l'architecture que vous choisissez, les calculs √† l'int√©rieur (quels calculs sont effectu√©s et dans quel ordre) resteront inchang√©s pendant la formation.  Au lieu de changer les math√©matiques, les variables internes (poids et d√©calages) changent pendant l'entra√Ænement. <br><br>  Par exemple, dans la t√¢che de conversion de degr√©s Celsius en degr√©s Fahrenheit, le mod√®le commence par multiplier la valeur d'entr√©e par un certain nombre (poids) et en ajoutant une autre valeur (d√©calage).  La formation aux mod√®les consiste √† trouver des valeurs adapt√©es √† ces variables, sans modifier les op√©rations de multiplication et d'addition effectu√©es. <br><br>  Mais une chose sympa √† penser!  Si vous avez r√©solu le probl√®me de la conversion des degr√©s Celsius en Fahrenheit, ce qui est indiqu√© dans la vid√©o et dans le texte ci-dessous, vous l'avez probablement r√©solu parce que vous aviez une exp√©rience ou des connaissances sur la fa√ßon d'effectuer ce type de conversion des degr√©s Celsius en Fahrenheit.  Par exemple, vous savez peut-√™tre que 0 degr√© Celsius correspond √† 32 degr√©s Fahrenheit.  D'un autre c√¥t√©, les syst√®mes bas√©s sur l'apprentissage automatique ne disposent pas de connaissances pr√©alables pour r√©soudre le probl√®me.  Ils apprennent √† r√©soudre de tels probl√®mes sans se baser sur des connaissances ant√©rieures et en leur absence totale. <br><br>  Assez parl√© - passez √† la partie pratique de la conf√©rence! <br><br><h2>  CoLab: convertir des degr√©s Celsius en degr√©s Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version russe du code source CoLab</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version anglaise du code source CoLab</a> . <br><br><h2>  Les bases: apprendre le premier mod√®le </h2><br>  Bienvenue √† CoLab, o√π nous formerons notre premier mod√®le d'apprentissage automatique! <br><br>  Nous essaierons de maintenir la simplicit√© du mat√©riel pr√©sent√© et n'introduirons que les concepts de base n√©cessaires au travail.  Les CoLabs ult√©rieurs contiendront des techniques plus avanc√©es. <br><br>  La t√¢che que nous allons r√©soudre est la conversion des degr√©s Celsius en degr√©s Fahrenheit.  La formule de conversion est la suivante: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>o</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.788ex" height="2.419ex" viewBox="0 -780.1 8089.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-66" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-6F" x="3118" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-69" x="3604" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-73" x="3949" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-31" x="4419" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-2C" x="4919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-38" x="5364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-2B" x="6087" y="0"></use><g transform="translate(7088,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>f</mi><mi>o</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ fois 1,8 + 32 </script></p><br><br>  Bien s√ªr, il serait plus facile d'√©crire simplement une fonction de conversion en Python ou tout autre langage de programmation qui effectuerait des calculs directs, mais dans ce cas, ce ne serait pas de l'apprentissage automatique :) <br><br>  Au lieu de cela, nous introduisons dans l'entr√©e TensorFlow nos degr√©s d'entr√©e disponibles Celsius (0, 8, 15, 22, 38) et leurs degr√©s Fahrenheit correspondants (32, 46, 59, 72, 100).  Ensuite, nous formerons le mod√®le de mani√®re √† ce qu'il corresponde approximativement √† la formule ci-dessus. <br><br><h3>  Importer les d√©pendances </h3><br>  La premi√®re chose que nous importons est <code>TensorFlow</code> .  Ici et dans ce qui suit, nous l'appelons abr√©g√© <code>tf</code> .  Nous configurons √©galement le niveau de journalisation - uniquement les erreurs. <br><br>  Ensuite, importez <code>NumPy</code> tant que <code>np</code> .  <code>Numpy</code> nous aide √† pr√©senter nos donn√©es sous forme de listes performantes. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Pr√©paration des donn√©es de formation </h3><br>  Comme nous l'avons vu pr√©c√©demment, la technique d'apprentissage automatique avec l'enseignant est bas√©e sur la recherche d'un algorithme pour convertir les donn√©es d'entr√©e en sortie.  √âtant donn√© que la t√¢che de ce CoLab est de cr√©er un mod√®le pouvant produire le r√©sultat de la conversion des degr√©s Celsius en degr√©s Fahrenheit, nous cr√©erons deux listes - <code>celsius_q</code> et <code>fahrenheit_a</code> , que nous utilisons lors de la formation de notre mod√®le. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Quelques terminologies d'apprentissage automatique: <br><br><ul><li>  <b>La propri√©t√©</b> est la ou les valeurs d'entr√©e de notre mod√®le.  Dans ce cas, la valeur unitaire est le degr√© Celsius. </li><li>  <b>Les √©tiquettes</b> sont les valeurs de sortie que notre mod√®le pr√©dit.  Dans ce cas, la valeur unitaire est le degr√© Fahrenheit. </li><li>  <b>Un exemple</b> est une paire de valeurs d'entr√©e-sortie utilis√©es pour la formation.  Dans ce cas, il s'agit d'une paire de valeurs de <code>celsius_q</code> et <code>fahrenheit_a</code> sous un certain indice, par exemple (22,72). </li></ul><br><h2>  Cr√©er un mod√®le </h2><br>  Ensuite, nous cr√©ons un mod√®le.  Nous utiliserons le mod√®le le plus simplifi√© - le mod√®le d'un r√©seau enti√®rement connect√© (r√©seau <code>Dense</code> ).  √âtant donn√© que la t√¢che est assez triviale, le r√©seau sera √©galement constitu√© d'une seule couche avec un seul neurone. <br><br><h4>  Construire un r√©seau </h4><br>  Nous nommerons la couche <code>l0</code> ( <b>l</b> ayer et z√©ro) et la cr√©erons en initialisant <code>tf.keras.layers.Dense</code> avec les param√®tres suivants: <br><br><ul><li>  <code>input_shape=[1]</code> - ce param√®tre d√©termine la dimension du param√®tre d'entr√©e - une valeur unique.  Matrice 1 √ó 1 avec une seule valeur.  Comme il s'agit de la premi√®re (et unique) couche, la dimension des donn√©es d'entr√©e correspond √† la dimension de l'ensemble du mod√®le.  La seule valeur est une valeur √† virgule flottante repr√©sentant les degr√©s Celsius. </li><li>  <code>units=1</code> - ce param√®tre d√©termine le nombre de neurones dans la couche.  Le nombre de neurones d√©termine le nombre de variables de la couche interne qui seront utilis√©es pour s'entra√Æner √† trouver une solution au probl√®me.  Comme il s'agit de la derni√®re couche, sa dimension est √©gale √† la dimension du r√©sultat - la valeur de sortie du mod√®le - un seul nombre √† virgule flottante repr√©sentant les degr√©s Fahrenheit.  (Dans un r√©seau multicouche, la taille et la forme de la couche <code>input_shape</code> doivent correspondre √† la taille et √† la forme de la couche suivante). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Convertir les calques en mod√®le </h4><br>  Une fois les couches d√©finies, elles doivent √™tre converties en mod√®le.  <code>Sequential</code> mod√®le <code>Sequential</code> prend comme arguments la liste des couches dans l'ordre dans lequel elles doivent √™tre appliqu√©es - de la valeur d'entr√©e √† la valeur de sortie. <br><br>  Notre mod√®le n'a qu'une seule couche - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Remarque</b> <br>  Tr√®s souvent, vous rencontrerez la d√©finition des couches directement dans la fonction de mod√®le, plut√¥t que leur description pr√©liminaire et leur utilisation ult√©rieure: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Nous compilons un mod√®le avec une fonction de perte et d'optimisation </h3><br>  Avant la formation, le mod√®le doit √™tre compil√© (assembl√©).  Lors de la compilation pour la formation, vous avez besoin de: <br><br><ul><li>  <b>fonction de perte</b> - un moyen de mesurer la distance entre la valeur pr√©dite et la valeur de sortie souhait√©e (une diff√©rence mesurable est appel√©e ¬´perte¬ª). </li><li>  <b>fonction d'optimisation</b> - un moyen d'ajuster les variables internes pour r√©duire les pertes. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  La fonction de perte et la fonction d'optimisation sont utilis√©es lors de l'apprentissage du mod√®le ( <code>model.fit(...)</code> mentionn√© ci-dessous) pour effectuer des calculs initiaux √† chaque point puis optimiser les valeurs. <br><br>  L'action de calculer les pertes actuelles et l'am√©lioration ult√©rieure de ces valeurs dans le mod√®le est exactement ce qu'est la formation (une it√©ration). <br><br>  Pendant la formation, la fonction d'optimisation est utilis√©e pour calculer les ajustements des valeurs des variables internes.  Le but est d'ajuster les valeurs des variables internes de cette mani√®re dans le mod√®le (et c'est en fait une fonction math√©matique) afin qu'elles refl√®tent le plus fid√®lement possible l'expression existante pour convertir les degr√©s Celsius en degr√©s Fahrenheit. <br><br>  TensorFlow utilise l'analyse num√©rique pour effectuer ce type d'op√©rations d'optimisation, et toute cette complexit√© est cach√©e √† nos yeux, nous n'entrerons donc pas dans les d√©tails de ce cours. <br><br>  Ce qu'il est utile de savoir sur ces options: <br><br>  La fonction de perte (erreur standard) et la fonction d'optimisation (Adam) utilis√©es dans cet exemple sont standard pour ces mod√®les simples, mais de nombreux autres sont disponibles en plus d'eux.  √Ä ce stade, nous ne nous soucions pas du fonctionnement de ces fonctions. <br><br>  Ce √† quoi vous devez faire attention, c'est la fonction d'optimisation et le param√®tre est le coefficient de <code>learning rate</code> , qui dans notre exemple est <code>0.1</code> .  Il s'agit de la taille de pas utilis√©e lors du r√©glage des valeurs internes des variables.  Si la valeur est trop petite, il faudra trop d'it√©rations de formation pour former le mod√®le.  Trop - la pr√©cision baisse.  Trouver une bonne valeur pour le coefficient de taux d'apprentissage n√©cessite quelques essais et erreurs; il se situe g√©n√©ralement dans la plage de <code>0.01</code> (par d√©faut) √† <code>0.1</code> . <br><br><h4>  Nous formons le mod√®le </h4><br>  La formation du mod√®le est r√©alis√©e par m√©thode d' <code>fit</code> . <br><br>  Pendant l'entra√Ænement, le mod√®le re√ßoit des degr√©s Celsius √† l'entr√©e, effectue des transformations en utilisant les valeurs des variables internes (appel√©es ¬´poids¬ª) et renvoie des valeurs qui doivent correspondre aux degr√©s Fahrenheit.  Comme les valeurs initiales des poids sont fix√©es arbitrairement, les valeurs r√©sultantes seront loin des valeurs correctes.  La diff√©rence entre le r√©sultat souhait√© et le r√©el est calcul√©e √† l'aide de la fonction de perte, et la fonction d'optimisation d√©termine comment les poids doivent √™tre ajust√©s. <br><br>  Ce cycle de calculs, de comparaisons et d'ajustements est contr√¥l√© dans le cadre de la m√©thode d' <code>fit</code> .  Le premier argument est la valeur d'entr√©e, le deuxi√®me argument est la valeur de sortie souhait√©e.  L'argument des <code>epochs</code> d√©termine combien de fois ce cycle de formation doit √™tre termin√©.  L'argument <code>verbose</code> contr√¥le le niveau de journalisation. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  Dans les vid√©os suivantes, nous allons plonger dans les d√©tails de la fa√ßon dont tout cela fonctionne et comment exactement les couches enti√®rement connect√©es (couches <code>Dense</code> ) "sous le capot". <br><br><h4>  Afficher les statistiques de formation </h4><br>  La m√©thode <code>fit</code> renvoie un objet qui contient des informations sur les modifications des pertes √† chaque it√©ration suivante.  Nous pouvons utiliser cet objet pour cr√©er un programme de perte appropri√©.  Une perte √©lev√©e signifie que les degr√©s Fahrenheit pr√©dits par le mod√®le sont loin des vraies valeurs du tableau <code>fahrenheit_a</code> . <br><br>  Pour la visualisation, nous utiliserons <code>Matplotlib</code> .  Comme vous pouvez le voir, notre mod√®le s'am√©liore tr√®s rapidement au tout d√©but, puis arrive √† une am√©lioration stable et lente jusqu'√† ce que les r√©sultats deviennent ¬´presque¬ª parfaits √† la toute fin de la formation. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Nous utilisons le mod√®le pour les pr√©dictions. </h4><br>  Nous avons maintenant un mod√®le qui a √©t√© form√© sur les valeurs d'entr√©e <code>celsius_q</code> et les valeurs de sortie <code>fahrenheit_a</code> pour d√©terminer la relation entre elles.  Nous pouvons utiliser la m√©thode de pr√©diction pour calculer les degr√©s Fahrenheit par lesquels nous ne connaissions pas auparavant les degr√©s Celsius correspondants. <br><br>  Par exemple, combien co√ªte 100,0 degr√©s Celsius Fahrenheit?  Essayez de deviner avant d'ex√©cuter le code ci-dessous. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Conclusion: <br><br> <code>[[211.29639]] <br></code> <br><br>  La bonne r√©ponse est 100 √ó 1,8 + 32 = 212, donc notre mod√®le a plut√¥t bien fonctionn√©! <br><br>  <b>Revue</b> <br><br><ul><li>  Nous avons cr√©√© un mod√®le en utilisant la couche <code>Dense</code> . </li><li>  Nous l'avons form√©e avec 3 500 exemples (7 paires de valeurs, 500 it√©rations d'entra√Ænement) </li></ul><br>  Notre mod√®le a ajust√© les valeurs des variables internes (poids) dans la couche <code>Dense</code> de mani√®re √† renvoyer les valeurs correctes de degr√©s Fahrenheit √† une valeur d'entr√©e arbitraire de degr√©s Celsius. <br><br><h3>  Nous regardons les poids </h3><br>  Affichons les valeurs des variables internes de la couche <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Conclusion: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  La valeur de la premi√®re variable est proche de ~ 1,8 et la seconde de ~ 32.  Ces valeurs (1,8 et 32) sont des valeurs directes dans la formule de conversion des degr√©s Celsius en degr√©s Fahrenheit. <br><br>  C'est vraiment tr√®s proche des valeurs r√©elles de la formule!  Nous examinerons ce point plus en d√©tail dans les vid√©os suivantes, o√π nous montrons comment fonctionne la couche <code>Dense</code> , mais pour l'instant, vous devez seulement savoir qu'un neurone avec une seule entr√©e et sortie contient des math√©matiques simples - <code>y = mx + b</code> (comme une √©quation direct), qui n'est rien de plus que notre formule de conversion des degr√©s Celsius en degr√©s Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Comme les repr√©sentations sont les m√™mes, les valeurs des variables internes du mod√®le devraient converger vers celles pr√©sent√©es dans la formule r√©elle, ce qui s'est finalement produit. <br><br>  Avec la pr√©sence de neurones suppl√©mentaires, de valeurs d'entr√©e et de valeurs de sortie suppl√©mentaires, la formule devient un peu plus compliqu√©e, mais l'essence reste la m√™me. <br><br><h4>  Un peu d'exp√©rimentation </h4><br>  Pour le plaisir!  Que se passe-t-il si nous cr√©ons plus de couches <code>Dense</code> avec plus de neurones, qui √† leur tour contiendront plus de variables internes? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Conclusion: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Comme vous l'avez peut-√™tre remarqu√©, le mod√®le actuel est √©galement capable de pr√©dire assez bien les degr√©s correspondants de Fahrenheit.  Cependant, si nous regardons les valeurs des variables internes (poids) des neurones par couches, nous ne verrons aucune valeur similaire √† 1,8 et 32.  La complexit√© suppl√©mentaire du mod√®le cache la forme ¬´simple¬ª de conversion des degr√©s Celsius en degr√©s Fahrenheit. <br><br>  Restez connect√© et dans la prochaine partie, nous verrons comment fonctionnent les couches denses ¬´sous le capot¬ª. <br><br><h3>  Bref r√©sum√© </h3><br>  F√©licitations!  Vous venez de former votre premier mod√®le.  En pratique, nous avons vu comment, par les valeurs d'entr√©e et de sortie, le mod√®le a appris √† multiplier la valeur d'entr√©e par 1,8 et √† y ajouter 32 pour obtenir le r√©sultat correct. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  C'√©tait vraiment impressionnant, compte tenu du nombre de lignes de code dont nous avions besoin pour √©crire: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  L'exemple ci-dessus est un plan g√©n√©ral pour tous les programmes d'apprentissage automatique.  Vous utiliserez des constructions similaires pour cr√©er et former des r√©seaux de neurones et pour r√©soudre des probl√®mes ult√©rieurs. <br><br><h3>  Processus de formation </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de formation (qui se d√©roule dans la m√©thode </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) consiste en une s√©quence tr√®s simple d'actions, dont le r√©sultat devrait √™tre les valeurs des variables internes donnant les r√©sultats le plus pr√®s possible de l'original. </font><font style="vertical-align: inherit;">Le processus d'optimisation par lequel ces r√©sultats sont obtenus, appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descente de gradient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , utilise une analyse num√©rique pour trouver les valeurs les plus appropri√©es pour les variables internes du mod√®le.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de vous engager dans l'apprentissage automatique, vous n'avez en principe pas besoin de comprendre ces d√©tails. Mais pour ceux qui sont toujours int√©ress√©s √† en savoir plus: la descente de gradient par it√©rations modifie un peu les valeurs des param√®tres, les ¬´tirant¬ª dans la bonne direction jusqu'√† ce que les meilleurs r√©sultats soient obtenus. Dans ce cas, les ¬´meilleurs r√©sultats¬ª (meilleures valeurs) signifient que toute modification ult√©rieure du param√®tre ne fera qu'aggraver le r√©sultat du mod√®le. Une fonction qui mesure le bien ou le mal d'un mod√®le √† chaque it√©ration est appel√©e ¬´fonction de perte¬ª, et le but de chaque ¬´traction¬ª (ajustement des valeurs internes) est de r√©duire la valeur de la fonction de perte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de formation commence par le bloc ¬´distribution directe¬ª, dans lequel les param√®tres d'entr√©e vont √† l'entr√©e du r√©seau neuronal, suivent les neurones cach√©s et ensuite vont au week-end. Le mod√®le applique ensuite des transformations internes sur les valeurs d'entr√©e et les variables internes pour pr√©dire la r√©ponse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre exemple, la valeur d'entr√©e est la temp√©rature en degr√©s Celsius et le mod√®le a pr√©dit la valeur correspondante en degr√©s Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s que la valeur est pr√©dite, la diff√©rence entre la valeur pr√©dite et la bonne est calcul√©e. La diff√©rence est appel√©e ¬´perte¬ª et est une forme de mesure de l'efficacit√© du mod√®le. La valeur de perte est calcul√©e par la fonction de perte, que nous avons d√©termin√©e par l'un des arguments lors de l'appel de la m√©thode </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir calcul√© la valeur de perte, les variables internes (poids et d√©placements) de toutes les couches du r√©seau neuronal sont ajust√©es pour minimiser la valeur de perte afin d'approximer la valeur de sortie √† la valeur de r√©f√©rence initiale correcte. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce processus d'optimisation est appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descente de gradient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un algorithme d'optimisation sp√©cifique est utilis√© pour calculer une nouvelle valeur pour chaque variable interne lorsque la m√©thode est appel√©e </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans l'exemple ci-dessus, nous avons utilis√© un algorithme d'optimisation </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'est pas n√©cessaire de comprendre les principes du processus de formation pour ce cours, mais si vous √™tes assez curieux, vous pouvez trouver plus d'informations sur le cours </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Crash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(La traduction et la partie pratique de l'ensemble du cours sont d√©finies dans les plans de publication de l'auteur). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, vous devez d√©j√† √™tre familiaris√© avec les termes suivants:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propri√©t√©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valeur d'entr√©e de notre mod√®le;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : paires entr√©e + sortie;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valeurs de sortie du mod√®le;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couches</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : une collection de n≈ìuds r√©unis au sein d'un r√©seau de neurones;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mod√®le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : repr√©sentation de votre r√©seau neuronal;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dense et enti√®rement connect√©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : chaque n≈ìud d'une couche est connect√© √† chaque n≈ìud de la couche pr√©c√©dente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poids et d√©calages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : mod√©liser les variables internes;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la diff√©rence entre la valeur de sortie souhait√©e et la valeur de sortie r√©elle du mod√®le;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  ¬´¬ª       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b> </b> :       ,              . </li></ul><br><h2> Dense- </h2><br>      ,       ,             . <br><br>       .     ?             3  ,             . <br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons qu'un r√©seau de neurones peut √™tre imagin√© comme un ensemble de couches, chacune compos√©e de n≈ìuds appel√©s neurones. Les neurones √† chaque niveau peuvent √™tre connect√©s aux neurones de chaque couche suivante. Le type de couches dans lequel chaque neurone d'une couche est connect√© √† l'autre neurone de la couche suivante est appel√© une couche enti√®rement connect√©e (enti√®rement connect√©e) ou dense ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-couche). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, lorsque nous utilisons des couches enti√®rement connect√©es </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous informons en quelque sorte que les neurones de cette couche doivent √™tre connect√©s √† tous les neurones de la couche pr√©c√©dente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er le r√©seau neuronal ci-dessus, les expressions suivantes nous suffisent:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc compris ce que sont les neurones et comment ils sont li√©s. Mais comment fonctionnent les couches enti√®rement connect√©es? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour comprendre ce qui se passe r√©ellement l√†-bas et ce qu'ils font, nous devons regarder ¬´sous le capot¬ª et analyser les math√©matiques internes des neurones. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez que notre mod√®le re√ßoive trois param√®tres - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- les neurones de notre r√©seau. Rappelez-vous que nous avons dit qu'un neurone a des variables internes? Ainsi, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont les m√™mes variables internes d'un neurone, √©galement appel√©es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poids</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©placements</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ce sont les valeurs de ces variables qui sont ajust√©es dans le processus d'apprentissage pour obtenir les r√©sultats les plus pr√©cis de comparaison des valeurs d'entr√©e √† la sortie. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce que vous devez certainement garder √† l'esprit, c'est que les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math√©matiques internes du neurone restent inchang√©es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En d'autres termes, pendant le processus de formation, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seuls les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> poids et les d√©placements </font><font style="vertical-align: inherit;">changent </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous commencez √† apprendre l'apprentissage automatique, cela peut sembler √©trange - le fait que cela fonctionne vraiment, mais c'est ainsi que fonctionne l'apprentissage automatique! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons √† notre exemple de conversion des degr√©s Celsius en degr√©s Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec un seul neurone, nous n'avons qu'un seul poids et un seul d√©placement. Tu sais quoi? C'est exactement √† quoi ressemble la formule de conversion des degr√©s Celsius en degr√©s Fahrenheit. Si nous substituons la </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et au lieu de </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous obtenons le mod√®le de transformation final! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous revenons aux r√©sultats de notre mod√®le de la partie pratique, nous faisons attention au fait que les indicateurs de poids et de d√©placement ont √©t√© ¬´calibr√©s¬ª de mani√®re √† correspondre approximativement aux valeurs de la formule.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons d√©lib√©r√©ment cr√©√© un tel exemple pratique afin de montrer clairement la comparaison exacte entre les poids et les d√©calages. En mettant l'apprentissage automatique en pratique, nous ne pouvons jamais comparer les valeurs des variables avec l'algorithme cible de cette mani√®re, comme dans l'exemple ci-dessus. Comment pouvons-nous faire cela? Pas question, car nous ne connaissons m√™me pas l'algorithme cible! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©soudre les probl√®mes d'apprentissage automatique, nous testons diverses architectures de r√©seaux de neurones avec diff√©rents nombres de neurones - par essais et erreurs, nous trouvons les architectures et les mod√®les les plus pr√©cis et esp√©rons qu'ils r√©soudront le probl√®me dans le processus d'apprentissage. Dans la prochaine partie pratique, nous pourrons √©tudier des exemples sp√©cifiques de cette approche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Restez en contact, car le plaisir commence maintenant!</font></font><br><br><h3>  R√©sum√© </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette le√ßon, nous avons appris les approches de base de l'apprentissage automatique et appris comment fonctionnent les couches (couches </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">enti√®rement connect√©es </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vous avez form√© votre premier mod√®le √† convertir des degr√©s Celsius en degr√©s Fahrenheit. </font><font style="vertical-align: inherit;">Vous avez √©galement appris les termes de base utilis√©s dans l'apprentissage automatique, tels que les propri√©t√©s, les exemples, les √©tiquettes. </font><font style="vertical-align: inherit;">Vous avez, entre autres, √©crit les principales lignes de code en Python, qui sont l'√©pine dorsale de tout algorithme d'apprentissage automatique. </font><font style="vertical-align: inherit;">Vous avez vu qu'en quelques lignes de code, vous pouvez cr√©er, former et demander une pr√©diction √† partir d'un r√©seau de neurones en utilisant </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... et appel √† l'action standard - inscrivez-vous, mettez un plus et partagez :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version vid√©o de l'article</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> T√©l√©gramme: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453558/">https://habr.com/ru/post/fr453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453542/index.html">Le robot √† quatre pattes a pu remorquer un avion pesant 3,3 tonnes</a></li>
<li><a href="../fr453544/index.html">D√©codeur √† sept segments utilisant √† la fois les sorties directes et inverses d'un compteur BCD</a></li>
<li><a href="../fr453546/index.html">Besoin d'un petit clavier - faites-le vous-m√™me</a></li>
<li><a href="../fr453548/index.html">Nous ravivons le freinage du Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../fr453554/index.html">Comment Starlink de SpaceX a chang√©</a></li>
<li><a href="../fr453562/index.html">√âv√©nements num√©riques √† Moscou du 27 mai au 2 juin</a></li>
<li><a href="../fr453564/index.html">Make it True - D√©veloppement d'un jeu de logique sur Unity</a></li>
<li><a href="../fr453566/index.html">Restaurer la l√©gende: un appel √† l'√©change de donn√©es ouvertes pouvant aider √† la restauration de Notre Dame</a></li>
<li><a href="../fr453568/index.html">Reconstruire une ic√¥ne: un appel au partage des donn√©es ouvertes pour aider √† restaurer Notre-Dame</a></li>
<li><a href="../fr453570/index.html">Microsoft Edge pour macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>