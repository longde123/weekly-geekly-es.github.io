<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💬 🌼 😥 Introduction à l'apprentissage automatique 🥝 🛥️ 👩🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le cours complet de russe se trouve sur ce lien . 
 Le cours d'anglais original est disponible sur ce lien . 



 De nouvelles conférences sont prévue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à l'apprentissage automatique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  Le cours complet de russe se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br>  Le cours d'anglais original est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>De nouvelles conférences sont prévues tous les 2-3 jours.</i> <br><br><h2>  Entretien avec Sebastian Trun, PDG Udacity </h2><br>  "Bonjour encore, je suis Paige et vous êtes mon invité aujourd'hui, Sebastian." <br>  - Salut, je suis Sebastian! <br>  - ... un homme qui a une carrière incroyable, qui a réussi à faire beaucoup de choses incroyables!  Vous êtes co-fondateur d'Udacity, vous avez fondé Google X, vous êtes professeur à Stanford.  Vous avez fait des recherches incroyables et un apprentissage approfondi tout au long de votre carrière.  Qu'est-ce qui vous a apporté le plus de satisfaction et dans quels domaines avez-vous reçu le plus de récompenses pour le travail accompli? <br>  - Franchement, j'aime vraiment être dans la Silicon Valley!  J'aime être près de gens beaucoup plus intelligents que moi, et j'ai toujours considéré la technologie comme un outil qui change les règles du jeu de diverses manières - de l'éducation à la logistique, aux soins de santé, etc.  Tout cela change si vite, et il y a une incroyable envie de participer à ces changements, de les observer.  Vous regardez votre environnement et comprenez que la plupart de ce que vous voyez autour de vous ne fonctionne pas comme il se doit - vous pouvez toujours inventer quelque chose de nouveau! <br>  - Eh bien, c'est une vision très optimiste de la technologie!  Quelle a été la plus grande eureka de votre carrière? <br>  - Seigneur, il y en avait tellement!  Je me souviens d'un des jours où Larry Page m'a appelé et m'a suggéré de créer des voitures à pilote automatique qui pourraient traverser toutes les rues de Californie.  À ce moment-là, j'étais considéré comme un expert, j'étais classé parmi ceux-là et j'étais la personne même qui disait "non, cela ne peut pas être fait".  Après cela, Larry m'a convaincu que, en principe, il est possible de le faire, il suffit de commencer et d'essayer.  Et nous l'avons fait!  C'était le moment où j'ai réalisé que même les experts se trompaient et en disant «non», nous sommes 100% pessimistes.  Je pense que nous devrions être plus ouverts au nouveau. <br>  - Ou, par exemple, si Larry Page vous appelle et vous dit: «Hé, faites quelque chose de cool comme Google X» et vous obtenez quelque chose d'assez cool! <br>  - Oui, c'est sûr, pas besoin de se plaindre!  Je veux dire, tout cela est un processus qui passe par beaucoup de discussions sur le chemin de la mise en œuvre.  J'ai vraiment de la chance de travailler et j'en suis fier, sur Google X et sur d'autres projets. <br>  - Génial!  Donc, ce cours est entièrement consacré à l'utilisation de TensorFlow.  Avez-vous de l'expérience avec TensorFlow ou peut-être le connaissez-vous? <br>  - Oui!  J'adore littéralement TensorFlow, bien sûr!  Dans mon propre laboratoire, nous l'utilisons souvent et beaucoup, l'un des travaux les plus importants basés sur TensorFlow a été publié il y a environ deux ans.  Nous avons appris que l'iPhone et Android peuvent être plus efficaces pour détecter le cancer de la peau que les meilleurs dermatologues du monde.  Nous avons publié nos recherches dans Nature et cela a créé une sorte d'agitation en médecine. <br>  - Cela semble incroyable!  Vous connaissez et aimez donc TensorFlow, ce qui est génial en soi!  Avez-vous déjà travaillé avec TensorFlow 2.0? <br>  - Non, malheureusement je n'ai pas encore eu le temps. <br>  - Il sera juste incroyable!  Tous les étudiants de ce cours travailleront avec cette version. <br>  - Je les envie!  Je vais certainement l'essayer! <br>  - Génial!  Dans notre cours, il y a beaucoup d'étudiants qui dans leur vie n'ont jamais été impliqués dans l'apprentissage automatique, du mot "complètement".  Pour eux, le domaine peut être nouveau, peut-être pour quelqu'un qui se programme lui-même sera nouveau.  Quels conseils leur donnez-vous? <br>  - Je souhaite qu'ils restent ouverts - à de nouvelles idées, techniques, solutions, positions.  L'apprentissage automatique est en fait plus facile que la programmation.  Dans le processus de programmation, vous devez prendre en compte chaque cas dans les données source, adapter la logique du programme et les règles pour cela.  En ce moment même, en utilisant TensorFlow et l'apprentissage automatique, vous formez essentiellement l'ordinateur à l'aide d'exemples, laissant l'ordinateur trouver les règles lui-même. <br>  - C'est incroyablement intéressant!  J'ai hâte d'en dire un peu plus sur l'apprentissage automatique aux étudiants de ce cours!  Sebastian, merci d'avoir pris le temps de venir nous voir aujourd'hui! <br>  - Merci!  Restez en contact! <br><br><h2>  Qu'est-ce que l'apprentissage automatique? </h2><br>  Commençons donc par la tâche suivante - des valeurs d'entrée et de sortie données. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Lorsque vous avez la valeur 0 comme valeur d'entrée, puis 32 comme valeur de sortie Lorsque vous avez 8 comme valeur d'entrée, puis 46,4 comme valeur de sortie.  Lorsque vous avez 15 comme valeur d'entrée, puis 59 comme valeur de sortie, etc. <br><br>  Examinez ces valeurs de plus près et laissez-moi vous poser une question.  Pouvez-vous déterminer quelle sera la sortie si nous obtenons 38 à l'entrée? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Si vous avez répondu 100,4, vous aviez raison! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Alors, comment pourrions-nous résoudre ce problème?  Si vous regardez attentivement les valeurs, vous pouvez voir qu'elles sont liées par l'expression: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Où C - degrés Celsius (valeurs d'entrée), F - Fahrenheit (valeurs de sortie). <br><br>  Ce que votre cerveau vient de faire - a comparé les valeurs d'entrée et les valeurs de sortie et a trouvé un modèle commun (connexion, dépendance) entre elles - c'est ce que fait l'apprentissage automatique. <br><br>  Sur la base des valeurs d'entrée et de sortie, les algorithmes d'apprentissage automatique trouveront un algorithme approprié pour convertir les valeurs d'entrée en valeurs de sortie.  Cela peut être représenté comme suit: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Regardons un exemple.  Imaginez que nous voulons développer un programme qui convertira les degrés Celsius en degrés Fahrenheit en utilisant la formule <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  La solution, à l'approche du point de vue du développement logiciel traditionnel, peut être implémentée dans n'importe quel langage de programmation en utilisant la fonction: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Alors qu'avons-nous?  La fonction prend une valeur d'entrée de C, puis calcule la valeur de sortie de F à l'aide d'un algorithme explicite, puis renvoie la valeur calculée. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  D'un autre côté, dans l'approche d'apprentissage automatique, nous n'avons que des valeurs d'entrée et de sortie, mais pas l'algorithme lui-même: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  L'approche d'apprentissage automatique repose sur l'utilisation de réseaux de neurones pour trouver la relation entre les valeurs d'entrée et de sortie. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Vous pouvez considérer les réseaux de neurones comme une pile de couches, chacune étant constituée de mathématiques (formules) et de variables internes précédemment connues.  La valeur d'entrée pénètre dans le réseau neuronal et traverse une pile de couches de neurones.  En passant à travers les couches, la valeur d'entrée est convertie selon les mathématiques (formules données) et les valeurs des variables internes des couches, produisant une valeur de sortie. <br><br>  Pour que le réseau de neurones puisse apprendre et déterminer la relation correcte entre les valeurs d'entrée et de sortie, nous devons le former - le former. <br><br>  Nous formons le réseau neuronal par des tentatives répétées de faire correspondre les valeurs d'entrée à celles de sortie. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  Dans le processus de formation, l'ajustement (sélection) des valeurs des variables internes dans les couches du réseau neuronal a lieu jusqu'à ce que le réseau apprenne à générer les valeurs de sortie correspondantes aux valeurs d'entrée correspondantes. <br><br>  Comme nous le verrons plus loin, afin de former un réseau de neurones et lui permettre de sélectionner les valeurs les plus adaptées des variables internes, des milliers ou des dizaines de milliers d'itérations (formations) sont effectuées. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  En tant que version simplifiée de la compréhension de l'apprentissage automatique, vous pouvez imaginer des algorithmes d'apprentissage automatique comme des fonctions qui sélectionnent les valeurs des variables internes afin que les valeurs d'entrée correctes correspondent aux valeurs de sortie correctes. <br><br>  Il existe de nombreux types d'architectures de réseaux de neurones.  Cependant, quelle que soit l'architecture que vous choisissez, les calculs à l'intérieur (quels calculs sont effectués et dans quel ordre) resteront inchangés pendant la formation.  Au lieu de changer les mathématiques, les variables internes (poids et décalages) changent pendant l'entraînement. <br><br>  Par exemple, dans la tâche de conversion de degrés Celsius en degrés Fahrenheit, le modèle commence par multiplier la valeur d'entrée par un certain nombre (poids) et en ajoutant une autre valeur (décalage).  La formation aux modèles consiste à trouver des valeurs adaptées à ces variables, sans modifier les opérations de multiplication et d'addition effectuées. <br><br>  Mais une chose sympa à penser!  Si vous avez résolu le problème de la conversion des degrés Celsius en Fahrenheit, ce qui est indiqué dans la vidéo et dans le texte ci-dessous, vous l'avez probablement résolu parce que vous aviez une expérience ou des connaissances sur la façon d'effectuer ce type de conversion des degrés Celsius en Fahrenheit.  Par exemple, vous savez peut-être que 0 degré Celsius correspond à 32 degrés Fahrenheit.  D'un autre côté, les systèmes basés sur l'apprentissage automatique ne disposent pas de connaissances préalables pour résoudre le problème.  Ils apprennent à résoudre de tels problèmes sans se baser sur des connaissances antérieures et en leur absence totale. <br><br>  Assez parlé - passez à la partie pratique de la conférence! <br><br><h2>  CoLab: convertir des degrés Celsius en degrés Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version russe du code source CoLab</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version anglaise du code source CoLab</a> . <br><br><h2>  Les bases: apprendre le premier modèle </h2><br>  Bienvenue à CoLab, où nous formerons notre premier modèle d'apprentissage automatique! <br><br>  Nous essaierons de maintenir la simplicité du matériel présenté et n'introduirons que les concepts de base nécessaires au travail.  Les CoLabs ultérieurs contiendront des techniques plus avancées. <br><br>  La tâche que nous allons résoudre est la conversion des degrés Celsius en degrés Fahrenheit.  La formule de conversion est la suivante: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>o</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.788ex" height="2.419ex" viewBox="0 -780.1 8089.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-66" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-6F" x="3118" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-69" x="3604" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMATHI-73" x="3949" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-31" x="4419" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-2C" x="4919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-38" x="5364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-2B" x="6087" y="0"></use><g transform="translate(7088,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhg8lGOllPRNxgQ903kZSzmvhCiW5A#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>f</mi><mi>o</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ fois 1,8 + 32 </script></p><br><br>  Bien sûr, il serait plus facile d'écrire simplement une fonction de conversion en Python ou tout autre langage de programmation qui effectuerait des calculs directs, mais dans ce cas, ce ne serait pas de l'apprentissage automatique :) <br><br>  Au lieu de cela, nous introduisons dans l'entrée TensorFlow nos degrés d'entrée disponibles Celsius (0, 8, 15, 22, 38) et leurs degrés Fahrenheit correspondants (32, 46, 59, 72, 100).  Ensuite, nous formerons le modèle de manière à ce qu'il corresponde approximativement à la formule ci-dessus. <br><br><h3>  Importer les dépendances </h3><br>  La première chose que nous importons est <code>TensorFlow</code> .  Ici et dans ce qui suit, nous l'appelons abrégé <code>tf</code> .  Nous configurons également le niveau de journalisation - uniquement les erreurs. <br><br>  Ensuite, importez <code>NumPy</code> tant que <code>np</code> .  <code>Numpy</code> nous aide à présenter nos données sous forme de listes performantes. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Préparation des données de formation </h3><br>  Comme nous l'avons vu précédemment, la technique d'apprentissage automatique avec l'enseignant est basée sur la recherche d'un algorithme pour convertir les données d'entrée en sortie.  Étant donné que la tâche de ce CoLab est de créer un modèle pouvant produire le résultat de la conversion des degrés Celsius en degrés Fahrenheit, nous créerons deux listes - <code>celsius_q</code> et <code>fahrenheit_a</code> , que nous utilisons lors de la formation de notre modèle. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Quelques terminologies d'apprentissage automatique: <br><br><ul><li>  <b>La propriété</b> est la ou les valeurs d'entrée de notre modèle.  Dans ce cas, la valeur unitaire est le degré Celsius. </li><li>  <b>Les étiquettes</b> sont les valeurs de sortie que notre modèle prédit.  Dans ce cas, la valeur unitaire est le degré Fahrenheit. </li><li>  <b>Un exemple</b> est une paire de valeurs d'entrée-sortie utilisées pour la formation.  Dans ce cas, il s'agit d'une paire de valeurs de <code>celsius_q</code> et <code>fahrenheit_a</code> sous un certain indice, par exemple (22,72). </li></ul><br><h2>  Créer un modèle </h2><br>  Ensuite, nous créons un modèle.  Nous utiliserons le modèle le plus simplifié - le modèle d'un réseau entièrement connecté (réseau <code>Dense</code> ).  Étant donné que la tâche est assez triviale, le réseau sera également constitué d'une seule couche avec un seul neurone. <br><br><h4>  Construire un réseau </h4><br>  Nous nommerons la couche <code>l0</code> ( <b>l</b> ayer et zéro) et la créerons en initialisant <code>tf.keras.layers.Dense</code> avec les paramètres suivants: <br><br><ul><li>  <code>input_shape=[1]</code> - ce paramètre détermine la dimension du paramètre d'entrée - une valeur unique.  Matrice 1 × 1 avec une seule valeur.  Comme il s'agit de la première (et unique) couche, la dimension des données d'entrée correspond à la dimension de l'ensemble du modèle.  La seule valeur est une valeur à virgule flottante représentant les degrés Celsius. </li><li>  <code>units=1</code> - ce paramètre détermine le nombre de neurones dans la couche.  Le nombre de neurones détermine le nombre de variables de la couche interne qui seront utilisées pour s'entraîner à trouver une solution au problème.  Comme il s'agit de la dernière couche, sa dimension est égale à la dimension du résultat - la valeur de sortie du modèle - un seul nombre à virgule flottante représentant les degrés Fahrenheit.  (Dans un réseau multicouche, la taille et la forme de la couche <code>input_shape</code> doivent correspondre à la taille et à la forme de la couche suivante). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Convertir les calques en modèle </h4><br>  Une fois les couches définies, elles doivent être converties en modèle.  <code>Sequential</code> modèle <code>Sequential</code> prend comme arguments la liste des couches dans l'ordre dans lequel elles doivent être appliquées - de la valeur d'entrée à la valeur de sortie. <br><br>  Notre modèle n'a qu'une seule couche - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Remarque</b> <br>  Très souvent, vous rencontrerez la définition des couches directement dans la fonction de modèle, plutôt que leur description préliminaire et leur utilisation ultérieure: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Nous compilons un modèle avec une fonction de perte et d'optimisation </h3><br>  Avant la formation, le modèle doit être compilé (assemblé).  Lors de la compilation pour la formation, vous avez besoin de: <br><br><ul><li>  <b>fonction de perte</b> - un moyen de mesurer la distance entre la valeur prédite et la valeur de sortie souhaitée (une différence mesurable est appelée «perte»). </li><li>  <b>fonction d'optimisation</b> - un moyen d'ajuster les variables internes pour réduire les pertes. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  La fonction de perte et la fonction d'optimisation sont utilisées lors de l'apprentissage du modèle ( <code>model.fit(...)</code> mentionné ci-dessous) pour effectuer des calculs initiaux à chaque point puis optimiser les valeurs. <br><br>  L'action de calculer les pertes actuelles et l'amélioration ultérieure de ces valeurs dans le modèle est exactement ce qu'est la formation (une itération). <br><br>  Pendant la formation, la fonction d'optimisation est utilisée pour calculer les ajustements des valeurs des variables internes.  Le but est d'ajuster les valeurs des variables internes de cette manière dans le modèle (et c'est en fait une fonction mathématique) afin qu'elles reflètent le plus fidèlement possible l'expression existante pour convertir les degrés Celsius en degrés Fahrenheit. <br><br>  TensorFlow utilise l'analyse numérique pour effectuer ce type d'opérations d'optimisation, et toute cette complexité est cachée à nos yeux, nous n'entrerons donc pas dans les détails de ce cours. <br><br>  Ce qu'il est utile de savoir sur ces options: <br><br>  La fonction de perte (erreur standard) et la fonction d'optimisation (Adam) utilisées dans cet exemple sont standard pour ces modèles simples, mais de nombreux autres sont disponibles en plus d'eux.  À ce stade, nous ne nous soucions pas du fonctionnement de ces fonctions. <br><br>  Ce à quoi vous devez faire attention, c'est la fonction d'optimisation et le paramètre est le coefficient de <code>learning rate</code> , qui dans notre exemple est <code>0.1</code> .  Il s'agit de la taille de pas utilisée lors du réglage des valeurs internes des variables.  Si la valeur est trop petite, il faudra trop d'itérations de formation pour former le modèle.  Trop - la précision baisse.  Trouver une bonne valeur pour le coefficient de taux d'apprentissage nécessite quelques essais et erreurs; il se situe généralement dans la plage de <code>0.01</code> (par défaut) à <code>0.1</code> . <br><br><h4>  Nous formons le modèle </h4><br>  La formation du modèle est réalisée par méthode d' <code>fit</code> . <br><br>  Pendant l'entraînement, le modèle reçoit des degrés Celsius à l'entrée, effectue des transformations en utilisant les valeurs des variables internes (appelées «poids») et renvoie des valeurs qui doivent correspondre aux degrés Fahrenheit.  Comme les valeurs initiales des poids sont fixées arbitrairement, les valeurs résultantes seront loin des valeurs correctes.  La différence entre le résultat souhaité et le réel est calculée à l'aide de la fonction de perte, et la fonction d'optimisation détermine comment les poids doivent être ajustés. <br><br>  Ce cycle de calculs, de comparaisons et d'ajustements est contrôlé dans le cadre de la méthode d' <code>fit</code> .  Le premier argument est la valeur d'entrée, le deuxième argument est la valeur de sortie souhaitée.  L'argument des <code>epochs</code> détermine combien de fois ce cycle de formation doit être terminé.  L'argument <code>verbose</code> contrôle le niveau de journalisation. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  Dans les vidéos suivantes, nous allons plonger dans les détails de la façon dont tout cela fonctionne et comment exactement les couches entièrement connectées (couches <code>Dense</code> ) "sous le capot". <br><br><h4>  Afficher les statistiques de formation </h4><br>  La méthode <code>fit</code> renvoie un objet qui contient des informations sur les modifications des pertes à chaque itération suivante.  Nous pouvons utiliser cet objet pour créer un programme de perte approprié.  Une perte élevée signifie que les degrés Fahrenheit prédits par le modèle sont loin des vraies valeurs du tableau <code>fahrenheit_a</code> . <br><br>  Pour la visualisation, nous utiliserons <code>Matplotlib</code> .  Comme vous pouvez le voir, notre modèle s'améliore très rapidement au tout début, puis arrive à une amélioration stable et lente jusqu'à ce que les résultats deviennent «presque» parfaits à la toute fin de la formation. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Nous utilisons le modèle pour les prédictions. </h4><br>  Nous avons maintenant un modèle qui a été formé sur les valeurs d'entrée <code>celsius_q</code> et les valeurs de sortie <code>fahrenheit_a</code> pour déterminer la relation entre elles.  Nous pouvons utiliser la méthode de prédiction pour calculer les degrés Fahrenheit par lesquels nous ne connaissions pas auparavant les degrés Celsius correspondants. <br><br>  Par exemple, combien coûte 100,0 degrés Celsius Fahrenheit?  Essayez de deviner avant d'exécuter le code ci-dessous. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Conclusion: <br><br> <code>[[211.29639]] <br></code> <br><br>  La bonne réponse est 100 × 1,8 + 32 = 212, donc notre modèle a plutôt bien fonctionné! <br><br>  <b>Revue</b> <br><br><ul><li>  Nous avons créé un modèle en utilisant la couche <code>Dense</code> . </li><li>  Nous l'avons formée avec 3 500 exemples (7 paires de valeurs, 500 itérations d'entraînement) </li></ul><br>  Notre modèle a ajusté les valeurs des variables internes (poids) dans la couche <code>Dense</code> de manière à renvoyer les valeurs correctes de degrés Fahrenheit à une valeur d'entrée arbitraire de degrés Celsius. <br><br><h3>  Nous regardons les poids </h3><br>  Affichons les valeurs des variables internes de la couche <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Conclusion: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  La valeur de la première variable est proche de ~ 1,8 et la seconde de ~ 32.  Ces valeurs (1,8 et 32) sont des valeurs directes dans la formule de conversion des degrés Celsius en degrés Fahrenheit. <br><br>  C'est vraiment très proche des valeurs réelles de la formule!  Nous examinerons ce point plus en détail dans les vidéos suivantes, où nous montrons comment fonctionne la couche <code>Dense</code> , mais pour l'instant, vous devez seulement savoir qu'un neurone avec une seule entrée et sortie contient des mathématiques simples - <code>y = mx + b</code> (comme une équation direct), qui n'est rien de plus que notre formule de conversion des degrés Celsius en degrés Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Comme les représentations sont les mêmes, les valeurs des variables internes du modèle devraient converger vers celles présentées dans la formule réelle, ce qui s'est finalement produit. <br><br>  Avec la présence de neurones supplémentaires, de valeurs d'entrée et de valeurs de sortie supplémentaires, la formule devient un peu plus compliquée, mais l'essence reste la même. <br><br><h4>  Un peu d'expérimentation </h4><br>  Pour le plaisir!  Que se passe-t-il si nous créons plus de couches <code>Dense</code> avec plus de neurones, qui à leur tour contiendront plus de variables internes? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Conclusion: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Comme vous l'avez peut-être remarqué, le modèle actuel est également capable de prédire assez bien les degrés correspondants de Fahrenheit.  Cependant, si nous regardons les valeurs des variables internes (poids) des neurones par couches, nous ne verrons aucune valeur similaire à 1,8 et 32.  La complexité supplémentaire du modèle cache la forme «simple» de conversion des degrés Celsius en degrés Fahrenheit. <br><br>  Restez connecté et dans la prochaine partie, nous verrons comment fonctionnent les couches denses «sous le capot». <br><br><h3>  Bref résumé </h3><br>  Félicitations!  Vous venez de former votre premier modèle.  En pratique, nous avons vu comment, par les valeurs d'entrée et de sortie, le modèle a appris à multiplier la valeur d'entrée par 1,8 et à y ajouter 32 pour obtenir le résultat correct. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  C'était vraiment impressionnant, compte tenu du nombre de lignes de code dont nous avions besoin pour écrire: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  L'exemple ci-dessus est un plan général pour tous les programmes d'apprentissage automatique.  Vous utiliserez des constructions similaires pour créer et former des réseaux de neurones et pour résoudre des problèmes ultérieurs. <br><br><h3>  Processus de formation </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de formation (qui se déroule dans la méthode </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) consiste en une séquence très simple d'actions, dont le résultat devrait être les valeurs des variables internes donnant les résultats le plus près possible de l'original. </font><font style="vertical-align: inherit;">Le processus d'optimisation par lequel ces résultats sont obtenus, appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descente de gradient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , utilise une analyse numérique pour trouver les valeurs les plus appropriées pour les variables internes du modèle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de vous engager dans l'apprentissage automatique, vous n'avez en principe pas besoin de comprendre ces détails. Mais pour ceux qui sont toujours intéressés à en savoir plus: la descente de gradient par itérations modifie un peu les valeurs des paramètres, les «tirant» dans la bonne direction jusqu'à ce que les meilleurs résultats soient obtenus. Dans ce cas, les «meilleurs résultats» (meilleures valeurs) signifient que toute modification ultérieure du paramètre ne fera qu'aggraver le résultat du modèle. Une fonction qui mesure le bien ou le mal d'un modèle à chaque itération est appelée «fonction de perte», et le but de chaque «traction» (ajustement des valeurs internes) est de réduire la valeur de la fonction de perte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de formation commence par le bloc «distribution directe», dans lequel les paramètres d'entrée vont à l'entrée du réseau neuronal, suivent les neurones cachés et ensuite vont au week-end. Le modèle applique ensuite des transformations internes sur les valeurs d'entrée et les variables internes pour prédire la réponse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre exemple, la valeur d'entrée est la température en degrés Celsius et le modèle a prédit la valeur correspondante en degrés Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dès que la valeur est prédite, la différence entre la valeur prédite et la bonne est calculée. La différence est appelée «perte» et est une forme de mesure de l'efficacité du modèle. La valeur de perte est calculée par la fonction de perte, que nous avons déterminée par l'un des arguments lors de l'appel de la méthode </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir calculé la valeur de perte, les variables internes (poids et déplacements) de toutes les couches du réseau neuronal sont ajustées pour minimiser la valeur de perte afin d'approximer la valeur de sortie à la valeur de référence initiale correcte. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce processus d'optimisation est appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descente de gradient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un algorithme d'optimisation spécifique est utilisé pour calculer une nouvelle valeur pour chaque variable interne lorsque la méthode est appelée </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans l'exemple ci-dessus, nous avons utilisé un algorithme d'optimisation </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'est pas nécessaire de comprendre les principes du processus de formation pour ce cours, mais si vous êtes assez curieux, vous pouvez trouver plus d'informations sur le cours </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Crash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(La traduction et la partie pratique de l'ensemble du cours sont définies dans les plans de publication de l'auteur). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, vous devez déjà être familiarisé avec les termes suivants:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriété</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valeur d'entrée de notre modèle;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : paires entrée + sortie;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valeurs de sortie du modèle;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couches</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : une collection de nœuds réunis au sein d'un réseau de neurones;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modèle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : représentation de votre réseau neuronal;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dense et entièrement connecté</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : chaque nœud d'une couche est connecté à chaque nœud de la couche précédente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poids et décalages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : modéliser les variables internes;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la différence entre la valeur de sortie souhaitée et la valeur de sortie réelle du modèle;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  «»       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b> </b> :       ,              . </li></ul><br><h2> Dense- </h2><br>      ,       ,             . <br><br>       .     ?             3  ,             . <br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons qu'un réseau de neurones peut être imaginé comme un ensemble de couches, chacune composée de nœuds appelés neurones. Les neurones à chaque niveau peuvent être connectés aux neurones de chaque couche suivante. Le type de couches dans lequel chaque neurone d'une couche est connecté à l'autre neurone de la couche suivante est appelé une couche entièrement connectée (entièrement connectée) ou dense ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-couche). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, lorsque nous utilisons des couches entièrement connectées </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous informons en quelque sorte que les neurones de cette couche doivent être connectés à tous les neurones de la couche précédente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer le réseau neuronal ci-dessus, les expressions suivantes nous suffisent:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc compris ce que sont les neurones et comment ils sont liés. Mais comment fonctionnent les couches entièrement connectées? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour comprendre ce qui se passe réellement là-bas et ce qu'ils font, nous devons regarder «sous le capot» et analyser les mathématiques internes des neurones. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez que notre modèle reçoive trois paramètres - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- les neurones de notre réseau. Rappelez-vous que nous avons dit qu'un neurone a des variables internes? Ainsi, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont les mêmes variables internes d'un neurone, également appelées </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poids</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déplacements</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ce sont les valeurs de ces variables qui sont ajustées dans le processus d'apprentissage pour obtenir les résultats les plus précis de comparaison des valeurs d'entrée à la sortie. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce que vous devez certainement garder à l'esprit, c'est que les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mathématiques internes du neurone restent inchangées</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En d'autres termes, pendant le processus de formation, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seuls les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> poids et les déplacements </font><font style="vertical-align: inherit;">changent </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous commencez à apprendre l'apprentissage automatique, cela peut sembler étrange - le fait que cela fonctionne vraiment, mais c'est ainsi que fonctionne l'apprentissage automatique! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons à notre exemple de conversion des degrés Celsius en degrés Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec un seul neurone, nous n'avons qu'un seul poids et un seul déplacement. Tu sais quoi? C'est exactement à quoi ressemble la formule de conversion des degrés Celsius en degrés Fahrenheit. Si nous substituons la </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et au lieu de </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous obtenons le modèle de transformation final! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous revenons aux résultats de notre modèle de la partie pratique, nous faisons attention au fait que les indicateurs de poids et de déplacement ont été «calibrés» de manière à correspondre approximativement aux valeurs de la formule.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons délibérément créé un tel exemple pratique afin de montrer clairement la comparaison exacte entre les poids et les décalages. En mettant l'apprentissage automatique en pratique, nous ne pouvons jamais comparer les valeurs des variables avec l'algorithme cible de cette manière, comme dans l'exemple ci-dessus. Comment pouvons-nous faire cela? Pas question, car nous ne connaissons même pas l'algorithme cible! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour résoudre les problèmes d'apprentissage automatique, nous testons diverses architectures de réseaux de neurones avec différents nombres de neurones - par essais et erreurs, nous trouvons les architectures et les modèles les plus précis et espérons qu'ils résoudront le problème dans le processus d'apprentissage. Dans la prochaine partie pratique, nous pourrons étudier des exemples spécifiques de cette approche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Restez en contact, car le plaisir commence maintenant!</font></font><br><br><h3>  Résumé </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette leçon, nous avons appris les approches de base de l'apprentissage automatique et appris comment fonctionnent les couches (couches </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">entièrement connectées </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vous avez formé votre premier modèle à convertir des degrés Celsius en degrés Fahrenheit. </font><font style="vertical-align: inherit;">Vous avez également appris les termes de base utilisés dans l'apprentissage automatique, tels que les propriétés, les exemples, les étiquettes. </font><font style="vertical-align: inherit;">Vous avez, entre autres, écrit les principales lignes de code en Python, qui sont l'épine dorsale de tout algorithme d'apprentissage automatique. </font><font style="vertical-align: inherit;">Vous avez vu qu'en quelques lignes de code, vous pouvez créer, former et demander une prédiction à partir d'un réseau de neurones en utilisant </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... et appel à l'action standard - inscrivez-vous, mettez un plus et partagez :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version vidéo de l'article</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Télégramme: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453558/">https://habr.com/ru/post/fr453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453542/index.html">Le robot à quatre pattes a pu remorquer un avion pesant 3,3 tonnes</a></li>
<li><a href="../fr453544/index.html">Décodeur à sept segments utilisant à la fois les sorties directes et inverses d'un compteur BCD</a></li>
<li><a href="../fr453546/index.html">Besoin d'un petit clavier - faites-le vous-même</a></li>
<li><a href="../fr453548/index.html">Nous ravivons le freinage du Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../fr453554/index.html">Comment Starlink de SpaceX a changé</a></li>
<li><a href="../fr453562/index.html">Événements numériques à Moscou du 27 mai au 2 juin</a></li>
<li><a href="../fr453564/index.html">Make it True - Développement d'un jeu de logique sur Unity</a></li>
<li><a href="../fr453566/index.html">Restaurer la légende: un appel à l'échange de données ouvertes pouvant aider à la restauration de Notre Dame</a></li>
<li><a href="../fr453568/index.html">Reconstruire une icône: un appel au partage des données ouvertes pour aider à restaurer Notre-Dame</a></li>
<li><a href="../fr453570/index.html">Microsoft Edge pour macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>