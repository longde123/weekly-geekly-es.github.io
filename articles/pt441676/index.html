<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💻 🛀🏿 🗓️ Como fazer amigos PLUTO e HDSDR 👨🏾‍💻 Ⓜ️ 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há pouco tempo, impulsivamente, comprou um transceptor SDR atraente para crianças e jovens - ADALM PLUTO. Para meu pesar, ele funciona com um monte de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como fazer amigos PLUTO e HDSDR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441676/"><img src="https://habrastorage.org/webt/dx/vl/5c/dxvl5cuxvc4qn7duv1lossoiz2c.jpeg"><br><br><p>  Há pouco tempo, impulsivamente, comprou um transceptor SDR atraente para crianças e jovens - ADALM PLUTO.  Para meu pesar, ele funciona com um monte de software para o LINUX, mas meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDSDR</a> favorito não é compatível.  Sem pensar duas vezes, comecei a lidar com esse problema e aqui está o que aconteceu: <br><a name="habracut"></a><br></p><p>  A Analog Devices dirige seu PLUTO aos alunos.  Todo o software para PLUTO está aberto e está disponível gratuitamente.  O site da empresa possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">página</a> onde você pode encontrar quase todas as informações necessárias sobre a operação do PLUTO.  A maior parte do software é escrita em Linux e os alunos são aconselhados a usar o GNU Radio, MATLAB, etc. <br><br></p><p>  Eu tenho um interesse de rádio puramente amador em PLUTO.  Um SDR com faixa de 70 MHz a 6 GHz (após <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">divulgação</a> ) por apenas 150 dólares americanos é um milagre.  Quantas experiências podem ser feitas!  Veja quanto tudo está integrado lá: <br><br></p><p><img src="https://habrastorage.org/webt/ao/wg/mn/aowgmnuvpv1nj7kzloexjef5-fy.jpeg"><br><br></p><p>  Aparentemente, o AD acredita que os próprios hams devem escrever drivers para programas populares; portanto, até recentemente, nem o SDR # era suportado.  Mas o SDR # não combina comigo, porque preciso de um bom suporte CAT em um programa para sincronizar a frequência com um transceptor.  Eu gostaria de tentar usar o HDSDR como um receptor panorâmico conectando-o à primeira frequência intermediária do transceptor.  Portanto, há apenas uma saída: integrar você mesmo o HDSDR e o PLUTO. <br><br></p><p>  Usando o Google, descobri rapidamente que, para resolver meu problema, preciso criar uma biblioteca ExtIO_.dll especial no formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Winrad</a> .  Essa biblioteca serve como uma ponte de software entre o HDSDR e o receptor SDR desejado.  Felizmente, a interface da biblioteca está bem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentada</a> .  Além disso, existem algumas implementações de bibliotecas prontas para vários receptores no github: RTL_SDR, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LimeSDR</a> , etc. Havia um lugar para ver como escrever código.  A biblioteca em si é bastante antiga, sem novas tecnologias, pura C89, como escreveram há 20 anos.  Pelo menos você não precisa aprender uma nova linguagem de programação, que já inspirou esperança de sucesso. <br><br></p><p>  Essencialmente, o ExtIO_.dll precisa ser implementado com dezenas de funções que permitem inicializar o equipamento SDR, iniciar e parar a recepção do sinal, salvar e restaurar as configurações especificadas.  Para mim, o momento mais incompreensível foi o formato da troca de dados de streaming entre o receptor e o HDSDR, mas mais sobre isso abaixo. <br><br></p><p>  Agora surgiu a questão de como controlar PLUTO programaticamente.  Na verdade, existem várias opções de controle.  Encontrei pelo menos dois: diretamente com o chip pela biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libad9361.dll</a> ou pela biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IIO</a> .  A última opção parecia mais simples e mais bem descrita para mim, então decidi.  Nesta biblioteca, todas as configurações de equipamento estão disponíveis na forma de algum tipo de estrutura XML; um elemento individual é acessado pelo nome textual da propriedade, o que é bastante conveniente.  Uma descrição mais detalhada da biblioteca pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  A enorme vantagem da biblioteca é que ela vem com utilitários de linha de comando, com os quais você sempre pode alterar rapidamente as configurações desejadas do receptor.  Portanto, você não precisa implementar todas as configurações de SDR na interface HDSDR; pode se dar bem com o mínimo necessário.  E carregar um filtro FIR exótico pode ser feito a partir da linha de comando, se é que existe alguma necessidade.  Fluxos de dados no IIO: <br><br></p><p><img src="https://habrastorage.org/webt/ce/dz/bh/cedzbhmsy9z56vdehgcoaas5hmk.png"><br><br></p><p>  Programaticamente, aprender como controlar o PLUTO a partir do HDSDR foi bastante rápido e fácil.  Foi um pouco mais difícil obter um resultado satisfatório no fluxo de dados, principalmente porque eu não tinha experiência anterior com SDR.  Aqui você precisa entender que os dados vêm do receptor SDR na forma de um fluxo de amostras I / Q / I / Q ... I / Q.  Cada amostra é um número inteiro de 16 bits sem sinal, dos quais apenas 12 bits de ordem inferior são importantes.  Ao mesmo tempo, o HDSDR tem uma dúzia de opções para receber fluxos de dados.  Qual é o mais conveniente e melhor não está totalmente claro para mim.  Como resultado, decidi pela opção, que no ExtIO é chamada exthwUSBdata16, ou seja,  na verdade, um a um, como a biblioteca IIO fornece dados. <br>  O próximo problema foi a transferência de dados entre os buffers de recebimento do IIO e o HDSDR.  O último recebe dados em blocos que são múltiplos de 512 bytes e o IIO não pode gerar dados nesse formato.  Eu tive que fazer um buffer intermediário e transferir o fluxo através dele.  O código de transmissão é mostrado abaixo. <br><br></p><p></p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DWORD WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GeneratorThreadProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __in LPVOID lpParameter )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> iqbuf[EXT_BLOCKLEN * <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> nbytes_rx; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p_dat, *p_end; <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> p_inc; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iqcnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pointer to sample in iqbuf while ( !gbExitThread ) { nbytes_rx = iio_buffer_refill(rxbuf); p_inc = iio_buffer_step(rxbuf); p_end = (char *)iio_buffer_end(rxbuf); for (p_dat = (char *)iio_buffer_first(rxbuf, rx0_i); p_dat &lt; p_end; p_dat += p_inc) { iqbuf[iqcnt++] = ((int16_t*)p_dat)[0]; iqbuf[iqcnt++] = ((int16_t*)p_dat)[1]; if (iqcnt == EXT_BLOCKLEN * 2) { // buffer full iqcnt = 0; pfnCallback(EXT_BLOCKLEN, 0, 0.0F, &amp;iqbuf[0]); } } } gbExitThread = false; gbThreadRunning = false; return 0; }</span></span></code> </pre> <br><p>  Utilizando o ciclo indicado, foi possível obter uma transferência de fluxo de 4 MS / s, acima desse valor, os dados não têm tempo para serem transmitidos e o sinal é recebido com gagueira, embora o ferro pareça ser capaz de enviar 20 MS / se ainda mais.  Aumentou a prioridade do encadeamento no qual o loop gira para THREAD_PRIORITY_TIME_CRITICAL, aumentou o tamanho dos buffers.  Nenhum resultado.  Além disso, quando o buffer foi aumentado para 1 MB, a recepção normal era impossível na vazão mínima.  Mais aqui não significa melhor.  Se você tem idéias sobre como aumentar a velocidade, compartilhe nos comentários. <br><br></p><p>  Devo dizer que 4 MS / s são suficientes para meus propósitos, a banda mais do que cobre qualquer banda HF amadora.  Sim, e nas faixas VHF e microondas o suficiente para a maioria das tarefas.  Como resultado, a biblioteca é gravada, a janela HDSDR com o PLUTO ativado para recepção é mais ou menos assim: <br><br></p><p><img src="https://habrastorage.org/webt/bz/sd/hb/bzsdhbg83dfjqv9iokbtcpwltbi.jpeg"><br><br></p><p>  Todo o código da biblioteca está disponível no github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Sinta-se à vontade para usá-lo em seus experimentos com o ADALM PLUTO. <br><br></p><p>  73 de R2AJP </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441676/">https://habr.com/ru/post/pt441676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441654/index.html">Como fazer um estágio em uma grande empresa de TI</a></li>
<li><a href="../pt441660/index.html">STM32F103C8T6 como unidade flash com sistema de arquivos FAT12</a></li>
<li><a href="../pt441664/index.html">Linus Torvalds não acredita que os servidores na arquitetura ARM substituam o x86. “Vendendo um modelo de 64 bits - idiotice”</a></li>
<li><a href="../pt441668/index.html">STM32. Prática de perda de peso ou dieta para o controlador</a></li>
<li><a href="../pt441674/index.html">Layout de teste? Fácil</a></li>
<li><a href="../pt441678/index.html">Física dos tornados de jogos: como a aerodinâmica é implementada em Just Cause 4 (tráfego)</a></li>
<li><a href="../pt441680/index.html">Programa de conferências Lua In Moscow 2019</a></li>
<li><a href="../pt441682/index.html">HyperX Fury 3D - SSD com um pedigree claro</a></li>
<li><a href="../pt441684/index.html">Previsões: as nuvens mudarão 2019</a></li>
<li><a href="../pt441686/index.html">Como implementamos o cache no banco de dados Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>