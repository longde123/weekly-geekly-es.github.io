<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¨ üíµ ‚è∏Ô∏è Desgra√ßa do SceneKit. Experi√™ncia Yandex com gr√°ficos 3D no iOS üò´ üöÅ üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sou jovem demais para morrer. 


 O SceneKit √© uma estrutura de gr√°ficos 3D de alto n√≠vel no iOS que ajuda a criar cenas e efeitos animados. Ele inclu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desgra√ßa do SceneKit. Experi√™ncia Yandex com gr√°ficos 3D no iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431880/"><p>  <i>Sou jovem demais para morrer.</i> </p><br><p>  O SceneKit √© uma estrutura de gr√°ficos 3D de alto n√≠vel no iOS que ajuda a criar cenas e efeitos animados.  Ele inclui um mecanismo f√≠sico, um gerador de part√≠culas e um conjunto de a√ß√µes simples para objetos 3D que permitem descrever a cena em termos de conte√∫do - geometria, materiais, ilumina√ß√£o, c√¢meras - e animar atrav√©s de uma descri√ß√£o das altera√ß√µes desses objetos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/de8/eb3/a60/de8eb3a6080bb48be4f407c07d1b122a.gif"></p><br><p> Hoje, examinaremos o SceneKit com um olhar atento e um pouco severo, mas primeiro, vamos examinar o b√°sico e ver como √© a cena 3D e o que precisa ser feito para cri√°-la. <a name="habracut"></a></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1fa/7d7/138/1fa7d71381bc0f217fe6ddff8a08e77f.png" alt="Uma cena mais simples de tr√™s n√≥s com geometria."><br>  <em>A cena mais simples de tr√™s n√≥s com geometria neles</em> </p><br><p>  Primeiro, voc√™ precisa criar a estrutura b√°sica da cena, que consiste em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√≥s</a> ou n√≥s da cena.  Cada n√≥ pode conter geometria e outros n√≥s.  A geometria pode ser simples, como uma bola, cubo ou pir√¢mide, ou mais complexa, criada em editores externos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9c/dd6/3ae/a9cdd63aeb3c662009d721feff5a2fa2.png" alt="Sobreposi√ß√£o de materiais"><br>  <em>Sobreposi√ß√£o de materiais</em> </p><br><p>  Ent√£o, para esta geometria, voc√™ precisa especificar os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">materiais</a> que determinar√£o a representa√ß√£o b√°sica dos objetos.  Cada material em si define seu pr√≥prio modelo de ilumina√ß√£o e, dependendo dele, usa um conjunto diferente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedades</a> .  Cada uma dessas propriedades geralmente √© uma cor ou textura, mas, al√©m dessas op√ß√µes comumente usadas, tamb√©m h√° a op√ß√£o de usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CALayer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVPlayer</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SKScene</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c1/ca5/831/0c1ca58318327b07263caf4f9d67ea63.png" alt="Adicionar fontes de ilumina√ß√£o"><br>  <em>Adicionar fontes de ilumina√ß√£o</em> </p><br><p>  Depois disso, voc√™ precisa adicionar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fontes de luz</a> que determinem o qu√£o bem os objetos s√£o vis√≠veis em uma ou outra parte da cena.  Eles, por analogia com a geometria, devem estar dentro de um n√≥.  O SceneKit suporta muitos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos</a> diferentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de ilumina√ß√£o</a> , bem como v√°rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos de sombras</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c16/a8e/f8e/c16a8ef8ebcfb7242eef1d8142b70dea.png" alt="Efeito boke pronto para uso"><br>  <em>Efeito Boke pronto para uso</em> </p><br><p>  Ent√£o voc√™ precisa criar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√¢mera</a> (e coloc√°-la em um n√≥ separado) e definir os par√¢metros b√°sicos para ela.  Existem muitos deles, mas com a ajuda deles voc√™ pode criar efeitos interessantes.  Fora da caixa, s√£o aceitas modifica√ß√µes de bokeh (ou desfoque), HDR com adapta√ß√£o, brilho, SSAO e matiz / satura√ß√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/76f/62c/908/76f62c908bda6280380c922e3a1e8ca3.gif" alt="Anima√ß√µes simples no SceneKit"><br>  <em>Anima√ß√µes simples no SceneKit</em> </p><br><p>  Por fim, o SceneKit inclui um conjunto simples de a√ß√µes para objetos 3D que permitem definir altera√ß√µes de cena ao longo do tempo.  O SceneKit tamb√©m suporta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a√ß√µes descritas em JavaScript</a> , mas este √© um t√≥pico para um artigo separado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/08c/0dc/2e4/08c0dc2e44e627e369af7dea6f18d27d.gif" alt="Uma intera√ß√£o de um gerador de sele√ß√£o com um motor f√≠sico pode levar a tornados!"><br>  <em>A intera√ß√£o de um gerador de part√≠culas com um motor f√≠sico pode levar a um tornado!</em> </p><br><p>  Al√©m dos gr√°ficos, os principais recursos do SceneKit s√£o o gerador de part√≠culas e um mecanismo f√≠sico avan√ßado que permite definir propriedades f√≠sicas reais para objetos e part√≠culas comuns do gerador. </p><br><p>  Um grande n√∫mero de tutoriais detalhados foi escrito sobre todos esses recursos.  Mas no processo de desenvolvimento, praticamente n√£o aproveitamos essas oportunidades ... </p><br><h2 id="hey-not-too-rough">  <strong>Ei, n√£o muito √°spero</strong> </h2><br><blockquote>  <em>Uma vez eu escrevi um modelo de ilumina√ß√£o para jogos 3D melhor do que a luz do sol real, fornecendo um FPS aceit√°vel na Nvidia 8800, mas decidi n√£o liberar o mecanismo, porque Deus √© bom comigo e n√£o quero mostrar sua incompet√™ncia nesse assunto.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Come√ßaremos um estudo detalhado com uma tarefa bastante simples que surge para quase todo mundo que trabalha com seriedade com o SceneKit: como carregar um modelo com geometria complexa e materiais conectados, materiais, ilumina√ß√£o e at√© anima√ß√µes? </p><br><p>  Existem v√°rias maneiras, e todas elas t√™m seus pr√≥s e contras: </p><br><ol><li><p>  SCNScene (nomeado :) - obt√©m uma cena de um pacote, </p><br></li><li><p>  SCNScene (url: options :) - carrega a cena por URL, </p><br></li><li><p>  SCNScene (mdlAsset :) - converte uma cena de diferentes formatos, </p><br></li><li><p>  SCNReferenceNode (url :) - carrega pregui√ßosamente a cena. </p><br></li></ol><br><h3 id="poluchaem-scenu-iz-bandla">  Obtenha a cena do pacote </h3><br><p>  Voc√™ pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√©todo padr√£o</a> : coloque nosso modelo no formato dae ou scn no pacote scnassets e carregue-o a partir da√≠ por analogia com UIImage (nomeado :). </p><br><p>  Mas e se voc√™ quiser controlar a atualiza√ß√£o dos modelos sem liberar uma atualiza√ß√£o na App Store toda vez que precisar alterar algumas texturas?  Ou suponha que voc√™ precise oferecer suporte a mapas e modelos criados pelo usu√°rio.  Ou - voc√™ simplesmente n√£o deseja aumentar o tamanho do aplicativo, pois os gr√°ficos 3D n√£o s√£o a principal funcionalidade. </p><br><h3 id="zagruzhaem-scenu-po-url">  Carregando a cena por URL </h3><br><p>  Voc√™ pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o construtor de cena a partir da URL do</a> arquivo scn.  Esse m√©todo suporta o download n√£o apenas do sistema de arquivos, mas tamb√©m da rede, mas, no √∫ltimo caso, voc√™ pode esquecer a compacta√ß√£o.  Al√©m disso, voc√™ precisa converter o modelo para o formato scn antecipadamente.  √â claro que voc√™ pode usar dae, mas com isso vem um conjunto de restri√ß√µes.  Por exemplo, a falta de renderiza√ß√£o com base fisicamente. </p><br><p>  A principal vantagem desse m√©todo √© que ele permite que voc√™ defina com flexibilidade as configura√ß√µes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">importa√ß√£o</a> .  Voc√™ pode, por exemplo, modificar o ciclo de vida das anima√ß√µes e faz√™-las repetir sem parar.  Voc√™ pode especificar explicitamente a fonte para carregar recursos externos, como texturas, converter a orienta√ß√£o e a escala da cena, criar normais ausentes para a geometria, mesclar toda a geometria da cena em um n√≥ grande ou descartar todos os elementos da cena que n√£o estejam em conformidade com o padr√£o de formato. </p><br><h3 id="konvertiruem-scenu-iz-raznyh-formatov">  Converta uma cena de diferentes formatos </h3><br><p>  A terceira op√ß√£o √© usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor com o MDLAsset</a> .  Ou seja, primeiro criamos um conjunto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MDLAs</a> , dispon√≠vel na estrutura ModelIO, e depois passamos para o construtor da cena. </p><br><p>  Essa op√ß√£o √© boa, pois permite baixar muitos formatos diferentes.  Oficialmente, o MDLAsset pode carregar os formatos obj, ply, stl e usd, mas, ap√≥s ter executado uma lista de todos os formatos poss√≠veis, pelo menos de alguma forma relacionados √† computa√ß√£o gr√°fica, encontrei mais quatro: abc, bsp, vox e md3, mas eles podem n√£o ser totalmente suportados ou n√£o em todos os sistemas e, para eles, √© necess√°rio verificar a corre√ß√£o da importa√ß√£o. </p><br><p>  Tamb√©m √© necess√°rio considerar que esse m√©todo possui uma sobrecarga para convers√£o e us√°-lo com muito cuidado. </p><br><p>  Esses m√©todos t√™m uma armadilha comum: eles retornam SCNScene, n√£o SCNNode.  A √∫nica maneira de adicionar conte√∫do a uma cena existente √© copiar todos os n√≥s filhos e - voc√™ pode pular facilmente esta etapa - anima√ß√µes do n√≥ raiz (por exemplo, elas podem aparecer l√° ao trabalhar com dae).  Al√©m disso, √© necess√°rio considerar que na cena s√≥ pode haver um ambiente de textura (se voc√™ n√£o usar shaders personalizados para reflex√µes). </p><br><h3 id="lenivo-zagruzhaem-scenu">  Pregui√ßosamente carregando a cena </h3><br><p>  A quarta op√ß√£o √© usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNReferenceNode</a> .  Ele n√£o retorna uma cena, mas um n√≥, que pode pregui√ßosamente (ou mediante solicita√ß√£o) carregar em si toda a hierarquia da cena.  Portanto, esse m√©todo √© semelhante ao primeiro, mas oculta dentro de si todos os problemas de c√≥pia. </p><br><p>  Ele tem uma coisa, mas: os par√¢metros globais da cena est√£o perdidos. </p><br><p>  Acontece que esta √© a maneira mais f√°cil e r√°pida de baixar seu modelo, mas se voc√™ precisar de ajuste de arquivo, o primeiro m√©todo ser√° melhor. </p><br><p>  Como resultado, decidimos pela primeira op√ß√£o, pois era mais conveniente trabalhar no formato scn e para designers - converter do formato dae para ele.  Al√©m disso, precis√°vamos de anima√ß√µes de ajuste de arquivo na inicializa√ß√£o. </p><br><h3 id="vovse-ne-prezhdevremennye-optimizacii">  Otimiza√ß√µes nada precoces </h3><br><p>  Tendo mexido nesse processo por um longo tempo, posso lhe dar alguns conselhos. </p><br><p>  A dica mais importante √© converter arquivos para scn com anteced√™ncia.  Ent√£o, voc√™ pode, ao abrir o arquivo no editor de cenas embutido no Xcode, ver como o seu objeto ficar√° no SceneKit. </p><br><p>  Al√©m disso, de fato, o arquivo scn √© apenas uma representa√ß√£o bin√°ria da cena; portanto, o carregamento dele levar√° menos tempo.  Para o mesmo dia, voc√™ deve primeiro analisar o xml e depois converter todas as malhas, anima√ß√µes e materiais.  Al√©m disso, a convers√£o de anima√ß√µes e materiais √© uma fonte potencial de problemas.  Recordamos a falta de suporte √† PBR em dae: acontece que, se voc√™ quiser us√°-lo, precisar√° alterar o tipo de todos os materiais ap√≥s a convers√£o e colocar manualmente as texturas apropriadas. </p><br><p>  Com esta opera√ß√£o, voc√™ pode obter um efeito colateral muito √∫til: compacta√ß√£o significativa de textura.  Basta abri-los no "View" e exportar, alterando o formato para heic.  Em m√©dia, essa opera√ß√£o simples economizou 5 megabytes por modelo. </p><br><p>  Al√©m disso, se voc√™ estiver baixando uma cena da Internet, posso aconselh√°-lo a fazer o download no arquivo, descompact√°-lo e transferir o URL do arquivo scn descompactado.  Isso economizar√° a voc√™ e ao usu√°rio megabytes extras - o que, por sua vez, acelerar√° o download e tamb√©m reduzir√° o n√∫mero de pontos de falha.  Concordo: fazer uma solicita√ß√£o separada para cada recurso externo e mesmo na Internet m√≥vel n√£o √© a melhor maneira de aumentar a confiabilidade. </p><br><h2 id="hurt-me-plenty">  <strong>Me machucou bastante</strong> </h2><br><blockquote>  <em>Quando dirijo um carro, ou√ßo frequentemente o disco r√≠gido do universo estalar, carregando a pr√≥xima rua.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Assim, quando o trabalho de carregar e importar modelos √© iniciado, surge uma nova tarefa: adicionar v√°rios efeitos e recursos √† cena.  E acredite, h√° algo a dizer.  Come√ßamos examinando as v√°rias constantes no SceneKit. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1e3/c0e/ffd/1e3c0effdc9c72b19d6e3d0a19a13796.png" alt="As restri√ß√µes no SceneKit s√£o permitidas ap√≥s a f√≠sica.  E antes de renderizar o quadro"><br>  <em>As restri√ß√µes no SceneKit s√£o consideradas imediatamente ap√≥s a f√≠sica.</em>  <em>E antes de renderizar o quadro</em> </p><br><p>  Restri√ß√µes, voc√™ diz?  Quais s√£o as constantes?  Poucas pessoas sabem, e mais ainda falam sobre isso, mas o SceneKit tem seu pr√≥prio conjunto de constantes.  E, embora n√£o sejam t√£o flex√≠veis quanto as constantes no UIkit, voc√™ ainda pode fazer muitas coisas interessantes com elas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/006/c01/3a3/006c013a36d0bc0f615ca4f4378e4767.gif" alt="SCNReplicatorConstraint"><br>  <em>SCNReplicatorConstraint</em> </p><br><p>  Vamos come√ßar com uma constante simples - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNReplicatorConstraint</a> .  Tudo o que ele faz √© duplicar a posi√ß√£o, rota√ß√£o e tamanho de outro objeto com compensa√ß√µes adicionais.  Como em todas as outras constantes, ele pode alterar a for√ßa e definir a bandeira da incrementalidade.  Ambos os par√¢metros podem ser melhor exibidos nesta constante. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd7/98d/a46/dd798da468df11e71ab53c7a41e187c5.gif" alt="For√ßa reduzida 10 vezes"><br>  <em>For√ßa reduzida 10 vezes</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A for√ßa</a> afeta quanta transforma√ß√£o √© aplicada ao objeto.  E como a posi√ß√£o do objeto alvo muda a cada quadro - o objeto sombra se aproxima de um d√©cimo da diferen√ßa de dist√¢ncia.  Por esse motivo, um efeito de atraso aparece. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/535/ec5/0bc/535ec50bce2b4e57f30c71226bc783da.gif" alt="Incremento aumentado e for√ßa reduzida em 10 vezes"><br>  <em>Incremento aumentado e for√ßa reduzida em 10 vezes</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A incrementalidade</a> , por sua vez, afeta se a constante √© cancelada ap√≥s a renderiza√ß√£o.  Suponha que desligamos.  Ent√£o, vemos que em cada quadro, a constante √© aplicada antes da renderiza√ß√£o e, ap√≥s a renderiza√ß√£o, √© cancelada e, portanto, cada quadro √© repetido.  Como resultado, combinando esses dois par√¢metros, voc√™ pode obter um efeito bastante interessante dos ponteiros do rel√≥gio. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/5c5/cfd/74d5c5cfd7bde6252adf7855705ec5ad.gif" alt="O avi√£o sempre fica √† frente da c√¢mera."><br>  <em>O avi√£o sempre fica de frente para a c√¢mera.</em> </p><br><p>  Vamos para uma constante mais interessante: o chamado outdoor. </p><br><p>  Suponhamos, √© necess√°rio que algum objeto esteja sempre "nos encarando".  Para fazer isso, basta usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNBillboardConstraint</a> , indicar em quais eixos o objeto pode girar.  Al√©m disso, antes de calcular cada quadro (ap√≥s um passo com a f√≠sica), as posi√ß√µes e orienta√ß√µes de todos os objetos ser√£o atualizadas para satisfazer todas as constantes. </p><br><p>  Aqui voc√™ pode mencionar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">restri√ß√£o de apar√™ncia</a> : √© semelhante a um outdoor, apenas o objeto pode ser definido de frente para qualquer outro objeto na cena, em vez da c√¢mera atual. </p><br><p>  O que pode ser feito com a ajuda deles?  Obviamente, na maioria das vezes essas constantes s√£o usadas para desenhar √°rvores ou objetos pequenos.  Eles tamb√©m criam efeitos especiais como fogo ou explos√£o.  Al√©m disso, com a ajuda deles, voc√™ pode fazer a c√¢mera seguir o objeto no palco. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/077/6ed/96d/0776ed96d0d6116c12ababd108bfe180.gif" alt="Manter dist√¢ncia entre os objetos"><br>  <em>Mant√©m a dist√¢ncia entre os objetos</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNDistanceConstraint</a> permite definir a dist√¢ncia m√≠nima e / ou m√°xima para a posi√ß√£o de outro objeto.  E sim, voc√™ pode us√°-lo para fazer uma cobra.  :) Essa restri√ß√£o tamb√©m pode ser usada para ligar a c√¢mera ao personagem, embora a posi√ß√£o da c√¢mera seja geralmente mais complicada, e descrev√™-la apenas com constru√ß√µes n√£o √© uma tarefa f√°cil.  O mesmo efeito pode ser alcan√ßado adicionando uma mola no mecanismo f√≠sico, mas essa mola pode ser suplementada com uma tens√£o, caso voc√™ precise evitar problemas com esticamento ou compress√£o excessiva da mola. </p><br><p>  Muitos viram em alguns Hitman, Fallout ou Skyrim: voc√™ arrasta um corpo com voc√™, ele toca em um obst√°culo - e come√ßa a se comportar como se um dem√¥nio tivesse entrado nele.  Essa constante ajudaria a evitar esses erros. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f8f/578/aca/f8f578aca5e9d78034dcef18062349b8.gif" alt="SCNSliderConstraint"><br>  <em>SCNSliderConstraint</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNSliderConstraint</a> permite definir a dist√¢ncia m√≠nima entre um determinado objeto e os corpos f√≠sicos com uma m√°scara de colis√£o adequada.  Constante bastante engra√ßada, mas, novamente, eles tentam simul√°-lo usando intera√ß√£o f√≠sica.  A id√©ia principal √© definir o raio da zona morta com corpos f√≠sicos para um objeto que n√£o possui um corpo f√≠sico. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/357/930/7df/3579307dfcf69c026734b0c35d7c6f04.gif" alt="Cinem√°tica inversa no trabalho"><br>  <em>Cinem√°tica inversa no trabalho</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCNIKConstraint</a> √© a constante mais interessante, mas tamb√©m a mais complexa, que usa a chamada cinem√°tica inversa.  Usando uma cadeia de n√≥s pais, a cinem√°tica inversa tenta iterativamente trazer a posi√ß√£o do n√≥ √† qual voc√™ aplica essa constante ao ponto necess√°rio.  De fato, permite que voc√™ n√£o pense em qual posi√ß√£o o ombro e o antebra√ßo devem estar, mas simplesmente defina a posi√ß√£o da m√£o e os poss√≠veis √¢ngulos de rota√ß√£o dos n√≥s de conex√£o.  O resto ser√° contado para voc√™.  A principal desvantagem dessa restri√ß√£o √© que ela permite definir apenas a posi√ß√£o da m√£o, mas n√£o sua orienta√ß√£o, e as restri√ß√µes nos √¢ngulos podem ser globalizadas, sem quebrar os eixos. </p><br><p>  Ent√£o, nos reunimos em detalhes com as constantes e com o que elas sabem fazer.  Vamos continuar a explorar efeitos interessantes.  Lidaremos com o efeito das sombras. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5d9/d62/4a4/5d9d624a480d96c5654a8df80be14115.gif" alt="Existe um avi√£o, mas n√£o √©"><br>  <em>Existe um avi√£o, mas n√£o √©</em> </p><br><p>  Parece que poderia ser mais f√°cil em um mecanismo que suporta sombras do que criar sombras?  Mas, √†s vezes, as sombras precisam ser projetadas em um plano completamente transparente.  Isso √© muito √∫til no ARKit, pois a imagem da c√¢mera √© exibida atr√°s do avi√£o e a sombra deve ser projetada em algum lugar.  O truque acaba sendo bastante simples: primeiro voc√™ precisa ativar sombras adiadas e desativar a grava√ß√£o em todos os componentes do plano na guia material, e a sombra continuar√° sobrepondo-a.  O √∫nico problema √© que este plano ir√° sobrepor os objetos por tr√°s dele. </p><br><p>  Mas as sombras n√£o s√£o o √∫nico efeito pouco estudado no SceneKit.  Vamos lidar com espelhos agora. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32d/75b/1ba/32d75b1ba50036e814d21bacb0104523.png" alt="Espelho SCNFloor - o que poderia ser mais simples"><br>  <em>Espelho SCNFloor - o que poderia ser mais simples</em> </p><br><p>  Todo mundo que brincou com o SceneKit provavelmente conhece o scnfloor, que adiciona reflexos no espelho ao ch√£o.  Mas, por alguma raz√£o, muito poucos o usam para reflex√µes honestas, porque voc√™ pode colocar seu modelo na geometria do piso, inclinar um pouco e transform√°-lo ... em um espelho comum. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c4/bdf/289/1c4bdf289fd13dd45489765512bc2d2a.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fdd/950/d98/fdd950d9889d35a4d8e66b871c0c2767.png" alt="Gotejamento em vidro e um espelho curvo"><br>  <em>Gotejamento em vidro e um espelho curvo</em> </p><br><p>  Mas, o que √© ainda menos conhecido, um mapa normal pode ser definido para esse g√™nero.  Por esse motivo, por sua vez, voc√™ pode criar muitos efeitos interessantes diferentes, como o efeito de listras ou um espelho curvo. </p><br><h2 id="ultra-violence">  <strong>Ultra-violeta</strong> </h2><br><blockquote>  <em>Certa vez, beijei uma garota de olhos abertos.</em>  <em>A menina cortou o rosto com o plano de recorte pr√≥ximo.</em>  <em>Desde ent√£o, beijo apenas com os olhos fechados.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Sombras, espelhos - efeitos interessantes.  Mas h√° um efeito que, quando usado com habilidade, pode se tornar ainda mais interessante - texturas de v√≠deo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/998/047/b54/998047b5496741e28e66d6faeb04f4a1.gif"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b7/91c/a6b/8b791ca6b8f464f5bd7401bdc07225ac.gif" alt="V√≠deos comuns e mapas de altura"><br>  <em>V√≠deos comuns e mapas de altura</em> </p><br><p>  Voc√™ pode precisar deles apenas para mostrar o v√≠deo dentro do jogo.  Mas √© muito mais interessante que, com a ajuda das texturas de v√≠deo, voc√™ pode modificar a geometria.  Para fazer isso, voc√™ precisa colocar a textura do v√≠deo com um mapa de altura na propriedade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deslocamento</a> do seu material e usar o material em um plano com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫mero</a> suficientemente grande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de segmentos</a> .  Resta entender como coloc√°-lo l√°. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mencionei</a> na descri√ß√£o do processo de cria√ß√£o de cena que voc√™ pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SKScene</a> como uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedade</a> material, e esta √© uma cena do SpriteKit.  SpriteKit √© como SceneKit, mas para gr√°ficos 2D.  Ele suporta a exibi√ß√£o de v√≠deos usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SKVideoNode</a> .  Voc√™ s√≥ precisa colocar o SKVideoNode no SKScene e o SKScene no SCNMaterialProperty e pronto. </p><br><p>  Mas depois de exportar a cena 3D resultante e abri-la em outro lugar, veremos um quadrado preto.  Vasculhando o arquivo scn, encontrei o motivo.  Acontece que, ao salvar um c√≥digo de v√≠deo, ele n√£o salva o URL do v√≠deo.  Parece que voc√™ toma e governa.  Mas nem tudo √© t√£o simples: o arquivo scn √© o chamado plist bin√°rio, que cont√©m o resultado do NSKeyedArchiver.  E o material, que √© a cena do SpriteKit, √© o mesmo c√≥digo bin√°rio, que, ao que parece, j√° est√° dentro de outro c√≥digo bin√°rio!  √â bom que haja apenas dois n√≠veis de aninhamento. </p><br><p>  Bem, agora vamos at√© o efeito, mas para uma ferramenta que permite criar qualquer tipo de efeito.  Estes s√£o modificadores de sombreador. </p><br><p>  Antes de modificar algo, voc√™ precisa entender o que estamos modificando.  Um sombreador, por defini√ß√£o, √© um programa para a GPU que √© executado para cada v√©rtice e para cada pixel.  Assim, um sombreador √© um programa que determina a apar√™ncia de um objeto na tela. </p><br><p>  Bem, modificadores de shader permitem alterar os resultados dos shaders padr√£o para GLSL ou Metal Shading Language.  Eles tamb√©m est√£o dispon√≠veis em um editor visual, que permite ver altera√ß√µes no modificador em tempo real. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/663/9d1/9a7/6639d19a72901a50caea2b969816a1ae.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/94a/660/1d194a660488fe33aa392c0573834ca4.png" alt="Mapeamento de peles e paralaxe"><br>  <em>Mapeamento de peles e paralaxe</em> </p><br><p>  Com a ajuda de modificadores de sombreador, voc√™ pode criar efeitos visuais complexos.  Por exemplo, alguns dos efeitos mais famosos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mapeamento de</a> peles e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paralaxe</a> . </p><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma arguments texture2d bg; texture2d height; float depth; float layers; #pragma transparent #pragma body constexpr sampler sm = sampler(filter::linear, s_address::repeat, t_address::repeat); float3 bitangent = cross(_surface.tangent, _surface.normal); float2 direction = float2(-dot(_surface.view.rgb, _surface.tangent), dot(_surface.view.rgb, _surface.bitangent)); _output.color.rgba = float4(0); for(int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; int(floor(layers)); i++) { float coeff = float(i) / floor(layers); float2 defaultCoords = _surface.diffuseTexcoord + direction * (1 - coeff) * depth; float2 adjustment = float2(scn_frame.sinTime + defaultCoords.x, scn_frame.cosTime) * depth * coeff * 0.1; float2 coords = defaultCoords + adjustment; _output.color.rgb += bg.sample(sm, coords).rgb * coeff * (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); _output.color.a += (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); } return _output;</span></span></span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/7aa/b5f/b0e/7aab5fb0e907d2a7290f0f31e415e4be.gif" alt="Ray Casting com c√°usticos em tempo real."><br>  <em>Fundi√ß√£o de raios com c√°usticos em tempo real</em> </p><br><p>  Mais interessante, ningu√©m se incomoda em jogar completamente fora os resultados de seu trabalho e escrever seu pr√≥prio renderizador.  Por exemplo, voc√™ pode tentar implementar o Ray Casting em shaders.  E tudo isso funciona r√°pido o suficiente para fornecer 30 FPS, mesmo em c√°lculos t√£o complexos.  Mas este √© um t√≥pico para um relat√≥rio separado.  Vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mobius</a> ! </p><br><h2 id="nightmare">  <strong>Pesadelo!</strong> </h2><br><blockquote>  <em>Eu n√£o gosto de piscar, porque as p√°lpebras fechadas carregam fortemente a GPU para BDPT devido √† falta de ilumina√ß√£o.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Ent√£o, temos um monte de objetos com efeitos interessantes.  Agora resta aprender a grav√°-las.  Para fazer isso, vamos para um t√≥pico mais complexo: como aprendemos a gravar v√≠deos diretamente do SceneKit sem uma interface de usu√°rio externa e como otimizamos essa grava√ß√£o dezenas de vezes. </p><br><p>  Vamos primeiro procurar a solu√ß√£o mais simples: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReplayKit</a> .  Descubra por que ele n√£o se encaixa.  De um modo geral, esta solu√ß√£o permite criar uma entrada de tela em v√°rias linhas de c√≥digo e salv√°-la atrav√©s da visualiza√ß√£o do sistema.  Mas  Ele tem muito menos - ele grava tudo, toda a interface do usu√°rio, incluindo todos os bot√µes na tela.  Esta foi a nossa primeira decis√£o, mas por raz√µes √≥bvias, era imposs√≠vel deix√°-lo em produ√ß√£o: os usu√°rios tinham que compartilhar o v√≠deo e n√£o da visualiza√ß√£o do sistema. </p><br><p>  Nos encontramos em uma situa√ß√£o em que a solu√ß√£o precisava ser escrita do zero.  Absolutamente do zero.  Ent√£o, vamos ver como no iOS voc√™ pode criar seu pr√≥prio v√≠deo e gravar seus quadros l√°.  Tudo √© bem simples: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bd5/ce3/0f8/bd5ce30f8b449cba0a5fbe8d68d2a420.png" alt="Processo de grava√ß√£o"><br>  <em>Processo de grava√ß√£o</em> </p><br><p>  Precisamos criar uma entidade que registre arquivos - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVAssetWriter</a> , adicione um fluxo de v√≠deo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVAssetWriterInput a ele</a> e crie um adaptador para esse fluxo que converta nosso buffer de pixel no formato exigido pelo fluxo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVAssetWriterPixelBufferAdaptor</a> . </p><br><p>  S√≥ por precau√ß√£o, lembro que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer de pixels</a> √© uma entidade, que √© um peda√ßo de mem√≥ria em que os dados dos pixels s√£o de alguma forma gravados.  Esta √© essencialmente uma representa√ß√£o de baixo n√≠vel da imagem. </p><br><p>  Mas como obter esse buffer de pixel?  A solu√ß√£o √© simples.  O SCNView possui uma maravilhosa fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.snapshot ()</a> que retorna uma UIImage.  N√≥s apenas precisamos criar um buffer de pixel a partir desta UIImage. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let rgbColorSpace = <span class="hljs-built_in"><span class="hljs-built_in">CGColorSpaceCreateDeviceRGB</span></span>() let bitmapInfo = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>(rawValue: <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>.byteOrder32Little.rawValue | <span class="hljs-built_in"><span class="hljs-built_in">CGImageAlphaInfo</span></span>.premultipliedFirst.rawValue) let rowBytes = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer)) let context = <span class="hljs-built_in"><span class="hljs-built_in">CGContext</span></span>( data: data, width: image.width, height: image.height, bitsPerComponent: <span class="hljs-number"><span class="hljs-number">8</span></span>, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer), space: rgbColorSpace, bitmapInfo: bitmapInfo.rawValue ) context?.draw(image, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: image.width, height: image.height)) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  N√≥s apenas alocamos um lugar na mem√≥ria, descrevemos qual o formato desses pixels, bloqueamos o buffer para alterar, obtemos o endere√ßo de mem√≥ria, criamos um contexto no endere√ßo recebido, onde descrevemos como os pixels s√£o compactados, quantas linhas existem na imagem e que espa√ßo de cores usamos.  Em seguida, copiamos os pixels da UIImage l√°, conhecendo o formato final e desbloqueamos a altera√ß√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ba0/e25/5a0/ba0e255a03515ee7e299bfa3d2757526.png"></p><br><p>  Agora voc√™ precisa fazer isso em todos os quadros.  Para fazer isso, criamos um link de exibi√ß√£o que chamar√° um retorno de chamada para cada quadro, onde, por sua vez, chamaremos o m√©todo snapshot e criaremos um buffer de pixel a partir da imagem.  Tudo √© simples! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab9/6fa/841/ab96fa8410458c0854d2c6b74bfb488c.gif"></p><br><p>  Mas n√£o.  Essa solu√ß√£o, mesmo em telefones poderosos, causa atrasos terr√≠veis e rebaixamentos de FPS.  Vamos fazer a otimiza√ß√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b13/562/6e6/b135626e6d19559cb931b0d62e20e0d3.png"></p><br><p>  Digamos que n√£o precisamos de 60 FPS.  N√≥s ficaremos satisfeitos com o dia 25.  Mas qual √© a maneira mais f√°cil de alcan√ßar esse resultado?  Obviamente, voc√™ s√≥ precisa colocar tudo isso em um thread de segundo plano.  Al√©m disso, de acordo com os desenvolvedores, essa fun√ß√£o √© segura para threads. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/701/d7c/a26/701d7ca267899b726966bcefacd2921e.gif"></p><br><p>  Hmm, o atraso ficou menor, mas o v√≠deo parou de gravar ... </p><br><p>  Tudo √© simples.  Como se costuma dizer, se voc√™ tiver um problema e o resolver√° com a ajuda de v√°rios threads, ter√° 2 problemas. </p><br><p>  Se voc√™ tentar gravar um buffer de pixels com um carimbo de data e hora menor que o √∫ltimo gravado, o v√≠deo inteiro ser√° inv√°lido. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/643/ed3/f61/643ed3f61dd84093f38c4447952d2a8b.png"></p><br><p>  N√£o vamos escrever um novo buffer at√© que a grava√ß√£o anterior termine. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/335/c9f/544/335c9f544b1bfd080a34cfe03847235a.gif"></p><br><p>  Hmm, ficou muito melhor  Mas, mesmo assim, por que os atrasos apareceram inicialmente? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef1/b9d/838/ef1b9d8381334a5b0d6c9c4952eea020.png"></p><br><p>  Acontece que a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.snapshot ()</a> , com a qual obtemos uma imagem da tela, cria um novo renderizador para cada chamada, desenha um quadro a partir do zero e o devolve, n√£o a imagem que est√° na tela.  Isso leva a efeitos divertidos.  Por exemplo, a simula√ß√£o f√≠sica √© duas vezes mais r√°pida. </p><br><p>  Mas espere - por que tentamos renderizar um novo quadro toda vez?  Certamente em algum lugar voc√™ pode encontrar o buffer que √© exibido na tela.  De fato, existe acesso a esse buffer, mas √© muito discreto.  Precisamos obter o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAMetalDrawable</a> do Metal. </p><br><p>  Infelizmente, chegar ao Metal diretamente do SCNView n√£o √© t√£o f√°cil por uma raz√£o bastante compreens√≠vel - no SceneKit, voc√™ pode escolher o tipo de API, mas se voc√™ olhar por baixo do cap√¥ e ver a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">camada</a> , poder√° ver que ele age como ele, no caso do Metal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAMetalLayer</a> . </p><br><p>  Mas aqui tamb√©m a falha nos espera: no CAMetalLayer, a √∫nica maneira de interagir com a visualiza√ß√£o √© a fun√ß√£o nextDrawable, que retorna um CAMetalDrawable desocupado.  Entende-se que voc√™ gravar√° dados nele e chamar√° a fun√ß√£o atual, que os exibir√° na tela. </p><br><p>  A solu√ß√£o realmente existe.  O fato √© que, depois de desaparecer da tela, o buffer n√£o √© desalocado, mas apenas colocado de volta no pool.  De fato, por que alocar mem√≥ria toda vez que dois ou tr√™s buffers s√£o suficientes: um √© mostrado na tela, o segundo para renderiza√ß√£o e o terceiro, por exemplo, para p√≥s-processamento, se voc√™ tiver um. </p><br><p>  Acontece que, ap√≥s exibir o buffer, os dados dele n√£o desaparecem em lugar algum e voc√™ pode acess√°-los com seguran√ßa. </p><br><p>  E se n√≥s, no sucessor, come√ßarmos em resposta a cada chamada para nextDrawable () para salv√°-lo, obteremos quase o que precisamos.  O problema √© que o CAMetalDrawable salvo √© aquele em que a imagem est√° sendo desenhada agora. </p><br><p>  O salto para a solu√ß√£o real √© muito simples - salvamos o Drawable atual e o anterior. </p><br><p>  E aqui est√°, pronto - acesso direto √† mem√≥ria atrav√©s do CAMetalDrawable. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let width: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.width let height: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.height let rowBytes: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer) lastDrawable.texture.getBytes( data, bytesPerRow: rowBytes, fromRegion: <span class="hljs-built_in"><span class="hljs-built_in">MTLRegionMake2D</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height), mipmapLevel: <span class="hljs-number"><span class="hljs-number">0</span></span> ) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Portanto, agora n√£o criamos um contexto e desenhamos uma UIImage nele, mas copiamos um peda√ßo de mem√≥ria para outro.  Surge a pergunta: e o formato de pixel? </p><br><p>  N√£o corresponde ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deviceColorSpace</a> ... E n√£o corresponde aos espa√ßos de cores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais usados</a> ... </p><br><p>  Este √© exatamente o ponto em que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> autor de um dos lares p√∫blicos, que executa a mesma tarefa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quebrou</a> .  Todo mundo nem chegou aqui. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/181/bc7/198181bc7d908bca2ec56df495010106.gif"></p><br><p>  Bem, todos esses truques - por um filtro assustador? </p><br><p>  Bem, n√£o!  No artigo sobre o ARKit, √© poss√≠vel mencionar que a imagem da c√¢mera n√£o usa o espa√ßo de cores padr√£o, mas expandida.  E at√© uma matriz de transforma√ß√£o do espa√ßo de cores √© apresentada.  Mas por que se envolver na transforma√ß√£o, se voc√™ pode tentar gravar diretamente nesse formato?  Resta descobrir qual √© o formato dos 60 dispon√≠veis ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/75d/802/781/75d8027810eb481eaa1775bd122cb79a.gif"></p><br><p>  E ent√£o eu comecei a rebentar.  Gravei tr√™s v√≠deos em diferentes transmiss√µes com diferentes formatos, substituindo-os a cada grava√ß√£o. </p><br><p>  Como resultado, no formato quadrag√©simo, obtemos o nome.  Acontece que n√£o √© outro sen√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kCVPixelFormatType_30RGBLEPackedWideGamut</a> .  Como eu n√£o adivinhei? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d6e/2e6/31e/d6e2e631e3dfdc690c85222a51561446.gif"></p><br><p>  Mas minha alegria durou at√© o primeiro testador.  Eu n√£o tinha palavras.  Como  Passei muito tempo procurando o formato certo.  √â bom que o problema seja localizado rapidamente - o bug foi reproduzido de forma est√°vel e apenas no 6s e 6s Plus.  Quase imediatamente depois disso, lembrei-me de que os monitores com suporte de ampla gama come√ßaram a ser instalados apenas nos s√©timos iPhones. </p><br><p>  Mudando a gama ampla para o bom e velho 32RGBA, recebo um recorde de trabalho!  Resta entender como determinar se o dispositivo suporta ampla gama.  Existem iPads com diferentes tipos de tela e achei que com certeza voc√™ pode obter o tipo de tela ENUM do sistema.  Revendo a documenta√ß√£o, eu achei - este √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">displayGamut</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UITraitCollection</a> . </p><br><p>  Tendo entregue a montagem aos testadores, recebi not√≠cias agrad√°veis ‚Äã‚Äãdeles - tudo funcionou sem atrasos, mesmo em dispositivos antigos! </p><br><p>  Em conclus√£o, quero lhe dizer - fa√ßa gr√°ficos 3D!  Em nosso aplicativo, para o qual a realidade aumentada n√£o √© o principal caso de uso, no fim de semana, as pessoas percorreram mais de 2.000 quil√¥metros, assistiram a mais de 3.000 objetos e gravaram mais de 1.000 v√≠deos com eles!  Imagine o que voc√™ pode fazer se voc√™ mesmo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431880/">https://habr.com/ru/post/pt431880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431870/index.html">Desenvolvedor de livros interativos com LEDs reclama do roubo de id√©ias por funcion√°rios do Google</a></li>
<li><a href="../pt431872/index.html">Guia do JavaScript Parte 9: Vis√£o geral dos padr√µes ES7, ES8 e ES9</a></li>
<li><a href="../pt431874/index.html">Imba: linguagem compat√≠vel com JavaScript para um trabalho r√°pido com DOM</a></li>
<li><a href="../pt431876/index.html">Otimiza√ß√£o de aplica√ß√µes angulares</a></li>
<li><a href="../pt431878/index.html">Recursos JavaScript pouco conhecidos</a></li>
<li><a href="../pt431884/index.html">Microsoft superou a Apple em capitaliza√ß√£o de mercado: como isso aconteceu?</a></li>
<li><a href="../pt431886/index.html">Al Lowy carregou sua cole√ß√£o de c√≥digos fonte dos produtos Sierra no eBay</a></li>
<li><a href="../pt431888/index.html">"Acho que as id√©ias da equipe s√£o as mais importantes no desenvolvimento de um produto."</a></li>
<li><a href="../pt431890/index.html">Como fazer um pedido na troca freelance</a></li>
<li><a href="../pt431894/index.html">Em dezembro, eles decidir√£o sobre o registro obrigat√≥rio de esta√ß√µes base LPWAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>