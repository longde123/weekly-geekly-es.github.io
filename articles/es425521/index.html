<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üôÉ üíæ M√©todos protegidos en JavaScript ES5 üé£ üßëüèª‚Äçü§ù‚Äçüßëüèª üëÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se han escrito muchos art√≠culos excelentes sobre el modelo de objetos en JavaScript. Y sobre las diversas formas de crear miembros de clase privada en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todos protegidos en JavaScript ES5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425521/">  Se han escrito muchos art√≠culos excelentes sobre el modelo de objetos en JavaScript.  Y sobre las diversas formas de crear miembros de clase privada en Internet est√° lleno de descripciones valiosas.  Pero sobre los m√©todos protegidos, hay muy pocos datos.  Me gustar√≠a llenar este vac√≠o y decirle c√≥mo puede crear m√©todos protegidos sin bibliotecas en JavaScript puro ECMAScript 5. <br><br>  En este articulo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPor qu√© se necesitan miembros de la clase protegida?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo que necesitas para entender el m√©todo presentado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Helper Class ProtectedError</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n de miembros protegidos (m√©todos y propiedades) para clases declaradas como funciones (ECMAScript 5)</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace al repositorio de git-hub con c√≥digo fuente y pruebas.</a> <a name="habracut"></a><br><br><h2>  ¬øPor qu√© se necesitan miembros de la clase protegida? </h2><br>  En resumen, entonces <br><br><ul><li>  es m√°s f√°cil entender el funcionamiento de la clase y encontrar errores en ella.  (Puede ver inmediatamente en qu√© caso se usan los miembros de la clase. Si es privado, entonces necesita analizar solo esta clase, bueno, y si est√° protegido, entonces solo esto y las clases derivadas). </li><li>  Cambio m√°s f√°cil de gestionar.  (Por ejemplo, puede eliminar miembros privados sin temor a que algo fuera de la clase editable se rompa). </li><li> se reduce la cantidad de aplicaciones en el rastreador de errores, porque  los usuarios de la biblioteca o el control pueden "coser" en nuestros miembros "privados", que decidimos eliminar en la nueva versi√≥n de la clase, o cambiar la l√≥gica de su trabajo. </li><li>  Y, en general, los miembros de la clase protegida son una herramienta de dise√±o.  Es bueno tenerlo a mano y bien probado. </li></ul><br>  Perm√≠tame recordarle que la idea principal de los miembros protegidos es ocultar m√©todos y propiedades de los usuarios de la instancia de clase, pero al mismo tiempo permitir que las clases derivadas tengan acceso a ellos. <br><br>  El uso de TypeScript no permitir√° llamar a m√©todos protegidos, sin embargo, despu√©s de la compilaci√≥n en JavaScript, todos los miembros privados y protegidos se hacen p√∫blicos.  Por ejemplo, desarrollamos un control o biblioteca que los usuarios instalar√°n en sus sitios o aplicaciones.  Estos usuarios podr√°n hacer lo que quieran con miembros protegidos, violando la integridad de la clase.  Como resultado, nuestro rastreador de errores est√° lleno de quejas de que nuestra biblioteca o control no funciona correctamente.  Dedicamos tiempo y esfuerzo a resolverlo: <i>"¬øes as√≠ como estaba el objeto en ese estado del cliente, lo que provoc√≥ un error?"</i>  .  Por lo tanto, para facilitar la vida de todos, se necesita tal protecci√≥n que no permita cambiar el significado de los miembros de la clase privados y protegidos. <br><br><h2>  Lo que necesitas para entender el m√©todo en cuesti√≥n </h2><br>  Para comprender el m√©todo de declarar miembros de clase protegidos, necesita un conocimiento s√≥lido: <br><br><ul><li>  clases de dispositivo y objetos en JavaScript. </li><li>  formas de crear miembros de la clase privada (al menos a trav√©s del cierre). </li><li>  m√©todos Object.defineProperty y Object.getOwnPropertyDescriptor </li></ul><br>  Sobre el modelo de dispositivo en JavaScript, puedo recomendar, por ejemplo, un excelente art√≠culo de Andrey Akinshin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">DreamWalker</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚ÄúComprender la POO en JS [Parte No. 1]‚Äù</a> . <br>  En cuanto a las propiedades privadas, hay una buena y, en mi opini√≥n, una descripci√≥n bastante completa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hasta 4 formas diferentes de crear miembros de clases privadas</a> en el sitio web de MDN. <br><br>  En cuanto al m√©todo Object.defineProperty, nos permitir√° ocultar propiedades y m√©todos de los bucles for-in y, como resultado, de los algoritmos de serializaci√≥n: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedNumber'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicNumber = <span class="hljs-number"><span class="hljs-number">25</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj1){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'property:'</span></span> prop); <span class="hljs-comment"><span class="hljs-comment">//prop     'protectedNumber' } console.log(JSON.stringify(obj1)); //  { 'publicNumber': 25 }</span></span></code> </pre> <br>  Tal ocultamiento debe realizarse, pero esto, por supuesto, no es suficiente porque  Todav√≠a existe la posibilidad de llamar al m√©todo / propiedad directamente: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1.protectedNumber); <span class="hljs-comment"><span class="hljs-comment">//  12.</span></span></code> </pre><br><h2>  Helper Class ProtectedError </h2><br>  Primero, necesitamos la clase ProtectedError, que hereda de Error, y que se generar√° si no hay acceso al m√©todo o propiedad protegidos. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtectedError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = <span class="hljs-string"><span class="hljs-string">"Encapsulation error, the object member you are trying to address is protected."</span></span>; } ProtectedError.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); ProtectedError.prototype.constructor = ProtectedError;</code> </pre><br><h2>  Implementaci√≥n de miembros de clase protegidos en ES5 </h2><br>  Ahora que tenemos la clase ProtectedError y entendemos lo que hace Object.defineProperty con el valor enumerable: falso, analicemos la creaci√≥n de una clase base que quiera compartir el m√©todo protectedMethod con todas sus clases derivadas, pero ocult√°moslo a todos los dem√°s: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,        /** @summary       */ function checkAccess() { if (!(this instanceof BaseClass)) throw new ProtectedError(); if (this.constructor === BaseClass) throw new ProtectedError() } Object.defineProperty(_self, 'protectedMethod', { enumerable: false, //    for-in  configurable:false, //     value: function(){ //   , ,          Base,     checkAccess.call(this); //  . protectedMethod(); } }); function protectedMethod(){ //       , //       this,   _self return 'example value'; } this.method = function (){ protectedMethod(); //          BaseClass //this.protectedMethod(); //   , ..      ProtectedError } }</span></span></code> </pre><br><h3>  Descripci√≥n del constructor de la clase BaseClass </h3><br>  Quiz√°s te confundir√° el cheque: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre>  Esta prueba es un "aficionado".  Puede eliminarlo; no tiene nada que ver con los m√©todos protegidos.  Sin embargo, personalmente lo dejo en mi c√≥digo, porque  es necesario para aquellos casos en que la instancia de clase no se crea correctamente, es decir  sin la palabra clave new.  Por ejemplo, as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = BaseClass(); <span class="hljs-comment"><span class="hljs-comment">//  : var obj2 = BaseClass.call({});</span></span></code> </pre><br>  En tales casos, haga lo que desee.  Puede, por ejemplo, generar un error: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong instance creation. Maybe operator "new" was forgotten'</span></span>);</code> </pre><br>  O simplemente puede crear instancias correctamente, como se hace en BaseClass. <br><br>  A continuaci√≥n, guardamos la nueva instancia en la variable _self (por qu√© necesito explicar esto m√°s adelante). <br><br><h3>  Descripci√≥n de una propiedad p√∫blica llamada protectedMethod </h3><br>  Al ingresar el m√©todo, llamamos a la verificaci√≥n de contexto en la que fuimos llamados.  Es mejor verificar en un m√©todo separado, por ejemplo, checkAccess, porque  se necesitar√° la misma verificaci√≥n en todos los m√©todos y propiedades protegidos de las clases.  Entonces, antes que nada, verifique el tipo de contexto de la llamada a esto.  Si este tiene un tipo distinto de BaseClass, entonces el tipo no es BaseClass ni ninguno de sus derivados.  Prohibimos tales llamadas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  ¬øC√≥mo puede pasar esto?  Por ejemplo, as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someObject = {}; b.protectedMethod.call(someObject); <span class="hljs-comment"><span class="hljs-comment">//   ,  protectedMethod this   someObject    , .. someObject instanceof BaseClass  </span></span></code> </pre><br>  En el caso de las clases derivadas, la expresi√≥n esta instancia de BaseClass ser√° verdadera.  Pero para las instancias de BaseClass, esta instancia de la expresi√≥n de BaseClass ser√° verdadera.  Por lo tanto, para distinguir instancias de la clase BaseClass de instancias de clases derivadas, verificamos el constructor.  Si el constructor coincide con BaseClass, se llama a nuestro m√©todo protegido en la instancia de BaseClass, al igual que un m√©todo p√∫blico normal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); b.protectedMethod();</code> </pre><br>  Prohibimos tales llamadas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === BaseClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Luego viene la llamada del m√©todo cerrado protectedMethod, que, de hecho, es el m√©todo que protegemos.  Dentro del m√©todo, si necesita referirse a los miembros de la clase BaseClass, puede hacerlo utilizando la instancia almacenada de _self.  Esto es exactamente lo que _self fue creado para tener acceso a los miembros de la clase desde todos los m√©todos privados / privados.  Por lo tanto, si no necesita acceder a los miembros de la clase en su m√©todo o propiedad protegidos, no puede crear la variable _self. <br><br><h3>  Llamar a un m√©todo protegido dentro de la clase BaseClass </h3><br>  Dentro de la clase BaseClass, se debe acceder a protectedMethod solo por nombre, no a trav√©s de esto.  De lo contrario, dentro de protectedMethod no podemos distinguir si fuimos llamados como m√©todo p√∫blico o desde dentro de una clase.  En este caso, el cierre nos salva: protectedMethod se comporta como un m√©todo privado normal, cerrado dentro de la clase y visible solo dentro del alcance de la funci√≥n BaseClass. <br><br><h3>  DerivedClass Derived Class Descripci√≥n </h3><br>  Ahora veamos una clase derivada y c√≥mo hacerla accesible para un m√©todo protegido de una clase base. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protectedMethod.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">/** @summary       */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError(); } <span class="hljs-comment"><span class="hljs-comment">//     Object.defineProperty(this, 'protectedMethod', { enumerable: false, // ..       this configurable: false,//         for-in  //      value: function(){ checkAccess.call(_self); return _base.protectedMethod(); } }); //        this.someMethod = function(){ console.log(_base.protectedMethod()); } } DerivedClass.prototype = new BaseClass(); Object.defineProperty(DerivedClass.prototype, 'constructor', { value : DerivedClass, configurable: false });</span></span></code> </pre><br><h3>  Descripci√≥n del constructor de clase derivada </h3><br>  En la clase derivada, creamos un objeto _base en el que colocamos una referencia al m√©todo protectedMethod de la clase base, cerrado al contexto de la clase derivada a trav√©s del m√©todo de enlace est√°ndar.  Esto significa que llamar a _base.protectedMethod ();  dentro de protectedMethod, este no es un objeto _base, sino una instancia de la clase DerivedClass. <br><br><h3>  M√©todo protegido M√©todo Descripci√≥n Dentro de DerivedClass </h3><br>  En la clase DerivedClass, es necesario declarar el m√©todo p√∫blico protectedMethod de la misma manera que lo hicimos en la clase base a trav√©s de Object.defineProperty y verificar el acceso llamando al m√©todo checkAccess o ingresando directamente en el m√©todo: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedMethod'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _base.protectedMethod(); } });</code> </pre><br>  Verificamos: <i>"¬øpero nos han llamado como un m√©todo p√∫blico simple?"</i>  Para instancias de la clase DerivedClass, el constructor ser√° igual a DerivedClass.  Si es as√≠, entonces genera un error.  De lo contrario, lo enviamos a la clase base y ya realizar√° todas las dem√°s comprobaciones. <br><br>  Entonces, en la clase derivada, tenemos dos funciones.  Uno se declara a trav√©s de Object.defineProperty y es necesario para las clases derivadas de DerivedClass.  Es p√∫blico y, por lo tanto, tiene un cheque que proh√≠be las llamadas p√∫blicas.  El segundo m√©todo se encuentra en el objeto _base, que est√° cerrado dentro de la clase DerivedClass y, por lo tanto, no es visible para nadie desde el exterior y se utiliza para acceder al m√©todo protegido desde todos los m√©todos DerivedClass. <br><br><h3>  Protecci√≥n de la propiedad </h3><br>  Con las propiedades, el trabajo ocurre un poco diferente.  Las propiedades en BaseClass se definen como de costumbre a trav√©s de Object.defineProperty, solo en getters y setters primero debe agregar nuestro cheque, es decir  llamada checkAccess: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _protectedProperty; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _protectedProperty = value; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }</code> </pre><br>  Dentro de la clase BaseClass, se accede a la propiedad protegida no a trav√©s de esto, sino a la variable cerrada _protectedProperty.  Si es importante para nosotros que el getter y el setter funcionen al usar la propiedad dentro de la clase BaseClass, entonces debemos crear m√©todos privados getProtectedPropety y setProtectedProperty, dentro de los cuales no habr√° comprobaciones, y ya deber√≠an llamarse. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProtectedProperty(); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setProtectedProperty(value); }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtectedProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return _protectedProperty; } function setProtectedProperty(value){ //    _protectedProperty = value; } }</span></span></code> </pre><br>  En las clases derivadas, trabajar con propiedades es un poco m√°s complicado porque  la propiedad no se puede reemplazar por contexto.  Por lo tanto, usaremos el m√©todo est√°ndar Object.getOwnPropertyDescriptor para obtener el captador y definidor de la propiedad de la clase base como funciones que ya pueden usarse para cambiar el contexto de la llamada: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: _self.protectedMethod.bind(_self), }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _baseProtectedPropertyDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(_self, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      _base //    DerivedClass     Object.defineProperty(_base, 'protectedProperty', { get: function() { return _baseProtectedPropertyDescriptor.get.call(_self); }, set: function(value){ _baseProtectedPropertyDescriptor.set.call(_self, value); } }) //      ,      DerivedClass      . Object.defineProperty(_self, 'protectedProperty', { get: function () { checkAccess.call(_self); return base.protectedProperty; }, set: function (value) { checkAccess.call(_self); _base.protectedProperty = value; }, enumerable: false, configurable: false }); }</span></span></code> </pre><br><h3>  Descripci√≥n de la herencia </h3><br>  Y lo √∫ltimo que me gustar√≠a comentar es la herencia de DerivedClass de BaseClass.  Como ya sabr√°s, DerivedClass.prototype = new BaseClass ();  no solo crea un prototipo, sino que tambi√©n reescribe su propiedad de constructor.  Debido a esto, para cada instancia de DerivedClass, la propiedad del constructor se vuelve igual a BaseClass.  Para solucionar esto, generalmente despu√©s de crear un prototipo, reescribe la propiedad del constructor: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); DerivedClass.prototype.constructor = DerivedClass;</code> </pre><br>  Sin embargo, para que nadie reescriba esta propiedad despu√©s de nosotros, usamos el mismo Object.defineProperty.  La propiedad configurable: false evita que la propiedad se anule nuevamente: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : DerivedClass, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425521/">https://habr.com/ru/post/es425521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425505/index.html">An√°lisis del proceso de arranque del kernel de Linux</a></li>
<li><a href="../es425507/index.html">Parsim Wikipedia para tareas de PNL en 4 equipos</a></li>
<li><a href="../es425511/index.html">Caracter√≠sticas no obvias de la aplicaci√≥n Rotativa para generar PDF en la aplicaci√≥n ASP.NET MVC</a></li>
<li><a href="../es425515/index.html">Apple bloquea la reparaci√≥n independiente de los nuevos modelos de MacBook</a></li>
<li><a href="../es425517/index.html">C√≥mo Yandex cre√≥ un pron√≥stico de precipitaci√≥n global utilizando radares y sat√©lites</a></li>
<li><a href="../es425525/index.html">Tim Berners-Lee sigue el camino de la guerra: "Un peque√±o paso para la web ..."</a></li>
<li><a href="../es425527/index.html">Listas en Kotlin. Enfoque de Haskell</a></li>
<li><a href="../es425529/index.html">Sans Forgetica: una fuente que te permite memorizar un poco mejor lo que lees</a></li>
<li><a href="../es425531/index.html">Refrigeraci√≥n l√≠quida de freno. Opciones de desarrollo del sistema</a></li>
<li><a href="../es425533/index.html">C√≥mo trabajar en la nube: desde verificar la confiabilidad de un centro de datos hasta administrar una infraestructura virtual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>