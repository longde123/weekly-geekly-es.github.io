<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦏 🔊 👨🏾‍🚒 Pintasan JavaScript untuk pemula 🕒 🥇 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penutupan adalah salah satu konsep dasar JavaScript, menyebabkan kesulitan bagi banyak pemula, yang harus diketahui dan dipahami oleh setiap programme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pintasan JavaScript untuk pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424967/">  Penutupan adalah salah satu konsep dasar JavaScript, menyebabkan kesulitan bagi banyak pemula, yang harus diketahui dan dipahami oleh setiap programmer JS.  Memiliki pemahaman yang baik tentang penutupan, Anda dapat menulis kode yang lebih baik, lebih efisien, dan lebih bersih.  Dan ini, pada gilirannya, akan berkontribusi pada pertumbuhan profesional Anda. <br><br>  Bahan, terjemahan yang kami terbitkan hari ini, dikhususkan untuk sebuah cerita tentang mekanisme internal penutupan dan bagaimana mereka bekerja dalam program JavaScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu penutupan?</font> </h2><br>  Penutupan adalah fungsi yang memiliki akses ke ruang lingkup yang dibentuk oleh fungsi eksternal relatif terhadapnya, bahkan setelah fungsi eksternal ini menyelesaikan pekerjaannya.  Ini berarti bahwa penutupan dapat menyimpan variabel yang dideklarasikan dalam fungsi eksternal dan argumen diteruskan ke sana.  Sebelum kita melanjutkan ke penutupan, kita akan memahami konsep "lingkungan leksikal". <br><br><h2>  <font color="#3AC1EF">Apa itu lingkungan leksikal?</font> </h2><br>  Istilah "lingkungan leksikal" atau "lingkungan statis" dalam JavaScript mengacu pada kemampuan untuk mengakses variabel, fungsi, dan objek berdasarkan lokasi fisik mereka dalam kode sumber.  Pertimbangkan sebuah contoh: <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br>  Di sini, fungsi <code>inner()</code> memiliki akses ke variabel yang dideklarasikan dalam cakupannya sendiri, dalam lingkup fungsi <code>outer()</code> , dan dalam lingkup global.  Fungsi <code>outer()</code> memiliki akses ke variabel yang dideklarasikan dalam ruang lingkupnya sendiri dan dalam ruang lingkup global. <br><br>  Rantai lingkup kode di atas akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br>  Perhatikan bahwa fungsi <code>inner()</code> dikelilingi oleh lingkungan leksikal dari fungsi <code>outer()</code> , yang pada gilirannya dikelilingi oleh cakupan global.  Itulah sebabnya fungsi <code>inner()</code> dapat mengakses variabel yang dideklarasikan di fungsi <code>outer()</code> dan dalam lingkup global. <br><br><h2>  <font color="#3AC1EF">Contoh praktis dari penutupan</font> </h2><br>  Pertimbangkan, sebelum membongkar seluk-beluk sirkuit internal, beberapa contoh praktis. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Di sini kita memanggil fungsi <code>person()</code> , yang mengembalikan fungsi internal <code>displayName()</code> , dan menyimpan fungsi ini dalam <code>peter</code> variabel.  Ketika, setelah ini, kita memanggil fungsi <code>peter()</code> (variabel yang sesuai sebenarnya menyimpan referensi ke fungsi <code>displayName()</code> ), nama <code>Peter</code> ditampilkan di konsol. <br><br>  Pada saat yang sama, tidak ada variabel <code>displayName()</code> dalam <code>displayName()</code> , sehingga kita dapat menyimpulkan bahwa fungsi ini entah bagaimana dapat mengakses variabel yang dinyatakan dalam fungsi eksternal untuk itu, <code>person()</code> , bahkan setelah itu bagaimana fungsi ini bekerja.  Mungkin ini karena fungsi <code>displayName()</code> sebenarnya adalah penutup. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Di sini, seperti pada contoh sebelumnya, kami menyimpan tautan ke fungsi internal anonim yang dikembalikan oleh fungsi <code>getCounter()</code> dalam jumlah variabel.  Karena fungsi <code>count()</code> adalah closure, ia dapat mengakses variabel <code>counter</code> dari fungsi <code>getCount()</code> bahkan setelah fungsi <code>getCounter()</code> telah menyelesaikan pekerjaannya. <br><br>  Perhatikan bahwa nilai variabel <code>counter</code> tidak diatur ulang ke 0 setiap kali fungsi <code>count()</code> dipanggil.  Mungkin tampaknya harus diatur ulang ke 0, seperti ketika memanggil fungsi biasa, tetapi ini tidak terjadi. <br><br>  Ini berfungsi seperti itu karena setiap kali fungsi <code>count()</code> dipanggil, lingkup baru dibuat untuk itu, tetapi hanya ada satu lingkup untuk fungsi <code>getCounter()</code> .  Karena variabel <code>counter</code> dideklarasikan dalam lingkup fungsi <code>getCounter()</code> , nilainya antara panggilan ke fungsi <code>count()</code> disimpan tanpa mengatur ulang ke 0. <br><br><h2>  <font color="#3AC1EF">Bagaimana cara kerja hubung singkat?</font> </h2><br>  Sejauh ini, kami telah berbicara tentang apa penutupan itu, dan memeriksa contoh-contoh praktis.  Sekarang mari kita bicara tentang mekanisme JavaScript internal yang membuatnya bekerja. <br><br>  Untuk memahami penutupan, kita perlu berurusan dengan dua konsep JavaScript penting.  Ini adalah Konteks Eksekusi dan Lingkungan Leksikal. <br><br><h3>  <font color="#3AC1EF">▍ Konteks eksekusi</font> </h3><br>  Konteks eksekusi adalah lingkungan abstrak tempat kode JavaScript dihitung dan dieksekusi.  Ketika kode global dieksekusi, ini terjadi di dalam konteks eksekusi global.  Kode fungsi dieksekusi dalam konteks eksekusi fungsi. <br><br>  Pada titik waktu tertentu, kode dapat dieksekusi hanya dalam satu konteks eksekusi (JavaScript adalah bahasa pemrograman single-threaded).  Proses-proses ini dikelola menggunakan apa yang disebut Call Stack. <br><br>  Tumpukan panggilan adalah struktur data yang disusun sesuai dengan prinsip LIFO (Last In, First Out - Last In, First Out).  Elemen baru hanya dapat ditempatkan di bagian atas tumpukan, dan hanya elemen yang dapat dihapus darinya. <br><br>  Konteks eksekusi saat ini akan selalu berada di atas tumpukan, dan ketika fungsi saat ini keluar, konteks eksekusi diambil dari tumpukan dan kontrol ditransfer ke konteks eksekusi, yang terletak di bawah konteks fungsi ini di tumpukan panggilan. <br><br>  Pertimbangkan contoh berikut untuk lebih memahami apa konteks eksekusi dan tumpukan panggilan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">Contoh Konteks Eksekusi</font></i> <br><br>  Ketika kode ini dieksekusi, mesin JavaScript membuat konteks eksekusi global untuk mengeksekusi kode global, dan ketika bertemu dengan fungsi <code>first()</code> , membuat konteks eksekusi baru untuk fungsi ini dan menempatkannya di atas tumpukan. <br><br>  Tumpukan panggilan dari kode ini terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">Tumpukan panggilan</font></i> <br><br>  Ketika eksekusi fungsi <code>first()</code> selesai, konteks eksekusi diambil dari tumpukan panggilan dan kontrol ditransfer ke konteks eksekusi di bawahnya, yaitu ke konteks global.  Setelah itu, kode yang tersisa di lingkup global akan dieksekusi. <br><br><h3>  <font color="#3AC1EF">EnvironmentLingkungan leksikal</font> </h3><br>  Setiap kali mesin JS membuat konteks eksekusi untuk mengeksekusi fungsi atau kode global, itu juga menciptakan lingkungan leksikal baru untuk menyimpan variabel yang dideklarasikan dalam fungsi ini selama eksekusi. <br><br>  Lingkungan leksikal adalah struktur data yang menyimpan informasi tentang korespondensi pengidentifikasi dan variabel.  Di sini, "pengidentifikasi" adalah nama variabel atau fungsi, dan "variabel" adalah referensi ke objek (ini termasuk fungsi) atau nilai tipe primitif. <br><br>  Lingkungan leksikal mengandung dua komponen: <br><br><ul><li>  Catatan lingkungan adalah tempat di mana deklarasi variabel dan fungsi disimpan. </li><li>  Referensi ke lingkungan luar - tautan yang memungkinkan Anda untuk mengakses lingkungan leksikal (induk) eksternal.  Ini adalah komponen paling penting yang perlu ditangani untuk memahami penutupan. </li></ul><br>  Secara konseptual, lingkungan leksikal terlihat seperti ini: <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br>  Lihatlah potongan kode berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br>  Ketika mesin JS menciptakan konteks eksekusi global untuk mengeksekusi kode global, itu juga menciptakan lingkungan leksikal baru untuk menyimpan variabel dan fungsi yang dideklarasikan dalam lingkup global.  Akibatnya, lingkungan leksikal dari lingkup global akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br>  Harap dicatat bahwa referensi ke lingkungan leksikal eksternal ( <code>outer</code> ) diatur ke <code>null</code> , karena ruang lingkup global tidak memiliki lingkungan leksikal eksternal. <br><br>  Ketika mesin membuat konteks eksekusi untuk fungsi <code>first()</code> , itu juga menciptakan lingkungan leksikal untuk menyimpan variabel yang dideklarasikan dalam fungsi ini selama eksekusi.  Akibatnya, lingkungan leksikal dari fungsi akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Tautan ke lingkungan leksikal eksternal dari fungsi diatur ke <code>&lt;globalLexicalEnvironment&gt;</code> , karena dalam kode sumber kode fungsi berada dalam lingkup global. <br><br>  Harap dicatat bahwa ketika fungsi selesai kerjanya, konteks eksekusi diambil dari tumpukan panggilan, tetapi lingkungan leksikalnya dapat dihapus dari memori, atau mungkin tetap ada.  Itu tergantung pada apakah di lingkungan leksikal lain ada referensi ke lingkungan leksikal ini dalam bentuk tautan ke lingkungan leksikal eksternal. <br><br><h2>  <font color="#3AC1EF">Analisis rinci tentang contoh-contoh bekerja dengan penutupan</font> </h2><br>  Sekarang setelah kami mempersenjatai diri dengan pengetahuan tentang konteks eksekusi dan lingkungan leksikal, kami akan kembali ke penutupan dan menganalisis fragmen kode yang sama lebih mendalam yang sudah kami periksa. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 1</font> </h3><br>  Lihatlah potongan kode ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Ketika fungsi <code>person()</code> dieksekusi, mesin JS menciptakan konteks eksekusi baru dan lingkungan leksikal baru untuk fungsi ini.  Pekerjaan selesai, fungsi mengembalikan fungsi <code>displayName()</code> , referensi ke fungsi ini ditulis ke <code>peter</code> variabel. <br><br>  Lingkungan leksikalnya akan terlihat seperti ini: <br><br><pre> <code class="hljs powershell">personLexicalEnvironment = { environmentRecord: {   name : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reference</span></span></span><span class="hljs-function">&gt; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-function">: &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">globalLexicalEnvironment</span></span></span><span class="hljs-function">&gt; }</span></span></code> </pre> <br>  Ketika fungsi <code>person()</code> keluar, konteks eksekusi muncul dari tumpukan.  Tetapi lingkungan leksikalnya tetap ada dalam memori, karena ada tautan ke dalamnya di lingkungan leksikal dari fungsi internalnya <code>displayName()</code> .  Akibatnya, variabel yang dideklarasikan dalam lingkungan leksikal ini tetap tersedia. <br><br>  Ketika fungsi <code>peter()</code> dipanggil (variabel yang sesuai menyimpan referensi ke fungsi <code>displayName()</code> ), mesin JS menciptakan konteks eksekusi baru dan lingkungan leksikal baru untuk fungsi ini.  Lingkungan leksikal ini akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  Tidak ada variabel dalam fungsi <code>displayName()</code> , jadi catatan lingkungannya akan kosong.  Selama pelaksanaan fungsi ini, mesin JS akan mencoba menemukan variabel <code>name</code> di lingkungan leksikal dari fungsi. <br><br>  Karena pencarian tidak dapat ditemukan di lingkungan leksikal dari fungsi <code>displayName()</code> , pencarian akan berlanjut di lingkungan leksikal eksternal, yaitu di lingkungan leksikal fungsi <code>person()</code> , yang masih dalam memori.  Di sana, mesin menemukan variabel yang diinginkan dan menampilkan nilainya di konsol. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Lingkungan leksikal dari fungsi <code>getCounter()</code> akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Fungsi ini mengembalikan fungsi anonim yang ditugaskan ke variabel <code>count</code> . <br><br>  Ketika fungsi <code>count()</code> dieksekusi, lingkungan leksikalnya terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br>  Saat melakukan fungsi ini, sistem akan mencari variabel <code>counter</code> di lingkungan leksikalnya.  Dalam kasus ini, sekali lagi, catatan lingkungan fungsi kosong, sehingga pencarian variabel berlanjut di lingkungan leksikal eksternal dari fungsi. <br><br>  Mesin menemukan variabel, menampilkannya di konsol, dan menambah variabel <code>counter</code> , yang disimpan dalam lingkungan leksikal dari fungsi <code>getCounter()</code> . <br><br>  Akibatnya, lingkungan leksikal dari fungsi <code>getCounter()</code> setelah panggilan pertama ke fungsi <code>count()</code> akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Setiap kali fungsi <code>count()</code> dipanggil, mesin JavaScript membuat lingkungan leksikal baru untuk fungsi ini dan menambah variabel <code>counter</code> , yang mengarah pada perubahan lingkungan leksikal dari fungsi <code>getCounter()</code> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami berbicara tentang apa penutupan itu dan menyortir mekanisme JavaScript yang mendasarinya.  Penutupan adalah salah satu konsep dasar JavaScript yang paling penting, dan setiap pengembang JS harus memahaminya.  Memahami penutupan adalah salah satu langkah untuk menulis aplikasi yang efektif dan berkualitas tinggi. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda memiliki pengalaman dalam pengembangan JS, silakan bagikan contoh praktis menggunakan penutupan dengan pemula. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424967/">https://habr.com/ru/post/id424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424955/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 332 (24 - 30 September 2018)</a></li>
<li><a href="../id424957/index.html">Menghasilkan Gambar dari Teks Menggunakan AttnGAN</a></li>
<li><a href="../id424961/index.html">MTA-STS untuk Postfix</a></li>
<li><a href="../id424963/index.html">Pendanaan Zuckerberg: Alat Bangun untuk Sains Bersama</a></li>
<li><a href="../id424965/index.html">Bereaksi Pengembangan Aplikasi Menggunakan ReasonReact</a></li>
<li><a href="../id424969/index.html">Panduan Node.js, Bagian 9: Bekerja dengan Sistem File</a></li>
<li><a href="../id424971/index.html">Habrokast "Sunset Manually" # 1. Mencoba mengatur lingkungan untuk mengembangkan mainan untuk Windows</a></li>
<li><a href="../id424973/index.html">Deteksi Wajah pada Video: Raspberry Pi dan Neural Compute Stick</a></li>
<li><a href="../id424975/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 2. Skema data sebagai refleksi dari model "dunia"</a></li>
<li><a href="../id424977/index.html">Belajar dari kesalahan: mengoptimalkan aplikasi di App Store dan Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>