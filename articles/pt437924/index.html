<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üßô ü§≥üèø Fragmento de Blockchain üõÄüèø üë®üèª‚Äç‚öñÔ∏è ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° a todos, sou um dos desenvolvedores do Near Protocol, que, entre outras coisas, implementa sharding, e neste artigo quero contar em detalhes o que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fragmento de Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Ol√° a todos, sou um dos desenvolvedores do Near Protocol, que, entre outras coisas, implementa sharding, e neste artigo quero contar em detalhes o que √© sharding no blockchain, como ele funciona e abordar v√°rios problemas que surgem ao tentar constru√≠-lo. </p><br><p>  √â sabido que o Ethereum, a plataforma dApps mais popular, processa menos de 20 transa√ß√µes por segundo.  Devido a essa restri√ß√£o, o pre√ßo das transa√ß√µes e o tempo para confirm√°-las s√£o muito altos: apesar do fato de um bloco ser publicado no Ethereum uma vez a cada 10 a 12 segundos, de acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ETH Gas Station, o</a> tempo entre o envio de uma transa√ß√£o e como ela realmente se encaixa no bloco √© uma m√©dia de 1,2 minutos.  Baixa largura de banda, pre√ßos altos e confirma√ß√£o de transa√ß√£o longa n√£o permitem o lan√ßamento de nenhum servi√ßo de alto desempenho no Ethereum. </p><br><p>  O principal motivo pelo qual o Ethereum n√£o pode processar mais de 20 transa√ß√µes por segundo √© porque todos os n√≥s no Ethereum precisam verificar todas as transa√ß√µes.  Nos cinco anos desde o lan√ßamento do Ethereum, muitas id√©ias foram propostas para resolver este problema.  Essas solu√ß√µes podem ser divididas em dois grupos: aqueles que oferecem delegar transa√ß√µes para um pequeno grupo de n√≥s com hardware muito bom e aqueles que oferecem cada n√≥ para processar apenas um subconjunto de todas as transa√ß√µes.  Um exemplo da primeira abordagem √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thunder</a> , no qual os blocos s√£o criados por apenas um n√≥, o que permite, de acordo com os desenvolvedores, receber 1200 transa√ß√µes por segundo, o que √© 100 vezes mais que o Ethereum.  Outros exemplos da primeira categoria s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solana</a> .  Todos esses protocolos aprimoram v√°rios aspectos do protocolo e permitem realizar mais transa√ß√µes do que no Ethereum, mas todos s√£o limitados pela velocidade de uma m√°quina (embora muito poderosa). </p><a name="habracut"></a><br><p>  A segunda abordagem, na qual cada n√≥ processa apenas um subconjunto de transa√ß√µes, √© chamada Sharding.  √â assim que a Ethereum Foundation planeja aumentar a largura de banda do Ethereum. </p><br><p>  Neste post, mostrarei como o Sharding funciona no Blockchain usando o exemplo de v√°rios protocolos atualmente em desenvolvimento. </p><br><div class="spoiler">  <b class="spoiler_title">Terminologia</b> <div class="spoiler_text"><p>  Como a terminologia n√£o √© padronizada, usarei os seguintes termos em russo no artigo: </p><br><p>  <strong>Uma blockchain</strong> √© uma tecnologia em geral ou uma estrutura de dados que cont√©m todos os blocos, incluindo garfos. </p><br><p>  <strong>Uma cadeia</strong> √© uma cadeia espec√≠fica na cadeia de blocos, ou seja, todos os blocos que s√£o alcan√ß√°veis ‚Äã‚Äãa partir de um bloco usando links para o bloco anterior. </p><br><p>  <strong>A cadeia can√¥nica</strong> √© uma cadeia na blockchain que o participante assistindo a blockchain considera a cadeia atual.  Por exemplo, na blockchain Prova de Trabalho, ser√° a cadeia com maior complexidade. </p><br><p>  <strong>Uma rede</strong> √© composta por muitos participantes construindo e usando blockchain. </p><br><p>  <strong>Um n√≥</strong> √© um servidor que suporta ou usa uma rede. </p></div></div><br><h2 id="samyy-prostoy-sharding">  O sharding mais f√°cil </h2><br><p>  Na implementa√ß√£o mais simples, em vez de suportar uma blockchain, daremos suporte a v√°rias e chamaremos cada uma dessas blockchain de "fragmento".  Cada shard √© suportado por um conjunto independente de n√≥s que verifica transa√ß√µes e cria blocos.  A seguir, chamarei esses validadores de n√≥s. </p><br><p>  Cada fragmento √© respons√°vel por um subconjunto de contratos e contas.  Por enquanto, suponha que as transa√ß√µes sempre operem apenas com contratos e contas no mesmo fragmento.  Um design t√£o simplificado √© suficiente para mostrar alguns problemas e recursos interessantes do sharding. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Nomea√ß√£o de Validadores e Blockchain Central </h2><br><p>  O primeiro problema com o fato de que cada fragmento tem seus pr√≥prios validadores √© que, se tivermos 10 shadras, cada fragmento agora √© 10 vezes menos confi√°vel do que uma blockchain seria.  Portanto, se um blockchain com validadores X decide fazer um hard fork em um sistema de shard com 10 shards e quebra os validadores X entre 10 shards, agora existem apenas validadores X / 10 em cada shard, e obter controle sobre o shard exige um controle acima de 5,1% (51 % / 10) validadores. </p><br><p>  O que leva √† primeira pergunta interessante: quem atribui validadores a shards?  Ter controle sobre 5,1% dos validadores √© um problema apenas se todos os 5,1% dos validadores estiverem no mesmo fragmento.  Se os pr√≥prios validadores n√£o puderem escolher a qual shard eles est√£o atribu√≠dos, obter controle sobre 5,1% dos validadores antes de serem atribu√≠dos aos shards n√£o permitir√° que eles obtenham controle sobre nenhum shards. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="imagem"></p><br><p>  Quase todos os projetos de sharding propostos existentes usam alguma fonte de n√∫meros aleat√≥rios para atribuir validadores a shards.  A obten√ß√£o de n√∫meros aleat√≥rios em um sistema distribu√≠do no qual os participantes n√£o confiam um no outro n√£o √© um problema completamente resolvido hoje, que n√£o abordaremos neste artigo, e simplesmente assuma que temos uma fonte de n√∫meros aleat√≥rios. </p><br><p>  Tanto o recebimento de n√∫meros aleat√≥rios quanto a nomea√ß√£o de validadores s√£o c√°lculos em uma escala de todo o sistema que n√£o s√£o espec√≠ficos para nenhum fragmento espec√≠fico.  Para esses c√°lculos, os projetos modernos de blockchain de fragmentos t√™m um blockchain dedicado adicional que existe apenas para realizar c√°lculos em todo o sistema.  Al√©m dos n√∫meros aleat√≥rios e da nomea√ß√£o de validadores, esses c√°lculos podem incluir a obten√ß√£o de hashes dos √∫ltimos blocos dos shards e armazen√°-los;  processamento de garantias em sistemas de Prova de Aposta e estudo de evid√™ncias de comportamento inadequado com a sele√ß√£o associada dessas garantias;  rebalanceamento de fragmentos, se essa fun√ß√£o for fornecida.  Esse blockchain √© chamado de cadeia Beacon no Ethereum 2.0 e Near Protocol, a cadeia Relay no PolkaDot e o Cosmos Hub no Cosmos. </p><br><p>  Neste post, chamaremos esse blockchain de "blockchain central".  A exist√™ncia de uma blockchain central nos leva ao pr√≥ximo t√≥pico interessante - fragmenta√ß√£o quadr√°tica. </p><br><h2 id="kvadratichnoe-shardirovanie">  Fragmenta√ß√£o quadr√°tica </h2><br><p>  O sharding √© frequentemente apresentado como uma solu√ß√£o que √© dimensionada infinitamente com o n√∫mero crescente de n√≥s.  Provavelmente, voc√™ pode realmente criar um sistema com essa propriedade, mas os sistemas com uma blockchain central t√™m um limite m√°ximo no n√∫mero de shards e, como resultado, n√£o t√™m escalabilidade infinita.  √â f√°cil entender o porqu√™: o blockchain central realiza alguns c√°lculos, como atribuir validadores e preservar os √∫ltimos estados de shard, cuja complexidade √© proporcional ao n√∫mero de shards.  Como o pr√≥prio blockchain central n√£o √© fragmentado e seu rendimento √© limitado pelo rendimento de cada n√≥, o n√∫mero de shards que ele pode suportar √© limitado. </p><br><p>  Vamos ver como a taxa de transfer√™ncia de todo o sistema muda se a pot√™ncia dos n√≥s que o suportam aumenta k vezes.  Cada shard poder√° processar k vezes mais transa√ß√µes, e o blockchain central poder√° suportar k vezes mais shards.  Assim, a taxa de transfer√™ncia de todo o sistema aumentar√° k ^ 2 vezes.  Da√≠ o nome "fragmenta√ß√£o quadr√°tica". </p><br><p>  √â dif√≠cil prever quanto shard pode suportar o blockchain central hoje, mas provavelmente no futuro pr√≥ximo n√£o chegaremos perto do limite de transa√ß√µes para um blockchain fragmentado com sharding quadr√°tico.  Provavelmente, em breve chegaremos ao limite de quantos n√≥s s√£o necess√°rios para suportar um n√∫mero t√£o grande de shards. </p><br><h2 id="shardirovanie-sostoyaniya">  Estilha√ßamento de estado </h2><br><p>  Status s√£o todas as informa√ß√µes sobre todas as contas e contratos.  At√© agora, falamos sobre sharding em geral, sem especificar o que exatamente √© sharding.  Os n√≥s no blockchain executam as tr√™s tarefas a seguir: 1) realizam transa√ß√µes 2) encaminham transa√ß√µes e blocos para outros n√≥s e 3) armazenam o estado e o hist√≥rico do blockchain.  Cada uma dessas tr√™s tarefas est√° associada a uma carga cada vez maior nos n√≥s: </p><br><ol><li>  A necessidade de realizar transa√ß√µes requer mais poder computacional, com um aumento no n√∫mero de transa√ß√µes; </li><li>  A necessidade de encaminhar transa√ß√µes requer mais largura de banda de rede √† medida que as transa√ß√µes crescem; </li><li>  A necessidade de manter estado e hist√≥rico requer mais espa√ßo em disco √† medida que o tamanho do estado e / ou hist√≥rico aumenta.  √â importante observar que, diferentemente dos dois primeiros pontos, a quantidade de espa√ßo em disco necess√°rio aumenta mesmo que o n√∫mero de transa√ß√µes por unidade de tempo n√£o seja alterado. </li></ol><br><p>  A partir da lista acima, pode parecer que o espa√ßo em disco √© o maior problema, pois apenas o espa√ßo em disco aumenta mesmo que o n√∫mero de transa√ß√µes n√£o aumente, mas na pr√°tica n√£o √©.  Hoje, o estado do Ethereum ocupa cerca de 100 GB, que podem ser facilmente salvos em qualquer m√°quina moderna, mas o n√∫mero de transa√ß√µes que o Ethereum pode processar √© limitado a v√°rias dezenas por segundo, dependendo do poder e da rede da computa√ß√£o. </p><br><p>  O Zilliqa √© o projeto mais famoso que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fragmenta a computa√ß√£o e a rede,</a> mas n√£o afirma.  O sharding de computa√ß√£o √© mais simples que o estado de sharding, porque todos os n√≥s t√™m todo o estado e ainda podem executar facilmente contratos que causam outros contratos ou afetam contas em diferentes shards.  Nesses aspectos, o design de Zilliqa √© muito simplificado. As cr√≠ticas ao design em ingl√™s podem ser lidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Embora o sharding de estado sem c√°lculos de sombreamento tenha sido proposto, eu n√£o conhe√ßo nenhum projeto que realmente fa√ßa isso, ent√£o assumiremos que o sharding de estado implica c√°lculos de sharding. </p><br><p>  Na pr√°tica, o fato de o estado ser fragmentado de alguma forma isola os fragmentos, permitindo que eles sejam cadeias independentes, como definimos acima.  Os validadores nos shards armazenam apenas um estado espec√≠fico para o shard, e apenas as transa√ß√µes que afetam esse estado s√£o executadas e encaminhadas.  Isso reduz a carga no processador, disco e rede linearmente com o n√∫mero de shards, mas traz novos problemas, como transa√ß√µes entre shard. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Transa√ß√µes entre fragmentos </h2><br><p>  At√© agora, vimos os shards como blockchains independentes em termos de como eles executam transa√ß√µes.  Com esse design, por exemplo, √© imposs√≠vel concluir uma transa√ß√£o que transfira dinheiro entre duas contas em dois fragmentos diferentes, ou causar contato em um fragmento de um contrato em outro.  Eu gostaria de apoiar os dois cen√°rios. </p><br><p>  Por uma quest√£o de simplicidade, consideraremos apenas as transa√ß√µes que transferem dinheiro e assumiremos que cada participante tem uma conta em exatamente um fragmento.  Se um participante de um fragmento desejar transferir dinheiro para um participante no mesmo fragmento, os validadores desse fragmento poder√£o processar essa transa√ß√£o e aplic√°-la ao estado.  Mas se, por exemplo, Alice tiver uma conta no fragmento 1 e desejar enviar dinheiro para Bob com uma conta no fragmento 2, nem os validadores de fragmento 1 (que n√£o podem adicionar dinheiro a Bob) nem os validadores de fragmento 2 (que n√£o podem obter o dinheiro de Alice ) n√£o pode concluir a transa√ß√£o e atualizar o estado. </p><br><p>  Existem dois grandes grupos de abordagens para resolver esse problema: </p><br><ol><li><p>  <strong>S√≠ncrono</strong> : para qualquer transa√ß√£o que envolva v√°rios shards, blocos em shards contendo atualiza√ß√µes de estado para essa transa√ß√£o s√£o produzidos simultaneamente e validadores nesses shards trabalham juntos para criar esses blocos.  O design mais elaborado dessa abordagem, conhecido por mim, √© o Merge Blocks, descrito (em ingl√™s) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br></li><li><p>  <strong>Ass√≠ncrona</strong> : uma transa√ß√£o entre fragmentos √© executada em shards que afeta de forma ass√≠ncrona: a parte da transa√ß√£o que adiciona dinheiro a Bob √© executada no fragmento # 2 quando os validadores no fragmento t√™m alguma evid√™ncia de que a parte da transa√ß√£o que subtrai dinheiro de Alice foi executada em fragmento # 1.  Essa abordagem √© mais popular nos sistemas desenvolvidos atualmente devido ao fato de n√£o exigir sincroniza√ß√£o adicional entre os shards para a produ√ß√£o de blocos.  Hoje, esses sistemas s√£o oferecidos no Cosmos, Ethereum Serenity, Near Protocol, Kadena e outros.  O problema dessa abordagem √© que, se os blocos forem produzidos independentemente, √© prov√°vel que um dos blocos que cont√©m a atualiza√ß√£o de estado da transa√ß√£o n√£o esteja na cadeia can√¥nica em seu fragmento e, portanto, a transa√ß√£o ser√° parcialmente parcialmente conclu√≠da.  Por exemplo, considere a figura abaixo.  Ele mostra dois fragmentos nos quais os garfos ocorreram e uma transa√ß√£o entre fragmentos, cuja atualiza√ß√£o de estado √© refletida nos blocos A e X ', respectivamente.  Se as cadeias AB e V'-X'-Y'-Z 'forem can√¥nicas em seus fragmentos, a transa√ß√£o ser√° totalmente finalizada.  Se as cadeias A'-B'-C'-D 'e VX forem can√¥nicas, a transa√ß√£o ser√° completamente cancelada, o que √© aceit√°vel.  Mas se, por exemplo, AB e VX se tornarem can√¥nicos, uma parte da transa√ß√£o ser√° finalizada, a outra ser√° cancelada e a transa√ß√£o ser√° parcialmente conclu√≠da. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="imagem"></p><br><p>  O cen√°rio descrito acima √© um dos grandes problemas no sharding, no qual todas as solu√ß√µes propostas n√£o s√£o ideais.  Vamos tocar um pouco abaixo. </p><br><h2 id="plohoe-povedenie">  Mau comportamento </h2><br><p>  Agora que descobrimos como o blockchain do shard funciona e estudamos os conceitos de blockchain central, a nomea√ß√£o de validadores e as transa√ß√µes entre shards, no final deste artigo, veremos outro t√≥pico interessante: o que um participante que tenta atacar o sistema pode fazer se conseguir obter controle sobre um n√∫mero suficientemente grande de validadores em um fragmento. </p><br><h3 id="celenapravlennye-forki">  Forquilhas direcionadas </h3><br><p>  Se o participante tiver controle suficiente sobre o fragmento, ele poder√° criar garfos de prop√≥sito.  Para criar garfos, n√£o importa qual consenso √© usado nos fragmentos, em particular, n√£o importa se √© BFT ou n√£o, se um n√∫mero suficiente de validadores for controlado pelo invasor, ele poder√° criar um garfo.  Por exemplo, o objetivo da bifurca√ß√£o pode ser reverter uma transa√ß√£o que pagou por algo fora da blockchain. </p><br><p>  Alega-se que ganhar controle de 50% do shard √© mais f√°cil do que 50% de toda a rede (por exemplo, porque um participante pode tentar hackear ou subornar validadores depois de ter sido designado ao shard).  Por defini√ß√£o, as transa√ß√µes entre fragmentos mudam de estado em v√°rios fragmentos.  Tais mudan√ßas cair√£o em alguns blocos nas cadeias de blocos dos fragmentos correspondentes.  √â necess√°rio que todos esses blocos sejam finalizados (ou seja, perten√ßam √† cadeia can√¥nica em seus respectivos fragmentos) ou que todos n√£o sejam finalizados (ou seja, n√£o perten√ßam √† cadeia can√¥nica em seus fragmentos).  Como assumimos que alguns participantes com m√°s inten√ß√µes podem, em princ√≠pio, obter controle sobre o fragmento, n√£o podemos assumir que os garfos n√£o ocorrer√£o, mesmo que o consenso bizantino tenha sido alcan√ßado ou que um grande n√∫mero de blocos tenha sido constru√≠do no topo do bloco com a transa√ß√£o. </p><br><p>  Esse problema tem muitas solu√ß√µes, a mais simples das vezes √© salvar o hash do √∫ltimo bloco no shard no blockchain central.  O algoritmo de sele√ß√£o de cadeia can√¥nica em shards √© ent√£o alterado para que nenhum alvo que contenha o √∫ltimo bloco armazenado no canonical blockchain central.  Ent√£o, para evitar completamente situa√ß√µes em que a transa√ß√£o foi parcialmente conclu√≠da devido ao fato de alguns dos blocos que cont√™m sua atualiza√ß√£o de estado estarem fora das cadeias can√¥nicas, voc√™ pode alterar o algoritmo para executar transa√ß√µes entre shards, para que o shard A n√£o aceite a prova da transa√ß√£o no shard B at√© o bloco contendo a atualiza√ß√£o de estado para a transa√ß√£o no fragmento B n√£o foi salvo no blockchain central. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Criando blocos inv√°lidos </h3><br><p>  Se o participante conseguiu obter controle sobre um n√∫mero suficientemente grande de validadores no shard, ele pode tentar criar um bloco completamente inv√°lido.  Por exemplo, suponha que antes do bloco, o estado era tal que Alice tivesse 10 tokens e, em Bob - 0, o bloco cont√©m apenas uma transa√ß√£o, que envia 10 tokens da conta de Alice para a conta de Bob, mas no novo estado reflete 0 tokens de Alice e 1000 com o Bob. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="imagem"></p><br><p>  Em um blockchain cl√°ssico e n√£o fragmentado, √© imposs√≠vel criar um bloco assim, porque todos os participantes, como aqueles que criam blocos e aqueles que simplesmente usam o blockchain, verificam todos os blocos e descartam imediatamente qualquer bloco que contenha tais erros.  Mesmo que os validadores controlados pelo invasor possam construir a cadeia mais rapidamente, isso n√£o permitir√° que eles passem a cadeia mais longa que cont√©m o bloco inv√°lido como o can√¥nico, porque todos os participantes da rede descartam imediatamente o bloco inv√°lido e qualquer bloco que foi constru√≠do no topo.  Os validadores honestos continuar√£o construindo sobre o √∫ltimo bloco v√°lido e todos os participantes da rede ver√£o sua cadeia como can√¥nica. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="imagem"></p><br><p>  A figura acima mostra cinco validadores, tr√™s dos quais est√£o sob o controle do atacante.  Eles criaram o bloco inv√°lido A 'e continuaram a construir a cadeia no topo.  Dois validadores privados descartaram imediatamente o bloco A 'como inv√°lido e continuaram a construir sobre o √∫ltimo bloco v√°lido que eles conheciam, criando assim um fork.  Como h√° menos validadores em uma cadeia honesta do que em uma cadeia desonesta, sua cadeia √© mais curta.  No entanto, no blockchain cl√°ssico n√£o compartilhado, todos os participantes do sistema validam todos os blocos que veem.  Assim, qualquer participante que use o blockchain ver√° que A '√© inv√°lido, descart√°-lo e, portanto, descartar√° B', C 'e D' como constru√≠do no topo do bloco inv√°lido e, portanto, todos os participantes ver√£o AB como uma cadeia can√¥nica. </p><br><p>  Em um design de fragmento, nenhum participante pode validar todos os blocos em todas as cadeias de blocos.   - ,        ,                ,     - . </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     ‚Äî   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu escrevo muito sobre blockchain e sharding em ingl√™s. </font><font style="vertical-align: inherit;">Tamb√©m entrevistamos periodicamente autores de outros protocolos, como Cosmos e Solana, aprofundando detalhes t√©cnicos. </font><font style="vertical-align: inherit;">Se voc√™ estiver interessado no t√≥pico, poder√° seguir novas postagens e v√≠deos assinando meu Twitter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437924/">https://habr.com/ru/post/pt437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437912/index.html">Um notebook pequeno para um administrador de sistema</a></li>
<li><a href="../pt437914/index.html">Jaxb (XJC) gerando classes do XML Schema (XSD) com descri√ß√µes de classe e campo como anota√ß√µes. Plug-in XJC</a></li>
<li><a href="../pt437916/index.html">D√™ ao leitor de livros eletr√¥nicos todos os bolsos! Revis√£o das √∫ltimas inova√ß√µes do ONYX BOOX</a></li>
<li><a href="../pt437918/index.html">Grava√ß√£o de v√≠deo com eje√ß√£o autom√°tica de pausa por software livre com constru√ß√£o de bicicletas</a></li>
<li><a href="../pt437922/index.html">Modelo de ataque: onde √© usado principalmente em compras eletr√¥nicas e como lidar com isso</a></li>
<li><a href="../pt437926/index.html">O guia oficial para o compartilhamento de Blockchain</a></li>
<li><a href="../pt437928/index.html">Como aprender ingl√™s</a></li>
<li><a href="../pt437930/index.html">Lumin√°ria Combo</a></li>
<li><a href="../pt437932/index.html">Mem√≥ria Intel Optane H10: cache de Optane + QLC 3D NAND</a></li>
<li><a href="../pt437934/index.html">Gerenciamento de tempo na vida real</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>