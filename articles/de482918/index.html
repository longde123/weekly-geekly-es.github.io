<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèª üå¨Ô∏è üë©üèø‚Äçüé® Speichern von Daten in einem EEPROM auf einem Arduino transaktional üéüÔ∏è üö∂ üì∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Vorhandensein von EEPROM bietet Entwicklern ein praktisches Tool zum Speichern von Konfigurationsparametern oder eines sich langsam √§ndernden Zust...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speichern von Daten in einem EEPROM auf einem Arduino transaktional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482918/">  Das Vorhandensein von EEPROM bietet Entwicklern ein praktisches Tool zum Speichern von Konfigurationsparametern oder eines sich langsam √§ndernden Zustands, in dem ein Stromausfall √ºberleben sollte.  In diesem Artikel werden wir uns ansehen, wie dies so sicher und bequem wie m√∂glich gemacht werden kann, um nichts zu vergessen und uns nicht daran zu erinnern, was nicht da war. <br><a name="habracut"></a><br>  Angenommen, wir haben eine Variable und m√∂chten sie in einem EEPROM speichern.  Es scheint, dass alle Werkzeuge daf√ºr in unseren H√§nden sind: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;EEPROM.h&gt; int my_var = DEFAULT_VALUE; EEPROM.get(MY_VAR_ADDR, my_var); my_var = NEW_VALUE; EEPROM.put(MY_VAR_ADDR, my_var);</span></span></span></span></code> </pre> <br>  Ein genauerer Blick zeigt jedoch, dass dieser Ansatz mehr Probleme schafft als l√∂st.  Wir werden sie der Reihe nach besprechen. <br><br>  1. Wie k√∂nnen wir sicherstellen, dass wir genau das lesen, was wir aufgeschrieben haben (um die <b>Integrit√§t</b> zu gew√§hrleisten)?  Stellen Sie sich folgendes Bild vor.  Wir schreiben uns einen Brief f√ºr den Fall unseres pl√∂tzlichen Todes aufgrund eines Stromausfalls oder eines R√ºcksetzsignals und legen ihn in eine Schreibtischschublade.  Im n√§chsten Leben √∂ffnen wir die Schreibtischschublade, nehmen ein St√ºck Papier heraus, lesen die Botschaft und setzen unsere Mission fort.  Das Problem ist, dass in der Box immer Bl√§tter mit zuf√§lligem Text gekritzelt sind.  Wir brauchen also eine M√∂glichkeit, die richtige Nachricht von der zuf√§lligen zu unterscheiden.  Man k√∂nnte ihm einen Notar zusichern, aber im einfachsten Fall w√ºrde seine Unterschrift ausreichen, wenn wir die Richtigkeit √ºberpr√ºfen k√∂nnten.  Beispielsweise k√∂nnen wir das Ergebnis eines mathematischen Ausdrucks in Abh√§ngigkeit vom Text als Signatur verwenden, so dass die Wahrscheinlichkeit eines zuf√§lligen Zusammentreffens ausreichend gering ist.  Im einfachsten Fall ist dies ein CRC oder eine Pr√ºfsumme.  Es sch√ºtzt uns nicht nur vor dem Lesen dessen, was wir nicht geschrieben haben, sondern auch vor dem Lesen einer besch√§digten Nachricht.  Schlie√ülich verblasst der Text mit der Zeit und die Elektronen im isolierten Shutter sind noch weniger langlebig - ein Partikel fliegt mit ausreichender Energie aus dem Weltraum, und das Bit √§ndert sich.  Es gibt aber auch eine andere M√∂glichkeit, eine besch√§digte Nachricht zu erhalten: F√ºgen Sie sie nicht am Ende hinzu.  Es ist nicht so exotisch, weil zum Zeitpunkt der Aufnahme der Stromverbrauch stark ansteigt, was einen vorzeitigen Tod des Schriftstellers hervorrufen kann. <br><br>  2. Angenommen, wir waren von der Richtigkeit der Nachricht √ºberzeugt, aber wie kann ich sicherstellen, dass ich es war, der sie geschrieben hat (um die <b>Authentizit√§t</b> zu gew√§hrleisten) <b>?</b>  Wie das Sprichwort sagt, bin ich anders.  Pl√∂tzlich sa√ü vor meiner Reinkarnation noch jemand an diesem Tisch, und er hatte eine andere Mission, und aus welchem ‚Äã‚ÄãGrund werde ich mich jetzt von seinen Botschaften leiten lassen?  Wenn wir unsere Notizen mit einem bestimmten Etikett versehen w√ºrden, k√∂nnten wir unsere leichter von Fremden unterscheiden.  Ein solches Label k√∂nnte beispielsweise der Name der Variablen sein, die wir speichern.  Das einzige Problem besteht darin, dass im EEPROM nicht viel Platz f√ºr Variablennamen vorhanden ist, und dies ist unpraktisch, da sie unterschiedlich lang sind.  Gl√ºcklicherweise gibt es jedoch eine einfachere M√∂glichkeit: Sie k√∂nnen die Pr√ºfsumme im Namen der Variablen berechnen und als Verkn√ºpfung verwenden.  Gleichzeitig ist es n√ºtzlich, die Gr√∂√üe der Variablen in Bytes zu dieser Pr√ºfsumme hinzuzuf√ºgen, um nicht versehentlich die falsche Menge zu lesen.  Der Vollst√§ndigkeit halber f√ºgen wir dort einen weiteren numerischen Bezeichner hinzu, um zu gew√§hrleisten, dass unsere Variable von einer anderen Person unterschieden wird, auch wenn sie gleich hei√üt.  Wir nennen diese Nummer die Instanzkennung (inspiriert von OOP, wenn der Variablenname als Objektfeld betrachtet wird).  Wenn wir unsere Mission jemals auf eine radikal neue Version aktualisieren, sodass dieses Update alles, was die alte gespeichert hat, sinnlos macht, m√ºssen wir nur die Instanz-ID √§ndern, um alles, was in der alten Version gespeichert ist, ung√ºltig zu machen. <br><br>  3. Wie kann ich einen unvollst√§ndigen Schreibvorgang ausf√ºhren, ohne den alten gespeicherten Wert zu √§ndern?  Das hei√üt, der Speichervorgang sollte entweder erfolgreich sein oder √ºberhaupt keine beobachtbaren Auswirkungen haben.  Mit anderen Worten, es sollte <b>atomar</b> oder transaktional sein, wenn es sich um eine Transaktion handelt, die auf eine bedingungslose Aktualisierung eines einzelnen Werts hinausl√§uft.  Offensichtlich k√∂nnen wir nicht sicherstellen, dass der Datensatz atomar ist, indem wir den vorherigen Wert √ºberschreiben. Wir m√ºssen an eine neue Stelle schreiben, damit der alte gespeicherte Wert erhalten bleibt, zumindest bis die Aufzeichnung des neuen Werts abgeschlossen ist.  Diese Technik wird oft als "Copy-on-Write" bezeichnet, wenn nur ein Teil des gespeicherten Werts aktualisiert wird, der unver√§nderte Teil jedoch noch kopiert und an eine neue Position geschrieben wird.  Ausgehend von unserer Analogie werden wir uns selbst Briefe schreiben, wobei die alten unangetastet bleiben, aber jeden Brief mit einer zunehmenden Seriennummer versehen, damit wir in unserem n√§chsten Leben die M√∂glichkeit haben, den letzten Brief zu finden, den wir geschrieben haben.  Gleichzeitig tritt jedoch ein neues Problem auf - die Stelle in der Box, an der wir die Buchstaben ablegen, endet fr√ºher oder sp√§ter, wenn wir alte, irrelevant gewordene Buchstaben nicht wegwerfen.  Es ist leicht zu verstehen, dass es ausreicht, nur zwei Buchstaben zu speichern - einen alten und einen neuen. M√∂glicherweise wird gerade geschrieben.  Dementsprechend ben√∂tigt die Buchstabennummer auch nicht viele Bits. <br><br>  Seltsamerweise konnte der Autor keine einzige Implementierung finden, die die Organisation der Datenspeicherung im EEPROM erm√∂glicht und gleichzeitig Integrit√§t, Authentizit√§t und Atomizit√§t gew√§hrleistet.  Ich musste selbst an <a href="https://github.com/olegv142/NvTx" rel="nofollow">github.com/olegv142/NvTx</a> schreiben <br><br>  Um jede Variable im EEPROM zu speichern, werden 2 aufeinanderfolgende Bereiche verwendet - Zellen mit derselben Struktur.  In die ersten 2 Bytes wird die Kennung der Variablen geschrieben, die anhand ihrer Gr√∂√üe, Textbezeichnung und Instanzkennung berechnet wird.  Als n√§chstes werden Daten geschrieben, gefolgt von 2 Bytes der Pr√ºfsumme.  Im allerersten Byte haben zwei Bits einen besonderen Zweck.  Das h√∂chstwertige Bit ist das Korrektheitsflag, das beim Schreiben immer auf eins gesetzt wird.  Das niederwertige Bit wird als Einzelbit-Nummer der √Ñra verwendet und zum Auffinden der letzten Nachricht ben√∂tigt.  Die Aufzeichnung erfolgt in Zellen 'in einem Kreis'.  Die Nummer der √Ñra √§ndert sich jedes Mal, wenn ein Datensatz in der ersten Zelle erstellt wird.  Daher der Algorithmus zur Bestimmung der zuletzt aufgezeichneten Zelle: Wenn die Epochen der Zellen gleich sind, wird die zweite zuletzt geschrieben, wenn sie unterschiedlich ist - dann die erste. <br><br>  Das Korrektheitsbit erscheint redundant, hat aber eine wichtige Funktion.  Zun√§chst lesen wir die gespeicherten Daten und √ºberpr√ºfen die Richtigkeit beider Zellen.  Wenn die Zelle die Pr√ºfung auf die richtige Kennung oder Pr√ºfsumme nicht besteht, setzen wir das Korrektheitsbit zur√ºck.  Nachfolgende Schreiboperationen pr√ºfen m√∂glicherweise nicht die Richtigkeit der Zellen, sondern verlassen sich auf dieses Flag, wodurch der Overhead um das Zweifache reduziert wird. <br><br>  Diejenigen, die sich mit den Implementierungsdetails befassen m√∂chten, k√∂nnen die Bilder und den Code im <a href="https://github.com/olegv142/NvTx" rel="nofollow">Repository sehen</a> .  Ich gehe weiter, um den Leser nicht zu langweilen.  Die Funktionen zum Schreiben / Lesen von Daten erhalten jeweils 5 Parameter, sodass die Benutzerfreundlichkeit zugunsten der Flexibilit√§t beeintr√§chtigt wird.  Es wird jedoch gro√üz√ºgig durch zwei S√§tze von Makros kompensiert, die die Verwendung der Bibliothek so einfach wie im Fall von EEPROM.get / put machen.  Die erste Gruppe von Makros wird verwendet, wenn Sie die Variable nur unter der angegebenen Adresse speichern m√∂chten: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; bool have_my_var = NvTxGetAt(my_var, MY_VAR_ADDR); my_var = NEW_VALUE; NvTxPutAt(my_var, MY_VAR_ADDR);</span></span></span></span></code> </pre><br>  Wenn mehrere Variablen gespeichert werden sollen, muss jede die Adresse ermitteln und gleichzeitig die Gr√∂√üe korrekt ber√ºcksichtigen, damit sich die Speicherbereiche, in denen die Variablen gespeichert sind, nicht √ºberlappen.  Um die Aufgabe zu vereinfachen, implementiert die zweite Gruppe von Makros die automatische Adresszuweisung, und zwar <b>zum Zeitpunkt der Kompilierung</b> .  Beispielsweise kann die <a href="https://github.com/thijse/Arduino-EEPROMEx" rel="nofollow">Arduino-EEPROMEx-Bibliothek</a> zur Laufzeit Speicher zuweisen, w√§hrend sie die Adresse f√ºr jede gespeicherte Variable im RAM speichert.  Die <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx-</a> Bibliothek reserviert Speicherplatz im EEPROM, ohne den ausf√ºhrbaren Code oder den Inhalt des RAM zu ver√§ndern. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; char my_string[16] = ""; NvPlace(my_var, MY_START_ADDR, MY_INST_ID); NvAfter(my_string, my_var); bool have_my_var = NvTxGet(my_var); my_var = NEW_VALUE; NvTxPut(my_var);</span></span></span></span></code> </pre><br>  Das Makro NvPlace legt die Startadresse des EEPROM-Bereichs fest, in dem die Variablen und die Instanzkennung gespeichert werden.  Das NvAfter-Makro reserviert einen Speicherbereich, um sein erstes Argument unmittelbar nach dem f√ºr den zweiten reservierten Speicherbereich zu speichern.  Bei der Zuweisung von Speicher wird au√üerdem √ºberpr√ºft, dass die verf√ºgbare EEPROM-Gr√∂√üe nicht √ºberschritten wurde und dass √ºberlappende Speicherbereiche nicht reserviert wurden (dies kann vorkommen, wenn zwei NvAfter-Makros dasselbe zweite Argument haben).  Bei einem Versto√ü gegen eine der beiden angegebenen Bedingungen wird das Programm einfach nicht kompiliert.  Diejenigen, die sich mit dem Speicherzuweisungsmechanismus befassen m√∂chten, finden ihn in der Header-Datei <a href="" rel="nofollow">NvTx.h.</a>  Alles, was die Makros NvPlace und NvAfter tun, ist, die Aufz√§hlungen zu definieren, ihre Namen auf der Grundlage der Variablennamen zu bilden und auch die sehr n√ºtzliche idiomatische Konstruktion der <a href="" rel="nofollow">Kompilierungszeit zu verwenden</a> . <br><br>  Hoffentlich <a href="https://github.com/olegv142/NvTx" rel="nofollow">hilft</a> die <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx-</a> Bibliothek den Lesern dabei, zuverl√§ssigen Code in Industriequalit√§t zu schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482918/">https://habr.com/ru/post/de482918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482902/index.html">Nein, k√ºnstliche Intelligenz kann uns nicht besiegen</a></li>
<li><a href="../de482904/index.html">Eine kurze Geschichte der Weltraummikroprozessoren, Teil Eins</a></li>
<li><a href="../de482906/index.html">Informationen zur Netzwerksicherheit</a></li>
<li><a href="../de482908/index.html">Der zweite Teil der √úbersetzung von David Kouchners Buch Masters of Doom. Kapitel 6-12</a></li>
<li><a href="../de482912/index.html">Die Idee eines dezentralen sozialen Netzwerks der n√§chsten Generation</a></li>
<li><a href="../de482920/index.html">Wie der Autopilot in unser Leben gefahren ist, haben wir aber nicht bemerkt</a></li>
<li><a href="../de482922/index.html">Drupal Digest - 2019 / Dezember</a></li>
<li><a href="../de482926/index.html">Arc ist ein Versionskontrollsystem f√ºr ein Monorepository. Yandex-Bericht</a></li>
<li><a href="../de482928/index.html">Predator Vision: W√§rmebildeffekt</a></li>
<li><a href="../de482930/index.html">Genealogische Forschung - metrische B√ºcher, Volksz√§hlungen, Archive, offene Datenbanken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>