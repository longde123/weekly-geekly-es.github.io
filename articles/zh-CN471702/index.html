<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💲 🗣️ 🙋🏾 网络增强型Web应用程序 👨🏾‍🌾 🧕🏽 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自jQuery和常规HTML页面问世以来，现代前端已经走了很长一段路。 现在，我们有了汇编程序，程序包管理器，组件方法，SPA，SSR等。 


 看来我们拥有幸福所需的一切。 但是行业正在向前发展。 我想告诉您有关已编译的Svelte框架及其相对于类似物的优点。 



 图片由安德鲁·沃尔波尔 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>网络增强型Web应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471702/"><p> 自jQuery和常规HTML页面问世以来，现代前端已经走了很长一段路。 现在，我们有了汇编程序，程序包管理器，组件方法，SPA，SSR等。 </p><br><p> 看来我们拥有幸福所需的一切。 但是行业正在向前发展。 我想告诉您有关已编译的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Svelte</a>框架及其相对于类似物的优点。 </p><br><p><img src="https://habrastorage.org/webt/es/5w/wc/es5wwct4qctbavihmd23-k8phvu.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图片由安德鲁·沃尔波尔</a> </p><a name="habracut"></a><br><h2 id="google-trends">  Google趋势 </h2><br><p> 为了了解前端的当前状况，我分析了过去5年在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google趋势</a>中查询关键词，React，jQuery，Vue，Angular在俄罗斯的流行程度。 </p><br><p><img src="https://habrastorage.org/webt/hb/7q/6l/hb7q6lfm_j8pjpkepo4_zcl-rto.png"><br>  <em>Google趋势</em> </p><br><p> 在过去的5年中，与jQuery相关的查询数量已大大减少，而让给了组件框架。 尽管jQuery失去了基础，但它仍然是流行的开发工具。 </p><br><p> 从该图可以得出结论，组件库赢得了前端，React是俄罗斯的领导者。 </p><br><h2 id="rynok-truda"> 劳动力市场 </h2><br><p> 我们不仅为自己编写代码，而且还为金钱编写代码。 主要是为了钱。 因此，孤立于劳动力市场而考虑框架的流行是愚蠢的。 </p><br><p> 根据hh上的空缺数量，React排名第一，其次是jQuery和其他组件库。 如果我们查看以关键技能指出有问题的库的申请人数，那么jQuery知道的申请人数是React的5倍。 比Angular大15倍。 </p><br><p><img src="https://habrastorage.org/webt/nk/vt/g0/nkvtg0lfwgjyltdhg6uvkvqfp6i.png"><br>  <em>劳动力市场</em> </p><br><p> 从该图可以得出以下结论： </p><br><ul><li> 组件框架在雇主中最受欢迎，其中最受欢迎的是React。 </li><li> 在申请人中，最常用的库是jQuery。 </li></ul><br><p> 因此，组件框架获得了成功。 前端解决了开发人员在jQuery期间遇到的问题。 但是新方法带来了新的麻烦。 我看到什么问题？ </p><br><ol><li> 性能。 <br> 今年1月，Google宣布可以在Google Play上发布PWA应用程序，为在本机应用程序商店中使用javascript铺平了道路。 这给开发人员带来了一定的责任，因为用户期望本机应用程序的性能，所以对于消费者而言应该没有任何区别。 <br>  Javascript还征服了低功耗设备。 这是一款智能电视，手表，物联网。 此类设备的内存和处理器预算有限，因此开发人员无法负担将资源浪费在用户身上。 <br> 在工作中，我们具有在Internet集线器上运行React应用程序的经验。 原来马马虎虎。 </li><li> 高入门门槛。 <br> 正如我们在上面看到的，大多数求职者都指向jQuery技能，而不是反应。 掌握React概念比连接到jQuery页面并开始创建要困难得多。 </li><li> 对框架的依赖。 <br> 如果您有用React编写的组件库，则不太可能在Vue或Angular项目中重用它。 您成为生态系统的人质。 </li></ol><br><h2 id="svelte-vanilla-flavored"> 苗条 香草味。 </h2><br><p> 今年4月，发布了编译后的Svelte框架的第三个版本。 <br>  Svelte为开发人员提供了编写高级声明性代码的能力，这些声明性代码经过编译后会变成低级命令性代码。 这也使得进行有效的树状摇动成为可能，因此可以向客户端发送最小的捆绑包。 <br> 让我们看看Svelte为解决这些问题提供了哪些解决方案。 </p><br><p> 由于React是俄罗斯最受欢迎的库，因此将在React上提供更多示例。 </p><br><h2 id="1-proizvoditelnost">  1.表现 </h2><br><p> 如果您开始熟悉新库，那么很可能会从“待办事项”列表开始游览。 这是一个相当简单的任务，通常在香草中更容易编写。 如果您想更深入地研究框架，那么对Real World Application进行回顾是一个不错的选择。 这是本质上是Medium的克隆的博客。 有注册，授权，创建帖子，评论，喜欢。 框架专家编写该功能的实现，并将其添加到“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">真实世界应用程序”</a>集合中。 <br>  FreeCodeCamp上发表了一篇有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较</a>用不同框架编写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Real World Application</a>的文章。 <br> 如果我们看看最终捆绑包的大小，那么斯维尔特的表现将超过其竞争对手。 仅9.7kb的代码发送到客户端。 结果，它花费更少的时间来传输数据，解析和处理您的代码。 </p><br><p><img src="https://habrastorage.org/webt/q_/nq/rm/q_nqrmfqup3utimvroeu-zsrjza.png"><br>  <em>实际应用程序捆绑包大小比较</em> </p><br><p> 最好的代码不是书面代码。 <br> 如果我们看一下编写应用程序功能所需的代码行数，那么Svelte将需要大约1000行，而React需要大约2000行。应用程序中的代码越少，错误越少，支持也就越容易。 </p><br><p><img src="https://habrastorage.org/webt/gk/jn/ey/gkjneygjfhfhi1b-cooph8aeqim.png"><br>  <em>实际应用代码大小比较</em> </p><br><p> 让我们看一下性能。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">js-framework-benchmark</a>提供了前端框架之间渲染性能的比较。 测试是绘制一张包含大量行的表。 对该表进行进一步的操作：部分或全部更新，创建，清理，删除行。 </p><br><p> 通过更新时间，Svelte显示了最佳或可比的时间。  Svelte非常平衡，执行不同类型的操作时不会变形。 </p><br><p><img src="https://habrastorage.org/webt/rk/qt/nz/rkqtnzb4ua4zy7vvbnbyonfqxqo.png"><br>  <em>比较更新执行时间，毫秒</em> </p><br><p> 如果我们查看消耗的内存量，那么Svelte在所讨论的库中是最不活跃的。 </p><br><p><img src="https://habrastorage.org/webt/de/d-/p_/ded-p_wuuzcdxlay0duwcubzb6g.png"><br>  <em>比较消耗的内存量，mb</em> </p><br><p> 我不习惯说话，而是决定自己检查所有内容。 我找到了前端<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DBMonster基准</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现，</a>并重写了React 16.8和Svelte 3上的实现。测试包括渲染表，然后更新行。 </p><br><p><img src="https://habrastorage.org/webt/p2/fc/0j/p2fc0jzzmb3jqkr3pxclinvgrqy.gif"><br>  <em>DBMonster测试是什么样的？</em> </p><br><p> 在测试期间，Svelte消耗的内存减少了10 MB，并且更新速度比React快10毫秒。 </p><br><p><img src="https://habrastorage.org/webt/it/xm/si/itxmsiqrktcbuiua--rg32ixlce.gif"><img src="https://habrastorage.org/webt/5c/q2/bu/5cq2buhlzbnbcd9ov0yhi1lh2xu.gif"><br>  <em>苗条/反应</em> </p><br><p> 上面的测试是综合的，但是从中可以得出结论，在Svelte上进行开发时，您会发现： </p><br><ul><li> 捆束尺寸更小 </li><li> 减少内存消耗 </li><li> 渲染速度更快。 </li></ul><br><h2 id="2-vysokiy-porog-vhoda">  2.高准入门槛 </h2><br><p> 如果我们看一下React上最简单的组件，那么您需要导入React本身，编写一个将返回标记并导出您的组件的函数。 总共3行代码。 </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component;</code> </pre> <br><p> 如果我们看一下svelte上组件的最简单示例，那么您只需编写标记。 总共1行代码。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 严格来说，最简单的Svelte组件是一个空文件。 这样就可以从空文件为您的应用程序创建模板，然后开始开发。 在这种情况下，什么都不会中断。 </p><br><p> 您还可以采用从排字机接收到的布局，并将其立即用作Svelte组件，而无需进行其他转换。 有效的html是Svelte组件。 </p><br><p> 我想分享一个关于中间反应开发人员职位的访谈中的例子。 </p><br><pre> <code class="javascript hljs">setFilter() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.switchFlag = !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.switchFlag } ... &lt;button onClick={setFilter}&gt;Filter&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt;</span></span></code> </pre> <br><p> 候选人试图将过滤器按钮的状态直接保存到class属性中。 尽管有它的名字，React仍然没有足够的反应能力来应对这种变化。 这表明即使是中级开发人员也很难获得React使用的状态更新模式。 </p><br><p> 让我们看一下通过单击增加计数器数量的按钮示例。 </p><br><p><img src="https://habrastorage.org/webt/id/en/d8/idend8qhqefwtl2uumhewmzjkg0.gif"></p><br><p> 在React上，您需要一个变量来保存状态和一个可以更新状态的函数。 接下来，您需要为按钮本身分配用于更新的处理程序。 总共，我得到了8行代码。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [count, setCount] = React.useState(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setCount(count + 1)}&gt; Clicked {count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component;</code> </pre> <br><p> 要解决Svelte上的类似问题，您需要一个变量来存储状态。 在处理程序中，您只需更改该变量的值即可。 总共6行代码。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> count = </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag">=&gt;</span></span>count+=1}&gt; Clicked {count} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 让我们使示例复杂一些。 假设我们需要一个输入字段，在其旁边显示其状态。 </p><br><p><img src="https://habrastorage.org/webt/cc/ld/xt/ccldxto2knv1mrmdxke33yevgse.gif"></p><br><p> 在React上，我们仍然需要一个变量和函数来更新状态。 然后，在输入字段中，您需要传输当前值并为更改分配一个处理程序。 我最终得到了11行代码。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = React.useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; {value} &lt;/React.Fragment&gt; ); } export default App;</code> </pre> <br><p> 要在Svelte上解决此问题，您需要一个存储状态的变量，然后在输入字段中进行双向绑定。 总共5行代码。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> value = </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">''</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{value}/</span></span></span><span class="hljs-tag">&gt;</span></span> {value}</code> </pre> <br><p> 如果您曾经动手在React上从DOM中移除元素，那么我很同情您。  React将需要一个包装器，该包装器将延迟从DOM中删除元素并制作动画，或者该元素将保留在DOM中，但是动画将需要控制display属性或其他操作，以便该元素不占用空间。 </p><br><p><img src="https://habrastorage.org/webt/_w/-7/05/_w-705ykcxp0h5jmajgmgvd6lok.gif"></p><br><p> 我试图在React上找到最简单的实现，最后我得到了35行代码。 如果您有更简单的解决方案，请分享评论。 </p><br><div class="spoiler">  <b class="spoiler_title">淡入淡出反应</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./style.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [visible, setVisible] = React.useState(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;React.Fragment&gt; &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> setVisible(!visible)}&gt;toggle&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;div className={visible ? "visible" : "invisible"}&gt;Hello&lt;/</span></span>div&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }; export default App;</span></span></code> </pre> <br><pre> <code class="html hljs xml">.visible { animation: fadeIn 0.5s linear forwards; } .invisible { animation: fadeOut 0.5s linear forwards; } @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; display: none; } } @keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }</code> </pre> </div></div><br><p> 在Svelte上，类似的组件仅需要8行代码。  Svelte具有用于管理动画的内置模块。 导入所需类型的动画，然后说出添加和删除时如何对组件进行动画处理。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { fade } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'svelte/transition'</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> visible = </span><span class="hljs-literal"><span class="javascript"><span class="hljs-literal">true</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag">=&gt;</span></span>visible=!visible}&gt;toggle<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {#if visible} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">transition:fade</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br><p> 兼容性使Svelte可以为开发人员提供出色的抽象。 而且，如果您不使用它们，它们将不会落入最终的捆绑包。 </p><br><p> 例如，过渡模块具有很酷的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交叉淡入淡出</a>功能，当从一个DOM节点移动到另一个DOM节点时，该模块使您可以对组件进行动画处理。 使用它，您可以在“待办事项”列表中进行此类任务转换。 </p><br><p><img src="https://habrastorage.org/webt/jy/qx/jk/jyqxjktdonnzxitsm7mdhe0fxgm.gif"></p><br><p> 酷抽象的另一个示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">use：</a>指令。 它允许您将自定义处理程序分配给DOM元素。 在下面的示例中，仅使用一个功能处理按下和移动事件以及触摸事件。 </p><br><p><img src="https://habrastorage.org/webt/vr/ne/xj/vrnexj0zvmftba16ecdnb8klmq4.gif"></p><br><p> 在认识Svelte之后，我的朋友们通常说，自jQuery以来，他们还没有经历过这种有趣的前端开发。 </p><br><h2 id="3-zavisimost-ot-freymvorka">  3.对框架的依赖 </h2><br><p> 当React到达时，网络上有很多jQuery小部件。 在React上找到合适的组件很困难。 然后，用于jQuery小部件的包装器开始出现，它们能够同步React和jQuery。 之后，用React本身编写的组件已经开始出现。 <br> 现在，React本身也有类似情况。 有很多现成的解决方案和库，它们使您无法轻松地转移到另一个框架。 </p><br><p> 斯维尔特提供什么？ 编译后，您的代码将变成常规的JS，不需要运行时。 这样就可以在其他框架中使用Svelte组件。 您只需要一个通用包装。 例如，用于React和Vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">svelte-adapter的适配器</a> 。 通过将组件包装在适配器中，可以将元素用作常规组件。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SvelteSpinner <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"svelte-spinner"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> toReact <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"svelte-adapter/react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Spinner = toReact(SvelteSpinner, {}, <span class="hljs-string"><span class="hljs-string">"div"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Spinner size={<span class="hljs-number"><span class="hljs-number">50</span></span>} /&gt;</code> </pre> <br><p><img src="https://habrastorage.org/webt/y7/xl/l1/y7xll1mvvg0lorjn21kz04_g6sq.gif"></p><br><p>  Svelte支持在自定义元素中进行编译，这进一步扩大了组件的应用范围。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">custom-elements-everywhere上</a>看到各种框架对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自</a>定义元素的支持。 </p><br><h2 id="lichnyy-opyt"> 个人经历 </h2><br><p> 我还不能在Svelte上班，因为我们正坐在React生态系统上，但是我有个人项目。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我以前曾写过</a>如何在Google Play上发布我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Metalz</a>应用程序。 </p><br><p><img src="https://habrastorage.org/webt/mr/a8/mm/mra8mmaxfr4odearjgnfbtisbu0.png"></p><br><p> 根据我的感觉，Svelte使您可以编写更简洁和易于理解的代码，同时提供了广泛的工具来简化实现。 </p><br><h2 id="minusy"> 缺点 </h2><br><p> 像任何年轻的框架一样，Svelte拥有一个小型的现成解决方案生态系统，并且很少有文章可以找到最佳实践。 因此，我不建议立即将Svelte用于大型项目，因为您可能会陷入体系结构的死胡同。 </p><br><p> 在小项目上尝试Svelte，我相信您会喜欢的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471702/">https://habr.com/ru/post/zh-CN471702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471678/index.html">按需承担服务</a></li>
<li><a href="../zh-CN471684/index.html">为什么需要为Nginx创建模块</a></li>
<li><a href="../zh-CN471686/index.html">AWS如何酿造其弹性服务。 服务器和数据库扩展</a></li>
<li><a href="../zh-CN471688/index.html">AWS如何酿造其弹性服务。 网络扩展</a></li>
<li><a href="../zh-CN471700/index.html">我如何选择具有未来基础的技术堆栈</a></li>
<li><a href="../zh-CN471704/index.html">该书“ Selfish线粒体。 如何保持健康和改变老年”</a></li>
<li><a href="../zh-CN471706/index.html">使用NetFlow分析可以检测到的9种典型网络问题（以Flowmon为例）</a></li>
<li><a href="../zh-CN471708/index.html">故事点对于开发客户端-服务器应用程序很危险</a></li>
<li><a href="../zh-CN471712/index.html">在React Native上创建移动聊天应用程序</a></li>
<li><a href="../zh-CN471716/index.html">GITEX 2019技术展览会-现状</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>