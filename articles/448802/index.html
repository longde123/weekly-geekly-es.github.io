<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéØ üî° üí∑ Pensar con portales: crear portales en Unreal Engine 4 üè¨ üêâ üåé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, le dir√© c√≥mo crear portales en Unreal Engine 4. No encontr√© ninguna fuente que describiera tal sistema en detalle (monitoreando a tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensar con portales: crear portales en Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="imagen"></div><br>  En este art√≠culo, le dir√© c√≥mo crear portales en Unreal Engine 4. No encontr√© ninguna fuente que describiera tal sistema en detalle (monitoreando a trav√©s de los portales y pasando por ellos), as√≠ que decid√≠ escribir el m√≠o. <br><br><h2>  ¬øQu√© es un portal? </h2><br>  Comencemos con ejemplos y explicaciones de lo que es un portal.  La forma m√°s f√°cil de describir los portales como una forma de paso de un espacio a otro.  En algunos juegos populares, este concepto se usa para efectos visuales e incluso para la mec√°nica del juego: <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplos de portal de juegos (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) y Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Presa, 2006</i> </div></div><br>  De los tres juegos, el m√°s famoso es probablemente Portal, pero personalmente siempre he admirado a Prey y era a ella a quien quer√≠a copiar.  Una vez intent√© implementar mi propia versi√≥n en Unreal Engine 4, pero realmente no tuve √©xito, porque el motor carec√≠a de funcionalidad.  Sin embargo, logr√© realizar estos experimentos: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Su navegador no admite video HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Sin embargo, solo en las nuevas versiones de Unreal Engine finalmente logr√© lograr el efecto deseado: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portales: ¬øc√≥mo funcionan? </h2><br>  Antes de continuar con los detalles, veamos la imagen general de c√≥mo funcionan los portales. <br><br>  De hecho, un portal es una ventana que no sale, pero a otro lugar, es decir, establecemos localmente un punto de vista espec√≠fico relativo al objeto y replicamos este punto de vista en otro lugar.  Usando este principio, podemos conectar dos espacios, incluso si est√°n muy lejos el uno del otro.  La ventana se asemeja a una m√°scara que nos permite averiguar d√≥nde y cu√°ndo mostrar otro espacio en lugar del original.  Dado que el punto de partida de la vista se replica en otro lugar, esto nos da la ilusi√≥n de continuidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  En esta imagen, el dispositivo de captura (SceneCapture en UE4) est√° ubicado frente al espacio que corresponde al espacio visto desde el punto de vista del jugador.  Todo lo que es visible despu√©s de la l√≠nea se reemplaza por lo que la captura puede ver.  Dado que el dispositivo de captura puede ubicarse entre la puerta y otros objetos, es importante utilizar el llamado "plano de recorte".  En el caso del portal, queremos que el plano de recorte cercano enmascare los objetos visibles en frente del portal. <br><br>  Para resumir.  Necesitamos: <br><br><ul><li>  Ubicaci√≥n del jugador </li><li>  Punto de entrada del portal </li><li>  Punto de salida del portal </li><li>  Dispositivo de recorte con plano de recorte </li></ul><br>  ¬øC√≥mo implementar esto en Unreal Engine? <br><br>  Constru√≠ mi sistema sobre la base de dos clases principales administradas por <b>PlayerController</b> y <b>Character</b> .  La clase <b>Portal</b> es un verdadero punto de entrada del portal, cuyo punto de vista / salida es el actor Target.  Tambi√©n hay un <b>Administrador de portal</b> , que es generado por PlayerController y actualizado por Character para administrar cada portal en el nivel y actualizarlos, as√≠ como para manipular el objeto SceneCapture (que es com√∫n a todos los portales). <br><br><blockquote>  Ten en cuenta que el tutorial espera que tengas acceso a las clases Character y PlayerController desde el c√≥digo.  En mi caso, se llaman ExedreCharacter y ExedrePlayerController. </blockquote><br><h2>  Crear una clase de actor de portal </h2><br>  Comencemos con el actor del portal, que se utilizar√° para establecer las "ventanas" a trav√©s de las cuales veremos el nivel.  La tarea del actor es proporcionar informaci√≥n sobre el jugador para calcular varias posiciones y turnos.  Tambi√©n se dedicar√° a reconocer si el jugador cruza el portal y su teletransportaci√≥n. <br><br>  Antes de comenzar una discusi√≥n detallada sobre el actor, perm√≠tanme explicar algunos conceptos que cre√© para administrar el sistema del portal: <br><br><ul><li>  Para el rechazo conveniente de los c√°lculos, el portal tiene un estado activo-inactivo.  Este estado lo actualiza Portal Manager. </li><li>  El portal tiene lados frontal y posterior determinados por su posici√≥n y direcci√≥n (vector hacia adelante). </li><li>  Para averiguar si el jugador cruza el portal, almacena la posici√≥n anterior del jugador y la compara con la actual.  Si en la medida anterior el jugador estaba delante del portal y en la corriente, detr√°s de √©l, entonces creemos que el jugador lo cruz√≥.  El comportamiento inverso se ignora. </li><li>  El portal tiene un volumen l√≠mite, para no realizar c√°lculos y comprobaciones hasta que el jugador est√© en este volumen.  Ejemplo: ignore la intersecci√≥n si el jugador no est√° tocando el portal. </li><li>  La ubicaci√≥n del jugador se calcula a partir de la ubicaci√≥n de la c√°mara para garantizar un comportamiento correcto cuando el punto de vista cruza el portal pero no el cuerpo del jugador. </li><li>  El portal recibe un Objetivo de procesamiento, que muestra un punto de vista diferente en cada medida en caso de que la textura la pr√≥xima vez sea incorrecta y deba reemplazarse. </li><li>  El portal almacena un enlace a otro actor llamado Target, para saber d√≥nde debe contactarse con el otro espacio. </li></ul><br>  Usando estas reglas, cre√© una nueva clase ExedrePortal heredada de AActor como punto de partida.  Aqu√≠ est√° su t√≠tulo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Como puede ver, hay la mayor√≠a de los comportamientos descritos aqu√≠.  Ahora veamos c√≥mo se procesan en el cuerpo (.cpp). <br><br><hr><br>  El dise√±ador aqu√≠ est√° preparando los componentes ra√≠z.  Decid√≠ crear dos componentes ra√≠z, porque el actor del portal combinar√° efectos gr√°ficos y colisiones / reconocimiento.  As√≠ que necesitaba una forma simple de determinar d√≥nde est√° el plano de la ventana / portal, sin la necesidad de funciones de Bluetooth u otros trucos.  PortalRootComponent ser√° la base para todos los c√°lculos relacionados con el portal. <br><br>  La ra√≠z del portal se establece en din√°mica, en caso de que la clase Blueprint la anime (por ejemplo, use una animaci√≥n de apertura / cierre). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Solo hay funciones Get y Set, y nada m√°s.  Gestionaremos el estado de la actividad desde otro lugar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Eventos de planos, no estoy haciendo nada en la clase C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Las funciones Get y Set para el actor Target.  No hay nada m√°s complicado en esta parte tampoco. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Con esta funci√≥n, podemos verificar f√°cilmente si un punto est√° frente a un plano, y en nuestro caso es un portal.  La funci√≥n utiliza la estructura FPlane del motor UE4 para realizar c√°lculos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Esta funci√≥n verifica si el punto ha cruzado el plano del portal.  Es aqu√≠ donde usamos la posici√≥n anterior para descubrir c√≥mo se comporta el punto.  Esta funci√≥n es com√∫n para que pueda funcionar con cualquier actor, pero en mi caso solo se usa con el jugador. <br><br>  La funci√≥n crea una direcci√≥n / segmento entre la ubicaci√≥n anterior y la actual, y luego verifica si se cruzan con el plano.  Si es as√≠, verificamos si se cruza en la direcci√≥n correcta (¬øde adelante hacia atr√°s?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Teleport Actor </h2><br>  La √∫ltima parte del actor del portal que veremos es la funci√≥n <b>TeleportActor ()</b> . <br><br>  Al teletransportar a un actor del punto A al punto B, debe replicar su movimiento y posici√≥n.  Por ejemplo, si un jugador pasa al portal, en combinaci√≥n con los efectos visuales adecuados, le parecer√° que atraves√≥ una puerta ordinaria. <br><br>  La intersecci√≥n del portal se siente como moverse en l√≠nea recta, pero en realidad sucede algo completamente diferente.  Al salir del portal, el jugador puede encontrarse en un contexto muy diferente.  Considere un ejemplo de Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Como puede ver, al cruzar el portal, la c√°mara gira en relaci√≥n con su vector hacia adelante (gira).  Esto se debe a que los puntos inicial y final son paralelos a diferentes planos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Por lo tanto, para que esto funcione, necesitamos transformar el movimiento del jugador en el espacio relativo del portal para convertirlo en el espacio Objetivo.  Al implementar esto, podemos estar seguros de que despu√©s de ingresar al portal y salir del otro lado, el jugador estar√° correctamente alineado con respecto al espacio.  Esto se aplica no solo a la posici√≥n y rotaci√≥n del actor, sino tambi√©n a su <b>velocidad</b> . <br><br><blockquote>  Si teletransportamos a un actor sin cambios, convirti√©ndolo en una rotaci√≥n local, entonces, como resultado, el actor puede encontrarse al rev√©s.  Esto puede ser adecuado para objetos, pero no aplicable a los personajes o al jugador mismo.  Debe cambiar la posici√≥n del actor, como se muestra arriba en el ejemplo de Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Como probablemente haya notado, para llamar a rotaci√≥n / posici√≥n, llamo funciones externas.  Se llaman desde la clase de usuario UTool, que define funciones est√°ticas que se pueden llamar desde cualquier lugar (incluidos los planos).  Su c√≥digo se muestra a continuaci√≥n, puede implementarlos de la manera que le parezca mejor (probablemente sea m√°s f√°cil colocarlos en la clase de actor Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  La transformaci√≥n aqu√≠ se realiza calculando el producto escalar de vectores para determinar diferentes √°ngulos.  El vector de direcci√≥n no est√° normalizado, es decir, podemos multiplicar nuevamente el resultado de los puntos por vectores de destino para obtener la posici√≥n exactamente a la misma distancia en el espacio local del actor de destino. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Convertir la transformaci√≥n fue un poco m√°s dif√≠cil de implementar.  Al final, la mejor soluci√≥n result√≥ ser el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">cuaterniones</a> , porque esto es mucho m√°s preciso que trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">√°ngulos</a> normales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Euler</a> y requiere solo unas pocas l√≠neas de c√≥digo.  Las rotaciones por cuaterniones se realizan mediante multiplicaci√≥n, por lo que en nuestro caso, aplicando Inverse () a la rotaci√≥n que queremos convertir, la trasladaremos al espacio local.  A continuaci√≥n, solo tenemos que multiplicarlo nuevamente por el turno Objetivo para obtener el turno final. <br><br><h2>  Crear una malla de portal </h2><br>  Para lucir bella desde el punto de vista de un jugador, mi sistema de portal utiliza una malla espec√≠fica.  La malla se divide en dos planos diferentes: <br><br><ul><li>  <b>Plano 1</b> : el plano principal en el que se muestra el objetivo de representaci√≥n del portal.  Este avi√≥n tiene un comportamiento bastante inusual, porque su tarea es alejarse un poco del jugador cuando se acerca para evitar que la c√°mara lo recorte.  Dado que los bordes del avi√≥n no se mueven, sino que solo se mueven sus picos medios, esto le permite al jugador superponer al renderizar el portal sin artefactos visuales.  Los bordes en los bordes tienen su propio UV en la mitad superior, mientras que los bordes internos tienen su propio UV en la mitad inferior, lo que facilita enmascararlos en el sombreador. </li><li>  <b>Plano 2</b> : este plano solo se usa para extender el cuadro delimitador est√°ndar de la malla.  Las normales de los v√©rtices se dirigen hacia abajo, por lo que incluso en terreno no plano la malla no ser√° visible por defecto (porque el material de renderizado no ser√° de dos lados). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  ¬øPor qu√© usar una malla como esta? <br><br>  Decid√≠ que el "avi√≥n 1" se estirar√≠a a medida que el jugador se acercara.  Esto permite que el jugador se superponga al portal y lo atraviese sin recortar (cortar).  Esto puede suceder, por ejemplo, si la c√°mara a√∫n no ha cruzado el plano del portal, pero los pies del jugador ya la han tocado.  Esto le permite no cortar el reproductor y duplicar la malla por otro lado. <br><br>  La tarea del "plano 2" es extender el cuadro delimitador est√°ndar de la malla.  Dado que el "plano 1" es plano, el cuadro delimitador en un eje tiene un grosor de 0, y si la c√°mara est√° detr√°s, el motor lo cortar√° (es decir, no lo renderizar√°).  El avi√≥n 1 tiene un tama√±o de 128 √ó 128, por lo que se puede escalar f√°cilmente con el motor.  El plano 2 es ligeramente m√°s grande y est√° debajo del piso (debajo de 0). <br><br>  Una vez creada la malla, simplemente la exportamos desde un editor 3D de terceros y la importamos a Unreal.  Se usar√° en el siguiente paso. <br><br><h2>  Crear material del portal </h2><br>  Para mostrar el otro lado del portal, necesitamos crear nuestro propio material.  Cree nuevo material en el navegador de contenido (lo llam√© <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Ahora √°bralo y cree el siguiente gr√°fico: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  As√≠ es como funciona el material: <br><br><ul><li>  <b>FadeColor</b> es el color que ser√° visible a trav√©s del portal cuando est√© muy lejos.  Es necesario porque no siempre renderizamos todos los portales, por lo que oscurecemos el renderizado cuando el reproductor / c√°mara est√° muy lejos. </li><li>  Para averiguar qu√© tan lejos est√° el jugador del portal, determino la <b>distancia</b> entre la posici√≥n de la c√°mara y la posici√≥n del actor.  Luego divido la distancia por el valor m√°ximo con el que quiero realizar una comparaci√≥n.  Por ejemplo, si el m√°ximo que configur√© es 2000, y la distancia al jugador es 1000, entonces obtenemos 0.5.  Si el jugador est√° m√°s lejos, obtendr√© un valor mayor que 1, as√≠ que uso nodos saturados para limitarlo.  Luego viene el nodo Smoothstep, usado para escalar la distancia como un gradiente y controlar con mayor precisi√≥n el sombreado del portal.  Por ejemplo, cuando el jugador est√° cerca, quiero que la sombra desaparezca por completo. </li><li>  Utilizo el c√°lculo de distancia como el valor del canal alfa para el nodo <b>Lerp</b> para mezclar el color de sombreado y la <b>textura</b> que representar√° el objetivo del portal. </li><li>  Finalmente, a√≠slo el componente Y de las coordenadas UV para crear una m√°scara que le permita saber qu√© v√©rtices de la malla ser√°n empujados.  Multiplico esta m√°scara por la cantidad de repulsi√≥n que necesito.  Utilizo un valor negativo para que cuando las normales de los v√©rtices se multipliquen por los v√©rtices, se muevan en la direcci√≥n opuesta. </li></ul><br>  Una vez hecho todo esto, creamos material listo para usar. <br><br><h2>  Crear un actor de portal en Blueprint </h2><br>  Configuremos una nueva clase de blueprint heredada del actor Portal.  Haga clic derecho en el navegador de contenido y seleccione la clase Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Ahora ingrese "portal" en el campo de b√∫squeda para seleccionar la clase de portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Abra bluetooth si a√∫n no est√° abierto.  En la lista de componentes ver√° la siguiente jerarqu√≠a: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Como esper√°bamos, hay un componente ra√≠z y una ra√≠z de portal.  Agreguemos un componente de malla est√°tica a PortalRootComponent y carguemos la malla creada en el paso anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Tambi√©n agregamos el cuadro de colisi√≥n, que se utilizar√° para determinar si el jugador est√° dentro del volumen del portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  El cuadro Colisi√≥n se encuentra debajo del componente de escena asociado con la ra√≠z principal, y no debajo de la ra√≠z del Portal.  Tambi√©n agregu√© un √≠cono (cartelera) y un componente de flecha para hacer que el portal sea m√°s visible en los niveles.  Por supuesto, esto no es necesario. <br><br>  Ahora configuremos el material en plano. <br><br>  Para empezar, necesitamos dos variables: una ser√° del tipo <b>Actor</b> y el nombre es <b>PortalTarget</b> , la segunda es del tipo <b>Dynamic Material Instance</b> y se llama <b>MaterialInstance</b> .  PortalTarget ser√° una referencia a la posici√≥n que est√° mirando la ventana del portal (por lo tanto, la variable es com√∫n, con un icono de ojo abierto) para que podamos cambiarla cuando el actor se coloca en el nivel.  MaterialInstance almacenar√° un enlace a material din√°mico para que en el futuro podamos asignar el objetivo de renderizado del portal sobre la marcha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Tambi√©n necesitamos agregar nuestros propios nodos de eventos.  Es mejor abrir el men√∫ derecho del mouse en el <b>Gr√°fico de eventos</b> y encontrar los nombres de los eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Y aqu√≠ para crear el siguiente diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Comenzar reproducci√≥n</b> : aqu√≠ llamamos a la funci√≥n principal SetTarget () del portal para asignarle un enlace al actor, que luego se usar√° para SceneCapture.  Luego creamos un nuevo material din√°mico y le asignamos el valor de la variable MaterialInstance.  Con este nuevo material, podemos asignarlo al componente de malla est√°tica.  Tambi√©n le di al material una textura ficticia, pero esto es opcional. </li><li>  <b>Borrar RTT</b> : el prop√≥sito de esta funci√≥n es borrar la textura de Render Target asignada al material del portal.  Es lanzado por el administrador del portal. </li><li>  <b>Establecer RTT</b> : el prop√≥sito de esta funci√≥n es establecer el material de destino del portal.  Es lanzado por el administrador del portal. </li></ul><br>  Hasta ahora hemos terminado con bluetooth, pero volveremos m√°s tarde para implementar las funciones de Tick. <br><br><h2>  Administrador del portal </h2><br>  Entonces, ahora tenemos todos los elementos b√°sicos necesarios para crear una nueva clase heredada de AActor, que ser√° Portal Manager.  Es posible que no necesite la clase Portal Manager en su proyecto, pero en mi caso, simplifica enormemente el trabajo con algunos aspectos.  Aqu√≠ hay una lista de tareas realizadas por el administrador del portal: <br><br><ul><li>  El administrador del portal es un actor <b>creado por el controlador del jugador</b> y conectado a √©l para rastrear el estado y la evoluci√≥n del jugador dentro del nivel del juego. </li><li>  Crear y destruir <b>el portal de destino de renderizado</b> .  La idea es crear din√°micamente una textura de destino de renderizado que coincida con la resoluci√≥n de pantalla del jugador.  Adem√°s, al cambiar la resoluci√≥n durante el juego, el administrador la convertir√° autom√°ticamente al tama√±o deseado. </li><li>  El administrador del portal <b>encuentra y actualiza</b> el nivel de actor del portal para darles un objetivo de representaci√≥n.  Esta tarea se realiza de manera que se garantice la compatibilidad con el nivel de transmisi√≥n.  Cuando aparece un nuevo actor, debe obtener una textura.  Adem√°s, si el objetivo Render cambia, el administrador tambi√©n puede asignar uno nuevo autom√°ticamente.  Esto facilita la administraci√≥n del sistema, en lugar de hacer que cada actor del Portal se comunique manualmente con el administrador. </li><li>  El componente <b>SceneCapture est√°</b> conectado al administrador del portal, para no crear una copia para cada portal.  Adem√°s, le permite reutilizarlo cada vez que cambiemos a un actor de portal espec√≠fico en el nivel. </li><li>  Cuando el portal decide <b>teletransportar al</b> jugador, env√≠a una solicitud al Administrador del portal.  Esto es necesario para actualizar los portales de origen y de destino (si los hay), para que la transici√≥n ocurra sin uniones. </li><li>  <b>El</b> administrador del portal se <b>actualiza</b> al final de la funci√≥n <b>tick ()</b> del <b>personaje</b> para que todo se actualice correctamente, incluida la c√°mara del jugador.  Esto asegura que todo en la pantalla est√© sincronizado y evita un retraso de un cuadro durante el renderizado por el motor. </li></ul><br>  Echemos un vistazo al encabezado de Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Antes de entrar en detalles, mostrar√© c√≥mo se crea un actor a partir de la clase Player Controller, llamada desde la funci√≥n BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Entonces, creamos un actor, lo adjuntamos al controlador del jugador (esto), y luego guardamos el enlace y llamamos a la funci√≥n Init (). <br><br>  Tambi√©n es importante tener en cuenta que actualizamos el actor manualmente desde la clase Character: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Y aqu√≠ est√° el constructor de Portal Manager.  Tenga en cuenta que Tick est√° deshabilitado, nuevamente porque actualizaremos manualmente Portal Manager a trav√©s del reproductor. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Estas son las funciones de get / set Portal Manager (despu√©s de eso pasaremos a cosas m√°s interesantes): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Obviamente, lo primero para comenzar es la funci√≥n <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo principal de esta funci√≥n es crear el componente SceneCapture (es decir, el dispositivo de captura mencionado anteriormente) y configurarlo correctamente. </font><font style="vertical-align: inherit;">Comienza con la creaci√≥n de un nuevo objeto y su registro como componente de este actor. </font><font style="vertical-align: inherit;">Luego pasamos a establecer propiedades relacionadas con esta captura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propiedades a mencionar:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : no queremos que la captura se active cuando no la necesitamos. </font><font style="vertical-align: inherit;">Lo gestionaremos manualmente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una propiedad bastante importante para representar la captura del portal correctamente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esto nos permite reemplazar la proyecci√≥n de Captura por la nuestra, seg√∫n el punto de vista del jugador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este modo es un poco costoso, pero necesario para representar una cantidad suficiente de informaci√≥n.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las propiedades restantes est√°n relacionadas principalmente con los par√°metros de postprocesamiento. </font><font style="vertical-align: inherit;">Son una forma conveniente de controlar la calidad y, por lo tanto, capturar el rendimiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima parte llama a la funci√≥n que crea el Destino de renderizado, que veremos a continuaci√≥n.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una funci√≥n que se llama cuando es necesario cuando necesita crear una nueva textura Render Target para portales. </font><font style="vertical-align: inherit;">Esto sucede en la funci√≥n de inicializaci√≥n, pero tambi√©n se puede invocar durante la actualizaci√≥n de Portal Manager. </font><font style="vertical-align: inherit;">Es por eso que esta funci√≥n tiene una verificaci√≥n interna para cambiar la resoluci√≥n de la ventana gr√°fica. </font><font style="vertical-align: inherit;">Si no sucedi√≥, entonces la actualizaci√≥n no se realiza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En mi caso, cre√© una clase de contenedor para UCanvasRenderTarget2D. Lo llam√© ExedreScriptedTexture, es un componente que se puede conectar a un actor. Cre√© esta clase para administrar convenientemente los objetivos de renderizado con actores que tienen tareas de renderizado. Realiza la inicializaci√≥n adecuada del Render Target y es compatible con mi propio sistema de interfaz de usuario. Sin embargo, en el contexto de los portales, una textura RenderTarget2D normal es m√°s que suficiente. Por lo tanto, simplemente puede usarlo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se mencion√≥ anteriormente, cre√© mi propia clase, por lo que las propiedades establecidas aqu√≠ deben adaptarse al objetivo de renderizado habitual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es importante comprender d√≥nde se mostrar√° la captura. </font><font style="vertical-align: inherit;">Dado que el objetivo de renderizado se mostrar√° en el juego, esto significa que esto suceder√° antes de todo el procesamiento posterior y, por lo tanto, necesitamos renderizar la escena con suficiente informaci√≥n (para almacenar valores superiores a 1 para crear Bloom). </font><font style="vertical-align: inherit;">Es por eso que eleg√≠ el formato RGBA16 (tenga en cuenta que tiene su propia Enum, necesitar√° usar ETextureRenderTargetFormat en su lugar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener m√°s informaci√≥n, consulte las siguientes fuentes:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s consideraremos las funciones de actualizaci√≥n. </font><font style="vertical-align: inherit;">La funci√≥n b√°sica es bastante simple y causa m√°s compleja. </font><font style="vertical-align: inherit;">Hay una demora antes de llamar a la funci√≥n GeneratePortalTexture () para evitar volver a crear el destino de representaci√≥n al cambiar el tama√±o de la ventana gr√°fica (por ejemplo, en el editor). </font><font style="vertical-align: inherit;">Durante la publicaci√≥n del juego, este retraso puede eliminarse.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamamos a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar todos los portales presentes en el mundo actual (incluidos todos los niveles cargados) y actualizarlos. </font><font style="vertical-align: inherit;">La funci√≥n tambi√©n determina cu√°l est√° "activo", es decir </font><font style="vertical-align: inherit;">visible para el jugador. </font><font style="vertical-align: inherit;">Si encontramos un portal activo, llamamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que controla el componente SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como funciona la actualizaci√≥n mundial dentro de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificaci√≥n que determina la correcci√≥n del portal es simple: le damos prioridad al portal m√°s cercano al jugador, porque lo m√°s probable es que sea el m√°s visible desde su punto de vista. </font><font style="vertical-align: inherit;">Para descartar parientes, pero, por ejemplo, portales ubicados detr√°s del jugador, se requerir√°n controles m√°s complejos, pero no quer√≠a centrarme en esto en mi tutorial, porque puede ser bastante dif√≠cil.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hora de considerar la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una funci√≥n de actualizaci√≥n que captura el otro lado del portal. </font><font style="vertical-align: inherit;">De los comentarios todo debe quedar claro, pero aqu√≠ hay una breve descripci√≥n:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlaces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a Controlador de personaje y jugador.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si todo es correcto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, componente SceneCapture, Reproductor).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como podemos ver, al teletransportar a un jugador, un elemento clave del comportamiento natural e impecable de SceneCapture es la correcta transformaci√≥n de la posici√≥n y la rotaci√≥n del portal en el espacio Target local. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para la definici√≥n de ConvertLocationToActorSpace (), consulte "Teletransportaci√≥n de un actor". </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no existe por defecto en la clase PlayerController, la agregu√© yo mismo. </font><font style="vertical-align: inherit;">Se muestra a continuaci√≥n:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, necesitamos implementar la llamada a la funci√≥n Teleport. </font><font style="vertical-align: inherit;">La raz√≥n para el procesamiento parcial de la teletransportaci√≥n a trav√©s del administrador del Portal es que es necesario garantizar la actualizaci√≥n de los portales necesarios, porque solo el Administrador tiene informaci√≥n sobre todos los portales en la escena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tenemos dos portales conectados, entonces, al cambiar de uno a otro, necesitamos actualizar ambos en un Tick. </font><font style="vertical-align: inherit;">De lo contrario, el jugador se teletransportar√° y estar√° al otro lado del portal, pero el Portal de destino no estar√° activo hasta el pr√≥ximo cuadro / medida. </font><font style="vertical-align: inherit;">Esto crear√° huecos visuales con el material desplazado de la malla plana que vimos arriba.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bueno, eso es todo, ¬°finalmente hemos terminado con Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Termina el plano </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez completado el Administrador del portal, solo necesitamos completar el actor del Portal, despu√©s de lo cual el sistema funcionar√°. </font><font style="vertical-align: inherit;">Lo √∫nico que falta aqu√≠ son las caracter√≠sticas de Tick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As√≠ es como funciona: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos actualizando el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que no permanezca en un estado activo.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el portal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√°</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actualmente </font><b><font style="vertical-align: inherit;">inactivo</font></b><font style="vertical-align: inherit;"> , el resto de la medida se descarta.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos la clase de personaje para acceder a la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ubicaci√≥n de la c√°mara</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera parte verifica si la c√°mara est√° en el cuadro de colisi√≥n del portal. </font><font style="vertical-align: inherit;">Si es as√≠, compensamos la malla del portal con su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda parte es volver a verificar la ubicaci√≥n dentro del cuadro de colisi√≥n. </font><font style="vertical-align: inherit;">Si se ejecuta, llamamos a una funci√≥n que verifica </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si cruzamos el portal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la captura de pantalla de mi gr√°fico, puede observar dos puntos interesantes: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Todav√≠a no he explicado estas dos funciones. Estas son funciones est√°ticas que defin√≠ en mi propia clase para que pueda llamarlas desde cualquier lugar. Este es un tipo de clase auxiliar. El c√≥digo de estas funciones se muestra a continuaci√≥n, usted mismo puede decidir d√≥nde insertarlas. Si no los necesita fuera del sistema de portal, puede insertarlos directamente en la clase de actor Portal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio quer√≠a usar el sistema de colisi√≥n para determinar si el actor del portal dentro del cuadro de colisi√≥n est√° en el portal, pero me pareci√≥ que no era lo suficientemente confiable. Adem√°s, me parece que este m√©todo es m√°s r√°pido de usar y tiene una ventaja: tiene en cuenta la rotaci√≥n del actor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima parte del actor Blueprint es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Recuerda que se llama Force Tick cuando un jugador cruza un portal y est√° al lado de otro portal para el que Portal Manager est√° forzando una actualizaci√≥n. </font><font style="vertical-align: inherit;">Como nos teletransportamos, no es necesario usar el mismo c√≥digo, y puede usar su versi√≥n simplificada:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El proceso comienza aproximadamente al mismo tiempo que la funci√≥n Tick, pero solo ejecutamos la primera parte de la secuencia, que actualiza el material. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemos terminado? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si implementamos el sistema de portal de esta forma, lo m√°s probable es que encontremos el siguiente problema:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© est√° pasando aqu√≠? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este gif, la velocidad de fotogramas del juego se limita a 6 FPS para mostrar el problema con mayor claridad. En un cuadro, el cubo desaparece porque el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema de recorte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine lo considera invisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se debe a que el descubrimiento se realiza en el marco actual y luego se usa en el siguiente. Esto crea un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retraso de un cuadro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto generalmente se puede resolver expandiendo el cuadro delimitador del objeto para que se registre antes de que sea visible. Sin embargo, esto no funcionar√° aqu√≠, porque cuando cruzamos el portal, nos teletransportamos de un lugar a otro completamente diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar el sistema de recorte tambi√©n es imposible, especialmente porque a niveles con muchos objetos esto reducir√° el rendimiento. Adem√°s, prob√© muchos equipos del motor Unreal, pero no obtuve resultados positivos: en todos los casos, se mantuvo un retraso de un cuadro. Afortunadamente, despu√©s de un estudio detallado del c√≥digo fuente de Unreal Engine, logr√© encontrar una soluci√≥n (el camino fue largo, ¬°tom√≥ m√°s de una semana)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con el componente SceneCapture, puedes decirle a la c√°mara del jugador que hicimos un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corte de salto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- la posici√≥n de la c√°mara salt√≥ entre dos cuadros, lo que significa que no podemos confiar en la informaci√≥n del cuadro anterior. </font><font style="vertical-align: inherit;">Este comportamiento se puede observar cuando se usa Matinee o Sequencer, por ejemplo, al cambiar de c√°mara: el desenfoque de movimiento o el suavizado no pueden depender de la informaci√≥n del fotograma anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, debemos considerar dos aspectos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esta clase procesa diversa informaci√≥n (por ejemplo, la vista del jugador) y est√° asociada con el PlayerController. </font><font style="vertical-align: inherit;">Aqu√≠ es donde podemos influir en el proceso de renderizado de la c√°mara del jugador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando un jugador se teletransporta, esta clase comienza a empalmarse gracias al acceso a LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La gran ventaja de esta soluci√≥n es que la intervenci√≥n en el proceso de renderizado del motor es m√≠nima y f√°cil de mantener en futuras actualizaciones de Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos creando una nueva clase heredada de LocalPlayer. </font><font style="vertical-align: inherit;">A continuaci√≥n se muestra un encabezado que identifica dos componentes principales: redefinir los c√°lculos de la vista de escena y una nueva funci√≥n para invocar el pegado de la c√°mara.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As√≠ es como se implementa todo: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplemente inicia Camera Cut con un valor booleano. </font><font style="vertical-align: inherit;">Cuando el motor llama a la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , primero ejecutamos la funci√≥n original. </font><font style="vertical-align: inherit;">Luego verificamos, tenemos que realizar el pegado. </font><font style="vertical-align: inherit;">Si es as√≠, redefinimos la variable booleana Camera Cut dentro de la estructura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que ser√° utilizada por el proceso de renderizado del motor, y luego restablecemos la variable booleana ( </font><b><font style="vertical-align: inherit;">√∫sela</font></b><font style="vertical-align: inherit;"> ).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el lado del controlador del jugador, los cambios son m√≠nimos. </font><font style="vertical-align: inherit;">Debe agregar una variable al encabezado para almacenar un enlace a la clase nativa LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, en la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n agregu√© una funci√≥n para iniciar r√°pidamente Cut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, en la funci√≥n de Administrador de portal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podemos ejecutar durante la teletransportaci√≥n de Camera Cut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Y eso es todo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se debe llamar a Camera Cut antes de actualizar SceneCapture, raz√≥n por la cual se encuentra al comienzo de la funci√≥n.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultado final </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hemos aprendido a pensar en portales. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el sistema funciona bien, entonces deber√≠amos poder crear estas cosas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si tiene problemas, compruebe lo siguiente: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique que Portal Manager se haya creado e inicializado correctamente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El objetivo de representaci√≥n se crea correctamente (puede usar el creado en el navegador de contenido para comenzar). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los portales est√°n correctamente activados y desactivados. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los portales tienen el actor Target configurado correctamente en el editor. </font></font></li></ul><br><h2>  Preguntas y respuestas </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las preguntas m√°s populares que me hicieron sobre este tutorial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs posible implementar esto en blunts y no a trav√©s de C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor parte del c√≥digo se puede implementar en romos, con la excepci√≥n de dos aspectos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData () de LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizada para obtener la matriz de proyecci√≥n no est√° disponible en planos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es cr√≠tica para resolver el problema del sistema de recorte, no est√° disponible en planos.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, debe usar una implementaci√≥n de C ++ para acceder a estas dos funciones o modificar el c√≥digo fuente del motor para que sea accesible a trav√©s de planos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPuedo usar este sistema en VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√≠, en su mayor parte. </font><font style="vertical-align: inherit;">Sin embargo, algunas partes deber√°n adaptarse, por ejemplo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe usar dos objetivos de renderizado (uno para cada ojo) y enmascararlos en el material del portal para mostrar uno al lado del otro en el espacio de la pantalla. </font><font style="vertical-align: inherit;">Cada objetivo de renderizado debe tener la mitad del ancho de la resoluci√≥n del dispositivo VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debe usar dos SceneCapture para representar el objetivo con la distancia correcta (la distancia entre los ojos) para crear efectos estereosc√≥picos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal problema ser√° el rendimiento, ya que el otro lado del portal deber√° representarse dos veces. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPuede otro objeto cruzar el portal?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hay en mi c√≥digo. Sin embargo, hacerlo m√°s general no es tan dif√≠cil. Para hacer esto, el portal necesita rastrear m√°s informaci√≥n sobre todos los objetos cercanos para verificar si lo cruzan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEl sistema admite recursividad (portal dentro del portal)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este tutorial no lo es. Para la recursividad, necesita un destino de renderizado adicional y SceneCapture. Tambi√©n ser√° necesario determinar qu√© RenderTarget se representar√° primero, y as√≠ sucesivamente. Esto es bastante dif√≠cil y no quer√≠a hacerlo, porque para mi proyecto esto no es necesario. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPuedo cruzar el portal cerca de la pared?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamentablemente no. </font><font style="vertical-align: inherit;">Sin embargo, veo dos formas de implementar esto (te√≥ricamente):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactiva las colisiones del jugador para que pueda atravesar las paredes. </font><font style="vertical-align: inherit;">Es f√°cil de implementar, pero generar√° muchos efectos secundarios.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hackea un sistema de colisi√≥n para crear un agujero de forma din√°mica, lo que permitir√° al jugador pasar. </font><font style="vertical-align: inherit;">Para hacer esto, debe modificar el sistema f√≠sico del motor. </font><font style="vertical-align: inherit;">Sin embargo, por lo que s√©, despu√©s de cargar el nivel, la f√≠sica est√°tica no se puede actualizar. </font><font style="vertical-align: inherit;">Por lo tanto, admitir esta funci√≥n requerir√° mucho trabajo. </font><font style="vertical-align: inherit;">Si sus portales son est√°ticos, entonces probablemente pueda solucionar este problema utilizando la transmisi√≥n de nivel para cambiar entre diferentes colisiones.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448802/">https://habr.com/ru/post/448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448792/index.html">Prueba de Python con pytest. Accesorios incorporados, Cap√≠tulo 4</a></li>
<li><a href="../448794/index.html">Prueba de Python con pytest. Complementos CAP√çTULO 5</a></li>
<li><a href="../448796/index.html">Prueba de Python con pytest. Configuraci√≥n, CAP√çTULO 6</a></li>
<li><a href="../448798/index.html">Prueba de Python con pytest. Usando pytest con otras herramientas, CAP√çTULO 7</a></li>
<li><a href="../448800/index.html">Configure Visual Studio en toda su organizaci√≥n con .vsconfig</a></li>
<li><a href="../448804/index.html">Prepar√°ndose para el tiempo de ejecuci√≥n y el notario endurecidos de macOS</a></li>
<li><a href="../448806/index.html">Crear un sistema de extensi√≥n en la biblioteca Qt</a></li>
<li><a href="../448808/index.html">Sobre cosas simples, complicadas. "Acero dormido". C√≥mo engrasar pernos oxidados o no WD-40 con un solo ...</a></li>
<li><a href="../448810/index.html">¬øC√≥mo atrap√© a un hacker?</a></li>
<li><a href="../448812/index.html">Misi√≥n lunar "Bereshit": busca la primera biblioteca lunar despu√©s de que el accidente de su portador haya comenzado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>