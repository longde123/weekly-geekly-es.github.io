<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꿢 游댜 游눵 Pensar con portales: crear portales en Unreal Engine 4 游낇 游낼 游깵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art칤culo, le dir칠 c칩mo crear portales en Unreal Engine 4. No encontr칠 ninguna fuente que describiera tal sistema en detalle (monitoreando a tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensar con portales: crear portales en Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="imagen"></div><br>  En este art칤culo, le dir칠 c칩mo crear portales en Unreal Engine 4. No encontr칠 ninguna fuente que describiera tal sistema en detalle (monitoreando a trav칠s de los portales y pasando por ellos), as칤 que decid칤 escribir el m칤o. <br><br><h2>  쯈u칠 es un portal? </h2><br>  Comencemos con ejemplos y explicaciones de lo que es un portal.  La forma m치s f치cil de describir los portales como una forma de paso de un espacio a otro.  En algunos juegos populares, este concepto se usa para efectos visuales e incluso para la mec치nica del juego: <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplos de portal de juegos (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) y Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Presa, 2006</i> </div></div><br>  De los tres juegos, el m치s famoso es probablemente Portal, pero personalmente siempre he admirado a Prey y era a ella a quien quer칤a copiar.  Una vez intent칠 implementar mi propia versi칩n en Unreal Engine 4, pero realmente no tuve 칠xito, porque el motor carec칤a de funcionalidad.  Sin embargo, logr칠 realizar estos experimentos: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Su navegador no admite video HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Sin embargo, solo en las nuevas versiones de Unreal Engine finalmente logr칠 lograr el efecto deseado: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portales: 쯖칩mo funcionan? </h2><br>  Antes de continuar con los detalles, veamos la imagen general de c칩mo funcionan los portales. <br><br>  De hecho, un portal es una ventana que no sale, pero a otro lugar, es decir, establecemos localmente un punto de vista espec칤fico relativo al objeto y replicamos este punto de vista en otro lugar.  Usando este principio, podemos conectar dos espacios, incluso si est치n muy lejos el uno del otro.  La ventana se asemeja a una m치scara que nos permite averiguar d칩nde y cu치ndo mostrar otro espacio en lugar del original.  Dado que el punto de partida de la vista se replica en otro lugar, esto nos da la ilusi칩n de continuidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  En esta imagen, el dispositivo de captura (SceneCapture en UE4) est치 ubicado frente al espacio que corresponde al espacio visto desde el punto de vista del jugador.  Todo lo que es visible despu칠s de la l칤nea se reemplaza por lo que la captura puede ver.  Dado que el dispositivo de captura puede ubicarse entre la puerta y otros objetos, es importante utilizar el llamado "plano de recorte".  En el caso del portal, queremos que el plano de recorte cercano enmascare los objetos visibles en frente del portal. <br><br>  Para resumir.  Necesitamos: <br><br><ul><li>  Ubicaci칩n del jugador </li><li>  Punto de entrada del portal </li><li>  Punto de salida del portal </li><li>  Dispositivo de recorte con plano de recorte </li></ul><br>  쮺칩mo implementar esto en Unreal Engine? <br><br>  Constru칤 mi sistema sobre la base de dos clases principales administradas por <b>PlayerController</b> y <b>Character</b> .  La clase <b>Portal</b> es un verdadero punto de entrada del portal, cuyo punto de vista / salida es el actor Target.  Tambi칠n hay un <b>Administrador de portal</b> , que es generado por PlayerController y actualizado por Character para administrar cada portal en el nivel y actualizarlos, as칤 como para manipular el objeto SceneCapture (que es com칰n a todos los portales). <br><br><blockquote>  Ten en cuenta que el tutorial espera que tengas acceso a las clases Character y PlayerController desde el c칩digo.  En mi caso, se llaman ExedreCharacter y ExedrePlayerController. </blockquote><br><h2>  Crear una clase de actor de portal </h2><br>  Comencemos con el actor del portal, que se utilizar치 para establecer las "ventanas" a trav칠s de las cuales veremos el nivel.  La tarea del actor es proporcionar informaci칩n sobre el jugador para calcular varias posiciones y turnos.  Tambi칠n se dedicar치 a reconocer si el jugador cruza el portal y su teletransportaci칩n. <br><br>  Antes de comenzar una discusi칩n detallada sobre el actor, perm칤tanme explicar algunos conceptos que cre칠 para administrar el sistema del portal: <br><br><ul><li>  Para el rechazo conveniente de los c치lculos, el portal tiene un estado activo-inactivo.  Este estado lo actualiza Portal Manager. </li><li>  El portal tiene lados frontal y posterior determinados por su posici칩n y direcci칩n (vector hacia adelante). </li><li>  Para averiguar si el jugador cruza el portal, almacena la posici칩n anterior del jugador y la compara con la actual.  Si en la medida anterior el jugador estaba delante del portal y en la corriente, detr치s de 칠l, entonces creemos que el jugador lo cruz칩.  El comportamiento inverso se ignora. </li><li>  El portal tiene un volumen l칤mite, para no realizar c치lculos y comprobaciones hasta que el jugador est칠 en este volumen.  Ejemplo: ignore la intersecci칩n si el jugador no est치 tocando el portal. </li><li>  La ubicaci칩n del jugador se calcula a partir de la ubicaci칩n de la c치mara para garantizar un comportamiento correcto cuando el punto de vista cruza el portal pero no el cuerpo del jugador. </li><li>  El portal recibe un Objetivo de procesamiento, que muestra un punto de vista diferente en cada medida en caso de que la textura la pr칩xima vez sea incorrecta y deba reemplazarse. </li><li>  El portal almacena un enlace a otro actor llamado Target, para saber d칩nde debe contactarse con el otro espacio. </li></ul><br>  Usando estas reglas, cre칠 una nueva clase ExedrePortal heredada de AActor como punto de partida.  Aqu칤 est치 su t칤tulo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Como puede ver, hay la mayor칤a de los comportamientos descritos aqu칤.  Ahora veamos c칩mo se procesan en el cuerpo (.cpp). <br><br><hr><br>  El dise침ador aqu칤 est치 preparando los componentes ra칤z.  Decid칤 crear dos componentes ra칤z, porque el actor del portal combinar치 efectos gr치ficos y colisiones / reconocimiento.  As칤 que necesitaba una forma simple de determinar d칩nde est치 el plano de la ventana / portal, sin la necesidad de funciones de Bluetooth u otros trucos.  PortalRootComponent ser치 la base para todos los c치lculos relacionados con el portal. <br><br>  La ra칤z del portal se establece en din치mica, en caso de que la clase Blueprint la anime (por ejemplo, use una animaci칩n de apertura / cierre). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Solo hay funciones Get y Set, y nada m치s.  Gestionaremos el estado de la actividad desde otro lugar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Eventos de planos, no estoy haciendo nada en la clase C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Las funciones Get y Set para el actor Target.  No hay nada m치s complicado en esta parte tampoco. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Con esta funci칩n, podemos verificar f치cilmente si un punto est치 frente a un plano, y en nuestro caso es un portal.  La funci칩n utiliza la estructura FPlane del motor UE4 para realizar c치lculos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Esta funci칩n verifica si el punto ha cruzado el plano del portal.  Es aqu칤 donde usamos la posici칩n anterior para descubrir c칩mo se comporta el punto.  Esta funci칩n es com칰n para que pueda funcionar con cualquier actor, pero en mi caso solo se usa con el jugador. <br><br>  La funci칩n crea una direcci칩n / segmento entre la ubicaci칩n anterior y la actual, y luego verifica si se cruzan con el plano.  Si es as칤, verificamos si se cruza en la direcci칩n correcta (쯗e adelante hacia atr치s?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Teleport Actor </h2><br>  La 칰ltima parte del actor del portal que veremos es la funci칩n <b>TeleportActor ()</b> . <br><br>  Al teletransportar a un actor del punto A al punto B, debe replicar su movimiento y posici칩n.  Por ejemplo, si un jugador pasa al portal, en combinaci칩n con los efectos visuales adecuados, le parecer치 que atraves칩 una puerta ordinaria. <br><br>  La intersecci칩n del portal se siente como moverse en l칤nea recta, pero en realidad sucede algo completamente diferente.  Al salir del portal, el jugador puede encontrarse en un contexto muy diferente.  Considere un ejemplo de Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Como puede ver, al cruzar el portal, la c치mara gira en relaci칩n con su vector hacia adelante (gira).  Esto se debe a que los puntos inicial y final son paralelos a diferentes planos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Por lo tanto, para que esto funcione, necesitamos transformar el movimiento del jugador en el espacio relativo del portal para convertirlo en el espacio Objetivo.  Al implementar esto, podemos estar seguros de que despu칠s de ingresar al portal y salir del otro lado, el jugador estar치 correctamente alineado con respecto al espacio.  Esto se aplica no solo a la posici칩n y rotaci칩n del actor, sino tambi칠n a su <b>velocidad</b> . <br><br><blockquote>  Si teletransportamos a un actor sin cambios, convirti칠ndolo en una rotaci칩n local, entonces, como resultado, el actor puede encontrarse al rev칠s.  Esto puede ser adecuado para objetos, pero no aplicable a los personajes o al jugador mismo.  Debe cambiar la posici칩n del actor, como se muestra arriba en el ejemplo de Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Como probablemente haya notado, para llamar a rotaci칩n / posici칩n, llamo funciones externas.  Se llaman desde la clase de usuario UTool, que define funciones est치ticas que se pueden llamar desde cualquier lugar (incluidos los planos).  Su c칩digo se muestra a continuaci칩n, puede implementarlos de la manera que le parezca mejor (probablemente sea m치s f치cil colocarlos en la clase de actor Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  La transformaci칩n aqu칤 se realiza calculando el producto escalar de vectores para determinar diferentes 치ngulos.  El vector de direcci칩n no est치 normalizado, es decir, podemos multiplicar nuevamente el resultado de los puntos por vectores de destino para obtener la posici칩n exactamente a la misma distancia en el espacio local del actor de destino. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Convertir la transformaci칩n fue un poco m치s dif칤cil de implementar.  Al final, la mejor soluci칩n result칩 ser el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">cuaterniones</a> , porque esto es mucho m치s preciso que trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">치ngulos</a> normales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Euler</a> y requiere solo unas pocas l칤neas de c칩digo.  Las rotaciones por cuaterniones se realizan mediante multiplicaci칩n, por lo que en nuestro caso, aplicando Inverse () a la rotaci칩n que queremos convertir, la trasladaremos al espacio local.  A continuaci칩n, solo tenemos que multiplicarlo nuevamente por el turno Objetivo para obtener el turno final. <br><br><h2>  Crear una malla de portal </h2><br>  Para lucir bella desde el punto de vista de un jugador, mi sistema de portal utiliza una malla espec칤fica.  La malla se divide en dos planos diferentes: <br><br><ul><li>  <b>Plano 1</b> : el plano principal en el que se muestra el objetivo de representaci칩n del portal.  Este avi칩n tiene un comportamiento bastante inusual, porque su tarea es alejarse un poco del jugador cuando se acerca para evitar que la c치mara lo recorte.  Dado que los bordes del avi칩n no se mueven, sino que solo se mueven sus picos medios, esto le permite al jugador superponer al renderizar el portal sin artefactos visuales.  Los bordes en los bordes tienen su propio UV en la mitad superior, mientras que los bordes internos tienen su propio UV en la mitad inferior, lo que facilita enmascararlos en el sombreador. </li><li>  <b>Plano 2</b> : este plano solo se usa para extender el cuadro delimitador est치ndar de la malla.  Las normales de los v칠rtices se dirigen hacia abajo, por lo que incluso en terreno no plano la malla no ser치 visible por defecto (porque el material de renderizado no ser치 de dos lados). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  쯇or qu칠 usar una malla como esta? <br><br>  Decid칤 que el "avi칩n 1" se estirar칤a a medida que el jugador se acercara.  Esto permite que el jugador se superponga al portal y lo atraviese sin recortar (cortar).  Esto puede suceder, por ejemplo, si la c치mara a칰n no ha cruzado el plano del portal, pero los pies del jugador ya la han tocado.  Esto le permite no cortar el reproductor y duplicar la malla por otro lado. <br><br>  La tarea del "plano 2" es extender el cuadro delimitador est치ndar de la malla.  Dado que el "plano 1" es plano, el cuadro delimitador en un eje tiene un grosor de 0, y si la c치mara est치 detr치s, el motor lo cortar치 (es decir, no lo renderizar치).  El avi칩n 1 tiene un tama침o de 128 칑 128, por lo que se puede escalar f치cilmente con el motor.  El plano 2 es ligeramente m치s grande y est치 debajo del piso (debajo de 0). <br><br>  Una vez creada la malla, simplemente la exportamos desde un editor 3D de terceros y la importamos a Unreal.  Se usar치 en el siguiente paso. <br><br><h2>  Crear material del portal </h2><br>  Para mostrar el otro lado del portal, necesitamos crear nuestro propio material.  Cree nuevo material en el navegador de contenido (lo llam칠 <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Ahora 치bralo y cree el siguiente gr치fico: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  As칤 es como funciona el material: <br><br><ul><li>  <b>FadeColor</b> es el color que ser치 visible a trav칠s del portal cuando est칠 muy lejos.  Es necesario porque no siempre renderizamos todos los portales, por lo que oscurecemos el renderizado cuando el reproductor / c치mara est치 muy lejos. </li><li>  Para averiguar qu칠 tan lejos est치 el jugador del portal, determino la <b>distancia</b> entre la posici칩n de la c치mara y la posici칩n del actor.  Luego divido la distancia por el valor m치ximo con el que quiero realizar una comparaci칩n.  Por ejemplo, si el m치ximo que configur칠 es 2000, y la distancia al jugador es 1000, entonces obtenemos 0.5.  Si el jugador est치 m치s lejos, obtendr칠 un valor mayor que 1, as칤 que uso nodos saturados para limitarlo.  Luego viene el nodo Smoothstep, usado para escalar la distancia como un gradiente y controlar con mayor precisi칩n el sombreado del portal.  Por ejemplo, cuando el jugador est치 cerca, quiero que la sombra desaparezca por completo. </li><li>  Utilizo el c치lculo de distancia como el valor del canal alfa para el nodo <b>Lerp</b> para mezclar el color de sombreado y la <b>textura</b> que representar치 el objetivo del portal. </li><li>  Finalmente, a칤slo el componente Y de las coordenadas UV para crear una m치scara que le permita saber qu칠 v칠rtices de la malla ser치n empujados.  Multiplico esta m치scara por la cantidad de repulsi칩n que necesito.  Utilizo un valor negativo para que cuando las normales de los v칠rtices se multipliquen por los v칠rtices, se muevan en la direcci칩n opuesta. </li></ul><br>  Una vez hecho todo esto, creamos material listo para usar. <br><br><h2>  Crear un actor de portal en Blueprint </h2><br>  Configuremos una nueva clase de blueprint heredada del actor Portal.  Haga clic derecho en el navegador de contenido y seleccione la clase Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Ahora ingrese "portal" en el campo de b칰squeda para seleccionar la clase de portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Abra bluetooth si a칰n no est치 abierto.  En la lista de componentes ver치 la siguiente jerarqu칤a: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Como esper치bamos, hay un componente ra칤z y una ra칤z de portal.  Agreguemos un componente de malla est치tica a PortalRootComponent y carguemos la malla creada en el paso anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Tambi칠n agregamos el cuadro de colisi칩n, que se utilizar치 para determinar si el jugador est치 dentro del volumen del portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  El cuadro Colisi칩n se encuentra debajo del componente de escena asociado con la ra칤z principal, y no debajo de la ra칤z del Portal.  Tambi칠n agregu칠 un 칤cono (cartelera) y un componente de flecha para hacer que el portal sea m치s visible en los niveles.  Por supuesto, esto no es necesario. <br><br>  Ahora configuremos el material en plano. <br><br>  Para empezar, necesitamos dos variables: una ser치 del tipo <b>Actor</b> y el nombre es <b>PortalTarget</b> , la segunda es del tipo <b>Dynamic Material Instance</b> y se llama <b>MaterialInstance</b> .  PortalTarget ser치 una referencia a la posici칩n que est치 mirando la ventana del portal (por lo tanto, la variable es com칰n, con un icono de ojo abierto) para que podamos cambiarla cuando el actor se coloca en el nivel.  MaterialInstance almacenar치 un enlace a material din치mico para que en el futuro podamos asignar el objetivo de renderizado del portal sobre la marcha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Tambi칠n necesitamos agregar nuestros propios nodos de eventos.  Es mejor abrir el men칰 derecho del mouse en el <b>Gr치fico de eventos</b> y encontrar los nombres de los eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Y aqu칤 para crear el siguiente diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Comenzar reproducci칩n</b> : aqu칤 llamamos a la funci칩n principal SetTarget () del portal para asignarle un enlace al actor, que luego se usar치 para SceneCapture.  Luego creamos un nuevo material din치mico y le asignamos el valor de la variable MaterialInstance.  Con este nuevo material, podemos asignarlo al componente de malla est치tica.  Tambi칠n le di al material una textura ficticia, pero esto es opcional. </li><li>  <b>Borrar RTT</b> : el prop칩sito de esta funci칩n es borrar la textura de Render Target asignada al material del portal.  Es lanzado por el administrador del portal. </li><li>  <b>Establecer RTT</b> : el prop칩sito de esta funci칩n es establecer el material de destino del portal.  Es lanzado por el administrador del portal. </li></ul><br>  Hasta ahora hemos terminado con bluetooth, pero volveremos m치s tarde para implementar las funciones de Tick. <br><br><h2>  Administrador del portal </h2><br>  Entonces, ahora tenemos todos los elementos b치sicos necesarios para crear una nueva clase heredada de AActor, que ser치 Portal Manager.  Es posible que no necesite la clase Portal Manager en su proyecto, pero en mi caso, simplifica enormemente el trabajo con algunos aspectos.  Aqu칤 hay una lista de tareas realizadas por el administrador del portal: <br><br><ul><li>  El administrador del portal es un actor <b>creado por el controlador del jugador</b> y conectado a 칠l para rastrear el estado y la evoluci칩n del jugador dentro del nivel del juego. </li><li>  Crear y destruir <b>el portal de destino de renderizado</b> .  La idea es crear din치micamente una textura de destino de renderizado que coincida con la resoluci칩n de pantalla del jugador.  Adem치s, al cambiar la resoluci칩n durante el juego, el administrador la convertir치 autom치ticamente al tama침o deseado. </li><li>  El administrador del portal <b>encuentra y actualiza</b> el nivel de actor del portal para darles un objetivo de representaci칩n.  Esta tarea se realiza de manera que se garantice la compatibilidad con el nivel de transmisi칩n.  Cuando aparece un nuevo actor, debe obtener una textura.  Adem치s, si el objetivo Render cambia, el administrador tambi칠n puede asignar uno nuevo autom치ticamente.  Esto facilita la administraci칩n del sistema, en lugar de hacer que cada actor del Portal se comunique manualmente con el administrador. </li><li>  El componente <b>SceneCapture est치</b> conectado al administrador del portal, para no crear una copia para cada portal.  Adem치s, le permite reutilizarlo cada vez que cambiemos a un actor de portal espec칤fico en el nivel. </li><li>  Cuando el portal decide <b>teletransportar al</b> jugador, env칤a una solicitud al Administrador del portal.  Esto es necesario para actualizar los portales de origen y de destino (si los hay), para que la transici칩n ocurra sin uniones. </li><li>  <b>El</b> administrador del portal se <b>actualiza</b> al final de la funci칩n <b>tick ()</b> del <b>personaje</b> para que todo se actualice correctamente, incluida la c치mara del jugador.  Esto asegura que todo en la pantalla est칠 sincronizado y evita un retraso de un cuadro durante el renderizado por el motor. </li></ul><br>  Echemos un vistazo al encabezado de Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Antes de entrar en detalles, mostrar칠 c칩mo se crea un actor a partir de la clase Player Controller, llamada desde la funci칩n BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Entonces, creamos un actor, lo adjuntamos al controlador del jugador (esto), y luego guardamos el enlace y llamamos a la funci칩n Init (). <br><br>  Tambi칠n es importante tener en cuenta que actualizamos el actor manualmente desde la clase Character: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Y aqu칤 est치 el constructor de Portal Manager.  Tenga en cuenta que Tick est치 deshabilitado, nuevamente porque actualizaremos manualmente Portal Manager a trav칠s del reproductor. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Estas son las funciones de get / set Portal Manager (despu칠s de eso pasaremos a cosas m치s interesantes): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Obviamente, lo primero para comenzar es la funci칩n <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo principal de esta funci칩n es crear el componente SceneCapture (es decir, el dispositivo de captura mencionado anteriormente) y configurarlo correctamente. </font><font style="vertical-align: inherit;">Comienza con la creaci칩n de un nuevo objeto y su registro como componente de este actor. </font><font style="vertical-align: inherit;">Luego pasamos a establecer propiedades relacionadas con esta captura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propiedades a mencionar:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : no queremos que la captura se active cuando no la necesitamos. </font><font style="vertical-align: inherit;">Lo gestionaremos manualmente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una propiedad bastante importante para representar la captura del portal correctamente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esto nos permite reemplazar la proyecci칩n de Captura por la nuestra, seg칰n el punto de vista del jugador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este modo es un poco costoso, pero necesario para representar una cantidad suficiente de informaci칩n.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las propiedades restantes est치n relacionadas principalmente con los par치metros de postprocesamiento. </font><font style="vertical-align: inherit;">Son una forma conveniente de controlar la calidad y, por lo tanto, capturar el rendimiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La 칰ltima parte llama a la funci칩n que crea el Destino de renderizado, que veremos a continuaci칩n.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una funci칩n que se llama cuando es necesario cuando necesita crear una nueva textura Render Target para portales. </font><font style="vertical-align: inherit;">Esto sucede en la funci칩n de inicializaci칩n, pero tambi칠n se puede invocar durante la actualizaci칩n de Portal Manager. </font><font style="vertical-align: inherit;">Es por eso que esta funci칩n tiene una verificaci칩n interna para cambiar la resoluci칩n de la ventana gr치fica. </font><font style="vertical-align: inherit;">Si no sucedi칩, entonces la actualizaci칩n no se realiza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En mi caso, cre칠 una clase de contenedor para UCanvasRenderTarget2D. Lo llam칠 ExedreScriptedTexture, es un componente que se puede conectar a un actor. Cre칠 esta clase para administrar convenientemente los objetivos de renderizado con actores que tienen tareas de renderizado. Realiza la inicializaci칩n adecuada del Render Target y es compatible con mi propio sistema de interfaz de usuario. Sin embargo, en el contexto de los portales, una textura RenderTarget2D normal es m치s que suficiente. Por lo tanto, simplemente puede usarlo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se mencion칩 anteriormente, cre칠 mi propia clase, por lo que las propiedades establecidas aqu칤 deben adaptarse al objetivo de renderizado habitual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es importante comprender d칩nde se mostrar치 la captura. </font><font style="vertical-align: inherit;">Dado que el objetivo de renderizado se mostrar치 en el juego, esto significa que esto suceder치 antes de todo el procesamiento posterior y, por lo tanto, necesitamos renderizar la escena con suficiente informaci칩n (para almacenar valores superiores a 1 para crear Bloom). </font><font style="vertical-align: inherit;">Es por eso que eleg칤 el formato RGBA16 (tenga en cuenta que tiene su propia Enum, necesitar치 usar ETextureRenderTargetFormat en su lugar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener m치s informaci칩n, consulte las siguientes fuentes:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem치s consideraremos las funciones de actualizaci칩n. </font><font style="vertical-align: inherit;">La funci칩n b치sica es bastante simple y causa m치s compleja. </font><font style="vertical-align: inherit;">Hay una demora antes de llamar a la funci칩n GeneratePortalTexture () para evitar volver a crear el destino de representaci칩n al cambiar el tama침o de la ventana gr치fica (por ejemplo, en el editor). </font><font style="vertical-align: inherit;">Durante la publicaci칩n del juego, este retraso puede eliminarse.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamamos a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar todos los portales presentes en el mundo actual (incluidos todos los niveles cargados) y actualizarlos. </font><font style="vertical-align: inherit;">La funci칩n tambi칠n determina cu치l est치 "activo", es decir </font><font style="vertical-align: inherit;">visible para el jugador. </font><font style="vertical-align: inherit;">Si encontramos un portal activo, llamamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que controla el componente SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As칤 es como funciona la actualizaci칩n mundial dentro de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificaci칩n que determina la correcci칩n del portal es simple: le damos prioridad al portal m치s cercano al jugador, porque lo m치s probable es que sea el m치s visible desde su punto de vista. </font><font style="vertical-align: inherit;">Para descartar parientes, pero, por ejemplo, portales ubicados detr치s del jugador, se requerir치n controles m치s complejos, pero no quer칤a centrarme en esto en mi tutorial, porque puede ser bastante dif칤cil.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hora de considerar la funci칩n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una funci칩n de actualizaci칩n que captura el otro lado del portal. </font><font style="vertical-align: inherit;">De los comentarios todo debe quedar claro, pero aqu칤 hay una breve descripci칩n:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlaces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a Controlador de personaje y jugador.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si todo es correcto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, componente SceneCapture, Reproductor).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como podemos ver, al teletransportar a un jugador, un elemento clave del comportamiento natural e impecable de SceneCapture es la correcta transformaci칩n de la posici칩n y la rotaci칩n del portal en el espacio Target local. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para la definici칩n de ConvertLocationToActorSpace (), consulte "Teletransportaci칩n de un actor". </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci칩n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no existe por defecto en la clase PlayerController, la agregu칠 yo mismo. </font><font style="vertical-align: inherit;">Se muestra a continuaci칩n:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, necesitamos implementar la llamada a la funci칩n Teleport. </font><font style="vertical-align: inherit;">La raz칩n para el procesamiento parcial de la teletransportaci칩n a trav칠s del administrador del Portal es que es necesario garantizar la actualizaci칩n de los portales necesarios, porque solo el Administrador tiene informaci칩n sobre todos los portales en la escena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tenemos dos portales conectados, entonces, al cambiar de uno a otro, necesitamos actualizar ambos en un Tick. </font><font style="vertical-align: inherit;">De lo contrario, el jugador se teletransportar치 y estar치 al otro lado del portal, pero el Portal de destino no estar치 activo hasta el pr칩ximo cuadro / medida. </font><font style="vertical-align: inherit;">Esto crear치 huecos visuales con el material desplazado de la malla plana que vimos arriba.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bueno, eso es todo, 춰finalmente hemos terminado con Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Termina el plano </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez completado el Administrador del portal, solo necesitamos completar el actor del Portal, despu칠s de lo cual el sistema funcionar치. </font><font style="vertical-align: inherit;">Lo 칰nico que falta aqu칤 son las caracter칤sticas de Tick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As칤 es como funciona: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos actualizando el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que no permanezca en un estado activo.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el portal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est치</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actualmente </font><b><font style="vertical-align: inherit;">inactivo</font></b><font style="vertical-align: inherit;"> , el resto de la medida se descarta.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos la clase de personaje para acceder a la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ubicaci칩n de la c치mara</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera parte verifica si la c치mara est치 en el cuadro de colisi칩n del portal. </font><font style="vertical-align: inherit;">Si es as칤, compensamos la malla del portal con su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda parte es volver a verificar la ubicaci칩n dentro del cuadro de colisi칩n. </font><font style="vertical-align: inherit;">Si se ejecuta, llamamos a una funci칩n que verifica </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si cruzamos el portal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la captura de pantalla de mi gr치fico, puede observar dos puntos interesantes: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Todav칤a no he explicado estas dos funciones. Estas son funciones est치ticas que defin칤 en mi propia clase para que pueda llamarlas desde cualquier lugar. Este es un tipo de clase auxiliar. El c칩digo de estas funciones se muestra a continuaci칩n, usted mismo puede decidir d칩nde insertarlas. Si no los necesita fuera del sistema de portal, puede insertarlos directamente en la clase de actor Portal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio quer칤a usar el sistema de colisi칩n para determinar si el actor del portal dentro del cuadro de colisi칩n est치 en el portal, pero me pareci칩 que no era lo suficientemente confiable. Adem치s, me parece que este m칠todo es m치s r치pido de usar y tiene una ventaja: tiene en cuenta la rotaci칩n del actor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La 칰ltima parte del actor Blueprint es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Recuerda que se llama Force Tick cuando un jugador cruza un portal y est치 al lado de otro portal para el que Portal Manager est치 forzando una actualizaci칩n. </font><font style="vertical-align: inherit;">Como nos teletransportamos, no es necesario usar el mismo c칩digo, y puede usar su versi칩n simplificada:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El proceso comienza aproximadamente al mismo tiempo que la funci칩n Tick, pero solo ejecutamos la primera parte de la secuencia, que actualiza el material. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemos terminado? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si implementamos el sistema de portal de esta forma, lo m치s probable es que encontremos el siguiente problema:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쯈u칠 est치 pasando aqu칤? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este gif, la velocidad de fotogramas del juego se limita a 6 FPS para mostrar el problema con mayor claridad. En un cuadro, el cubo desaparece porque el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema de recorte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine lo considera invisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se debe a que el descubrimiento se realiza en el marco actual y luego se usa en el siguiente. Esto crea un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retraso de un cuadro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto generalmente se puede resolver expandiendo el cuadro delimitador del objeto para que se registre antes de que sea visible. Sin embargo, esto no funcionar치 aqu칤, porque cuando cruzamos el portal, nos teletransportamos de un lugar a otro completamente diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar el sistema de recorte tambi칠n es imposible, especialmente porque a niveles con muchos objetos esto reducir치 el rendimiento. Adem치s, prob칠 muchos equipos del motor Unreal, pero no obtuve resultados positivos: en todos los casos, se mantuvo un retraso de un cuadro. Afortunadamente, despu칠s de un estudio detallado del c칩digo fuente de Unreal Engine, logr칠 encontrar una soluci칩n (el camino fue largo, 춰tom칩 m치s de una semana)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con el componente SceneCapture, puedes decirle a la c치mara del jugador que hicimos un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corte de salto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- la posici칩n de la c치mara salt칩 entre dos cuadros, lo que significa que no podemos confiar en la informaci칩n del cuadro anterior. </font><font style="vertical-align: inherit;">Este comportamiento se puede observar cuando se usa Matinee o Sequencer, por ejemplo, al cambiar de c치mara: el desenfoque de movimiento o el suavizado no pueden depender de la informaci칩n del fotograma anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, debemos considerar dos aspectos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esta clase procesa diversa informaci칩n (por ejemplo, la vista del jugador) y est치 asociada con el PlayerController. </font><font style="vertical-align: inherit;">Aqu칤 es donde podemos influir en el proceso de renderizado de la c치mara del jugador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando un jugador se teletransporta, esta clase comienza a empalmarse gracias al acceso a LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La gran ventaja de esta soluci칩n es que la intervenci칩n en el proceso de renderizado del motor es m칤nima y f치cil de mantener en futuras actualizaciones de Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos creando una nueva clase heredada de LocalPlayer. </font><font style="vertical-align: inherit;">A continuaci칩n se muestra un encabezado que identifica dos componentes principales: redefinir los c치lculos de la vista de escena y una nueva funci칩n para invocar el pegado de la c치mara.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As칤 es como se implementa todo: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplemente inicia Camera Cut con un valor booleano. </font><font style="vertical-align: inherit;">Cuando el motor llama a la funci칩n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , primero ejecutamos la funci칩n original. </font><font style="vertical-align: inherit;">Luego verificamos, tenemos que realizar el pegado. </font><font style="vertical-align: inherit;">Si es as칤, redefinimos la variable booleana Camera Cut dentro de la estructura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que ser치 utilizada por el proceso de renderizado del motor, y luego restablecemos la variable booleana ( </font><b><font style="vertical-align: inherit;">칰sela</font></b><font style="vertical-align: inherit;"> ).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el lado del controlador del jugador, los cambios son m칤nimos. </font><font style="vertical-align: inherit;">Debe agregar una variable al encabezado para almacenar un enlace a la clase nativa LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, en la funci칩n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi칠n agregu칠 una funci칩n para iniciar r치pidamente Cut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, en la funci칩n de Administrador de portal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podemos ejecutar durante la teletransportaci칩n de Camera Cut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">춰Y eso es todo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se debe llamar a Camera Cut antes de actualizar SceneCapture, raz칩n por la cual se encuentra al comienzo de la funci칩n.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultado final </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hemos aprendido a pensar en portales. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el sistema funciona bien, entonces deber칤amos poder crear estas cosas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si tiene problemas, compruebe lo siguiente: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique que Portal Manager se haya creado e inicializado correctamente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El objetivo de representaci칩n se crea correctamente (puede usar el creado en el navegador de contenido para comenzar). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los portales est치n correctamente activados y desactivados. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los portales tienen el actor Target configurado correctamente en el editor. </font></font></li></ul><br><h2>  Preguntas y respuestas </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las preguntas m치s populares que me hicieron sobre este tutorial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쮼s posible implementar esto en blunts y no a trav칠s de C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor parte del c칩digo se puede implementar en romos, con la excepci칩n de dos aspectos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci칩n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData () de LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizada para obtener la matriz de proyecci칩n no est치 disponible en planos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci칩n LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es cr칤tica para resolver el problema del sistema de recorte, no est치 disponible en planos.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, debe usar una implementaci칩n de C ++ para acceder a estas dos funciones o modificar el c칩digo fuente del motor para que sea accesible a trav칠s de planos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쯇uedo usar este sistema en VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S칤, en su mayor parte. </font><font style="vertical-align: inherit;">Sin embargo, algunas partes deber치n adaptarse, por ejemplo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe usar dos objetivos de renderizado (uno para cada ojo) y enmascararlos en el material del portal para mostrar uno al lado del otro en el espacio de la pantalla. </font><font style="vertical-align: inherit;">Cada objetivo de renderizado debe tener la mitad del ancho de la resoluci칩n del dispositivo VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debe usar dos SceneCapture para representar el objetivo con la distancia correcta (la distancia entre los ojos) para crear efectos estereosc칩picos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal problema ser치 el rendimiento, ya que el otro lado del portal deber치 representarse dos veces. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쯇uede otro objeto cruzar el portal?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hay en mi c칩digo. Sin embargo, hacerlo m치s general no es tan dif칤cil. Para hacer esto, el portal necesita rastrear m치s informaci칩n sobre todos los objetos cercanos para verificar si lo cruzan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쮼l sistema admite recursividad (portal dentro del portal)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este tutorial no lo es. Para la recursividad, necesita un destino de renderizado adicional y SceneCapture. Tambi칠n ser치 necesario determinar qu칠 RenderTarget se representar치 primero, y as칤 sucesivamente. Esto es bastante dif칤cil y no quer칤a hacerlo, porque para mi proyecto esto no es necesario. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">쯇uedo cruzar el portal cerca de la pared?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamentablemente no. </font><font style="vertical-align: inherit;">Sin embargo, veo dos formas de implementar esto (te칩ricamente):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactiva las colisiones del jugador para que pueda atravesar las paredes. </font><font style="vertical-align: inherit;">Es f치cil de implementar, pero generar치 muchos efectos secundarios.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hackea un sistema de colisi칩n para crear un agujero de forma din치mica, lo que permitir치 al jugador pasar. </font><font style="vertical-align: inherit;">Para hacer esto, debe modificar el sistema f칤sico del motor. </font><font style="vertical-align: inherit;">Sin embargo, por lo que s칠, despu칠s de cargar el nivel, la f칤sica est치tica no se puede actualizar. </font><font style="vertical-align: inherit;">Por lo tanto, admitir esta funci칩n requerir치 mucho trabajo. </font><font style="vertical-align: inherit;">Si sus portales son est치ticos, entonces probablemente pueda solucionar este problema utilizando la transmisi칩n de nivel para cambiar entre diferentes colisiones.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448802/">https://habr.com/ru/post/448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448792/index.html">Prueba de Python con pytest. Accesorios incorporados, Cap칤tulo 4</a></li>
<li><a href="../448794/index.html">Prueba de Python con pytest. Complementos CAP칈TULO 5</a></li>
<li><a href="../448796/index.html">Prueba de Python con pytest. Configuraci칩n, CAP칈TULO 6</a></li>
<li><a href="../448798/index.html">Prueba de Python con pytest. Usando pytest con otras herramientas, CAP칈TULO 7</a></li>
<li><a href="../448800/index.html">Configure Visual Studio en toda su organizaci칩n con .vsconfig</a></li>
<li><a href="../448804/index.html">Prepar치ndose para el tiempo de ejecuci칩n y el notario endurecidos de macOS</a></li>
<li><a href="../448806/index.html">Crear un sistema de extensi칩n en la biblioteca Qt</a></li>
<li><a href="../448808/index.html">Sobre cosas simples, complicadas. "Acero dormido". C칩mo engrasar pernos oxidados o no WD-40 con un solo ...</a></li>
<li><a href="../448810/index.html">쮺칩mo atrap칠 a un hacker?</a></li>
<li><a href="../448812/index.html">Misi칩n lunar "Bereshit": busca la primera biblioteca lunar despu칠s de que el accidente de su portador haya comenzado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>