<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏏️ 👐🏾 ⏯️ [CppCon 2018] Herb Sutter：迈向更简单，更强大的C ++ 🎁 🤸 🤞🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在2018年CppCon大会上的演讲中，Herb Sutter在两个方向上向公众展示了他的成就。 首先，它是变量生存期的控制 （Lifetime），它允许在编译阶段检测整个bug类。 其次，这是有关元类的更新建议，一旦描述了类类别的行为，然后用一行将其连接到特定类，就可以避免代码重复。 
 前言：更...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[CppCon 2018] Herb Sutter：迈向更简单，更强大的C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425873/"><iframe width="560" height="315" src="https://www.youtube.com/embed/80BZxujhY38" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>在2018年CppCon大会上的演讲中，Herb Sutter在两个方向上向公众展示了他的成就。 首先，它是变量<strong>生存期</strong>的<strong>控制</strong> （Lifetime），它允许在编译阶段检测整个bug类。 其次，这是有关<strong>元类</strong>的更新建议，一旦描述了类类别的行为，然后用一行将其连接到特定类，就可以避免代码重复。 </p><a name="habracut"></a><br><h2 id="predislovie-bolshe--prosche"> 前言：更多=更容易？ </h2><br><p> 听到C ++的指控，该标准正在毫无意义和残酷地增长。 但是，即使是最热心的保守派也不会认为range-for（收集周期）和auto（至少对于迭代器）这样的新构造会使代码更简单。 您可以制定（至少一种，最好是全部）新语言扩展必须满足的近似标准，以简化实践中的代码： </p><br><ol><li> 减少，简化代码，删除重复的代码（范围，自动，lambda，元类） </li><li> 使安全代码更易于编写，防止出现错误和特殊情况（智能指针，生命周期） </li><li> 完全替换旧的，功能较少的功能（typedef→使用） </li></ol><br><p>  Herb Sutter识别“现代C ++”-符合现代编码标准（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++核心准则</a> ）的功能的子集，并将完整标准视为每个人都不需要知道的“兼容模式”。 因此，如果“现代C ++”没有增长，那么一切都很好。 </p><br><h2 id="proverki-vremeni-zhizni-peremennyh-lifetime"> 检查变量的生命周期（生命周期） </h2><br><p> 现在，新的终身验证组可作为Clang和Visual C ++的核心准则检查器的一部分。 目标不是要像Rust中那样达到绝对的严格性和准确性，而是要在各个功能内执行简单而快速的检查。 </p><br><h3 id="osnovnye-principy-proverki"> 验证的基本原则 </h3><br><p> 从生命周期分析的角度来看，类型分为三类： </p><br><ul><li> 该值是指针可以指向的值。 </li><li>指针-指值，但不控制其寿命。 可能会挂（悬空的指针）。 示例： <code>T*</code> ， <code>T&amp;</code> ，迭代器， <code>std::observer_ptr&lt;T&gt;</code> ， <code>std::string_view</code> ， <code>gsl::span&lt;T&gt;</code> </li><li> 所有者-控制价值的有效期。 通常可以提前删除其值。 例如： <code>std::unique_ptr&lt;T&gt;</code> ， <code>std::shared_ptr&lt;T&gt;</code> ， <code>std::vector&lt;T&gt;</code> ， <code>std::string</code> ， <code>gsl::owner&lt;T*&gt;</code> </li></ul><br><p> 指针可以处于以下状态之一： </p><br><ul><li> 指向存储在堆栈中的值 </li><li> 指向某个所有者“内部”包含的值 </li><li> 为空（空） </li><li> 挂起（无效） </li></ul><br><h3 id="ukazateli-i-znacheniya"> 指标与价值 </h3><br><p> 对于每个指针 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> p </script> 被追踪 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">t</span><span class="MJXp-mrow" id="MJXp-Span-8"><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">p</span><span class="MJXp-mrow" id="MJXp-Span-11"><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.297ex" height="2.419ex" viewBox="-38.5 -780.1 4003 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-74" x="1439" y="0"></use><g transform="translate(1801,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="2630" y="0"></use><g transform="translate(3134,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg></span><script type="math/tex" id="MathJax-Element-2"> pset（p）</script>  -它可能指示的一组值。 删除值时，它在所有值中都出现 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.272ex" height="2.298ex" viewBox="-38.5 -728.2 1839.5 989.6" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-74" x="1439" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> pset </script> 替换为 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mrow" id="MJXp-Span-19"><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.278em; margin-right: 0.278em;">无</span></span><span class="MJXp-mrow" id="MJXp-Span-21"><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.278em; margin-right: 0.278em;">效</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.855ex" height="2.298ex" viewBox="0 -780.1 1660 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">无</text><g transform="translate(829,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">效</text></g></g></svg></span><script type="math/tex" id="MathJax-Element-4">无效</script>  。 访问指针值时 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> p </script> 这样 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-25"><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.278em; margin-right: 0.278em;">无</span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.278em; margin-right: 0.278em;">效</span></span><span class="MJXp-mo" id="MJXp-Span-30" style="margin-left: 0.333em; margin-right: 0.333em;">∈</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">t</span><span class="MJXp-mrow" id="MJXp-Span-35"><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">p</span><span class="MJXp-mrow" id="MJXp-Span-38"><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.904ex" height="2.419ex" viewBox="0 -780.1 6847.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">无</text><g transform="translate(829,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">效</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMAIN-2208" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="2883" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-73" x="3386" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-65" x="3856" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-74" x="4322" y="0"></use><g transform="translate(4684,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="5514" y="0"></use><g transform="translate(6017,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg></span><script type="math/tex" id="MathJax-Element-6">无效∈pset（p）</script> 发出错误。 </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} { char a[100]; s = a; // pset(s) = {a} cout &lt;&lt; s[0]; // OK } // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR: invalid ∈ pset(s)</span></span></code> </pre> <br><p> 使用注释，可以配置将哪些操作视为访问值的操作。 默认情况下： <code>*</code> ， <code>-&gt;</code> ， <code>[]</code> ， <code>begin()</code> ， <code>end()</code> 。 </p><br><p> 请注意，警告仅在<em>访问</em>无效索引时发出。 如果“值”被删除，但没有人访问过该指针，则一切正常。 </p><br><h3 id="ukazateli-i-vladelcy"> 路标和所有者 </h3><br><p> 如果指针 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> p </script> 指示所有者中包含的值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">o</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.455ex" viewBox="0 -520.7 485.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhg3lNPDGnz-P0KPEvW5JLcCDOIg3w#MJMATHI-6F" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> o </script> 然后这个 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">t</span><span class="MJXp-mrow" id="MJXp-Span-49"><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">p</span><span class="MJXp-mrow" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-55"><span class="MJXp-msup" id="MJXp-Span-56"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57" style="margin-right: 0.05em;">o</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-58" style="vertical-align: 0.5em;">′</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> pset（p）= {o'} </script>  。 </p><br><p> 拥有者的方法和功能分为： </p><br><ul><li> 所有者价值访问操作。 默认值： <code>*</code> ， <code>-&gt;</code> ， <code>[]</code> ， <code>begin()</code> ， <code>end()</code> </li><li> 对所有者本身的访问操作， <code>v.clear()</code>指针，如<code>v.clear()</code> 。 默认情况下，这些是所有其他非常量操作 </li><li> 对所有者本身（非无效指针<code>v.empty()</code>访问操作，例如<code>v.empty()</code> 。 默认情况下，这些都是const操作。 </li></ul><br><p> 旧内容所有者宣布 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-mrow" id="MJXp-Span-60"><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.278em; margin-right: 0.278em;">无</span></span><span class="MJXp-mrow" id="MJXp-Span-62"><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.278em; margin-right: 0.278em;">效</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10">无效</script> 移走所有者或应用无效操作后。 </p><br><p> 这些规则足以检测C ++代码中的许多典型错误： </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} string name = "foo"; s = name; // pset(s) = {name'} cout &lt;&lt; s[0]; // OK name = "bar"; // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;v[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// pset(p) = {v'} v.push_back(42); // pset(p) = {invalid} cout &lt;&lt; *p; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view s = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>s; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// ERROR // :       std::string_view s = "foo"s // pset(s) = {"foo"s '} ; // pset(s) = {invalid}</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { <span class="hljs-comment"><span class="hljs-comment">// pset(i) = {v'} if (*i == 2) { v.erase(i); // pset(i) = {invalid} } // pset(i) = {v', invalid} } // ERROR: ++i for (auto i = v.begin(); i != v.end(); ) { if (*i == 2) i = v.erase(i); // OK else ++i; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; get_data(); <span class="hljs-comment"><span class="hljs-comment">//   ,  get_data() != nullopt for (int value : *get_data()) // ERROR cout &lt;&lt; value; // *get_data() —     for (int value : std::vector&lt;int&gt;(*get_data())) // OK cout &lt;&lt; value;</span></span></code> </pre> <br><h3 id="otslezhivanie-vremeni-zhizni-parametrov-funkciy"> 跟踪功能参数的寿命 </h3><br><p> 当我们开始使用C ++中的返回指针的函数时，我们只能猜测参数的生存期与返回值之间的关系。 如果一个函数接受并返回相同类型的Pointer，则假定该函数从输入参数之一“获取”返回值： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* q)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">*</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {p', q'} auto g(std::string&amp; s) -&gt; char*; // pset(ret) = {s'}</span></span></code> </pre> <br><p> 很容易检测到可疑函数，这些函数从无处获得结果： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::reference_wrapper&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_data() { <span class="hljs-comment"><span class="hljs-comment">//    int i = 3; return {i}; // pset(ret) = {i'} } // pset(ret) = {invalid}</span></span></code> </pre> <br><p> 由于可以将临时值传递给<code>const T&amp;</code>参数，因此不会考虑它们，除非结果无处可取： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; y)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {x', y'} //    const T&amp;- //        auto x = 10, y = 2; auto&amp; bad = min(x, y + 1); // pset(bad) = {x, temp} // pset(bad) = {x, invalid} cout &lt;&lt; bad; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> K = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> V = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> V&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_or_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;K, V&gt;&amp; m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> V&amp; def)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {m', key', def'} std::map&lt;K, V&gt; map; K key = "foo"; const V&amp; s = find_or_default(map, key, "none"); // pset(s) = {map', key', temp} ⇒ pset(s) = {map', key', invalid} cout &lt;&lt; s; // ERROR</span></span></code> </pre> <br><p> 还可以相信，如果一个函数接受一个指针（而不是引用），则它可以是nullptr，并且在与nullptr比较之前不能使用该指针。 </p><br><h3 id="zaklyuchenie-po-kontrolyu-vremeni-zhizni"> 寿命控制结论 </h3><br><p> 我再说一遍，Lifetime并不是针对C ++标准的建议，而是大胆尝试在C ++中实现生命周期检查，例如，与Rust不同，那里从来没有相应的注释。 最初，会有很多误报，但随着时间的流逝，启发式方法将不断完善。 </p><br><h3 id="voprosy-iz-zala"> 听众的提问 </h3><br><p>  <strong>生命周期组检查是否提供数学上准确的保证，确保没有悬空的指针？</strong> </p><br><p> 从理论上讲，有可能（在新代码中）在类和函数上悬挂一堆注释，作为回报，编译器将提供此类保证。 但是这些检查是遵循80:20原则开发的，也就是说，您可以使用少量规则并应用最少的注释来捕获大多数错误。 </p><br><h2 id="metaklassy"> 元类 </h2><br><p> 元类以某种方式补充了应用它的类的代码，并且还充当满足某些条件的一组类的名称。 例如，如下所示， <code>interface</code>元类将使所有功能公开，并且对您而言完全是虚拟的。 </p><br><p> 去年，Herb Sutter进行了他的第一个元类项目（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅此处</a> ）。 从那时起，当前建议的语法已更改。 </p><br><p> 首先，使用元类的语法已更改： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  interface Shape { int area() const; void scale_by(double factor); }; //  class(interface) Shape { … }</span></span></code> </pre> <br><p> 它已经变长了，但是现在有一种自然的语法可以一次应用几个元类： <code>class(meta1, meta2)</code> 。 </p><br><h3 id="opisanie-metaklassa"> 元类描述 </h3><br><p> 以前，元类是用于修改类的一组规则。 现在，元类是一个constexpr函数，它接受一个旧类（在代码中声明）并创建一个新类。 </p><br><p> 即，该函数采用一个参数-有关旧类的元信息（参数的类型取决于实现），创建类元素（片段），然后使用<code>__generate</code>指令将其添加到新类的主体中。 </p><br><p> 可以使用<code>__fragment</code> ， <code>__inject</code>和<code>idexpr(…)</code>构造生成片段。 发言者希望不要专注于他们的目的，因为在将其提交给标准化委员会之前，这部分仍会更改。 名称本身保证会被更改，专门添加了双下划线以澄清这一点。 报告中的重点是更进一步的例子。 </p><br><h3 id="interface"> 介面 </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// source    //     .     //  ~X,  X —   . __generate __fragment struct X { virtual ~X noexcept {} }; //    static_assert, compiler.require   //   constexpr-. //      . compiler.require(source.variables().empty(), "interfaces may not contain data members"); // member_functions(), ,  tuple&lt;…&gt;,   for... for... (auto f : source.member_functions()) { // ,   —   / compiler.require(!f.is_copy() &amp;&amp; !f.is_move(), "interfaces may not copy or move; consider a virtual clone()"); //   public   if (!f.has_default_access()) f.make_public(); // (1) // ,       protected/private compiler.require(f.is_public(), "interface functions must be public"); //     f.make_pure_virtual(); // (2) //   f     __generate f; } }</span></span></code> </pre> <br><p> 您可能会认为在第（1）和（2）行中，我们修改了原始类，但没有。 请注意，我们通过复制来遍历原始类的功能，修改这些功能，然后将其插入新类中。 </p><br><p> 元类应用程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_by</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor)</span></span></span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//  : class Shape { public: virtual ~Shape noexcept {} public: virtual int area() const = 0; public: virtual void scale_by(double factor) = 0; };</span></span></code> </pre> <br><h3 id="otladka-myuteksa"> 互斥调试 </h3><br><p> 假设我们有一个互斥锁保护的非线程安全数据。 如果在调试程序集中的每个调用中检查当前进程是否已锁定此互斥锁，则可以促进调试。 为此，编写了一个简单的TestableMutex类： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestableMutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m.lock(); id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id{}; m.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_held</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id&gt; id; };</code> </pre> <br><p> 此外，在MyData类中，我们希望每个公共领域都喜欢 </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v;</code> </pre> <br><p> 替换为+ getter： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; v() { assert(m_.is_held()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v_; }</code> </pre> <br><p> 对于功能，也可以执行类似的转换。 </p><br><p> 使用宏和代码生成可解决此类任务。 赫伯·萨特（Herb Sutter）向宏宣战：它们是不安全的，会忽略语义，名称空间等。 解决方案在元类上看起来像什么： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">guarded_with_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __generate __fragment <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> {</span></span> TestableMutex m_; <span class="hljs-comment"><span class="hljs-comment">// lock, unlock } } template &lt;typename T, typename U&gt; constexpr void guarded_member(T type, U name) { auto field = …; __generate field; auto getter = …; __generate getter; } template &lt;typename T&gt; constexpr void guarded(T source) { guarded_with_mutex(); for... (auto o : source.member_variables()) { guarded_member(o.type(), o.name()); } }</span></span></code> </pre> <br><p> 使用方法： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">guarded</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; Widget* w; }; MyData&amp; x = findData(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); xv().clear(); <span class="hljs-comment"><span class="hljs-comment">// assertion failed: m_.is_held()</span></span></code> </pre> <br><h3 id="actor"> 演员 </h3><br><p> 好吧，即使我们用互斥锁保护了某个对象，但现在所有内容都是线程安全的，也没有要求正确性。 但是，如果一个对象经常可以被多个并行线程访问，则互斥对象将过载，并且占用大量开销。 </p><br><p> 解决多虫互斥问题的根本解决方案是参与者的概念，当一个对象有一个请求队列时，对该对象的所有调用都将排入队列，并在一个特殊线程中一个接一个地执行。 </p><br><p> 让Active类包含所有这些的实现-实际上，是具有单个线程的线程池/执行程序。 好吧，元类将帮助摆脱重复的代码并使所有操作排队： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageFilter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ImageFilter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; w) : work(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(w)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer* b)</span></span></span><span class="hljs-function"> </span></span>{ work(b); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; work; } <span class="hljs-comment"><span class="hljs-comment">//  : class ImageFilter { public: ImageFilter(std::function&lt;void(Buffer*)&gt; w) : work(std::move(w)) {} void apply(Buffer* b) { a.send([=] { work(b); }).join(); } private: std::function&lt;void(Buffer*)&gt; work; Active a; //   ,     work }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fstream f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(…)</span></span></span><span class="hljs-function"> </span></span>{ f &lt;&lt; …; } };</code> </pre> <br><h3 id="property"> 财产 </h3><br><p> 几乎所有现代编程语言都具有属性，而没有根据C ++实现它们的人：Qt，C ++ / CLI，各种丑陋的宏。 但是，它们永远不会被添加到C ++标准中，因为它们本身被认为过于狭窄，并且始终希望有一些提案可以将它们作为一种特殊情况来实现。 好了，它们可以在元类上实现！ </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  class X { public: class(property&lt;int&gt;) WidthClass { } width; }; //  class X { public: class WidthClass { int value; int get() const; void set(const int&amp; v); void set(int&amp;&amp; v); public: WidthClass(); WidthClass(const int&amp; v); WidthClass&amp; operator=(const int&amp; v); operator int() const; //   move! WidthClass(int&amp;&amp; v); WidthClass&amp; operator=(int&amp;&amp; v); } width; };</span></span></code> </pre> <br><p> 您可以设置自己的getter和setter： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">&lt;int&gt;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonthClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> month; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> month; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m)</span></span></span><span class="hljs-function"> </span></span>{ assert(m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; m &lt; <span class="hljs-number"><span class="hljs-number">13</span></span>); month = m; } } month; }; Date date; date.month = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-comment"><span class="hljs-comment">// assertion failed</span></span></code> </pre> <br><p> 理想情况下，我想将<code>property int month { … }</code>写为<code>property int month { … }</code> ，但是即使这样的实现也将取代发明属性的C ++扩展的动物园。 </p><br><h3 id="zaklyuchenie-po-metaklassam"> 元类结论 </h3><br><p> 对于已经很复杂的语言，元类是一个很大的新功能。 值得吗？ 这里有一些好处： </p><br><ul><li> 让程序员更清楚地表达自己的意图（我想写演员） </li><li> 减少代码重复并简化遵循某些模式的代码的开发和维护 </li><li> 消除一些常见的错误（一次足以解决所有细微差别） </li><li> 允许摆脱宏吗？  （草药萨特非常好战） </li></ul><br><h3 id="voprosy-iz-zala-1"> 听众的提问 </h3><br><p>  <strong>如何调试元类？</strong> </p><br><p> 至少对于Clang，有一个内在函数，如果被调用，它将在编译时打印类的实际内容，即在应用所有元类后获得的内容。 </p><br><p>  <strong>据说它能够在元类中声明非成员，如swap和hash。</strong>  <strong>她去哪了</strong> </p><br><p> 语法将进一步发展。 </p><br><p>  <strong>如果已经为标准化采用了概念，为什么我们需要元类？</strong> </p><br><p> 这些是不同的东西。 需要使用元类来定义类的各个部分，并且概念会使用类示例检查类是否符合特定模式。 实际上，元类和概念可以很好地协同工作。 例如，您可以定义迭代器的概念和“典型迭代器”的元类，该“典型迭代器”定义其余的一些冗余操作。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425873/">https://habr.com/ru/post/zh-CN425873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425859/index.html">区域运营商反对取消漫游</a></li>
<li><a href="../zh-CN425861/index.html">测试一下自己：您可以保护公司免受网络攻击吗？</a></li>
<li><a href="../zh-CN425867/index.html">Web服务性能测试，作为持续集成的一部分。 Yandex经验</a></li>
<li><a href="../zh-CN425869/index.html">iFixit：苹果尚未激活阻止翻新的MacBook的功能</a></li>
<li><a href="../zh-CN425871/index.html">叶卡捷琳堡，10月11日-Atlassian遇到docker</a></li>
<li><a href="../zh-CN425875/index.html">笔记本电脑矩阵升级TN-> IPS或如何从廉价笔记本电脑中获得更高级的笔记本电脑</a></li>
<li><a href="../zh-CN425877/index.html">苹果首席执行官表示，超微服务器中的中国间谍芯片是虚构的</a></li>
<li><a href="../zh-CN425879/index.html">Google在演讲中显示的内容</a></li>
<li><a href="../zh-CN425881/index.html">您需要了解的有关Flexbox中对齐的所有信息</a></li>
<li><a href="../zh-CN425883/index.html">全职</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>