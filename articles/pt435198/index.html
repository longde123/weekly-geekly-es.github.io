<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèø ‚õ≤Ô∏è üò® Arduin e LED, ou como atualizar o designer infantil ‚úÖ üóíÔ∏è üßóüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meu filho firmemente "fisgou" o construtor magn√©tico Magformers . Depois de examinar uma s√©rie de Fixiks em que o mesmo construtor foi apresentado, a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin e LED, ou como atualizar o designer infantil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Meu filho firmemente "fisgou" o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor magn√©tico Magformers</a> .  Depois de examinar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de Fixiks em que o mesmo construtor foi apresentado, a</a> crian√ßa perguntou: "Pai, por que os fixics t√™m detalhes que brilham, mas n√£o temos?". <br><br>  Descobriu-se que realmente existe um "Magformers Neon LED Set", onde, al√©m dos componentes comuns, tamb√©m h√° um elemento com um LED.  Como nessa √©poca j√° t√≠nhamos reunido uma caixa inteira de √≠m√£s de todas as formas e tamanhos poss√≠veis (quanto a mim, os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">formadores de magias chineses</a> n√£o s√£o nada inferiores ao original), de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguma forma</a> eu n√£o queria comprar outro conjunto apenas por uma l√¢mpada.  Al√©m disso, este conjunto custa significativamente mais do que um similar sem luz de fundo. <br><br>  Tendo calculado que h√° apenas alguns d√≥lares nos componentes, a maioria dos quais eu j√° tinha, decidi coletar minha morgulka.  Sim, e com efeitos que o original n√£o teve. <br><br>  Sob o gato, voc√™ encontrar√° a op√ß√£o de um pisca-pisca no ATTiny85 e o painel de LED nos LEDs WS8212.  Vou falar sobre circuitos, como eu alimentei tudo isso com a bateria, bem como com os problemas n√£o √≥bvios que resolvi ao longo do caminho.  Tamb√©m falarei em detalhes sobre o componente de software do projeto. <br><a name="habracut"></a><br><h2>  Primeiros passos </h2><br>  Pareceu-me que o brilho de um LED comum (mesmo RGB) √© chato e banal.  Mas sentir algo como WS8212 parecia interessante.  No ebee, foram oferecidos LEDs e matrizes individuais de at√© 16x16 em tamanho.  Tendo comprado v√°rios m√≥dulos diferentes, decidi por uma matriz 4x4.  Existem muitos LEDs para permitir v√°rios efeitos visuais, enquanto o m√≥dulo √© compar√°vel em tamanho √† janela do bloco quadrado do designer. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Para controlar a matriz de LEDs, basta apenas um pino do microcontrolador, de modo que at√© o arduino nano parece um busto (al√©m disso, ele n√£o se encaixa no gabinete).  Mas o clone do digispark no controlador ATTiny85 acabou sendo perfeito - ele n√£o possui muita mem√≥ria e pinos, mas √© suficiente para o pisca-pisca de LED.  O m√≥dulo se integra perfeitamente ao IDE do Arduino e possui um carregador de inicializa√ß√£o USB a bordo, portanto, a programa√ß√£o deste m√≥dulo √© muito simples e confort√°vel.  H√° muito tempo que queria experimentar. <br><br>  Come√ßou com o esquema mais simples. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  Nesta forma, foi poss√≠vel depurar rapidamente todos os algoritmos de brilho / piscada (sobre eles abaixo).  Mas um brinquedo movido a fio n√£o √© o caso - voc√™ precisa pensar na energia da bateria.  Al√©m disso, para n√£o falir com as baterias digitais (que, al√©m disso, n√£o cabem no envelope), foi decidido o uso de l√≠tio.  E como h√° uma bateria de l√≠tio, voc√™ precisa pensar em como carreg√°-la.  Nas caixas, acabamos de encontrar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controlador de carregamento "popular" no chip TP4056 que</a> foi comprado na ocasi√£o. <br><br>  Mas n√£o funcionou imediatamente.  O circuito do m√≥dulo Digispark ATTiny85 n√£o √© muito projetado para isso - existe energia USB, mas a energia √© fornecida diretamente ao microcontrolador (atrav√©s do barramento +5) ou da entrada VIN, mas a energia passa pelo estabilizador linear 7805. Op√ß√£o quando o m√≥dulo de carregamento de l√≠tio inserido no espa√ßo entre o conector USB e o microcontrolador n√£o √© fornecido.  Eu tive que modificar um pouco o circuito e remover os detalhes extras. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Portanto, agora a energia USB √© fornecida ao pino VIN e depois √© direcionada √† entrada do carregador.  A sa√≠da do carregador (na verdade, a bateria est√° conectada diretamente) volta para a placa atrav√©s do p√© de 5V.  E, embora de fato haja de 3 a 4,2V (tens√£o da bateria), isso √© bastante normal - a faixa de tens√£o operacional do microcontrolador √© de 1,8-5,5V.  E at√© o m√≥dulo LED funciona normalmente de 2,7V, embora abaixo de 3,2V o LED azul esteja um pouco ausente e as cores ‚Äúflutuem‚Äù um pouco em amarelo. <br><br>  Para economizar energia, o LED D2 sempre ativo tamb√©m desapareceu.  O esquema geral agora se parece com isso <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Seria poss√≠vel alimentar o circuito atrav√©s do conector USB no carregador, mas a capacidade de fazer o upload do firmware atrav√©s do conector USB na placa controladora seria perdida.  Seria poss√≠vel deixar dois conectores USB para v√°rios fins - um para carregar e outro para firmware, mas isso est√° de alguma forma errado. <br><br>  Comprei uma bateria de tamanho 6x25x35 no ebay, mas ela estava com defeito ou a matei com um curto-circuito ou uma grande corrente de carga (por padr√£o, a corrente de carga √© definida como 1A e voc√™ precisa soldar um resistor para reduzir a corrente).  De qualquer forma, quando a carga foi conectada, mesmo a 10 mA, a voltagem da bateria caiu para 1V.  No momento do teste, troquei para uma bateria LiPo meio morta de um pequeno quadroc√≥ptero.  Um pouco mais tarde, pedi a bateria de outro vendedor e ela ficou boa. <br><br>  Em princ√≠pio, seria poss√≠vel parar com isso, soldar os fios de conex√£o e empurrar tudo suavemente para algum tipo de alojamento, mas decidi medir o consumo do circuito.  E ent√£o eu chorei.  Bem, em condi√ß√µes de trabalho (quando as l√¢mpadas brilham completamente), essa coisa consome at√© 130mA; portanto, em repouso, o consumo √© superior a 25mA!  I.e.  esse pisca-pisca consome minha bateria de 600mAh em menos de um dia! <br><br>  Verificou-se que cerca de 10 mA consomem LEDs.  Mesmo se eles n√£o acenderem, um microcontrolador ainda funciona em cada um deles e aguarda um comando.  I.e.  Voc√™ precisa criar um circuito de desligamento para os LEDs. <br><br>  Os 15 mA restantes s√£o consumidos pelo microcontrolador.  Sim, pode ser colocado na cama e, de acordo com a ficha t√©cnica, o consumo ser√° medido por microamperes, mas, na verdade, n√£o foi poss√≠vel obter menos de 1 mA.  Desliguei o ADC e traduzi os pinos em entrada.  Parece que em algum lugar do circuito h√° algum tipo de vazamento, mas meu conhecimento modesto de eletr√¥nica n√£o √© suficiente para encontr√°-lo e compreend√™-lo. <br><br><h2>  N√≥s complicamos o esquema </h2><br>  Lembrei-me de que comprei um chip PT1502 para um teste.  Este chip √© um controlador de carga de bateria de l√≠tio completo com uma fonte de alimenta√ß√£o com v√°rias entradas de controle.  A √∫nica dificuldade √© que o microcircuito √© fornecido em uma embalagem QFN20 de 4x4 mm e requer algumas correias.  Soldar isso em casa √© dif√≠cil, mas poss√≠vel.  A taxa √© dif√≠cil para um LUT regular e deve ser solicitada aos chineses.  Mas n√£o temos medo de dificuldades, certo? <br><br>  Em v√°rias caixas, o esquema pode ser descrito da seguinte maneira. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  No estado desligado, a energia n√£o √© fornecida ao controlador e aos LEDs.  O dispositivo possui um bot√£o 'Power' que liga o pisca-pisca (ele tamb√©m alterna os modos).  O LED brilha, digamos, um minuto e, se n√£o houver atividade do usu√°rio (ningu√©m pressiona um bot√£o), o dispositivo desliga.  I.e.  Ele n√£o apenas dorme, mas desliga a energia pelo sinal Power Hold.  E desliga tudo de uma vez - tanto o microcontrolador quanto os LEDs.  A funcionalidade de ligar e desligar √© implementada dentro do chip PT1502 <br><br>  Tudo o que resta √© desenhar um diagrama de circuito e fazer uma placa de circuito.  O circuito √©, na maioria das vezes, associado √† folha de dados do PT1502 e ao m√≥dulo Digispark ATTiny85.  O microcircuito do controlador de pot√™ncia PT1502 √© funcionalmente dividido em v√°rias partes, portanto, √© dividido em blocos no circuito. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Na verdade, este √© um controlador de carga de bateria de l√≠tio com seu pr√≥prio chicote.  LED1 indica o estado da carga, a carga est√° ligada.  O resistor R6 define a corrente de carga para 470mA.  Desde que eu tenho uma bateria de 600mAh, em princ√≠pio, voc√™ pode aumentar a corrente e colocar um resistor em 780-800 Ohms at√© 600mA.  No entanto, n√£o tenho certeza da qualidade especial da minha bateria - √© melhor carregar mais devagar, mas ela durar√° mais. <br><br>  Considere um plano de energia <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  O bot√£o SW1 inicia todo o sistema - o chip PT1502 acorda sozinho e, em seguida, inicia todas as fontes de energia (das quais possui 3).  Quando a energia √© instalada, o microcircuito inicia o microcontrolador liberando o sinal RESET.  Para facilitar a depura√ß√£o, tamb√©m adicionei um bot√£o Redefinir separado. <br><br>  O sinal HOLD √© usado para desligar todo o sistema.  Quando o microcontrolador √© iniciado, ele deve definir a unidade nesta linha.  Quando √© hora de terminar, o microcontrolador define zero na linha HOLD e o chip de pot√™ncia PT1502 interrompe todas as fontes de energia. <br><br>  Ainda seria poss√≠vel rastrear a carga da bateria fraca usando a sa√≠da BAT_LOW, mas neste artigo eu a classifiquei - voc√™ n√£o precisa salvar nenhum dado e nada explodir√° se voc√™ n√£o perceber uma bateria descarregada a tempo.  Morre assim morre.  Mas por precau√ß√£o, o conselho forneceu contato para esse neg√≥cio. <br><br>  Vamos voltar ao bot√£o SW1 por um segundo.  Decidi n√£o fazer 2 bot√µes separados para ligar e controlar.  Portanto, o mesmo bot√£o tamb√©m √© conectado ao ATTiny85 e, durante a opera√ß√£o, alterna os modos de piscar.  Os valores do divisor R7-R8 s√£o selecionados para n√£o queimar a porta do microcontrolador PB2.  Para todas as faixas de tens√£o da bateria (3,3 - 4,2V), a tens√£o ser√° fornecida ao p√© do controlador dentro dos limites especificados da folha de dados (0,7 * VCC - VCC + 0,5V) <br><br>  Considere uma fonte de energia <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Este √© um conversor DC-DC pulsado.  A tens√£o de sa√≠da √© definida pelos resistores R10-R11 e, de acordo com a f√≥rmula da folha de dados, √© definida como 3,3V.  Tudo o resto √© simples. <br><br>  Para o bem, uma fonte de energia t√£o complicada n√£o √© realmente necess√°ria - seria poss√≠vel alimentar o microcontrolador em geral diretamente da bateria.  S√≥ que essa fonte j√° est√° implementada no chip PT1502 e pode ser ligada / desligada quando necess√°rio - por que n√£o us√°-la? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  O chip tamb√©m possui 2 estabilizadores lineares, mas n√£o os utilizarei.  Infelizmente, como se viu, ainda √© necess√°rio fornecer a tens√£o de entrada para essa fonte; caso contr√°rio, o microcircuito acha que a energia ainda n√£o √© est√°vel o suficiente e n√£o inicia o microcontrolador (esse conhecimento me foi dado por uma semana soldando a placa de teste) - eu n√£o conseguia entender por que ela n√£o funciona. ) <br><br>  Vamos para a parte l√≥gica. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  O cabo USB √© dobrado da placa Digispark inalterado.  Isso √© necess√°rio para coordenar a tens√£o do USB (que executa 3,3V) e os sinais do microcontrolador (que no original √© alimentado por 5V).  Como no meu caso o microcontrolador tamb√©m √© alimentado por 3,3V, o circuito pode ser simplificado, mas, por precau√ß√£o, eu me divorciei do circuito original na placa. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  N√£o h√° nada de interessante na liga√ß√£o do microcontrolador. <br><br>  O toque final √© o conector <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  Na verdade, eu adquiri uma placa de depura√ß√£o para mim no ATTiny85 com suporte a USB e um controlador de energia com uma bateria de l√≠tio.  Portanto, n√£o me limitei apenas a emitir a linha para o LED.  Em vez disso, trouxe todas as linhas do microcontrolador para o pente - ao mesmo tempo, √© conveniente conectar-se ao programador. <br><br>  E deixe quase todas as linhas atadas rigidamente a uma certa funcionalidade (PB1 - Linha de espera, PB2 - bot√£o liga / desliga, PB3 / PB4 - USB, PB5 - Reset) no futuro, ser√° poss√≠vel ignorar alguns limites.  Por exemplo, n√£o solde o cabo USB e solte as linhas PB3 / PB4.  Ou, por exemplo, recusar uma redefini√ß√£o e liberar PB5.  Enquanto isso, apenas o PB0 permanece livre - e conecte nosso LED a ele. <br><br>  Passamos para o quadro.  Dadas as limita√ß√µes no tamanho da placa em 40x40mm, o n√∫mero de componentes e a caixa QFN20 do chip PT1502, eu nem sequer considerei a fabrica√ß√£o da placa em casa.  Portanto, comecei imediatamente a criar a placa de duas camadas mais compacta.  Foi o que eu consegui <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Para facilitar o uso, no verso, assinei todas as fun√ß√µes de sa√≠da poss√≠veis (recebi a id√©ia do quadro do Digispark) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  Eu pedi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conselho</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JLCPCB</a> .  Para ser sincero, n√£o estou muito satisfeito com a qualidade - se voc√™ solda o chip muitas vezes, a m√°scara perto dos pequenos contatos do PT1502 fica um pouco nublada.  Bem, pequenas inscri√ß√µes flutuaram um pouco.  No entanto, se tudo for soldado pela primeira vez, ent√£o as normas. <br><br>  Para soldar QFN20, voc√™ precisa de um ferro de soldar, tudo o mais pode ser soldado com um certo ferro de solda com uma certa habilidade.  √â assim que a placa soldada se parece <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Habita√ß√£o </h2><br>  √â hora de seguir para o casco.  Imprimi-o em uma impressora 3D.  Design sem frescuras - caixa e bot√£o.  Ganchos especiais s√£o fornecidos na caixa para instalar o vaga-lume no m√≥dulo quadrado padr√£o do designer. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  A placa principal e a bateria ficam no gabinete. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  O painel de LEDs √© montado na tampa, que por sua vez √© parafusada na caixa principal com parafusos <br><br>  No come√ßo, pensei em parafusar o painel de LED na tampa com parafusos, mas no final apenas o colei em uma fita dupla face.  Acabou assim <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  Nesta forma, o dispositivo j√° pode ser usado, mas ainda parece feio - n√£o h√° difusor suficiente. <br><br>  Tentei fazer a primeira vers√£o do difusor usando a tecnologia de encolhimento de garrafas PET com um secador de cabelo para constru√ß√£o (espiado nos modelos de aeronaves). <br><br>  Ent√£o, primeiro voc√™ precisa de um espa√ßo em branco.  Fiz de gesso, que coloquei em um formul√°rio que imprimi em uma impressora 3D.  Na primeira vers√£o, o formul√°rio era uma pe√ßa e eu nunca fui capaz de puxar o disco fundido.  Portanto, eu tive que fazer um formul√°rio de duas pe√ßas. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  A ideia do m√©todo √© a seguinte.  Voc√™ coloca uma garrafa de iogurte em um espa√ßo em branco e a senta com um secador de cabelo.  Aqui est√£o apenas re-portando peda√ßos de 20 cont√™ineres diferentes sob leite diferente. Eu nunca consegui colocar essa coisa muito bem, sem dobras e bolhas.  Aparentemente, voc√™ precisa cercar algum tipo de instala√ß√£o a v√°cuo e assentar a folha de pl√°stico.  Em geral, acabou sendo muito dif√≠cil para esse tipo de embarca√ß√£o. <br><br>  Depois de resmungar pelos esquilos, encontrei um par de metros da sonda de pl√°stico Verbatim PET Transparent.  Decidi experimentar o difusor apenas para imprimir.  E, embora na entrada da impressora, o pl√°stico pare√ßa cristalino, a parte real √© opaca.  Provavelmente isso se deve √† estrutura interna, pois  as camadas n√£o preenchem completamente o volume, mas se sobrep√µem a lacunas e lacunas.  Al√©m disso, se voc√™ tentar processar a pe√ßa com uma lixa para obter uma superf√≠cie mais lisa, obteremos ainda mais mate.  No entanto, √© exatamente isso que eu precisava. <br><br>  Eu estava com pregui√ßa de me preocupar com o suporte do difusor, ent√£o o adicionei √† cola quente.  Portanto, meu design agora √© condicionalmente dobr√°vel.  Eu poderia estar confuso com a inven√ß√£o de algum tipo de trava, mas j√° fiquei sem a sonda de pl√°stico transparente.  Ent√£o deixe derreter quente. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Para piscas de LED, voc√™ n√£o precisa mergulhar particularmente na periferia do microcontrolador - apenas algumas fun√ß√µes para trabalhar com o GPIO s√£o suficientes.  Mas como o m√≥dulo est√° encaixado na plataforma Arduino, por que n√£o tirar proveito disso? <br><br>  Primeiro, algumas defini√ß√µes e constantes <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Isso determina o n√∫mero de pixels na minha matriz, n√∫meros de pinos e o brilho m√°ximo dos LEDs (durante a depura√ß√£o, era conveniente configur√°-lo em 50 para que n√£o cegasse meus olhos) <br><br>  Os LEDs na minha matriz s√£o organizados de uma maneira n√£o √≥bvia - um zigue-zague.  Portanto, para efeitos diferentes, tive que renumerar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Para controlar os LEDs, n√£o reinventei a roda e peguei uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca pronta para trabalhar com os LEDs WS8211</a> .  A interface da biblioteca √© ligeiramente caiada de branco.  Algumas fun√ß√µes auxiliares (por exemplo, a convers√£o de HSV para RGB) tamb√©m ficaram presas l√°. <br><br>  Primeiro, a placa e a biblioteca WS8211 precisam ser inicializadas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Antes de tudo, √© necess√°rio definir o sinal POWER HOLD como unidade - este ser√° um sinal para o chip PT1502 que o microcontrolador acabou e est√° funcionando corretamente.  O microcircuito, por sua vez, fornecer√° regularmente eletricidade ao microcontrolador e LEDs, desde que o sinal HOLD esteja definido como unidade. <br><br>  Em seguida, as pernas para controlar o LED na sa√≠da e os bot√µes na entrada s√£o configurados.  Depois disso, voc√™ pode inicializar a biblioteca WS8211. <br><br>  Como este √© um dispositivo bastante aut√¥nomo, n√£o se pode permitir que o microcontrolador fique em um estado incompreens√≠vel e consuma a bateria inteira.  Para fazer isso, inicio o timer do watchdog por 2 segundos.  O cron√¥metro ser√° reiniciado no loop principal do programa. <br><br>  Agora voc√™ precisa definir algumas fun√ß√µes auxiliares.  A biblioteca WS8211 armazena um buffer com os valores de cores de cada LED.  Trabalhar diretamente com o buffer n√£o √© muito conveniente, porque escrevi uma fun√ß√£o simples para gravar valores RGB em um LED espec√≠fico <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  Mas na maioria dos casos, no modelo de cores RGB, contar cores n√£o √© muito conveniente ou mesmo imposs√≠vel.  Por exemplo, ao desenhar qualquer tipo de arco-√≠ris, √© mais conveniente trabalhar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o modelo de cores HSV</a> .  A cor de cada pixel √© definida pelo valor do tom e brilho da cor.  A satura√ß√£o √© omitida por simplicidade (o m√°ximo √© usado).  Os valores de matiz s√£o reduzidos para um intervalo de 0 a 255 (em vez do padr√£o de 0 a 359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  A fun√ß√£o √© retirada da biblioteca Ai_WS8211 e ligeiramente arquivada.  Na vers√£o original dessa fun√ß√£o da biblioteca, havia alguns bugs, devido aos quais a cor do arco-√≠ris era mostrada com empurr√µes. <br><br>  Vamos seguir para a implementa√ß√£o de v√°rios efeitos.  Cada fun√ß√£o √© chamada do loop principal para desenhar um "quadro".  Como cada efeito opera com par√¢metros diferentes entre as chamadas, eles s√£o armazenados em vari√°veis ‚Äã‚Äãest√°ticas. <br><br>  Esse √© o efeito mais simples - todos os LEDs s√£o preenchidos com uma cor, que muda suavemente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  O pr√≥ximo efeito √© mais interessante - exibe um arco-√≠ris ao longo do contorno da matriz e as cores no arco-√≠ris mudam gradualmente em um c√≠rculo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  E esse efeito preenche toda a matriz com uma cor aleat√≥ria, que primeiro acende suavemente e depois tamb√©m sai suavemente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  O pr√≥ximo grupo de efeitos desenha diferentes far√≥is piscantes.  Assim, por exemplo, uma crian√ßa gosta de construir um trator com √≠m√£s e um pisca-pisca laranja ser√° muito √∫til l√°. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Tecnicamente, o efeito parece um ponto brilhante que se move ao longo da matriz.  Mas, para ficar bonito, os LEDs vizinhos desaparecem gradualmente √† medida que voc√™ se afasta do ponto principal.  Portanto, eu precisava de uma fun√ß√£o que calcula esse mesmo brilho. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos √© uma certa posi√ß√£o condicional do ponto luminoso de brilho, mapeado para um intervalo de loopback de 0 a 255.  ledPos √© a posi√ß√£o do LED (exibido na mesma faixa) cujo brilho voc√™ precisa calcular.  Se a diferen√ßa de posi√ß√£o for maior que delta, o LED n√£o acender√° e, quanto mais pr√≥ximo da posi√ß√£o, mais brilhante brilha. <br><br>  Ou, por exemplo, uma luz piscante vermelho-azul da pol√≠cia <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Como estamos falando de carros, o sem√°foro aqui n√£o √© um problema para implementar. <br><br>  Estas s√£o fun√ß√µes que incluem v√°rios sinais de tr√¢nsito em v√°rias posi√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  √â hora de reviv√™-lo.  O sem√°foro opera de acordo com um programa especial definido em uma esp√©cie de bytecode.  A placa descreve o modo e a hora em que esse modo deve ser ativado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  Na verdade, a fun√ß√£o que processa tudo <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Ao atingir o intervalo de tempo especificado, o pr√≥ximo modo de sem√°foro √© ativado e a contagem regressiva inicia novamente. <br><br>  O √∫ltimo efeito sobre o qual minha imagina√ß√£o foi suficiente s√£o asteriscos.  5 LEDs aleat√≥rios acendem com brilho aleat√≥rio e depois desligam sem problemas.  Se uma estrela se apagar, outra em um local aleat√≥rio acender√°. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Em algum lugar aqui um inseto maligno apareceu.  √Äs vezes, as estrelas se iluminam bruscamente ou vice-versa desaparecem abruptamente.  Mas, para ser sincero, eu estava com pregui√ßa de descobrir - parece bem normal. <br><br>  √â hora de pensar em economizar bateria.  Eu j√° dei os valores de consumo dessa coisa toda.  Se voc√™ n√£o pensar em desligar a energia, os LEDs consumir√£o a bateria em algumas horas.  Essa fun√ß√£o √© respons√°vel por desligar a energia ap√≥s 90 segundos de inatividade.  Inicialmente, eram 60 segundos, mas com um jogo real isso n√£o era suficiente, e 2 minutos eram de alguma forma longos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  Na verdade, o desligamento ocorre da seguinte maneira. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Se o usu√°rio pressionar os bot√µes, o temporizador √© redefinido.  Ap√≥s o tempo definido, a fun√ß√£o define o sinal HOLD para zero, que √© um comando PT1502 para desligar a energia.  O Watchdog, a prop√≥sito, tamb√©m precisa ser interrompido; caso contr√°rio, ap√≥s 2 segundos, ele despertar√° o sistema e ligar√° a energia novamente. <br><br>  Finalmente, o loop principal que inicia tudo <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Pressionar o bot√£o alterna os modos e redefine o timer de desligamento autom√°tico.  Dependendo do modo atual, uma das fun√ß√µes de efeito da lista Modos √© iniciada.  Em cada ciclo, o watchdog tamb√©m √© redefinido. <br><br>  Se uma crian√ßa, por exemplo, estava brincando com um carro da pol√≠cia e depois de 1,5 minutos a luz de emerg√™ncia se apagasse, provavelmente depois de um segundo turno, o filho vai querer continuar brincando.  Para fazer isso, o modo selecionado √© salvo na EEPROM (o n√∫mero de c√©lula 10 √© selecionado no bulldozer). <br><br>  Aqui est√° um v√≠deo que mostra como tudo funciona. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Carregador de inicializa√ß√£o </h2><br>  Quase tudo est√° pronto.  Mas h√° mais uma coisa que precisa ser arquivada - um gerenciador de inicializa√ß√£o.  O fato √© que o carregador de inicializa√ß√£o padr√£o n√£o √© adequado para n√≥s. <br><br>  Em primeiro lugar, quando voc√™ liga a alimenta√ß√£o, ela espera por 6 segundos - talvez o firmware comece a derramar nele.  Somente ap√≥s esse controle ser transferido para o firmware principal.  Isso √© conveniente no est√°gio de desenvolvimento, mas ser√° irritante no dispositivo acabado. <br><br>  E segundo, o carregador de inicializa√ß√£o padr√£o n√£o sabe nada sobre o chip PT1502, o que seria bom para dar um sinal de espera.  Sem esse sinal, o microcircuito pensa que o microcontrolador n√£o foi iniciado ou, pelo contr√°rio, deseja desligar.  E, nesse caso, depois de alguns milissegundos, o PT1502 cortar√° a energia de todo o circuito. <br><br>  O benef√≠cio de corrigir os dois problemas n√£o √© dif√≠cil.  O digispark ATTiny85 usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o gerenciador de inicializa√ß√£o de micron√∫cleos</a> .  Este gerenciador de inicializa√ß√£o √© f√°cil o suficiente para arquivar para nossas necessidades.  √â necess√°rio apenas corrigir as defini√ß√µes correspondentes no arquivo de configura√ß√£o. <br><br>  Primeiro, copiei a configura√ß√£o padr√£o de firmware \ configuration \ t85_default para meu pr√≥prio diret√≥rio e j√° fiz todas as altera√ß√µes nele.  Portanto, ser√° f√°cil reverter para o gerenciador de inicializa√ß√£o original. <br><br>  No arquivo bootloaderconfig.h, h√° uma maneira de inserir o carregador de inicializa√ß√£o.  Pelo que √© oferecido imediatamente, nada nos conv√©m, mas a op√ß√£o mais pr√≥xima √© ENTRY_JUMPER.  Nesta op√ß√£o, o gerenciador de inicializa√ß√£o √© acessado apenas se um determinado n√≠vel aparecer em um pino espec√≠fico (o jumper est√° fechado na placa). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  N√£o temos um jumper, mas h√° um bot√£o no p√© do PB2.  Deixe o carregador de inicializa√ß√£o entrar se o bot√£o for pressionado por 5-7 segundos quando a energia for ligada.  Mas se pressionado e liberado, a transi√ß√£o para o firmware principal ocorre imediatamente. <br><br>  Precisamos definir tr√™s fun√ß√µes - inicializa√ß√£o, desinicializa√ß√£o e realmente verificar se √© hora de entrar no gerenciador de inicializa√ß√£o.  No original, todos s√£o simples e implementados com macros.  Apenas os 2 primeiros ser√£o simples <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () configura o pino do bot√£o (JUMPER_PIN) na entrada e desativa o suspensor nela.  J√° temos um pull-up no quadro e no ch√£o, e quando voc√™ pressiona um bot√£o no pino, pelo contr√°rio, haver√° um.  Ao mesmo tempo, voc√™ pode configurar imediatamente o sinal HOLD para emitir e definir a unidade para ele ... <br><br>  Para obter uma explica√ß√£o da aritm√©tica de bits, por exemplo, acesse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , e uma compreens√£o dos registros de configura√ß√£o GPIO nos controladores AVR pode ser obtida, por exemplo, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> . <br><br>  A fun√ß√£o bootLoaderExit () est√° vazia porque  a configura√ß√£o exposta √© bastante adequada para a transi√ß√£o subsequente para o firmware principal <br><br>  A fun√ß√£o bootLoaderStartCondition (), respons√°vel por inserir o carregador de inicializa√ß√£o no formato macro, n√£o se encaixa e, portanto, tornou-se uma fun√ß√£o completa <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  A fun√ß√£o dentro de alguns segundos (de fato, cerca de 6-7) verifica o status do bot√£o.  Se o bot√£o foi liberado anteriormente, n√£o precisamos entrar no gerenciador de inicializa√ß√£o.  Paciente e persistente s√£o permitidos no gerenciador de inicializa√ß√£o. <br><br>  Como se viu, o arquivo bootloaderconfig.h est√° envolvido na compila√ß√£o dos arquivos do assembler e o c√≥digo nesse arquivo causa erros.  Eu tive que colocar a fun√ß√£o no bloco #ifndef __ASSEMBLER__ <br><br>  Outro par√¢metro que eu ajustei diz ao gerenciador de inicializa√ß√£o o que fazer se n√£o estiver conectado ao USB - saia ap√≥s um segundo.  O fato √© que, durante o arrombamento, o filho frequentemente pressionava o bot√£o e acidentalmente entrava no gerenciador de inicializa√ß√£o.  N√£o sei como √© milagroso, mas se o carregador de inicializa√ß√£o n√£o viu a conex√£o USB, ele pode substituir acidentalmente algumas p√°ginas de mem√≥ria.  Portanto, se n√£o houver conex√£o, simplesmente sairemos para o programa principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  N√≥s compilamos ... e obtemos um erro de que o c√≥digo n√£o se encaixa no espa√ßo do carregador de inicializa√ß√£o alocado para ele.  Como a mem√≥ria flash no controlador √© muito pequena, o gerenciador de inicializa√ß√£o √© compactado ao m√°ximo para deixar mais espa√ßo para o programa principal.  Mas isso √© facilmente corrigido no arquivo Makefile.inc, seguindo as instru√ß√µes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Depois, reduzi o endere√ßo inicial do carregador de inicializa√ß√£o para uma p√°gina (64 bytes), aumentando assim o espa√ßo do carregador de inicializa√ß√£o. <br><br>  Caso contr√°rio, compilar e fazer upload do gerenciador de inicializa√ß√£o usando o programador USBAsp n√£o foi um problema. <br><br><h2>  Conclus√£o </h2><br>  Era uma maneira muito interessante de um prot√≥tipo em uma placa de ensaio para um dispositivo acabado.  Parece um pisca-pisca comum de uma aula de arduino, mas, de fato, no processo de trabalho, tive que resolver um monte de problemas interessantes - aqui est√£o a luta com o consumo, a escolha da base do elemento e o design do caso, e trazendo √† mente o firmware com o gerenciador de inicializa√ß√£o.  Espero sinceramente que minha experi√™ncia seja √∫til para algu√©m. <br><br>  Poderia ter sido mais f√°cil?  Claro que voc√™ pode.  Eu acho que tudo poderia ser feito com um transistor.  Infelizmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> li <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> depois de soldar o quadro.  Eu veria o artigo anteriormente - eu faria tudo no mesmo TP4056 popular - √© mais f√°cil sold√°-lo.  De qualquer forma, o conversor DC-DC, que est√° dentro do PT1502 neste dispositivo, definitivamente, n√£o √© necess√°rio.  No entanto, um estudo pr√°tico do microcircuito PT1502 √© √∫til para mim em meu outro projeto, bem como a capacidade de soldar microcircuitos no pacote QFN20. <br><br>  Finalmente, aqui est√£o os links para o meu projeto: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo de firmware</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Circuito e placa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo de caixa e difusor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelos STL prontos para impress√£o</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435198/">https://habr.com/ru/post/pt435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435184/index.html">Intelig√™ncia artificial aprendida a encontrar a doen√ßa de Alzheimer no c√©rebro 6 anos antes do diagn√≥stico</a></li>
<li><a href="../pt435186/index.html">Rolls-Royce desenvolve o avi√£o el√©trico mais r√°pido do mundo</a></li>
<li><a href="../pt435190/index.html">O Google conseguiu retirar a tributa√ß√£o de US $ 22,7 bilh√µes atrav√©s da Irlanda e Bermuda</a></li>
<li><a href="../pt435194/index.html">Simplifique a escrita do curr√≠culo de um desenvolvedor</a></li>
<li><a href="../pt435196/index.html">Pesquisadores aprovam ReCAPTCHA usando os servi√ßos do Google</a></li>
<li><a href="../pt435202/index.html">Escrevemos nossa linguagem de programa√ß√£o, parte 1: escrevemos uma linguagem VM</a></li>
<li><a href="../pt435204/index.html">Recep√ß√£o para que os desenvolvedores superem a procrastina√ß√£o</a></li>
<li><a href="../pt435206/index.html">Europa aprova diretiva de direitos autorais - por que as plataformas de streaming se op√µem</a></li>
<li><a href="../pt435208/index.html">Internet das coisas ... que choram por uma boa UI / UX</a></li>
<li><a href="../pt435210/index.html">O trabalho de Xamarin com o C SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>