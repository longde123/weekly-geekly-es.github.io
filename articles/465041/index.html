<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëº üë©üèº‚Äçüíª üëâüèæ C√≥mo hacer una transacci√≥n BTC sin depositar monedas peque√±as ü§±üèº ‚ò∫Ô∏è üï¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchas billeteras bitcoin al elegir monedas para enviar prefieren usar una moneda grande, cuyo saldo es mayor que la cantidad enviada. Despu√©s de cada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo hacer una transacci√≥n BTC sin depositar monedas peque√±as</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465041/"><p><img src="https://habrastorage.org/webt/fn/ez/kn/fnezknn373mov5izqcr1u0nppfk.png" alt="Objetivo: empacar tantos art√≠culos valiosos como sea posible en una mochila, siempre que la mochila tenga una capacidad limitada"></p><br><p> Muchas billeteras bitcoin al elegir monedas para enviar prefieren usar una moneda grande, cuyo saldo es mayor que la cantidad enviada.  Despu√©s de cada transacci√≥n, se forma una moneda de cambio.  Despu√©s de un tiempo, toda la billetera est√° cubierta de monedas del orden de 0.001 (~ $ 10 en este momento), que ya no hay nada en qu√© gastar.  Cuando, una vez m√°s, necesitaba hacer una transacci√≥n, se me ocurri√≥ si era posible ensamblar la transacci√≥n para que no hubiera cambios.  La billetera se ofreci√≥ obstinadamente a "cortar" otra moneda m√°s grande, as√≠ que decid√≠ recoger monedas con mis manos para recolectar la cantidad necesaria.  Sin embargo, esto result√≥ no ser tan simple: la suma result√≥ ser menor que el valor deseado o excedi√≥ demasiado.  Como resultado, decid√≠ que deber√≠a haber un algoritmo con el que puedas recolectar la cantidad deseada de monedas o un poco m√°s.  Result√≥ que esto no solo es posible, sino que funciona tan bien que me hizo escribir este art√≠culo.  Pero lo primero es lo primero. </p><a name="habracut"></a><br><h2 id="zadacha-o-ryukzake">  Problema de mochila </h2><br><p>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de la mochila es</a> ampliamente conocido: empacar tantas cosas valiosas como sea posible en una mochila, siempre que la capacidad de la mochila sea limitada.  En este caso, tenemos el caso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del problema de mochila 0-1</a> , ya que cada art√≠culo (moneda) est√° disponible para empacar en la mochila solo una vez.  Adem√°s, el peso de cada "elemento" coincide con su valor, por lo que estamos tratando con un caso a√∫n m√°s especial, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de la suma de los subconjuntos</a> .  Wikipedia sugiere usar un algoritmo gen√©tico, pero decid√≠ buscar una soluci√≥n exacta usando programaci√≥n din√°mica, ya que esto es bastante factible en t√©rminos de recursos y parece simple. </p><br><p>  Para reducir el problema de elegir monedas para la tarea de una mochila, debe realizar una peque√±a conversi√≥n de los datos de entrada.  El hecho es que resolver el problema de la mochila (m√°s precisamente, la suma de los subconjuntos) nos dar√° un subconjunto del conjunto original que tiene una cantidad m√°xima que no excede el par√°metro (capacidad de carga de la mochila).  Pero no estamos satisfechos con la combinaci√≥n de monedas, dando una cantidad menor que la cantidad que queremos enviar.  Sin embargo, nos sentimos c√≥modos con combinaciones que son ligeramente superiores.  Por ejemplo, si necesitamos enviar 0.005 bitcoins, y encontramos una combinaci√≥n que da 0.00499, entonces es in√∫til para nosotros, ya que es menor que la cantidad que el vendedor quiere.  Pero si encontramos 0.005001, eso es correcto.  Se puede usar satoshiki adicional como comisi√≥n (hablaremos de ello en detalle a continuaci√≥n) o se lo daremos al vendedor si √©l permite enviar una cantidad mayor.  Por lo tanto, con la ayuda del problema de la mochila, debemos elegir no las monedas que deben <strong>enviarse</strong> , sino las que deben <strong>dejarse</strong> .  Entonces la "escasez" al m√°ximo se convertir√° en "quiebra" en t√©rminos del problema original. </p><br><p><img src="https://habrastorage.org/webt/ew/3q/su/ew3qsuzkpbzdy68chuyleel8vrm.png" alt="Selecci√≥n autom√°tica y manual de monedas para enviar"></p><br><p>  Un ejemplo  Supongamos que tenemos tales monedas: 0.1 BTC, 0.002 BTC, 0.00832423 BTC.  Y necesitamos enviar 0.01 BTC.  Encontramos tales monedas, cuya cantidad ser√° m√°xima, pero menor o igual que la cantidad total de nuestras monedas menos la cantidad enviada, es decir, dicho n√∫mero: 0.1 + 0.002 + 0.00832423 - 0.01 = 0.10032423.  En este caso, una b√∫squeda simple descubre que es una moneda de 0.1.  Lo dejamos, lo que significa que enviamos el resto: 0.002 BTC y 0.00832423 BTC, que en total dan 0.01032423 BTC, que es m√°s de 0.01 BTC y nos conviene.  (Es cierto, la comisi√≥n sali√≥ alrededor de $ 3, pero, digamos que la red est√° ocupada y queremos que el env√≠o sea lo m√°s r√°pido posible). </p><br><h2 id="komissii">  Comisiones </h2><br><p>  Para tener en cuenta las tarifas de transacci√≥n, modifiqu√© cada moneda de entrada, reduciendo su saldo en la cantidad que habr√≠a que pagar por su inclusi√≥n en la transacci√≥n como entrada.  Esto se puede hacer conociendo el tama√±o de la entrada y la comisi√≥n (por ejemplo, 2 satoshi por byte).  Adem√°s, modifiqu√© el monto a enviar, agregando el precio de la parte de la transacci√≥n que no depende de las monedas seleccionadas: encabezado y salida (s).  El usuario puede especificar todos estos par√°metros usando banderas.  Tambi√©n puede deshabilitar el ajuste de las comisiones en general especificando una comisi√≥n de 0 Satoshi por byte. </p><br><p>  Tom√© informaci√≥n sobre los tama√±os de las entradas y salidas en diferentes versiones de direcciones (segwit cl√°sico, envuelto y segwit nativo desde aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bitcoin.stackexchange.com/a/84006</a> </p><br><h2 id="algoritmy-i-realizaciya">  Algoritmos e implementaci√≥n </h2><br><p>  Inmediatamente dej√© caer el algoritmo gen√©tico, quiz√°s en vano.  Centrado en algoritmos precisos.  Mi primer intento fue realizar a trav√©s de una b√∫squeda exhaustiva de todas las combinaciones, pero incluso con 40 monedas funcion√≥ durante horas y tuvo que abandonarlo.  Luego prob√© la programaci√≥n din√°mica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sugerida en Wikipedia</a> .  En √©l, no puede guardar en la memoria toda la matriz, sino solo las filas actuales y anteriores.  Adem√°s, no necesitamos almacenar el valor, ya que coincide con el peso y es el n√∫mero de columna.  Pero debemos recordar la combinaci√≥n: decid√≠ almacenarla en forma de bitset.  Adem√°s, puede almacenar solo una fila, creando la siguiente fila in situ a partir de ella.  Cada registro de fila distinto de cero permanece en su lugar y se copia (con la adici√≥n del bit correspondiente) a otra celda, un cierto n√∫mero de celdas a la derecha (si antes estaba vac√≠o).  Si va en el orden inverso, clasificando a trav√©s de la celda en la que va el "salto", entonces puede llenar todo correctamente: </p><br><p><img src="https://habrastorage.org/webt/fa/qb/ts/faqbtspntkfkjgzwy6koiubabvi.png" alt="Ilustraci√≥n de la transici√≥n a la siguiente fila, es decir, agregar otra moneda a la programaci√≥n din√°mica"><br>  <em>Cada celda diferente de cero en la fila actual genera en la siguiente fila y otra celda para un cierto n√∫mero de celdas (igual al valor de la moneda agregada) a la derecha.</em>  <em>Si ya hay un valor en esa celda, entonces la opci√≥n con el mayor n√∫mero de monedas seleccionadas (es decir, no incluidas en la transacci√≥n) "gana", ya que queremos enviar la menor cantidad de monedas posible, otras cosas son iguales.</em> </p><br><p>  En una celda gasto 8 bytes para un conjunto de bits, y el n√∫mero de celdas es igual al n√∫mero posible de saldos de 0 a la cantidad de monedas menos la cantidad enviada.  Por ejemplo, si solo hay 1 bitcoin en la billetera y se env√≠a 0.1, entonces habr√° 100'000'000-10'000'000 = 90'000'000 celdas, cada una de 8 bytes, eso es 720 megabytes, un poco para una computadora moderna.  Si el n√∫mero de monedas es inferior a 32, podr√≠an usarse 4 bytes por moneda, pero no lo optimic√©.  Adem√°s, si hay m√°s de 64 monedas, entonces el programa no funciona; esto tambi√©n deber√≠a corregirse haciendo un conjunto de bits de longitud arbitraria.  Finalmente, puede descartar el √∫ltimo signo en las balanzas, perdiendo un poco de precisi√≥n, pero ganando 10 veces en la memoria.  Pero hasta ahora lo har√°. </p><br><p> Llam√© al <strong>programa sin cambios</strong> y lo coloqu√© en el gitlab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gitlab.com/starius/changeless</a> .  Est√° escrito en Go, ensamblado usando <code>go get</code> , como de costumbre.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los binarios para Linux, Windows, Mac</a> , recopilados en CI est√°n disponibles. </p><br><p>  Cuando lanc√© el programa con monedas reales, me sorprendi√≥ la precisi√≥n con que ella recogi√≥ la combinaci√≥n necesaria.  Cuando el n√∫mero de monedas es grande, casi cualquier cantidad acorde con los saldos de las monedas se puede seleccionar con precisi√≥n hasta satoshi.  Cambia la cantidad requerida para 1 satoshi y el programa ofrece una combinaci√≥n completamente diferente de monedas exactamente para esta cantidad.  A continuaci√≥n se muestra un ejemplo de trabajo en 50 monedas aleatorias con saldos de 0 a 1 bitcoin. </p><br><pre> <code class="plaintext hljs">$ cat coins50.txt 0.01331611 0.03906237 0.04847086 0.08453118 0.09748168 0.10395389 0.10619825 0.12156721 0.12923149 0.13587973 0.14798976 0.16053788 0.19011834 0.21570038 0.21946913 0.31861430 0.33435508 0.33718842 0.33789473 0.35976748 0.37360122 0.44944553 0.47572926 0.49927495 0.50992142 0.53062326 0.53079433 0.53542072 0.54715225 0.55019714 0.55313907 0.56656642 0.56673333 0.65879650 0.66228482 0.68424322 0.70436496 0.75638055 0.79095597 0.82438005 0.83684407 0.85151564 0.86862948 0.90054250 0.90239402 0.91636213 0.93087757 0.93579251 0.97207439 0.98248384 $ changeless -amount 10.00000000 -coins coins50.txt Processing item 50/50. 0.09748168 + 0.33435508 + 0.47572926 + 0.53542072 + 0.66228482 + 0.70436496 + 0.75638055 + 0.82438005 + 0.9005425 + 0.90239402 + 0.91636213 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004651 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte). $ changeless -amount 10.00000001 -coins coins50.txt Processing item 50/50. 0.01331611 + 0.09748168 + 0.53079433 + 0.56656642 + 0.70436496 + 0.75638055 + 0.82438005 + 0.86862948 + 0.9005425 + 0.91636213 + 0.93087757 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004652 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte).</code> </pre> <br><p>  El programa logr√≥ recoger combinaciones de monedas para enviar exactamente 10 bitcoins y exactamente 10.00000001 bitcoins (10 bitcoins y 1 satoshi).  Para ver esto, debe restar la comisi√≥n de la cantidad de monedas: 10.00004651 - 0.00004651 = 10, 10.00004652 - 0.00004651 = 10.00000001. </p><br><h2 id="kak-poluchit-spisok-balansov-monet">  C√≥mo obtener una lista de saldos de monedas </h2><br><p>  Para el programa Electrum, encontr√© esta manera (comando de consola): </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent())</code> </pre> <br><p>  Si desea excluir ciertas monedas, por ejemplo, en una direcci√≥n determinada, esto puede hacerse as√≠: </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent() if x["address"] != "bad address")</code> </pre> <br><p>  Para otras billeteras, no encontr√© una manera tan f√°cil y tuve que volver a escribirla con mis manos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465041/">https://habr.com/ru/post/465041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465027/index.html">10 preguntas ingenuas pero importantes sobre CRM</a></li>
<li><a href="../465029/index.html">[POSIBLE] SORM descifra el tr√°fico HTTPS a Mail.ru e ICQ</a></li>
<li><a href="../465031/index.html">Vista interior: RFID en el mundo moderno. Parte 2: RFID chino</a></li>
<li><a href="../465033/index.html">Ven con la tecnolog√≠a Powercheck</a></li>
<li><a href="../465039/index.html">Semana de la seguridad 35: estad√≠sticas de contrase√±as y ataques filtrados a trav√©s de Google Drive</a></li>
<li><a href="../465045/index.html">Kali Linux NetHunter en Android: por qu√© y c√≥mo instalar</a></li>
<li><a href="../465047/index.html">Pruebas unitarias en DBMS: c√≥mo lo hacemos en Sportmaster, segunda parte</a></li>
<li><a href="../465049/index.html">10 libros sobre gesti√≥n √°gil de proyectos que vale la pena llevar contigo en 2020</a></li>
<li><a href="../465055/index.html">Seis habilidades para llevar tu carrera de ciencia de datos al siguiente nivel.</a></li>
<li><a href="../465057/index.html">Contenedores y Ventanas. De Hello World a Kubernetes. Primera parte, introductoria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>