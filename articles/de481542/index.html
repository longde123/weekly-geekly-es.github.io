<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¶ üêï ü§ôüèø √úberpr√ºfung von digitalen Schaltkreisen. R√ºckblick üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üê§ ‚ÄºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich werde versuchen, allgemein √ºber die Verifizierung digitaler Schaltkreise zu sprechen. 


 Die √úberpr√ºfung in diesem Bereich ist ein wichtiger Proz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfung von digitalen Schaltkreisen. R√ºckblick</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481542/"><p><img src="https://habrastorage.org/getpro/habr/post_images/889/a75/78e/889a7578e7d0f02194ae18361e06f056.jpg" alt="Bild"></p><br><p>  Ich werde versuchen, allgemein √ºber die Verifizierung digitaler Schaltkreise zu sprechen. </p><br><p>  Die √úberpr√ºfung in diesem Bereich ist ein wichtiger Prozess, bei dem erfahrene Ingenieure hinzugezogen werden m√ºssen.  Beispielsweise muss ein Verifizierungsspezialist, der an Systemen mit einer CPU arbeitet, in der Regel √ºber Skriptsprachen und Befehlsshellsprachen (Tcl, bash, Makefile usw.), Programmiersprachen (C, C ++, Assembler) und HDL / HDVL verf√ºgen (SystemVerilog [10, Anhang C - Geschichte der Sprache] [11], Verilog, VHDL), moderne Methoden und Frameworks (UVM). </p><br><p>  Der f√ºr die √úberpr√ºfung aufgewendete Zeitanteil betr√§gt 70-80% der gesamten Projektzeit.  Einer der Hauptgr√ºnde f√ºr diese Aufmerksamkeit ist, dass Sie nach der Serienproduktion keinen ‚ÄûPatch‚Äú auf dem Chip ver√∂ffentlichen k√∂nnen, sondern nur ‚ÄûSilizium-Errata‚Äú (dies gilt nicht f√ºr FPGA / FPGA-Projekte). </p><br><p>  Mit digitalen Schaltungen meine ich: </p><br><ul><li>  komplexe Funktionsbl√∂cke / geistiges Eigentum (SFB / IP); </li><li>  Kundenspezifische Chips f√ºr anwendungsspezifische integrierte Schaltkreise (ASIC) </li><li>  integrierte programmierbare Logikschaltungen / feldprogrammierbares Gate-Array (FPGA); </li><li>  Systeme auf einem Chip / System-on-Crystal (SoC / SoC); </li><li>  usw. </li></ul><a name="habracut"></a><br><h2 id="aktualnye-problemy-verifikacii">  Aktuelle √úberpr√ºfungsprobleme </h2><br><p>  Der aktuelle Stand und die Trends auf dem Gebiet der Verifizierung k√∂nnen anhand der folgenden Herausforderungen und Probleme beurteilt werden [6]: </p><br><ul><li>  Die Gr√∂√üe des Verifizierungsobjekts (OB) w√§chst st√§ndig.  Selbst ein kleiner Mikrocontroller-IC besteht aus einem Satz von Dutzenden von Submodulen, die h√§ufig komplexe Funktionen aufweisen.  Gro√üe ICs sind Komplexe, in denen es bis zu zehn Milliarden Transistoren geben kann, und das Energieverwaltungsschema allein kann einige Prozessoren in seiner Komplexit√§t √ºbertreffen [8]. </li><li>  Es ist unm√∂glich, zu Beginn des Projekts eine Spezifikation f√ºr IMS zu erstellen und diese erst in der Zukunft zu befolgen. Sie √§ndert sich w√§hrend des gesamten Entwicklungsprozesses st√§ndig (der Kunde √§ndert die Anforderungen, technischen Probleme oder findet optimale L√∂sungen, um Ans√§tze zu √ºberdenken usw.).  Auf dieser Grundlage sollten alle Prozesse die Dynamik von Spezifikations√§nderungen wahrnehmen und entsprechend den Anforderungen modifiziert werden. </li><li>  H√§ufig arbeiten mehrere voneinander entfernte Teams an der Projekt√ºberpr√ºfung, deren Anzahl Dutzende von Personen erreichen kann. </li><li>  Die Anzahl der einzelnen Tests und ihre Arten erreicht eine gro√üe Anzahl, ihre Ergebnisse m√ºssen gesammelt und analysiert werden. </li><li>  Die Modellierung auch digitaler Systeme erfordert viel Computerzeit. </li><li>  Die Vollst√§ndigkeit der f√ºr das Projekt festgelegten Vorbereitungsziele h√§ngt weitgehend von der Kompetenz und der Intuition der Verifizierungsspezialisten ab. </li><li>  Trotz des Vorhandenseins von Indikatoren f√ºr die Projektabdeckung mit Tests (Metriken) besteht die einzige M√∂glichkeit, die √úberpr√ºfung abzuschlie√üen, darin, sie auszusetzen. Dies basiert haupts√§chlich auf den folgenden Schlussfolgerungen: Das Geld oder die Zeit, die f√ºr die Projektphase aufgewendet werden muss, scheint eine Codeabdeckung von 100 zu haben %, wir testen seit einer Woche und haben keine Fehler gefunden. </li></ul><br><h2 id="tipy-verifikacii">  √úberpr√ºfungstypen </h2><br><p>  Die √úberpr√ºfung von digitalen Schaltkreisen kann in folgende Haupttypen unterteilt werden: </p><br><ol><li>  <strong>funktional</strong> (Funktions√ºberpr√ºfung) - der Name spricht f√ºr sich selbst, Sie pr√ºfen, ob Ihr System seine Funktionen korrekt ausf√ºhrt; </li><li>  formale Verifikation - Mit dieser Verifikation wird die Gleichwertigkeit der Darstellungen Ihres Systems auf verschiedenen Stufen des Entwurfswegs oder die Erf√ºllung der im Quellcode gesetzten Aussagen festgestellt: <br><ul><li>  √Ñquivalenzpr√ºfung (z. B. RTL-zu-RTL, RTL-zu-Gate, Gate-zu-Gate); </li><li>  Eigenschaftspr√ºfung (Modellpr√ºfung) (pr√ºft die im Code angegebenen Eigenschaften (Zusicherungen) mit SVA (zum Beispiel)). </li></ul></li><li>  Statische Code-Analyse - √úberpr√ºfung des Quellcodes nach formalen Kriterien hinsichtlich der Einhaltung der Regeln f√ºr die Verwendung der Sprache und ihrer Konstruktionen.  Sehr oft werden die konfigurierten √úberpr√ºfungsregeln an RMM gesendet [4].  Programme f√ºr eine solche √úberpr√ºfung werden normalerweise als Flusen oder Linter bezeichnet. </li><li>  <strong>physische Verifizierung</strong> - beinhaltet im Wesentlichen DRC-, LVS-, PERC- usw. √úberpr√ºfungen, die physische Darstellung des Systems wird auf √úbereinstimmung mit technologischen Standards und die Konformit√§t von physischen und logischen Darstellungen usw. √ºberpr√ºft.  Die Zusammensetzung der Schecks ist stark technologieabh√§ngig.  In der Regel wird die physische √úberpr√ºfung von einem Ingenieur oder einem topologischen Designteam durchgef√ºhrt. </li><li>  <strong>Prototyping</strong> - Verwendung von FPGA zur Funktions√ºberpr√ºfung [18]. </li></ol><br><p>  Die Funktions√ºberpr√ºfung im Rahmen aller Arbeiten ist von gr√∂√üter Bedeutung und erfordert die direkte Einbeziehung des Menschen. </p><br><p>  Die Analyse des statischen Codes erfordert nur eine Erstkonfiguration der Tools, die den vom Unternehmen festgelegten internen Designregeln entspricht. Dann ist das Tool darauf bedacht, dass es Entwicklern ‚Äûwertvolle Hinweise‚Äú gibt und keine st√§ndige √úberwachung erfordert. </p><br><p>  Formale √úberpr√ºfungswerkzeuge sind oftmals auch sehr unabh√§ngig und erfordern nur eine sorgf√§ltige Analyse der von ihnen erstellten Berichte.  Sie eignen sich auch f√ºr das Reverse Engineering, wenn Sie aus irgendeinem Grund wissen, dass Sie den Code aus der Liste der Schaltkreise wiederherstellen m√ºssen. </p><br><h2 id="primery-instrumentov-verifikacii">  Beispiele f√ºr √úberpr√ºfungstools </h2><br><p>  Beispiele f√ºr Tools zur √úberpr√ºfung digitaler Schaltungen (Digital-On-Top-Route): </p><br><ul><li>  √úberpr√ºfungsverwaltungstools <br><ul><li>  Mentor Graphics - Questa √úberpr√ºfungsmanagement </li><li>  Cadence - vManager </li><li>  Synopsys - Verdi, VC Execution Manager ("ExecMan") </li></ul></li><li>  funktionsf√§hig - in der Regel Simulatoren <br><ul><li>  Mentor Graphics - ModelSim, QuestaSim </li><li>  Cadence - Incisive, Xcelium </li><li>  Synopsys - VCS </li><li>  Freie Software von unabh√§ngigen Entwicklern - Simulatoren Verilator, Icarus [5] </li></ul></li><li>  formal <br><ul><li>  Mentor Graphics - Formal Pro, Questa Formale Verifizierung </li><li>  Cadence - JasperGold, Conformal LEC, Plattform f√ºr formale Verifizierung </li><li>  Synopsys - Formalit√§t, VC Formal </li></ul></li><li>  statische Code-Analyse <br><ul><li>  Mentor Graphics - Questa AutoCheck </li><li>  Cadence - HAL, JasperGold </li><li>  Inhaltsangabe - SpyGlass Lint </li></ul></li><li>  physische √úberpr√ºfung <br><ul><li>  Mentor Graphics - Kaliber </li><li>  Cadence - Pegasus, System zur physischen Verifizierung, </li><li>  Synopsys - Hercules, IC Validator </li></ul></li></ul><br><h2 id="metody-funkcionalnoy-verifikacii">  Funktionspr√ºfungsmethoden </h2><br><p>  Funktions√ºberpr√ºfung - ist eine Reihe von Tests, ich erlaube mir unter bestimmten Bedingungen, in drei Gruppen eingeteilt zu werden (dies ist kein Dogma, dies ist aus pers√∂nlicher Erfahrung): </p><br><ol><li>  <strong>Positive Verzweigungen</strong> - √úberpr√ºfung des Verhaltens in normalen Situationen, geregelt durch die Spezifikation f√ºr das Ger√§t oder den Standard usw.  Das hei√üt  Wir pr√ºfen Situationen, in denen alles gut l√§uft. </li><li>  <strong>Negative Verzweigungen</strong> - √úberpr√ºfung von Abweichungen von Standardsituationen, aber beispielsweise im Rahmen einer Spezifikation oder eines Standards - Nicht√ºbereinstimmung der Pr√ºfsumme, Anzahl der empfangenen Daten usw.  Das hei√üt  wenn etwas schief geht, aber wir wussten, dass dies sein k√∂nnte und wir wissen, wie man in dieser Situation arbeitet. </li><li>  <strong>Nicht-Standard-Situationen</strong> - beliebige Situationen, von Verst√∂√üen gegen Kommunikationsprotokolle, die Reihenfolge der Daten bis hin zu physischen Kollisionen in Schnittstellen, zuf√§lligen √Ñnderungen des Zustands von Logikelementen usw.  Das hei√üt  In diesem Fall kann alles passieren und Sie m√ºssen sicherstellen, dass der OB danach wieder funktionsf√§hig ist. </li></ol><br><p>  Die ersten beiden Stufen k√∂nnen mithilfe von UVC / VIP (Universal Verification Component / Verification IP) automatisiert werden. Dort k√∂nnen Sie schnell das Volumen verschiedener Tests erh√∂hen, auch der automatisch generierten.  Die dritte Stufe ist ein "Meisterst√ºck" in der Verifikation, diese Stufe erfordert einen au√üergew√∂hnlichen Ansatz und Erfahrung, es ist sehr schwer zu automatisieren, weil  Die meisten Situationen sind ein separater Algorithmus, m√∂glicherweise ein Skript f√ºr CAD oder Anweisungen f√ºr "manuelle" Pr√ºfungen. </p><br><h3 id="tipy-metrik-funkcionalnoy-verifikacii">  Arten von Metriken zur Funktions√ºberpr√ºfung </h3><br><p>  Metriken sind Indikatoren f√ºr die Testabdeckung eines Projekts.  Sie werden ben√∂tigt, um zu verstehen, welche anderen Tests entwickelt werden m√ºssen, um m√∂gliche Situationen zu √ºberpr√ºfen und wie viel Zeit die √úberpr√ºfung in Anspruch nehmen kann [16]. </p><br><p>  Leider wird nur ein Metriktyp basierend auf dem Quellcode des Projekts bewertet, die Definition der Kriterien f√ºr die √ºbrigen Typen ist das Ergebnis intellektueller Arbeit. </p><br><p>  Dar√ºber hinaus muss beachtet werden, dass das Erreichen der gew√ºnschten Indikatoren durch eine Art von Metrik nicht die Verarbeitbarkeit im Allgemeinen bedeutet, es ist immer notwendig, den Komplex zu bewerten. </p><br><p>  Arten von Metriken [3]: </p><br><ul><li>  <strong>funktionelle Beschichtung</strong> .  Zeigt an, wie viel die OB-Funktion getestet wurde.  Die Kriterien f√ºr diese Abdeckung k√∂nnen durch den Testplan und die Einf√ºhrung von Sonderkonstruktionen (Covergroup [1]) in die Testumgebung und / oder das OM festgelegt werden. Dabei kann √ºberwacht werden, ob eine bestimmte Funktion / Aktion ausgef√ºhrt wurde, ob sich die Daten auf eine bestimmte Art und Weise ge√§ndert haben usw.  Informationen aus im Quellcode eingebetteten Designs k√∂nnen automatisch von CAD erfasst werden. </li><li>  <strong>Codeabdeckung</strong> - √Ñndern des Status von Quellcodekonstruktionen w√§hrend der Tests.  Es wird automatisch von CAD gesammelt, erfordert keine Einf√ºhrung von Strukturen im Quellcode.  Zum Beispiel: <br><ul><li>  Schaltregister (Toggle Coverage); </li><li>  Aktivit√§t jeder Codezeile (Line Coverage); </li><li>  Aktivit√§t von Ausdr√ºcken (Anweisungsabdeckung) - Dies ist zwar die Zeilenabdeckung, kann jedoch Ausdr√ºcke verfolgen, die mehr als eine Zeile im Editor enthalten. </li><li>  Aktivit√§t eines Codesegments innerhalb einer bedingten Anweisung oder Prozedur (Block Coverage), eine Variation der Anweisungsabdeckung; </li><li>  Aktivit√§t aller Zweige von bedingten Anweisungen, z. B. wenn, w√§hrend, f√ºr immer wiederholen, f√ºr, Schleife (Branch Coverage); </li><li>  √Ñnderung aller Zust√§nde (wahr, falsch) der logischen Ausdr√ºcke der Komponente (Ausdrucks√ºberdeckung); </li><li>  Zustand der Zustandsmaschine (Finite-State-Machine-Coverage). </li></ul></li><li>  <strong>Anspr√ºche decken</strong> .  Anweisungen sind spezielle Sprachkonstrukte, die verschiedene Ereignisse und Sequenzen verfolgen und nach festgelegten Kriterien die Rechtm√§√üigkeit ihres Auftretens bestimmen. </li></ul><br><h3 id="metody-funkcionalnoy-verifikacii-1">  Funktionspr√ºfungsmethoden </h3><br><h4 id="directed-tests-method-dtm">  Directed Tests Method (DTM) </h4><br><p>  Direkte, aussagekr√§ftige Tests.  Wenn diese Methode im Projekt √ºbernommen wird, besteht der √úberpr√ºfungsplan aus Tests, mit denen das Verhalten von organischer Substanz an bestimmten Punkten von Interesse (Zust√§nden) √ºberpr√ºft werden soll.  Es ist fast unm√∂glich, alle m√∂glichen Situationen, insbesondere in komplexen Projekten, zu √ºberpr√ºfen. <br>  Gleichzeitig werden Probleme, die in Situationen auftreten k√∂nnen, die nicht durch Tests abgedeckt sind, nicht erkannt, bevor das Ger√§t unter realen Bedingungen in Betrieb genommen wird.  In der Regel verwenden diese Tests Metriken f√ºr die funktionale Abdeckung. </p><br><h4 id="coverage-driven-verification-metric-driven-verification-cdv-mdv-17">  Coverage-Driven Verification, Metric-Driven Verification (CDV, MDV) [17] </h4><br><p>  Das Konzept der Erstellung von Tests zielt darauf ab, eine bestimmte ‚ÄûTestabdeckung‚Äú von organischen Substanzen zu erreichen.  Sie verlassen sich auf Metriken, um zu verstehen, welche Tests zum Verifizierungsplan hinzugef√ºgt werden m√ºssen, um die Projektbereitschaftsziele zu erreichen. <br>  Sie m√ºssen Abdeckungsanalyse-Tools verwenden, um zu sehen, was dem √úberpr√ºfungsplan noch hinzugef√ºgt werden muss.  In der Tat k√∂nnen wir bereits davon ausgehen, dass wir reibungslos von DTM zu CDV gewechselt sind, wenn wir beginnen, den √úberpr√ºfungsplan im DTM anzupassen, indem wir uns zumindest auf die ‚ÄûCodeabdeckung‚Äú verlassen. </p><br><h4 id="constrained-random-verification-crv">  Eingeschr√§nkte zuf√§llige √úberpr√ºfung (CRV) </h4><br><p>  √úberpr√ºfung durch Einreichung zuf√§lliger Einfl√ºsse.  Dies sind wirklich automatische Tests, bei denen zuf√§llige Effekte auf OM erzeugt werden. Eine Symbiose mit ABV ist jedoch nur schwer vorstellbar. <br>  Die Methode ist zun√§chst sehr aufwendig, weil  Die Vorbereitung der Werkzeuge dauert lange.  Nach Abschluss der anf√§nglichen Vorbereitungsphase kann der Test automatisch wiederholt mit unterschiedlichen Anfangsdaten gestartet werden.  Wenn eine Assertionsinkongruenz erkannt wird, beginnt das Entwicklungs- und Verifizierungsteam mit der Analyse des erkannten Fehlers. <br>  In einem realen Projekt kann man sich nicht nur auf diese Methode beschr√§nken, weil  Mit dieser Methode k√∂nnen Sie Codeabdeckung und Anweisungsabdeckung erfassen, und sie k√∂nnen nichts √ºber den korrekten Betrieb des Betriebssystems aussagen, d. H.  Einhaltung der Spezifikationen.  Es muss mit Funktionstests erg√§nzt werden. <br>  Zur Implementierung dieser Methodik ist Folgendes erforderlich: </p><br><ol><li>  Implementieren Sie "Assertion" in allen wichtigen Punkten des Quellcodes des OB und der Testumgebung. </li><li>  Generatoren zuf√§lliger Effekte und Szenarien ihrer Arbeit zu entwickeln, d.h.  Die Auswirkungen sind zuf√§llig, es bestehen jedoch Einschr√§nkungen hinsichtlich der Reichweite (wir haben nicht die Zeit, alles zu sortieren), der Reihenfolge der Ablage usw. </li></ol><br><h4 id="assertion-based-verification9-abv">  Durchsetzungsbasierte √úberpr√ºfung [9] (ABV) </h4><br><p>  √úberpr√ºfung mit Aussagen.  Wahrscheinlich ist dies nicht einmal eine eigenst√§ndige Methode, sondern eine Komponente oder Grundkomponente der obigen. </p><br><p>  Ein wichtiges Thema bei ABV ist die Verteilung von Behauptungen, die sich am besten im Quellcode des OB befinden und die sich in der Testumgebung befinden sollten. </p><br><p>  Es sollte sofort beachtet werden, dass die Verilog-Sprache keine Assertions in ihrem Standard enth√§lt (sie k√∂nnen mit den grundlegenden Sprachkonstrukten erstellt werden, aber f√ºr den Synthesizer sind Direktiven erforderlich, damit sie sich nicht mit ihrer Konvertierung befassen).  Zusicherungen werden nur im SystemVerilog-Standard angezeigt und waren urspr√ºnglich auch im VHDL- und e-Sprachstandard enthalten. </p><br><p>  Ich schlage vor, dass Sie sich mit den Empfehlungen von Fachleuten vertraut machen, darunter Clifford Cummings [12, Artikel √ºber SVA] √ºber die Verbreitung von Werken zu deren Verfassen sowie Materialien zu ABV auf der Website der Verification Academy [13]. </p><br><h2 id="spisok-literatury">  Referenzliste </h2><br><ol><li>  IEEE Std 1800TM-2012.  IEEE-Standard f√ºr SystemVerilog - Einheitliche Hardware-Design-, Spezifikations- und Verifikationssprache </li><li>  Clive Maxfield.  FPGA-Design.  Architektur, Werkzeuge und Methoden.  Der Kurs des jungen K√§mpfers.  ISBN 978-5-94120-147-1 (RUS), ISBN 0-7506-7604-3 (ENG) </li><li>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Verification Academy.</a>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Abdeckungs-Kochbuch.</a>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Pro Testabdeckung</a> </li><li>  Michael Keating, Pierre Bricaud.  Handbuch zur Wiederverwendung von Methoden f√ºr System-on-a-Chip-Designs.  Druck ISBN 1-4020-7141-8, eBook ISBN 0-306-47640-1 </li><li>  <a href="https://en.wikipedia.org/wiki/List_of_HDL_simulators" rel="nofollow">Liste der lizenzierten und frei verteilten CAD</a> </li><li>  <a href="https://www.mentor.com/products/fv/resources/overview/trends-in-functional-verification-a-2016-industry-study-72f652de-b0a2-4c8e-97de-b1efbf457a36" rel="nofollow">Mentor Graphics.</a>  <a href="https://www.mentor.com/products/fv/resources/overview/trends-in-functional-verification-a-2016-industry-study-72f652de-b0a2-4c8e-97de-b1efbf457a36" rel="nofollow">Ein Beispiel f√ºr Statistiken zum aktuellen Status und zum Umfang der √úberpr√ºfung</a> </li><li>  <a href="https://en.wikichip.org/wiki/WikiChip" rel="nofollow">WikiChip.</a>  <a href="https://en.wikichip.org/wiki/WikiChip" rel="nofollow">Chips Wikipedia</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Transistor_count" rel="nofollow">Wikipedia</a>  <a href="https://en.wikipedia.org/wiki/Transistor_count" rel="nofollow">Verallgemeinerte Daten zur Anzahl der Transistoren im IC</a> </li><li>  Harry Foster, Adam Krolnik und David Lacey.  Durchsetzungsbasiertes Design. Druck-ISBN 1-4020-8027-1, eBook ISBN 1-4020-8028-X </li><li>  Stuart Sutherland, Simon Davidmann und Peter Flake.  SystemVerilog f√ºr Design.  Print ISBN-10: 0-387-33399-1, eBook ISBN-10: 0-387-36495-1 </li><li>  Chris Spear, Greg Tumbush.  SystemVerilog zur √úberpr√ºfung.  Print ISBN: 978-1-4614-0714-0, eBook ISBN: 978-1-4614-0715-7 </li><li>  <a href="http://www.sunburst-design.com/papers/" rel="nofollow">Sunburst Design.</a>  <a href="http://www.sunburst-design.com/papers/" rel="nofollow">Papiere</a> </li><li>  <a href="https://verificationacademy.com/courses/assertion-based-verification" rel="nofollow">Verification Academy.</a>  <a href="https://verificationacademy.com/courses/assertion-based-verification" rel="nofollow">ABV nat√ºrlich</a> </li><li>  <a href="https://www.doulos.com/" rel="nofollow">Doulos.</a>  <a href="https://www.doulos.com/" rel="nofollow">N√ºtzliche Online-Materialien und Nachschlagewerke</a> </li><li>  Prakash Rashinkar, Peter Paterson, Leena Singh.  System-on-a-Chip-√úberpr√ºfung.  Methodik und Techniken.  Print ISBN: 0-792-37279-4, eBook ISBN: 0-306-46995-2 </li><li>  <a href="https://verificationacademy.com/courses/metrics-soc-verification" rel="nofollow">Verification Academy.</a>  <a href="https://verificationacademy.com/courses/metrics-soc-verification" rel="nofollow">Metriken bei der SoC-√úberpr√ºfung</a> </li><li>  <a href="https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/" rel="nofollow">Doulos.</a>  <a href="https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/" rel="nofollow">Coverage-basierte Verifizierungsmethode</a> </li><li>  Doug Amos, Austin Lesea, Rene Richter.  Handbuch zur FPGA-basierten Prototyping-Methodik: Best Practices f√ºr Design-for-Prototyping (FPMM).  Druck-ISBN: 978-1617300042.  <a href="https://www.synopsys.com/company/resources/synopsys-press/fpga-based-prototyping-methodology-manual.html" rel="nofollow">Kostenloser Download von der Synopsys-Website</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481542/">https://habr.com/ru/post/de481542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481532/index.html">Memory Forensics, Rubber Duck und GPO-Passw√∂rter. Probleml√∂sung mit r0ot-mi. Teil 2</a></li>
<li><a href="../de481534/index.html">Stirbt Delphi - Falsch</a></li>
<li><a href="../de481536/index.html">Die Geschichte des Domain Name Systems: "Krieg" -Protokolle</a></li>
<li><a href="../de481538/index.html">20 SEO-Mythen, die 2020 sterben werden</a></li>
<li><a href="../de481540/index.html">OpenGLESv2-Texturen √ºber DMABUF neu laden</a></li>
<li><a href="../de481544/index.html">Verwenden eines neuronalen Faltungsnetzwerks zum Spielen von Life (auf Keras)</a></li>
<li><a href="../de481546/index.html">Die Geschichte des Mikroprozessors und des Personalcomputers: 1947-1974</a></li>
<li><a href="../de481548/index.html">Symbol.iterator in Javascript</a></li>
<li><a href="../de481550/index.html">Inmarsat: Empfang und Dekodierung eines Satellitensignals zu Hause</a></li>
<li><a href="../de481552/index.html">PGConf.Russia 2020 erscheint in K√ºrze</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>