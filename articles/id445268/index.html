<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖱️ 👩🏿‍⚕️ 🐘 Detail GraphQL: Apa, Bagaimana, dan Mengapa 👩‍👧 🚺 💿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL sekarang, tanpa berlebihan, ini adalah puncak terakhir dari IT-mode. Dan jika Anda belum tahu teknologi apa itu, bagaimana menggunakannya, dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detail GraphQL: Apa, Bagaimana, dan Mengapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445268/">  GraphQL sekarang, tanpa berlebihan, ini adalah puncak terakhir dari IT-mode.  Dan jika Anda belum tahu teknologi apa itu, bagaimana menggunakannya, dan mengapa itu mungkin berguna bagi Anda, maka artikel yang kami terbitkan hari ini ditulis untuk Anda.  Di sini kita akan membahas dasar-dasar GraphQL menggunakan contoh implementasi skema data untuk API perusahaan popcorn.  Secara khusus, mari kita bicara tentang tipe data, kueri, dan mutasi. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/c7/oq/a1/c7oqa1w2b00akzatd2womwb_daw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu GraphQL?</font> </h2><br>  GraphQL adalah bahasa permintaan yang digunakan oleh aplikasi klien untuk bekerja dengan data.  GraphQL dikaitkan dengan konsep seperti "skema" - inilah yang memungkinkan Anda untuk mengatur pembuatan, membaca, memperbarui, dan menghapus data dalam aplikasi Anda (yaitu, kami memiliki empat fungsi dasar yang digunakan saat bekerja dengan gudang data, yang biasanya disebut oleh akronim CRUD - buat, baca, perbarui, hapus). <br><br>  Dikatakan di atas bahwa GraphQL digunakan untuk bekerja dengan data dalam "aplikasi Anda", dan bukan "dalam database Anda".  Faktanya adalah bahwa GraphQL adalah sistem yang tidak tergantung pada sumber data, artinya, tidak masalah di mana ia diatur untuk mengatur pekerjaannya. <br><br>  Jika Anda melihat, tanpa mengetahui apa-apa tentang GraphQL, atas nama teknologi ini, mungkin kita dihadapkan pada sesuatu yang sangat rumit dan membingungkan.  Nama teknologinya bertuliskan "Grafik".  Apakah ini berarti bahwa untuk menguasainya, Anda harus belajar bekerja dengan basis data grafik?  Dan fakta bahwa namanya mengandung "QL" (yang dapat berarti "bahasa query", yaitu, "bahasa query"), apakah itu berarti bahwa mereka yang ingin menggunakan GraphQL harus mempelajari bahasa pemrograman yang sama sekali baru? <br><br>  Ketakutan ini tidak sepenuhnya dibenarkan.  Untuk meyakinkan Anda - ini adalah kebenaran yang kejam tentang teknologi ini: itu hanya dihiasi permintaan <code>GET</code> atau <code>POST</code> .  Sementara GraphQL, secara umum, memperkenalkan beberapa konsep baru yang terkait dengan organisasi data dan interaksi dengannya, mekanisme internal teknologi ini bergantung pada permintaan HTTP lama yang baik. <br><br><h2>  <font color="#3AC1EF">Memikirkan Kembali Teknologi REST</font> </h2><br>  Fleksibilitas adalah apa yang membedakan teknologi GraphQL dari teknologi REST yang terkenal.  Saat menggunakan REST, jika semuanya dilakukan dengan benar, titik akhir biasanya dibuat dengan mempertimbangkan karakteristik sumber daya atau tipe data aplikasi tertentu. <br><br>  Misalnya, saat melakukan permintaan <code>GET</code> ke rasa titik akhir <code>/api/v1/flavors</code> diharapkan akan mengirimkan respons yang terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">[ {  "id": 1,   "name": "The Lazy Person's Movie Theater",   "description": "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }, {   "id": 2,   "name": "What's Wrong With You Caramel",   "description": "You're a crazy person that likes sweet popcorn. Congratulations." }, {   "id": 3,   "name": "Gnarly Chili Lime",   "description": "The kind of popcorn you make when you need a good smack in the face."} ]</code> </pre> <br>  Tidak ada yang salah dengan jawaban ini, tetapi mari kita pikirkan tentang antarmuka pengguna, atau lebih tepatnya, bagaimana kami bermaksud untuk mengkonsumsi data ini. <br><br>  Jika kami ingin menampilkan daftar sederhana di antarmuka yang hanya berisi nama-nama jenis popcorn yang tersedia (dan tidak ada yang lain), maka daftar ini mungkin terlihat seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/0fd/c56/a890fdc56389815233584327e76011c1.png"></div><br>  <i><font color="#999999">Daftar Jenis Popcorn</font></i> <br><br>  Dapat dilihat bahwa di sini kita berada dalam situasi yang sulit.  Kami mungkin memutuskan untuk tidak menggunakan bidang <code>description</code> , tetapi apakah kami akan duduk dan berpura-pura bahwa kami tidak mengirimkan bidang ini ke klien?  Apa lagi yang bisa kita lakukan?  Dan ketika, setelah beberapa bulan, mereka akan bertanya kepada kami mengapa aplikasi ini sangat lambat bagi pengguna, kami hanya perlu membiarkan orang itu dan tidak lagi bertemu dengan manajemen perusahaan tempat kami membuat aplikasi ini. <br><br>  Faktanya, fakta bahwa server mengirim data yang tidak perlu sebagai tanggapan atas permintaan klien bukan sepenuhnya kesalahan kami.  REST adalah mekanisme akuisisi data yang dapat dibandingkan dengan restoran di mana pelayan bertanya kepada pengunjung: "Apa yang Anda inginkan?", Dan, tidak terlalu memperhatikan keinginannya, ia mengatakan kepadanya: "Aku akan membawakan apa yang kami miliki" . <br><br>  Jika kita membuang lelucon, maka dalam aplikasi nyata ini dapat menyebabkan situasi masalah.  Misalnya, kita dapat menampilkan berbagai informasi tambahan tentang setiap jenis popcorn, seperti informasi harga, informasi tentang produsen atau informasi nutrisi (“Popcorn Vegan!”).  Pada saat yang sama, titik akhir REST yang tidak fleksibel membuatnya sangat sulit untuk mendapatkan data spesifik tentang jenis popcorn tertentu, yang mengarah pada beban yang terlalu tinggi pada sistem dan pada kenyataan bahwa solusi yang dihasilkan jauh dari yang bisa dibanggakan oleh pengembang. <br><br><h2>  <font color="#3AC1EF">Bagaimana Teknologi GraphQL Meningkatkan Teknologi REST Digunakan Untuk Apa</font> </h2><br>  Analisis dangkal dari situasi yang dijelaskan di atas mungkin tampak bahwa kita hanya masalah kecil.  "Apa yang salah dengan mengirim data yang tidak perlu ke klien?"  Untuk memahami sejauh mana "data yang tidak perlu" bisa menjadi masalah besar, ingatlah bahwa GraphQL dikembangkan oleh Facebook.  Perusahaan ini harus melayani jutaan permintaan per detik. <br><br>  Apa artinya ini?  Dan fakta bahwa dengan volume seperti itu setiap hal kecil penting. <br><br>  GraphQL, jika kita melanjutkan analogi dengan restoran, alih-alih “membawa” ke pengunjung “apa adanya”, membawa persis apa yang dipesan pengunjung. <br><br>  Kita bisa mendapatkan respons dari GraphQL yang berfokus pada konteks di mana data digunakan.  Dalam hal ini, kita tidak perlu menambahkan titik akses "satu kali" ke sistem, melakukan banyak permintaan atau menulis struktur bersyarat bertingkat. <br><br><h2>  <font color="#3AC1EF">Bagaimana cara kerja GraphQL?</font> </h2><br>  Seperti yang telah kami katakan, GraphQL bergantung pada permintaan <code>GET</code> atau <code>POST</code> sederhana untuk mengirimkan data ke klien dan menerimanya dari itu.  Jika kami mempertimbangkan ide ini lebih terinci, ternyata ada dua jenis kueri di GraphQL.  Tipe pertama termasuk permintaan untuk membaca data, yang dalam terminologi GraphQL hanya disebut kueri dan merujuk ke huruf R (membaca, membaca) dari akronim CRUD.  Permintaan jenis kedua adalah permintaan modifikasi data, yang disebut mutasi dalam GraphQL.  Mereka berhubungan dengan kotak as roda C, U, dan D dari akronim CRUD, yaitu, mereka menggunakannya untuk membuat, membuat, memperbarui, dan menghapus catatan. <br><br>  Semua pertanyaan dan mutasi ini dikirim ke URL server GraphQL, yang, misalnya, mungkin terlihat seperti <code>https://myapp.com/graphql</code> , dalam bentuk <code>GET</code> atau permintaan <code>POST</code> .  Kami akan berbicara lebih banyak tentang ini di bawah ini. <br><br><h2>  <font color="#3AC1EF">Permintaan GraphQL</font> </h2><br>  Kueri GraphQL adalah entitas yang mewakili permintaan ke server untuk menerima data tertentu.  Misalnya, kami memiliki antarmuka pengguna tertentu yang ingin kami isi dengan data.  Untuk data ini, kami beralih ke server, menjalankan permintaan.  Saat menggunakan API REST tradisional, permintaan kami berbentuk permintaan GET.  Saat bekerja dengan GraphQL, sintaks kueri baru digunakan: <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Apakah itu JSON?  Atau objek JavaScript?  Tidak satu atau yang lain.  Seperti yang telah kita katakan, atas nama teknologi GraphQL, dua huruf terakhir, QL, berarti "bahasa query", yaitu, bahasa query.  Ini, secara harfiah, bahasa baru untuk menulis permintaan data.  Semua ini terdengar seperti deskripsi sesuatu yang agak rumit, tetapi sebenarnya tidak ada yang rumit di sini.  Mari kita menganalisis permintaan di atas: <br><br><pre> <code class="plaintext hljs">{ //    ,   . }</code> </pre> <br>  Semua permintaan dimulai dengan "permintaan root", dan apa yang Anda butuhkan selama eksekusi permintaan disebut bidang.  Untuk menyelamatkan diri dari kebingungan, yang terbaik adalah menyebut entitas ini "bidang kueri dalam skema."  Jika nama seperti itu tampaknya tidak dapat dipahami oleh Anda - tunggu sebentar - di bawah ini kami akan berbicara lebih banyak tentang skema tersebut.  Di sini kita, dalam permintaan root, meminta bidang <code>flavors</code> . <br><br><pre> <code class="plaintext hljs">{ flavors {   //  ,        flavor. } }</code> </pre> <br>  Saat meminta bidang tertentu, kami juga harus menunjukkan bidang bersarang yang harus diterima untuk setiap objek yang menanggapi permintaan (bahkan jika diharapkan hanya satu objek yang akan menanggapi permintaan). <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Apa hasilnya?  Setelah kami mengirim permintaan seperti itu ke server GraphQL, kami akan mendapatkan jawaban yang rapi seperti berikut: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "name": "The Lazy Person's Movie Theater" },     { "name": "What's Wrong With You Caramel" },     { "name": "Gnarly Chili Lime" }   ] } }</code> </pre> <br>  Harap dicatat bahwa tidak ada yang berlebihan.  Untuk membuatnya lebih jelas, berikut ini adalah permintaan lain yang dijalankan untuk mendapatkan data pada halaman lain dari aplikasi: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   description } }</code> </pre> <br>  Menanggapi permintaan ini, kami mendapatkan yang berikut: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" },     { "id": 2, "name": "What's Wrong With You Caramel", description: "You're a crazy person that likes sweet popcorn. Congratulations." },     { "id": 3, "name": "Gnarly Chili Lime", description: "A friend told me this would taste good. It didn't. It burned my kernels. I haven't had the heart to tell him." }   ] } }</code> </pre> <br>  Seperti yang Anda lihat, GraphQL adalah teknologi yang sangat kuat.  Kami beralih ke titik akhir yang sama, dan jawaban atas permintaan tepat sesuai dengan apa yang diperlukan untuk mengisi halaman dari mana permintaan ini dieksekusi. <br><br>  Jika kita hanya perlu mendapatkan satu objek <code>flavor</code> , maka kita dapat memanfaatkan fakta bahwa GraphQL dapat bekerja dengan argumen: <br><br><pre> <code class="plaintext hljs">{ flavors(id: "1") {   id   name   description } }</code> </pre> <br>  Di sini kita secara kaku mengatur pengidentifikasi spesifik ( <code>id</code> ) objek dalam kode, informasi yang kita butuhkan, tetapi dalam kasus seperti itu kita dapat menggunakan pengidentifikasi dinamis: <br><br><pre> <code class="plaintext hljs">query getFlavor($id: ID) { flavors(id: $id) {   id   name   description } }</code> </pre> <br>  Di sini, di baris pertama, kami memberikan nama permintaan (nama dipilih secara sewenang-wenang, <code>getFlavor</code> dapat diganti dengan sesuatu seperti <code>pizza</code> , dan permintaan akan tetap operasional) dan mendeklarasikan variabel yang diharapkan oleh permintaan.  Dalam hal ini, diasumsikan bahwa pengidentifikasi ( <code>id</code> ) dari tipe skalar <code>ID</code> akan diteruskan ke permintaan (kita akan berbicara tentang jenis di bawah). <br><br>  Terlepas dari apakah <code>id</code> statis atau dinamis digunakan saat mengeksekusi permintaan, berikut adalah respons terhadap permintaan serupa: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }   ] } }</code> </pre> <br>  Seperti yang Anda lihat, semuanya diatur dengan sangat nyaman.  Anda mungkin mulai berpikir untuk menggunakan GraphQL di proyek Anda sendiri.  Dan, meskipun apa yang telah kita bicarakan terlihat luar biasa, keindahan GraphQL benar-benar memanifestasikan dirinya di mana ia bekerja dengan bidang bersarang.  Misalkan dalam skema kami ada bidang lain yang disebut <code>nutrition</code> yang berisi informasi tentang nilai gizi berbagai jenis popcorn: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories     fat     sodium   } } }</code> </pre> <br>  Tampaknya di gudang data kami, setiap objek <code>flavor</code> akan berisi objek <code>nutrition</code> bersarang.  Tetapi ini tidak sepenuhnya benar.  Menggunakan GraphQL, Anda dapat menggabungkan panggilan ke sumber data yang independen, tetapi terkoneksi dalam satu kueri, yang memungkinkan Anda untuk mendapatkan jawaban yang memberikan kemudahan bekerja dengan data yang disematkan tanpa perlu mendenormalkan basis data: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     {       "id": 1,       "name": "The Lazy Person's Movie Theater",       "nutrition": {         "calories": 500,         "fat": 12,         "sodium": 1000       }     },     ...   ] } }</code> </pre> <br>  Ini secara signifikan dapat meningkatkan produktivitas programmer dan kecepatan sistem. <br><br>  Sejauh ini, kami telah berbicara tentang permintaan baca.  Bagaimana dengan permintaan pembaruan data?  Apakah menggunakan mereka memberi kita kenyamanan yang sama? <br><br><h2>  <font color="#3AC1EF">Mutasi GraphQL</font> </h2><br>  Sementara GraphQL kueri memuat data, mutasi bertanggung jawab untuk membuat perubahan pada data.  Mutasi dapat digunakan dalam bentuk mekanisme RPC (Remote Procedure Call) dasar untuk menyelesaikan berbagai tugas, seperti mengirim data pengguna ke API pihak ketiga. <br><br>  Saat menjelaskan mutasi, sintaks digunakan yang menyerupai yang kami gunakan saat membuat kueri: <br><br><pre> <code class="plaintext hljs">mutation updateFlavor($id: ID!, $name: String, $description: String) { updateFlavor(id: $id, name: $name, description: $description) {   id   name   description } }</code> </pre> <br>  Di sini kami mendeklarasikan mutasi <code>updateFlavor</code> , menetapkan beberapa variabel - <code>id</code> , <code>name</code> dan <code>description</code> .  Bertindak sesuai dengan skema yang sama yang digunakan untuk menggambarkan kueri, kami “menyusun” bidang variabel (mutasi root) menggunakan kata kunci <code>mutation</code> , diikuti dengan nama yang menggambarkan mutasi, dan satu set variabel yang diperlukan untuk membentuk permintaan perubahan data yang sesuai. <br><br>  Variabel-variabel ini termasuk apa yang kita coba ubah, atau mutasi apa yang ingin kita sebabkan.  Harap perhatikan juga bahwa setelah mutasi, kami dapat meminta pengembalian beberapa bidang. <br><br>  Dalam hal ini, kita perlu mendapatkan, setelah mengubah catatan, bidang <code>id</code> , <code>name</code> dan <code>description</code> .  Ini bisa berguna ketika mengembangkan sesuatu seperti antarmuka optimis, menghilangkan kebutuhan untuk memenuhi permintaan untuk menerima data yang diubah setelah mengubahnya. <br><br><h2>  <font color="#3AC1EF">Merancang skema dan menghubungkannya ke server GraphQL</font> </h2><br>  Sejauh ini, kami telah berbicara tentang cara kerja GraphQL pada klien, dan bagaimana mereka mengeksekusi query.  Sekarang mari kita bicara tentang bagaimana menanggapi permintaan ini. <br><br><h3>  <font color="#3AC1EF">Server raphGraphQL</font> </h3><br>  Untuk menjalankan kueri GraphQL, Anda memerlukan server GraphQL tempat Anda dapat mengirim kueri tersebut.  Server GraphQL adalah server HTTP biasa (jika Anda menulis dalam JavaScript, ini bisa berupa server yang dibuat menggunakan Express atau Hapi), yang melampirkan diagram GraphQL. <br><br><pre> <code class="plaintext hljs">import express from 'express' import graphqlHTTP from 'express-graphql' import schema from './schema' const app = express() app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true })) app.listen(4000)</code> </pre> <br>  Dengan "bergabung" dalam suatu skema, kami maksudkan suatu mekanisme yang meneruskan permintaan yang diterima dari klien melalui skema tersebut dan mengembalikan jawaban untuknya.  Itu seperti sebuah saringan udara yang melaluinya udara memasuki ruangan. <br><br>  Proses "penyaringan" dikaitkan dengan permintaan atau mutasi yang dikirim oleh klien ke server.  Kueri dan mutasi diselesaikan dengan menggunakan fungsi yang terkait dengan bidang yang ditentukan dalam kueri root atau dalam mutasi akar skema. <br><br>  Di atas adalah contoh kerangka kerja server HTTP yang dibuat menggunakan perpustakaan JavaScript Express.  Menggunakan fungsi <code>graphqlHTTP</code> dari paket <code>express-graphql</code> dari Facebook, kami "melampirkan" skema (diasumsikan bahwa itu dijelaskan dalam file terpisah) dan menjalankan server pada port 4000. Artinya, klien, berbicara tentang penggunaan lokal server ini, akan dapat mengirim permintaan melalui alamat <code>http://localhost:4000/graphql</code> . <br><br><h3>  <font color="#3AC1EF">▍ Jenis data dan penyelesai</font> </h3><br>  Untuk memastikan pengoperasian server GraphQL, Anda harus menyiapkan skema dan melampirkannya. <br><br>  Ingatlah bahwa kami berbicara tentang mendeklarasikan bidang dalam kueri root atau dalam mutasi root di atas. <br><br><pre> <code class="plaintext hljs">import gql from 'graphql-tag' import mongodb from '/path/to/mongodb' //  -  . ,  `mongodb`     MongoDB. const schema = { typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     id: ID     name: String     description: String     nutrition: Nutrition   }   type Query {     flavors(id: ID): [Flavor]   }   type Mutation {     updateFlavor(id: ID!, name: String, description: String): Flavor   } `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {       // ,  args  ,  { id: '1' }       return mongodb.collection('flavors').find(args).toArray()     },   },   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(args)       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   },   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, }, } export default schema</code> </pre> <br>  Definisi bidang dalam skema GraphQL terdiri dari dua bagian - dari deklarasi tipe ( <code>typeDefs</code> ) dan <code>resolver</code> .  <code>typeDefs</code> berisi deklarasi tipe untuk data yang digunakan dalam aplikasi.  Sebagai contoh, sebelumnya kita berbicara tentang permintaan untuk mendapatkan daftar objek <code>flavor</code> dari server.  Untuk membuat permintaan serupa ke server kami, Anda perlu melakukan tiga langkah berikut: <br><br><ol><li>  Beri tahu skema bagaimana data objek <code>flavor</code> terlihat (dalam contoh di atas, ini terlihat seperti iklan <code>type Flavor</code> ). </li><li>  Deklarasikan bidang di bidang akar <code>type Query</code> (ini adalah properti <code>flavors</code> dari nilai <code>type Query</code> ). </li><li>  Menyatakan <code>resolvers.Query</code> Fungsi pengenal objek <code>type Query</code> ditulis sesuai dengan bidang yang dideklarasikan di bidang akar <code>type Query</code> . </li></ol><br>  Sekarang mari kita perhatikan <code>typeDefs</code> .  Di sini kami memberikan informasi skema tentang bentuk data kami.  Dengan kata lain, kami memberi tahu GraphQL tentang berbagai properti yang mungkin terkandung dalam entitas dari tipe yang sesuai. <br><br><pre> <code class="plaintext hljs">type Flavor { id: ID name: String description: String nutrition: Nutrition }</code> </pre> <br>  Deklarasi <code>type Flavor</code> menunjukkan bahwa objek <code>flavor</code> dapat berisi bidang <code>id</code> dari <code>ID</code> tipe, bidang <code>name</code> <code>String</code> tipe, bidang <code>description</code> tipe <code>String</code> dan bidang <code>nutrition</code> tipe <code>Nutrition</code> . <br><br>  Dalam hal <code>nutrition</code> kami menggunakan di sini nama dari tipe berbeda yang dideklarasikan di <code>typeDefs</code> .  Di sini, <code>type Nutrition</code> membangun menggambarkan bentuk data gizi popcorn. <br><br>  Perhatikan fakta bahwa di sini, seperti pada awal materi ini, kita berbicara tentang "aplikasi" dan bukan tentang "database".  Dalam contoh di atas, diasumsikan bahwa kita memiliki database, tetapi data dalam aplikasi dapat berasal dari sumber apa pun.  Bahkan bisa berupa API pihak ketiga atau file statis. <br><br>  Sama seperti yang kami lakukan pada deklarasi <code>type Flavor</code> , di sini kami menentukan nama bidang yang akan terkandung dalam objek <code>nutrition</code> , menggunakan, sebagai tipe data bidang ini (properti), apa yang di GraphQL disebut tipe data skalar.  Pada saat penulisan ini, GraphQL mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5 tipe data skalar</a> bawaan: <br><br><ul><li>  <code>Int</code> : menandatangani integer 32-bit. </li><li>  <code>Float</code> : angka floating-point presisi ganda dengan tanda. </li><li>  <code>String</code> : urutan karakter yang dikodekan dalam UTF-8. </li><li>  <code>Boolean</code> : Boolean <code>true</code> atau <code>false</code> . </li><li>  <code>ID</code> : pengidentifikasi unik yang sering digunakan untuk memuat objek berulang kali atau sebagai kunci dalam cache.  Nilai <code>ID</code> tipe diserialisasi dengan cara yang sama dengan string, namun, indikasi bahwa tipe <code>ID</code> memiliki nilai ditekankan oleh fakta bahwa nilai ini tidak dimaksudkan untuk ditampilkan kepada orang-orang, tetapi untuk digunakan dalam program. </li></ul><br>  Selain tipe skalar ini, kami juga dapat menetapkan properti untuk tipe yang kami tentukan sendiri.  Inilah yang kami lakukan dengan menetapkan properti <code>nutrition</code> dijelaskan dalam <code>type Flavor</code> , tipe <code>Nutrition</code> . <br><br><pre> <code class="plaintext hljs">type Query { flavors(id: ID): [Flavor] }</code> </pre> <br>  Di konstruk <code>type Query</code> , yang menjelaskan tipe akar <code>Query</code> ("kueri root" yang telah kita bicarakan sebelumnya), kami menyatakan nama bidang yang bisa diminta.  Dengan mendeklarasikan bidang ini, kami, di samping itu, bersama dengan tipe data yang kami harapkan untuk kembali, tentukan argumen yang mungkin datang dalam permintaan. <br><br>  Dalam contoh ini, kami mengharapkan kemungkinan penerimaan argumen <code>id</code> dari <code>ID</code> tipe skalar.  Menanggapi permintaan seperti itu, sebuah array objek diharapkan perangkat yang menyerupai perangkat tipe <code>Flavor</code> . <br><br><h3>  <font color="#3AC1EF">▍Menghubungkan pengenal query</font> </h3><br> ,    <code>type Query</code>    <code>field</code> ,    ,   -. <br><br>  —  ,  GraphQL,   , «».      <code>resolvers</code> ,     <code>Query</code> ,   ,      <code>flavors</code> ,   .        <code>flavors</code> ,     <code>type Query</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`…`, resolvers: { Query: {   flavors: (parent, args) =&gt; {     // ,  args    { id: '1' }     return mongodb.collection('flavors').find(args).toArray()   }, }, … },</code> </pre> <br>  -   .  <code>parent</code> —   ,   ,  <code>args</code>      ,   .      <code>context</code> ,      .       «»  ( —        ,       ). <br><br>     ,    ,   .   GraphQL « »          . , ,      . <br><br>  GraphQL      ,      ,    .    JSON-,  JSON-,  (  GraphQL   ). <br><br>    -   <code>flavors</code>   MongoDB,  <code>args</code> (    )   <code>.find()</code>   ,        ,   . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>     -,   GraphQL,  , ,   ,      <code>nutrition</code> .   ,  ,   <code>Nutrition</code> , ,   ,      ,   <code>flavor</code> .      ,       /  . <br><br>    GraphQL  ,  <code>type Flavor</code>      <code>nutrition</code>   <code>type Nutrition</code> ,          .  ,    ,      <code>flavor</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     […]     nutrition: Nutrition   }   type Query {…}   type Mutation {…} `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {…},   },   Mutation: {…},   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, },</code> </pre> <br>      <code>resolvers</code>  ,   ,      <code>Query</code> , <code>Mutation</code>  <code>Flavor</code> .   ,      <code>typeDefs</code> . <br><br>     <code>Flavors</code> ,  ,   <code>nutrition</code>     -.       ,        <code>Flavor</code> .  ,   : « ,     <code>nutrition</code>     ,  <code>type Flavor</code> ». <br><br>         MongoDB,      ,     <code>parent</code> ,  -. ,     <code>parent</code> ,   ,    ,   <code>flavors</code> . ,      <code>flavor</code> ,    : <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories   } } }</code> </pre> <br>   <code>flavor</code> ,   <code>flavors</code> ,     <code>nutrition</code> ,        <code>parent</code> .     ,  ,  ,    MongoDB,   <code>parent.id</code> ,    <code>id</code>  <code>flavor</code> ,       . <br><br>  <code>parent.id</code>      ,     <code>nutrition</code>   <code>flavorId</code> ,     <code>flavor</code> . <br><br><h3> <font color="#3AC1EF">▍ </font> </h3><br> ,      ,     .   ,          .      <code>type Mutation</code> ,   ,       <code>updateFlavor</code> ,  ,   . <br><br><pre> <code class="plaintext hljs">type Mutation { updateFlavor(id: ID!, name: String, description: String): Flavor }</code> </pre> <br>     : « ,   <code>updateFlavor</code>  <code>id</code>  <code>ID</code> ( , <code>!</code> ,  GraphQL  ,    ), <code>name</code>  <code>String</code>  <code>description</code>  <code>String</code> ».  ,         ,     <code>Flavor</code> (  — ,    <code>id</code> , <code>name</code> , <code>description</code> , , , <code>nutrition</code> ). <br><br><pre> <code class="plaintext hljs">{ typeDefs: gql`…`, resolvers: {   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(         { id: args.id },         {           $set: {             ...args,           },         },       )       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   }, }, }</code> </pre> <br>  -   <code>updateFlavor</code>    ,      :       ,    ,   — ,      <code>flavor</code> . <br><br>    ,               ,       <code>flavor</code>     .   ? <br><br>   ,          ,        .     ,     <code>flavor</code> ,     . <br><br>      <code>args</code> ? , . ,          ,   ,      100%   ,         .       ,    ,  ,     ,      ,    . <br><br><h2> <font color="#3AC1EF">    GraphQL?</font> </h2><br>  ,      ,    ,     ,   , GraphQL-API. <br><br>        ,     GraphQL      ,      .  ,         .        ,    .  , ,   ,   GraphQL      REST      .  ,   ,           ,     GraphQL. <br><br><h3> <font color="#3AC1EF">▍    ,   </font> </h3><br>     ,       HTTP-,  ,      ,   ,   —  .       GraphQL       ,  ,    ,     ,     (            ). <br><br>        ,  ,     ( —         ),  GraphQL      . <br><br><h3> <font color="#3AC1EF">▍    ,    ,       </font> </h3><br>  ,       ,    « ».      , ,   ,   .        .   GraphQL         . <br><br><h3> <font color="#3AC1EF">▍     ,       </font> </h3><br>          REST API,          :  ,    . ,      -,   iOS  Android,   API  .    ,  , ,   , «   »    . <br><br>    ,   ,   ,   HTTP,              API (, ,   ). <br><br><h3> <font color="#3AC1EF">▍   GraphQL —   ?        REST API    GraphQL?</font> </h3><br> , .   . ,  ,   GraphQL     .       GraphQL,     .       ,      ,      ,           .     ,      ,     . <br><br> ,  GraphQL  ,  ,      ,  .    GraphQL    ,      Apollo  Relay,       . <br><br> GraphQL — ,  ,   .   <code>graphql</code> (     <code>express-graphql</code> ,    ) —      .  ,   GraphQL      -  .      ,     -,   ,  ,     ,    . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>   ,   GraphQL    ,           . GraphQL      ,    , ,  .  , ,       ,        ,       GraphQL. <br><br> ,       : GraphQL   .              GraphQL  . ,     GraphQL,      ,  , ,  ,  ,  ,  . <br><br>  —   ,  GraphQL — ,   ,   .  GraphQL       ,   .    ,  GraphQL —  ,  , ,  .           .  ,       ,      ,   ,     ,      ,      GraphQL. <br><br>  <b>Pembaca yang budiman!</b>        GraphQL —     ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445268/">https://habr.com/ru/post/id445268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445258/index.html">Cara menghapus data Anda dengan aman dari ponsel cerdas Android Anda sebelum menjualnya</a></li>
<li><a href="../id445260/index.html">Akankah robot benar-benar mengenali diri mereka sendiri? Para ilmuwan bergerak ke arah ini.</a></li>
<li><a href="../id445262/index.html">GeekUniversity Membuka Rekrutmen di Big Data Department of Analytics</a></li>
<li><a href="../id445264/index.html">Pra-muat, prefetch, dan tag lainnya</a></li>
<li><a href="../id445266/index.html">GeekBrains bersama dengan Rostelecom akan melakukan IoT Hackathon</a></li>
<li><a href="../id445270/index.html">[bookmark] Bash untuk pemula: 21 perintah yang berguna</a></li>
<li><a href="../id445272/index.html">JavaScript adalah bahasa pemrograman terbaik untuk pemula. Jadi atau tidak?</a></li>
<li><a href="../id445274/index.html">Ketika "Zoë"! == "Zoë", atau mengapa Anda perlu menormalkan string Unicode</a></li>
<li><a href="../id445276/index.html">Panduan UseEffect Lengkap</a></li>
<li><a href="../id445278/index.html">Cara membuat game jika Anda tidak pernah seorang artis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>