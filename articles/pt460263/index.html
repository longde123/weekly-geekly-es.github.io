<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅿️ 👩🏻‍🚒 ☝🏾 Fazendo uma pesquisa realmente inteligente: guia passo a passo 👂🏼 👅 👆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pesquise no sistema de informações corporativas - já a partir dessa frase, ela fica presa na boca. É bom que você tenha uma, nem precisa pensar em uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazendo uma pesquisa realmente inteligente: guia passo a passo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>Pesquise no sistema de informações corporativas</em> - já a partir dessa frase, ela fica presa na boca.  É bom que você tenha uma, nem precisa pensar em uma experiência positiva do usuário.  Como reverter a atitude dos usuários estragados pelos mecanismos de pesquisa e criar um produto rápido, preciso e perfeitamente compreensível?  Precisamos pegar uma boa parte do Elasticsearch, um punhado de serviços inteligentes e amassá-los neste guia. </p><br><p>  Existem muitos artigos sobre como fixar a pesquisa de texto completo com base no Elasticsearch no banco de dados existente.  Mas claramente não há artigos suficientes sobre como fazer uma pesquisa realmente inteligente. </p><br><blockquote>  Ao mesmo tempo, a frase "Pesquisa Inteligente" já se transformou em um chavão e é usada para o local e não.  Então, o que um mecanismo de pesquisa deve fazer para ser considerado inteligente?  Por fim, isso pode ser descrito como fornecendo o resultado que o usuário realmente precisa, mesmo que esse resultado não corresponda exatamente ao texto da solicitação.  Mecanismos de pesquisa populares como Google e Yandex vão além e não apenas encontram as informações necessárias, mas respondem diretamente às perguntas dos usuários. </blockquote><p>  Ok, não tomaremos uma decisão de ultimato imediatamente, mas o que pode ser feito para aproximar uma pesquisa de texto completo <em>regular de</em> uma pesquisa <em>inteligente</em> ? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Elementos de inteligência </h2><br><p>  Pesquisa inteligente - este é apenas o caso em que a quantidade pode ter qualidade e muitos recursos pequenos e bastante simples podem formar uma sensação de mágica. </p><br><ul><li>  Correção de erros do usuário - se é um erro de digitação, um layout incorreto ou talvez uma solicitação com um número suspeito de resultados, mas semelhante a uma solicitação para a qual há muito mais informações. </li><li>  Para <del>  th </del>  Bate-papos de PNL (processamento de linguagem natural, não o que você pensou) - se o usuário inseriu <em><strong>ofertas comerciais no último ano</strong></em> , ele realmente queria procurar essas palavras no texto de todos os documentos ou realmente precisava apenas de ofertas comerciais e somente no ano passado ? </li><li>  Preveja entrada com base em consultas anteriores ou documentos populares. </li><li> A apresentação do resultado é o destaque usual do fragmento encontrado, informações adicionais dependendo do que você estava procurando.  Como as propostas comerciais eram necessárias no parágrafo anterior, talvez faça sentido mostrar imediatamente o assunto da proposta e de qual organização ela veio? </li><li>  Pesquisa detalhada - a capacidade de refinar a consulta de pesquisa usando filtros e facetas adicionais. </li></ul><br><h2 id="vvodnaya">  Introdutório </h2><br><p>  Há um ECM DIRECTUM com muitos documentos.  O documento consiste em um cartão com meta-informação e um corpo, que pode ter várias versões. </p><br><p>  O objetivo é procurar rápida e convenientemente informações nesses documentos da maneira usual para um usuário de mecanismos de pesquisa. </p><br><h2 id="indeksirovanie">  Indexação </h2><br><blockquote>  Para procurar algo bem, você precisa indexá-lo bem primeiro. </blockquote><p>  Os documentos no ECM não são estáticos, os usuários modificam o texto, criam novas versões, alteram os dados nos cartões;  novos documentos são constantemente criados e os antigos são excluídos. <br>  Para manter as informações atualizadas no Elasticsearch, os documentos precisam ser constantemente reindexados.  Felizmente, o ECM já possui sua própria fila de eventos assíncronos; portanto, quando você altera um documento, basta adicioná-lo à fila para indexação. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Mapeando documentos ECM para documentos Elasticsearch </h3><br><p>  Um corpo do documento no ECM pode ter várias versões.  No Elasticsearch, isso pode ser pensado como uma matriz de objetos aninhados, mas torna-se inconveniente trabalhar com eles - fica mais difícil escrever consultas, ao alterar uma das versões, você precisa reindexar tudo, versões diferentes do mesmo documento não podem ser armazenadas em índices diferentes (por que isso pode ser necessário - na próxima seção).  Portanto, desnormalizamos um documento do ECM em vários documentos do Elasticsearch com o mesmo cartão, mas com corpos diferentes. </p><br><p>  Além do cartão e do corpo, várias informações de serviço são adicionadas ao documento Elasticsearch, que vale a pena mencionar separadamente: </p><br><ul><li>  uma lista de IDs de grupos e usuários que têm direitos sobre o documento - para pesquisas com direitos; </li><li>  o número de chamadas para o documento - para ajustar a relevância; </li><li>  hora da última indexação. </li></ul><br><h3 id="sostav-indeksov">  Composição do Índice </h3><br><p>  Sim, índices plurais.  Geralmente, vários índices para armazenar informações com significado semelhante no Elasticsearch são usados ​​apenas se essas informações forem imutáveis ​​e vinculadas a algum tipo de período de tempo, por exemplo, logs.  Em seguida, os índices são criados todos os meses / dia ou mais frequentemente, dependendo da intensidade da carga.  No nosso caso, qualquer documento pode ser alterado, e seria possível armazenar tudo em um índice. </p><br><p>  Mas - os documentos no sistema podem estar em diferentes idiomas, e o armazenamento de dados multilíngues no Elasticsearch traz 2 problemas: </p><br><ul><li>  Stemming errado.  Para algumas palavras, a base será encontrada corretamente, para algumas - incorretamente (haverá outra palavra no índice), para algumas - não será encontrada (o índice ficará entupido com as formas de palavras).  Para algumas palavras de idiomas diferentes e com significados diferentes, a base será a mesma e, em seguida, o significado da palavra será perdido.  O uso de várias hastes consecutivas pode levar a um cálculo adicional da base para uma já calculada. </li></ul><br><blockquote>  Stamming - encontrar a base da palavra.  O caule não precisa ser a raiz da palavra ou sua forma normal.  Geralmente, basta que as palavras relacionadas sejam projetadas em uma estrutura. <br>  A lematização é um tipo de derivação em que a forma normal (vocabulário) de uma palavra é considerada a base. </blockquote><br><ul><li>  Frequência incorreta de palavras.  Alguns mecanismos de determinação de relevância no ES levam em consideração a frequência das palavras pesquisadas no documento (quanto mais frequentemente, maior a relevância) e a frequência das palavras pesquisadas no índice (quanto mais frequentemente, menor a relevância).  Portanto, uma pequena disseminação da fala russa em um documento em inglês, quando os documentos em inglês estiverem predominantemente no índice, terá alto peso, mas vale a pena misturar os documentos em inglês e russo no índice, e o peso diminuirá. </li></ul><br><p>  O primeiro problema pode ser resolvido para o caso em que idiomas diferentes usam conjuntos de caracteres diferentes (documentos em russo-inglês usam letras cirílicas e latinas) - os tradutores de idiomas processam apenas "seus" caracteres. </p><br><p>  Apenas para resolver o segundo problema, usamos a abordagem com um índice separado para cada idioma. </p><br><p>  Combinando as duas abordagens, obtemos índices de idiomas, que contêm analisadores para vários idiomas que não se cruzam em conjuntos de caracteres: russo-inglês (e separadamente inglês-russo), polonês-russo, alemão-russo, ucraniano-inglês etc. . </p><br><p>  Para não criar antecipadamente todos os índices possíveis, usamos modelos de índice - o Elasticsearch permite especificar um modelo que contém configurações e mapeamentos e especificar um padrão de nome de índice.  Quando você tenta indexar um documento em um índice inexistente, cujo nome corresponde a um dos padrões do modelo, não apenas um novo índice será criado, mas as configurações e os mapeamentos do modelo correspondente serão aplicados a ele. </p><br><h3 id="struktura-indeksov">  Estrutura do índice </h3><br><p>  Para indexação, usamos dois analisadores de uma só vez (por vários campos): padrão para pesquisar por frase exata e personalizado para todo o resto: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  Com o filtro em minúsculas, tudo fica claro, vou falar sobre o resto. </p><br><p>  Os filtros russian_morphology e english_morphology destinam-se à análise morfológica do texto em russo e em inglês, respectivamente.  Eles não fazem parte do Elasticsearch e são incluídos como parte de um plug-in de análise-morfologia separado.  Estes são lematizadores que usam a abordagem de vocabulário em combinação com algumas heurísticas e funcionam significativamente MUITO, melhor do que os filtros internos para os idiomas correspondentes. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  E: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Filtro word_delimiter muito curioso.  Por exemplo, ajuda a eliminar erros de digitação quando não há espaço após o ponto.  Usamos a seguinte configuração: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  O yo_filter permite ignorar a diferença entre E e E: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  tipo de filtro ru_en_stopwords stop - nosso dicionário de palavras stop. </p><br><h3 id="process-indeksirovaniya">  Processo de indexação </h3><br><p>  Os corpos dos documentos no ECM são, em regra, arquivos de formatos de escritório: .docx, .pdf, etc.  Para extrair o texto, o plug-in de inserção de anexo é usado com o seguinte pipeline: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  Do incomum no pipeline, ignorar erros da ausência do corpo (isso acontece para documentos criptografados) e determinar o índice de destino com base no idioma do texto.  O último é feito em um roteiro indolor, cujo corpo darei separadamente, porque  devido a restrições JSON, ele deve ser gravado em uma linha.  Juntamente com dificuldades de depuração (a maneira recomendada é lançar exceções aqui e ali), ela se torna completamente dolorosa. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Assim, sempre enviamos o documento para <em>index_name</em> .  Se o idioma não estiver definido ou não for suportado, o documento será estabelecido nesse índice, caso contrário, ele se enquadra no <em>index_name_language</em> . </p><br><p>  Não armazenamos o corpo original do arquivo, mas o campo _source está ativado, porque  é necessário atualizar parcialmente o documento e destacar o encontrado. </p><br><p>  Se apenas o cartão foi alterado desde a última indexação, usamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API Atualizar por consulta</a> sem pipeline para atualizá-lo.  Isso permite, em primeiro lugar, não extrair corpos de documentos potencialmente pesados ​​do ECM e, em segundo lugar, acelera significativamente a atualização no lado do Elasticsearch - você não precisa extrair o texto dos documentos dos formatos de escritório, o que consome muitos recursos. </p><br><blockquote>  Como tal, não há nenhuma atualização do documento no Elasticsearch, tecnicamente, ao atualizar a partir do índice, o documento antigo é retirado, alterado e completamente indexado novamente. </blockquote><p>  Mas se o corpo foi alterado, o documento antigo geralmente é excluído e indexado do zero.  Isso permite que os documentos sejam <em>movidos</em> de um índice de idioma para outro. </p><br><h2 id="poisk">  Pesquisar </h2><br><p>  Para facilitar a descrição, darei uma captura de tela do resultado final </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Texto completo </h3><br><p>  O principal tipo de consulta que temos é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Query Simple Query String Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  onde <em>.exact</em> são os campos indexados pelo analisador <em>padrão</em> .  A importância do nome do documento é duas vezes maior que o restante dos campos.  A combinação de <code>"default_operator": "or"</code> e <code>"minimum_should_match": "-35%"</code> permite encontrar documentos que não contêm até 35% das palavras pesquisadas. </p><br><h3 id="sinonimy">  Sinônimos </h3><br><p>  Em geral, diferentes analisadores são usados ​​para indexação e pesquisa, mas a única diferença neles é a adição de um filtro para adicionar sinônimos à consulta de pesquisa: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Direitos contábeis </h3><br><p>  Para pesquisas baseadas em direitos, a consulta principal é incorporada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consulta Bool</a> , com a adição de um filtro: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  Como lembramos da seção sobre indexação, o índice possui um campo com o ID de usuários e grupos que têm direitos sobre o documento.  Se houver uma interseção desse campo com a matriz passada, haverá direitos. </p><br><h3 id="tyuning-relevantnosti">  Ajuste de Relevância </h3><br><p>  Por padrão, o Elasticsearch avalia a relevância dos resultados usando o algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BM25</a> usando a consulta e o texto do documento.  Decidimos que mais três fatores devem influenciar a avaliação da conformidade com o resultado desejado e real: </p><br><ul><li>  a hora da última edição do documento - quanto mais ele estava no passado, menos provável era a necessidade desse documento; </li><li>  o número de chamadas para o documento - quanto mais, maior a probabilidade de que este documento seja necessário; </li><li><p>  As versões do corpo do ECM têm vários estados possíveis: sendo desenvolvidos, operacionais e obsoletos.  É lógico que a atuação seja mais importante que as outras. </p><br><p>  Você pode obter esse efeito com a ajuda da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">função Score Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  Como resultado, ceteris paribus, obtemos aproximadamente a seguinte dependência do modificador de classificação de resultados na data de sua última alteração X e no número de ocorrências Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  Inteligência externa </h3><br><p>  Para parte da funcionalidade da pesquisa inteligente, precisamos extrair vários <em>fatos</em> da consulta de pesquisa: datas com sua aplicação (criação, modificação, aprovação etc.), nomes de organizações, tipos de documentos procurados etc. </p><br><p>  Também é desejável classificar a solicitação em uma determinada categoria, por exemplo, documentos por organização, funcionário, órgão regulador etc. </p><br><p>  Essas duas operações são executadas pelo Módulo Inteligente ECM - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DIRECTUM Ario</a> . </p><br><h3 id="process-umnogo-poiska">  Processo de pesquisa inteligente </h3><br><p>  É hora de considerar mais detalhadamente quais mecanismos são implementados elementos de inteligência. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Correção de erro do usuário </h4><br><p>  A correção do layout é determinada com base no modelo de idioma do trigrama - para uma linha, é calculado qual a probabilidade de atender às seqüências de três caracteres em textos em inglês e russo.  Se o layout atual for considerado menos provável, primeiro, uma dica com o layout correto será exibida: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  e segundo, as etapas adicionais da pesquisa são executadas com o layout correto: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  E se nada puder ser encontrado com o layout corrigido, a pesquisa começará com a linha original. </p><br><p>  A correção de erros de digitação é implementada usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phrase Suggester</a> .  Existe um problema: se você executar uma consulta em vários índices ao mesmo tempo, sugira que não retorne nada, enquanto que, se você executar em apenas um índice, haverá resultados.  Isso <em>é tratado</em> definindo confiança = 0, mas, em seguida, sugira sugerir a substituição de palavras por sua forma normal.  Concordo, será estranho quando você procurar por "letra <strong>a</strong> " para obter uma resposta no espírito: <em>Talvez você estivesse procurando uma carta?</em> </p><br><p>  Isso pode ser contornado usando dois prompts na solicitação: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Dos parâmetros comuns usados </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Se o primeiro opinador retornou o resultado, mas o segundo não, esse resultado é a própria string original, possivelmente com palavras de outras formas, e não há necessidade de mostrar uma dica.  Se a dica ainda for necessária, a frase de pesquisa original será mesclada à dica.  Isso acontece substituindo apenas as palavras corrigidas e somente aquelas que o corretor ortográfico (usando Hunspell) considera incorretas. </p><br><p>  Se a pesquisa na cadeia de origem retornou 0 resultados, ela será substituída pela cadeia obtida pela mesclagem e a pesquisa será realizada novamente: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Caso contrário, a sequência de prompt resultante será retornada apenas como um prompt para a pesquisa: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Classificação de consulta e extração de fatos </h4><br><p>  Como mencionei, usamos o DIRECTUM Ario, a saber, o serviço de classificação de texto e o serviço de extração de fatos.  Para fazer isso, fornecemos aos analistas consultas de pesquisa anônimas e uma lista de fatos nos quais estamos interessados.  Com base em consultas e conhecimento sobre quais documentos estão no sistema, os analistas identificaram várias categorias e treinaram o serviço de classificação para determinar a categoria de acordo com o texto da consulta.  Com base nas categorias resultantes e na lista de fatos, formulamos as regras para o uso desses fatos.  Por exemplo, a frase <em><strong>do último ano</strong></em> na categoria <strong>Todos</strong> é considerada a data de criação do documento e na categoria <strong>Por organização</strong> - a data do registro.  Ao mesmo tempo, os <em><strong>criados no ano passado</strong></em> devem, em qualquer categoria, cair na data de criação. </p><br><p>  Do lado da pesquisa - eles fizeram uma configuração na qual registraram as categorias, quais fatos são aplicados a quais filtros de faceta. </p><br><h4 id="avtodopolnenie-vvoda">  Conclusão da entrada </h4><br><p>  Além das correções de layout já mencionadas, pesquisas anteriores do usuário e documentos públicos caem no preenchimento automático. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  Eles são implementados usando outro tipo de Sugeridor - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sugeridor de conclusão</a> , mas cada um tem suas próprias nuances. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Preenchimento automático: histórico de pesquisa </h5><br><p>  Existem muito menos usuários no ECM que os mecanismos de pesquisa e alocam consultas comuns suficientes para eles <del>  por que lenin cogumelo </del>  não é possível.  Mostrar tudo em uma linha também não vale a pena devido a considerações de privacidade.  O Sugestor de Conclusão usual pode pesquisar apenas o conjunto inteiro de documentos no índice, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Context Suggester</a> vem em socorro - uma maneira de definir um contexto para cada dica e filtrar por esses contextos.  Se os nomes de usuário forem usados ​​como contextos, apenas a história dele poderá ser mostrada a todos. </p><br><p>  Você também precisa dar ao usuário a oportunidade de remover o prompt pelo qual ele tem vergonha.  Como chave para exclusão, usamos o nome do usuário e o texto da dica de ferramenta.  Como resultado, para o índice com dicas, obtivemos um mapeamento tão duplicado: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  O peso de cada nova dica é definido como um e aumenta cada vez que você a digita novamente usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API Atualizar por consulta</a> com um script <code>ctx._source.suggest.weight++</code> muito simples. </p><br><h5 id="avtodopolnenie-dokumenty">  Preenchimento automático: documentos </h5><br><p>  Mas pode haver muitos documentos e possíveis combinações de direitos.  Portanto, aqui, pelo contrário, decidimos não fazer a filtragem por direitos ao preencher automaticamente, mas apenas indexar documentos públicos.  Sim, e você não precisa remover dicas individuais desse índice.  Parece que a implementação em tudo é mais fácil do que a anterior, se não por dois pontos: </p><br><p>  O primeiro - o Completion Suggester oferece suporte apenas à pesquisa de prefixos, e os clientes adoram atribuir números de itens a tudo, e algumas <code>.01.01   </code> ao digitar uma consulta.  Aqui, junto com o nome completo, você também pode indexar n-gramas derivados: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  Isso não foi tão crítico com a história, mas o mesmo usuário entra aproximadamente na mesma linha se ele procurar algo novamente.  <em>Provavelmente</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  A segunda - por padrão, todas as dicas são iguais, mas gostaríamos de torná-las mais iguais e de preferência para que isso seja consistente com a classificação dos resultados da pesquisa.  Para fazer isso, repita aproximadamente as funções gauss e field_value_factor usadas na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consulta de Pontuação</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Função</a> . </p><br><p>  Acontece que aqui está um pipeline: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  com o seguinte script: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Por que se preocupar com um oleoduto indolor em vez de escrevê-lo em um idioma mais conveniente?  Como agora, usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API Reindex</a> , você pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">substituir</a> o conteúdo dos índices de pesquisa em índices para obter dicas (especificando apenas os campos necessários, é claro) em apenas um comando. </p><br><p>  A composição dos documentos públicos realmente necessários não é atualizada com frequência, portanto esse comando pode ser deixado em um início manual. </p><br><h3 id="otobrazhenie-rezultatov">  Exibir resultados </h3><br><h4 id="kategorii">  Categorias </h4><br><p>  A categoria determina quais facetas estarão disponíveis e como será o snippet.  Ele pode ser detectado automaticamente por <em>inteligência externa</em> ou selecionado manualmente acima da barra de pesquisa. </p><br><h4 id="fasety">  Facetas </h4><br><p>  As facetas são uma coisa tão intuitiva para todos cujo comportamento, no entanto, é descrito por regras muito triviais.  Aqui estão alguns deles: </p><br><ol><li><p>  Os valores das facetas dependem dos resultados da pesquisa, MAS os resultados da pesquisa dependem das facetas selecionadas.  Como evitar recursão? </p><br></li><li><p>  A seleção de valores em uma faceta não afeta outros valores dessa faceta, mas afeta valores em outras facetas: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  Os valores de faceta selecionados pelo usuário não devem desaparecer, mesmo se uma opção em outra faceta os <em>aniquilar</em> para 0 ou eles não estiverem mais no topo: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  Na elasticidade, as facetas são realizadas através do mecanismo de agregação, mas, para cumprir as regras descritas, essas agregações devem ser investidas uma na outra e filtradas uma pela outra. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Considere os fragmentos de solicitação responsáveis ​​por isso: </p><br><div class="spoiler">  <b class="spoiler_title">Código muito grande</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  O que há aqui que: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post_filter</a> permite impor uma condição adicional aos resultados de uma consulta já concluída e não afeta os resultados das agregações.  Essa mesma lacuna de recursão.  Inclui todos os valores selecionados de todas as facetas. </li><li>  agregações de nível superior, no exemplo <em>card.author_value_id</em> e <em>editor_value_id</em> .  Cada um tem: <br><ul><li>  filtre pelos valores de todas as outras facetas, exceto a sua; </li><li>  agregação aninhada para valores de faceta selecionados - <em>proteção contra aniquilação</em> ; </li><li>  agregação aninhada para outros valores de faceta.  Mostramos os 10 principais e solicitamos os 11 principais - para determinar se o botão <strong>Mostrar tudo será</strong> exibido. </li></ul></li></ul><br><h4 id="snippety">  Snippets </h4><br><p>  Dependendo da categoria selecionada, o snippet pode parecer diferente, por exemplo, o mesmo documento ao pesquisar em uma categoria </p><br><p>  <strong>Todos</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  e <strong>funcionários</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Ou lembre-se, queríamos ver o assunto de uma oferta comercial e de quem ela veio? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  Para não arrastar o cartão inteiro do elástico (isso diminui a velocidade da pesquisa), a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">filtragem de origem é usada</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  Para destacar as palavras encontradas no texto do documento, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marcador Fast Vector</a> é usado - como gerador dos trechos mais apropriados para textos grandes e para o nome - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marcador unificado</a> - como o menos exigente em recursos e estrutura de índice: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  Nesse caso, o nome é destacado por inteiro e, a partir do texto, temos até 3 fragmentos com 300 caracteres.  O texto retornado pelo marca-texto Fast Vector é ainda compactado por um algoritmo improvisado para obter um estado de snippet minimizado. </p><br><h3 id="kollaps">  Reduzir </h3><br><p>  Historicamente, os usuários desse ECM estão acostumados ao fato de que a pesquisa retorna <em>documentos para</em> eles, mas, na verdade, o Elasticsearch pesquisa entre <em>versões de documentos</em> .  Pode acontecer que várias versões quase idênticas sejam encontradas na mesma consulta.  Isso irá confundir os resultados e confundir o usuário.  Felizmente, esse comportamento pode ser evitado usando o mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Field Collapsing</a> - uma versão leve de agregações que já funciona nos resultados finais (nesse caso, ele se parece com post_filter, <em>duas muletas são um par</em> ).  O <em>recolhimento</em> resultará no mais relevante dos objetos <em>recolhidos</em> . </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Infelizmente, o colapso tem vários efeitos desagradáveis, por exemplo, várias características numéricas do resultado da pesquisa continuam retornando como se não houvesse colapso.  Ou seja, o número de resultados, o número de valores das facetas - todos estarão <em>levemente</em> incorretos, mas o usuário geralmente não percebe isso, assim como o leitor cansado, que provavelmente não leu essa proposta antes. </p><br><p>  O fim </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460263/">https://habr.com/ru/post/pt460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460253/index.html">10 razões para fazer sua habilidade para assistente de voz</a></li>
<li><a href="../pt460255/index.html">Backdoor no Node.js: por que, por que e como funciona</a></li>
<li><a href="../pt460257/index.html">Olá Mundo! Imersão profunda em terminais</a></li>
<li><a href="../pt460259/index.html">O que é design de interface do usuário e UX? O que é comum e diferente?</a></li>
<li><a href="../pt460261/index.html">Amazon: 25 anos de sucesso no comércio eletrônico</a></li>
<li><a href="../pt460265/index.html">Criar um modelo de projeto do Xcode</a></li>
<li><a href="../pt460273/index.html">Autorização no Apple Pay pelo menor</a></li>
<li><a href="../pt460275/index.html">Por que você não precisa da solução perfeita</a></li>
<li><a href="../pt460279/index.html">Contrato de 10 bilhões: quem lidará com a nuvem para o Pentágono</a></li>
<li><a href="../pt460281/index.html">Como o UX Writer ajuda a melhorar o produto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>