<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üë∞üèº ‚¨áÔ∏è Este seu Haskell √© (n√£o) apenas fatorial e bom para ü§≤üèø üíª üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando se trata de idiomas favoritos, costumo dizer que, sendo todas as coisas iguais, prefiro C ++ para trituradores de n√∫meros e Haskell para todo o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Este seu Haskell √© (n√£o) apenas fatorial e bom para</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445134/"><p> Quando se trata de idiomas favoritos, costumo dizer que, sendo todas as coisas iguais, prefiro C ++ para trituradores de n√∫meros e Haskell para todo o resto.  √â √∫til verificar periodicamente se essa divis√£o √© justificada, e apenas recentemente surgiu uma quest√£o ociosa e muito simples: como a soma de todos os divisores de um n√∫mero se comportar√° com o crescimento desse n√∫mero, digamos, para o primeiro bilh√£o de n√∫meros.  √â f√°cil intimidar essa tarefa (√© uma pena cham√°-la de multiplicador de n√∫meros resultante), por isso parece uma √≥tima op√ß√£o para essa verifica√ß√£o. </p><br><p>  Al√©m disso, ainda n√£o tenho a capacidade de prever com precis√£o o desempenho do c√≥digo Haskell, por isso √© √∫til tentar abordagens conscientemente ruins para ver como o desempenho diminui. </p><br><p>  Al√©m disso, voc√™ pode exibir facilmente um algoritmo mais eficiente do que a busca frontal por divisores para cada n√∫mero de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  . </p><a name="habracut"></a><br><h3>  Algoritmo </h3><br><p>  Ent√£o, vamos come√ßar com o algoritmo. </p><br><p>  Como encontrar a soma de todos os divisores de um n√∫mero <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n </script>  ?  Voc√™ pode passar por todos <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-4"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  e para todos esses <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> k_1 </script>  verifique o restante da divis√£o <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n </script>  em <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-18" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> k_1 </script>  .  Se o restante for <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mn" id="MJXp-Span-20">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  e adicione √† bateria <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k_1 + k_2 </script>  onde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">c</span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span></span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;">1</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> k_2 = \ frac {n} {k_1} </script>  se <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">q</span><span class="MJXp-msubsup" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-55" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> k_1 \ neq k_2 </script>  e apenas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> k_1 </script>  caso contr√°rio. </p><br><p>  Esse algoritmo pode ser aplicado <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> n </script>  vezes, para cada n√∫mero de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n </script>  ?  Voc√™ pode, √© claro.  Qual ser√° a dificuldade?  F√°cil de ver esse pedido <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">O</span><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-71" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">c</span><span class="MJXp-mrow" id="MJXp-Span-76"><span class="MJXp-mn" id="MJXp-Span-77">3</span></span><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79">2</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> O (n ^ \ frac {3} {2}) </script>  divis√µes - para cada n√∫mero, fazemos exatamente a raiz das divis√µes e temos n√∫meros <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n </script>  .  Podemos fazer melhor?  Acontece que sim. </p><br><p>  Um dos problemas com esse m√©todo √© que estamos desperdi√ßando muito esfor√ßo.  Muitas divis√µes n√£o nos levam ao sucesso, dando um restante diferente de zero.  √â natural tentar ser um pouco mais pregui√ßoso e abordar a tarefa do outro lado: vamos gerar todos os tipos de candidatos a divisores e ver quais n√∫meros eles satisfazem? </p><br><p>  Ent√£o, agora vamos precisar de um golpe para cada n√∫mero de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mn" id="MJXp-Span-84">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  calcular a soma de todos os seus divisores.  Para fazer isso, passe por todos <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="noError" id="MJXp-Span-88" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  e para cada um desses <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-msubsup" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-92" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> k_1 </script>  vamos passar por tudo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="noError" id="MJXp-Span-94" style="display: inline-block;">k_2&nbsp;\&nbsp;in&nbsp;\&nbsp;{k_1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;frac&nbsp;{n}&nbsp;{k}&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> k_2 \ in \ {k_1 \ dots \ lfloor \ frac {n} {k} \ rfloor \} </script>  .  Para cada par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-99" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-103" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> (k_1, k_2) </script>  adicionar √† c√©lula com o √≠ndice <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-msubsup" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-108" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-109">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> k_1 \ cdot k_2 </script>  valor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-msubsup" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-120" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-122"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-124" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> k_1 + k_2 </script>  se <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-msubsup" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-128" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-129">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">q</span><span class="MJXp-msubsup" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-135" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> k_1 \ neq k_2 </script>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-msubsup" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-139" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> k_1 </script>  caso contr√°rio. </p><br><p>  Esse algoritmo faz exatamente <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-msubsup" id="MJXp-Span-141"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-143" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">c</span><span class="MJXp-mrow" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span><span class="MJXp-mrow" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n ^ \ frac {1} {2} </script>  divis√µes e cada multiplica√ß√£o (que √© mais barata que a divis√£o) nos leva ao sucesso: a cada itera√ß√£o aumentamos algo.  Isso √© muito mais eficaz que a abordagem frontal. </p><br><p>  Al√©m disso, com essa mesma abordagem frontal, voc√™ pode comparar as duas implementa√ß√µes e garantir que elas apresentem os mesmos resultados para n√∫meros razoavelmente pequenos, o que deve adicionar um pouco de confian√ßa. </p><br><h3>  Primeira implementa√ß√£o </h3><br><p>  E, a prop√≥sito, isso √© diretamente quase um pseudoc√≥digo da implementa√ß√£o inicial em Haskell: </p><br><pre><code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IntMap.Strict <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IM divisorSums :: Int -&gt; Int divisorSums n = IM.fromListWith (+) premap IM.! n where premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor $ sqrt $ fromIntegral n ] , k2 &lt;- [ k1 .. n `quot` k1 ] ]</code> </pre> <br><p>  <code>Main</code> m√≥dulo √© simples e n√£o o trago. </p><br><p>  Al√©m disso, aqui mostramos o valor apenas para os mais <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n </script>  para facilitar a compara√ß√£o com outras implementa√ß√µes.  Apesar de Haskell ser uma linguagem pregui√ßosa, nesse caso, todos os valores ser√£o calculados (embora a justificativa completa esteja al√©m do escopo deste artigo), portanto, n√£o resulta que n√£o contaremos nada inadvertidamente. </p><br><p>  Qu√£o r√°pido ele funciona?  No meu i7 3930k, em um fluxo, 100.000 elementos s√£o trabalhados em 0,4 s.  Nesse caso, 0,15 s s√£o gastos em c√°lculos e 0,25 s em GC.  E ocupamos cerca de 8 megabytes de mem√≥ria, embora, como o tamanho do int seja 8 bytes, o ideal seja termos 800 kilobytes. </p><br><p>  Bom (n√£o realmente).  Como esses n√∫meros crescer√£o com n√∫meros cada vez maiores?  Para 1'000'000 elementos, ele trabalha h√° cerca de 7,5 segundos, gastando tr√™s segundos em computa√ß√£o e 4,5 segundos em GC, al√©m de ocupar 80 megabytes (10 vezes mais que o necess√°rio).  E mesmo se fingirmos ser desenvolvedores s√™nior de software Java por um segundo e come√ßarmos a ajustar o GC, n√£o mudaremos significativamente o cen√°rio.  Que pena.  Parece que nunca esperaremos um bilh√£o de n√∫meros e tamb√©m n√£o entraremos na mem√≥ria: h√° apenas 64 gigabytes de RAM na minha m√°quina e levar√° cerca de 80 se a tend√™ncia continuar. </p><br><p>  Parece hora de fazer </p><br><h3>  Op√ß√£o C ++ </h3><br><p>  Vamos tentar ter uma id√©ia do que faz sentido nos esfor√ßarmos e, para isso, escreveremos o c√≥digo nas vantagens. </p><br><p>  Bem, como j√° temos um algoritmo depurado, tudo √© simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; int main(int argc, char **argv) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " maxN" &lt;&lt; std::endl; return 1; } int64_t n = std::stoi(argv[1]); std::vector&lt;int64_t&gt; arr; arr.resize(n + 1); for (int64_t k1 = 1; k1 &lt;= static_cast&lt;int64_t&gt;(std::sqrt(n)); ++k1) { for (int64_t k2 = k1; k2 &lt;= n / k1; ++k2) { auto val = k1 != k2 ? k1 + k2 : k1; arr[k1 * k2] += val; } } std::cout &lt;&lt; arr.back() &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Se de repente voc√™ quiser escrever algo sobre esse c√≥digo</b> <div class="spoiler_text"><p>  O compilador faz um √≥timo movimento de c√≥digo invari√°vel nesse loop, calculando a raiz uma vez na vida do programa e computando <code>n / k1</code> uma vez por itera√ß√£o do loop externo. <br></p></div></div><br><div class="spoiler">  <b class="spoiler_title">E um spoiler sobre simplicidade</b> <div class="spoiler_text"><p>  Este c√≥digo n√£o funcionou para mim na primeira vez, apesar de eu ter copiado um algoritmo existente.  Cometi alguns erros muito est√∫pidos que, ao que parece, n√£o est√£o diretamente relacionados aos tipos, mas ainda assim foram cometidos.  Mas √©, pensamentos em voz alta. </p></div></div><br><p>  <code>-O3 -march=native</code> , cl 8, um milh√£o de elementos √© processado em 0,024 s, ocupando os 8 megabytes de mem√≥ria alocados.  Bilh√µes - 155 segundos, 8 gigabytes de mem√≥ria, conforme o esperado.  Ai.  Haskell n√£o √© bom.  Haskell precisa ser jogado fora.  Apenas fatoriais e prepromorfismos nele e escreva!  Ou n√£o? </p><br><h3>  Segunda op√ß√£o </h3><br><p>  Obviamente, executar todos os dados gerados atrav√©s do <code>IntMap</code> , que √©, de fato, um mapa relativamente comum - para dizer o m√≠nimo, n√£o √© a decis√£o mais sensata (sim, esta √© a mesma op√ß√£o obviamente p√©ssima mencionada no in√≠cio).  Por que n√£o usamos uma matriz como no c√≥digo C ++? </p><br><p>  Vamos tentar: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! n where arr = A.accumArray (+) 0 (1, <span class="hljs-title"><span class="hljs-title">n</span></span>) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Aqui, imediatamente usamos a vers√£o sem caixa da matriz, pois <code>Int</code> bastante simples e n√£o precisamos de pregui√ßa.  A vers√£o em caixa diferiria apenas no tipo <code>arr</code> , por isso n√£o perdemos o idioma tamb√©m.  Al√©m disso, a liga√ß√£o para <code>bound</code> √© feita separadamente aqui, mas n√£o porque o compilador seja est√∫pido e n√£o faz o LICM, mas porque ent√£o voc√™ pode especificar explicitamente seu tipo e evitar um aviso do compilador sobre o padr√£o do argumento de <code>floor</code> . </p><br><p>  0,045 s para um milh√£o de elementos (apenas duas vezes pior que as vantagens!).  8 megabytes de mem√≥ria, zero milissegundos em GC (!).  Em tamanhos maiores, a tend√™ncia persiste - cerca de duas vezes mais lenta que o C ++ e a mesma quantidade de mem√≥ria.  √ìtimo resultado!  Mas podemos fazer melhor? </p><br><p>  Acontece que sim.  <code>accumArray</code> verifica os √≠ndices, o que n√£o precisamos fazer neste caso - os √≠ndices est√£o corretos na constru√ß√£o.  Vamos tentar substituir a chamada para <code>accumArray</code> por <code>unsafeAccumArray</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) where arr = A.unsafeAccumArray (+) 0 (0, <span class="hljs-title"><span class="hljs-title">n</span></span> - 1) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span> - 1, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Como voc√™ pode ver, as altera√ß√µes s√£o m√≠nimas, exceto pela necessidade de serem indexadas do zero (o que, na minha opini√£o, √© um bug na API da biblioteca, mas essa √© outra quest√£o).  Qual √© o desempenho? </p><br><p>  Um milh√£o de elementos - 0,021 s (uau, dentro da margem de erro, mas mais r√°pido que os profissionais!).  Naturalmente, os mesmos 8 megabytes de mem√≥ria, os mesmos 0 ms no GC. </p><br><p>  Bilh√µes de elementos - 152 s (parece que √© realmente mais r√°pido que os benef√≠cios!).  Um pouco menos de 8 gigabytes.  0 ms no GC.  O c√≥digo ainda √© idiom√°tico.  Eu acho que podemos dizer que isso √© uma vit√≥ria. </p><br><h3>  Em conclus√£o </h3><br><p>  Em primeiro lugar, fiquei surpreso que a substitui√ß√£o do <code>accumArray</code> por uma vers√£o <code>unsafe</code> trar√° esse aumento.  Seria mais razo√°vel esperar de 10 a 20% (afinal, nos trunfos, substituir o <code>operator[]</code> por <code>at()</code> n√£o causa uma diminui√ß√£o significativa no desempenho), mas n√£o pela metade! </p><br><p>  Em segundo lugar, na minha opini√£o, √© muito legal que um c√≥digo limpo bastante idiom√°tico, sem uma altera√ß√£o mut√°vel, atinja esse n√≠vel de desempenho. </p><br><p>  Em terceiro lugar, √© claro, outras otimiza√ß√µes s√£o poss√≠veis e em todos os n√≠veis.  Estou certo, por exemplo, de que voc√™ pode extrair um pouco mais do c√≥digo das vantagens.  No entanto, na minha opini√£o, em todos esses benchmarks, o equil√≠brio entre o esfor√ßo despendido (e a quantidade de c√≥digo) e o escape resultante √© importante.  Caso contr√°rio, tudo acabar√° convergindo para o desafio do LLVM JIT ou algo assim.  Al√©m disso, certamente existem algoritmos mais eficientes para resolver esse problema, mas o resultado de uma breve reflex√£o apresentada aqui tamb√©m funcionar√° para esta pequena aventura de domingo. </p><br><p>  Quarto, meu favorito: os sistemas de tipos precisam ser desenvolvidos.  <code>unsafe</code> n√£o √© necess√°rio aqui, como programador posso provar que <code>k_1 * k_2 &lt;= n</code> para todos os <code>k_1, k_2</code> encontrados no loop.  Em um mundo ideal de linguagens de tipo dependente, eu constru√≠va essa prova estaticamente e a passava para a fun√ß√£o correspondente, o que eliminaria a necessidade de verifica√ß√µes em tempo de execu√ß√£o.  Mas, infelizmente, em Haskell n√£o h√° zavtipov de pleno direito, e em idiomas em que h√° zavtipy (e que eu sei), n√£o h√° <code>array</code> e an√°logos. </p><br><p>  Em quinto lugar, n√£o conhe√ßo outras linguagens de programa√ß√£o suficientes para se qualificar para quase benchmarks nessas linguagens, mas um dos meus amigos escreveu um an√°logo em python.  Quase exatamente cem vezes mais devagar e pior da mem√≥ria.  E o algoritmo em si √© extremamente simples; portanto, se algu√©m com conhecimento escrever um anal√≥gico em Go, Rust, Julia, D, Java, Malbolge nos coment√°rios, ou compartilhar uma compara√ß√£o, por exemplo, com o c√≥digo C ++ em sua m√°quina - provavelmente ser√° √≥timo . </p><br><p>  PS: Desculpe pelo cabe√ßalho ligeiramente isca de clique.  Eu n√£o consegui pensar em nada melhor. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445134/">https://habr.com/ru/post/pt445134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445122/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 357 (18 a 24 de mar√ßo de 2019)</a></li>
<li><a href="../pt445124/index.html">Prote√ß√£o moderada para Firefox</a></li>
<li><a href="../pt445126/index.html">Aplica√ß√µes de engenharia reversa ap√≥s ofusca√ß√£o (parte 2)</a></li>
<li><a href="../pt445128/index.html">Tutorial do Oracle Application Express Vis√£o geral do IDE</a></li>
<li><a href="../pt445130/index.html">O Minist√©rio da Administra√ß√£o Interna comprou PCs por 180 milh√µes de rublos - todo o dinheiro foi destinado a fabricantes estrangeiros</a></li>
<li><a href="../pt445136/index.html">N√£o fique nervoso, n√£o se apresse, n√£o interrompa: a hist√≥ria de uma trag√©dia</a></li>
<li><a href="../pt445138/index.html">IBM Integration Bus e o que come</a></li>
<li><a href="../pt445140/index.html">PHP Digest No. 152 (11 a 25 de mar√ßo de 2019)</a></li>
<li><a href="../pt445146/index.html">A hist√≥ria do elefante Slonik, o logotipo do PostgreSQL</a></li>
<li><a href="../pt445150/index.html">Upwork est√° registrado na Federa√ß√£o Russa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>