<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 👰🏼 ⬇️ Este seu Haskell é (não) apenas fatorial e bom para 🤲🏿 💻 📩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando se trata de idiomas favoritos, costumo dizer que, sendo todas as coisas iguais, prefiro C ++ para trituradores de números e Haskell para todo o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Este seu Haskell é (não) apenas fatorial e bom para</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445134/"><p> Quando se trata de idiomas favoritos, costumo dizer que, sendo todas as coisas iguais, prefiro C ++ para trituradores de números e Haskell para todo o resto.  É útil verificar periodicamente se essa divisão é justificada, e apenas recentemente surgiu uma questão ociosa e muito simples: como a soma de todos os divisores de um número se comportará com o crescimento desse número, digamos, para o primeiro bilhão de números.  É fácil intimidar essa tarefa (é uma pena chamá-la de multiplicador de números resultante), por isso parece uma ótima opção para essa verificação. </p><br><p>  Além disso, ainda não tenho a capacidade de prever com precisão o desempenho do código Haskell, por isso é útil tentar abordagens conscientemente ruins para ver como o desempenho diminui. </p><br><p>  Além disso, você pode exibir facilmente um algoritmo mais eficiente do que a busca frontal por divisores para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  . </p><a name="habracut"></a><br><h3>  Algoritmo </h3><br><p>  Então, vamos começar com o algoritmo. </p><br><p>  Como encontrar a soma de todos os divisores de um número <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n </script>  ?  Você pode passar por todos <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-4"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  e para todos esses <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> k_1 </script>  verifique o restante da divisão <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n </script>  em <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-18" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhjDvjmR82KHTbE-zfe4mHeTtEADzw#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> k_1 </script>  .  Se o restante for <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mn" id="MJXp-Span-20">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  e adicione à bateria <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k_1 + k_2 </script>  onde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">c</span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span></span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;">1</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> k_2 = \ frac {n} {k_1} </script>  se <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">q</span><span class="MJXp-msubsup" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-55" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> k_1 \ neq k_2 </script>  e apenas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> k_1 </script>  caso contrário. </p><br><p>  Esse algoritmo pode ser aplicado <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> n </script>  vezes, para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n </script>  ?  Você pode, é claro.  Qual será a dificuldade?  Fácil de ver esse pedido <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">O</span><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-71" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">c</span><span class="MJXp-mrow" id="MJXp-Span-76"><span class="MJXp-mn" id="MJXp-Span-77">3</span></span><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79">2</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> O (n ^ \ frac {3} {2}) </script>  divisões - para cada número, fazemos exatamente a raiz das divisões e temos números <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n </script>  .  Podemos fazer melhor?  Acontece que sim. </p><br><p>  Um dos problemas com esse método é que estamos desperdiçando muito esforço.  Muitas divisões não nos levam ao sucesso, dando um restante diferente de zero.  É natural tentar ser um pouco mais preguiçoso e abordar a tarefa do outro lado: vamos gerar todos os tipos de candidatos a divisores e ver quais números eles satisfazem? </p><br><p>  Então, agora vamos precisar de um golpe para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mn" id="MJXp-Span-84">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  calcular a soma de todos os seus divisores.  Para fazer isso, passe por todos <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="noError" id="MJXp-Span-88" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  e para cada um desses <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-msubsup" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-92" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> k_1 </script>  vamos passar por tudo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="noError" id="MJXp-Span-94" style="display: inline-block;">k_2&nbsp;\&nbsp;in&nbsp;\&nbsp;{k_1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;frac&nbsp;{n}&nbsp;{k}&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> k_2 \ in \ {k_1 \ dots \ lfloor \ frac {n} {k} \ rfloor \} </script>  .  Para cada par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-99" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-103" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> (k_1, k_2) </script>  adicionar à célula com o índice <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-msubsup" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-108" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-109">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> k_1 \ cdot k_2 </script>  valor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-msubsup" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-120" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-122"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-124" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> k_1 + k_2 </script>  se <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-msubsup" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-128" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-129">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">q</span><span class="MJXp-msubsup" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-135" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> k_1 \ neq k_2 </script>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-msubsup" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-139" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> k_1 </script>  caso contrário. </p><br><p>  Esse algoritmo faz exatamente <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-msubsup" id="MJXp-Span-141"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-143" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">c</span><span class="MJXp-mrow" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span><span class="MJXp-mrow" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n ^ \ frac {1} {2} </script>  divisões e cada multiplicação (que é mais barata que a divisão) nos leva ao sucesso: a cada iteração aumentamos algo.  Isso é muito mais eficaz que a abordagem frontal. </p><br><p>  Além disso, com essa mesma abordagem frontal, você pode comparar as duas implementações e garantir que elas apresentem os mesmos resultados para números razoavelmente pequenos, o que deve adicionar um pouco de confiança. </p><br><h3>  Primeira implementação </h3><br><p>  E, a propósito, isso é diretamente quase um pseudocódigo da implementação inicial em Haskell: </p><br><pre><code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IntMap.Strict <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IM divisorSums :: Int -&gt; Int divisorSums n = IM.fromListWith (+) premap IM.! n where premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor $ sqrt $ fromIntegral n ] , k2 &lt;- [ k1 .. n `quot` k1 ] ]</code> </pre> <br><p>  <code>Main</code> módulo é simples e não o trago. </p><br><p>  Além disso, aqui mostramos o valor apenas para os mais <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n </script>  para facilitar a comparação com outras implementações.  Apesar de Haskell ser uma linguagem preguiçosa, nesse caso, todos os valores serão calculados (embora a justificativa completa esteja além do escopo deste artigo), portanto, não resulta que não contaremos nada inadvertidamente. </p><br><p>  Quão rápido ele funciona?  No meu i7 3930k, em um fluxo, 100.000 elementos são trabalhados em 0,4 s.  Nesse caso, 0,15 s são gastos em cálculos e 0,25 s em GC.  E ocupamos cerca de 8 megabytes de memória, embora, como o tamanho do int seja 8 bytes, o ideal seja termos 800 kilobytes. </p><br><p>  Bom (não realmente).  Como esses números crescerão com números cada vez maiores?  Para 1'000'000 elementos, ele trabalha há cerca de 7,5 segundos, gastando três segundos em computação e 4,5 segundos em GC, além de ocupar 80 megabytes (10 vezes mais que o necessário).  E mesmo se fingirmos ser desenvolvedores sênior de software Java por um segundo e começarmos a ajustar o GC, não mudaremos significativamente o cenário.  Que pena.  Parece que nunca esperaremos um bilhão de números e também não entraremos na memória: há apenas 64 gigabytes de RAM na minha máquina e levará cerca de 80 se a tendência continuar. </p><br><p>  Parece hora de fazer </p><br><h3>  Opção C ++ </h3><br><p>  Vamos tentar ter uma idéia do que faz sentido nos esforçarmos e, para isso, escreveremos o código nas vantagens. </p><br><p>  Bem, como já temos um algoritmo depurado, tudo é simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; int main(int argc, char **argv) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " maxN" &lt;&lt; std::endl; return 1; } int64_t n = std::stoi(argv[1]); std::vector&lt;int64_t&gt; arr; arr.resize(n + 1); for (int64_t k1 = 1; k1 &lt;= static_cast&lt;int64_t&gt;(std::sqrt(n)); ++k1) { for (int64_t k2 = k1; k2 &lt;= n / k1; ++k2) { auto val = k1 != k2 ? k1 + k2 : k1; arr[k1 * k2] += val; } } std::cout &lt;&lt; arr.back() &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Se de repente você quiser escrever algo sobre esse código</b> <div class="spoiler_text"><p>  O compilador faz um ótimo movimento de código invariável nesse loop, calculando a raiz uma vez na vida do programa e computando <code>n / k1</code> uma vez por iteração do loop externo. <br></p></div></div><br><div class="spoiler">  <b class="spoiler_title">E um spoiler sobre simplicidade</b> <div class="spoiler_text"><p>  Este código não funcionou para mim na primeira vez, apesar de eu ter copiado um algoritmo existente.  Cometi alguns erros muito estúpidos que, ao que parece, não estão diretamente relacionados aos tipos, mas ainda assim foram cometidos.  Mas é, pensamentos em voz alta. </p></div></div><br><p>  <code>-O3 -march=native</code> , cl 8, um milhão de elementos é processado em 0,024 s, ocupando os 8 megabytes de memória alocados.  Bilhões - 155 segundos, 8 gigabytes de memória, conforme o esperado.  Ai.  Haskell não é bom.  Haskell precisa ser jogado fora.  Apenas fatoriais e prepromorfismos nele e escreva!  Ou não? </p><br><h3>  Segunda opção </h3><br><p>  Obviamente, executar todos os dados gerados através do <code>IntMap</code> , que é, de fato, um mapa relativamente comum - para dizer o mínimo, não é a decisão mais sensata (sim, esta é a mesma opção obviamente péssima mencionada no início).  Por que não usamos uma matriz como no código C ++? </p><br><p>  Vamos tentar: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! n where arr = A.accumArray (+) 0 (1, <span class="hljs-title"><span class="hljs-title">n</span></span>) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Aqui, imediatamente usamos a versão sem caixa da matriz, pois <code>Int</code> bastante simples e não precisamos de preguiça.  A versão em caixa diferiria apenas no tipo <code>arr</code> , por isso não perdemos o idioma também.  Além disso, a ligação para <code>bound</code> é feita separadamente aqui, mas não porque o compilador seja estúpido e não faz o LICM, mas porque então você pode especificar explicitamente seu tipo e evitar um aviso do compilador sobre o padrão do argumento de <code>floor</code> . </p><br><p>  0,045 s para um milhão de elementos (apenas duas vezes pior que as vantagens!).  8 megabytes de memória, zero milissegundos em GC (!).  Em tamanhos maiores, a tendência persiste - cerca de duas vezes mais lenta que o C ++ e a mesma quantidade de memória.  Ótimo resultado!  Mas podemos fazer melhor? </p><br><p>  Acontece que sim.  <code>accumArray</code> verifica os índices, o que não precisamos fazer neste caso - os índices estão corretos na construção.  Vamos tentar substituir a chamada para <code>accumArray</code> por <code>unsafeAccumArray</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) where arr = A.unsafeAccumArray (+) 0 (0, <span class="hljs-title"><span class="hljs-title">n</span></span> - 1) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span> - 1, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Como você pode ver, as alterações são mínimas, exceto pela necessidade de serem indexadas do zero (o que, na minha opinião, é um bug na API da biblioteca, mas essa é outra questão).  Qual é o desempenho? </p><br><p>  Um milhão de elementos - 0,021 s (uau, dentro da margem de erro, mas mais rápido que os profissionais!).  Naturalmente, os mesmos 8 megabytes de memória, os mesmos 0 ms no GC. </p><br><p>  Bilhões de elementos - 152 s (parece que é realmente mais rápido que os benefícios!).  Um pouco menos de 8 gigabytes.  0 ms no GC.  O código ainda é idiomático.  Eu acho que podemos dizer que isso é uma vitória. </p><br><h3>  Em conclusão </h3><br><p>  Em primeiro lugar, fiquei surpreso que a substituição do <code>accumArray</code> por uma versão <code>unsafe</code> trará esse aumento.  Seria mais razoável esperar de 10 a 20% (afinal, nos trunfos, substituir o <code>operator[]</code> por <code>at()</code> não causa uma diminuição significativa no desempenho), mas não pela metade! </p><br><p>  Em segundo lugar, na minha opinião, é muito legal que um código limpo bastante idiomático, sem uma alteração mutável, atinja esse nível de desempenho. </p><br><p>  Em terceiro lugar, é claro, outras otimizações são possíveis e em todos os níveis.  Estou certo, por exemplo, de que você pode extrair um pouco mais do código das vantagens.  No entanto, na minha opinião, em todos esses benchmarks, o equilíbrio entre o esforço despendido (e a quantidade de código) e o escape resultante é importante.  Caso contrário, tudo acabará convergindo para o desafio do LLVM JIT ou algo assim.  Além disso, certamente existem algoritmos mais eficientes para resolver esse problema, mas o resultado de uma breve reflexão apresentada aqui também funcionará para esta pequena aventura de domingo. </p><br><p>  Quarto, meu favorito: os sistemas de tipos precisam ser desenvolvidos.  <code>unsafe</code> não é necessário aqui, como programador posso provar que <code>k_1 * k_2 &lt;= n</code> para todos os <code>k_1, k_2</code> encontrados no loop.  Em um mundo ideal de linguagens de tipo dependente, eu construíva essa prova estaticamente e a passava para a função correspondente, o que eliminaria a necessidade de verificações em tempo de execução.  Mas, infelizmente, em Haskell não há zavtipov de pleno direito, e em idiomas em que há zavtipy (e que eu sei), não há <code>array</code> e análogos. </p><br><p>  Em quinto lugar, não conheço outras linguagens de programação suficientes para se qualificar para quase benchmarks nessas linguagens, mas um dos meus amigos escreveu um análogo em python.  Quase exatamente cem vezes mais devagar e pior da memória.  E o algoritmo em si é extremamente simples; portanto, se alguém com conhecimento escrever um analógico em Go, Rust, Julia, D, Java, Malbolge nos comentários, ou compartilhar uma comparação, por exemplo, com o código C ++ em sua máquina - provavelmente será ótimo . </p><br><p>  PS: Desculpe pelo cabeçalho ligeiramente isca de clique.  Eu não consegui pensar em nada melhor. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445134/">https://habr.com/ru/post/pt445134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445122/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 357 (18 a 24 de março de 2019)</a></li>
<li><a href="../pt445124/index.html">Proteção moderada para Firefox</a></li>
<li><a href="../pt445126/index.html">Aplicações de engenharia reversa após ofuscação (parte 2)</a></li>
<li><a href="../pt445128/index.html">Tutorial do Oracle Application Express Visão geral do IDE</a></li>
<li><a href="../pt445130/index.html">O Ministério da Administração Interna comprou PCs por 180 milhões de rublos - todo o dinheiro foi destinado a fabricantes estrangeiros</a></li>
<li><a href="../pt445136/index.html">Não fique nervoso, não se apresse, não interrompa: a história de uma tragédia</a></li>
<li><a href="../pt445138/index.html">IBM Integration Bus e o que come</a></li>
<li><a href="../pt445140/index.html">PHP Digest No. 152 (11 a 25 de março de 2019)</a></li>
<li><a href="../pt445146/index.html">A história do elefante Slonik, o logotipo do PostgreSQL</a></li>
<li><a href="../pt445150/index.html">Upwork está registrado na Federação Russa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>