<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏻 👐 👎🏽 如何在bash中安全编程 ♂️ 🍮 🙆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为什么要扑朔迷离？ 
 bash中有数组和安全模式。 如果正确使用，bash几乎与安全的编码惯例一致。 

 在鱼上犯错误比较困难，但是没有安全的模式。 因此，如果您知道如何正确制作鱼的原型，然后将其从鱼转变为猛击，将是一个好主意。 

 前言 
 该指南随ShellHarden一起提供，但作者还建...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在bash中安全编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1> 为什么要扑朔迷离？ </h1><br>  bash中有数组和安全模式。 如果正确使用，bash几乎与安全的编码惯例一致。 <br><br> 在鱼上犯错误比较困难，但是没有安全的模式。 因此，如果您知道如何正确制作鱼的原型，然后将其从鱼转变为猛击，将是一个好主意。 <br><br><h1> 前言 </h1><br> 该指南随ShellHarden一起提供，但作者还建议执行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ShellCheck，</a>以使ShellHarden规则与ShellCheck保持一致。 <br><br>  Bash不是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">同时解决问题</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最正确方法最简单的语言</a> 。 如果您参加bash安全编程考试，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BashPitfalls</a>的第一条规则将是：始终使用引号。 <br><br><h1> 您需要了解有关bash编程的主要知识 </h1><br>  <b>躁狂引号！</b> 一个没有引号的变量应该被视为一个自爆炸弹：与空间接触会爆炸。 是的，它在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将字符串分成数组</a>的意义上爆炸。 特别是，由于将内部字符串扩展为数组时，由于将特殊的<code>$IFS</code>变量拆分为默认空间，因此将<code>$var</code>这样的变量扩展名和<code>$(cmd)</code>这样的命令替换项拆分为<i>单词</i> 。 这通常是不可见的，因为最常见的结果是一个由1个元素组成的数组，与预期字符串无法区分。 <br><a name="habracut"></a><br> 不仅扩展了它，还扩展了通配符（ <code>*?</code> ）。 拆分单词后会发生此过程，因此，如果单词具有至少一个通配符，则该单词会变成适用于任何合适文件路径的通配符。 因此，此功能开始应用于文件系统！ <br><br> 引用抑制了变量和命令替换的单词拆分和模式扩展。 <br><br> 变量扩展： <br><br><ul><li> 好： <code>"$my_var"</code> </li><li> 错误： <code>$my_var</code> </li></ul><br> 命令替换： <br><br><ul><li> 好： <code>"$(cmd)"</code> </li><li> 错误： <code>$(cmd)</code> </li></ul><br> 有一些带有可选引号的例外，但是引号永远不会受到损害，并且一般规则是要小心不要引用未引号的变量，因此我们不会为了您的利益而寻找边界例外。 它看起来是错误的，并且错误的做法已经广泛地引起人们的怀疑：许多脚本编写时对文件名和其中的空格进行了残破的处理... <br><br>  ShellHarden仅提及少数例外-这些变量是否具有数字内容，例如<code>$?</code>  ， <code>$#</code>和<code>${#array[@]}</code> 。 <br><br><h3> 我需要使用反引号吗？ </h3><br> 命令替换也可以具有以下形式： <br><br><ul><li> 正确： <code>"`cmd`"</code> </li><li> 错误： <code>`cmd`</code> </li></ul><br> 尽管可以正确使用此样式，但在引号中看起来不太方便，并且在嵌套时可读性较低。 这里的共识很明确：避免这样做。 <br><br>  ShellHarden用美元将这些复选标记重写在方括号中。 <br><br><h3> 是否需要使用花括号？ </h3><br> 括号用于插入字符串，因此它们通常是多余的： <br><br><ul><li> 错误： <code>some_command $arg1 $arg2 $arg3</code> </li><li> 较差且冗长： <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li> 很好，但很冗长： <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li> 好： <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br> 从理论上讲，始终使用花括号不是问题，但是根据您的作者的经验，不必要地使用花括号与正确使用引号之间存在很强的负相关关系-几乎每个人都选择“不好而冗长”而不是“好而冗长”的形式！ <br><br> 您的作者的理论： <br><br><ul><li> 由于担心做错事情：初学者可能会担心<code>$prefix</code>变量会导致<code>"$prefix_postfix"</code>变量扩展，而不是真正的危险（没有引号），但这种方式无法正常工作。 </li><li> 货运邪教：在出现错误恐惧之前立下代码。 </li><li> 括号与引号竞争允许的冗长限制。 </li></ul><br> 因此，决定禁止使用不必要的花括号：ShellHarden用最简单的良好形式替换了这些选项。 <br><br> 现在关于字符串插值，其中花括号确实有用： <br><br><ul><li> 错误（连接）： <code>$var1"more string content"$var2</code> </li><li> 良好（串联）： <code>"$var1""more string content""$var2"</code> </li><li> 好（插值）： <code>"${var1}more string content${var2}"</code> </li></ul><br> 即使在数组中，bash中的串联和内插也是等效的（这很荒谬）。 <br><br> 由于ShellHarden不格式化样式，因此不应更改正确的代码。 对于“良好（插值）”选项，这是正确的：从ShellHarden的角度来看，这将是规范正确的形式。 <br><br>  ShellHarden现在正在根据需要添加和删除花括号：在一个不好的例子中，var1带有方括号，但是即使在“良好（插值）”的情况下，var2也不允许使用花括号，因为行末尾不需要它们。 最后一个要求可以颠倒。 <br><br><h4> 陷阱：带编号的参数 </h4><br> 与普通变量<i>标识符</i>名称（在正则表达式中： <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ）不同，带编号的参数需要使用方括号（不需要行插值）。  ShellCheck说： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden拒绝修复它（认为差异太微妙了）。 <br><br> 由于括号最多允许9个，ShellHarden允许它们用于所有编号的参数。 <br><br><h1> 使用数组 </h1><br> 为了能够引用所有变量，必须使用实数数组，而不是用空格分隔的伪大量字符串。 <br><br> 语法很冗长，但是您必须处理它。 这种Bashism只是对于大多数Shell脚本放弃POSIX兼容性的原因之一。 <br><br> 好： <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br> 不好： <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br> 这就是为什么数组是shell如此基本的功能的原因： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参数从根本上说就是数组</a> （而shell脚本是命令和参数）。 可以说，人为地使其无法通过几个论点的外壳将是可笑且毫无价值的。 此类别中的一些常见外壳包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dash</a>和Busybox Ash。 这些是最小的POSIX兼容外壳程序-但是，如果最重要的内容<i>不在</i> POSIX上，则兼容性有什么好处？ <br><br><h3> 当您真的要折线的特殊情况 </h3><br> 使用<code>\v</code>作为数据分隔符的示例（请注意第二次出现）： <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 这样，我们避免了模板扩展，即使数据分隔符为<code>\n</code> ，该方法仍然有效。 如果最后一个元素是空格，则第二次出现的数据分隔符将保护最后一个元素。 出于某种原因，应该先使用<code>-d</code>选项，因此<code>-rad ''</code>选项<code>-rad ''</code>诱人，但无效。 由于在这种情况下read返回一个非零值，因此如果启用，则应防止errexit（ <code>|| true</code> ）。 在bash 4.0、4.1、4.2、4.3和4.4中进行了测试。 <br><br>  bash 4.4的替代方法： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1> 在哪里启动bash脚本 </h1><br> 从这样的事情： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br> 这包括： <br><br><ul><li> 舍邦： <br><ul><li> 可移植性问题： <code>env</code>的绝对路径对于可移植性可能比<code>bash</code>的绝对路径更好。 您可以看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NixOS</a>的示例。  POSIX需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">env</a> ，但不需要bash。 </li><li> 安全问题：对于没有语言的用户， <code>-euo pipefail</code>不会接受<code>-euo pipefail</code>类的选项！ 使用<code>env</code>重定向时，这变得不可能，但是即使您的爆炸以<code>#!/bin/bash</code>开头，也不是影响脚本值的参数的位置，因为可以覆盖它们，这将使错误地执行脚本成为可能。 但是，作为奖励，可以重新定义不影响脚本值的选项，例如<code>set -x</code> （如果使用的话）。 </li></ul></li><li> 通过<code>set -u</code>功能检查，我们需要从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非官方的Bash严格模式中</a>获得什么。 我们不需要所有严格的Bash模式，因为shellcheck / shellharden兼容性意味着引用所有严格的内容。 此外，在Bash 4.3及更早版本中<b>不应使用</b> <code>set -u</code>选项。 由于此选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将空数组视为</a>那些版本中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">丢弃的</a>数组，因此不能将数组用于此处描述的目的。 使用数组是本指南中第二个最重要的技巧（在引号后），并且是我们牺牲与POSIX兼容性的唯一原因，因此这绝不是不可接受的：要么根本不使用<code>set -u</code>要么不使用Bash 4.4或另一个普通的Shell（如Zsh）。 说起来容易做起来难，因为有人可能仍会在旧版的Bash中运行您的脚本。 幸运的是，所有与<code>set -u</code>一起使用的东西都可以在没有它的情况下工作（对于<code>set -e</code>您不能这么说）。 这就是使用版本检查很重要的原因。 注意以下假设：测试和开发是在与Bash 4.4兼容的shell中进行的（因此对<code>set -u</code>方面进行了测试）。 如果这使您感到困扰，则另一种选择是拒绝兼容性（版本验证失败时脚本将失败），或拒绝<code>set -u</code> 。 </li><li> 如果<code>*.txt</code>未找到文件， <code>shopt -s nullglob</code>强制<code>for f in *.txt</code>正常工作。 默认行为（aka <i>passglob</i> ）不变地传递模板，如果结果为零，则出于多种原因这很危险。 对于<i>globstar，</i>这将激活递归查找。 替换比<code>find</code>更容易使用。 因此使用它。 </li></ul><br> 但不是： <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li> 将<i>内部字段定界符设置</i>为空字符串将无法拆分单词。 听起来像是完美的解决方案。 不幸的是，这是对引号变量和命令替换的不完全替代，并且由于您将使用引号，因此它什么也没有。 之所以仍然需要使用引号，是因为否则空字符串会变成空数组（如<code>test $x = ""</code> ），并且仍然可以进行间接模板扩展。 此外，此变量的问题还会导致<code>read</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>命令出现问题，这会破坏<code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>构造<code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> 。 </li><li> 模板扩展名被禁用：不仅是臭名昭著的间接扩展名，而且还有麻烦的直接扩展名，正如我所说，您应该使用它。 因此很难接受。 对于shellcheck / shellharden兼容脚本，这也是完全可选的。 </li><li> 与<i>nullglob</i>不同， <i>failglob</i>失败，结果为空。 尽管对于大多数命令来说这是有意义的，例如<i>rm-</i> <code>rm -- *.txt</code> （因为对于大多数命令来说，仍然不希望执行结果为零），但是显然只有在您不希望结果为零<i>时才</i>可以使用<i>failglob</i> 。 这意味着，除非您假设相同，否则通常不会在命令参数中放置组模板。 但是，总会发生的事情是使用<i>nullglob</i>并将模板扩展为可以接受它们的构造中的null参数，例如循环或将值分配给数组（ <code>txt_files=(*.txt)</code> ）。 </li></ul><br><h1> 如何完成bash脚本 </h1><br> 脚本退出状态是最后执行的命令的状态。 确保它代表真正的成功或失败。 <br><br> 最糟糕的事情是在脚本末尾以AND列表的形式将解决方案置于不相关的条件下。 如果条件为假，则最后执行的命令将为条件本身。 <br><br> 对于errexit，绝不会首先使用AND列表形式的条件。 如果不使用errexit，则即使对于最后一个命令也要考虑处理错误，因此，如果将其他代码添加到脚本中，则不会掩盖其退出状态。 <br><br> 不好： <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br> 好（errexit选项）： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br> 良好（错误处理选项）： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1> 如何使用errexit </h1><br> 像<code>set -e</code>一样。 <br><br><h3> 程序级延迟清除 </h3><br> 如果errexit可以正常工作，请使用它在出口上安装所有必要的清除程序。 <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3> 捕获：errexit在命令参数中被忽略 </h3><br> 这是一个非常棘手的分支“炸弹”，对此的理解对我来说非常有价值。 我的构建脚本在不同的开发机器上都可以正常工作，但是将构建服务器放在了膝盖上： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br> 正确（任务中的命令替换）： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br> 警告： <code>local</code>和<code>export</code>内置命令仍然是命令，因此这仍然是错误的： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br> 在这种情况下，ShellCheck仅警告诸如<code>local</code>特殊命令。 <br><br> 要使用<code>local</code> ，请将声明与作业分开： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3> 捕获：errexit被忽略，具体取决于调用方的上下文 </h3><br> 有时POSIX太糟糕了。 如果调用方检查其成功，则Errexit在函数，组命令甚至子Shell中都将被忽略。 所有这些示例均显示出<code>Unreachable</code> and <code>Great success</code> ，尽管看起来似乎很奇怪。 <br><br> 子壳： <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br> 组队： <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br> 功能： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br> 因此，带有errexit的bash实际上不适合链接：是的， <i>可以</i>包装errexit函数以使其起作用，但是怀疑节省的精力（在显式错误处理上）是否值得。 相反，请考虑拆分为完全自主的脚本。 <br><br><h1> 避免使用不正确的引号调用外壳 </h1><br> 从其他编程语言调用命令时，最容易犯错误并隐式调用Shell。 如果此shell命令是静态的，则很好-它可以工作，也可以不工作。 但是，如果您的程序以某种方式处理了这些行以构建此命令，那么您需要了解-您正在<b>生成shell脚本</b> ！ 我很少要这样做，很累，要正确地安排所有事情： <br><br><ul><li> 引用每个论点； </li><li> 转义参数中的相应字符。 </li></ul><br> 无论您使用哪种编程语言，至少都有三种方法可以正确地建立团队。 按优先顺序： <br><br><h3> 计划A：不带壳 </h3><br> 如果这只是一个带有参数的命令（也就是说，没有诸如管道传递或重定向之类的外壳函数），则选择一个数组选项。 <br><br><ul><li> 错误（python3）： <code>subprocess.check_call('rm -rf ' + path)</code> </li><li> 良好（python3）： <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br> 错误（C ++）： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br> 良好（C / POSIX），减去错误处理： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3> 计划B：静态Shell脚本 </h3><br> 如果需要外壳，则将参数设为参数。 您可能会认为在自己的文件中编写特殊的Shell脚本并访问它很麻烦，直到您看到这样的窍门： <br><br> 错误（python3）： <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br> 良好（python3）： <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br> 你能注意到shell脚本吗？ <br><br> 没错，printf命令被重定向。 请注意正确引用的带编号的参数。 实施静态Shell脚本很好。 <br><br> 这些示例在Docker中运行，因为否则它们不会那么有用，但是Docker还是一个很好的示例，该命令可以基于参数运行其他命令。 与Ssh不同，我们将在后面看到。 <br><br><h3> 最后选择：行处理 </h3><br> 如果它<i>应该</i>是一个字符串（例如，因为它必须通过<code>ssh</code>起作用），则不能绕过它。 您将必须引用每个参数，并转义退出这些引用所需的任何字符。 最简单的方法是切换到单引号，因为它们具有最简单的转义规则。 只有一个规则： <code>'</code> → <code>'\"</code> 。 <br><br> 典型的单引号文件名： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br> 如何使用此技巧安全地执行ssh命令？ 这是不可能的！ 好吧，这是“经常正确”的解决方案： <br><br><ul><li>  “通常正确”的解决方案（python3）： <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br> 我们自己必须将所有参数组合成一个字符串，以使Ssh不会做错：如果尝试传递多个ssh参数，它将开始以欺骗性的方式组合不带引号的参数。 <br><br> 通常不可能这样做的原因是，正确的决定取决于另一端用户的偏好，即远程外壳，它可以是任何东西。 基本上，甚至可能是你妈妈。 假定远程外壳是bash或另一个POSIX兼容外壳，但<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此阶段不兼容fish</a>是“通常正确的”。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413117/">https://habr.com/ru/post/zh-CN413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413105/index.html">物联网提供商的说明。 LoraWAN中的激活和安全性</a></li>
<li><a href="../zh-CN413107/index.html">Svelto.ECS项目Wiki的翻译。 适用于Unity3D的ECS框架</a></li>
<li><a href="../zh-CN413109/index.html">如何构建SaaS产品集成平台：Poster Cloud Checkout体验</a></li>
<li><a href="../zh-CN413111/index.html">STM32 + NetBeans =？</a></li>
<li><a href="../zh-CN413113/index.html">类JavaScript JavaScript序列化支持</a></li>
<li><a href="../zh-CN413119/index.html">上周第317天（2018年5月28日至6月3日）的前端世界摘要</a></li>
<li><a href="../zh-CN413121/index.html">莫斯科接班照片之旅</a></li>
<li><a href="../zh-CN413123/index.html">加入NoSQL数据库</a></li>
<li><a href="../zh-CN413125/index.html">基因疗法为肌肉萎缩的小患者提供了生存的机会</a></li>
<li><a href="../zh-CN413127/index.html">关于虚拟机管理程序的实际性能的几句话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>