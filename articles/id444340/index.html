<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜóÔ∏è ü§≠ üòπ Fitur menggunakan tipe data Simbol dalam JavaScript ü§í üí° üí≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Karakter primitif adalah salah satu inovasi standar ES6, yang membawa beberapa fitur berharga ke JavaScript. Simbol yang diwakili oleh tipe data Simbo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur menggunakan tipe data Simbol dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444340/">  Karakter primitif adalah salah satu inovasi standar ES6, yang membawa beberapa fitur berharga ke JavaScript.  Simbol yang diwakili oleh tipe data Simbol sangat berguna ketika digunakan sebagai pengidentifikasi untuk properti objek.  Sehubungan dengan skenario penerapan mereka, muncul pertanyaan tentang apa yang mereka bisa, apa yang tidak bisa dilakukan oleh garis itu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br>  Dalam materi, terjemahan yang kami terbitkan hari ini, kami akan berbicara tentang tipe data Simbol dalam JavaScript.  Kami akan mulai dengan meninjau beberapa fitur JavaScript yang perlu Anda navigasikan untuk menangani simbol. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informasi awal</font> </h2><br>  Dalam JavaScript, sebenarnya, ada dua jenis nilai.  Tipe pertama - nilai primitif, objek kedua (mereka juga menyertakan fungsi).  Nilai-nilai primitif meliputi tipe data sederhana seperti angka (ini termasuk semuanya mulai dari bilangan bulat hingga angka floating-point, nilai <code>Infinity</code> dan <code>NaN</code> ), nilai logis, string, nilai <code>undefined</code> dan <code>null</code> .  Perhatikan bahwa ketika memeriksa <code>typeof null === 'object'</code> menghasilkan <code>true</code> , <code>null</code> adalah nilai primitif. <br><br>  Nilai-nilai primitif tidak dapat diubah.  Mereka tidak bisa diubah.  Tentu saja, Anda dapat menulis sesuatu yang baru dalam variabel yang menyimpan nilai primitif.  Misalnya, ini menulis nilai baru ke variabel <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br>  Tetapi pada saat yang sama, tidak ada perubahan (mutasi) dari nilai numerik primitif <code>1</code> . <br><br>  Dalam beberapa bahasa, misalnya, dalam C, ada konsep melewati argumen fungsi dengan referensi dan nilai.  JavaScript juga memiliki hal serupa.  Bagaimana tepatnya pekerjaan dengan data diatur tergantung pada jenisnya.  Jika nilai primitif yang diwakili oleh variabel tertentu diteruskan ke fungsi, dan kemudian diubah dalam fungsi ini, nilai yang disimpan dalam variabel asli tidak berubah.  Namun, jika Anda meneruskan nilai objek yang diwakili oleh variabel ke fungsi dan memodifikasinya, maka apa yang disimpan dalam variabel ini juga akan berubah. <br><br>  Perhatikan contoh berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br>  Nilai-nilai primitif (dengan pengecualian <code>NaN</code> misterius, yang tidak sama dengan dirinya sendiri) selalu berubah menjadi sama dengan nilai-nilai primitif lainnya yang terlihat seperti diri mereka sendiri.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Namun, konstruksi nilai objek yang terlihat sama secara lahiriah tidak akan mengarah pada fakta bahwa entitas akan diperoleh, jika dibandingkan, kesetaraan mereka satu sama lain akan terungkap.  Anda dapat memverifikasi ini dengan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br>  Objek memainkan peran mendasar dalam JavaScript.  Mereka digunakan secara harfiah di mana-mana.  Sebagai contoh, mereka sering digunakan dalam bentuk koleksi kunci / nilai.  Tetapi sebelum munculnya tipe data <code>Symbol</code> , hanya string yang dapat digunakan sebagai kunci objek.  Ini adalah batasan serius pada penggunaan benda-benda dalam bentuk koleksi.  Saat mencoba menetapkan nilai non-string sebagai kunci objek, nilai ini dilemparkan ke string.  Anda dapat memverifikasi ini dengan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br>  Ngomong-ngomong, meskipun ini membawa kita sedikit jauh dari topik karakter, saya ingin mencatat bahwa struktur data <code>Map</code> dibuat untuk memungkinkan penggunaan data kunci / nilai menyimpan dalam situasi di mana kunci bukan string. <br><br><h2>  <font color="#3AC1EF">Apa itu simbol?</font> </h2><br>  Sekarang kami telah menemukan fitur nilai primitif dalam JavaScript, kami akhirnya siap untuk mulai berbicara tentang karakter.  Simbol adalah makna primitif yang unik.  Jika Anda mendekati simbol dari posisi ini, Anda akan melihat bahwa simbol dalam hal ini mirip dengan objek, karena penciptaan beberapa contoh simbol akan mengarah pada penciptaan nilai yang berbeda.  Namun, simbol, adalah nilai-nilai primitif yang tidak berubah.  Berikut ini adalah contoh bekerja dengan karakter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Saat membuat turunan karakter, Anda dapat menggunakan argumen string pertama opsional.  Argumen ini adalah deskripsi simbol yang dimaksudkan untuk digunakan dalam debugging.  Nilai ini tidak mempengaruhi simbol itu sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Simbol sebagai kunci untuk properti objek</font> </h2><br>  Simbol dapat digunakan sebagai kunci properti untuk objek.  Ini sangat penting.  Berikut ini adalah contoh menggunakannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br>  Harap dicatat bahwa kunci yang ditentukan oleh karakter tidak dikembalikan ketika metode <code>Object.keys()</code> .  Kode yang ditulis sebelum penampilan karakter di JS tidak tahu apa-apa tentang mereka, akibatnya, informasi tentang kunci objek yang diwakili oleh karakter tidak boleh dikembalikan oleh metode <code>Object.keys()</code> kuno. <br><br>  Pada pandangan pertama, sepertinya fitur karakter di atas memungkinkan Anda untuk menggunakannya untuk membuat properti pribadi objek JS.  Di banyak bahasa pemrograman lain, Anda bisa membuat properti objek tersembunyi menggunakan kelas.  Kurangnya fitur ini telah lama dianggap sebagai salah satu kekurangan JavaScript. <br><br>  Sayangnya, kode yang berfungsi dengan objek dapat dengan bebas mengakses kunci string mereka.  Kode juga dapat mengakses kunci yang ditentukan oleh karakter, bahkan, bahkan jika kode dari mana mereka bekerja dengan objek tidak memiliki akses ke karakter yang sesuai.  Misalnya, menggunakan metode <code>Reflect.ownKeys()</code> , Anda bisa mendapatkan daftar semua kunci objek, baik yang string maupun yang karakter: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br>  Perhatikan bahwa pekerjaan saat ini sedang berlangsung untuk melengkapi kelas dengan kemampuan untuk menggunakan properti pribadi.  Fitur ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bidang Pribadi</a> .  Benar, itu tidak mempengaruhi sepenuhnya semua objek, merujuk hanya kepada mereka yang dibuat berdasarkan kelas yang disiapkan sebelumnya.  Dukungan untuk bidang pribadi sudah tersedia di browser Chrome versi 72 dan lebih lama. <br><br><h2>  <font color="#3AC1EF">Mencegah tabrakan nama properti objek</font> </h2><br>  Simbol, tentu saja, tidak menambah kemampuan JavaScript untuk membuat properti pribadi objek, tetapi mereka adalah inovasi berharga dalam bahasa karena alasan lain.  Yaitu, mereka berguna dalam situasi ketika perpustakaan tertentu perlu menambahkan properti ke objek yang dijelaskan di luar mereka, dan pada saat yang sama tidak takut tabrakan nama-nama properti objek. <br><br>  Pertimbangkan contoh di mana dua pustaka yang berbeda ingin menambahkan metadata ke objek.  Mungkin kedua perpustakaan perlu melengkapi objek dengan beberapa pengidentifikasi.  Jika Anda hanya menggunakan sesuatu seperti string <code>id</code> dari dua huruf untuk nama properti seperti itu, Anda mungkin menghadapi situasi di mana satu perpustakaan menimpa properti yang ditentukan oleh yang lain. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Jika kita menggunakan simbol dalam contoh kita, maka setiap perpustakaan dapat menghasilkan, setelah inisialisasi, simbol yang dibutuhkan.  Simbol-simbol ini kemudian dapat digunakan untuk menetapkan properti ke objek dan untuk mengakses properti ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Dengan melihat skenario seperti itu Anda bisa mendapatkan keuntungan dari penampilan karakter dalam JavaScript. <br><br>  Namun, mungkin ada pertanyaan tentang penggunaan perpustakaan untuk nama-nama properti objek, string acak atau string dengan struktur yang kompleks, termasuk, misalnya, nama perpustakaan.  String serupa dapat membentuk sesuatu seperti ruang nama untuk pengidentifikasi yang digunakan oleh perpustakaan.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br>  Secara umum, Anda bisa melakukannya.  Pendekatan serupa, pada kenyataannya, sangat mirip dengan apa yang terjadi ketika menggunakan simbol.  Dan jika, menggunakan pengidentifikasi acak atau ruang nama, beberapa perpustakaan tidak akan menghasilkan, secara kebetulan, nama properti yang sama, maka tidak akan ada masalah dengan nama. <br><br>  Pembaca yang cerdik akan mengatakan sekarang bahwa dua pendekatan yang dipertimbangkan untuk menamai properti objek tidak sepenuhnya setara.  Nama properti yang dihasilkan secara acak atau menggunakan ruang nama memiliki kelemahan: kunci yang sesuai sangat mudah ditemukan, terutama jika kode mencari kunci objek atau mengurutkannya.  Perhatikan contoh berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br>  Jika simbol digunakan untuk nama kunci dalam situasi ini, maka representasi JSON objek tidak akan mengandung nilai simbol.  Kenapa begitu?  Faktanya adalah fakta bahwa tipe data baru telah muncul dalam JavaScript tidak berarti bahwa perubahan telah dibuat untuk spesifikasi JSON.  JSON mendukung, sebagai kunci properti, hanya string.  Saat membuat serial objek, tidak ada upaya yang dilakukan untuk mewakili karakter dengan cara khusus apa pun. <br><br>  Masalah yang dipertimbangkan untuk mendapatkan nama properti di representasi JSON objek dapat diselesaikan dengan menggunakan <code>Object.defineProperty()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br>  Kunci string yang "disembunyikan" dengan mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskriptor</a> <code>enumerable</code> mereka ke perilaku <code>false</code> dalam cara yang sama seperti kunci yang diwakili oleh karakter.  Keduanya tidak ditampilkan ketika <code>Object.keys()</code> dipanggil, dan keduanya dapat dideteksi menggunakan <code>Reflect.ownKeys()</code> .  Begini tampilannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br>  Di sini, saya harus mengatakan, kita hampir menciptakan kembali kemungkinan simbol, menggunakan cara lain dari JS.  Secara khusus, kedua kunci yang diwakili oleh simbol dan kunci pribadi tidak termasuk dalam representasi JSON dari suatu objek.  Keduanya dapat dikenali dengan merujuk pada metode <code>Reflect.ownKeys()</code> .  Akibatnya, keduanya tidak dapat disebut benar-benar pribadi.  Jika kami berasumsi bahwa beberapa nilai acak atau ruang nama pustaka digunakan untuk menghasilkan nama kunci, maka ini berarti bahwa kami menghilangkan risiko tabrakan nama. <br><br>  Namun, ada satu perbedaan kecil antara menggunakan nama simbol dan nama yang dibuat menggunakan mekanisme lain.  Karena string tidak dapat diubah, dan karakter dijamin unik, selalu ada kemungkinan seseorang, setelah melalui semua kemungkinan kombinasi karakter dalam string, akan menyebabkan benturan nama.  Dari sudut pandang matematika, ini berarti bahwa karakter benar-benar memberi kita kesempatan berharga yang tidak dimiliki string. <br><br>  Dalam Node.js, saat memeriksa objek (misalnya, menggunakan <code>console.log()</code> ), jika metode objek yang disebut <code>inspect</code> terdeteksi, maka metode ini digunakan untuk mendapatkan representasi string objek dan kemudian menampilkannya di layar.  Sangat mudah untuk memahami bahwa setiap orang tidak dapat memperhitungkan hal ini, oleh karena itu perilaku sistem tersebut dapat menyebabkan panggilan ke metode objek <code>inspect</code> , yang dirancang untuk menyelesaikan masalah yang tidak terkait dengan pembentukan representasi string dari objek.  Fitur ini tidak digunakan lagi dalam Node.js 10, dalam versi 11 metode dengan nama yang sama diabaikan saja.  Sekarang, untuk mengimplementasikan fitur ini, <code>require('util').inspect.custom</code> .  Ini berarti bahwa tidak seorang pun akan pernah dapat mengganggu sistem secara tidak sengaja dengan membuat metode objek yang disebut <code>inspect</code> . <br><br><h2>  <font color="#3AC1EF">Imitasi properti pribadi</font> </h2><br>  Berikut ini pendekatan menarik yang dapat Anda gunakan untuk mensimulasikan properti pribadi objek.  Pendekatan ini melibatkan penggunaan fitur JavaScript modern lainnya - objek proxy.  Objek tersebut berfungsi sebagai pembungkus untuk objek lain yang memungkinkan pemrogram untuk campur tangan dalam tindakan yang dilakukan dengan objek ini. <br><br>  Objek proxy menawarkan banyak cara untuk mencegat tindakan yang dilakukan pada objek.  Kami tertarik pada kemampuan untuk mengontrol operasi tombol membaca suatu objek.  Kami tidak akan membahas detail tentang objek proxy di sini.  Jika Anda tertarik, lihat publikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Kita bisa menggunakan proxy untuk mengontrol properti objek apa yang terlihat dari luar.  Dalam hal ini, kami ingin membuat proxy yang menyembunyikan dua properti yang kami tahu.  Satu memiliki nama string <code>_favColor</code> , dan yang kedua diwakili oleh karakter yang ditulis ke variabel <code>favBook</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br>  Berurusan dengan properti yang namanya diwakili oleh string <code>_favColor</code> tidak sulit: cukup baca kode sumber.  Kunci dinamis (seperti tombol uuid yang kita lihat di atas) dapat dicocokkan dengan brute force.  Tetapi tanpa referensi ke simbol, Anda tidak dapat mengakses nilai <code>Metro 2033</code> dari objek <code>proxy</code> . <br><br>  Perlu dicatat bahwa di Node.js ada satu fitur yang melanggar privasi objek proxy.  Fitur ini tidak ada dalam bahasa itu sendiri, jadi tidak relevan untuk runtime JS lainnya, seperti browser.  Faktanya adalah bahwa fitur ini memungkinkan Anda untuk mengakses objek yang tersembunyi di belakang objek proxy, jika Anda memiliki akses ke objek proxy.  Berikut adalah contoh yang menunjukkan kemampuan untuk mem-bypass mekanisme yang ditunjukkan dalam cuplikan kode sebelumnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br>  Sekarang, untuk mencegah penggunaan fitur ini dalam contoh spesifik Node.js, Anda harus memodifikasi objek global <code>Reflect</code> atau pengikatan proses <code>util</code> .  Namun, ini adalah tugas lain.  Jika Anda tertarik, lihat posting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> tentang melindungi API berbasis JavaScript. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami berbicara tentang tipe data <code>Symbol</code> , tentang fitur apa yang disediakan untuk pengembang JavaScript, dan tentang mekanisme bahasa apa yang dapat digunakan untuk mensimulasikan fitur ini. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan simbol dalam proyek JavaScript Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444340/">https://habr.com/ru/post/id444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444328/index.html">Redesign UI sering buang-buang waktu</a></li>
<li><a href="../id444330/index.html">Serverless CMS akhirnya merupakan pesaing yang layak untuk Wordpress</a></li>
<li><a href="../id444332/index.html">Keamanan dan katering informasi: bagaimana manajer berpikir tentang produk TI</a></li>
<li><a href="../id444336/index.html">Daftar tangkapan cepat: apa perbedaan antara tautan yang lemah, kuat dan tidak dimiliki?</a></li>
<li><a href="../id444338/index.html">Enkapsulasi dalam Python 3</a></li>
<li><a href="../id444342/index.html">Mengembangkan aplikasi JavaScript sederhana dan modern menggunakan Webpack dan teknologi web canggih</a></li>
<li><a href="../id444344/index.html">10 langkah untuk proyek Python yang sukses</a></li>
<li><a href="../id444346/index.html">GraphQL dan Golang</a></li>
<li><a href="../id444348/index.html">Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas?</a></li>
<li><a href="../id444350/index.html">Untuk beberapa alasan MVP (produk minimum yang layak) tidak dimulai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>