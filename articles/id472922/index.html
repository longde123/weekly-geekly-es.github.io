<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘§ğŸ¿ ğŸšŠ ğŸ™‹ğŸ¾ Programmer defender lebih kuat dari entropi ğŸ§”ğŸ» ğŸ—ï¸ âœ‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Â© Dragon Ball. Goku. 

 Programmer-defender kapan saja dan di mana saja dalam kode mengharapkan munculnya masalah potensial dan menulis kode sedemikia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmer defender lebih kuat dari entropi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/472922/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bu/kn/5n/bukn5ndtci4czpuwtbu3nsihkyi.jpeg"></div>  <i>Â© Dragon Ball.</i>  <i>Goku.</i> <br><br>  Programmer-defender kapan saja dan di mana saja dalam kode mengharapkan munculnya masalah potensial dan menulis kode sedemikian rupa untuk melindungi diri mereka dari mereka terlebih dahulu.  Dan jika Anda tidak dapat membela diri terhadap masalah, maka setidaknya pastikan bahwa konsekuensi dan dampaknya terhadap pengguna minimal. <br><br>  Saya ingat efek <i>FlashForward</i> dari film Hollywood ketika protagonis melihat bencana yang akan datang dan tetap sangat tenang, karena dia tahu sebelumnya bahwa itu akan terjadi dan memiliki perlindungan dari itu.  Gagasan di balik pemrograman defensif adalah untuk melindungi diri Anda dari masalah yang sulit atau tidak mungkin diprediksi.  Seorang programmer keamanan mengharapkan kesalahan terjadi di mana saja dalam sistem dan pada waktu tertentu untuk mencegahnya sebelum menyebabkan kerusakan.  Namun, tujuannya bukan untuk membuat sistem yang tidak pernah crash, itu masih mustahil.  Tujuannya adalah untuk menciptakan sistem yang <b>crash dengan anggun</b> jika terjadi masalah yang tidak terduga. <br><br>  Mari kita pahami lebih detail apa yang termasuk dalam konsep "jatuh anggun." <br><br><ul><li>  <b>Jatuh cepat.</b>  Dalam hal terjadi kesalahan tak terduga, semua operasi harus diselesaikan segera, terutama jika perhitungan selanjutnya sulit atau dapat menyebabkan korupsi data. </li><li>  <b>Jatuh dengan rapi.</b>  Jika terjadi kesalahan, program harus membebaskan semua sumber daya, menghapus kunci, menghapus file sementara dan setengah direkam, menutup koneksi.  Tunggu selesainya operasi kritis, yang interupsi yang dapat menyebabkan hasil yang tidak terduga.  Atau cara aman untuk menghentikan operasi ini. </li><li>  <b>Jatuh dengan jelas dan indah.</b>  Jika ada yang rusak, pesan kesalahan harus sederhana, singkat dan berisi detail penting dari konteks sistem tempat kesalahan terjadi.  Ini akan membantu tim yang bertanggung jawab atas sistem untuk mencari tahu masalah secepat mungkin dan memperbaikinya. </li></ul><a name="habracut"></a><br>  Tapi Anda mungkin punya pertanyaan. <br><br>  Mengapa membuang waktu untuk masalah yang mungkin timbul di masa depan?  <b>Sekarang</b> mereka tidak ada di sana, kodenya berfungsi dengan sempurna.  Selain itu, masalah mungkin tidak pernah terjadi sama sekali.  Bagaimanapun, profesional tidak melakukan rekayasa demi rekayasa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YAGNI</a> - Anda tidak akan membutuhkannya)! <br><br><h2>  Yang utama adalah pragmatisme </h2><br>  Andrew Hunt dalam buku "Programmer-pragmatis" memberikan definisi pemrograman defensif berikut - " <b>paranoia pragmatis</b> ." <br><br>  Lindungi kode Anda dari: <br><br><ul><li>  kesalahan sendiri; </li><li>  kesalahan orang lain; </li><li>  kesalahan dan kegagalan dalam sistem lain yang terintegrasi dengan Anda; </li><li>  kesalahan besi, lingkungan, dan platform tempat aplikasi Anda bekerja. </li></ul><br>  Mari kita bahas beberapa metode taktis dan strategis pemrograman defensif, berikut ini yang akan menciptakan sistem yang andal dan dapat diprediksi yang tahan terhadap kegagalan sewenang-wenang. <br><br>  Beberapa tips mungkin tampak "kapten", tetapi dalam praktiknya, banyak pengembang bahkan tidak mengikuti mereka.  Tetapi jika Anda mematuhi praktik dan pendekatan sederhana, ini akan secara signifikan meningkatkan stabilitas sistem Anda. <br><br><h2>  Jangan percaya siapapun </h2><br>  Data pengguna tidak dapat diandalkan secara default.  Pengguna sering salah memahami apa yang tampak jelas bagi kami (sebagai pengembang sistem).  Harapkan input yang salah dan selalu periksa. <br><br>  Periksa juga jumlah input.  Mungkin saja pengguna mengirim terlalu banyak.  Pada saat yang sama, dari sudut pandang logika bisnis, ini adalah skenario yang benar.  Tapi itu bisa menyebabkan pemrosesan terlalu lama.  Apa yang bisa dilakukan dengan ini?  Misalnya, jalankan secara tidak sinkron, jika jumlah data input melebihi batas tertentu dan spesifik bisnis memungkinkan Anda untuk memproses data di latar belakang. <br><br>  Pengaturan aplikasi (misalnya, file konfigurasi) juga tunduk pada tampilan data yang salah di dalamnya.  Seringkali, pengaturan program disimpan dalam JSON, YAML, XML, INI dan format lainnya.  Karena semua ini adalah file teks, orang harus berharap bahwa cepat atau lambat seseorang akan mengubah sesuatu di dalamnya, dan program Anda akan mulai bekerja secara tidak benar.  Itu bisa berupa pengguna akhir atau seseorang dari tim Anda. <br><br>  Basis data, file, penyimpanan terpusat dari konfigurasi, registri - semua tempat ini dapat diakses oleh orang lain, dan cepat atau lambat mereka akan mengubah sesuatu di sana ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Murphy</a> ). <br><br><h2>  Inlet sampah â†’ inlet sampah </h2><br>  Input yang lulus validasi dan mulai diproses harus bersih jika Anda ingin kode Anda melakukan apa yang Anda harapkan darinya. <br><br>  Namun, praktik yang baik untuk melakukan pemeriksaan validasi data tambahan, termasuk ketika mereka sudah mulai diproses.  Di tempat-tempat kritis (penagihan, otorisasi, data pribadi dan rahasia, dll.) Ini hampir merupakan persyaratan wajib.  Ini diperlukan agar dalam kasus bug dalam kode atau masalah dengan validator data input, hentikan aliran eksekusi secepat mungkin.  Sulit untuk membuat validasi kualitas dengan memeriksa semua skenario kesalahan yang mungkin terjadi, sehingga Anda dapat menggunakan metode yang lebih sederhana untuk memvalidasi bahwa program masih mengeksekusi dengan benar - pernyataan dan pengecualian. <br><br>  Paranoid yang sehat adalah fitur khas semua pengembang profesional.  Tetapi sangat penting untuk mencari keseimbangan optimal dan memahami kapan solusinya sudah cukup baik. <br><br><h2>  Pisahkan konfigurasi di sekitar lingkungan </h2><br>  Penyebab umum dari masalah adalah pemisahan konfigurasi yang tidak memadai antara lingkungan atau tidak adanya pemisahan seperti itu. <br><br>  Ini dapat menyebabkan banyak masalah, misalnya: <br><br><ul><li>  lingkungan pengujian mulai membaca dan / atau menulis data dari produksi, basis data, antrian, dan sumber daya lainnya; </li><li>  lingkungan pengujian menggunakan integrasi dan layanan eksternal dengan akun produksi; <br></li><li>  pencampuran statistik, metrik, kesalahan dari lingkungan yang berbeda; <br></li><li>  pelanggaran keamanan (pengembang, penguji dan anggota tim lainnya mendapatkan akses ke sumber daya produksi); </li><li>  bug yang sulit diselidiki pada produksi (misalnya, bagian dari pesan dalam antrian hilang karena lingkungan pengujian mulai membacanya). </li></ul><br>  Ini hanya contoh, daftar lengkap masalah yang mungkin disebabkan oleh pemisahan konfigurasi yang tidak bertanggung jawab hampir tidak ada habisnya dan tergantung pada spesifikasi proyek. <br><br>  Pemisahan data konfigurasi oleh lingkungan yang bertanggung jawab dapat secara signifikan mengurangi kemungkinan seluruh kelas masalah yang terkait dengan: <br><br><ul><li>  keamanan </li><li>  keandalan; </li><li>  dukungan dan penyebaran (Insinyur DevOps akan berterima kasih). </li></ul><br>  Selain itu, praktik yang baik untuk menyimpan data rahasia (kunci, token, kata sandi) di tempat terpisah yang dirancang khusus untuk menyimpan dan memproses rahasia.  Sistem seperti itu mengenkripsi data dengan aman, memiliki sarana yang fleksibel untuk mengelola hak akses, dan juga memungkinkan Anda untuk dengan cepat mengubah kunci jika telah dikompromikan.  Dalam hal ini, Anda tidak perlu membuat perubahan pada kode dan menggunakan kembali aplikasi.  Ini sangat penting untuk sistem yang bekerja dengan transaksi keuangan, data rahasia atau pribadi. <br><br><h2>  Ingat efek cascading </h2><br>  Penyebab umum jatuhnya sistem besar dan kompleks adalah efek cascading.  Kerusakan atau degradasi fungsi salah satu bagian sistem terjadi, dan satu per satu subsistem lain yang terkait dengannya mulai gagal.  Dihamburkan sampai seluruh sistem menjadi sepenuhnya tidak dapat diakses. <br><br>  Beberapa trik perlindungan: <br><br><ul><li>  gunakan timeout progresif (eksponensial) dengan elemen acak; </li><li>  set nilai yang wajar untuk batas waktu koneksi dan batas waktu soket; </li><li>  meramalkan kemunduran di muka dalam kasus kegagalan layanan individu.  Lebih baik untuk sementara menurunkan beberapa fungsi, menonaktifkan layanan sama sekali, tetapi jangan mengambil risiko merusak seluruh sistem.  Tetapi bayangkan bahwa dalam kasus ini pengguna melihat pesan yang dimengerti dan tidak menakutkan, dan tim dukungan dan pengembangan secepatnya mencari tahu tentang masalah tersebut. </li></ul><br><h2>  Laporkan masalah dengan cepat </h2><br>  Semua sistem gagal.  Terkadang sesuatu yang aneh terjadi pada mereka yang diharapkan oleh para pencipta "setiap 10 tahun sekali."  Integrasi dan API eksternal secara berkala menjadi tidak tersedia atau merespons secara tidak benar.  Membuat kemunduran untuk semua kasus seperti itu seringkali sulit, panjang, atau tidak mungkin.  Antisipasi situasi ini sebelumnya dan laporkan secepat mungkin.  Masuk ke tingkat ERROR atau ke sistem pemantauan - begitu saja.  Menambahkan validasi tambahan ke pemeriksaan kesehatan bahkan lebih baik.  Untuk mengirim pesan dari kode ke Slack, Telegram, PagerDuty atau layanan lain yang secara instan akan memberi tahu tim Anda tentang masalah tersebut sangat ideal. <br><br>  Tetapi penting untuk memahami dengan jelas kapan masuk akal mengirim pesan secara langsung.  Hanya jika kesalahan, situasi yang mencurigakan atau atipikal dikaitkan dengan proses bisnis dan penting bahwa orang atau sekelompok orang tertentu dalam tim menerima pemberitahuan secepat mungkin dan dapat merespons. <br><br>  Semua masalah teknis dan penyimpangan lainnya harus ditangani dengan cara standar - pemantauan, peringatan, penebangan. <br><br><h2>  Tembolok yang sering digunakan dan / atau data terkini </h2><br>  Program dan orang memiliki satu kesamaan - mereka cenderung menggunakan kembali data yang sering digunakan atau baru-baru ini ditemui.  Dalam sistem yang sangat dimuat, Anda harus selalu mengingat ini dan menyimpan data di tempat terpanas di sistem. <br><br>  Strategi caching sangat tergantung pada spesifikasi proyek dan data.  Jika data bisa berubah, ada kebutuhan untuk pembatalan cache.  Karena itu, pertimbangkan sebelumnya bagaimana Anda akan melakukan ini.  Dan pikirkan juga risiko apa yang mungkin terjadi jika data yang sudah ketinggalan zaman muncul di cache, cache tidak berfungsi, dll. <br><br><h2>  Ganti operasi yang mahal dengan yang murah </h2><br>  Bekerja dengan string adalah salah satu operasi paling umum dalam program apa pun.  Dan jika ini tidak dilakukan secara optimal, itu bisa menjadi operasi yang mahal.  Dalam berbagai bahasa pemrograman, spesifikasi bekerja dengan string mungkin berbeda-beda, tetapi Anda harus selalu mengingatnya. <br><br>  Dalam aplikasi besar dengan basis kode besar, kode yang ditulis bertahun-tahun yang lalu sering ditemukan bekerja tanpa kesalahan, tetapi tidak optimal dalam hal kinerja.  Seringkali, perubahan dangkal dalam struktur data dari array / daftar ke tabel hash memberikan dorongan serius (bahkan jika hanya di tempat lokal dalam kode). <br><br>  Terkadang Anda dapat meningkatkan kinerja dengan menulis ulang algoritme untuk menggunakan operasi bitwise.  Tetapi bahkan dalam kasus-kasus langka ketika dibenarkan, kodenya sangat kompleks.  Karena itu, ketika membuat keputusan, pertimbangkan keterbacaan kode dan fakta bahwa kode tersebut perlu didukung.  Hal yang sama berlaku untuk optimasi rumit lainnya: hampir selalu, kode seperti itu menjadi sulit dibaca dan sangat sulit untuk dipertahankan.  Jika Anda masih memutuskan optimisasi yang rumit, jangan lupa untuk menulis komentar yang menjelaskan <b>apa</b> yang ingin Anda lakukan dengan kode ini dan <b>mengapa</b> ditulis seperti itu. <br><br>  Pada saat yang sama, optimasi harus diperlakukan dengan pragmatisme yang sehat: <br><br><ul><li>  jika dibutuhkan Anda, sebagai pengembang, selama beberapa detik atau menit - masuk akal untuk segera melakukannya; </li><li>  jika lebih, masuk akal untuk melakukannya segera hanya ketika Anda 100% yakin akan kebutuhannya.  Dalam semua kasus lain, masuk akal untuk menunda, menulis dalam kode TODO, mengumpulkan lebih banyak informasi, berkonsultasi dengan kolega, dll. </li></ul><br><blockquote>  Optimalisasi prematur adalah akar dari segala kejahatan (Donald Knuth) <br></blockquote><br><h2>  Menulis ulang dalam bahasa tingkat yang lebih rendah </h2><br>  Ini adalah langkah ekstrem.  Bahasa tingkat rendah hampir selalu lebih cepat dibandingkan dengan bahasa tingkat yang lebih tinggi.  Tetapi solusi ini memiliki harga - mengembangkan program semacam itu lebih lama dan lebih sulit.  Terkadang, menulis ulang bagian-bagian penting dari sistem dalam bahasa tingkat rendah, Anda dapat mencapai peningkatan produktivitas yang serius.  Tetapi ada efek samping - biasanya solusi seperti itu hilang di lintas platform dan dukungan mereka lebih mahal.  Karena itu, buat keputusan dengan hati-hati. <br><br><h2>  Sendiri di lapangan bukan seorang pejuang </h2><br>  Sebagai kesimpulan, saya ingin mencatat satu hal yang lebih penting, mungkin yang paling penting.  Langkah-langkah yang kami pertimbangkan dalam paragraf sebelumnya hanya akan berfungsi jika semua anggota tim mematuhinya dan semua orang memiliki pemahaman tentang siapa yang bertanggung jawab atas apa dan apa yang perlu dilakukan jika terjadi situasi kritis.  Adalah penting bahwa setelah memperbaiki masalah, mengadakan pertemuan (Post Mortem) dengan semua orang yang tertarik dan mencari tahu mengapa masalah ini muncul dan apa yang dapat dilakukan untuk mencegah masalah ini terjadi di masa depan.  Dalam banyak kasus, perubahan teknis dan proses diperlukan.  Dengan setiap Post Mortem baru, sistem Anda akan menjadi lebih dapat diandalkan, tim akan lebih berpengalaman dan kohesif, dan entropi di alam semesta akan sedikit kurang;) <br><br>  <i>Artikel ini sebagian menggunakan bahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa Pemrograman Defensif adalah Cara Terbaik untuk Pengkodean yang Kuat</a> (Ravi Shankar Rajan).</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472922/">https://habr.com/ru/post/id472922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472908/index.html">Dagaz: Episodes (Bagian 2)</a></li>
<li><a href="../id472910/index.html">Temukan teks pada tanda dan paket menggunakan smartphone</a></li>
<li><a href="../id472912/index.html">Database ClickHouse untuk manusia, atau Teknologi Asing</a></li>
<li><a href="../id472916/index.html">Backend, pembelajaran mesin, dan tanpa server adalah yang paling menarik dari konferensi Habr Juli</a></li>
<li><a href="../id472918/index.html">ZX Spectrum di Rusia dan CIS: bagaimana pengejaran online berubah secara offline</a></li>
<li><a href="../id472926/index.html">Hukum percepatan pengembalian (bagian 1)</a></li>
<li><a href="../id472928/index.html">Layanan komputasi GPU yang sangat dimuat</a></li>
<li><a href="../id472930/index.html">Silicon Valley, Astrofisika, Mengukur Mode</a></li>
<li><a href="../id472932/index.html">IntelliJ IDEA Analisis Statis vs Pikiran Manusia</a></li>
<li><a href="../id472934/index.html">Apa itu Zero Trust? Model keamanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>