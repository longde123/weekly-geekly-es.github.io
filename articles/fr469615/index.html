<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛒 👩🏻‍⚖️ 🚴 Temps de haute précision: comment travailler avec des fractions de seconde en MySQL et PHP 🚄 🤷🏻 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois que je me suis surpris à penser que lorsque je travaillais avec le temps dans des bases de données, j'utilisais presque toujours du temps pré...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Temps de haute précision: comment travailler avec des fractions de seconde en MySQL et PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/469615/"><p><img src="https://habrastorage.org/webt/uu/43/0k/uu430kx8xpmnjcelv7obc41muik.jpeg"></p><br><p>  Une fois que je me suis surpris à penser que lorsque je travaillais avec le temps dans des bases de données, j'utilisais presque toujours du temps précis à la seconde simplement parce que j'étais habitué et que c'était l'option décrite dans la documentation et un grand nombre d'exemples.  Cependant, cette précision est désormais loin d'être suffisante pour toutes les tâches.  Les systèmes modernes sont complexes - ils peuvent être constitués de nombreuses parties, avoir des millions d'utilisateurs interagissant avec eux - et dans de nombreux cas, il est plus pratique d'utiliser une plus grande précision, dont le support existe depuis longtemps. </p><br><p>  Dans cet article, je parlerai des moyens d'utiliser le temps avec des parties fractionnaires d'une seconde dans MySQL et PHP.  Il a été conçu comme un tutoriel, donc le matériel est conçu pour un large éventail de lecteurs et, à certains endroits, répète la documentation.  La valeur principale devrait être que j'ai rassemblé dans un seul texte tout ce que vous devez savoir pour travailler avec ce temps dans MySQL, PHP et le framework Yii, et j'ai également ajouté des descriptions des problèmes non évidents que vous pourriez rencontrer. </p><br><p>  J'utiliserai le terme «temps de haute précision».  Dans la documentation MySQL, vous verrez le terme «secondes fractionnelles», mais sa traduction littérale semble étrange, mais je n'ai pas trouvé une autre traduction établie. </p><a name="habracut"></a><br><h2 id="kogda-stoit-ispolzovat-vremya-vysokoy-tochnosti">  Quand utiliser le temps de haute précision? </h2><br><p>  Pour commencer, je vais montrer une capture d'écran de la boîte de réception de ma boîte de réception, qui illustre bien l'idée: </p><br><p><img src="https://habrastorage.org/webt/bc/tg/gx/bctggxr0qbeetqe9hmmb4zjmbom.png" alt="Deux lettres d'un expéditeur"></p><br><p>  Les lettres sont la réaction d'une même personne à un événement.  Un homme a accidentellement appuyé sur le mauvais bouton, s'en est vite rendu compte et s'est corrigé.  En conséquence, nous avons reçu deux lettres envoyées à peu près en même temps, qui sont importantes pour trier correctement.  Si l'heure d'envoi est la même, il est possible que les lettres soient affichées dans le mauvais ordre et que le destinataire soit gêné, car alors il recevra le mauvais résultat pour lequel il comptera. </p><br><p>  Je suis tombé sur les situations suivantes dans lesquelles un temps de grande précision serait pertinent: </p><br><ol><li>  Vous souhaitez mesurer le temps entre certaines opérations.  Ici, tout est très simple: plus la précision des horodatages aux limites de l'intervalle est élevée, plus la précision du résultat est élevée.  Si vous utilisez des secondes entières, vous pouvez faire une erreur pendant 1 seconde (si vous tombez sur les frontières des secondes).  Si vous utilisez six décimales, l'erreur sera inférieure de six ordres de grandeur. </li><li>  Vous avez une collection où il est probable qu'il y ait plusieurs objets avec le même temps de création.  Un exemple est un chat familier à tout le monde, où la liste des contacts est triée par heure du dernier message.  S'il apparaît une navigation page par page, il existe même un risque de perte de contacts aux bordures de page.  Ce problème peut être résolu sans temps de haute précision grâce au tri et à la pagination par une paire de champs (temps + identifiant unique d'un objet), mais cette solution a ses inconvénients (au moins la complication des requêtes SQL, mais pas seulement).  Augmenter la précision du temps contribuera à réduire la probabilité de problèmes et à éviter de compliquer le système. </li><li> Vous devez conserver un historique des modifications de certains objets.  Ceci est particulièrement important dans le monde des services, où les modifications peuvent se produire en parallèle et à des endroits complètement différents.  À titre d'exemple, je peux travailler avec des photos de nos utilisateurs, où de nombreuses opérations différentes peuvent être effectuées en parallèle (l'utilisateur peut rendre la photo privée ou la supprimer, elle peut être modérée dans l'un des nombreux systèmes, recadrée pour être utilisée comme photo dans le chat, etc.). ) </li></ol><br><p>  Il faut garder à l'esprit que l'on ne peut pas croire les valeurs obtenues à 100% et la précision réelle des valeurs obtenues peut être inférieure à six décimales.  Cela est dû au fait que nous pouvons obtenir une valeur d'heure inexacte (en particulier lorsque vous travaillez dans un système distribué composé de nombreux serveurs), l'heure peut changer de manière inattendue (par exemple, lors de la synchronisation via NTP ou lors du changement d'horloge), etc. Je ne m'attarderai pas sur tous ces problèmes, mais je donnerai quelques articles où vous pourrez en savoir plus à leur sujet: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Idées fausses des programmeurs sur le temps»</a> (l'article lui-même est très minimaliste, mais en plus des résumés du texte, des explications peuvent être trouvées dans les commentaires); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"La lourde charge de temps</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-mysql">  Travailler avec un temps de haute précision dans MySQL </h2><br><p> MySQL prend en charge trois types de colonnes dans lesquelles l'heure peut être stockée: <code>TIME</code> , <code>DATETIME</code> et <code>TIMESTAMP</code> .  Initialement, ils ne pouvaient stocker que des valeurs qui étaient des multiples d'une seconde (par exemple, 2019-08-14 19:20:21).  Dans la version 5.6.4, sortie en décembre 2011, il est devenu possible de travailler avec la fraction de seconde.  Pour ce faire, lors de la création de la colonne, vous devez spécifier le nombre de décimales, qui doivent être stockées dans la partie fractionnaire de l'horodatage.  Le nombre maximal de caractères pris en charge est de six, ce qui vous permet de stocker un temps précis à la microseconde près.  Si vous essayez d'utiliser plus de caractères, vous obtenez une erreur. </p><br><p>  Un exemple: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> ( <span class="hljs-string"><span class="hljs-string">`chat_id`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-string"><span class="hljs-string">`title`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">`last_message_send_time`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>; Query OK, 0 rows affected (0.02 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ERROR 1426 (42000): Too-big precision 9 specified for 'last_message_send_time'. Maximum is 6. Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #1'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>()); Query OK, 1 row affected (0.03 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.000 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Dans cet exemple, l'horodatage de l'enregistrement inséré a une fraction nulle.  Cela s'est produit car la valeur d'entrée a été indiquée à la seconde près.  Pour résoudre le problème, la précision de la valeur d'entrée doit être identique à celle de la base de données.  Le conseil semble évident, mais il est pertinent, car un problème similaire peut apparaître dans les applications réelles: nous étions confrontés à une situation où la valeur d'entrée avait trois décimales et six étaient stockées dans la base de données. </p><br><p>  Le moyen le plus simple d'éviter ce problème est d'utiliser les valeurs d'entrée avec une précision maximale (jusqu'à quelques microsecondes).  Dans ce cas, lors de l'écriture des données dans la table, l'heure sera arrondie à la précision requise.  Il s'agit d'une situation tout à fait normale qui ne provoquera aucun avertissement: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">"2019-09-22 22:23:15.2345"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.235 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Lorsque vous utilisez l'initialisation automatique et la mise à jour automatique des colonnes TIMESTAMP à l'aide d'une structure de la forme <code>DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code> il est important que les valeurs aient la même précision que la colonne elle-même: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>; ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>); ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); Query OK, 0 rows affected (0.07 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">'2019-09-22 22:22:22'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 0 rows affected (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+-------------------------+ | chat_id | title | last_message_send_time | updated | +---------+---------+-------------------------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:22:22.000 | 2019-09-22 22:26:39.968 | +---------+---------+-------------------------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Les fonctions MySQL pour travailler dans le temps permettent de travailler avec la partie fractionnaire des unités de mesure.  Je ne les énumérerai pas tous (je suggère de regarder dans la documentation), mais je donnerai quelques exemples: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">INTERVAL</span></span> <span class="hljs-number"><span class="hljs-number">7.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SECOND</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------------------+--------------------------+------------------------------+ | NOW(2) | NOW(4) | NOW(4) + INTERVAL 7.5 SECOND | +------------------------+--------------------------+------------------------------+ | 2019-09-22 21:12:23.31 | 2019-09-22 21:12:23.3194 | 2019-09-22 21:12:30.8194 | +------------------------+--------------------------+------------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)), CURRENT_TIME(6), CURRENT_TIME(3); +-------------------------------------------+-----------------+-----------------+ | SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)) | CURRENT_TIME(6) | CURRENT_TIME(3) | +-------------------------------------------+-----------------+-----------------+ | 00:00:00.000712 | 21:12:50.793712 | 21:12:50.793 | +-------------------------------------------+-----------------+-----------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Le principal problème associé à l'utilisation de la partie fractionnaire des secondes dans les requêtes SQL est l'incohérence de la précision dans les comparaisons ( <code>&gt;</code> , <code>&lt;</code> , <code>BETWEEN</code> ).  Vous pouvez le rencontrer si les données de la base de données ont une précision et dans les requêtes - une autre.  Voici un petit exemple illustrant ce problème: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#         Test&gt; INSERT INTO ChatContactsList (title, last_message_send_time) VALUES ('Chat #2', '2019-09-22 21:16:39.123456'); Query OK, 0 row affected (0.00 sec) Test&gt; SELECT chat_id, title, last_message_send_time FROM ChatContactsList WHERE title='Chat #2'; +---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 2 | Chat #2 | 2019-09-22 21:16:39.123 | &lt;-     - ,    +---------+---------+-------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT title, last_message_send_time FROM ChatContactsList WHERE last_message_send_time &gt;= '2019-09-22 21:16:39.123456'; &lt;-    ,    INSERT- +---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #1 | 2019-09-22 22:22:22.000 | +---------+-------------------------+ 1 row in set (0.00 sec) &lt;- Chat #2   - ,     ,    </span></span></code> </pre> <br><p>  Dans cet exemple, la précision des valeurs de la requête est supérieure à la précision des valeurs de la base de données et le problème se produit «à la frontière par le haut».  Dans la situation opposée (si la valeur d'entrée a une précision inférieure à la valeur dans la base de données), il n'y aura pas de problème - MySQL apportera la valeur à la précision souhaitée dans INSERT et SELECT: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #3'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>); Query OK, 1 row affected (0.00 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title, last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> last_message_send_time &lt;= <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>; +<span class="hljs-comment"><span class="hljs-comment">---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #3 | 2019-09-03 21:20:19.100 | +---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  La cohérence de l'exactitude des valeurs doit toujours être gardée à l'esprit lorsque vous travaillez avec un temps de haute précision.  Si ces problèmes de limites sont critiques pour vous, vous devez vous assurer que le code et la base de données fonctionnent avec le même nombre de décimales. </p><br><div class="spoiler">  <b class="spoiler_title">Réflexions sur le choix de la précision dans les colonnes avec des parties fractionnaires de secondes</b> <div class="spoiler_text"><p>  La quantité d'espace occupée par la partie fractionnaire d'une unité de temps dépend du nombre de caractères dans la colonne.  Il semble naturel de choisir des significations familières: trois ou six décimales.  Mais dans le cas de trois personnages, ce n'est pas si simple.  En fait, MySQL utilise un octet pour stocker deux décimales: </p><br><blockquote><div class="scrollable-table"><table><thead><tr><th>  Précision fractionnelle en secondes </th><th>  Exigences de stockage </th></tr></thead><tbody><tr><td>  0 </td><td>  0 octets </td></tr><tr><td>  1, 2 </td><td>  1 octet </td></tr><tr><td>  3, 4 </td><td>  2 octets </td></tr><tr><td>  5, 6 </td><td>  3 octets </td></tr></tbody></table></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exigences de stockage de type de date et d'heure</a> </blockquote><p>  Il s'avère que si vous sélectionnez trois décimales, vous n'utilisez pas pleinement l'espace occupé et pour la même surcharge, vous pouvez prendre quatre caractères.  En général, je vous recommande de toujours utiliser un nombre pair de caractères et, si nécessaire, de «rogner» ceux qui ne sont pas nécessaires lors de la sortie.  L'option idéale est de ne pas être gourmand et de prendre six décimales.  Dans le pire des cas (avec le type DATETIME), cette colonne occupera 8 octets, c'est-à-dire la même chose que l'entier dans la colonne BIGINT. </p></div></div><br><p>  Voir aussi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Secondes fractionnaires dans les valeurs temporelles»</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Initialisation et mise à jour automatiques pour TIMESTAMP et DATETIME»</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Fonctions de date et d'heure»</a> . </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-php">  Travailler avec un temps de haute précision en PHP </h2><br><p>  Il ne suffit pas d'avoir du temps de haute précision dans la base de données - vous devez pouvoir travailler avec lui dans le code de vos programmes.  Dans cette section, je parlerai de trois points principaux: </p><br><ol><li>  Réception et formatage de l'heure: je vais expliquer comment obtenir l'horodatage avant de le mettre dans la base de données, de le récupérer à partir de là et de faire une sorte de manipulation. </li><li>  Travailler avec le temps dans PDO: je vais vous montrer un exemple de la façon dont PHP prend en charge le formatage du temps dans une bibliothèque de base de données. </li><li>  Travailler avec le temps dans les frameworks: je vais parler de l'utilisation du temps dans les migrations pour changer la structure de la base de données. </li></ol><br><h3 id="poluchenie-i-formatirovanie-vremeni">  Obtention et formatage de l'heure </h3><br><p>  Lorsque vous travaillez avec le temps, vous devez pouvoir effectuer plusieurs opérations de base: </p><br><ul><li>  obtenir l'heure actuelle; </li><li>  obtenir un instant dans le temps d'une chaîne formatée; </li><li>  ajouter une période à un point dans le temps (ou soustraire une période); </li><li>  obtenir une chaîne formatée pour un point dans le temps. </li></ul><br><p>  Dans cette partie, je vais vous dire quelles sont les possibilités pour effectuer ces opérations en PHP. </p><br><p>  La première consiste à travailler avec <strong>un horodatage sous forme de nombre</strong> .  Dans ce cas, dans le code PHP, nous travaillons avec des variables numériques, que nous opérons à travers des fonctions telles que l' <code>time</code> , la <code>date</code> , <code>strtotime</code> .  Cette méthode ne peut pas être utilisée pour travailler avec un temps de haute précision, car dans toutes ces fonctions, les horodatages sont un entier (ce qui signifie que la partie fractionnelle en eux sera perdue). </p><br><p>  Voici les signatures des principales fonctions de la documentation officielle: </p><br><blockquote> <code>time ( void ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.php.net/manual/ru/function.time.php</a> <br><br> <code>strtotime ( string $time [, int $now = time() ] ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://php.net/manual/ru/function.strtotime.php</a> <br><br> <code>date ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://php.net/manual/ru/function.date.php</a> <br><br> <code>strftime ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.php.net/manual/ru/function.strftime.php</a> </blockquote><br><div class="spoiler">  <b class="spoiler_title">Un point intéressant sur la fonction date</b> <div class="spoiler_text"><p>  Bien qu'il soit impossible de passer la fraction de seconde à l'entrée de ces fonctions, dans la ligne du modèle de formatage passé à l'entrée de la fonction <code>date</code> , vous pouvez définir des caractères pour afficher les millisecondes et microsecondes.  Lors du formatage, les zéros seront toujours renvoyés à leur place. </p><br><div class="scrollable-table"><table><thead><tr><th>  Caractère au format chaîne </th><th>  La description </th><th>  Exemple de valeur de retour </th></tr></thead><tbody><tr><td>  u </td><td>  Microsecondes (ajoutées en PHP 5.2.2).  Notez que date () renverra toujours 000000, comme  il prend un paramètre entier, alors que DateTime :: format () prend en charge les microsecondes si DateTime est créé avec eux. </td><td>  Par exemple: 654321 </td></tr><tr><td>  v </td><td>  Millisecondes (ajouté en PHP 7.0.0).  La remarque est la même que pour u. </td><td>  Par exemple: 654 </td></tr></tbody></table></div><br><p>  Un exemple: </p><br><pre> <code class="php hljs">$now = time(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> date(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, $now); <span class="hljs-comment"><span class="hljs-comment">// 2019-09-11 21:27:18.000000 print date('Ymd H:i:s.v', $now); // 2019-09-11 21:27:18.000</span></span></code> </pre> </div></div><br><p>  Cette méthode inclut <code>microtime</code> <code>hrtime</code> <code>microtime</code> et <code>hrtime</code> , qui vous permettent d'obtenir un <code>hrtime</code> avec une partie fractionnaire pour l'instant en cours.  Le problème est qu'il n'existe aucun moyen prêt à l'emploi pour formater une telle étiquette et l'obtenir à partir d'une chaîne d'un format spécifique.  Cela peut être résolu en implémentant indépendamment ces fonctions, mais je n'envisagerai pas une telle option. </p><br><blockquote>  Si vous devez travailler uniquement avec des minuteries, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HRTime</a> est une bonne option, que je ne considérerai pas plus en détail en raison des limites de son utilisation.  Je peux seulement dire qu'il vous permet de travailler avec du temps à la nanoseconde et garantit la monotonie des minuteries, ce qui élimine certains des problèmes qui peuvent être rencontrés lorsque vous travaillez avec d'autres bibliothèques. </blockquote><p>  Pour travailler pleinement avec des parties fractionnaires d'une seconde, vous devez utiliser le module <strong>DateTime</strong> .  Sous certaines réserves, il vous permet d'effectuer toutes les opérations listées ci-dessus: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    : $time = new \DateTimeImmutable(); //      : $time = new \DateTimeImmutable('2019-09-12 21:32:43.908502'); $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.9085'); // / : $period = \DateInterval::createFromDateString('5 seconds'); $timeBefore = $time-&gt;add($period); $timeAfter = $time-&gt;sub($period); //      : print $time-&gt;format('Ymd H:i:s.v'); // '2019-09-12 21:32:43.908' print $time-&gt;format("Ymd H:i:su"); // '2019-09-12 21:32:43.908502'</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Le point non évident lors de l'utilisation de `DateTimeImmutable :: createFromFormat`</b> <div class="spoiler_text"><p>  La lettre <code>u</code> dans la chaîne de format signifie microsecondes, mais elle fonctionne également correctement dans le cas de parties fractionnaires de moindre précision.  De plus, c'est le seul moyen de spécifier des parties fractionnaires d'une seconde dans une chaîne de format.  Un exemple: </p><br><pre> <code class="php hljs">$time = \DateTimeImmutable::createFromFormat(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-12 21:32:43.9085'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   DateTimeImmutable    2019-09-12 21:32:43.908500 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.90'); // =&gt;   DateTimeImmutable    2019-09-12 21:32:43.900000 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43'); // =&gt;  false</span></span></code> </pre> </div></div><br><p>  Le principal problème de ce module est l'inconvénient de travailler avec des intervalles contenant des fractions de seconde (voire l'impossibilité d'un tel travail).  La <code>\DateInterval</code> bien qu'elle contienne la partie fractionnaire d'une seconde précise aux mêmes six décimales, vous ne pouvez initialiser cette partie fractionnaire que par <code>DateTime::diff</code> .  Le constructeur de la classe DateInterval et la méthode d'usine <code>\DateInterval::createFromDateString</code> ne peuvent fonctionner qu'avec des secondes entières et ne permettent pas de spécifier la partie fractionnaire: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     -   $buggyPeriod1 = new \DateInterval('PT7.500S'); //       ,    $buggyPeriod2 = \DateInterval::createFromDateString('2 minutes 7.5 seconds'); print $buggyPeriod2-&gt;format('%R%H:%I:%S.%F') . PHP_EOL; //  "+00:02:00.000000"</span></span></code> </pre> <br><p>  Un autre problème peut survenir lors du calcul de la différence entre deux points dans le temps à l'aide de la méthode <code>\DateTimeImmutable::diff</code> .  En PHP avant la version 7.2.12, il y avait un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bug à</a> cause duquel les parties fractionnaires d'une seconde existaient séparément des autres chiffres et pouvaient recevoir leur propre signe: </p><br><pre> <code class="php hljs">$timeBefore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-12 21:20:19.987654'</span></span>); $timeAfter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-14 12:13:14.123456'</span></span>); $diff = $timeBefore-&gt;diff($timeAfter); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $diff-&gt;format(<span class="hljs-string"><span class="hljs-string">'%R%a days %H:%I:%S.%F'</span></span>) . PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">//  PHP  7.2.12+   "+1 days 14:52:54.135802" //       "+1 days 14:52:55.-864198"</span></span></code> </pre> <br><p>  En général, je vous conseille d'être prudent lorsque vous travaillez avec des intervalles et de couvrir soigneusement ce code avec des tests. </p><br><p>  Voir aussi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Date et heure"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Fonction Hrtime."</a> </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-pdo">  Travailler avec un temps de haute précision dans PDO </h3><br><p>  PDO et mysqli sont les deux principales interfaces pour interroger les bases de données MySQL à partir du code PHP.  Dans le contexte d'une conversation sur le temps, ils sont similaires les uns aux autres, donc je ne parlerai que de l'un d'eux - AOP. </p><br><p>  Lorsque vous travaillez avec des bases de données dans PDO, l'heure apparaît à deux endroits: </p><br><ul><li>  en tant que paramètre passé aux requêtes exécutées; </li><li>  comme une valeur qui vient en réponse aux requêtes SELECT. </li></ul><br><p>  Il est recommandé de passer des espaces réservés lors du passage de paramètres à la demande.  Les espaces réservés peuvent transférer des valeurs à partir d'un très petit ensemble de types: valeurs booléennes, chaînes et entiers.  Il n'y a pas de type approprié pour la date et l'heure, vous devez donc convertir manuellement la valeur d'un objet de la classe DateTime / DateTimeImmutable en une chaîne. </p><br><pre> <code class="php hljs">$now = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(); $db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \PDO(<span class="hljs-string"><span class="hljs-string">'mysql:...'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]); $stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'INSERT INTO Test.ChatContactsList (title, last_message_send_time) VALUES (:title, :date)'</span></span>); $result = $stmt-&gt;execute([<span class="hljs-string"><span class="hljs-string">':title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test #1"</span></span>, <span class="hljs-string"><span class="hljs-string">':date'</span></span> =&gt; $now-&gt;format(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>)]);</code> </pre> <br><p>  L'utilisation d'un tel code n'est pas très pratique, car à chaque fois vous devez formater la valeur transmise.  Par conséquent, dans la base de code Badoo, nous avons implémenté la prise en charge des espaces réservés typés dans notre wrapper pour travailler avec la base de données.  Dans le cas des dates, cela est très pratique, car il vous permet de transférer une valeur dans différents formats (un objet qui implémente DateTimeInterface, une chaîne formatée ou un nombre avec un horodatage), et toutes les transformations et vérifications nécessaires de l'exactitude des valeurs transférées sont déjà effectuées à l'intérieur.  En prime, lors du transfert d'une valeur incorrecte, nous apprenons l'erreur immédiatement, et non après avoir reçu une erreur de MySQL lors de l'exécution de la requête. </p><br><p>  La récupération de données à partir des résultats de requête semble assez simple.  Lors de l'exécution de cette opération, PDO renvoie les données sous forme de chaînes, et dans le code, nous devons continuer à traiter les résultats si nous voulons travailler avec des objets temporels (et ici, nous avons besoin de la fonctionnalité pour obtenir l'heure de la chaîne formatée, dont j'ai parlé dans la section précédente). </p><br><pre> <code class="php hljs">$stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'SELECT * FROM Test.ChatContactsList ORDER BY last_message_send_time DESC, chat_id DESC LIMIT 5'</span></span>); $stmt-&gt;execute(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { $row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>] = is_null($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]) ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><blockquote>  Remarque <br><br>  Le fait que PDO renvoie des données sous forme de chaînes n'est pas entièrement vrai.  Lors de la réception de valeurs, il est possible de définir le type de valeur pour la colonne à l'aide de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PDOStatement::bindColumn</code></a> .  Je n'en ai pas parlé car il y a le même ensemble limité de types qui n'aide pas avec les dates. </blockquote><p>  Malheureusement, il y a un problème à prendre en compte.  En PHP avant la version 7.3, il y a un bogue à cause duquel PDO, lorsque l'attribut <code>PDO::ATTR_EMULATE_PREPARES</code> est <code>PDO::ATTR_EMULATE_PREPARES</code> "coupe" la partie fractionnaire d'une seconde lorsqu'il est reçu de la base de données.  Des détails et un exemple peuvent être trouvés dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bogue sur php.net</a> .  En PHP 7.3, cette erreur a été corrigée et a averti que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce changement rompt la compatibilité descendante</a> . </p><br><p>  Si vous utilisez PHP version 7.2 ou antérieure et n'êtes pas en mesure de le mettre à jour ou d'activer <code>PDO::ATTR_EMULATE_PREPARES</code> , vous pouvez contourner ce bogue en corrigeant les requêtes SQL qui renvoient l'heure avec une partie fractionnaire afin que cette colonne ait un type de chaîne.  Cela peut être fait, par exemple, comme ceci: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> last_message_send_time_fixed <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Ce problème peut également être rencontré lorsque vous travaillez avec le module <code>mysqli</code> : si vous utilisez des requêtes préparées via un appel à la méthode <code>mysqli::prepare</code> , puis en PHP avant la version 7.3, la partie fractionnaire d'une seconde ne sera pas retournée.  Comme avec PDO, vous pouvez résoudre ce problème en mettant à jour PHP ou en contournant la conversion temporelle en type de chaîne. </p><br><p>  Voir aussi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Requêtes préparées et procédures stockées dans PDO"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Requêtes préparées dans mysqli"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation sur la méthode mysqli_stmt :: bind_param</a> (ici les types d'espaces réservés supportés dans mysqli sont décrits); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pool de requêtes à PHP, dans lequel ils ont fixé la "troncature" de la partie fractionnaire de secondes</a> . </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-yii-2">  Travailler avec un temps de haute précision dans Yii 2 </h3><br><p>  La plupart des frameworks modernes fournissent une fonctionnalité de migration qui vous permet de stocker l'historique des modifications de schéma de base de données dans le code et de le modifier de manière incrémentielle.  Si vous utilisez des migrations et souhaitez utiliser du temps de haute précision, votre framework doit le prendre en charge.  Heureusement, cela fonctionne dès le départ dans tous les principaux cadres. </p><br><p>  Dans cette section, je montrerai comment ce support est implémenté dans Yii (dans les exemples j'ai utilisé la version 2.0.26).  À propos de Laravel, Symfony et d'autres, je n'écrirai pas afin de ne pas rendre l'article sans fin, mais je serai heureux si vous ajoutez des détails dans les commentaires ou les nouveaux articles sur ce sujet. </p><br><p>  Dans la migration, nous écrivons du code qui décrit les modifications apportées au schéma de données.  Lors de la création d'une nouvelle table, nous décrivons toutes ses colonnes à l'aide de méthodes spéciales de la classe \ yii \ db \ Migration (elles sont déclarées dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">barre SchemaBuilderTrait</a> ).  Les méthodes <code>time</code> , <code>timestamp</code> et <code>datetime</code> qui peuvent prendre une valeur d'entrée de précision sont responsables de la description des colonnes contenant la date et l'heure. </p><br><p>  Exemple de migration dans laquelle une nouvelle table est créée avec une colonne de temps de haute précision: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">db</span></span>\<span class="hljs-title"><span class="hljs-title">Migration</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190914_141123_create_news_table</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;createTable(<span class="hljs-string"><span class="hljs-string">'news'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;primaryKey(), <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;string()-&gt;notNull(), <span class="hljs-string"><span class="hljs-string">'content'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;text(), <span class="hljs-string"><span class="hljs-string">'published'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-comment"><span class="hljs-comment">//     ]); } public function down() { $this-&gt;dropTable('news'); } }</span></span></code> </pre> <br><p>  Et voici un exemple de migration dans lequel la précision d'une colonne existante change: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190916_045702_change_news_time_precision</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p>       ActiveRecord     -  :          ,         DateTime-.  ,     —    «»      <code>PDO::ATTR_EMULATE_PREPARES</code> .   Yii    ,        .   ,       ,        PDO. </p><br><p> . : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    Yii 2</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  SchemaBuilderTrait</a> . </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> ,   ,     —  ,     .                 ,    ,    . ,    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469615/">https://habr.com/ru/post/fr469615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469599/index.html">Débriefing du développement du moteur 2D sur WinForms</a></li>
<li><a href="../fr469605/index.html">L'avenir du Li-Fi: polaritons, excitons, photons et certains disulfures de tungstène</a></li>
<li><a href="../fr469607/index.html">Conscience humaine. Impossible de transférer la copie?</a></li>
<li><a href="../fr469609/index.html">Veuillez être en ligne</a></li>
<li><a href="../fr469613/index.html">À propos du système national de gestion des données</a></li>
<li><a href="../fr469617/index.html">Détruisez le monopole américain sur l'EDA. Innopolis fait le premier pas</a></li>
<li><a href="../fr469619/index.html">Recherche: si l'acheteur comprend qu'il parle avec le chat bot, l'achat n'aura pas lieu du tout</a></li>
<li><a href="../fr469623/index.html">GitLab 12.3 avec pare-feu d'application Web et analyse des performances</a></li>
<li><a href="../fr469625/index.html">Comment nous avons collecté des données sur les campagnes publicitaires des plateformes en ligne (le chemin épineux vers le produit)</a></li>
<li><a href="../fr469629/index.html">L'atome pacifique n'est pas dans tous les foyers: des options inattendues pour les sources d'énergie des radionucléides</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>