<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèø üêü üë®üèΩ‚Äç‚öñÔ∏è Rendering-Funktionen in Metro: Exodus c Raytracing üëµüèΩ ‚è¨ ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 Nachdem das letzte Spiel aus der Metro-Serie ver√∂ffentlicht worden war, verbrachte ich mehrere Stunden damit, seine interne Arbeit zu studie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendering-Funktionen in Metro: Exodus c Raytracing</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447194/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6c/122/9f2/b6c1229f21aaaefc416b180a41759690.jpg" alt="Bild"></div><br><h3>  Vorwort </h3><br>  Nachdem das letzte Spiel aus der Metro-Serie ver√∂ffentlicht worden war, verbrachte ich mehrere Stunden damit, seine interne Arbeit zu studieren, und beschloss, etwas zu teilen, das aus technologischer Sicht interessant erscheinen k√∂nnte.  Ich werde keine detaillierte Analyse durchf√ºhren oder den zerlegten Code der Shader untersuchen, aber ich werde die allgemeinen Entscheidungen zeigen, die die Entwickler bei der Erstellung des Spiels getroffen haben. <br><br>  Im Moment haben die Entwickler noch nicht √ºber die im Spiel verwendeten Rendering-Techniken gesprochen.  Die einzige offizielle Informationsquelle ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noreferrer noopener">GDC-Bericht</a> , der nirgendwo anders im Internet zu finden ist.  Und das ist √§rgerlich, weil das Spiel auf einer sehr interessanten propriet√§ren Engine l√§uft, die sich aus fr√ºheren Spielen der Metro-Serie entwickelt hat.  Dies ist eines der ersten Spiele, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DXR verwenden</a> . <br><br>  Hinweis: Dieser Artikel ist keine vollst√§ndige Beschreibung und ich werde darauf zur√ºckkommen, wenn ich etwas finde, das es wert ist, hinzugef√ºgt zu werden.  Vielleicht habe ich etwas verpasst, weil einige Aspekte erst in den n√§chsten Phasen des Spiels auftauchen, oder ich habe mir nur die Details angesehen. <br><br><h3>  Erste Schritte </h3><br>  Ich habe mehrere Tage gebraucht, um eine Umgebung zu finden, die mit diesem Spiel arbeiten kann.  Nachdem ich mehrere Versionen von RenderDoc und PIX getestet hatte, entschied ich mich, die Ergebnisse der Raytracing-Funktion mit Nvidia NSight zu untersuchen.  Ich wollte das Rendern ohne Raytracing lernen, aber NSight erlaubte mir, auch die Details dieser Funktion zu untersuchen, und entschied mich, sie aktiviert zu lassen.  F√ºr den Rest des Renderings passt PIX gut.  Mit beiden Anwendungen wurden Screenshots gemacht. <br><a name="habracut"></a><br>  NSight hat einen Nachteil: Das Speichern der Aufnahme in einer Datei wird nicht unterst√ºtzt, sodass ich nicht zu den Frames zur√ºckkehren konnte, die ich studiert habe. <br><br>  Gleich zu Beginn meiner Arbeit stie√ü ich auf ein anderes Problem, das nichts mit Frame-Debugging-Anwendungen zu tun hatte: F√ºr die Raytracing-Funktionen musste das neueste Windows-Update installiert werden, aber das Spiel erm√∂glichte es, sie in die Optionen aufzunehmen, ohne das Update zu installieren.  In diesem Fall f√ºhrte die Einbeziehung von Funktionen dazu, dass das Spiel beim Start abst√ºrzte.  Die GeForce Experience sagte auch nichts √ºber die Notwendigkeit der richtigen Windows-Version aus, um diese Funktionen zu aktivieren.  Dieses Problem muss auf beiden Seiten angegangen werden. <br><br>  Der Vollst√§ndigkeit halber habe ich Aufnahmen von einem Spiel gemacht, das mit den maximal m√∂glichen Parametern ausgef√ºhrt wurde, jedoch ohne DLSS. <br><br><h3>  Rahmenanalyse </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/541/f12/e34/541f12e34559d73faa7eb743915e5cdd.png"></div><br>  <i>Fertiger Rahmen</i> <br><br>  Eine kurze Analyse des Renderings zeigt einen ziemlich standardm√§√üigen Satz von Funktionen, mit Ausnahme der globalen Beleuchtung, die durch Raytracing (Raytraced GI) durchgef√ºhrt wird. <br><br>  Vor dem Rendern des Bildes wird der Ma√üstab des vorherigen Frames in der Rechenwarteschlange reduziert und die durchschnittliche Helligkeit berechnet. <br><br>  Die grafische Warteschlange beginnt mit dem Rendern von Verzerrungspartikeln (Tr√∂pfchen auf der Kamera), die in der Nachbearbeitungsphase angewendet werden.  Dann erzeugt ein schneller vorl√§ufiger Durchlauf der Tiefen einen Teil der Tiefen vor dem Gbuffer;  es sieht so aus, als w√ºrde es nur eine Erleichterung bringen. <br><br>  Der GBuffer-Durchlauf f√ºllt 4 Rendering-Ziele gem√§√ü dem folgenden Diagramm und vervollst√§ndigt auch das F√ºllen des Tiefenpuffers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a67/9ef/332/a679ef3320584af81cc4d3c6970fecd1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/c7d/d77/97bc7dd7753e655aec4a8279851e78be.png"></div><br>  <i>1. Ziel im RGBA8-Format mit Albedo und m√∂glicherweise Umgebungsokklusion im Alphakanal;</i>  <i>Auf einigen Oberfl√§chen sieht es sehr dunkel aus.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ff/a5f/972/8ffa5f972989ecb5104c92cf1e56ddc0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/580/93a/6e158093ac061f9c993fc5d954d3a383.png"></div><br>  <i>2. Ziel im RGB10A2-Format mit Normalen und m√∂glicherweise einer unterirdischen Streumaske im Alphakanal.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/cab/600/aedcab600ed86cab9d6fff32d005365b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/7e8/64e/d9e7e864ecc5794d64a9f0923153f673.png"></div><br>  <i>3. Ziel im RGBA8-Format mit anderen Materialparametern, wahrscheinlich Metall und Rauheit im Alphakanal.</i>  <i>Seltsamerweise enthalten die RGB-Kan√§le in diesem Fall genau die gleichen Daten.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/aaf/aa7/2aeaafaa75ea48daa6c9671ef02024e4.png"></div><br>  <i>4. Ziel im RG16F-Format mit 2D-Bewegungsvektoren.</i> <br><br>  Nachdem die Tiefen vollst√§ndig gef√ºllt sind, wird ein linearer Tiefenpuffer erstellt und sein Ma√üstab nimmt ab.  All dies erfolgt in der Rechenwarteschlange.  In derselben Warteschlange wird der Puffer mit etwas gef√ºllt, das der gerichteten Beleuchtung √§hnelt, ohne Schatten zu verwenden. <br><br>  In der Grafikwarteschlange verfolgt die GPU die Strahlen der globalen Beleuchtung, aber ich werde weiter unten mehr dar√ºber sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/205/368/6b1/2053686b1cb719229dc0ccce1540e5c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/879/607/0ab/8796070abae27e9695fb82d6f5789375.png"></div><br>  Die Rechenwarteschlange berechnet Umgebungsokklusion, Reflexionen und √§hnliches wie die Kantenerkennung. <br><br>  In der Grafikwarteschlange wird eine vierstufige Schattenkarte in eine 32-Bit-Tiefenkarte der Gr√∂√üe 6k * 6k gerendert.  Mehr dazu weiter unten.  Nach Fertigstellung der Karte der gerichteten Schatten verringert sich die Aufl√∂sung der dritten Kaskade aus unbekannten Gr√ºnden auf 768 * 768. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/203/3e2/a852033e230487f7be913e94ee87a7fa.png"></div><br>  In der Mitte des Schattenwiedergabeprozesses gibt es einen merkw√ºrdigen Moment: Der Betr√ºgeratlas wird durch einige Objekte erg√§nzt, bevor lokale Schatten aus der Beleuchtung gerendert werden (dar√ºber, welche Betr√ºger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind</a> ).  Sowohl die Impostor-Puffer als auch die lokalen Lichtschattenpuffer sind ebenfalls 6k * 6k-Texturen. <br><br>  Nachdem alle Schatten abgeschlossen sind, beginnt die Berechnung der Beleuchtung.  Dieser Teil des Renderings ist ziemlich unverst√§ndlich, da es viele Renderings gibt, die einige mysteri√∂se Aktionen ausf√ºhren und daher zus√§tzliche Studien erfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e07/838/016/e078380165142b63cce7e340155e4aef.png"></div><br>  Das Rendern der Szene endet mit frontal beleuchteten Objekten (Augen, Partikel).  Visuelle Effekte werden in einen Puffer mit halber Aufl√∂sung gerendert. Anschlie√üend werden sie durch Zoomen mit undurchsichtigen Objekten zusammengesetzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d95/88c/66e/d9588c66ecb2dbd09b0386fc481771c1.png"></div><br>  Das endg√ºltige Bild wird durch Tonwertkorrektur und Bloom-Berechnung erzielt (verringern und erh√∂hen Sie dann die Aufl√∂sung des Rahmens mit Tonwertkorrektur).  Schlie√ülich wird die Benutzeroberfl√§che in einen separaten Puffer gerendert und zusammen mit Bloom Compositing √ºber die Szene gelegt. <br><br>  Ich habe den Teil, in dem die Gl√§ttung durchgef√ºhrt wird, nicht gefunden, daher lasse ich ihn f√ºr sp√§ter. <br><br><h3>  Globale Lichtstrahlverfolgung </h3><br>  Einige Informationen zur globalen Beleuchtung durch Raytraced GI.  Diese beschleunigende Struktur deckt einen gro√üen Bereich der Spielwelt ab, wahrscheinlich mehrere hundert Meter, und beh√§lt √ºberall sehr hohe Details bei.  Es scheint irgendwie zu streamen.  Die Szene der beschleunigenden Struktur stimmt nicht mit der gerasterten Szene √ºberein. Beispielsweise sind die Geb√§ude im Bild unten in der gerasterten Form nicht sichtbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e98/f99/6d9/e98f996d9c2ad589d81fb6c5abac1208.png"></div><br>  <i>Blick von oben</i> <br><br>  Hier sehen wir vier Kacheln, die die Position des Spielers umgeben.  Ebenfalls offensichtlich ist der Mangel an Geometrie, die auf dem Alphakanal getestet wird.  B√§ume haben St√§mme, aber kein Laub, kein Gras, keine B√ºsche. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/500/53a/089/50053a0898f262725ade46d2b5dadb88.png"></div><br>  <i>Ansicht schlie√üen</i> <br><br>  In der Nahansicht werden die Details und die Dichte von Objekten besser gesehen.  Jedes Objekt einer anderen Farbe hat seine eigene Beschleunigungsstruktur der unteren Ebene.  Nur auf diesem Bild gibt es mehrere hundert davon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83e/5e8/dff/83e5e8dfff1709a0d38b1f4c5d012282.png"></div><br>  <i>Spielergegenst√§nde unter den F√º√üen</i> <br><br>  Interessanterweise sind die Gegenst√§nde des Spielers auch Teil der Beschleunigungsstruktur, befinden sich jedoch aus irgendeinem Grund unter seinen F√º√üen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/c2b/203/969c2b203e8abecbd7718e061db99984.png"></div><br>  <i>Gebrochene Haut?</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/620/78d/36662078d0930dfb66fb3bf1d928f022.png"></div><br>  <i>Wieder gebrochene Haut?</i> <br><br>  Einige der Objekte mit Hautbildung sehen in der Beschleunigungsstruktur gebrochen aus.  Eines der beobachteten Probleme ist das Dehnen des Netzes (an den Beinen des Kindes).  Ein weiteres Problem f√ºhrt dazu, dass sich verschiedene Teile des Charakters mit Hautbildung in unterschiedlichen Positionen befinden.  Es gibt keine Dehnung, aber die Teile sind voneinander getrennt.  Es scheint, dass nichts davon in der globalen Raytracing-Beleuchtung sichtbar ist, oder zumindest konnte ich dies im Spiel nicht bemerken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/647/c7c/c2b/647c7cc2beab467af7223ed97f80fa08.png"></div><br>  <i>Eine gro√üe Anzahl von Objekten</i> <br><br>  Auf einer allgemeineren Ebene k√∂nnen Sie sehen, wie viele verschiedene Objekte sich in der Beschleunigungsstruktur befinden.  Die meisten von ihnen werden nicht wirklich zu den Ergebnissen der Berechnungen der globalen Beleuchtung beitragen.  Hier ist auch zu sehen, dass es kein LOD-Schema gibt.  Alle Objekte werden detailliert hinzugef√ºgt.  Es w√§re interessant zu wissen, ob dies Auswirkungen auf das Raytracing hat (ich w√ºrde ja annehmen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/11b/0ec/64f11b0ec3d0882a84503875c5a1cb20.png"></div><br>  <i>Ultrahohe LOD, jede Skala und jeder Schalter vollst√§ndig modelliert</i> <br><br>  Ein weiterer Screenshot zeigt ein gro√ües Detail von Objekten, die noch weit vom Player entfernt sind.  Jeder Schalter und jede Skala in diesem Bild sind auch ohne Texturen gut lesbar.  Der Ort, an dem ich die Kamera bewegt habe, um diesen Screenshot aufzunehmen, befindet sich mehrere zehn Meter vom Player entfernt, und das Eliminieren dieser Details h√§tte die Bildqualit√§t nicht verschlechtert.  M√∂glicherweise w√§re die Aktualisierung der Beschleunigungsstruktur mithilfe von LOD zu kostspielig, aber es besteht eine hohe Wahrscheinlichkeit, dass diese Aktualisierung asynchron durchgef√ºhrt werden kann.  Dieser Punkt ist definitiv eine n√§here Untersuchung wert. <br><br><h3>  Richtungsschatten rendern </h3><br>  Der Hauptteil des Renderns von Schatten ist einfach und erfordert keine besondere Erw√§hnung, aber hier gibt es interessante Punkte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/016/0ea/d160160ea9d4dc571c97440f77d103a0.png"></div><br>  <i>Maschen, f√ºr die Schattenwurf unwahrscheinlich ist</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/857/cb1/369857cb17bf6baeaae52295930b4ac5.png"></div><br>  <i>Riesige Details in Schattenkarten</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e0/708/9ba/0e07089ba7b63f9c055a95a8ed783f09.png"></div><br>  <i>Netze, die anscheinend den falschen Indexpuffer verwenden</i> <br><br>  Es scheint, dass das Schatten-Rendering wie das Beschleunigen von Strukturen absolut alles umfasst.  Es gibt Objekte, die fast nicht zur Schattenkarte beitragen, aber dennoch gerendert werden.  Ich frage mich, ob dies aufgrund einer Erlaubnis geschieht oder ob es keine einfache M√∂glichkeit im Motor gibt, sie auszuschlie√üen. <br><br>  Es gibt Objekte, die selbst bei Schatten im Bildschirmbereich schwer zu erkennen sind.  Das Rendern dauert nicht lange, aber es w√§re interessant zu sehen, ob sie entfernt werden k√∂nnen, um ein wenig Zeit zu sparen. <br><br>  Bei der Untersuchung des Netzes scheinen einige der in der Schattenkarte gerenderten Netze defekte Indexpuffer zu haben, aber nach dem Vertex-Shader sehen sie korrekt aus (die Ergebnisse sind in PIX und NSight gleich).  Dies ist das beste Beispiel, das ich gefunden habe, aber es ist bei weitem nicht das einzige.  Vielleicht ist dies eine spezielle Verpackungsposition? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/079/80b/5d907980beab8411086ae95a3cd1069e.png"></div><br>  <i>Maschen scheinen eine schlechte Haut zu haben</i> <br><br>  Das Enth√§uten scheint nicht nur bei der Beschleunigung von Strukturen Probleme zu verursachen.  Interessanterweise f√ºhrt dies nicht zu sichtbaren Artefakten auf dem Bildschirm. <br><br><h2>  Teil 2 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/d1c/c6d/787d1cc6d642436ce05542678e27b807.png" alt="Bild"></div><br><h3>  Kleinere √Ñnderung </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efe/177/37b/efe17737bab902e3b3d1e4ae2a29edbf.png"></div><br>  Im vorherigen Teil habe ich geschrieben, dass das dritte Renderziel des GBuffer-Puffers h√∂chstwahrscheinlich Metall enth√§lt, aber es scheint, dass es tats√§chlich Spiegelfarben enth√§lt.  Zuerst habe ich keine Farben gesehen und nicht verstanden, warum alle drei RGB-Kan√§le dieselben Daten enthalten, aber wahrscheinlich, weil die Szene keine Farbreflexionen aufwies.  F√ºr diese Waffe enth√§lt der Puffer viel mehr verschiedene Farben. <br><br>  Ich habe auch vergessen, meine Lieblingstextur hinzuzuf√ºgen, die ich bei der Untersuchung des Renderings des Spiels gefunden habe.  Es ist definitiv erw√§hnenswert, weil es die chaotische Natur der Spieleentwicklung demonstriert, wenn es nicht immer m√∂glich ist, sie zu bereinigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/5b4/288/7bb5b428878a0be20dbe80d599256d80.png"></div><br>  <i>"Verbessere mich!"</i> <br><br><h3>  Transparenz-Compositing und Anti-Aliasing </h3><br>  Beim Versuch herauszufinden, wie sich die Aufl√∂sung des Transparenzpuffers in halber Gr√∂√üe erh√∂ht und wie das Spiel Antialiasing ausf√ºhrt, fiel mir etwas Interessantes auf.  Ich brauchte eine Szene, in der es viel mehr Kontrast gab, damit klar erkennbar war, was geschah.  Gl√ºcklicherweise habe ich es geschafft, ein Bild zu erfassen, in dem sich die Waffe des Spielers leicht zwischen den Bildern bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0c/974/612/a0c9746122e45a19786bdf51521015a9.png"></div><br>  <i>Vor dem Rendern von Transparenz</i> <br><br>  Es scheint, dass der Puffer vor dem Zusammensetzen des Transparenzpuffers bereits ein vollst√§ndig gerendertes Bild enth√§lt. Da dieser Rahmen keine scharfen Kanten enth√§lt, ist es logisch anzunehmen, dass dies die Daten des vorherigen Rahmens sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/bd5/b89/c56bd5b8938a315f97def63dc7b8b214.png"></div><br>  <i>Nach dem Zusammensetzen der Transparenz des aktuellen Frames</i> <br><br>  Wenn Sie dem aktuellen Frame Transparenz hinzuf√ºgen, k√∂nnen Sie einzelne gebrochene Kanten feststellen.  Es geschah, weil sich die Waffe leicht nach rechts bewegte.  Einige Wolken werden transparent gemacht, aber sie werden am Horizont abgeschnitten (was undurchsichtig ist), sodass beim Zusammensetzen der Boden nicht ver√§ndert wird, sondern bereits das Waffennetz aus dem vorherigen Frame mithilfe des Tiefenpuffers des aktuellen Frames gerendert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/7a1/e93/64f7a1e9340dfe180e4807cf7c4da5be.png"></div><br>  <i>Nach dem Hinzuf√ºgen von Deckkraft zum aktuellen Bild</i> <br><br>  Nach mehreren Zeichenaufrufen werden Compositing- und undurchsichtige Netze ausgef√ºhrt.  Es scheint keinen besonderen Grund zu geben, dies in dieser Reihenfolge zu tun.  Es ist logisch, den Transparenzpuffer in die Daten undurchsichtiger Objekte des aktuellen Frames zu komponieren. Dies ist jedoch nicht der Fall, und es w√§re interessant zu wissen, warum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/963/bce/f23/963bcef23544573444acf29bf7a83a87.png"></div><br>  <i>Nach TAA</i> <br><br>  Nach Abschluss des vollst√§ndigen Frames gl√§ttet der TAA-Durchgang (Temporal Smoothing) die Kanten.  Das hat mich schon fr√ºher interessiert, weil ich nicht gesehen habe, wo die Gl√§ttung stattfindet.  Aber ich habe dies √ºbersprungen, weil unmittelbar nach diesem Draw-Aufruf das Downsampling f√ºr den Bloom-Pass beginnt und ich diesen einen Draw-Aufruf verpasse. <br><br><h3>  Linseneffekt </h3><br>  Normalerweise m√∂chte ich keine einzelnen Effekte analysieren, aber es gibt viele M√∂glichkeiten, Linseneffekte zu implementieren. Daher war ich gespannt, welche Entwickler sich entschieden haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/d1c/c6d/787d1cc6d642436ce05542678e27b807.png"></div><br>  <i>Linseneffekt beim fertigen Compositing</i> <br><br>  In den meisten F√§llen ist der Linseneffekt kaum wahrnehmbar, aber dies ist ein sch√∂ner Effekt.  Es ist schwierig, auf dem Screenshot zu zeigen, daher werde ich mich nicht viel M√ºhe geben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a32/554/efc/a32554efc67afb79416b6ce2fe337148.png"></div><br>  <i>Linseneffekt im Bl√ºtenpuffer</i> <br><br>  Nach der Suche fand ich einen Draw-Aufruf, der diesen Effekt hinzuf√ºgt, und es stellte sich heraus, dass es sich um einen Aufruf nach der letzten Phase der Erh√∂hung der Bloom-Aufl√∂sung handelte.  In diesem Puffer ist der Effekt viel deutlicher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/f38/078/8a3f38078dc5d6c6451030ee3eb5c53b.png"></div><br>  <i>Geometrie Linseneffekt</i> <br><br>  Wenn Sie sich die Geometrie ansehen, ist der Linseneffekt ziemlich einfach.  Mindestens 6 Vierecke sind an der Erstellung des Endergebnisses auf dem Bildschirm beteiligt, es gibt jedoch keine Reihe kleinerer Vierecke, die sich dem Sonnenstand n√§hern.  Wir k√∂nnen daraus schlie√üen, dass dies eine ziemlich standardm√§√üige L√∂sung ist, obwohl einige Entwickler den Linseneffekt direkt in der Rendertarget-Szene rendern, w√§hrend andere den Effekt als Nachbearbeitung berechnen. <br><br><h3>  Terrain-Rendering </h3><br>  Eine der interessantesten Schwierigkeiten bei allen Open-World-Spielen ist das Rendern von Gel√§nde.  Ich entschied, dass es interessant erscheinen k√∂nnte, diesen Aspekt zu untersuchen, aber ehrlich gesagt ein wenig entt√§uscht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/125/7a6/89b/1257a689b93f0f7a0239b5514ce911af.png"></div><br>  Auf den ersten Blick sieht ein Fragment des Reliefs so aus, als w√ºrde eine Art Tessellation durchgef√ºhrt.  Die Art und Weise, wie das Relief w√§hrend der Bewegung verformt wird, macht es logisch anzunehmen, dass es eine zus√§tzliche Verschiebung gibt.  Dar√ºber hinaus verwendet das Spiel auf einem PC aktiv die Tessellation, sodass es logisch w√§re, sie als Relief zu verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99d/214/a4d/99d214a4dc8c15862b7e385edda0c25e.png"></div><br>  Vielleicht hatte ich die falschen Parameter eingestellt, aber das Spiel rendert alle Fragmente des Reliefs ohne Tessellation.  F√ºr jedes Fragment des Reliefs verwendet sie dieses einheitliche 32 * 32-Raster.  Es gibt auch keine LOD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/aa8/4bc/744aa84bce83c87e8c2a49338f7c8c13.png"></div><br>  Wenn Sie sich ein Fragment des Reliefs nach dem Scheitelpunkt-Shader ansehen, sehen Sie, dass die meisten Scheitelpunktpaare zu einem nahezu perfekten 16 * 16-Raster zusammengef√ºhrt wurden, mit Ausnahme einiger Stellen, die mehr Genauigkeit erfordern (wahrscheinlich aufgrund der Kr√ºmmung des Reliefs).  Die oben erw√§hnte Verformung entsteht wahrscheinlich durch das Lesen der Mip-Texturen der H√∂henkarte des Reliefs, wenn das Relief weit von der Kamera entfernt ist. <br><br><h3>  Ray Tracking Tricks </h3><br>  Und nun dar√ºber, worauf alle gewartet haben. <br><br><h4>  Daten streamen </h4><br>  Einer der derzeit interessantesten Aspekte einer DXR-Implementierung ist die Art und Weise, wie Sie mit Daten arbeiten.  Das Wichtigste ist, wie die Daten in beschleunigende Strukturen geladen und wie sie aktualisiert werden.  Um dies zu testen, habe ich zwei Aufnahmen gemacht und die beschleunigenden Strukturen in NSight verglichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fc/7b7/0d2/3fc7b70d22199c5be429417fd6ed92a9.png"></div><br>  <i>Der Spieler ist im Schiff</i> <br><br>  Bei der ersten Aufnahme stand ich in einem kaputten Schiff, das in der Mitte dieses Bildes sichtbar ist.  Es werden nur die n√§chstgelegenen Objekte geladen, mit Ausnahme gro√üer Steine ‚Äã‚Äãam Rand der Karte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/e41/2fa/dc4e412fa02b74f7ca4384a53e1b8100.png"></div><br>  <i>Der Player hat sich in die obere linke Ecke dieses Bildes bewegt.</i> <br><br>  Bei der zweiten Aufnahme entfernte ich mich vom Rand der Karte und befand mich n√§her am oberen linken Rand des Bildes.  Das Schiff und alles um es herum ist noch geladen, aber es wurden auch neue Objekte geladen.  Interessanterweise kann ich keine Kachelstruktur definieren.  Objekte k√∂nnen basierend auf Entfernung und Sichtbarkeit aus der Beschleunigungsstruktur geladen / daraus entfernt werden (m√∂glicherweise wird das Parallelogramm eingeschr√§nkt?).  Au√üerdem sieht der obere rechte Rand detaillierter aus, obwohl er sich von ihm entfernt hat.  Es w√§re interessant, mehr dar√ºber zu erfahren. <br><br><h4>  Erleichterung und was darunter ist </h4><br>  Einige Aspekte der DXR-Implementierung in Metro: Exodus in Bezug auf das Gel√§nde k√∂nnen erw√§hnt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e97/386/8bf/e973868bf7b0bd40cfc58c0d94678acf.png"></div><br>  Erstens ist es interessant, dass Beschleunigungsstrukturen keine Reliefnetze enthalten (mit Ausnahme von Sonderf√§llen).  Diese Monster rennen tats√§chlich im Spiel auf dem Boden, aber nach den Daten in NSight k√∂nnte man denken, dass sie fliegen.  Dies wirft f√ºr uns eine interessante Frage auf: Kann die Implementierung der globalen Beleuchtung das Relief irgendwie ber√ºcksichtigen (m√∂glicherweise unter Verwendung einer H√∂henkarte und eines Reliefmaterials) oder nicht? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/03e/860/a7a03e8601a37c6459eff55cc7dda39f.png"></div><br>  Im n√§chsten Moment h√§tte ich es nie bemerkt, wenn die Erleichterung vorhanden w√§re.  Als ich zu Beginn des Levels die Beschleunigungsstruktur in NSight betrachtete, bemerkte ich einige Maschen unter dem Relief. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/458/b77/ec3/458b77ec37a3db2b1d8ca0b3f1694dd8.png"></div><br>  K√ºnstler platzieren aus verschiedenen Gr√ºnden h√§ufig Debug-Meshes unter dem Level, aber sie werden normalerweise gel√∂scht, bevor das Spiel ver√∂ffentlicht wird.  In diesem Fall √ºberlebten diese Maschen nicht nur bis zur Freisetzung, sondern wurden auch Teil der beschleunigenden Struktur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/64a/15d/27d64a15df609c55b8742d77637fca22.png"></div><br>  Zus√§tzlich zu den oben genannten fand ich andere Maschen, die unter dem Relief verstreut waren.  Grunds√§tzlich sind sie nicht sehr erw√§hnenswert, aber dieser war sehr interessant - dies ist ein Charakter, der direkt unter dem Startpunkt des Levels steht.  Es hat sogar einen eigenen Pool. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/5dd/66c/53f5dd66c2b959793151e3a59d1309a5.png"></div><br>  Das letzte merkw√ºrdige Element der Beschleunigungsstruktur sind die einseitigen Maschen, die nach au√üen schauen.  Wenn sie nicht als bilateral betrachtet werden, besteht nur eine sehr geringe Chance, dass sie einen Beitrag zum Bild des Spiels leisten.  Selbst wenn die Maschen zweiseitig sind, sind sie so weit vom spielbaren Bereich entfernt, dass sie wahrscheinlich nur die Beschleunigungsstruktur dehnen.  Es ist interessant zu sehen, dass sie nicht gefiltert werden.  Dieses Bild zeigt auch einen der Sonderf√§lle des "Reliefnetzes" in der unteren rechten Ecke zwischen Zug und Geb√§ude. <br><br><h4>  Kopflosigkeit beim H√§uten </h4><br>  Ich habe bereits √ºber die Probleme beim Enth√§uten von Maschen gesprochen, aber auf dieser Ebene ist mir etwas anderes aufgefallen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/0dd/a8c/1d10dda8c75112713b51c32771bb8ecb.png"></div><br>  Erstens zeigt dieses Monster beide Fehler in einem Bild, die ich oben bemerkt habe.  Ich frage mich immer noch, was sie verursacht hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/265/dd7/523265dd72a9613800831592706bd510.png"></div><br>  Mir ist auch aufgefallen, dass diese kleinen Kreaturen wie Flederm√§use keine K√∂pfe in der Beschleunigungsstruktur haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fd/1a9/801/6fd1a9801d440a719602ab30eb33a88e.png"></div><br>  Ein weiteres Beispiel.  Beachten Sie das Loch, in dem sich der Kopf befinden sollte.  Ich habe keinen einzigen Fall gesehen, in dem der Kopf sichtbar war. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/51e/741/e7f51e74194bf8cccf8e430e6ec8513d.png"></div><br>  Die gleiche Art von Kreaturen im Rastermodus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass der Kopf deutlich sichtbar ist. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/d67/2ea/ebdd672ea50f7717c4b66afeb20b4cf8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und hier ist das Drahtgitter des Kopfes. </font></font><br><br><h3>  Abschlie√üend </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles f√ºr heute. </font><font style="vertical-align: inherit;">Ich hoffe, Ihnen hat dieser Blick auf die Innenseiten von Metro: Exodus gefallen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde mich weiterhin mit dem Rendern des Spiels befassen, aber ich werde keine neuen Teile des Artikels ver√∂ffentlichen, es sei denn, ich finde einige spezielle Teile, die f√ºr die Leute interessant w√§ren, oder finde etwas, das es wert ist, geteilt zu werden.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447194/">https://habr.com/ru/post/de447194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447182/index.html">Betriebssysteme: Drei einfache Teile. Teil 3: Prozess-API (√úbersetzung)</a></li>
<li><a href="../de447184/index.html">Was ist Initial Exchange Offering (IEO) und wie unterscheidet es sich von ICO?</a></li>
<li><a href="../de447186/index.html">So starten Sie einen ML-Prototyp an einem Tag. Bericht Yandex.Taxi</a></li>
<li><a href="../de447190/index.html">Vorhersagen von Mathematikern. Wir analysieren die wichtigsten Methoden zur Erkennung von Anomalien</a></li>
<li><a href="../de447192/index.html">Welche Rolle kann Technologie in der alten Kunst des Gew√ºrzmischens spielen?</a></li>
<li><a href="../de447196/index.html">7. Check Point Erste Schritte R80.20. Zugangskontrolle</a></li>
<li><a href="../de447198/index.html">Mondmission "Bereshit": Landungsunfall-Sturz auf den Mond</a></li>
<li><a href="../de447204/index.html">17. April: Offene Vorlesung "Der Weg des Spieleentwicklers: Von der Idee zum Start" und eine Spielbibliothek an der Higher School of Law</a></li>
<li><a href="../de447208/index.html">SQA Days EU Review</a></li>
<li><a href="../de447210/index.html">@ Pythonetc-Zusammenstellung M√§rz 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>