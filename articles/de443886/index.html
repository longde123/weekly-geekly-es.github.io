<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📫 🌺 🛂 Lösen einer Aufgabe aus einem Google-Interview mit JavaScript: 4 verschiedene Möglichkeiten 🌳 🥜 🧓🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich die Leistung von Algorithmen studierte, stieß ich auf dieses Video aus dem Scheininterview von Google . Es gibt nicht nur eine Vorstellung dav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lösen einer Aufgabe aus einem Google-Interview mit JavaScript: 4 verschiedene Möglichkeiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/443886/"><img src="https://habrastorage.org/getpro/habr/post_images/83f/a6b/8bb/83fa6b8bb04adab1ec1067682d5a2fd1.jpg"><br><br>  Als ich die Leistung von Algorithmen studierte, stieß ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Video aus dem Scheininterview von Google</a> .  Es gibt nicht nur eine Vorstellung davon, wie Interviews in großen Technologieunternehmen durchgeführt werden, sondern ermöglicht Ihnen auch zu verstehen, wie algorithmische Probleme am effizientesten gelöst werden. <br><br>  Dieser Artikel ist eine Art Begleitung zum Video.  Darin gebe ich Kommentare zu allen gezeigten Lösungen sowie zu meiner eigenen Version der Lösung in JavaScript.  Die Nuancen jedes Algorithmus werden ebenfalls diskutiert. <br><a name="habracut"></a><br><blockquote>  <b>Wir erinnern Sie daran:</b> <i>Für alle Leser von „Habr“ - ein Rabatt von 10.000 Rubel bei der Anmeldung für einen Skillbox-Kurs mit dem Promo-Code „Habr“.</i> <br><br>  <b>Skillbox empfiehlt:</b> Praktikum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Mobile Developer PRO"</a> . <br></blockquote><br><h3>  Erklärung des Problems </h3><br>  Wir erhalten ein geordnetes Array und einen bestimmten Wert.  Dann bitten sie darum, eine Funktion zu erstellen, die true oder false zurückgibt, je nachdem, ob die Summe von zwei beliebigen Zahlen aus dem Array dem angegebenen Wert entsprechen kann. <br><br>  Mit anderen Worten, gibt es zwei Ganzzahlen x und y im Array, die beim Hinzufügen dem angegebenen Wert entsprechen? <br><br>  <b>Beispiel A.</b> <br><br>  Wenn wir ein Array [1, 2, 4, 9] und einen Wert von 8 erhalten haben, gibt die Funktion false zurück, da keine zwei Zahlen aus dem Array insgesamt 8 ergeben können. <br><br>  <b>Beispiel B.</b> <br><br>  Wenn es sich jedoch um ein Array [1, 2, 4, 4] handelt und der Wert 8 ist, sollte die Funktion true zurückgeben, da 4 + 4 = 8 ist. <br><br>  <b>Lösung 1. Bruteforce</b> <br><br>  <i>Zeitliche Schwierigkeit: O (N²).</i> <i><br></i>  <i>Räumliche Komplexität: O (1).</i> <br><br>  Die naheliegendste Bedeutung ist die Verwendung eines Paares verschachtelter Schleifen. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; arr.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i !== j &amp;&amp; arr[i] + arr[j] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Diese Lösung kann nicht als effektiv bezeichnet werden, da sie jede mögliche Summe von zwei Elementen im Array überprüft und jedes Indexpaar zweimal vergleicht.  (Wenn zum Beispiel i = 1 und j = 2 ist, entspricht dies tatsächlich dem Vergleich mit i = 2 und j = 1, aber in dieser Lösung versuchen wir beide Optionen). <br><br>  Da unsere Lösung ein Paar verschachtelter for-Schleifen verwendet, ist sie quadratisch mit einer Zeitkomplexität von O (N²). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/BretCameron/embed/preview/aMLOyb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Lösung 2. Binäre (binäre) Suche</b> <br><br>  <i>Zeitliche Schwierigkeit: O (Nlog (N)).</i> <i><br></i>  <i>Räumliche Komplexität: O (1)</i> . <br><br>  Da Arrays geordnet sind, können wir mithilfe der binären Suche nach einer Lösung suchen.  Dies ist der effizienteste Algorithmus für geordnete Arrays.  Die binäre Suche selbst hat eine O (log (N)) Laufzeit.  Sie müssen jedoch weiterhin eine for-Schleife verwenden, um jedes Element mit allen anderen Werten zu vergleichen. <br><br>  So könnte die Lösung aussehen.  Um alles klar zu machen, verwenden wir eine separate Funktion, um die binäre Suche zu steuern.  Sowie die Funktion removeIndex (), die die Version des Arrays abzüglich des angegebenen Index zurückgibt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binarySearch(removeIndex(arr, i), val - arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> removeIndex = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, i).concat(arr.slice(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, arr.length)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binarySearch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(arr.length / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; arr[pivot]) { end = pivot - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; arr[pivot]) { start = pivot + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((start + end) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[pivot] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Der Algorithmus beginnt bei Index [0].  Anschließend wird eine Version des Arrays mit Ausnahme des ersten Index erstellt und mithilfe einer binären Suche überprüft, ob der verbleibende Wert zum Array hinzugefügt werden kann, um die gewünschte Menge zu erhalten.  Diese Aktion wird einmal für jedes Element im Array ausgeführt. <br><br>  Die for-Schleife selbst hat eine lineare Zeitkomplexität von O (N), aber innerhalb der for-Schleife führen wir eine binäre Suche durch, die die Gesamtzeitkomplexität von O (Nlog (N)) angibt.  Diese Lösung ist besser als die vorherige, aber es gibt noch etwas zu verbessern. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/BretCameron/embed/preview/MxEYdB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Lösung 3. Lineare Zeit</b> <br><br>  <i>Zeitliche Schwierigkeit: O (N).</i> <i><br></i>  <i>Räumliche Komplexität: O (1).</i> <br><br>  Jetzt werden wir das Problem lösen und uns daran erinnern, dass das Array sortiert ist.  Die Lösung besteht darin, zwei Zahlen zu verwenden: eine am Anfang und eine am Ende.  Wenn das Ergebnis vom gewünschten abweicht, ändern wir den Start- und Endpunkt. <br><br>  Am Ende erfüllen wir entweder den gewünschten Wert und geben true zurück, oder die Start- und Endpunkte konvergieren und geben false zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = arr[start] + arr[end]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &gt; val) { end -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &lt; val) { start += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/BretCameron/embed/preview/jJGERY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jetzt ist alles in Ordnung, die Lösung scheint optimal zu sein.  Aber wer garantiert, dass das Array bestellt wurde? <br><br><h3>  Was dann? </h3><br>  Auf den ersten Blick könnten wir zuerst das Array sortieren und dann die obige Lösung verwenden.  Aber wie wirkt sich das auf die Laufzeit aus? <br><br>  Der beste Algorithmus ist die schnelle Sortierung mit der Zeitkomplexität O (Nlog (N)).  Wenn wir es in unserer optimalen Lösung verwenden, ändert es seine Leistung von O (N) in O (Nlog (N)).  Ist es möglich, eine lineare Lösung mit einem ungeordneten Array zu finden? <br><br>  <b>Entscheidung 4</b> <br><br>  <i>Zeitliche Schwierigkeit: O (N).</i> <i><br></i>  <i>Räumliche Komplexität: O (N).</i> <br><br>  Ja, es gibt eine lineare Lösung. Dazu müssen Sie ein neues Array erstellen, das eine Liste der Übereinstimmungen enthält, nach denen wir suchen.  Der Kompromiss hierbei ist eine aktivere Nutzung des Speichers: Dies ist die einzige Lösung in dem Artikel mit einer räumlichen Komplexität von mehr als O (1). <br><br>  Wenn der erste Wert dieses Arrays 1 und der Suchwert 8 ist, können wir den Wert 7 zum Array der "Suchwerte" hinzufügen. <br><br>  Wenn wir dann jedes Element des Arrays verarbeiten, können wir das Array der „Suchwerte“ überprüfen und feststellen, ob einer von ihnen unserem Wert entspricht.  Wenn ja, geben Sie true zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchValues = [val - arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchVal = val - arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchValues.includes(arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchValues.push(searchVal); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Die Basis der Lösung ist die for-Schleife, die, wie wir oben gesehen haben, eine lineare Zeitkomplexität O (N) aufweist. <br><br>  Der zweite Iterationsteil unserer Funktion ist Array.prototype.include (), eine JavaScript-Methode, die je nachdem, ob das Array den angegebenen Wert enthält, true oder false zurückgibt. <br><br>  Um die zeitliche Komplexität von Array.prototype.includes () herauszufinden, können wir uns die von MDN bereitgestellte (und in JavaScript geschriebene) Polyfüllung ansehen oder eine Methode im Quellcode einer JavaScript-Engine wie Google V8 (C ++) verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// https://tc39.github.io/ecma262/#sec-array.prototype.includes if (!Array.prototype.includes) { Object.defineProperty(Array.prototype, 'includes', { value: function(valueToFind, fromIndex) { if (this == null) { throw new TypeError('"this" is null or not defined'); } // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")). var len = o.length &gt;&gt;&gt; 0; // 3. If len is 0, return false. if (len === 0) { return false; } // 4. Let n be ? ToInteger(fromIndex). // (If fromIndex is undefined, this step produces the value 0.) var n = fromIndex | 0; // 5. If n ≥ 0, then // a. Let k be n. // 6. Else n &lt; 0, // a. Let k be len + n. // b. If k &lt; 0, let k be 0. var k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0); function sameValueZero(x, y) { return x === y || (typeof x === 'number' &amp;&amp; typeof y === 'number' &amp;&amp; isNaN(x) &amp;&amp; isNaN(y)); } // 7. Repeat, while k &lt; len while (k &lt; len) { // a. Let elementK be the result of ? Get(O, ! ToString(k)). // b. If SameValueZero(valueToFind, elementK) is true, return true. if (sameValueZero(o[k], valueToFind)) { return true; } // c. Increase k by 1. k++; } // 8. Return false return false; } }); }</span></span></code> </pre> <br>  Hier ist der iterative Teil von Array.prototype.include () die while-Schleife in Schritt 7, die (fast) die gesamte Länge des angegebenen Arrays durchläuft.  Dies bedeutet, dass seine zeitliche Komplexität ebenfalls linear ist.  Nun, da es immer einen Schritt hinter unserem Hauptarray liegt, ist die zeitliche Komplexität O (N + (N - 1)).  Mit der Big O-Notation vereinfachen wir sie auf O (N) - da N mit zunehmender Eingabegröße den größten Einfluss hat. <br><br>  Für die räumliche Komplexität wird ein zusätzliches Array benötigt, dessen Länge das ursprüngliche Array widerspiegelt (minus eins, ja, aber dies kann ignoriert werden), was zur räumlichen Komplexität von O (N) führt.  Eine erhöhte Speichernutzung sorgt für maximale Effizienz des Algorithmus. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/BretCameron/embed/preview/vPeYqb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ich hoffe, dieser Artikel ist für Sie als Anhang zu einem Videointerview hilfreich.  Es zeigt, dass ein einfaches Problem auf verschiedene Weise mit unterschiedlichen Ressourcen (Zeit, Speicher) gelöst werden kann. <br><br><blockquote>  <b>Skillbox empfiehlt:</b> <br><br><ul><li>  Angewandter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python Data Analyst</a> Online-Kurs. <br></li><li>  Online-Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Beruf Frontend-Entwickler</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li><li>  Praktischer Jahreskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"PHP-Entwickler von 0 bis PRO"</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443886/">https://habr.com/ru/post/de443886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443874/index.html">Vergleich von Deep-Learning-Frameworks: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe usw.</a></li>
<li><a href="../de443876/index.html">Wir entwickeln einen Telegramm-Bot zum Verfolgen von Filmen auf NodeJS und TypeScript</a></li>
<li><a href="../de443878/index.html">DEV Labs 2019. Python zur Lösung nicht trivialer Aufgaben. Online Mitap</a></li>
<li><a href="../de443882/index.html">MOSDROID # 15 Phosphor: Leistungsvideo</a></li>
<li><a href="../de443884/index.html">3 Schlüsselqualitäten eines erfolgreichen Produktmanagers: Anton Danilov</a></li>
<li><a href="../de443894/index.html">Die vierte Ebene von Max Tegmarks Multiuniversum</a></li>
<li><a href="../de443896/index.html">Technische Schulden wie Tetris</a></li>
<li><a href="../de443898/index.html">Nägel in der Decke des Sarges von Runet</a></li>
<li><a href="../de443900/index.html">Wie wir die Qualität und Effektivität der Dokumentationsentwicklung messen. Hintergrund und Grundlagen. Yandex-Bericht</a></li>
<li><a href="../de443902/index.html">Wie wir den internen Hackathon gewonnen haben, indem wir Skibidi, Zahnseide und Javascript gelernt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>