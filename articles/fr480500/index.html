<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è üòΩ ü§æüèº Attaques mat√©rielles contre les microcontr√¥leurs utilisant ChipWhisperer et m√©thodes de protection contre ceux-ci üë©üèæ‚Äçüç≥ ü§Ω üîÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les attaques mat√©rielles constituent une grande menace pour tous les appareils √©quip√©s de microcontr√¥leurs (ci-apr√®s - MK), car ils peuvent contourner...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Attaques mat√©rielles contre les microcontr√¥leurs utilisant ChipWhisperer et m√©thodes de protection contre ceux-ci</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/480500/"><img src="https://habrastorage.org/webt/fm/dm/6l/fmdm6lpgrxzzbswipqkegkikcda.png" align="left"><br><p>  Les attaques mat√©rielles constituent une grande menace pour tous les appareils √©quip√©s de microcontr√¥leurs (ci-apr√®s - MK), car ils peuvent contourner divers m√©canismes de s√©curit√©.  Il est difficile de se d√©fendre contre de telles attaques √† l'aide de logiciels ou de mat√©riel.  Par exemple, vous pouvez lire <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/group1/9f/0b/e4/b6/75/15/4f/e2/DM00493651/files/DM00493651.pdf/jcr:content/translations/en.DM00493651.pdf">un article</a> de STMicroelectronics sur divers types d'attaques mat√©rielles et sur les m√©thodes de protection de MK. <br>  Nous, l'√©quipe de Raccoon Security, nous int√©ressons √† ce sujet, car l'un des domaines d'activit√© de notre entreprise est le d√©veloppement de dispositifs embarqu√©s, y compris ceux contenant des m√©canismes de protection des informations.  Pour la plupart, nous nous int√©ressons aux attaques glitch, car elles vous permettent de passer les instructions MK ex√©cutables.  Il s'agit d'une menace s√©rieuse pour les informations confidentielles contenues dans MK, et la cons√©quence la plus dangereuse de telles attaques est la lecture de micrologiciels ferm√©s, contournant les m√©canismes de s√©curit√© fournis par les d√©veloppeurs MK. </p><br><p>  Lors de Hardwear.io 2018 √† La Haye et EmbeddedWorld 2019 √† Nuremberg, NewAE a pr√©sent√© le dispositif ChipWhisperer, qui permet la mise en ≈ìuvre de cette partie des attaques mat√©rielles non invasives qui ne n√©cessitent pas une connaissance approfondie de la nano√©lectronique et la disponibilit√© d'√©quipements sp√©cifiques.  En utilisant cet appareil, nous avons √©tudi√© la s√©curit√© des appareils embarqu√©s et trouv√© comment minimiser le r√©sultat de telles attaques.  Sous la coupe - ce que nous avons fait. </p><a name="habracut"></a><br><p>  <strong>Chipwhisperer</strong> </p><br><p> Le kit ChipWhisperer est une bo√Æte √† outils open source pour analyser la s√©curit√© des MK les plus populaires (STM, Xmega, Intel D2000, SAM, LPC, MSP, 78K et autres) et des FPGA.  Le projet a d√©marr√© le 27 f√©vrier 2015 sur <a href="https://www.kickstarter.com/projects/coflynn/chipwhisperer-lite-a-new-era-of-hardware-security">Kickstarter</a> .  Pour le moment, il existe diff√©rentes versions de ChipWhisperer (toutes les options se trouvent dans le <a href="http://newae.com/catalogue/">catalogue</a> ).  Ils ont un ensemble d'outils diff√©rent, mais sont g√©n√©ralement orient√©s vers les types d'attaques mat√©rielles suivants: </p><br><p>  ‚Ä¢ attaques par canal lat√©ral (SCA); </p><br><p>  ‚Ä¢ attaques glitch. </p><br><p>  Pour une analyse plus approfondie, nous avons choisi ChipWhisperer-Pro (CW1200), qui est le plus ancien mod√®le ChipWhisperer √† l'heure actuelle et qui poss√®de de nombreuses fonctionnalit√©s et un large package: </p><br><img src="https://habrastorage.org/webt/w9/-h/fp/w9-hfpu2mqywy9imc05cxdss4z4.jpeg"><br><p>  <em>Kit ChipWhisperer (CW1200)</em> </p><br><p>  √Ä bord, le CW1200 dispose d'un oscilloscope, qui se compose d'un amplificateur r√©glable et d'un ADC avec un √©chantillon de 105 MSPS.  Cet ensemble d'outils vous permet d'enregistrer le niveau du signal en centi√®mes de millivolt et d'obtenir une bonne base de temps.  Dans le CW1200, il y a √©galement des ports pour organiser CLK-glitch et Vcc-glitch, des ports GPIO qui peuvent √™tre attribu√©s comme d√©clencheurs d'entr√©e pour suivre l'origine d'un √©v√©nement (demande d'entr√©e de mot de passe, √©tat de t√©l√©chargement, etc.).  Le CW1200 se connecte √† un PC via USB et dispose de deux protocoles de communication avec MK: UART et SPI. </p><br><p>  Pour travailler avec ChipWhisperer, vous devez installer des pilotes, t√©l√©charger des biblioth√®ques Python et des exemples de travail depuis <a href="https://github.com/newaetech/chipwhisperer/releases">GitHub,</a> ou t√©l√©charger l'image pr√©par√©e d'une machine virtuelle sous Linux, dans laquelle toutes les biblioth√®ques et les exemples de travail sont pr√©install√©s.  Ces biblioth√®ques ouvertes contiennent: </p><br><p>  ‚Ä¢ protocole de communication avec ChipWhisperer; </p><br><p>  ‚Ä¢ algorithmes math√©matiques pour le traitement des attaques contre les m√©thodes de chiffrement populaires; </p><br><p>  ‚Ä¢ protocoles de communication avec les chargeurs de d√©marrage de MK populaires; </p><br><p>  ‚Ä¢ firmware pr√©par√© pour la formation sur les cartes avec MK, inclus dans le kit. </p><br><p>  Nous avons d√©cid√© de parcourir tous les tutoriels <a href="https://wiki.newae.com/">sur l'ancien site Web de</a> NewAE.  Maintenant, une autre <a href="https://chipwhisperer.readthedocs.io/en/latest/index.html">ressource</a> est en cours de d√©veloppement, o√π des informations plus pertinentes sont pr√©sent√©es et il existe un <a href="https://forum.newae.com/">forum</a> . </p><br><p>  Dans cet article, nous ne pr√©senterons que quelques exemples de guides des d√©veloppeurs ChipWhisperer et nous les impl√©mentons non pas sur les cartes avec MK incluses dans le package, mais sur le STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Board STM32F103RBT6</em> </p><br><p>  Nous avons √©galement √©crit du code identique √† leurs exemples pr√©par√©s, mais avec des biblioth√®ques HAL g√©n√©r√©es √† partir de CubeMX.  Toutes ces actions sont n√©cessaires pour confirmer que les attaques avec ChipWhisperer peuvent √™tre impl√©ment√©es sur tous les appareils al√©atoires, et pas seulement sur les cartes pr√©sentes dans le kit. </p><br><p>  Ensuite, nous fournissons un bref aper√ßu et des exemples d'attaques SCA et d'attaques par p√©pin. </p><br><p>  <strong>Analyse SCA</strong> </p><br><p>  La base des attaques SCA est le suivi des changements des facteurs externes de l'√©tat du MC (consommation actuelle du MC, temp√©rature, champ √©lectromagn√©tique) au cours du d√©veloppement de diverses instructions.  ChipWhisperer met en ≈ìuvre des canaux pour surveiller la puissance √† l'aide d'un ADC et un champ √©lectromagn√©tique √† l'aide d'une antenne. </p><br><p>  L'analyse SCA est efficace pour d√©tecter les mots de passe, les cl√©s de chiffrement, etc.  Le site Web de NewAE pr√©sente de nombreux <br>  <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_cpa_1-openadc-cwlitearm.html">des</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">lignes directrices</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_cpa_1-openadc-cwlitearm.html">utiles</a> pour trouver <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">des cl√©s de chiffrement</a> et pour les <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_tvla_1-openadc-cwlitearm.html">attaques</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_profiling_1-openadc-cwlitearm.html">SCA</a> , mais nous ne donnerons qu'un seul exemple d'analyse SCA, car les attaques glitch nous int√©ressent le plus. </p><br><p>  <strong>Exemples d'attaques SCA - Analyse des signatures de puissance</strong> </p><br><p> Ce <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html">guide</a> pr√©sente un type d'attaque SCA: le suivi de l'entr√©e de mot de passe caract√®re par caract√®re en surveillant les signatures sur le canal d'alimentation.  En r√©p√©tant les signatures de puissance, il est possible d'identifier le d√©veloppement de diverses instructions de programme √† l'int√©rieur du MK.  L'exemple ci-dessus montre le d√©veloppement de l'entr√©e de mot de passe MK en suivant la signature de l'op√©ration d' <code>break</code> . </p><br><p>  Commen√ßons la pr√©paration.  Tout d'abord, vous devez √©tablir des connexions selon la figure: </p><br><img src="https://habrastorage.org/webt/vk/cv/gu/vkcvguq0vvlgyivzanufkixv-8e.jpeg"><br><p>  <em>Connexion MC pour l'analyse SCA</em> </p><br><p>  Le diagramme pr√©sente les composants qui n'ont pas besoin d'√™tre connect√©s (contrairement √† la connexion MK standard).  Les fl√®ches indiquent les points de connexion de ChipWhisperer et les signatures indiquent ses broches. </p><br><p>  Pr√©parez le firmware MK.  La fonction suivante se trouve dans la boucle principale while <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">028</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">password_check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">029</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-number"><span class="hljs-number">030</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> correct_passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">031</span></span> HAL_Delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-number"><span class="hljs-number">032</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WARNING: UNAUTHORIZED ACCESS WILL BE PUNISHED\n"</span></span>); <span class="hljs-number"><span class="hljs-number">033</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">034</span></span> <span class="hljs-number"><span class="hljs-number">035</span></span> <span class="hljs-comment"><span class="hljs-comment">//Get password 036 uart_send("Please enter password to continue: "); 037 uart_receive(passwd, 32); 038 039 uint8_t passbad = 0; 040 041 led_on(); 042 043 for(uint8_t i = 0; i &lt; sizeof(correct_passwd); i++) 044 { 045 if (correct_passwd[i] != passwd[i]) 046 { 047 passbad = 1; 048 break; 049 } 050 } 051 052 if (passbad) 053 { 054 //Stop them fancy timing attacks 055 int wait = rand() % 100000; 056 for(volatile int i = 0; i &lt; wait; i++) 057 { 058 ; 059 } 060 HAL_Delay(4); 061 uart_send("PASSWORD FAIL\n"); 062 } 063 else 064 { 065 uart_send("Access granted, Welcome!\n"); 066 } 067 while(1) 068 { 069 ; 070 } 071 }</span></span></code> </pre> <br><p>  La ligne 030 d√©finit le mot de passe d'entr√©e - Vulkan.  Ensuite, la LED s'allume <br>  <code>led_on()</code> et un message UART est envoy√© √† propos de la demande de mot de passe.  La fonction <code>led_on()</code> active la broche GPIO du PA12 MK et signale un √©v√©nement contre lequel ChipWhisperer commencera √† accumuler des formes d'onde.  C'est √† cette broche que CW_TRIG doit √™tre connect√©.  Tout cela est ¬´synth√©tis√©¬ª pour plus de commodit√©, mais dans les cas r√©els, la diff√©rence sera insignifiante, car vous pouvez entrer un d√©lai dans le nombre de cycles d'horloge CLOCK par rapport √† tout √©v√©nement auquel CW_TRIG est connect√©.  Par exemple, cela peut √™tre le d√©but du t√©l√©chargement MK, la transmission / r√©ception des messages, la LED allum√©e, etc. </p><br><p>  De plus, MK attend la saisie d'un mot de passe, qu'il v√©rifiera caract√®re par caract√®re.  Si un caract√®re de la file d'attente ne correspond pas, par exemple, trois caract√®res sont corrects et le quatri√®me ne l'est pas, vous devez quitter la boucle for avec l'instruction <code>break</code> et signaler le mauvais mot de passe.  Aux lignes 055 √† 059, un g√©n√©rateur de retard al√©atoire est impl√©ment√©.  Cette conception est le plus souvent utilis√©e pour compliquer la conduite d'attaques temporaires (c'est-√†-dire suivre les changements dans le temps de r√©ponse de l'ensemble du syst√®me).  Cette conception est incluse pour comprendre que nous n'avons pas s√©lectionn√© de mot de passe √† l'aide de la m√©thode d'attaque temporaire. </p><br><p>  Le code du didacticiel Jupyter Python est h√©berg√© sur la <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html%2522/l%2522tutorial-pa-spa-1-openadc-cwlitearm">ressource</a> correspondante.  La figure ci-dessous montre un exemple de saisie d'un mot de passe avec la sortie de la forme d'onde d'alimentation du MK avec chaque nouveau symbole correct.  Notez qu'avec la saisie de caract√®res du mot de passe correct (le mot de passe que vous entrez est affich√© en haut de la figure), la signature de l'op√©ration de <code>break</code> est d√©plac√©e √† la ligne 046 (surlign√©e en orange dans la figure ci-dessous).  Il s'agit de la "faiblesse" de l'interruption par l'op√©ration d' <code>break</code> lors de la v√©rification mot de passe par caract√®re du mot de passe. </p><br><img src="https://habrastorage.org/webt/eu/6p/xf/eu6pxfivltkrmfs5pa-ryxugvam.png"><br><p>  <em>Oscillogrammes de mot de passe</em> </p><br><p>  Suite √† la familiarisation avec ce guide, nous avons d√©couvert √† quel point il est facile de contourner la protection par mot de passe avec cette approche de v√©rification √† l'aide de l'analyse SCA.  Il suffit de commenter l'op√©ration d' <code>break</code> de la ligne 048 dans ce firmware et, en g√©n√©ral, la v√©rification du mot de passe sera aussi r√©ussie, mais le suivi du traitement de la signature deviendra plus compliqu√©.  Par cons√©quent, pour r√©duire l'efficacit√© de telles attaques, vous devez √©viter l'op√©ration d'interruption imm√©diate des cycles d'analyse. </p><br><p>  La complexit√© de cette analyse r√©side dans la recherche des signatures n√©cessaires.  Par cons√©quent, la conduite de telles attaques peut compliquer consid√©rablement l'introduction de constructions temporaires <code>rand()</code> au moment de la v√©rification du mot de passe, en ajoutant des calculs suppl√©mentaires ou en ajoutant du bruit √† d'autres composants. </p><br><p>  <strong>Attaques par p√©pin</strong> </p><br><p>  Les attaques glitch sont effectu√©es par une s√©rie d'impulsions √† court terme √† un moment pr√©cis dans le temps selon une certaine m√©thode d'influence.  Les m√©thodes les plus populaires sont: l'horloge (CLK-glitch), l'alimentation (Vcc-glitch) et le champ √©lectromagn√©tique.  Le champ √©lectromagn√©tique est g√©n√©r√© par une √©tincelle haute tension pr√®s du MC.  Pour cela, NewAE utilise l'√©quipement <a href="http://store.newae.com/chipshouter-kit/">ChipSHOUTER</a> .  Nous ne l'avons pas achet√©, nous n'avons donc effectu√© que les attaques CLK-glitch et Vcc-glitch. </p><br><p>  Les attaques de glitch sont effectu√©es en ajoutant une impulsion de tension: pour CLK-glitch - au signal externe CLOCK du MK (√† partir d'un quartz externe ou d'un g√©n√©rateur), pour Vcc-glitch - sous tension. </p><br><p>  En g√©n√©ral, les attaques glitch vous permettent de contourner toute instruction MK, par exemple, en entrant un mot de passe, une demande d'acc√®s, un accord de licence, etc.  Les attaques par p√©pin sont plus complexes, minutieuses et chronophages.  De plus, il est n√©cessaire de r√©p√©ter √† plusieurs reprises l'attaque de glitch, car son succ√®s est de nature probabiliste et d√©pend des param√®tres de l'impulsion.  Voici les options de glitch: </p><br><p>  ‚Ä¢ scope.glitch.width - largeur d'impulsion en pourcentage par rapport √† CLOCK; </p><br><p>  ‚Ä¢ scope.glitch.offset - d√©calage d'impulsion en pourcentage par rapport √† CLOCK; </p><br><p>  ‚Ä¢ scope.glitch.repeat - le nombre de r√©p√©titions d'impulsions d'attaque; </p><br><p>  ‚Ä¢ scope.glitch.ext_offset - le nombre de mesures manqu√©es apr√®s le d√©clenchement de l'√©v√©nement. </p><br><p>  Les mappages de glitch pour CLK-glitch et Vcc-glitch sont pr√©sent√©s dans les chronogrammes: </p><br><img src="https://habrastorage.org/webt/ll/cs/vb/llcsvbaocipt0fz1rwtrgpswzka.jpeg"><br><p>  <em>Diagramme de temps pour CLK-glitch</em> </p><br><img src="https://habrastorage.org/webt/yc/fr/k5/ycfrk5slksrrxh5sjpcgvv4uons.jpeg"><br><p>  <em>Diagramme de temps pour Vcc-glitch</em> </p><br><p>  Tous les param√®tres de l'impulsion de p√©pin sont s√©lectionn√©s de sorte que le noyau MK fonctionne dans un mode instable (en raison duquel les instructions sont ignor√©es). </p><br><p>  Selon les r√©sultats des attaques glitch, il a √©t√© r√©v√©l√© que si la valeur du param√®tre scope.glitch.repeat est trop petite, le ¬´glissement¬ª des instructions ne se produit pas.  Si vous d√©finissez une grande valeur, vous pouvez ignorer non seulement les instructions n√©cessaires, mais √©galement toutes les instructions suivantes.  Dans la plupart des cas, la recherche de scope.glitch.repeat dans la r√©gion de 5 √† 25 suffit.  En ce qui concerne les autres param√®tres, tout d√©pend du type d'attaque et des conditions de connexion. </p><br><p>  <strong>CLK-glitch</strong> </p><br><p>  Les attaques de glitch CLK sont effectu√©es en ajoutant des impulsions de dur√©e plus courte au signal CLOCK MK.  Par cons√©quent, CLOCK doit √™tre d√©connect√© du MK et aliment√© de ChipWhisperer d√©j√† avec une attaque de glitch CLK. </p><br><p>  Vous devez d'abord connecter ChipWhisperer √† MK: </p><br><img src="https://habrastorage.org/webt/dr/2l/w_/dr2lw_3vrw7t5rcmz5bfuotngno.jpeg"><br><p>  <em>Sch√©ma de raccordement pour CLK-glitch</em> </p><br><p>  Tout le code Python et une description d√©taill√©e du manuel sont pr√©sent√©s sur la <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html%2522/l%2522tutorial-fault-1-openadc-cwlitearm">ressource</a> .  Ensuite, dans STM32F103RBT6, ¬´remplissez¬ª le micrologiciel, o√π la fonction suivante est ajout√©e √† la <code>while(1)</code> principale <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">075</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 076 </span></span>{ <span class="hljs-number"><span class="hljs-number">077</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> inp[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-number"><span class="hljs-number">078</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; <span class="hljs-number"><span class="hljs-number">079</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">080</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"Password:"</span></span>); <span class="hljs-number"><span class="hljs-number">081</span></span> <span class="hljs-number"><span class="hljs-number">082</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((c != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &amp; (cnt &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)) <span class="hljs-number"><span class="hljs-number">083</span></span> { <span class="hljs-number"><span class="hljs-number">084</span></span> c = getch(); <span class="hljs-number"><span class="hljs-number">085</span></span> inp[cnt] = c; <span class="hljs-number"><span class="hljs-number">086</span></span> cnt++; <span class="hljs-number"><span class="hljs-number">087</span></span> } <span class="hljs-number"><span class="hljs-number">088</span></span> <span class="hljs-number"><span class="hljs-number">089</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">090</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passok = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">091</span></span> <span class="hljs-number"><span class="hljs-number">092</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">093</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">094</span></span> <span class="hljs-number"><span class="hljs-number">095</span></span> <span class="hljs-comment"><span class="hljs-comment">//Simple test - doesn't check for too-long password! 096 for(cnt = 0; cnt &lt; 5; cnt++) 097 { 098 if (inp[cnt] != passwd[cnt]) 099 { 100 passok = 0; 101 } 102 } 103 if (!passok){ 104 uart_send("Denied\n"); 105 } 106 else 107 { 108 uart_send("Wow! Vulkan win!\n"); 109 } 110 }</span></span></code> </pre> <br><p>  Notre objectif est de contourner l' <code>if</code> √† la ligne 103 lors de la saisie du mauvais mot de passe et d'entrer dans le cas <code>else</code> √† la ligne 106. La chose la plus importante dans cette attaque est de v√©rifier la variable <code>passok</code> √† la ligne 103. Pour ce faire, s√©lectionnez le param√®tre scope.glitch.ext_offset.  Ceci est plus facile √† faire en connectant l'oscilloscope √† l'UART et en r√©glant le p√©pin √† l'emplacement de l'interf√©rence, car le p√©pin s'infiltre √† travers l'ensemble du MK: </p><br><img src="https://habrastorage.org/webt/de/3q/hv/de3qhvyf89kklulihenck7loqfk.jpeg"><br><p>  <em>Emplacement de Glitch</em> </p><br><p>  Le code d'attaque et la m√©thodologie sont extraits de ce <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">manuel</a> (section Boucle d'attaque, blocs 9‚Äì10).  La seule chose que nous avons modifi√©e dans le code √©tait d'activer la sortie de tous <code>print(response)</code> messages d' <code>print(response)</code> sans filtrage, car les √©v√©nements importants sont souvent ignor√©s en raison de filtres configur√©s comme: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_response <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre> <br><p>  Les figures ci-dessous montrent des exemples d'un journal de sortie de message qui appara√Æt lorsqu'une attaque CLK-glitch est proche du succ√®s ou est loin d'√™tre r√©ussie.  Lorsque vous approchez des param√®tres de p√©pin corrects, des instabilit√©s dans le fonctionnement du MK commencent √† appara√Ætre (les messages s'arr√™tent, le MK red√©marre).  Cela peut √™tre un indice lors de la recherche. </p><br><img src="https://habrastorage.org/webt/hf/n2/b1/hfn2b1ds3gqlkhuwmg0knrjlp98.png"><br><p>  <em>Sortie de message lors d'une attaque de p√©pin avec des param√®tres qui sont loin d'√™tre r√©ussis (a) et proches du succ√®s (b)</em> </p><br><img src="https://habrastorage.org/webt/e_/hy/t7/e_hyt75mrika_metrq8tzrvu518.png"><br><p>  <em>Le r√©sultat d'une attaque r√©ussie de glitch CLK</em> </p><br><p>  √Ä la suite des attaques, il a √©t√© r√©v√©l√© que les param√®tres de l'impulsion de glitch CLK peuvent ¬´flotter¬ª en fonction de la qualit√© de la connexion ChipWhisperer au CLOCK MK.  Par exemple, lors du r√©glage de la sonde de l'oscilloscope sur la broche CLOCK, le param√®tre scope.glitch.offset est devenu diff√©rent pour une attaque r√©ussie, car la sonde a ses propres param√®tres capacitifs inductifs qui corrigent le probl√®me de haute fr√©quence.  La connexion via un long c√¢ble non blind√© peut donc surprendre.  Sinon, les attaques CLK-glitch peuvent √™tre qualifi√©es de stables, comme  leurs param√®tres ont l√©g√®rement chang√© pour diverses instructions (si, pour, tandis que ont √©t√© v√©rifi√©s). </p><br><p>  La m√©thode de protection contre de telles attaques consiste √† utiliser le signal interne CLOCK MK, mais il pr√©sente la pire stabilit√© de temp√©rature et de temps.  En outre, une m√©thode efficace peut √™tre d'introduire un d√©lai al√©atoire avant et apr√®s des instructions importantes (v√©rification des mots de passe, donn√©es personnelles, etc.), ce qui peut compliquer le coup exact de l'impulsion de glitch CLK au bon moment. </p><br><p>  <strong>Vcc-glitch</strong> </p><br><p>  Vcc-glitch, comme CLK-glitch, introduit des interf√©rences √† haute fr√©quence dans le fonctionnement du MK, uniquement en court-circuitant l'alimentation du MK √† la terre.  Lors de la conduite d'attaques Vcc-glitch, il faut tenir compte du fait que les param√®tres d'une impulsion r√©ussie d√©pendent de nombreux facteurs, tels que: </p><br><p>  ‚Ä¢ les caract√©ristiques de conception de la carte de circuit imprim√© pour MK et la pr√©sence d'un cerclage diversifi√©; </p><br><p>  ‚Ä¢ la longueur du c√¢ble coaxial pour connecter MK et le port de glitch de ChipWhisperer (plus le c√¢ble est long, moins la probabilit√© d'une attaque r√©ussie, la longueur optimale est de 10-15 cm); </p><br><p>  ‚Ä¢ s√©rie MK; </p><br><p>  ‚Ä¢ instructions √† sauter; </p><br><p>  ‚Ä¢ Optimisation du compilateur MK; </p><br><p>  ‚Ä¢ type de transistor MOSFET (en raison de la diff√©rence dans les composantes haute fr√©quence des param√®tres S). </p><br><p>  Par cons√©quent, lors de la conduite d'attaques, il est n√©cessaire de s'assurer que ces param√®tres ne changent pas. </p><br><p>  Vous devez d'abord connecter ChipWhisperer √† MK: </p><br><img src="https://habrastorage.org/webt/tv/mu/rx/tvmurxgqouyuiswpaqrkdemm_yg.jpeg"><br><p>  <em>Sch√©ma de connexion pour les attaques Vcc-glitch</em> </p><br><p>  Ensuite, nous ¬´flasher¬ª le firmware dans MK, o√π dans la <code>while(1)</code> principale <code>while(1)</code> il y a la fonction suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">115</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_while</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> 116 </span></span>{ <span class="hljs-number"><span class="hljs-number">117</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> infinity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">118</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">" Hello habr!"</span></span>); <span class="hljs-number"><span class="hljs-number">119</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">120</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">121</span></span> <span class="hljs-number"><span class="hljs-number">122</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(infinity != <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">123</span></span> { <span class="hljs-number"><span class="hljs-number">124</span></span> ; <span class="hljs-number"><span class="hljs-number">125</span></span> } <span class="hljs-number"><span class="hljs-number">126</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WOW!!! Vcc Glitch work!"</span></span>); <span class="hljs-number"><span class="hljs-number">127</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">128</span></span> { <span class="hljs-number"><span class="hljs-number">129</span></span> ; <span class="hljs-number"><span class="hljs-number">130</span></span> } <span class="hljs-number"><span class="hljs-number">131</span></span> }</code> </pre> <br><p>  MK apr√®s l'envoi du message "Bonjour habr!" Entre dans une boucle sans fin sur la ligne 122. Notre t√¢che est de supprimer MK de cette boucle en utilisant Vcc-glitch.  Dans cette boucle, la variable <code>volatile uint8_t infinity</code> est utilis√©e comme condition, qui ne sera jamais √©gale √† deux lorsque le programme <code>volatile uint8_t infinity</code> normalement.  Si nous mettons <code>while(1)</code> au lieu de <code>while(infinity != 2)</code> , le compilateur ignorerait le code ci-dessous, y compris notre message annon√ßant la sortie de la boucle infinie.  En raison d'une variable de type <code>volatile</code> compilateur ne pourra pas le faire.  La <code>while(1)</code> ligne 127 est ajout√©e pour qu'apr√®s le <em>WOW !!!</em>  <em>Vcc Glitch fonctionne!</em>  nous ne sommes pas affich√©s √† nouveau <em>Bonjour habr!</em> </p><br><p>  Nous avons utilis√© du code Python pour contr√¥ler ChipWhisperer √† partir de ce <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">guide</a> .  Voici les messages de MK: </p><br><img src="https://habrastorage.org/webt/ar/ef/s9/arefs9fdqislmsdldtxdzj41zwe.png"><br><p>  <em>Le r√©sultat d'une attaque Vcc-glitch r√©ussie</em> </p><br><p>  Comme on peut le voir sur la figure, l'attaque Vcc-glitch a r√©ussi. </p><br><p>  La difficult√© de mener une attaque Vcc-glitch r√©side dans la s√©lection des param√®tres d'impulsion corrects.  La mise en ≈ìuvre de cette attaque a pris le plus de temps par rapport aux autres, car la mise en ≈ìuvre r√©ussie des attaques Vcc-glitch d√©pend des facteurs d√©crits ci-dessus. </p><br><p>  La m√©thode de protection contre de telles attaques peut √©galement √™tre l'introduction d'un d√©lai al√©atoire avant les instructions importantes et apr√®s celles-ci (v√©rification des mots de passe, des donn√©es personnelles, etc.).  Cela peut compliquer le coup exact de l'impulsion Vcc-glitch au bon moment.  Une augmentation du couplage capacitif entre l'alimentation et la masse lors du c√¢blage PCB peut √©galement aider l√©g√®rement. </p><br><p>  <strong>Conclusions</strong> </p><br><p>  Les attaques men√©es vous permettent de contourner les instructions en MK.  Un exemple d'analyse SCA a montr√© que m√™me le type le plus simple d'une telle attaque peut menacer la s√©curit√© de vos donn√©es (mots de passe, cl√©s de chiffrement).  Nous nous sommes assur√©s que les attaques glitch contournent les diff√©rentes instructions et m√©thodes de protection logicielle pr√©vues dans les appareils.  La m√©thode universelle de protection contre les attaques dans les manuels consid√©r√©s peut √™tre l'introduction de d√©lais al√©atoires lors de l'ex√©cution d'instructions importantes dans le contr√¥leur de gestion. </p><br><p>  Notre √©tude des attaques mat√©rielles ne s'arr√™te pas l√†.  √Ä l'avenir, nous pr√©voyons d'explorer la possibilit√© de contourner la v√©rification de l'octet du firmware du firmware MK √† l'aide d'attaques Vcc-glitch.  L'acc√®s au firmware MK peut ouvrir de grandes opportunit√©s pour un attaquant: du clonage d'un appareil pour la revente √† un acc√®s complet √† toutes les informations propri√©taires et au contr√¥le de MK. </p><br><p>  Dans nos exp√©riences avec Vcc-glitch, nous avons essay√© de contourner la protection du firmware, et nous avons r√©ussi.  Nous nous sommes assur√©s que cela soit possible.  Nous pr√©senterons des exp√©riences d√©montrant la lecture du firmware MK cach√© dans le prochain article. </p><br><p> <a href="http://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security est une √©quipe sp√©ciale d'experts du Centre scientifique et technique Volcano dans le domaine de la s√©curit√© des informations pratiques, de la cryptographie, des circuits, de la r√©tro-ing√©nierie et de la cr√©ation de logiciels de bas niveau. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480500/">https://habr.com/ru/post/fr480500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480486/index.html">Ma solution est la meilleure</a></li>
<li><a href="../fr480488/index.html">Un article sur les bons sacs √† dos (enregistrer)</a></li>
<li><a href="../fr480490/index.html">Connaissance des pilotes Appium (ou comment choisir le pilote n√©cessaire)</a></li>
<li><a href="../fr480494/index.html">environ tech QATOK: mat√©riel de l'√©v√©nement</a></li>
<li><a href="../fr480498/index.html">Analyse: pourquoi avons-nous besoin d'un service de messagerie quand il y a un CRM avec la fonction d'envoyer des lettres?</a></li>
<li><a href="../fr480502/index.html">Le post-futurisme que nous m√©ritons</a></li>
<li><a href="../fr480506/index.html">4. Analyse des programmes malveillants √† l'aide de Check Point forensics. CloudGuard SaaS</a></li>
<li><a href="../fr480508/index.html">AI Journey: rapports et r√©sultats des concours</a></li>
<li><a href="../fr480510/index.html">Chronique de la confrontation entre Rambler et Nginx (mise √† jour le 23 d√©cembre √† 12h00)</a></li>
<li><a href="../fr480512/index.html">Chronique du groupe Rambler et confrontation avec Nginx (mise √† jour le 23 d√©cembre, 12 h)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>