<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’…ğŸ¾ ğŸ‘ğŸ½ ğŸ‘©ğŸ¾â€ğŸ”¬ Yang terbaik adalah musuh dari yang baik â¡ï¸ ğŸ¤™ğŸ½ ğŸ‘¨ğŸ»â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah kisah bagaimana kami pernah memutuskan untuk meningkatkan alat SelfTester internal kami yang kami terapkan untuk menguji kualitas p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yang terbaik adalah musuh dari yang baik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466739/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Gambar 6" align="left"></p>  Artikel ini adalah kisah bagaimana kami pernah memutuskan untuk meningkatkan alat SelfTester internal kami yang kami terapkan untuk menguji kualitas penganalisis PVS-Studio.  Peningkatannya sederhana dan tampaknya bermanfaat, tetapi membuat kami mengalami beberapa masalah.  Kemudian ternyata lebih baik kita menyerah saja. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Kami mengembangkan dan mempromosikan penganalisis kode statis PVS-Studio untuk C, C ++, C # dan Java.  Untuk menguji kualitas alat analisis kami, kami menggunakan alat internal, umumnya disebut SelfTester.  Kami membuat versi SelfTester terpisah untuk setiap bahasa yang didukung.  Itu karena spesifik pengujian, dan itu hanya lebih nyaman.  Dengan demikian, saat ini kami memiliki tiga alat SelfTester internal di perusahaan kami masing-masing untuk C \ C ++, C # dan Java.  Selanjutnya, saya akan memberi tahu Anda tentang versi Windows dari SelfTester untuk proyek-proyek Visual Studio C \ C ++, dengan menyebutnya SelfTester.  Penguji ini adalah yang pertama dalam garis alat internal serupa, ini yang paling canggih dan kompleks dari semua. <br><br>  Bagaimana cara kerja SelfTester?  Idenya sederhana: ambil kumpulan proyek uji (kami menggunakan proyek open source nyata) dan menganalisisnya menggunakan PVS-Studio.  Sebagai hasilnya, log penganalisis dihasilkan untuk setiap proyek.  Log ini dibandingkan dengan log <i>referensi</i> dari proyek yang sama.  Saat membandingkan log, SelfTester membuat <i>ringkasan</i> log yang membandingkan dengan cara yang ramah-pengembang. <br><br>  Setelah mempelajari ringkasan, pengembang menyimpulkan tentang perubahan perilaku penganalisa sesuai dengan jumlah dan jenis peringatan, kecepatan kerja, kesalahan penganalisa internal, dll.  Semua informasi ini sangat penting: ini memungkinkan Anda untuk mengetahui bagaimana penganalisa mengatasi pekerjaannya. <br><br>  Berdasarkan ringkasan perbandingan log, pengembang memperkenalkan perubahan pada inti penganalisa (misalnya, saat membuat aturan diagnostik baru) dan segera mengontrol hasil editnya.  Jika pengembang tidak lagi memiliki masalah untuk membandingkan log biasa, ia membuat <i>referensi</i> log peringatan <i>saat ini</i> untuk proyek.  Kalau tidak, pekerjaan terus berlanjut. <br><br>  Jadi, tugas SelfTester adalah bekerja dengan kumpulan proyek uji (omong-omong, ada lebih dari 120 di antaranya untuk C / C ++).  Proyek-proyek untuk kumpulan dipilih dalam bentuk solusi Visual Studio.  Hal ini dilakukan untuk memeriksa pekerjaan penganalisis pada berbagai versi Visual Studio, yang mendukung penganalisa (pada titik ini dari Visual Studio 2010 ke Visual Studio 2019). <br><br>  <i>Catatan:</i> selanjutnya saya akan memisahkan konsep <i>solusi</i> dan <i>proyek</i> , dengan mempertimbangkan proyek sebagai bagian dari solusi. <br><br>  Antarmuka SelfTester terlihat sebagai berikut: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Gambar 3"></div><br>  Di sebelah kiri ada daftar solusi, di sebelah kanan - hasil cek untuk setiap versi Visual Studio. <br><br>  Label abu-abu "Tidak didukung" menunjukkan bahwa solusi tidak mendukung versi Visual Studio yang dipilih atau tidak dikonversi untuk versi ini.  Beberapa solusi memiliki konfigurasi dalam kumpulan, yang menunjukkan versi Visual Studio tertentu untuk pemeriksaan.  Jika versi tidak ditentukan, solusi akan diperbarui untuk semua versi Visual Studio berikutnya.  Contoh dari solusi semacam itu ada di tangkapan layar - "smart_ptr_check.sln" (sebuah cek dibuat untuk semua versi Visual Studio). <br><br>  Label hijau "OK" menunjukkan bahwa pemeriksaan reguler belum mendeteksi perbedaan dengan log referensi.  Label merah "Diff" menunjukkan tentang perbedaan.  Label-label ini harus mendapat perhatian khusus.  Setelah mengklik dua kali pada label yang diperlukan, solusi yang dipilih akan dibuka dalam versi Visual Studio terkait.  Jendela dengan log peringatan juga akan terbuka di sana.  Tombol kontrol di bagian bawah memungkinkan Anda untuk menjalankan kembali analisis dari solusi yang dipilih atau semua, membuat referensi log yang dipilih (atau sekaligus), dll. <br><br>  Hasil SelfTester selalu diduplikasi dalam laporan html (laporan berbeda) <br><br>  Selain GUI, SelfTester juga memiliki mode otomatis untuk lari malam.  Namun, pola penggunaan yang biasa diulang pengembang dijalankan oleh pengembang selama hari kerja.  Oleh karena itu, salah satu karakteristik SelfTester yang paling penting adalah kecepatan bekerja. <br><br>  Mengapa kecepatan penting: <br><br><ol><li> Kinerja setiap langkah sangat penting dalam hal tes malam berjalan.  Jelas, semakin cepat tes lulus, semakin baik.  Saat ini, waktu kinerja rata-rata SelfTester melebihi 2 jam; </li><li>  Ketika menjalankan SelfTester di siang hari, pengembang harus menunggu lebih sedikit untuk hasilnya, yang meningkatkan produktivitas tenaga kerjanya. </li></ol><br>  Performa yang mempercepat itulah yang menjadi alasan penyempurnaan kali ini. <br><br><h2>  Multi-threading di SelfTester </h2><br>  SelfTester pada awalnya dibuat sebagai aplikasi multithreaded dengan kemampuan untuk secara bersamaan menguji beberapa solusi.  Satu-satunya batasan adalah bahwa Anda tidak dapat secara bersamaan memeriksa solusi yang sama untuk versi Visual Studio yang berbeda, karena banyak solusi perlu diperbarui ke versi Visual Studio tertentu sebelum pengujian.  Selama itu, perubahan diperkenalkan langsung dalam file proyek <i>.vcxproj</i> , yang mengarah ke kesalahan selama menjalankan paralel. <br><br>  Untuk membuat pekerjaan lebih efisien, SelfTester menggunakan penjadwal tugas cerdas untuk menetapkan nilai thread paralel yang sangat terbatas dan memeliharanya. <br><br>  Perencana digunakan pada dua level.  Yang pertama adalah tingkat <i>solusi</i> , digunakan untuk mulai menguji solusi <i>.sln menggunakan</i> utilitas <i>PVS-Studio_Cmd.exe</i> .  Penjadwal yang sama, tetapi dengan pengaturan lain <i>tingkat paralelisme</i> , digunakan di dalam <i>PVS-Studio_Cmd.exe</i> (pada tingkat pengujian <i>file</i> sumber). <br><br>  Tingkat paralelisme adalah parameter yang menunjukkan berapa banyak thread paralel yang harus dijalankan secara bersamaan.  <i>Empat</i> dan <i>delapan</i> nilai default dipilih untuk tingkat paralelisme solusi dan tingkat file, masing-masing.  Dengan demikian, jumlah utas paralel dalam implementasi ini harus 32 (4 solusi dan 8 file yang diuji secara bersamaan).  Pengaturan ini tampak optimal bagi kami untuk pekerjaan analisis pada prosesor delapan inti. <br><br>  Seorang pengembang dapat mengatur sendiri nilai-nilai lain dari tingkat paralelisme sesuai dengan kinerja komputernya atau tugas saat ini.  Jika pengembang tidak menentukan parameter ini, jumlah prosesor sistem logis akan dipilih secara default. <br><br>  <i>Catatan:</i> mari kita asumsikan lebih lanjut bahwa kita berurusan dengan tingkat paralelisme default. <br><br>  Penjadwal <i>LimitedConcurrencyLevelTaskScheduler</i> diwarisi dari <i>System.Threading.Tasks.TaskScheduler</i> dan disempurnakan untuk memberikan tingkat paralelisme maksimum saat bekerja di <i>ThreadPool</i> .  Hirarki warisan: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler</i> memungkinkan Anda untuk menjeda kinerja tugas, dan selain itu, <i>LimitedConcurrencyLevelTaskScheduler</i> memberikan kontrol intelektual terhadap antrian tugas dan menjadwalkan kinerja mereka, dengan mempertimbangkan tingkat paralelisme, ruang lingkup tugas yang dijadwalkan, dan faktor lainnya.  Penjadwal digunakan ketika menjalankan tugas <i>LimitedConcurrencyLevelTaskScheduler</i> . <br><br><h2>  Alasan perbaikan </h2><br>  Proses yang dijelaskan di atas memiliki kelemahan: tidak optimal ketika berhadapan dengan solusi dari berbagai ukuran.  Dan ukuran solusi dalam kumpulan uji <i>sangat</i> beragam: dari 8KB hingga 4GB - ukuran folder dengan solusi dan dari 1 hingga beberapa ribu file kode sumber di masing-masingnya. <br><br>  Penjadwal membuat solusi pada antrian hanya satu demi satu, tanpa komponen yang cerdas.  Biarkan saya mengingatkan Anda bahwa secara default tidak lebih dari empat solusi dapat diuji secara bersamaan.  Jika empat solusi besar saat ini diuji (jumlah file di masing-masing lebih dari delapan), diasumsikan bahwa kami bekerja secara efektif karena kami menggunakan sebanyak mungkin utas (32). <br><br>  Tetapi mari kita bayangkan situasi yang agak sering, ketika beberapa solusi kecil diuji.  Misalnya, satu solusi berukuran besar dan berisi 50 file (jumlah utas maksimum akan digunakan), sementara tiga solusi lainnya masing-masing berisi tiga, empat, lima file.  Dalam hal ini, kami hanya akan menggunakan 20 utas (8 + 3 + 4 + 5).  Kami kurang memanfaatkan waktu prosesor dan mengurangi kinerja secara keseluruhan. <br><br>  <i>Catatan</i> : sebenarnya, bottleneck biasanya adalah subsistem disk, bukan prosesor. <br><br><h2>  Perbaikan </h2><br>  Peningkatan yang jelas dalam hal ini adalah peringkat daftar solusi yang diuji.  Kita perlu mendapatkan penggunaan yang optimal dari jumlah set thread yang dilakukan secara simultan (32), dengan melewati untuk menguji proyek dengan jumlah file yang benar. <br><br>  Mari kita perhatikan lagi contoh pengujian empat solusi dengan jumlah file berikut di masing-masing: 50, 3, 4 dan 5. Tugas yang memeriksa solusi dari <i>tiga</i> file cenderung bekerja paling cepat.  Akan lebih baik untuk menambahkan solusi dengan delapan file atau lebih daripada itu (untuk menggunakan maksimum dari utas yang tersedia untuk solusi ini).  Dengan cara ini, kami akan menggunakan 25 utas sekaligus (8 + <b>8</b> + 4 + 5).  Tidak buruk.  Namun, tujuh utas masih belum terlibat.  Dan inilah ide perbaikan lain, yaitu untuk menghapus batas empat utas pada solusi pengujian.  Karena kita sekarang dapat menambahkan bukan hanya satu, tetapi beberapa solusi, menggunakan 32 utas.  Mari kita bayangkan bahwa kita memiliki dua solusi masing-masing dari tiga dan empat file.  Menambahkan tugas-tugas ini akan sepenuhnya menutup "celah" dari utas yang tidak digunakan, dan akan ada 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ) dari mereka. <br><br>  Semoga idenya jelas.  Padahal, implementasi perbaikan ini juga tidak membutuhkan banyak usaha.  Semuanya dilakukan dalam satu hari. <br><br>  Kami perlu mengerjakan ulang kelas tugas: mewarisi dari <i>System.Threading.Tasks.Task</i> dan penugasan bidang "berat".  Kami menggunakan algoritma sederhana untuk menetapkan bobot ke solusi: jika jumlah file kurang dari delapan, beratnya sama dengan nomor ini (misalnya, 5).  Jika angkanya lebih besar atau sama dengan delapan, beratnya akan sama dengan delapan. <br><br>  Kami juga harus menjabarkan penjadwal: mengajarkannya untuk memilih solusi dengan bobot yang dibutuhkan untuk mencapai nilai maksimum 32 utas.  Kami juga harus mengizinkan lebih dari empat utas untuk pengujian solusi simultan. <br><br>  Akhirnya, kami membutuhkan langkah awal untuk menganalisis semua solusi di kumpulan (evaluasi menggunakan MSBuild API) untuk mengevaluasi dan menetapkan bobot solusi (mendapatkan jumlah file dengan kode sumber). <br><br><h2>  Hasil </h2><br>  Saya pikir setelah perkenalan yang begitu lama Anda sudah menebak bahwa tidak ada yang datang dari itu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Gambar 12"></div><br>  Meskipun demikian, perbaikannya sederhana dan cepat. <br><br>  Inilah bagian dari artikel itu, di mana saya akan memberi tahu Anda tentang apa yang "membawa kita ke banyak masalah" dan semua hal yang berkaitan dengannya. <br><br><h2>  Efek samping </h2><br>  Jadi, hasil negatif juga merupakan hasil.  Ternyata jumlah solusi besar di kolam <i>jauh melebihi</i> jumlah yang kecil (kurang dari delapan file).  Dalam hal ini, peningkatan ini tidak memiliki efek yang sangat nyata, karena hampir tidak terlihat: pengujian proyek kecil membutuhkan waktu yang sangat kecil dibandingkan dengan waktu, yang dibutuhkan untuk proyek besar. <br><br>  Namun, kami memutuskan untuk meninggalkan penyempurnaan baru sebagai "tidak mengganggu" dan berpotensi bermanfaat.  Selain itu, kumpulan solusi pengujian terus diisi ulang, sehingga di masa depan, mungkin, situasinya akan berubah. <br><br>  Dan kemudian ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Gambar 5"></div><br>  Salah satu pengembang mengeluh tentang kehancuran SelfTester.  Ya, hidup terjadi.  Untuk mencegah kesalahan ini agar tidak hilang, kami membuat insiden internal (tiket) dengan nama "Pengecualian ketika bekerja dengan SelfTester".  Kesalahan terjadi saat mengevaluasi proyek.  Meskipun sejumlah besar jendela dengan kesalahan menunjukkan masalah kembali pada penangan kesalahan.  Tapi ini dengan cepat dihilangkan, dan selama minggu berikutnya tidak ada yang jatuh.  Tiba-tiba, pengguna lain mengeluh tentang SelfTester.  Sekali lagi, kesalahan evaluasi proyek: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Gambar 8"></div><br>  Kali ini tumpukan berisi banyak informasi berguna - kesalahannya adalah dalam format xml.  Kemungkinan, ketika menangani file proyek <i>Proto_IRC.vcxproj</i> (representasi xml-nya) sesuatu terjadi pada file itu sendiri, itu sebabnya <i>XmlTextReader</i> tidak bisa menanganinya. <br><br>  Memiliki dua kesalahan dalam waktu yang cukup singkat membuat kami melihat lebih dekat pada masalahnya.  Selain itu, seperti yang saya katakan di atas, SelfTester sangat aktif digunakan oleh pengembang. <br><br>  Untuk memulainya, kami menganalisis crash terakhir.  Sedih untuk mengatakan, kami menemukan tidak ada yang mencurigakan.  Untuk berjaga-jaga kami meminta pengembang (pengguna SelfTester) untuk mengawasi dan melaporkan tentang kemungkinan kesalahan. <br><br>  Poin penting: kode yang salah digunakan kembali di SelfTester.  Ini awalnya digunakan untuk mengevaluasi proyek-proyek dalam penganalisa itu sendiri ( <i>PVS-Studio_Cmd.exe</i> ).  Itu sebabnya perhatian terhadap masalah telah tumbuh.  Namun, tidak ada crash seperti itu di penganalisa. <br><br>  Sementara itu, tiket tentang masalah dengan SelfTester dilengkapi dengan kesalahan baru: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Gambar 9"></div><br>  <i>XmlException</i> lagi.  Jelas, ada utas bersaing di suatu tempat yang bekerja dengan membaca dan menulis file proyek.  SelfTester bekerja dengan proyek dalam kasus-kasus berikut: <br><br><ol><li>  Evaluasi proyek dalam proses perhitungan awal bobot solusi: langkah baru yang awalnya menimbulkan kecurigaan; </li><li>  Memperbarui proyek ke versi Visual Studio yang diperlukan: dilakukan tepat sebelum pengujian (proyek tidak mengganggu) dan tidak boleh memengaruhi proses kerja. </li><li>  Evaluasi proyek selama pengujian: mekanisme thread-safe mapan, digunakan kembali dari <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Mengembalikan file proyek (mengganti file <i>.vcxproj yang</i> dimodifikasi dengan file referensi awal) ketika keluar dari SelfTester, karena file proyek dapat memperbarui ke versi Visual Studio yang diperlukan selama pekerjaan.  Ini adalah langkah terakhir, yang tidak berdampak pada mekanisme lain. </li></ol><br>  Kecurigaan jatuh pada kode baru yang ditambahkan untuk optimasi (perhitungan berat).  Tetapi penyelidikan kode menunjukkan bahwa jika pengguna menjalankan analisis tepat setelah dimulainya SelfTester, tester selalu benar menunggu sampai akhir pra-evaluasi.  Tempat ini tampak aman. <br><br>  Sekali lagi, kami tidak dapat mengidentifikasi sumber masalah. <br><br><h2>  Nyeri </h2><br>  Semua bulan berikutnya SelfTester terus crash terus menerus.  Tiket terus terisi dengan data, tetapi tidak jelas apa yang harus dilakukan dengan data ini.  Sebagian besar crash dengan <i>XmlException yang</i> sama <i>.</i>  Kadang-kadang ada sesuatu yang lain, tetapi pada kode yang digunakan kembali yang sama dari <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Gambar 1"></div><br>  Secara tradisional, alat internal tidak memberlakukan persyaratan yang sangat tinggi, jadi kami terus mencari kesalahan SelfTester tentang prinsip residual.  Dari waktu ke waktu, orang yang berbeda terlibat (selama seluruh insiden enam orang mengerjakan masalah, termasuk dua pekerja magang).  Namun, kami harus terganggu oleh tugas ini. <br><br>  <i>Kesalahan pertama kami.</i>  Bahkan, pada titik ini kita bisa menyelesaikan masalah ini untuk selamanya.  Bagaimana?  Jelas bahwa kesalahan itu disebabkan oleh optimasi baru.  Bagaimanapun, sebelum semuanya bekerja dengan baik, dan kode yang digunakan kembali jelas tidak bisa seburuk itu.  Selain itu, pengoptimalan ini tidak membawa manfaat apa pun.  Jadi apa yang harus dilakukan?  <i>Hapus pengoptimalan ini.</i>  Seperti yang mungkin Anda pahami, itu tidak dilakukan.  Kami terus mengerjakan masalah, yang kami ciptakan sendiri.  Kami terus mencari jawabannya: "BAGAIMANA?"  Bagaimana itu crash?  Tampaknya ditulis dengan benar. <br><br>  <i>Kesalahan kedua kami.</i>  <i>Orang lain terlibat</i> dalam memecahkan masalah <i>.</i>  Ini kesalahan yang sangat, sangat besar.  Tidak hanya tidak menyelesaikan masalah tetapi juga membutuhkan sumber daya terbuang tambahan.  Ya, orang-orang baru membawa ide-ide baru, tetapi butuh banyak waktu kerja untuk mengimplementasikan (tanpa alasan) ide-ide ini.  Pada titik tertentu, kami meminta peserta magang menulis program pengujian yang meniru evaluasi satu dan proyek yang sama di utas yang berbeda dengan modifikasi paralel dari suatu proyek di proyek lain.  Itu tidak membantu.  Kami hanya menemukan bahwa MSBuild API aman di dalam, yang sudah kami ketahui.  Kami juga menambahkan penghematan mini dump otomatis saat pengecualian <i>XmlException</i> terjadi.  Kami memiliki seseorang yang men-debug semua ini.  Orang miskin!  Ada diskusi, kami melakukan hal-hal lain yang tidak perlu. <br><br>  <i>Akhirnya, keluar kesalahan ketiga.</i>  Tahukah Anda berapa banyak waktu yang telah berlalu sejak masalah SelfTester terjadi sampai ke titik ketika masalah itu diselesaikan?  Nah, Anda bisa menghitung sendiri.  Tiket dibuat pada 09/17/2018 dan ditutup pada 02/20/2019.  Ada lebih dari 40 komentar!  Guys, itu banyak waktu!  Kami <i>membiarkan diri kami</i> sibuk selama lima bulan dengan INI.  Pada saat yang sama kami sibuk mendukung Visual Studio 2019, menambahkan dukungan bahasa Jawa, memperkenalkan standar MISRA C / C ++, meningkatkan penganalisa C #, berpartisipasi aktif dalam konferensi, menulis banyak artikel, dll.  Semua aktivitas ini menerima lebih sedikit waktu pengembang karena kesalahan bodoh di SelfTester. <br><br>  Teman-teman, belajarlah dari kesalahan kita dan jangan pernah melakukan ini.  Kami juga tidak akan melakukannya. <br><br>  Itu saja, saya sudah selesai. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Gambar 15"></div><br>  Oke, itu hanya lelucon, saya akan memberi tahu Anda apa masalahnya dengan SelfTester :) <br><br><h2>  Bingo! </h2><br>  Untungnya, ada seseorang di antara kami dengan pandangan mata jernih (kolega saya Sergey Vasiliev), yang hanya melihat masalah dari sudut pandang yang sangat berbeda (dan juga - ia mendapat sedikit keberuntungan).  Bagaimana jika tidak apa-apa di dalam SelfTester, tetapi sesuatu dari luar merusak proyek?  Biasanya kami tidak meluncurkan apa pun dengan SelfTester, dalam beberapa kasus kami benar-benar mengendalikan lingkungan eksekusi.  Dalam hal ini, "sesuatu" yang sangat ini bisa jadi SelfTester itu sendiri, tetapi contoh yang berbeda. <br><br>  Saat keluar dari SelfTester, utas yang mengembalikan file proyek dari referensi, terus bekerja untuk sementara waktu.  Pada titik ini, penguji mungkin diluncurkan lagi.  Perlindungan terhadap proses simultan dari beberapa instance SelfTester telah ditambahkan <i>kemudian</i> dan sekarang terlihat sebagai berikut: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Gambar 16"></div><br>  Tetapi pada saat itu kami tidak memilikinya. <br><br>  Kacang-kacangan, tetapi benar - selama hampir enam bulan siksaan tidak ada yang memperhatikannya.  Mengembalikan proyek dari referensi adalah prosedur latar belakang yang cukup cepat, tetapi sayangnya tidak cukup cepat untuk tidak mengganggu peluncuran ulang SelfTester.  Dan apa yang terjadi ketika kita meluncurkannya?  Itu benar, menghitung bobot solusi.  Satu proses menulis ulang file <i>.vcxproj</i> sementara yang lain mencoba membacanya.  Ucapkan salam untuk <i>XmlException</i> . <br><br>  Sergey mengetahui semua ini ketika dia menambahkan kemampuan untuk beralih ke set log referensi yang berbeda ke tester.  Itu menjadi perlu setelah menambahkan satu set aturan MISRA di penganalisa.  Anda dapat beralih langsung di antarmuka, sementara pengguna melihat jendela ini: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Gambar 14"></div><br>  Setelah itu, <i>SelfTester</i> memulai kembali.  Dan sebelumnya, tampaknya, pengguna entah bagaimana meniru masalah itu sendiri, menjalankan tester lagi. <br><br><h2>  Blamestorming dan kesimpulan </h2><br>  Tentu saja, kami menghapus (yaitu, dinonaktifkan) optimasi yang dibuat sebelumnya.  Selain itu, itu jauh lebih mudah daripada melakukan semacam sinkronisasi antara memulai kembali tester dengan sendirinya.  Dan semuanya mulai bekerja dengan sempurna, seperti sebelumnya.  Dan sebagai langkah tambahan, kami menambahkan perlindungan di atas terhadap peluncuran tester secara bersamaan. <br><br>  Saya sudah menulis di atas tentang kesalahan utama kami ketika mencari masalah, jadi cukup dengan self flagellation.  Kita adalah manusia, jadi kita mungkin salah.  Penting untuk belajar dari kesalahan Anda sendiri dan menarik kesimpulan.  Kesimpulan dari kasus ini cukup sederhana: <br><br><ul><li>  Kita harus memantau dan memperkirakan kompleksitas tugas; </li><li>  Terkadang kita perlu berhenti di beberapa titik; </li><li>  Cobalah untuk melihat masalahnya secara lebih luas.  Seiring waktu seseorang bisa mendapatkan visi terowongan dari kasus ini sementara itu membutuhkan perspektif yang segar. </li><li>  Jangan takut untuk menghapus kode lama atau tidak perlu. </li></ul><br>  Itu saja, kali ini saya pasti selesai.  Terima kasih sudah membaca sampai akhir.  Semoga kode bugless Anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466739/">https://habr.com/ru/post/id466739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466729/index.html">Buku "Data mining. Mengambil informasi dari Facebook, Twitter, LinkedIn, Instagram, GitHub Â»</a></li>
<li><a href="../id466731/index.html">Extravaganza. September naik</a></li>
<li><a href="../id466733/index.html">Selamat datang di DINS Java EVENING 18 September</a></li>
<li><a href="../id466735/index.html">Cara mudah untuk membuat peringatan suara di sistem Home Automation ("Smart Home")</a></li>
<li><a href="../id466737/index.html">Mengapa jaringan sosial Google+ gagal</a></li>
<li><a href="../id466741/index.html">Yang terbaik adalah musuh dari yang baik</a></li>
<li><a href="../id466745/index.html">Tempat kerja pertama atau cara mulai mengembangkan API di Node.js</a></li>
<li><a href="../id466747/index.html">Mitap pengembang iOS di Redmadrobot</a></li>
<li><a href="../id466753/index.html">Administrasi Jaringan Cepat dan Efisien - Jaringan MACMonitor</a></li>
<li><a href="../id466755/index.html">Komputer akan membuat Anda enak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>