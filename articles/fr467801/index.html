<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÆ ü§í üóíÔ∏è Automatisation pour les plus petits. Partie 1.1. Bases de la virtualisation üë©üèΩ‚Äçüåæ üö≠ üèáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article pr√©c√©dent a examin√© l'architecture d'un r√©seau virtualis√©, la superposition de sous-couches, le chemin du package entre les machines virtuel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisation pour les plus petits. Partie 1.1. Bases de la virtualisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article pr√©c√©dent a</a> examin√© l'architecture d'un r√©seau virtualis√©, la superposition de sous-couches, le chemin du package entre les machines virtuelles et plus encore. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Roman Gorge a √©t√©</a> inspir√© par elle et a d√©cid√© d'√©crire un num√©ro de revue sur la virtualisation en g√©n√©ral. <br><br>  Dans cet article, nous aborderons (ou essayerons de toucher) les questions: comment la virtualisation des fonctions r√©seau se produit r√©ellement, comment le backend des principaux produits pour le lancement et la gestion des VM est impl√©ment√©, et comment fonctionne la commutation virtuelle (pont OVS et Linux). <br><br>  Le sujet de la virtualisation est large et profond, il est impossible d'expliquer tous les d√©tails du travail de l'hyperviseur (et ce n'est pas n√©cessaire).  Nous nous limiterons √† l'ensemble minimal de connaissances n√©cessaires pour comprendre le fonctionnement de toute solution virtualis√©e, pas n√©cessairement Telco. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1>  Table des mati√®res </h1><br><ul><li>  <b>Introduction et bref historique de la virtualisation</b> </li><li>  <b>Types de ressources virtuelles - calcul, stockage, r√©seau</b> </li><li>  <b>Commutation virtuelle</b> </li><li>  <b>Outils de virtualisation - libvirt, virsh et plus</b> </li><li>  <b>Conclusion</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1>  Introduction et bref historique de la virtualisation </h1><br><br>  L'histoire des technologies de virtualisation modernes remonte √† 1999, lorsque la jeune entreprise VMware a lanc√© un produit appel√© VMware Workstation.  Il s'agissait d'un produit de virtualisation pour les applications de bureau / client.  La virtualisation c√¥t√© serveur est venue un peu plus tard sous la forme du produit ESX Server, qui a √©volu√© plus tard vers ESXi (je veux dire int√©gr√©) - c'est le m√™me produit qui est utilis√© universellement dans les TI et les t√©l√©communications comme hyperviseur d'application de serveur. <br><br>  C√¥t√© opensource, deux projets majeurs ont apport√© la virtualisation √† Linux: <br><ul><li>  KVM (Kernel-based Virtual Machine) est un module de noyau Linux qui permet au noyau de fonctionner comme un hyperviseur (cr√©e l'infrastructure n√©cessaire pour d√©marrer et g√©rer des machines virtuelles).  Il a √©t√© ajout√© dans la version 2.6.20 du noyau en 2007. </li><li>  QEMU (Quick Emulator) - √©mule directement le mat√©riel d'une machine virtuelle (CPU, disque, RAM, tout ce qui inclut un port USB) et est utilis√© en conjonction avec KVM pour obtenir des performances presque "natives". </li></ul><br><br><blockquote>  En fait, pour le moment, toutes les fonctionnalit√©s de KVM sont disponibles dans QEMU, mais ce n'est pas important, car la plupart des utilisateurs de virtualisation Linux n'utilisent pas directement KVM / QEMU, mais y acc√®dent via au moins un niveau d'abstraction, mais plus √† ce sujet plus tard. <br></blockquote><br><br>  Aujourd'hui, VMware ESXi et Linux QEMU / KVM sont les deux principaux hyperviseurs qui dominent le march√©.  Ils sont √©galement des repr√©sentants de deux types diff√©rents d'hyperviseurs: <br><ul><li>  Type 1 - l'hyperviseur fonctionne directement sur le mat√©riel (m√©tal nu).  Il s'agit de VMware ESXi, Linux KVM, Hyper-V </li><li>  Type 2 - l'hyperviseur est lanc√© dans le syst√®me d'exploitation h√¥te (syst√®me d'exploitation).  Il s'agit de VMware Workstation ou d'Oracle VirtualBox. </li></ul><br><br>  Une discussion de ce qui est mieux et de ce qui est pire d√©passe le cadre de cet article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br>  Les producteurs de fer devaient √©galement faire leur part pour garantir des performances acceptables. <br><br>  Peut-√™tre le plus important et le plus largement utilis√© est Intel VT (Virtualization Technology) - un ensemble d'extensions d√©velopp√©es par Intel pour ses processeurs x86 qui sont utilis√©es pour le fonctionnement efficace de l'hyperviseur (et dans certains cas sont n√©cessaires, par exemple, KVM ne fonctionnera pas sans VT activ√©) -x et sans lui, l'hyperviseur est oblig√© de s'engager dans une √©mulation purement logicielle, sans acc√©l√©ration mat√©rielle). <br>  Deux de ces extensions sont les plus connues - VT-x et VT-d.  Le premier est important pour am√©liorer les performances du processeur pendant la virtualisation, car il fournit une prise en charge mat√©rielle de certaines de ses fonctions (avec VT-x 99,9%, le code du SE invit√© est ex√©cut√© directement sur le processeur physique, ne produisant des sorties pour l'√©mulation que dans les cas les plus n√©cessaires), le second est destin√© √† connecter directement des p√©riph√©riques physiques √† une machine virtuelle (pour les fonctions virtuelles avanc√©es (VF) SRIOV, par exemple, VT-d <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doit √™tre activ√©</a> ). <br><br>  Le prochain concept important est la diff√©rence entre la virtualisation compl√®te et la para-virtualisation. <br>  La virtualisation compl√®te est bonne, elle vous permet d'ex√©cuter n'importe quel syst√®me d'exploitation sur n'importe quel processeur, cependant, elle est extr√™mement inefficace et ne convient absolument pas aux syst√®mes fortement charg√©s. <br>  La para-virtualisation, en bref, est lorsque le syst√®me d'exploitation invit√© comprend qu'il s'ex√©cute dans un environnement virtuel et coop√®re avec l'hyperviseur pour atteindre une plus grande efficacit√©.  Autrement dit, l'interface invit√©-hyperviseur appara√Æt. <br>  La grande majorit√© des syst√®mes d'exploitation utilis√©s aujourd'hui prennent en charge la para-virtualisation - dans le noyau Linux, cela est apparu depuis la version 2.6.20 du noyau. <br><br>  Pour qu'une machine virtuelle fonctionne, non seulement un processeur virtuel (vCPU) et une m√©moire virtuelle (RAM) sont n√©cessaires; l'√©mulation de p√©riph√©riques PCI est √©galement requise.  En fait, un ensemble de pilotes est requis pour g√©rer les interfaces r√©seau virtuelles, les disques, etc. <br>  Dans l'hyperviseur KVM Linux, cette t√¢che a √©t√© r√©solue en impl√©mentant <b>virtio</b> , un cadre de d√©veloppement et d'utilisation de p√©riph√©riques d'E / S virtualis√©s. <br>  Virtio est un niveau d'abstraction suppl√©mentaire, qui vous permet d'√©muler divers p√©riph√©riques d'E / S dans un hyperviseur para-virtualis√©, fournissant une interface unifi√©e et standardis√©e sur le c√¥t√© de la machine virtuelle.  Cela vous permet de r√©utiliser le code du pilote virtio pour divers p√©riph√©riques intrins√®quement.  Virtio se compose de: <br><ul><li>  Pilote frontal - contenu de la machine virtuelle </li><li>  Pilote principal - contenu de l'hyperviseur </li><li>  Pilote de transport - ce qui relie le backend et le frontend </li></ul><br>  Cette modularit√© vous permet de changer les technologies utilis√©es dans l'hyperviseur sans affecter les pilotes de la machine virtuelle (ce point est tr√®s important pour les technologies d'acc√©l√©ration r√©seau et les solutions Cloud en g√©n√©ral, mais plus √† ce sujet plus tard). <br>  Autrement dit, il existe une connexion invit√©-hyperviseur lorsque le syst√®me d'exploitation invit√© "sait" qu'il s'ex√©cute dans un environnement virtuel. <br><blockquote>  Si vous avez d√©j√† √©crit une question dans la DP ou r√©pondu √† une question dans la DP ¬´La virtio est-elle prise en charge dans votre produit?¬ª  Il s'agissait simplement de prendre en charge le pilote virtio frontal. <br></blockquote><br><br><h1>  Types de ressources virtuelles - calcul, stockage, r√©seau </h1><br>  En quoi consiste une machine virtuelle? <br>  Il existe trois principaux types de ressources virtuelles: <br><br><ul><li>  calcul - processeur et RAM </li><li>  stockage - disque syst√®me de la machine virtuelle et stockage par blocs </li><li>  r√©seau - cartes r√©seau et p√©riph√©riques d'entr√©e / sortie </li></ul><br><br><hr><br><br><h1>  Calculer </h1><br><br><h2>  CPU </h2><br>  Th√©oriquement, QEMU est capable d'√©muler n'importe quel type de processeur et ses indicateurs et fonctionnalit√©s correspondants; en pratique, ils utilisent soit le mod√®le h√¥te et d√©sactivent les indicateurs ponctuellement avant de les transf√©rer vers le syst√®me d'exploitation invit√©, soit ils prennent le mod√®le nomm√© et activent / d√©sactivent les indicateurs ponctuellement. <br><br>  Par d√©faut, QEMU √©mulera un processeur que le SE invit√© reconna√Ætra comme CPU virtuel QEMU.  Ce n'est pas le type de processeur le plus optimal, surtout si une application s'ex√©cutant sur une machine virtuelle utilise des drapeaux CPU pour son travail.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En savoir plus sur les diff√©rents mod√®les de CPU dans QEMU</a> . <br><br>  QEMU / KVM vous permet √©galement de contr√¥ler la topologie du processeur, le nombre de threads, la taille du cache, de lier vCPU au c≈ìur physique et bien plus encore. <br><br>  La n√©cessit√© ou non d'une machine virtuelle d√©pend du type d'application ex√©cut√©e sur le syst√®me d'exploitation invit√©.  Par exemple, il est bien connu que pour les applications qui traitent des paquets avec un PPS √©lev√©, il est important de proc√©der √† <b>l'√©pinglage du processeur</b> , c'est-√†-dire de ne pas permettre le transfert du processeur physique vers d'autres machines virtuelles. <br><br><h2>  La m√©moire </h2><br>  La prochaine ligne est la RAM.  Du point de vue de Host OS, une machine virtuelle lanc√©e √† l'aide de QEMU / KVM n'est pas diff√©rente de tout autre processus ex√©cut√© dans l'espace utilisateur du syst√®me d'exploitation.  En cons√©quence, le processus d'allocation de m√©moire √† une machine virtuelle est effectu√© par les m√™mes appels dans le noyau Host OS, comme si vous aviez lanc√©, par exemple, un navigateur Chrome. <br><br><blockquote>  Avant de poursuivre l'histoire de la RAM dans les machines virtuelles, vous devez vous √©loigner et expliquer le terme <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NUMA</a></b> - Non-Uniform Memory Access. <br>  L'architecture des serveurs physiques modernes implique la pr√©sence de deux ou plusieurs processeurs (CPU) et associ√©s √† une m√©moire vive (RAM).  Un tel tas de processeur + m√©moire est appel√© un n≈ìud ou un n≈ìud.  La communication entre les diff√©rents n≈ìuds NUMA s'effectue via un bus sp√©cial - <b>QPI</b> (QuickPath Interconnect) <br><br>  Le n≈ìud NUMA local est allou√© - lorsque le processus en cours d'ex√©cution dans le syst√®me d'exploitation utilise le processeur et la RAM situ√©s dans le m√™me n≈ìud NUMA, et le n≈ìud NUMA distant - lorsque le processus en cours d'ex√©cution dans le syst√®me d'exploitation utilise le processeur et la RAM situ√©s dans diff√©rents n≈ìuds NUMA, c'est-√†-dire que pour l'interaction du processeur et de la m√©moire, un transfert de donn√©es via le bus QPI est requis. <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br>  Du point de vue de la machine virtuelle, la m√©moire lui √©tait d√©j√† allou√©e au moment de son lancement, mais en r√©alit√© ce n'est pas le cas, et le noyau Host OS alloue de nouvelles sections de m√©moire au processus QEMU / KVM car l'application dans Guest OS demande de la m√©moire suppl√©mentaire (bien qu'il puisse √©galement y avoir une exception si vous sp√©cifiez directement QEMU / KVM pour allouer toute la m√©moire √† la machine virtuelle directement au d√©marrage). <br><br>  La m√©moire est allou√©e non octet par octet, mais par une certaine taille - <b>page</b> .  La taille de la page est configurable et peut th√©oriquement √™tre n'importe laquelle, mais en pratique, la taille est de 4 Ko (par d√©faut), 2 Mo et 1 Go.  Les deux derni√®res tailles sont appel√©es <b>HugePages</b> et sont souvent utilis√©es pour allouer de la m√©moire aux machines virtuelles gourmandes en m√©moire.  La raison d'utiliser HugePages dans le processus de recherche d'une correspondance entre l'adresse virtuelle de la page et la m√©moire physique dans <b>Translation Lookaside Buffer</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLB</a></b> ), qui √† son tour est limit√© et stocke des informations uniquement sur les derni√®res pages utilis√©es.  S'il n'y a aucune information sur la page souhait√©e dans le TLB, un processus appel√© <b>miss TLB</b> se produit et vous devez utiliser le processeur Host OS pour trouver la cellule de m√©moire physique correspondant √† la page souhait√©e. <br><br>  Ce processus est inefficace et lent, donc moins de pages de plus grande taille sont utilis√©es. <br>  QEMU / KVM vous permet √©galement d'√©muler diverses topologies NUMA pour le syst√®me d'exploitation invit√©, de prendre de la m√©moire pour une machine virtuelle uniquement √† partir d'un syst√®me d'exploitation h√¥te de n≈ìud NUMA sp√©cifique, etc.  La pratique la plus courante consiste √† extraire la m√©moire d'une machine virtuelle d'un n≈ìud NUMA local vers les processeurs allou√©s √† la machine virtuelle.  La raison en est le d√©sir d'√©viter une charge inutile sur le bus <b>QPI</b> reliant les sockets CPU du serveur physique (bien s√ªr, cela est logique si votre serveur a 2 sockets ou plus). <br><br><hr><br><br><h1>  Stockage </h1><br>  Comme vous le savez, la RAM est appel√©e m√©moire op√©rationnelle car son contenu dispara√Æt lorsque l'alimentation est coup√©e ou que le syst√®me d'exploitation est red√©marr√©.  Pour stocker des informations, vous avez besoin d'un p√©riph√©rique de stockage persistant (ROM) ou d' <b>un stockage persistant</b> . <br>  Il existe deux principaux types de stockage persistant: <br><ul><li>  Stockage de blocs - un bloc d'espace disque qui peut √™tre utilis√© pour installer le syst√®me de fichiers et cr√©er des partitions.  Si c'est grossier, vous pouvez le prendre comme un disque normal. </li><li>  Stockage d'objets - les informations ne peuvent √™tre enregistr√©es qu'en tant qu'objet (fichier), accessible via HTTP / HTTPS.  Des exemples typiques de stockage d'objets sont AWS S3 ou Dropbox. </li></ul><br><br>  La machine virtuelle a besoin d' <b>un stockage persistant</b> , cependant, comment faire si la machine virtuelle "vit" dans la RAM du syst√®me d'exploitation h√¥te?  En bref, tout appel du syst√®me d'exploitation invit√© au contr√¥leur de disque virtuel est intercept√© par QEMU / KVM et transform√© en un enregistrement sur le disque physique du syst√®me d'exploitation h√¥te.  Cette m√©thode est inefficace et, par cons√©quent, ici comme pour les p√©riph√©riques r√©seau, le pilote virtio est utilis√© au lieu d'√©muler compl√®tement un p√©riph√©rique IDE ou iSCSI.  En savoir plus √† ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Ainsi, la machine virtuelle acc√®de √† son disque virtuel via un pilote virtio, puis QEMU / KVM effectue les informations transf√©r√©es √©crites sur le disque physique.  Il est important de comprendre que dans Host OS, un backend de disque peut √™tre impl√©ment√© en tant que plateau CEPH, NFS ou iSCSI. <br><br>  La fa√ßon la plus simple d'√©muler un stockage persistant est d'utiliser le fichier dans un r√©pertoire du syst√®me d'exploitation h√¥te comme espace disque d'une machine virtuelle.  QEMU / KVM prend en charge de nombreux formats diff√©rents de ce type de fichier - raw, vdi, vmdk et autres.  Cependant, le format le plus utilis√© est <b>qcow2</b> (QEMU copy-on-write version 2).  En g√©n√©ral, qcow2 est un fichier structur√© d'une certaine mani√®re sans aucun syst√®me d'exploitation.  Un grand nombre de machines virtuelles sont distribu√©es sous forme d'images qcow2 (images) et sont une copie du disque syst√®me d'une machine virtuelle, compress√©e au format qcow2.  Cela pr√©sente plusieurs avantages - le codage qcow2 prend beaucoup moins d'espace qu'une copie brute d'un disque d'octet √† octet, QEMU / KVM peut redimensionner un fichier qcow2, ce qui signifie qu'il est possible de modifier la taille du disque d'une machine virtuelle, le cryptage AES qcow2 est √©galement pris en charge (cela a du sens, car l'image d'une machine virtuelle peut contenir une propri√©t√© intellectuelle). <br><br>  De plus, lorsque la machine virtuelle d√©marre, QEMU / KVM utilise le fichier qcow2 comme disque syst√®me (j'omet le processus de chargement de la machine virtuelle ici, bien que ce soit √©galement une t√¢che int√©ressante), et la machine virtuelle a la capacit√© de lire / √©crire des donn√©es dans le fichier qcow2 via virtio chauffeur.  Ainsi, le processus de prise d'images de machines virtuelles fonctionne, car √† tout moment le fichier qcow2 contient une copie compl√®te du disque syst√®me de la machine virtuelle, et l'image peut √™tre utilis√©e pour la sauvegarde, le transfert vers un autre h√¥te, etc. <br><br>  En g√©n√©ral, ce fichier qcow2 sera d√©fini dans l'OS invit√© en tant que <i>p√©riph√©rique / dev / vda</i> , et l'OS invit√© partitionnera l'espace disque en partitions et installera le syst√®me de fichiers.  De m√™me, les fichiers qcow2 suivants connect√©s par QEMU / KVM en tant que p√©riph√©riques <i>/ dev / vdX</i> peuvent √™tre utilis√©s comme <b>stockage de bloc</b> dans une machine virtuelle pour stocker des informations (c'est exactement comment fonctionne le composant Openstack Cinder). <br><hr><br><br><h1>  R√©seau </h1><br>  Les derni√®res cartes virtuelles et p√©riph√©riques d'E / S figurent en dernier sur notre liste de ressources virtuelles.  Une machine virtuelle, comme un h√¥te physique, a besoin d'un <b>bus PCI / PCIe</b> pour connecter des p√©riph√©riques d'E / S.  QEMU / KVM est capable d'√©muler diff√©rents types de chipsets - q35 ou i440fx (le premier prend en charge PCIe, le second prend en charge le PCI h√©rit√©), ainsi que diverses topologies PCI, par exemple, cr√©ent des bus PCI s√©par√©s (bus d'extension PCI) pour les n≈ìuds NUMA OS invit√©s. <br><br>  Apr√®s avoir cr√©√© le bus PCI / PCIe, vous devez y connecter un p√©riph√©rique d'E / S.  En g√©n√©ral, il peut s'agir d'une carte r√©seau ou d'un GPU physique.  Et, bien s√ªr, une carte r√©seau, √† la fois enti√®rement virtualis√©e (interface e1000 enti√®rement virtualis√©e, par exemple), et para-virtualis√©e (virtio, par exemple) ou une carte r√©seau physique.  La derni√®re option est utilis√©e pour les machines virtuelles du plan de donn√©es o√π vous devez obtenir des taux de paquets au d√©bit de ligne - routeurs, pare-feu, etc. <br><br>  Il existe deux approches principales ici - <b>passthrough PCI</b> et <b>SR-IOV</b> .  La principale diff√©rence entre eux est que pour PCI-PT, le pilote est utilis√© uniquement √† l'int√©rieur de l'OS invit√©, et pour SRIOV, le pilote de l'OS h√¥te (pour cr√©er <b>VF - Fonctions virtuelles</b> ) et le pilote de l'OS invit√© sont utilis√©s pour contr√¥ler SR-IOV VF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Juniper a √©crit d'</a> excellents d√©tails sur PCI-PT et SRIOV. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote>  Pour plus de pr√©cision, il convient de noter que le passthrough PCI et SR-IOV sont des technologies compl√©mentaires.  SR-IOV d√©coupe une fonction physique en fonctions virtuelles.  Cela se fait au niveau du syst√®me d'exploitation h√¥te.  Dans le m√™me temps, Host OS voit les fonctions virtuelles comme un autre p√©riph√©rique PCI / PCIe.  Ce qu'il fait ensuite avec eux n'est pas important. <br><br>  Et PCI-PT est un m√©canisme de transfert de tout p√©riph√©rique PCI OS h√¥te dans le syst√®me d'exploitation invit√©, y compris la fonction virtuelle cr√©√©e par le p√©riph√©rique SR-IOV <br></blockquote><br><br>  Ainsi, nous avons examin√© les principaux types de ressources virtuelles et la prochaine √©tape consiste √† comprendre comment la machine virtuelle communique avec le monde ext√©rieur via un r√©seau. <br><hr><br><br><h1>  Commutation virtuelle </h1><br><br>  S'il y a une machine virtuelle, et qu'il y a une interface virtuelle dedans, alors, √©videmment, le probl√®me se pose de transf√©rer un paquet d'une VM √† une autre.  Dans les hyperviseurs bas√©s sur Linux (KVM, par exemple), ce probl√®me peut √™tre r√©solu en utilisant le pont Linux, cependant, le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open vSwitch</a> (OVS) a √©t√© largement accept√©. <br>  Plusieurs fonctionnalit√©s de base ont permis √† OVS de se r√©pandre largement et de devenir de facto la m√©thode de commutation de paquets de base utilis√©e par de nombreuses plates-formes de cloud computing (telles que Openstack) et des solutions virtualis√©es. <br><ul><li>  Transfert d'√©tat du r√©seau - lors de la migration d'une machine virtuelle entre hyperviseurs, la t√¢che se pose de transf√©rer les listes de contr√¥le d'acc√®s, les QoS, les tables de transfert L2 / L3, etc.  Et OVS peut le faire. </li><li>  Impl√©mentation du m√©canisme de transfert de paquets (datapath) √† la fois dans le noyau et dans l'espace utilisateur </li><li>  Architecture CUPS (Control / User-plane separation) - vous permet de transf√©rer les fonctionnalit√©s du traitement des paquets vers un chipset sp√©cialis√© (les chipsets Broadcom et Marvell, par exemple, peuvent le faire), en le contr√¥lant via l'OVS du plan de contr√¥le. </li><li>  Prise en charge des m√©thodes de contr√¥le du trafic √† distance - protocole OpenFlow (hi, SDN). </li></ul><br><br>  L'architecture OVS √† premi√®re vue semble assez effrayante, mais ce n'est qu'√† premi√®re vue. <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br>  Pour travailler avec OVS, vous devez comprendre les √©l√©ments suivants: <br><ul><li>  <b>Chemin de donn√©es</b> - les packages sont trait√©s ici.  L'analogie est la structure de commutation d'un interrupteur en fer.  Datapath comprend la r√©ception de paquets, le traitement des en-t√™tes, les correspondances dans la table de flux, qui est d√©j√† programm√©e dans Datapath.  Si OVS s'ex√©cute dans le noyau, il est impl√©ment√© en tant que module du noyau.  Si OVS s'ex√©cute dans l'espace utilisateur, il s'agit d'un processus dans Linux espace utilisateur. </li><li>  <b>vswitchd</b> et <b>ovsdb</b> sont des d√©mons dans l'espace utilisateur, qui impl√©mentent directement la fonctionnalit√© du commutateur, stockent la configuration, d√©finissent le flux vers le chemin de donn√©es et le programment. </li><li>  <b>Bo√Æte √†</b> outils de configuration et de d√©pannage OVS - <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b> .  Tout ce qui est n√©cessaire pour enregistrer la configuration des ports dans ovsdb, enregistrer le flux vers lequel basculer, collecter des statistiques, etc.  Les bonnes personnes ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crit un article</a> √† ce sujet. </li></ul><br><br>  <b>Comment le p√©riph√©rique r√©seau d'une machine virtuelle se retrouve-t-il dans OVS?</b> <br><br>  Pour r√©soudre ce probl√®me, nous devons en quelque sorte interconnecter l'interface virtuelle situ√©e dans l'espace utilisateur du syst√®me d'exploitation avec le chemin de donn√©es OVS situ√© dans le noyau. <br><br>  Dans le syst√®me d'exploitation Linux, les paquets sont transf√©r√©s entre le noyau et les processus de l'espace utilisateur via deux interfaces sp√©ciales.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux interfaces sont utilis√©es pour √©crire / lire un paquet vers / depuis un fichier sp√©cial pour transf√©rer des paquets du processus de l'espace utilisateur vers le noyau et vice versa - descripteur de fichier (FD) (c'est l'une des raisons des mauvaises performances de commutation virtuelle si le chemin de donn√©es OVS est dans le noyau - chaque paquet besoin d'√©crire / lire FD) </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (tunnel) - un appareil qui fonctionne en mode L3 et vous permet d'√©crire / lire uniquement des paquets IP vers / depuis FD.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (tap r√©seau) - identique √† l'interface tun + peut effectuer des op√©rations avec des trames Ethernet, c.-√†-d. </font><font style="vertical-align: inherit;">travailler en mode L2.</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est pourquoi lorsque la machine virtuelle s'ex√©cute dans Host OS, vous pouvez voir les interfaces TAP cr√©√©es avec le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien ip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou la </font><font style="vertical-align: inherit;">commande </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - c'est la partie ¬´r√©ponse¬ª de virtio, qui est ¬´visible¬ª dans le noyau Host OS. </font><font style="vertical-align: inherit;">Il convient √©galement de noter que l'interface TAP a la m√™me adresse MAC que l'interface virtio dans la machine virtuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interface TAP peut √™tre ajout√©e √† OVS √† l'aide des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commandes ovs-vsctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - puis tout package commut√© par OVS vers l'interface TAP sera transf√©r√© vers la machine virtuelle via un descripteur de fichier.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La proc√©dure r√©elle de cr√©ation d'une machine virtuelle peut √™tre diff√©rente, c'est-√†-dire </font><font style="vertical-align: inherit;">Tout d'abord, vous pouvez cr√©er un pont OVS, puis dire √† la machine virtuelle de cr√©er une interface connect√©e √† cet OVS, ou vice versa.</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, si nous devons √™tre en mesure de transf√©rer des paquets entre deux ou plusieurs machines virtuelles qui s'ex√©cutent sur le m√™me hyperviseur, il nous suffit de cr√©er un pont OVS et d'y ajouter des interfaces TAP √† l'aide des commandes ovs-vsctl. Quelles √©quipes sont n√©cessaires pour cela sont facilement googl√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut y avoir plusieurs ponts OVS sur l'hyperviseur, par exemple, c'est ainsi que Openstack Neutron fonctionne, ou les machines virtuelles peuvent se trouver dans des espaces de noms diff√©rents pour impl√©menter l'h√©bergement multiple. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si les machines virtuelles sont dans des ponts OVS diff√©rents?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour r√©soudre ce probl√®me, il existe un autre outil - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paire veth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La paire Veth peut √™tre repr√©sent√©e comme une paire d'interfaces r√©seau connect√©es par un c√¢ble - tout ce qui ¬´vole¬ª dans une interface, ¬´vole¬ª d'une autre. </font><font style="vertical-align: inherit;">La paire Veth est utilis√©e pour connecter plusieurs ponts OVS ou ponts Linux entre eux. </font><font style="vertical-align: inherit;">Un autre point important est que des parties de la paire veth peuvent se trouver dans un syst√®me d'exploitation Linux d'espace de noms diff√©rent, c'est-√†-dire que la paire veth peut √©galement √™tre utilis√©e pour communiquer l'espace de noms entre elles au niveau du r√©seau.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outils de virtualisation - libvirt, virsh et plus </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les chapitres pr√©c√©dents, nous avons examin√© les fondements th√©oriques de la virtualisation, dans ce chapitre, nous parlerons des outils disponibles pour l'utilisateur directement pour d√©marrer et modifier des machines virtuelles sur l'hyperviseur KVM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arr√™tons-nous sur trois composants principaux qui couvrent 90% de toutes sortes d'op√©rations avec des machines virtuelles:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libvirt </font></font></li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt est un projet open source √† grande √©chelle qui d√©veloppe un ensemble d'outils et de pilotes pour la gestion des hyperviseurs. Il prend en charge non seulement QEMU / KVM, mais √©galement ESXi, LXC et bien plus encore. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principale raison de sa popularit√© est une interface structur√©e et intuitive pour interagir via un ensemble de fichiers XML, ainsi que la possibilit√© d'automatiser via une API. Il convient de noter que libvirt ne d√©crit pas toutes les fonctions possibles de l'hyperviseur, il ne fournit qu'une interface pratique pour utiliser les fonctions d'hyperviseur qui sont </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiles</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , du point de vue des participants au projet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et oui, libvirt est le standard de facto dans le monde de la virtualisation aujourd'hui. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetez</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">≈ìil √† la liste des applications</font></a><font style="vertical-align: inherit;"> qui utilisent libvirt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bonne nouvelle √† propos de libvirt est que tous les packages n√©cessaires sont d√©j√† pr√©install√©s dans tous les OS h√¥tes les plus fr√©quemment utilis√©s - Ubuntu, CentOS et RHEL, donc vous n'aurez probablement pas √† compiler les packages n√©cessaires et compiler libvirt. </font><font style="vertical-align: inherit;">Dans le pire des cas, vous devrez utiliser le programme d'installation par lots appropri√© (apt, yum et similaires). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'installation et du d√©marrage initiaux, libvirt cr√©e par d√©faut le pont Linux virbr0 et sa configuration minimale.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est pourquoi lors de l'installation d'Ubuntu Server, par exemple, vous verrez dans la sortie de la commande ifconfig Linux bridge virbr0 - c'est le r√©sultat de l'ex√©cution du d√©mon libvirtd </font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce pont Linux ne sera connect√© √† aucune interface physique, mais il peut √™tre utilis√© pour communiquer des machines virtuelles au sein d'un seul hyperviseur. </font><font style="vertical-align: inherit;">Libvirt peut certainement √™tre utilis√© avec OVS, cependant, pour cela, l'utilisateur doit cr√©er ind√©pendamment des ponts OVS en utilisant les commandes OVS appropri√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toute ressource virtuelle n√©cessaire pour cr√©er une machine virtuelle (calcul, r√©seau, stockage) est repr√©sent√©e comme un objet dans libvirt. </font><font style="vertical-align: inherit;">Un ensemble de diff√©rents fichiers XML est responsable du processus de description et de cr√©ation de ces objets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'est pas tr√®s logique de d√©crire en d√©tail le processus de cr√©ation de r√©seaux virtuels et de stockages virtuels, car cette application est bien d√©crite dans la documentation de libvirt:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©seautage</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stockage</a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La machine virtuelle elle-m√™me avec tous les p√©riph√©riques PCI connect√©s est appel√©e domaine dans la terminologie libvirt. Il s'agit √©galement d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objet √† l'int√©rieur de libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est d√©crit par un fichier XML distinct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce fichier XML est, √† proprement parler, une machine virtuelle avec toutes les ressources virtuelles - RAM, processeur, p√©riph√©riques r√©seau, disques, etc. Souvent, ce fichier XML est appel√© libvirt XML ou dump XML. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est peu probable qu'il y ait une personne qui comprenne tous les param√®tres de libvirt XML, cependant, cela n'est pas requis en cas de documentation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, libvirt XML pour Ubuntu Desktop Guest OS sera assez simple - 40-50 lignes. </font><font style="vertical-align: inherit;">√âtant donn√© que toute optimisation des performances est √©galement d√©crite dans libvirt XML (topologie NUMA, topologies CPU, √©pinglage CPU, etc.), pour les fonctions r√©seau, libvirt XML peut √™tre tr√®s complexe et contenir plusieurs centaines de lignes. </font><font style="vertical-align: inherit;">Tout fabricant de p√©riph√©riques r√©seau qui exp√©die leurs logiciels sous forme de machines virtuelles a recommand√© des exemples de libvirt XML.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virsh CLI </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilitaire virsh est une ligne de commande ¬´native¬ª pour g√©rer libvirt. </font><font style="vertical-align: inherit;">Son objectif principal est de g√©rer les objets libvirt d√©crits comme des fichiers XML. </font><font style="vertical-align: inherit;">Les exemples typiques sont d√©marrer, arr√™ter, d√©finir, d√©truire, etc. </font><font style="vertical-align: inherit;">Autrement dit, le cycle de vie des objets - la gestion du cycle de vie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une description de toutes les commandes et drapeaux virsh est √©galement disponible dans la documentation de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt-install </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre utilitaire utilis√© pour interagir avec libvirt. L'un des principaux avantages est que vous n'avez pas √† g√©rer le format XML, mais que vous vous en sortez avec les indicateurs disponibles dans virsh-install. Le deuxi√®me point important est la mer d'exemples et d'informations sur le Web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, quel que soit l'utilitaire que vous utilisez, ce sera finalement libvirt qui contr√¥lera l'hyperviseur, il est donc important de comprendre l'architecture et les principes de son fonctionnement.</font></font><br><hr><br><br><h1>  Conclusion </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons examin√© l'ensemble minimal de connaissances th√©oriques n√©cessaires pour travailler avec des machines virtuelles. </font><font style="vertical-align: inherit;">Je n'ai pas intentionnellement donn√© d'exemples et de conclusions pratiques des commandes, car de tels exemples peuvent √™tre trouv√©s autant que vous le souhaitez sur le Web, et je ne me suis pas fix√© pour t√¢che d'√©crire un ¬´guide √©tape par √©tape¬ª. </font><font style="vertical-align: inherit;">Si vous √™tes int√©ress√© par un sujet ou une technologie sp√©cifique, laissez vos commentaires et √©crivez des questions.</font></font><br><hr><br><br><h1>  Liens utiles </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprendre les p√©riph√©riques QEMU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merci </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Shalimov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mon coll√®gue et expert dans le d√©veloppement de r√©seaux virtuels. </font><font style="vertical-align: inherit;">Pour commentaires et modifications.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yevgeny Yakovlev, mon coll√®gue et expert dans le domaine de la virtualisation, pour commentaires et corrections. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467801/">https://habr.com/ru/post/fr467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467789/index.html">Java 13 vient d'arriver. ZGC a commenc√© √† partager la m√©moire, CDS se souvient des classes et d'autres merveilles techniques</a></li>
<li><a href="../fr467791/index.html">Analyse du d√©filement des pages dans Google Data Studio</a></li>
<li><a href="../fr467793/index.html">Pile technologique ennuyeuse d'une entreprise Internet unipersonnelle</a></li>
<li><a href="../fr467795/index.html">Remarque sur les crypto-monnaies et la r√©glementation de l'√âtat</a></li>
<li><a href="../fr467797/index.html">"Riez pour le plaisir de": pourquoi pourriez-vous avoir besoin d'outils logiciels qui n'ont pas d'application "de combat"</a></li>
<li><a href="../fr467803/index.html">Simulation √©l√©mentaire d'interaction physique personnalis√©e en python + matplotlib</a></li>
<li><a href="../fr467807/index.html">Acheter et vendre des crypto-monnaies en Russie: m√©thodes, l√©galisation, risques</a></li>
<li><a href="../fr467811/index.html">Architecture et programmation Fairchild Channel F</a></li>
<li><a href="../fr467813/index.html">R√©vision des changements dans le 17e ordre du FSTEC</a></li>
<li><a href="../fr467815/index.html">Les m√©dias ont paniqu√© que "les adresses IP s'√©puisent en Russie". Comment vraiment?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>