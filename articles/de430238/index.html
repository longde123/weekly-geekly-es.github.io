<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎳 👶🏾 🧘🏾 Ein weiteres DSL auf Kotlin oder wie ich PDF von React gedruckt habe ♋️ 🐙 👌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie können nicht einfach eine in React geschriebene Seite aufnehmen und drucken: Es gibt Seitentrennzeichen und Eingabefelder. Außerdem möchte ich ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiteres DSL auf Kotlin oder wie ich PDF von React gedruckt habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430238/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ir/d8/d4/ird8d4jfijzncjzyjbubqxjoaiw.jpeg"></a> <br><br>  Sie können nicht einfach eine in React geschriebene Seite aufnehmen und drucken: Es gibt Seitentrennzeichen und Eingabefelder.  Außerdem möchte ich ein Rendering einmal schreiben, damit es sowohl ReactDom als auch reguläres HTML generiert, das in PDF konvertiert werden kann. <br><br>  Das Schwierigste ist, dass React eine eigene DSL und HTML eine eigene hat.  Wie kann man dieses Problem lösen?  Schreibe noch einen! <br><br>  Ich hätte fast vergessen, dass alles in Kotlin geschrieben wird, also ist dies eigentlich ein Artikel über Kotlin dsl. <br><a name="habracut"></a><br><h3>  Warum brauchen wir unser eigenes Uruk-hai? </h3><br>  Mein Projekt enthält viele Berichte, die alle gedruckt werden müssen.  Hierfür gibt es verschiedene Möglichkeiten: <br><br><ul><li>  Spielen Sie mit Druckstilen, verstecken Sie alles, was Sie nicht benötigen, und hoffen Sie, dass alles in Ordnung ist.  Es werden nur Schaltflächen, Filter und dergleichen so gedruckt, wie sie sind.  Und wenn es viele Tabellen gibt, muss sich jede auf einer separaten Seite befinden.  Und persönlich machen mich die hinzugefügten Links, Daten usw., die beim Drucken von der Website herauskommen, wütend </li><li> Versuchen Sie, beim Reagieren eine spezielle Bibliothek zu verwenden, die PDF rendern kann.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> gefunden, es ist Beta und darin können Sie anscheinend normale Reaktionskomponenten nicht wiederverwenden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwandeln Sie HTML in Leinwand</a> und machen Sie PDF daraus.  Dafür benötigen wir jedoch HTML ohne Schaltflächen und dergleichen.  Es muss in einem versteckten Element gerendert werden, um es später zu drucken.  Es scheint jedoch nicht, dass Sie mit dieser Option Seitenumbrüche steuern können. </li></ul><br>  Am Ende habe ich beschlossen, Code zu schreiben, der sowohl ReactDom als auch HTML generieren kann.  Ich sende den HTML-Code an das Backend, um die PDF-Datei zu drucken, indem ich unterwegs spezielle Tags zu Seitenumbrüchen einfüge. <br><br>  Kotlin verfügt über eine Ebenenbibliothek für die Arbeit mit React, die typsichere DSL für die Arbeit mit React bietet.  Wie es im Allgemeinen aussieht, finden Sie in meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> . <br><br>  JetBrains hat auch eine Bibliothek zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generieren von HTML geschrieben</a> .  Es ist plattformübergreifend, d.h.  Es kann sowohl in Java als auch in JS verwendet werden.  Dies ist auch dsl, sehr ähnlich in der Struktur. <br><br>  Wir müssen einen Weg finden, zwischen Bibliotheken zu wechseln, je nachdem, ob wir ReactDom oder reines HTML benötigen. <br><br><h3>  Welches Material haben wir? </h3><br>  Nehmen Sie zum Beispiel eine Tabelle mit einem Suchfeld in der Kopfzeile.  So sieht das Rendern von Tabellen in React und HTML aus: <br><table><tbody><tr><th>  reagieren <br></th><th>  html <br></th></tr><tr><td><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> RBuilder.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderReactTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, onChangeSearch: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) { table { thead { tr { th { attrs.colSpan = <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-comment"><span class="hljs-comment">//(1) attrs.style = js { border = "solid" borderColor = "red" } //(2) +":" search(search, onChangeSearch) //(3) } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } } }</span></span></code> </pre> <br></td><td><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> TagConsumer</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;*&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderHtmlTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span> { table { thead { tr { th { colSpan = <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-comment"><span class="hljs-comment">//(1) style = """ border: solid; border-color: red; """ //(2) +": " +(search?:"") //(3) } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } } }</span></span></code> </pre><br></td></tr></tbody></table><br><br>  Unsere Aufgabe ist es, die linke und rechte Seite des Tisches zu kombinieren. <br><br>  Lassen Sie uns zunächst herausfinden, was der Unterschied ist: <br><br><ol><li>  In HTML werden die <code>colSpan</code> <code>style</code> und <code>colSpan</code> auf der obersten Ebene in React für das verschachtelte attr-Objekt zugewiesen </li><li>  Stil füllt sich anders.  Wenn dies in HTML reguläres CSS als Zeichenfolge ist, handelt es sich in React um ein js-Objekt, dessen Feldnamen sich aufgrund von JS-Einschränkungen geringfügig von Standard-CSS unterscheiden. </li><li>  In der React-Version verwenden wir Eingaben für die Suche, in HTML zeigen wir einfach den Text an.  Dies geht bereits von der Problemstellung aus. </li></ol><br>  Gut und das Wichtigste: Dies sind verschiedene DSL mit verschiedenen Verbrauchern und verschiedenen APIs.  Für den Compiler sind sie völlig unterschiedlich.  Es ist unmöglich, sie direkt zu kreuzen, daher müssen Sie eine Ebene schreiben, die fast gleich aussieht, aber sowohl mit React-API als auch mit HTML-API arbeiten kann. <br><br><h3>  Bauen Sie das Skelett zusammen </h3><br>  Zeichnen Sie vorerst einfach eine Tablette aus einer leeren Zelle: <br><br><pre> <code class="kotlin hljs">table { thead { tr { th { } } } }</code> </pre><br>  Wir haben einen HTML-Baum und zwei Möglichkeiten, ihn zu verarbeiten.  Die klassische Lösung besteht darin, zusammengesetzte Muster und Besuchermuster zu implementieren.  Nur haben wir keine Schnittstelle für Besucher.  Warum - es wird später gesehen. <br><br>  Die Haupteinheiten sind ParentTag und TagWithParent.  ParentTag wird durch das HTML-Tag aus der Kotlin-API generiert (Gott sei Dank wird es sowohl in HTML als auch in der React-API verwendet), und TagWithParent speichert das Tag selbst und zwei Funktionen, die es in zwei API-Varianten in das übergeordnete Element einfügen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : HTMLTag</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tags: MutableList&lt;TagWithParent&lt;*, T&gt;&gt; = mutableListOf() <span class="hljs-comment"><span class="hljs-comment">//     protected fun RDOMBuilder&lt;T&gt;.withChildren() { ... } //  reactAppender    protected fun T.withChildren() { ... } //  htmlAppender    } class TagWithParent&lt;T, P : HTMLTag&gt;( val tag: T, val htmlAppender: (T, P) -&gt; Unit, val reactAppender: (T, RDOMBuilder&lt;P&gt;) -&gt; Unit )</span></span></code> </pre><br>  Warum brauchst du so viele Generika?  Das Problem ist, dass dsl für HTML beim Kompilieren sehr streng ist.  Wenn Sie in React td von überall aufrufen können, auch von einem div, dann können Sie es im Fall von HTML nur aus dem Kontext von tr aufrufen.  Daher müssen wir den Kontext für die Kompilierung überall in Form von Generika ziehen. <br><br>  Die meisten Tags werden ungefähr gleich geschrieben: <br><br><ol><li>  Wir implementieren zwei Besuchsmethoden.  Eine für React, eine für HTML.  Sie sind für das endgültige Rendering verantwortlich.  Diese Methoden fügen Stile, Klassen und dergleichen hinzu. </li><li>  Wir schreiben eine Erweiterung, die das Tag in das übergeordnete Element einfügt. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Hier ist ein Beispiel für Thead</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THead</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ParentTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">THEAD</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TABLE</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.thead { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TABLE</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.thead { withChildren() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Table.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THead</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { tags += TagWithParent(THead().also(block), THead::visit, THead::visit) }</code> </pre><br></div></div><br>  Schließlich können Sie erklären, warum die Schnittstelle für Besucher nicht verwendet wurde.  Das Problem ist, dass tr sowohl in den Kopf als auch in den Körper eingefügt werden kann.  Ich konnte dies nicht im Rahmen einer Schnittstelle ausdrücken.  Es kamen vier Überladungen der Besuchsfunktion heraus. <br><br><div class="spoiler">  <b class="spoiler_title">Eine Reihe von Duplikaten, die nicht vermieden werden können</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tr</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classes: String? ) : ParentTag&lt;TR&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THEAD</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THEAD</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TBODY</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TBODY</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.tr(classes) { withChildren() } } }</code> </pre><br></div></div><br><h3>  Fleisch bauen </h3><br>  Fügen Sie der Zelle Text hinzu: <br><br><pre> <code class="kotlin hljs"> table { thead { tr { th { +<span class="hljs-string"><span class="hljs-string">": "</span></span> } } } }</code> </pre><br>  Das Fokussieren mit '+' ist ganz einfach: Es reicht aus, nur unaryPlus in Tags neu zu definieren, die möglicherweise Text enthalten. <br><br><pre> <code class="plaintext hljs">abstract class TableCell&lt;T : HTMLTag&gt; : ParentTag&lt;T&gt;() { operator fun String.unaryPlus() { ... } }</code> </pre><br>  Auf diese Weise können Sie im Kontext von td oder th '+' aufrufen, wodurch dem Baum ein Tag mit Text hinzugefügt wird. <br><br><h3>  Formen Sie die Haut </h3><br>  Jetzt müssen wir uns mit Stellen befassen, die sich im HTML unterscheiden, und auf die API reagieren.  Ein kleiner Unterschied zu colSpan wird von selbst gelöst, aber der Unterschied in der Stilbildung ist komplizierter.  Wenn jemand nicht weiß, dass Stil in React ein JS-Objekt ist und Sie keinen Bindestrich im Feldnamen verwenden können.  Daher wird stattdessen camelCase verwendet.  In der HTML-API möchten wir reguläres CSS von uns.  Wir brauchen wieder dies und das gleichzeitig. <br><br>  Ich könnte versuchen, camelCase automatisch zum Bindestrich zu bringen und es wie in React api zu belassen, aber ich weiß nicht, ob es immer funktionieren wird.  Deshalb habe ich eine weitere Ebene geschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Wer nicht faul ist, kann sehen, wie es aussieht</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Style</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> border: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> padding: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> background: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Style</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { callback() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toHtmlStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = properties .map { it.html to it.property(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } .filter { (_, value) -&gt; value != <span class="hljs-literal"><span class="hljs-literal">null</span></span> } .joinToString(<span class="hljs-string"><span class="hljs-string">"; "</span></span>) { (name, value) -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$value</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toReactStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = js(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>) properties .map { it.react to it.property(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } .filter { (_, value) -&gt; value != <span class="hljs-literal"><span class="hljs-literal">null</span></span> } .forEach { (name, value) -&gt; result[name] = value.toString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.unsafeCast&lt;String&gt;() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StyleProperty</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> html: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> react: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> property: Style.() -&gt; Any? ) <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> properties = listOf( StyleProperty(<span class="hljs-string"><span class="hljs-string">"border"</span></span>, <span class="hljs-string"><span class="hljs-string">"border"</span></span>) { border }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"border-color"</span></span>, <span class="hljs-string"><span class="hljs-string">"borderColor"</span></span>) { borderColor }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"width"</span></span>, <span class="hljs-string"><span class="hljs-string">"width"</span></span>) { width }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"padding"</span></span>, <span class="hljs-string"><span class="hljs-string">"padding"</span></span>) { padding }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"background"</span></span>, <span class="hljs-string"><span class="hljs-string">"background"</span></span>) { background } ) } }</code> </pre><br></div></div><br>  Ja, ich weiß, wenn Sie eine weitere CSS-Eigenschaft wünschen - fügen Sie dieser Klasse hinzu.  Ja, und eine Karte mit einem Konverter wäre einfacher zu implementieren.  Aber typsicher.  Ich benutze sogar stellenweise Aufzählungen.  Wenn ich nicht für mich selbst schreiben würde, würde ich die Frage vielleicht anders lösen. <br><br>  Ich habe ein wenig geschummelt und diese Verwendung der resultierenden Klasse zugelassen: <br><br><pre> <code class="kotlin hljs">th { attrs.style { border = <span class="hljs-string"><span class="hljs-string">"solid"</span></span> borderColor = <span class="hljs-string"><span class="hljs-string">"red"</span></span> } }</code> </pre><br>  So geht's: Im Feld attr.style ist standardmäßig bereits ein leerer Style () vorhanden.  Wenn Sie Operator Fun Invoke definieren, kann das Objekt als Funktion verwendet werden, d. H.  Sie können <code>attrs.style()</code> aufrufen, obwohl style ein Feld und keine Funktion ist.  Bei einem solchen Aufruf müssen die im Operator Fun Invoke angegebenen Parameter übergeben werden.  In diesem Fall ist dies ein Parameter - Rückruf: Stil. () -&gt; Einheit.  Da dies ein Lambda ist, sind (Klammern) optional. <br><br><h3>  Verschiedene Rüstungen anprobieren </h3><br>  Es bleibt zu lernen, wie man Eingaben in React und nur Text in HTML zeichnet.  Ich möchte diese Syntax erhalten: <br><br><pre> <code class="kotlin hljs">react { search(search, onChangeSearch) } html { +(search?:<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre><br>  So funktioniert es: Die React-Funktion nimmt ein Lambda für die Rreact-API und gibt das eingefügte Tag zurück.  Auf dem Tag können Sie die Infix-Funktion aufrufen und das Lambda an die HTML-API übergeben.  Mit dem Infix-Modifikator kann HTML ohne Punkt aufgerufen werden.  Sehr ähnlich zu if {} else {}.  Und wie in if-else ist der HTML-Aufruf optional, er hat sich mehrmals als nützlich erwiesen. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReactTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : HTMLTag</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> block: RBuilder.() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {} ) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> htmlAppender: (T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">html</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>.() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { htmlAppender = block } ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : HTMLTag&gt;</span></span></span><span class="hljs-function"> ParentTag</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">react</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): ReactTag&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> reactTag = ReactTag&lt;T&gt;(block) tags += TagWithParent&lt;ReactTag&lt;T&gt;, T&gt;(reactTag, ReactTag&lt;T&gt;::visit, ReactTag&lt;T&gt;::visit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reactTag }</code> </pre><br></div></div><br><h3>  Sarumans Mal </h3><br>  Noch eine Berührung.  Es ist erforderlich, ParentTag und TagWithParent von einer speziell gewickelten Schnittstelle mit einer speziell gewickelten Annotation zu erben, auf der eine spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Annotation @DslMarker steht</a> , die bereits aus dem Kern der Sprache stammt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@DslMarker</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StyledTableMarker</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@StyledTableMarker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tag</span></span></span></span></code> </pre><br>  Dies ist notwendig, damit der Compiler keine seltsamen Aufrufe wie diese schreiben kann: <br><br><pre> <code class="kotlin hljs">td { td { } } tr { thead { } }</code> </pre><br>  Es ist jedoch unklar, wer daran denken würde, so etwas zu schreiben ... <br><br><h3>  In die Schlacht! </h3><br>  Alles ist bereit, um eine Tabelle vom Anfang des Artikels an zu zeichnen, aber dieser Code generiert bereits sowohl ReactDom als auch HTML.  Schreiben Sie einmal laufen überall! <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Table.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderUniversalTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, onChangeSearch: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { thead { tr { th { attrs.colSpan = <span class="hljs-number"><span class="hljs-number">2</span></span> attrs.style { border = <span class="hljs-string"><span class="hljs-string">"solid"</span></span> borderColor = <span class="hljs-string"><span class="hljs-string">"red"</span></span> } +<span class="hljs-string"><span class="hljs-string">":"</span></span> react { search(search, onChangeSearch) <span class="hljs-comment"><span class="hljs-comment">//(*) } html { +(search?:"") } } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } }</span></span></code> </pre><br>  Beachten Sie (*) - dies ist genau die gleiche Suchfunktion wie in der Originalversion der Tabelle für React.  Es ist nicht erforderlich, alles auf die neue DSL zu übertragen, sondern nur allgemeine Tags. <br><br>  Was könnte das Ergebnis eines solchen Codes funktionieren?  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel eines PDF-Ausdrucks eines</a> Berichts aus meinem Projekt.  Natürlich habe ich alle Zahlen und Namen durch zufällige ersetzt.  Zum Vergleich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF-Ausdruck</a> derselben Seite, jedoch vom Browser.  Artefakte vom Aufbrechen einer Tabelle zwischen Seiten bis zum Überlagern von Text. <br><br>  Wenn Sie dsl schreiben, erhalten Sie viel zusätzlichen Code, der sich ausschließlich auf die Verwendungsform konzentriert.  Darüber hinaus werden viele Kotlin-Funktionen verwendet, an die Sie im Alltag nicht einmal denken. <br><br>  Vielleicht wird es in anderen Fällen anders sein, aber in diesem Fall gab es auch viele Duplikate, die ich nicht loswerden konnte (soweit ich weiß, verwendet JetBarins die Codegenerierung, um die HTML-Bibliothek zu schreiben). <br><br>  Aber es stellte sich heraus, dass ich dsl fast ähnlich wie die React- und HTML-API erstellt habe (ich habe fast nicht geguckt).  Interessanterweise haben wir neben der Bequemlichkeit von dsl die volle Kontrolle über das Rendern.  Sie können getrennten Seiten ein Seiten-Tag hinzufügen.  Sie können das " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akkordeon</a> " beim Drucken erweitern.  Und Sie können versuchen, einen Weg zu finden, diesen Code auf dem Server wiederzuverwenden und HTML bereits für Suchmaschinen zu generieren. <br><br>  PS Sicher gibt es Möglichkeiten, PDF einfacher zu drucken <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rübe mit Quelle für den Artikel</a> <br><br><div class="spoiler">  <b class="spoiler_title">Andere Artikel über Kotlin:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Nachgeschmack von Kotlin, Teil 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Nachgeschmack von Kotlin, Teil 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachgeschmack von Kotlin, Teil 3. Coroutinen - Prozessorzeit teilen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin + Reagieren gegen Javasript + Reagieren</a> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430238/">https://habr.com/ru/post/de430238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430226/index.html">Von var b bis zum Interview</a></li>
<li><a href="../de430228/index.html">X-förmige Markierungen als Methode zur Radaridentifizierung mittels Open-Data-Analyse von zwei wissenschaftlichen Satelliten SENTINEL-1</a></li>
<li><a href="../de430230/index.html">So behalten Sie Ihren Platz in einem wachsenden Startup</a></li>
<li><a href="../de430232/index.html">Generierung von Close Call in Spielen: "Am Rande der Niederlage" oder "Fast gewonnen"</a></li>
<li><a href="../de430236/index.html">NASA kündigt Neumondflug an</a></li>
<li><a href="../de430240/index.html">Sicherheitsanfälligkeit in Bitcoin Pseudo Random Number</a></li>
<li><a href="../de430242/index.html">OpenSceneGraph: Gruppenknoten, Transformationsknoten und Switch-Knoten</a></li>
<li><a href="../de430244/index.html">SpaceX erhielt die Erlaubnis, ein Satellitennetzwerk mit 11943 Satelliten bereitzustellen</a></li>
<li><a href="../de430252/index.html">Feind drinnen: wie ich zum Insider-Redding kam</a></li>
<li><a href="../de430256/index.html">Anwendungskonfiguration - Spring-Konfigurationsmetadaten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>