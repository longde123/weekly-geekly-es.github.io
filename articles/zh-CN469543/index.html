<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥈 🐼 👎 DirectisRX服务的Redis扩展和故障转移 👍 ✍🏽 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis是完全放在RAM中的NoSQL类的数据库管理系统（非关系DBMS）。 要访问数据，使用“键”-“值”模型。 这种DBMS通常用于在可伸缩服务中存储高速缓存，用于存储图像和小数据。 

 由于以下原因，Redis DBMS被广泛使用： 



- 高速，因为 所有数据都存储在RAM中； 
-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DirectisRX服务的Redis扩展和故障转移</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/469543/">  Redis是完全放在RAM中的NoSQL类的数据库管理系统（非关系DBMS）。 要访问数据，使用“键”-“值”模型。 这种DBMS通常用于在可伸缩服务中存储高速缓存，用于存储图像和小数据。 <br><br> 由于以下原因，Redis DBMS被广泛使用： <br><br><ul><li> 高速，因为 所有数据都存储在RAM中； </li><li> 跨平台 </li><li> 根据BSD许可进行分发（适用于开源软件）。 </li></ul><br>  Redis的分布范围和适用性可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该项目</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站</a>上大量的带有各种案例的文档来估算。 <br><br> 如果使用DirectumRX服务的水平扩展，则必须使用Redis故障安全安装才能与DirectumRX存储服务和DirectumRX Web访问服务一起正常使用。 <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/740/12b/060/74012b060e74628af35c33d4fa96b3bb.jpg" alt="图片"><br><br>  Redis将存储操作数据，缓存和其他在伸缩模式下运行的服务所必需的信息，以便用户与系统交互的过程不取决于他当前使用的安装。 <br><br>  Redis将不会存储敏感数据，并且不会承受重负载。 但是，如果Redis失败，则用户在安装之间进行切换时会遇到很多错误。 <br><br> 在Redis官方网站上，有两种方法可以确保水平缩放和容错： <br><br><ol><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redis Sentiel</a> 。 </li><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redis集群</a> 。 </li></ol><br> 考虑自定义这些选项。 <br><br><h2> 配置Redis Sentiel </h2><br>  Redis 2.4中实现了使用Redis Sentiel（Redis跟踪节点）的选项，该选项包括使用附加的Redis Sentiel服务来监视向导的可用性。 如果向导失败，他还将执行副本节点的配置。 确定哪个SLAVE节点将成为MASTER并随时随地执行重新配置。 <br><br> 实施经典方案： <br><br><img width="467" src="https://habrastorage.org/getpro/habr/post_images/093/10e/efb/09310eefbd3eb3c05d23b9e227bb5d7a.jpg" alt="图片"><br><br> 可以有许多SLAVE节点（根据官方网站最多可以有1000个），为了进行生产性工作，建议至少使用两个SLAVE节点。 <br><br> 通常，以以下方式配置方案：在MASTER和SLAVE节点上配置Redis Sentiel服务，如果MASTER节点发生故障，则其余监视节点决定引入新的MASTER。 <br><br> 可从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">产品开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站上</a>下载最新版本的Redis。 但是，分发站点仅适用于Linux。 有一次，正在开发将Redis移植到Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目</a> ，但是目前该项目停止了3.2.100版的开发，因此在本文中，我们将考虑最相关的部署选项-在Linux上。 <br><br> 作为测试节点，我们将使用两个虚拟主机redis1和redis2以及已安装的Debian 10 Linux发行版。 <br><br> 首先，从默认存储库更新软件包列表，然后安装Redis： <br><br><pre><code class="bash hljs">apt-get update &amp;&amp; apt-get upgrade apt install redis-server</code> </pre> <br> 检查版本： <br><br><pre> <code class="bash hljs">root@redis1:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-server -v Redis server v=5.0.3 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=afa0decbb6de285f</span></span></code> </pre> <br> 让redis1充当MASTER节点，让redis2充当SLAVE节点。 <br><br> 为此，我们在Redis配置文件中写入必要的参数，这些参数将使您可以创建副本（尚未容错）。 <br><br> 对于配置文件/etc/redis/redis.conf中的redis1，请指定： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,   MASTER     . requirepass TestPass</span></span></code> </pre> <br> 对于配置文件/etc/redis/redis.conf中的redis2，请指定： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   MASTER  . slaveof redis1 6379 #      . masterauth TestPass #   ,         . requirepass TestPass</span></span></code> </pre> <br> 在两个节点上重新启动redis-server服务： <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis1:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service.</span></span></code> </pre> <br> 我们在MASTER端检查节点是否成为副本并获得了必要的角色： <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:1 slave0:ip=192.168.9.96,port=6379,state=online,offset=28,lag=0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:28 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:28</span></span></code> </pre> <br> 在从设备方面，我们看到了相同的情况： <br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:redis1 master_port:6379 master_link_status:up master_last_io_seconds_ago:4 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14</span></span></code> </pre> <br> 现在，您需要配置副本，以便在其中一个节点发生故障的情况下自动还原副本。 为此，我们需要Redis Sentinel跟踪服务。 <br><br> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ，Redis Sentinel监视服务可以执行以下操作： <br><br><ol><li> 检查MASTER和SLAVE节点的可用性，并能够发送有关节点不可访问性的警报。 </li><li> 如果MASTER节点发生故障，见证节点可以将SLAVE节点置于MASTER模式，并重新配置其余的SLAVE节点，然后它们就可以与新的MASTER一起使用。 </li><li> 更改MASTER和SLAVE节点的配置文件。 </li></ol><br> 为了保证实验的纯洁性，我们将见证服务放置在单独的redis3 VM上。 <br><br> 我们以相同的方式连接Redis存储库并安装redis-sentinel软件包： <br><br><pre> <code class="bash hljs">apt install redis-sentinel</code> </pre> <br> 安装后，需要在监视节点/etc/redis/sentinel.conf的配置文件中进行设置： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    redis1   6379. #   1 -      , #        MASTER-. #       , #     MASTER-. sentinel monitor master01 redis1 6379 1 #  3 ,       . sentinel down-after-milliseconds master01 3000 #    MASTER- sentinel failover-timeout master01 6000 # ,  SLAVE-   . #    ,    , #      . sentinel parallel-syncs master01 1 #    . bind 192.168.9.97 127.0.0.1 ::1 #    MASTER-. sentinel auth-pass master01 TestPass</span></span></code> </pre><br> 进行设置后，重新启动服务： <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-sentinel restart [ ok ] Restarting redis-sentinel (via systemctl): redis-sentinel.service.</span></span></code> </pre> <br> 检查跟踪服务是否看到MASTER和SLAVE： <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br> 我们开始实验。 <br><br> 我们模拟一个故障，在redis1节点上停止redis-server服务并获取见证节点的当前信息： <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.96:6379,slaves=1,sentinels=1</span></span></code> </pre> <br> 我们看到MASTER发生了变化。 <br><br> 我们将还原redis1节点的操作并检查其状态： <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:192.168.9.96 master_port:6379 master_link_status:up master_last_io_seconds_ago:1 master_sync_in_progress:0 slave_repl_offset:15977 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:15977 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:15977</span></span></code> </pre> <br> 我们看到该节点收到了SLAVE角色，而redis2节点是MASTER节点。 <br><br> 模拟redis2节点的故障并检查见证节点的状态： <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br> 以及redis1节点的状态： <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:0 master_replid:6e9d67d6460815b925319c2bafb58bf2c435cffb master_replid2:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_repl_offset:33610 second_repl_offset:26483 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:33610</span></span></code> </pre> <br> 很好，该机制有效。 但是现在出现了一个问题，我们将如何连接DirectumRX服务，因为它们需要一个节点地址。 我们将使用HAProxy服务解决这种情况。 <br><br><h2>  Redis节点代理 </h2><br> 任何代理tcp服务都可以充当Redis节点的反向代理。 在本文中，我们将考虑使用HAProxy，因为HAProxy是旨在提供高可用性和负载平衡的专用工具，并且已被众所周知的联机服务使用。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在开发人员页面上</a>阅读有关HAProxy的更多信息。 <br><br> 在redis3节点上安装HAProxy： <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># apt install haproxy</span></span></code> </pre> <br> 在HAProxy配置文件/etc/haproxy/haproxy.cfg中，添加用于将请求代理到Redis节点的设置： <br><br><pre> <code class="bash hljs">… frontend ft_redis <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> *:6379 name redis mode tcp default_backend bk_redis backend bk_redis mode tcp option tcp-check tcp-check connect <span class="hljs-comment"><span class="hljs-comment">#  ,         . tcp-check send AUTH\ TestPass\r\n tcp-check expect string +OK tcp-check send PING\r\n tcp-check expect string +PONG tcp-check send info\ replication\r\n #    MASTER, .. SLAVE      . tcp-check expect string role:master tcp-check send QUIT\r\n tcp-check expect string +OK server Redis1 redis1:6379 check inter 3s server Redis2 redis2:6379 check inter 3s</span></span></code> </pre><br> 在此配置中，表明我们将在端口6379的地址上代理到达当前虚拟机的所有接口的所有请求。我们会将请求传输到将对其具有MASTER角色的节点进行响应。 <br><br> 重新启动haproxy服务： <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/haproxy restart</span></span></code> </pre> <br> 让我们尝试使用redis-cli客户端进行连接并创建一个测试密钥： <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 6379 -a TestPass Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. 127.0.0.1:6379&gt; SET TestKey "Some test string" OK 127.0.0.1:6379&gt; GET TestKey "Some test string" 127.0.0.1:6379&gt; info keyspace # Keyspace db0:keys=1,expires=0,avg_ttl=0</span></span></code> </pre> <br> 停止redis1节点，然后再次查询键列表： <br><br><pre> <code class="bash hljs">127.0.0.1:6379&gt; info keyspace Error: Server closed the connection (3.01s) 127.0.0.1:6379&gt; info keyspace <span class="hljs-comment"><span class="hljs-comment"># Keyspace db0:keys=1,expires=0,avg_ttl=0 (2.01s) 127.0.0.1:6379&gt; GET TestKey "Some test string"</span></span></code> </pre><br> 我们看到一段时间以来，连接已断开，但随后又恢复了连接，所有数据都保留在原位。 <br><br> 现在，只需在DirectumRX服务的配置文件中注册反向代理地址即可连接到Redis。 <br><br><h2> 配置Redis集群 </h2><br>  Redis Cluster clustering选项（为redis 3.0及更高版本实现）是使用数据分段和复制创建和管理集群的解决方案。 在多个MASTER节点之一发生故障时，执行节点管理，复制，节点上的数据同步以及确保客户端应用程序对MASTER节点的访问等任务。 <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/86e/5c6/e56/86e5c6e56fe5541c36297e978c4c34d4.png" alt="图片"><br><br>  Redis Cluster在多主机模式下工作，每个MASTER节点可以有一个或多个SLAVE节点（最多1000个）。 <br><br> 扩展是集群的主要功能。 另外，集群可以保证Redis服务的容错能力： <br><br><ul><li> 如果某些节点不起作用，群集会将负载从它们重新分配给其他节点； </li><li> 如果关键节点不起作用，则整个群集结束。 </li></ul><br> 当客户端2写入节点M2时，可能会出现这种情况。  M2回答“确定”并尝试写入S2。 同时，M2不等待与S2的数据交换正确完成，而是立即响应客户端。 在这种情况下，S2复制副本可能没有全部数据。 因此，建议使用多个SLAVE副本。 <br><br> 当M1，M3停止“看到” M2并且客户端仍继续将数据写入M2时，也可能会出现这种情况。 如果不可用性将持续相当长的一段时间（cluster-node-timeout参数），则在这种情况下，S2将进入MASTER模式，而M2将自行停止工作。 <br><br> 官方文档建议使用6个节点-每个节点一个Redis实例，这样可以提高可靠性，但没有人禁止使用具有以下连接拓扑的三个节点： <br><br><img width="573" src="https://habrastorage.org/getpro/habr/post_images/3c1/56a/860/3c156a860e5728015e9631b3bb5854a1.jpg" alt="图片"><br><br> 如果物理节点之一发生故障，相应的SLAVE副本将进入MASTER模式，并且操作不会中断。 <br><br> 我们在测试平台上实现3个虚拟机（redis1，redis2和redis3），每个虚拟机将运行2个Redis实例。 <br><br> 客户端应用程序将连接到客户端配置文件中指定的特定端口，因此，MASTER-SLAVE对应在相同的端口上工作。 <br><br> 对于M1-S1对，我们将使用端口6381 <br> 对于M2-S2对，我们将使用端口6382 <br> 对于M3-S3对，我们将使用端口6383 <br><br> 准备配置文件 <br><br> 在redis1上： <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m1_redis.conf cp /etc/redis/redis.conf /etc/redis/s2_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br> 在redis2上： <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m2_redis.conf cp /etc/redis/redis.conf /etc/redis/s3_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br> 在redis3上： <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m3_redis.conf cp /etc/redis/redis.conf /etc/redis/s1_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br> 根据模板填写配置文件： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> &lt;IP- &gt; protected-mode no <span class="hljs-comment"><span class="hljs-comment">#      ,    . port &lt;&gt; pidfile /var/run/redis_&lt;&gt;.pid # &lt;yes/no&gt; -   Redis Cluster cluster-enabled yes # ,      : #  ,  ,    . #         . cluster-config-file nodes-&lt;&gt;.conf #  ,  master-   , #          slaves #    . cluster-node-timeout 15000</span></span></code> </pre> <br> 让我们启动Redis节点： <br><br> 节点redis1： <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m1_redis.conf root@redis1:/etc/redis# redis-server /etc/redis/s2_redis.conf</span></span></code> </pre> <br>  Redis2节点： <br><br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m2_redis.conf root@redis2:/etc/redis# redis-server /etc/redis/s3_redis.conf</span></span></code> </pre> <br>  Redis3节点： <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m3_redis.conf root@redis3:/etc/redis# redis-server /etc/redis/s1_redis.conf</span></span></code> </pre> <br> 要配置集群，您需要使用redis-cli客户端实用程序，向其传递一系列将扮演MASTER和SLAVE角色的服务器的ip：端口对： <br><br><pre> <code class="bash hljs">redis-cli --cluster create redis1-ip:6381 redis2-ip:6382 redis3-ip:6383 redis1-ip:6382 redis2-ip:6383 redis3-ip:6381 --cluster-replicas 1</code> </pre> <br>  ，--cluster-replicas 1选项告诉您每个主服务器有多少个SLAVE，并从传输的副本列表中自动选择它们。 <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli --cluster create 192.168.9.51:6381 192.168.9.52:6382 192.168.9.53:6383 192.168.9.51:6382 192.168.9.52:6383 192.168.9.53:6381 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 192.168.9.52:6383 to 192.168.9.51:6381 Adding replica 192.168.9.51:6382 to 192.168.9.52:6382 Adding replica 192.168.9.53:6381 to 192.168.9.53:6383 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [OK] Perfect anti-affinity obtained! M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 replicates 3a41475e1613519c3ecdec695736a898262a24a5 S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 replicates e92cb96fd6c20db7509662a248902e3751ebe95f Can I set the above configuration? (type 'yes' to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join ..... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.9.51:6381) M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 slots: (0 slots) slave replicates e92cb96fd6c20db7509662a248902e3751ebe95f S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 slots: (0 slots) slave replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 slots: (0 slots) slave replicates 3a41475e1613519c3ecdec695736a898262a24a5 M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered.</span></span></code> </pre> <br> 群集已正确构建。 我们将显示有关集群的信息： <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:1254 cluster_stats_messages_pong_sent:1243 cluster_stats_messages_sent:2497 cluster_stats_messages_ping_received:1238 cluster_stats_messages_pong_received:1254 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:2497 192.168.9.51:6381&gt;</span></span></code> </pre> <br> 与Redis Sentiel一样，要测试特定的副本，可以使用INFO复制命令： <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; INFO replication # Replication role:master connected_slaves:1 slave0:ip=192.168.9.53,port=6381,state=online,offset=1946,lag=0 master_replid:59cd95d394dad9d0e49042637fdfd5290db4abfe master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1946 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1946 192.168.9.51:6381&gt;</span></span></code> </pre> <br> 让我们尝试创建几个密钥，并验证这些密钥是否出现在副本中： <br><br><pre> <code class="bash hljs">192.168.9.51:6381&gt; SET key1 test1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 OK 192.168.9.52:6382&gt; SET key2 test2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 OK 192.168.9.51:6381&gt; SET key3 test3 OK 192.168.9.51:6381&gt;</code> </pre> <br> 检查M2： <br><br><pre> <code class="bash hljs">root@redis2:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.52 -p 6382 192.168.9.52:6382&gt; GET key1 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br> 在M3上： <br><br><pre> <code class="bash hljs">root@redis3:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.53 -p 6383 192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br> 我们将禁用redis1节点并检查S1的工作方式： <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; CLUSTER NODES &lt;b&gt;182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave,fail d499af3672b3063c7239572ec311ad3160f280ae 1569509904727 1569509900000 4 connected&lt;/b&gt; 485ffb786e9763955e6f10ffc59247690ad9bc11 &lt;i&gt;192.168.9.53:6381@16381 master&lt;/i&gt; - 0 1569510017272 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569510018274 5 connected &lt;b&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 master,fail - 1569509906731 1569509901721 1 connected&lt;/b&gt; 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569510019275 3 connected 10923-16383 d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 myself,master - 0 1569510017000 2 connected 5461-10922</code> </pre> <br> 我们看到有关M1和S2故障以及S3已切换到MASTER模式的信息。 <br><br> 检查密钥的存储位置： <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; GET key1 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6381&gt; GET key3 <span class="hljs-string"><span class="hljs-string">"test3"</span></span> 192.168.9.53:6381&gt;</code> </pre><br> 以前存储在redis1上的密钥现在在redis3上可用。 <br><br> 恢复redis1节点的操作，并检查节点M1和S2的状态： <br><br><pre> <code class="bash hljs">192.168.9.53:6381&gt; CLUSTER NODES &lt;i&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 slave 485ffb786e9763955e6f10ffc59247690ad9bc11 0 1569511658217 7 connected 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave d499af3672b3063c7239572ec311ad3160f280ae 0 1569511657000 4 connected&lt;/i&gt; d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 master - 0 1569511656000 2 connected 5461-10922 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569511656000 3 connected 10923-16383 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381@16381 myself,master - 0 1569511656000 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569511657216 5 connected</code> </pre> <br>  M1和S2的运行状况已经恢复，但是现在M1处于从模式。 <br><br> 密钥也位于redis3节点上： <br><br><pre> <code class="bash hljs">192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6383&gt; GET key3 -&gt; Redirected to slot [935] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test3"</span></span></code> </pre> <br> 已配置集群并测试了Redis恢复。 <br><br> 要访问DirectumRX服务，还需要配置反向代理，就像设置Redis Sentiel一样。 <br><br><h2> 而不是结论 </h2><br> 本文并未考虑提高Redis容错能力的另一种方法-使用第三方群集资源管理器（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pacemaker）</a> 。 在这种情况下，可以通过两个节点来解决问题，但是在紧急情况下很有可能会丢失数据。 <br><br> 对于反向代理（在本例中为HAProxy），也希望提供容错功能，但是此问题也不在本文讨论范围之内。 如果您对该主题感兴趣，还可以在单​​独的文章中考虑这些部署选项，并逐步进行调整和测试结果。 <br><br> 您可以在下面的链接中找到有关该主题的更多信息： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redis集群教程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redis Sentinel文档</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HAProxy配置手册</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469543/">https://habr.com/ru/post/zh-CN469543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469529/index.html">文字渲染讨厌你</a></li>
<li><a href="../zh-CN469531/index.html">“在更好的基础上比较编程语言是完全愚蠢的职业。”</a></li>
<li><a href="../zh-CN469533/index.html">生物识别的问题和威胁</a></li>
<li><a href="../zh-CN469537/index.html">通过Snake了解Swift</a></li>
<li><a href="../zh-CN469541/index.html">使用werf和GitLab CI组装和部署相同的微服务</a></li>
<li><a href="../zh-CN469545/index.html">Linux内核5.3的新增功能-网络子系统中的图形驱动程序，虚拟化和修改</a></li>
<li><a href="../zh-CN469549/index.html">我们如何为Windows VPS支付99卢布的关税</a></li>
<li><a href="../zh-CN469551/index.html">带视频卡的VDS-我们对变态知识了解很多</a></li>
<li><a href="../zh-CN469555/index.html">广播：莫斯科Kubernetes聚会＃6</a></li>
<li><a href="../zh-CN469557/index.html">通用回收站视图或如何不编写样板代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>