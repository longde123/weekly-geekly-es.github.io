<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 👲 🤦🏿 Ulme. Bequem und umständlich. Json.Encoder und Json.Decoder 🚋 😥 🤵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir sprechen weiterhin über Elm 0.18 . 


 Ulme. Bequem und umständlich 
 Ulme. Bequem und umständlich. Zusammensetzung 
 Ulme. Bequem und umständlich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ulme. Bequem und umständlich. Json.Encoder und Json.Decoder</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424437/"><p>  Wir sprechen weiterhin über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elm 0.18</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bequem und umständlich</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bequem und umständlich.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammensetzung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bequem und umständlich.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP, Aufgabe</a> </p><br><p>  Dieser Artikel behandelt die Probleme von Encodern / Decodern. </p><br><p>  Decoder / Encoder werden verwendet für: </p><br><ol><li>  Konvertierung von Antworten aus Ressourcen von Drittanbietern (HTTP, WebSocket usw.); </li><li>  Interaktionen über Ports.  In den folgenden Artikeln werde ich Ihnen mehr über Ports und nativen Code erzählen. </li></ol><a name="habracut"></a><br><p>  Wie bereits beschrieben, müssen wir bei Elm externe Daten in interne Anwendungstypen umwandeln.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.Decode-</a> Modul ist für diesen Prozess verantwortlich.  Der umgekehrte Vorgang ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.Encode</a> . </p><br><p>  Der Typ, der die Decodierungsregeln definiert, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.Decode.Decoder a</a> .  Dieser Typ wird vom Benutzertyp parametrisiert und bestimmt, wie der Benutzertyp a vom JSON-Objekt abgerufen wird. </p><br><p>  Für den Encoder ist nur der Ergebnistyp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">definiert</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.Encode.Value</a> . </p><br><p>  Betrachten Sie Beispiele für den Typ UserData. </p><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Decoder zum Empfangen von Daten vom Benutzer: </p><br><pre> <code class="hljs pgsql">decodeUserData : <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.Decoder UserData decodeUserData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map3 UserData (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “id” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.int) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “<span class="hljs-type"><span class="hljs-type">name</span></span>” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “email” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) encodeUserData : UserData -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> encodeUserData userData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ ( “id”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.int userData.id) , ( “<span class="hljs-type"><span class="hljs-type">name</span></span>”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.name) , ( “email”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.email) ]</code> </pre> <br><p>  Die Funktion Json.Decode.map3 akzeptiert einen Konstruktor vom Typ UserData.  Als nächstes werden drei Decoder des Typs in der Reihenfolge ihrer Deklaration im Benutzertyp UserData übertragen. </p><br><p>  Die Funktion decodeUserData kann in Verbindung mit den Funktionen Json.Decode.decodeString oder Json.Decode.decodeValue verwendet werden.  <a href="">Ein Anwendungsbeispiel</a> aus den vorherigen Artikeln. </p><br><p>  Die Funktion encodeUserData erzeugt eine benutzerdefinierte Typcodierung vom Typ Json.Encode.Value, die gesendet werden kann.  In einfachen Worten entspricht Json.Encode.Value einem JSON-Objekt. </p><br><p>  Einfache Optionen sind in der Dokumentation beschrieben, sie können ohne große Schwierigkeiten untersucht werden.  Schauen wir uns Lebensfälle an, die etwas Fingerspitzengefühl erfordern. </p><br><h2 id="dekodery-union-tipov-ili-diskriminatory-tipov">  Union Decoder oder Typ Diskriminatoren </h2><br><p>  Angenommen, wir haben einen Warenkatalog.  Und jedes Produkt kann eine beliebige Anzahl von Attributen haben, von denen jedes einen Typ von einem der vielen hat: </p><br><ol><li>  ganze Zahl; </li><li>  Zeichenfolge </li><li>  aufgezählt.  Nimmt die Wahl eines der gültigen Werte an. </li></ol><br><p>  Ein JSON-Objekt ist wie folgt gültig: </p><br><pre> <code class="hljs powershell">{ “id”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “name”: “Product name”, “price”: <span class="hljs-number"><span class="hljs-number">1000</span></span>, “attributes”: [ { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-type"><span class="hljs-type">Length</span></span>”, “<span class="hljs-type"><span class="hljs-type">unit</span></span>”: “<span class="hljs-type"><span class="hljs-type">meters</span></span>”, “<span class="hljs-type"><span class="hljs-type">value</span></span>”: <span class="hljs-number"><span class="hljs-number">100</span></span> }, { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-type"><span class="hljs-type">Color</span></span>”, “<span class="hljs-type"><span class="hljs-type">unit</span></span>”: “”, “<span class="hljs-type"><span class="hljs-type">value</span></span>”: { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">label</span></span>”: “<span class="hljs-type"><span class="hljs-type">red</span></span>” } },<span class="hljs-type"><span class="hljs-type">...</span></span> ] }</code> </pre> <br><p>  Die verbleibenden möglichen Typen werden nicht berücksichtigt, die Arbeit mit ihnen ist ähnlich.  Dann hätte ein benutzerdefinierter Produkttyp die folgende Beschreibung: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Product = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , price: <span class="hljs-type"><span class="hljs-type">Int</span></span> , attributes: Attributes } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Attributes = List <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , unit: String , <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: AttributeValue } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AttributeValue = IntValue <span class="hljs-type"><span class="hljs-type">Int</span></span> | StringValue String | EnumValue Enum <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Enum = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , label: String }</code> </pre> <br><p>  Wir werden die beschriebenen Typen leicht diskutieren.  Es gibt ein Produkt (Produkt), das eine Liste von Attributen / Merkmalen (Attribute) enthält.  Jedes Attribut (Attribut) enthält einen Bezeichner, einen Namen, eine Dimension und einen Wert.  Der Attributwert wird als Vereinigungstyp beschrieben, ein Element für jeden Typ von Merkmalwert.  Der Enum-Typ beschreibt einen Wert aus einem akzeptablen Satz und enthält: Bezeichner und lesbaren Wert. </p><br><p>  Beschreibung des Decoders, der Kürze halber das Präfix Json.Decode weglassen: </p><br><pre> <code class="hljs cpp">decodeProduct : Decoder Product decodeProduct = map4 Product (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “price” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “attributes” decodeAttributes) decodeAttributes : Decoder Attributes decodeAttributes = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> decodeAttribute decodeAttribute : Decoder Attribute decodeAttribute = map4 Attribute (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “unit” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “value” decodeAttributeValue) decodeAttributeValue : Decoder AttributeValue decodeAttributeValue = oneOf [ <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> IntValue <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> StringValue <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> EnumValue decodeEnumValue ] decodeEnumValue : Decoder Enum decodeEnumValue = map2 Enum (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “label” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)</code> </pre> <br><p>  Der gesamte Trick ist in der Funktion decodeAttributeValue enthalten.  Bei Verwendung der Funktion Json.Decode.oneOf werden alle gültigen Decoder für den Attributwert durchlaufen.  Bei erfolgreichem Entpacken durch einen der Decoder wird der Wert mit dem entsprechenden Tag vom Typ AttributeValue gekennzeichnet. </p><br><p>  Die Produkttypcodierung kann mit der Funktion Json.Encode.object durchgeführt werden, an die codierte Typattribute übergeben werden.  Es lohnt sich, auf die Codierung vom Typ AttributeValue zu achten.  In Übereinstimmung mit dem zuvor beschriebenen JSON-Objekt kann der Encoder wie folgt beschrieben werden: Das Json.Encode-Präfix wird der Kürze halber weggelassen: </p><br><pre> <code class="hljs cs">encodeAttributeValue : AttributeValue -&gt; Value encodeAttributeValue attributeValue = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> attributeValue of IntValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> StringValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> EnumValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ (“id”, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.id) , (“id”, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.label) ]</code> </pre> <br><p>  Wie Sie sehen können, vergleichen wir die Typoptionen und verwenden die entsprechenden Encoder. </p><br><p>  Ändern Sie die Beschreibung der Attribute und definieren Sie sie mithilfe eines Typdiskriminators.  Das JSON-Attributobjekt würde in diesem Fall folgendermaßen aussehen: </p><br><pre> <code class="hljs pgsql">{ “id”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>”, “<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>”: “<span class="hljs-type"><span class="hljs-type">int</span></span>”, “value_int”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “value_string”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_id”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_label”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br><p>  In diesem Fall wird der Typdiskriminator im Typfeld gespeichert und bestimmt, in welchem ​​Feld der Wert gespeichert wird.  Eine solche Beschreibungsstruktur ist wahrscheinlich nicht die bequemste, wird aber häufig gefunden.  Es lohnt sich wahrscheinlich nicht, die Typbeschreibung für dieses JSON-Objekt zu ändern. Es ist besser, die Typen für den internen Gebrauch in einer geeigneten Form aufzubewahren.  In diesem Fall kann die Beschreibung des Decoders wie folgt sein: </p><br><pre> <code class="hljs vhdl">decodeAttribute2 : Decoder <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> decodeAttribute2 = field <span class="hljs-string"><span class="hljs-string">"type"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; andThen decodeAttributeValueType |&gt; andThen (\attributeValue -&gt; map4 <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> (field <span class="hljs-string"><span class="hljs-string">"id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field <span class="hljs-string"><span class="hljs-string">"unit"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (succeed attributeValue) ) decodeAttributeValueType : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Decoder AttributeValue decodeAttributeValueType valueType = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> valueType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_int"</span></span> int |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> IntValue <span class="hljs-string"><span class="hljs-string">"string"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_string"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> StringValue <span class="hljs-string"><span class="hljs-string">"enum"</span></span> -&gt; map2 Enum (field <span class="hljs-string"><span class="hljs-string">"value_enum_id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"value_enum_label"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> EnumValue _ -&gt; Json.Decode.fail <span class="hljs-string"><span class="hljs-string">"Unknown attribute type"</span></span></code> </pre> <br><p>  In der Funktion decodeAttribute2 dekodieren wir zuerst den Diskriminator. Wenn dies erfolgreich ist, dekodieren wir den Attributwert.  Als nächstes dekodieren wir die verbleibenden Felder des Attributtyps und geben den zuvor erhaltenen Wert als Wert des Wertefelds an. </p><br><p>  <a href="">Der Quellcode des Decoders</a> . </p><br><h2 id="chastichnoe-obnovlenie-tipa">  Teilweise Typaktualisierung </h2><br><p>  Es gibt Fälle, in denen die API nicht das gesamte Objekt, sondern nur einen Teil davon zurückgibt.  Zum Beispiel, wenn Sie sich registrieren, um den Status eines Objekts anzuzeigen oder zu ändern.  In diesem Fall ist es bequemer, das aktualisierte Objekt sofort in der Nachricht zu empfangen und alle Manipulationen hinter dem Decoder zu verbergen. </p><br><p>  Zum Beispiel nehmen wir dasselbe Produkt, fügen jedoch das Statusfeld hinzu und verarbeiten die Anforderung zum Schließen des Produkts. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Attributes</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } decodeUpdateStatus : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Decoder</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> decodeUpdateStatus product = field “status” int |&gt; andThen (\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">succeed</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">product</span></span></span><span class="hljs-class"> | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class">} )</span></span></code> </pre> <br><p>  Oder Sie können die Funktion Json.Decode.map verwenden. </p><br><pre> <code class="hljs erlang-repl">decodeUpdateStatus : Product -&gt; Decoder Product decodeUpdateStatus product = field “status” int |&gt; map (\newStatus -&gt; { product | status = newStatus} )</code> </pre> <br><h2 id="data-i-vremya">  Datum und Uhrzeit </h2><br><p>  Wir werden die Date.fromString-Funktion verwenden, die mit dem Konstruktor des Date-Typs implementiert wird. </p><br><pre> <code class="hljs pgsql">decodeDateFromString : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromString = string |&gt; andThen (\stringDate -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromString stringDate <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Ok <span class="hljs-type"><span class="hljs-type">date</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.succeed <span class="hljs-type"><span class="hljs-type">date</span></span> Err reason -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.fail reason )</code> </pre> <br><p>  Wenn der Zeitstempel als Datums- / Zeitdarstellung verwendet wird, kann der Decoder im Allgemeinen wie folgt beschrieben werden: </p><br><pre> <code class="hljs pgsql">decodeDateFromTimestamp : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromTimestamp = oneOf [ <span class="hljs-type"><span class="hljs-type">int</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map toFloat , <span class="hljs-type"><span class="hljs-type">float</span></span> ] |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromTime</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424437/">https://habr.com/ru/post/de424437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424427/index.html">Roskomnadzor- und Telegramm-Bots über einen Proxy</a></li>
<li><a href="../de424429/index.html">Wissenschaft Kunst und Klang: 4 beeindruckende Projekte</a></li>
<li><a href="../de424431/index.html">Valve enthüllt Steam Game Controller-Ranglisten</a></li>
<li><a href="../de424433/index.html">Warum Hacker Mikrotik und wie ich 100.000 RouterOS vor einem Botnetz versteckt habe</a></li>
<li><a href="../de424435/index.html">Ölbohrzoo: Ordnung schaffen</a></li>
<li><a href="../de424441/index.html">Was ist neu im ersten CTP von SQL Server 2019?</a></li>
<li><a href="../de424443/index.html">Vivaldi 2.0 zu unseren Gunsten</a></li>
<li><a href="../de424445/index.html">Neil Fords Übersetzung von Microservices als evolutionäre Architektur</a></li>
<li><a href="../de424447/index.html">Lisp mit Pascal oder der Programmiersprache 8501. gewürzt</a></li>
<li><a href="../de424453/index.html">Lerne OpenGL. Lektion 6.2 - Physikalisches Rendern. Analytische Lichtquellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>