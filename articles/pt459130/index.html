<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèΩ ü¶é üëàüèº Manipula√ß√£o suave de erros em microsservi√ßos ‚åõÔ∏è üë∏üèø üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo mostra como implementar o tratamento de erros e o log com base no princ√≠pio "Feito e Esquecido" no Go. O m√©todo foi desenvolvido para micross...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manipula√ß√£o suave de erros em microsservi√ßos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  O artigo mostra como implementar o tratamento de erros e o log com base no princ√≠pio "Feito e Esquecido" no Go.  O m√©todo foi desenvolvido para microsservi√ßos on Go, trabalhando em um cont√™iner Docker e constru√≠do em conformidade com os princ√≠pios da Arquitetura Limpa. </p><a name="habracut"></a><br><p>  Este artigo √© uma vers√£o detalhada de um relat√≥rio da recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reuni√£o do Go em Kazan</a> .  Se voc√™ est√° interessado em Go e mora em Kazan, Innopolis, na bonita Yoshkar-Ola ou em outra cidade pr√≥xima, visite a p√°gina da comunidade: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">golangkazan.github.io</a> . </p><br><p>  Na reuni√£o, nossa equipe em dois relat√≥rios mostrou como estamos desenvolvendo microsservi√ßos no Go - quais princ√≠pios seguimos e como simplificamos nossas vidas.  Este artigo se concentra em nosso conceito de tratamento de erros, que agora estendemos a todos os nossos novos microsservi√ßos. </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa">  Acordos de estrutura de microsservi√ßos </h2><br><p>  Antes de abordar as regras para tratamento de erros, vale a pena decidir quais restri√ß√µes observamos ao projetar e codificar.  Para fazer isso, vale a pena dizer como s√£o os nossos microsservi√ßos. </p><br><p>  Antes de tudo, respeitamos a arquitetura limpa.  Dividimos o c√≥digo em tr√™s n√≠veis e observamos a regra de depend√™ncia: pacotes em um n√≠vel mais profundo s√£o independentes de pacotes externos e n√£o existem depend√™ncias c√≠clicas.  Felizmente, as depend√™ncias diretas de round-robin dos pacotes s√£o proibidas no Go.  Depend√™ncias indiretas por meio de terminologia de empr√©stimo, suposi√ß√µes sobre comportamento ou convers√£o para um tipo ainda podem aparecer; elas devem ser evitadas. </p><br><p>  √â assim que nossos n√≠veis se parecem: </p><br><ol><li>  O n√≠vel do dom√≠nio cont√©m regras de l√≥gica de neg√≥cios ditadas pela √°rea de assunto. <br><ul><li>  √†s vezes fazemos sem dom√≠nio se a tarefa √© simples </li><li>  <em>regra: o</em> c√≥digo no n√≠vel do dom√≠nio depende apenas dos recursos do Go, da biblioteca Go padr√£o e das bibliotecas selecionadas que estendem o idioma Go </li></ul></li><li>  A camada de aplicativo cont√©m regras de l√≥gica de neg√≥cios ditadas pelas tarefas do aplicativo. <br><ul><li>  <em>regra: o</em> c√≥digo no n√≠vel do aplicativo pode depender do dom√≠nio </li></ul></li><li>  O n√≠vel de infraestrutura cont√©m c√≥digo de infraestrutura que conecta o aplicativo a v√°rias tecnologias de armazenamento (MySQL, Redis), transporte (GRPC, HTTP), intera√ß√£o com o ambiente externo e outros servi√ßos <br><ul><li>  <em>regra: o</em> c√≥digo no n√≠vel da infraestrutura pode depender do dom√≠nio e do aplicativo </li><li>  <em>regra:</em> apenas uma tecnologia por pacote Go </li></ul></li><li>  O pacote principal cria todos os objetos - "singleton vital√≠cio", os conecta e lan√ßa corotinas de longa dura√ß√£o - por exemplo, come√ßa a processar solicita√ß√µes HTTP da porta 8081 </li></ol><br><p>  √â assim que a √°rvore de diret√≥rios do microsservi√ßo √© exibida (a parte onde est√° o c√≥digo Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Imagem: Ir √°rvore de projetos"></p><br><p>  Para cada um dos contextos de aplica√ß√£o (m√≥dulos), a estrutura do pacote tem a seguinte apar√™ncia: </p><br><ul><li> o pacote de aplicativos declara uma interface de servi√ßo que cont√©m todas as a√ß√µes poss√≠veis em um determinado n√≠vel que implementa a interface da estrutura de servi√ßo e a fun√ß√£o <code>func NewService(...) Service</code> </li><li>  o isolamento do trabalho com o banco de dados √© alcan√ßado devido ao fato de o dom√≠nio ou o pacote de aplicativos declarar a interface do Reposit√≥rio, que √© implementada no n√≠vel da infraestrutura no pacote com o nome visual "mysql" </li><li>  o c√≥digo de transporte est√° localizado no pacote de <code>infrastructure/transport</code> <br><ul><li>  usamos GRPC, para que os stubs do servidor sejam gerados a partir do arquivo proto (ou seja, interface do servidor, estruturas de resposta / solicita√ß√£o e todo o c√≥digo de intera√ß√£o do cliente) </li></ul></li></ul><br><p>  Tudo isso √© mostrado no diagrama: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Imagem: Diagrama de pacote do projeto Go"></p><br><h2 id="principy-obrabotki-oshibok">  Princ√≠pios de tratamento de erros </h2><br><p>  Tudo √© simples aqui: </p><br><ol><li>  Acreditamos que erros e p√¢nico ocorram ao processar solicita√ß√µes √† API - o que significa que um erro ou p√¢nico deve afetar apenas uma solicita√ß√£o </li><li>  Acreditamos que os logs s√£o necess√°rios apenas para an√°lise de incidentes (e existe um depurador para depura√ß√£o); portanto, informa√ß√µes sobre solicita√ß√µes s√£o recebidas no log e, antes de tudo, erros inesperados ao processar solicita√ß√µes </li><li>  Acreditamos que toda uma infraestrutura foi criada para processar logs (por exemplo, com base no ELK) - e o microsservi√ßo desempenha um papel passivo nela, gravando logs no stderr </li></ol><br><p>  N√£o focaremos no p√¢nico: n√£o se esque√ßa de lidar com o p√¢nico em todas as goroutines e durante o processamento de cada solicita√ß√£o, cada mensagem, cada tarefa ass√≠ncrona iniciada pela solicita√ß√£o.  Quase sempre, o p√¢nico pode se transformar em um erro para impedir que o aplicativo inteiro seja conclu√≠do. </p><br><h2 id="idioma-sentinel-errors">  Erros de sentinela de idioma </h2><br><p>  No n√≠vel da l√≥gica de neg√≥cios, apenas os erros esperados definidos pelas regras de neg√≥cios s√£o processados.  Os erros do Sentinel o ajudar√£o a identificar esses erros - usamos esse idioma em vez de escrever nossos pr√≥prios tipos de dados para erros.  Um exemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Aqui √© declarada uma vari√°vel global que, pelo acordo de nossos cavalheiros, n√£o devemos mudar em lugar algum.  Se voc√™ n√£o gosta de vari√°veis ‚Äã‚Äãglobais e usa o linter para detect√°-las, pode conviver com algumas constantes, como sugere Dave Cheney na publica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erros Constant</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Se voc√™ gosta dessa abordagem, pode adicionar o tipo <code>ConstError</code> √† sua biblioteca de idiomas Go corporativa. </blockquote><br><h2 id="kompoziciya-oshibok">  Composi√ß√£o dos erros </h2><br><p>  A principal vantagem dos erros do Sentinel √© a capacidade de compor erros com facilidade.  Em particular, ao criar um erro ou receber um erro de fora, seria bom adicionar um rastreamento de pilha a ele.  Para tais fins, existem duas solu√ß√µes populares. </p><br><ul><li>  pacote xerrors, que no Go 1.13 ser√° inclu√≠do na biblioteca padr√£o como um experimento </li><li>  Pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/pkg/errors</a> por Dave Cheney <br><ul><li>  a embalagem est√° congelada e n√£o se expande, mas √© boa </li></ul></li></ul><br><p>  Nossa equipe ainda usa <code>github.com/pkg/errors</code> e os <code>errors.WithStack</code> Fun√ß√µes <code>errors.WithStack</code> (quando n√£o temos nada a acrescentar, exceto <code>errors.Wrap</code> ) ou <code>errors.Wrap</code> (quando temos algo a dizer sobre esse erro).  Ambas as fun√ß√µes aceitam um erro na entrada e retornam um novo erro, mas com o rastreamento de pilha.  Exemplo da camada de infraestrutura: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Recomendamos que cada erro seja quebrado apenas uma vez.  Isso √© f√°cil se voc√™ seguir as regras: </p><br><ul><li>  quaisquer erros externos s√£o agrupados uma vez em um dos pacotes de infraestrutura </li><li>  quaisquer erros gerados pelas regras da l√≥gica de neg√≥cios s√£o complementados pelo stacktrace no momento da cria√ß√£o </li></ul><br><h2 id="pervoprichina-oshibki">  Causa raiz do erro </h2><br><p>  Todos os erros s√£o divididos em esperados e inesperados.  Para lidar com o erro esperado, voc√™ precisa se livrar dos efeitos da composi√ß√£o.  Os pacotes <code>github.com/pkg/errors</code> e <code>github.com/pkg/errors</code> t√™m tudo o que voc√™ precisa: em particular, o pacote de erros possui a fun√ß√£o <code>errors.Cause</code> , que retorna a causa raiz do erro.  Essa fun√ß√£o em um loop, uma ap√≥s a outra, recupera erros anteriores, enquanto o pr√≥ximo erro extra√≠do possui o m√©todo de <code>Cause() error</code> . </p><br><p>  Um exemplo ao qual extra√≠mos a causa raiz e a comparamos diretamente com o erro sentinela: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Tratamento de erros no adiamento </h2><br><p>  Talvez voc√™ esteja usando o linter, o que faz com que voc√™ verifique manualmente todos os erros.  Nesse caso, voc√™ provavelmente est√° enfurecido quando o linter pede para verificar erros nos m√©todos <code>.Close()</code> e outros m√©todos que voc√™ <code>defer</code> apenas de <code>defer</code> .  Voc√™ j√° tentou lidar corretamente com o erro no adiamento, especialmente se houver outro erro antes disso?  E tentamos e estamos com pressa de compartilhar a receita. </p><br><p>  Imagine que todo o trabalho com o banco de dados seja estritamente atrav√©s de transa√ß√µes.  De acordo com a regra de depend√™ncia, os n√≠veis de aplicativo e dom√≠nio n√£o devem depender direta ou indiretamente da infraestrutura e da tecnologia SQL.  Isso significa que, <strong>nos n√≠veis do aplicativo e do dom√≠nio, n√£o h√° palavra "transa√ß√£o"</strong> . </p><br><p>  A solu√ß√£o mais simples √© substituir a palavra "transa√ß√£o" por algo abstrato;  assim nasce o padr√£o da Unidade de Trabalho.  Em nossa implementa√ß√£o, o servi√ßo no pacote de aplicativos recebe a f√°brica por meio da interface UnitOfWorkFactory e, durante cada opera√ß√£o, cria um objeto UnitOfWork que oculta a transa√ß√£o.  O objeto UnitOfWork permite obter um reposit√≥rio. </p><br><div class="spoiler">  <b class="spoiler_title">Mais sobre UnitOfWork</b> <div class="spoiler_text"><p>  Para entender melhor o uso da Unidade de Trabalho, d√™ uma olhada no diagrama: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Image Go Unidade de Trabalho"></p><br><ul><li>  Reposit√≥rio representa uma cole√ß√£o persistente abstrata de objetos (por exemplo, agregados no n√≠vel do dom√≠nio) de um tipo definido </li><li>  UnitOfWork oculta a transa√ß√£o e cria objetos de reposit√≥rio </li><li>  UnitOfWorkFactory simplesmente permite que o servi√ßo crie novas transa√ß√µes sem saber nada sobre transa√ß√µes. </li></ul><br><p>  N√£o √© excessivo criar uma transa√ß√£o para cada opera√ß√£o, mesmo inicialmente at√¥mica?  Depende de voc√™;  Acreditamos que manter a independ√™ncia da l√≥gica de neg√≥cios √© mais importante do que economizar na cria√ß√£o de uma transa√ß√£o. </p><br><p>  √â poss√≠vel combinar UnitOfWork e Repository?  √â poss√≠vel, mas acreditamos que isso viola o princ√≠pio da responsabilidade √∫nica. </p></div></div><br><p>  √â assim que a interface se parece: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  A interface UnitOfWork fornece o m√©todo Complete, que utiliza um par√¢metro de entrada e sa√≠da: um ponteiro para a interface de erro.  Sim, √© o ponteiro e o par√¢metro in-out - em qualquer outro caso, o c√≥digo no lado de chamada ser√° muito mais complicado. </p><br><p>  Exemplo de opera√ß√£o com unitOfWork: </p><br><blockquote>  Cuidado: o erro <strong>deve</strong> ser declarado como valor de retorno nomeado.  Se, em vez do valor de retorno nomeado err, voc√™ usar a vari√°vel local err, n√£o poder√° us√°-lo no adiamento!  E nem um √∫nico linter detectar√° isso ainda - veja o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cr√≠tico # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Ent√£o a conclus√£o √© realizada <del>  transa√ß√µes </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  A fun√ß√£o <code>mergeErrors</code> mescla dois erros, mas processa nada sem problemas, em vez de um ou ambos os erros.  Ao mesmo tempo, acreditamos que ambos os erros ocorreram durante a execu√ß√£o de uma opera√ß√£o em est√°gios diferentes, e o primeiro erro √© mais importante - portanto, quando os dois erros n√£o s√£o nulos, salvamos o primeiro e apenas a mensagem √© salva do segundo erro: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Talvez voc√™ deva adicionar a fun√ß√£o <code>mergeErrors</code> √† sua biblioteca corporativa do Go. </blockquote><br><h2 id="podsistema-logirovaniya">  Subsistema de registro em log </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lista de verifica√ß√£o do</a> artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">: o que voc√™ tinha que fazer antes de iniciar os microsservi√ßos no produto</a> aconselha: </p><br><ul><li>  logs s√£o escritos em stderr </li><li>  logs devem estar em JSON, um objeto JSON compacto por linha </li><li>  Deve haver um conjunto padr√£o de campos: <br><ul><li>  timestamp - hora do evento em <strong>milissegundos</strong> , de prefer√™ncia no formato RFC 3339 (exemplo: "1985-04-12T23: 20: 50.52Z") </li><li>  n√≠vel - n√≠vel de import√¢ncia, por exemplo, "informa√ß√µes" ou "erro" </li><li>  app_name - nome do aplicativo </li><li>  e outros campos </li></ul></li></ul><br><p>  Preferimos adicionar mais dois campos √†s mensagens de erro: <code>"error"</code> e <code>"stacktrace"</code> . </p><br><p>  Existem muitas bibliotecas de registro de qualidade para a linguagem Golang, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sirupsen / logrus</a> , que usamos.  Mas n√£o usamos a biblioteca diretamente.  Primeiro de tudo, em nosso pacote de <code>log</code> , reduzimos a interface de biblioteca excessivamente extensa para uma interface do Logger: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Se o programador quiser gravar logs, ele dever√° obter a interface do Logger de fora, e isso deve ser feito no n√≠vel da infraestrutura, n√£o no aplicativo ou no dom√≠nio.  A interface do criador de logs √© concisa: </p><br><ul><li>  reduz o n√∫mero de n√≠veis de severidade para depura√ß√£o, informa√ß√µes e erros, como aconselha o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo.Vamos falar sobre o log.</a> </li><li>  ele introduz regras especiais para o m√©todo Error: o m√©todo sempre aceita um objeto de erro </li></ul><br><p>  Essa rigidez permite direcionar os programadores na dire√ß√£o certa: se algu√©m quiser melhorar o sistema de registro em si, deve faz√™-lo levando em considera√ß√£o toda a infraestrutura de sua coleta e processamento, que s√≥ come√ßa no microsservi√ßo (e geralmente termina em Kibana e Zabbix). </p><br><p>  No entanto, no pacote de log, h√° outra interface que permite interromper o programa quando ocorre um erro fatal e, portanto, s√≥ pode ser usado no pacote principal: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Pacote Jsonlog </h2><br><p>  Implementa a interface do Logger em nosso pacote <code>jsonlog</code> , que configura a biblioteca logrus e abstrai o trabalho com ela.  Esquematicamente aparece assim: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Diagrama de pacotes do Logger de imagens"></p><br><p>  Um pacote propriet√°rio permite conectar as necessidades de um microsservi√ßo (expresso pela interface <code>log.Logger</code> ), os recursos da biblioteca logrus e os recursos de sua infraestrutura. </p><br><p>  Por exemplo, usamos ELK (Elastic Search, Logstash, Kibana) e, portanto, no pacote jsonlog: </p><br><ul><li>  configure o formato <code>logrus.JSONFormatter</code> para <code>logrus.JSONFormatter</code> <br><ul><li>  ao mesmo tempo, definimos a op√ß√£o FieldMap, com a qual transformamos o campo <code>"time"</code> em <code>"@timestamp"</code> e o campo <code>"msg"</code> em <code>"message"</code> </li></ul></li><li>  selecione o n√≠vel do log </li><li>  adicione um gancho que extraia o rastreamento de pilha do objeto de <code>Error(error, ...interface{})</code> passado para o m√©todo <code>Error(error, ...interface{})</code> </li></ul><br><p>  O microsservi√ßo inicializa o logger na fun√ß√£o principal: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Tratamento e registro de erros com Middleware </h2><br><p>  Estamos mudando para o GRPC em nossos microsservi√ßos on Go.  Mas mesmo se voc√™ usar a API HTTP, os princ√≠pios gerais s√£o para voc√™. </p><br><p>  Primeiro, o tratamento e registro de erros devem ocorrer no n√≠vel da <code>infrastructure</code> do pacote respons√°vel pelo transporte, porque √© ele quem combina o conhecimento das regras do protocolo de transporte e o conhecimento dos <code>app.Service</code> interface <code>app.Service</code> .  Lembre-se da apar√™ncia do relacionamento do pacote: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Diagrama de pacote GRPC da imagem"></p><br><p>  √â conveniente processar erros e manter logs usando o padr√£o Middleware (Middleware √© o nome do padr√£o Decorator no mundo de Golang e Node.js): </p><br><p>  Onde adicionar o Middleware?  Quantos devem haver? </p><br><p>  Existem diferentes op√ß√µes para adicionar Middleware, voc√™ escolhe: </p><br><ul><li>  Voc√™ pode decorar a interface <code>app.Service</code> , mas n√£o recomendamos fazer isso porque essa interface n√£o recebe informa√ß√µes da camada de transporte, como IP do cliente </li><li>  Com o GRPC, voc√™ pode suspender um manipulador em todas as solicita√ß√µes (mais precisamente, duas - un√°rias e steam), mas todos os m√©todos de API ser√£o registrados no mesmo estilo com o mesmo conjunto de campos </li><li>  Com o GRPC, o gerador de c√≥digo cria para n√≥s uma interface de servidor na qual chamamos o m√©todo <code>app.Service</code> - decoramos essa interface porque ela cont√©m informa√ß√µes em n√≠vel de transporte e a capacidade de registrar diferentes m√©todos de API de maneiras diferentes </li></ul><br><p>  Esquematicamente aparece assim: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Diagrama de pacote de imagem GRPC Middleware"></p><br><p>  Voc√™ pode criar Middlewares diferentes para tratamento de erros (e p√¢nico) e para cria√ß√£o de log.  Voc√™ pode cruzar tudo em um.  Vamos considerar um exemplo no qual tudo √© cruzado em um Middleware, criado dessa maneira: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  N√≥s obtemos a interface <code>api.BackendService</code> como uma <code>api.BackendService</code> e a decoramos, retornando nossa implementa√ß√£o da interface <code>api.BackendService</code> como uma <code>api.BackendService</code> . </p><br><p>  Um m√©todo de API arbitr√°rio no Middleware √© implementado da seguinte maneira: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Aqui, realizamos tr√™s tarefas: </p><br><ol><li>  Chame o m√©todo ListCakes do objeto decorado </li><li>  <code>logCall</code> m√©todo <code>logCall</code> , transmitindo todas as informa√ß√µes importantes, incluindo um conjunto de campos individualmente selecionados que se enquadram no log </li><li>  No final, substitu√≠mos o erro chamando translateError. </li></ol><br><p>  A convers√£o de erros ser√° discutida mais tarde.  E o <code>logCall</code> √© realizado pelo m√©todo <code>logCall</code> , que simplesmente chama o m√©todo correto da interface do Logger: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Erro de tradu√ß√£o </h2><br><p>  Devemos obter a causa raiz do erro e transform√°-lo em um erro compreens√≠vel no n√≠vel de transporte e documentado na API do seu servi√ßo. </p><br><p>  No GRPC, √© simples - use a fun√ß√£o <code>status.Errorf</code> para criar um erro com um c√≥digo de status.  Se voc√™ tiver uma API HTTP (API REST), poder√° criar seu pr√≥prio tipo de erro que os <strong>n√≠veis de aplicativo e dom√≠nio n√£o devem estar cientes.</strong> </p><br><p>  Em uma primeira aproxima√ß√£o, a tradu√ß√£o do erro √© semelhante a esta: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Ao validar argumentos de entrada, a interface decorada pode retornar um erro do <code>status.Status</code> Tipo de status com um c√≥digo de status e a primeira vers√£o do translateError perder√° esse c√≥digo de status. </p><br><p>  Vamos fazer uma vers√£o aprimorada convertendo para um tipo de interface (vida longa, digitando duck!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  A fun√ß√£o <code>translateError</code> √© criada individualmente para cada contexto (m√≥dulo independente) em seu microsservi√ßo e converte erros de l√≥gica de neg√≥cios em erros no n√≠vel de transporte. </p><br><h2 id="podvedyom-itogi">  Resumir </h2><br><p>  Oferecemos v√°rias regras para lidar com erros e trabalhar com logs.  A decis√£o de segui-los ou n√£o √© com voc√™. </p><br><ol><li>  Siga os princ√≠pios da arquitetura limpa, n√£o quebre direta ou indiretamente a regra das depend√™ncias.  A l√≥gica de neg√≥cios deve depender apenas de uma linguagem de programa√ß√£o e n√£o de tecnologias externas. </li><li>  Use um pacote que ofere√ßa composi√ß√£o de erro e cria√ß√£o de rastreamento de pilha.  Por exemplo, "github.com/pkg/errors" ou o pacote xerrors, que em breve far√° parte da biblioteca padr√£o Go. </li><li>  N√£o use bibliotecas de log de terceiros no microsservi√ßo - crie sua pr√≥pria biblioteca com os pacotes log e jsonlog, que ocultar√£o os detalhes da implementa√ß√£o de log </li><li>  Use o padr√£o Middleware para manipular erros e gravar logs na dire√ß√£o de transporte do n√≠vel de infraestrutura do programa </li></ol><br><p>  Aqui, n√£o dissemos nada sobre as tecnologias de rastreamento de consultas (por exemplo, OpenTracing), monitoramento de m√©tricas (por exemplo, desempenho de consultas ao banco de dados) e outras coisas como registro em log.  Voc√™ mesmo vai lidar com isso, n√≥s acreditamos em voc√™. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459130/">https://habr.com/ru/post/pt459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459118/index.html">Como projetamos e implementamos a nova rede na Huawei no escrit√≥rio de Moscou, parte 2</a></li>
<li><a href="../pt459120/index.html">Computadores modulares incorporados da s√©rie UNO-1000/2000</a></li>
<li><a href="../pt459122/index.html">Aleksey Savvateev: Pr√™mio Nobel de Jean Tyrol por analisar mercados imperfeitos (2014) e reputa√ß√£o coletiva</a></li>
<li><a href="../pt459126/index.html">Tanque de rob√¥ Raspberry Pi com bast√£o de computador Intel Neural 2</a></li>
<li><a href="../pt459128/index.html">Interfaces japonesas no mundo real</a></li>
<li><a href="../pt459134/index.html">Experi√™ncia usando BDD</a></li>
<li><a href="../pt459136/index.html">P√≠lula azul falsa</a></li>
<li><a href="../pt459138/index.html">Como a chave secreta da Huawei entrou no firmware dos roteadores Cisco</a></li>
<li><a href="../pt459140/index.html">Coloca√ß√£o do implante: como isso √© feito?</a></li>
<li><a href="../pt459142/index.html">Construindo um gr√°fico de linha de m√©dia m√≥vel animado em R. Recuperando dados atrav√©s da API da NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>