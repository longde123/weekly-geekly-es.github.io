<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçî üöµüèª üë®üèº‚Äçüç≥ Verwalten der Asynchronit√§t in PHP: Von Versprechen zu Coroutinen ‚òÑÔ∏è üë©‚Äç‚öñÔ∏è üìÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist Asynchronit√§t? Kurz gesagt bedeutet Asynchronit√§t, dass mehrere Aufgaben √ºber einen bestimmten Zeitraum ausgef√ºhrt werden. PHP wird in einem e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwalten der Asynchronit√§t in PHP: Von Versprechen zu Coroutinen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  Was ist Asynchronit√§t?  Kurz gesagt bedeutet Asynchronit√§t, dass mehrere Aufgaben √ºber einen bestimmten Zeitraum ausgef√ºhrt werden.  PHP wird in einem einzigen Thread ausgef√ºhrt, was bedeutet, dass jeweils nur ein Teil des PHP-Codes ausgef√ºhrt werden kann.  Dies mag wie eine Einschr√§nkung erscheinen, gibt uns aber tats√§chlich mehr Freiheit.  Infolgedessen m√ºssen wir uns nicht der Komplexit√§t der Multithread-Programmierung stellen.  Andererseits gibt es eine Reihe von Problemen.  Wir m√ºssen uns mit Asynchronit√§t befassen.  Wir m√ºssen es irgendwie schaffen und koordinieren. </p><br><p>  <em>Einf√ºhrung in die √úbersetzung eines Artikels aus dem Blog des Skyeng-Backend-Entwicklers Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Wenn wir beispielsweise zwei parallele HTTP-Anforderungen ausf√ºhren, sagen wir, dass sie "parallel ausgef√ºhrt" werden.  Dies ist normalerweise einfach und unkompliziert. Es treten jedoch Probleme auf, wenn wir die Antworten dieser Anforderungen organisieren m√ºssen, z. B. wenn f√ºr eine Anforderung Daten erforderlich sind, die von einer anderen Anforderung empfangen wurden.  Daher liegt die gr√∂√üte Schwierigkeit im Asynchronit√§tsmanagement.  Es gibt verschiedene M√∂glichkeiten, um dieses Problem zu l√∂sen. </p><br><blockquote>  PHP bietet derzeit keine native Unterst√ºtzung f√ºr Abstraktionen auf hoher Ebene zur Steuerung der Asynchronit√§t, und wir m√ºssen Bibliotheken von Drittanbietern wie ReactPHP und Amp verwenden.  In den Beispielen in diesem Artikel verwende ich ReactPHP. </blockquote><br><h3>  Versprechen </h3><br><p>  Um die Idee von Versprechungen besser zu verstehen, wird ein Beispiel aus der Praxis n√ºtzlich sein.  Stellen Sie sich vor, Sie sind bei McDonald's und m√∂chten eine Bestellung aufgeben.  Sie zahlen Geld daf√ºr und beginnen damit die Transaktion.  Als Antwort auf diese Transaktion erwarten Sie einen Hamburger und Pommes.  Die Kassiererin gibt das Essen jedoch nicht sofort zur√ºck.  Stattdessen erhalten Sie einen Scheck mit der Bestellnummer.  Betrachten Sie diesen Scheck als Versprechen f√ºr eine zuk√ºnftige Bestellung.  Jetzt k√∂nnen Sie diesen Check machen und √ºber Ihr k√∂stliches Mittagessen nachdenken.  Der erwartete Hamburger und die Pommes sind noch nicht fertig, also stehen Sie und warten, bis Ihre Bestellung abgeschlossen ist.  Sobald seine Nummer auf dem Bildschirm erscheint, tauschen Sie den Scheck gegen Ihre Bestellung ein.  Das sind die Versprechen: </p><br><blockquote>  <i>Ersatz f√ºr zuk√ºnftigen Wert.</i> </blockquote><p>  Ein Versprechen ist eine Darstellung f√ºr die zuk√ºnftige Bedeutung, ein zeitunabh√§ngiger Wrapper, den wir um die Bedeutung wickeln.  Es ist uns egal, ob der Wert bereits vorhanden ist oder noch nicht.  Wir denken weiterhin genauso √ºber ihn.  Stellen Sie sich vor, wir haben drei asynchrone HTTP-Anforderungen, die "parallel" ausgef√ºhrt werden, sodass sie zu einem bestimmten Zeitpunkt abgeschlossen werden.  Aber wir wollen ihre Antworten irgendwie koordinieren und organisieren.  Zum Beispiel m√∂chten wir diese Antworten drucken, sobald sie empfangen wurden, aber mit einer kleinen Einschr√§nkung: Drucken Sie die zweite Antwort erst, wenn die erste empfangen wurde.  Hier meine ich, wenn <b>$ Versprechen1</b> erf√ºllt ist, dann drucken wir es.  Wenn jedoch <b>$ Versprechen2</b> zuerst erf√ºllt wird, drucken wir es nicht aus, da <b>$ Versprechen1</b> noch in Bearbeitung ist.  Stellen Sie sich vor, wir versuchen, drei wettbewerbsf√§hige Anfragen so anzupassen, dass sie f√ºr den Endbenutzer wie eine schnelle Anfrage aussehen. </p><br><p>  Wie k√∂nnen wir dieses Problem mit Versprechungen l√∂sen?  Zun√§chst brauchen wir eine Funktion, die ein Versprechen zur√ºckgibt.  Wir k√∂nnen drei solcher Versprechen sammeln und sie dann zusammenstellen.  Hier ist ein gef√§lschter Code daf√ºr: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Hier habe ich zwei Funktionen: <br>  <b>fakeResponse (Zeichenfolge $ url, aufrufbarer $ R√ºckruf)</b> enth√§lt eine fest codierte Antwort und erm√∂glicht den angegebenen R√ºckruf mit dieser Antwort. <br>  <b>makeRequest (string $ url)</b> gibt ein Versprechen zur√ºck, das <b>fakeResponse () verwendet,</b> um anzuzeigen, dass die Anforderung abgeschlossen wurde. </p><br><p>  Aus dem Client-Code rufen wir einfach die Funktion <b>makeRequest () auf</b> und erhalten die Versprechen: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  Es war einfach, aber jetzt m√ºssen wir diese Antworten irgendwie sortieren.  Wir m√∂chten erneut, dass die Antwort aus dem zweiten Versprechen erst nach Abschluss des ersten Versprechens gedruckt wird.  Um dieses Problem zu l√∂sen, k√∂nnen Sie eine Reihe von Versprechungen erstellen: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Im obigen Code beginnen wir mit <b>$ versprechen1</b> .  Sobald es fertig ist, drucken wir seinen Wert.  Es ist uns egal, wie lange es dauert: weniger als eine Sekunde oder eine Stunde.  Sobald das Versprechen erf√ºllt ist, werden wir seinen Wert drucken.  Und dann warten wir auf <b>$ versprechen2</b> .  Und hier k√∂nnen wir zwei Szenarien haben: </p><br><p>  <b>$ versprechen2 ist</b> bereits abgeschlossen und wir drucken sofort seinen Wert; <br>  <b>$ versprechen2 wird</b> noch erf√ºllt und wir warten. </p><br><p>  Dank der Verkettung von Versprechungen m√ºssen wir uns keine Sorgen mehr machen, ob ein Versprechen erf√ºllt wurde oder nicht.  Promis ist nicht zeitabh√§ngig und verbirgt dadurch seine Zust√§nde vor uns (dabei bereits abgeschlossen oder storniert). </p><br><p>  So k√∂nnen Sie die Asynchronit√§t mit Versprechungen steuern.  Und es sieht gut aus, die Kette der Versprechen ist viel h√ºbscher und verst√§ndlicher als eine Reihe verschachtelter R√ºckrufe. </p><br><h3>  Generatoren </h3><br><p>  In PHP sind Generatoren eine integrierte Sprachunterst√ºtzung f√ºr Funktionen, die angehalten und dann fortgesetzt werden k√∂nnen.  Wenn die Codeausf√ºhrung in einem solchen Generator stoppt, sieht es aus wie ein kleines blockiertes Programm.  Aber au√üerhalb dieses Programms, au√üerhalb des Generators, funktioniert alles andere weiter.  Das ist die ganze Magie und Kraft der Generatoren. </p><br><p>  Wir k√∂nnen den Generator buchst√§blich vor Ort anhalten, um auf die Erf√ºllung des Versprechens zu warten.  Die Grundidee ist, Versprechen und Generatoren zusammen zu verwenden.  Sie √ºbernehmen die Kontrolle √ºber die Asynchronit√§t, und wir rufen Yield nur auf, wenn wir den Generator anhalten m√ºssen.  Hier ist das gleiche Programm, aber jetzt verbinden wir Generatoren und Versprechen: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>F√ºr diesen Code verwende ich die Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">recoilphp / recoil</a> , mit der Sie <b>ReactKernel :: start ()</b> aufrufen <b>k√∂nnen</b> .</i>  <i>Mit Recoil k√∂nnen PHP-Generatoren verwendet werden, um asynchrone ReactPHP-Versprechen auszuf√ºhren.</i> </blockquote><p>  Hier f√ºhren wir immer noch drei Abfragen parallel durch, aber jetzt sortieren wir die Antworten mit dem Schl√ºsselwort <b>yield</b> .  Und wieder zeigen wir die Ergebnisse am Ende jedes Versprechens an, aber erst nach dem vorherigen. </p><br><h3>  Coroutinen </h3><br><p>  Coroutinen sind eine M√∂glichkeit, eine Operation oder einen Prozess in Bl√∂cke zu unterteilen, wobei in jedem dieser Bl√∂cke eine gewisse Ausf√ºhrung erfolgt.  Infolgedessen stellt sich heraus, dass der gesamte Vorgang nicht gleichzeitig ausgef√ºhrt wird (was zu einem sp√ºrbaren Einfrieren der Anwendung f√ºhren kann), sondern schrittweise ausgef√ºhrt wird, bis alle erforderlichen Arbeiten abgeschlossen sind. </p><br><p>  Jetzt, da wir unterbrechbare und erneuerbare Generatoren haben, k√∂nnen wir sie verwenden, um asynchronen Code mit Versprechungen in einer bekannteren synchronen Form zu schreiben.  Mit PHP-Generatoren und Versprechungen k√∂nnen Sie R√ºckrufe vollst√§ndig beseitigen.  Die Idee ist, dass, wenn wir ein Versprechen abgeben (unter Verwendung des Yield Call), eine Coroutine es abonniert.  Corutin macht eine Pause und wartet, bis das Versprechen erf√ºllt ist (abgeschlossen oder storniert).  Sobald das Versprechen erf√ºllt ist, wird Coroutine weiterhin erf√ºllt.  Nach erfolgreichem Abschluss sendet das Coroutine-Versprechen den empfangenen Wert mithilfe des Aufrufs <b>Generator :: send ($ value)</b> an den Generatorkontext zur√ºck.  Wenn das Versprechen fehlschl√§gt, l√∂st Corutin mit dem Aufruf <b>Generator :: throw ()</b> eine Ausnahme durch den Generator aus.  Ohne R√ºckrufe k√∂nnen wir asynchronen Code schreiben, der fast wie der √ºbliche synchrone Code aussieht. </p><br><p>  <b>Sequentielle Ausf√ºhrung</b> </p><br><p>  Bei Verwendung von Coroutine ist jetzt die Ausf√ºhrungsreihenfolge im asynchronen Code von Bedeutung.  Der Code wird genau an der Stelle ausgef√ºhrt, an der das Yield-Schl√ºsselwort aufgerufen wird, und dann angehalten, bis das Versprechen erf√ºllt ist.  Betrachten Sie den folgenden Code: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Versprechen1:</b> wird hier angezeigt, dann wird die Ausf√ºhrung angehalten und gewartet.  Sobald das Versprechen von <b>makeRequest ('url1') erf√ºllt</b> ist, drucken wir das Ergebnis aus und fahren mit der n√§chsten Codezeile fort. </p><br><p>  <b>Fehlerbehandlung</b> </p><br><p>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promises / A +</a> Promise-Standard besagt, dass jedes Promise die Methoden <b>then () und catch () enth√§lt</b> .  √úber diese Schnittstelle k√∂nnen Sie Ketten aus Versprechungen erstellen und optional Fehler abfangen.  Betrachten Sie den folgenden Code: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Hier haben wir eine Kette von Versprechungen, die das Ergebnis jedes vorherigen Versprechens an das n√§chste weitergibt.  Es gibt jedoch keinen <b>catch ()</b> -Block in dieser Kette, hier gibt es keine Fehlerbehandlung.  Wenn ein Versprechen in einer Kette fehlschl√§gt, wird die Codeausf√ºhrung zum n√§chsten Fehlerbehandler in der Kette verschoben.  In unserem Fall bedeutet dies, dass das ausstehende Versprechen ignoriert wird und alle Fehler, die weggeworfen werden, f√ºr immer verschwinden.  Bei Coroutinen tritt die Fehlerbehandlung in den Vordergrund.  Wenn eine asynchrone Operation fehlschl√§gt, wird eine Ausnahme ausgel√∂st: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Asynchronen Code lesbar machen </h3><br><p>  Generatoren haben einen wirklich wichtigen Nebeneffekt, mit dem wir die Asynchronit√§t steuern k√∂nnen und der das Problem der Lesbarkeit von asynchronem Code l√∂st.  Es ist schwer zu verstehen, wie der asynchrone Code ausgef√ºhrt wird, da der Ausf√ºhrungsthread st√§ndig zwischen verschiedenen Teilen des Programms wechselt.  Unser Gehirn arbeitet jedoch grunds√§tzlich synchron und mit einem Thread.  Zum Beispiel planen wir unseren Tag sehr konsequent: einen, dann einen anderen und so weiter.  Aber asynchroner Code funktioniert nicht so, wie unser Gehirn es gewohnt ist zu denken.  Selbst eine einfache Kette von Versprechungen sieht m√∂glicherweise nicht gut lesbar aus: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Wir m√ºssen es mental zerlegen, um zu verstehen, was dort passiert.  Wir brauchen also ein anderes Muster, um die Asynchronit√§t zu steuern.  Kurz gesagt, Generatoren bieten eine M√∂glichkeit, asynchronen Code so zu schreiben, dass er synchron aussieht. </p><br><p>  Versprechen und Generatoren kombinieren das Beste aus beiden Welten: Wir erhalten asynchronen Code mit gro√üer Leistung, aber gleichzeitig sieht er synchron, linear und sequentiell aus.  Mit Coroutinen k√∂nnen Sie die Asynchronit√§t ausblenden, die bereits zu einem Implementierungsdetail wird.  Gleichzeitig sieht unser Code so aus, als w√§re unser Gehirn an das Denken gew√∂hnt - linear und sequentiell. </p><br><p>  Wenn wir √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReactPHP</a> sprechen, k√∂nnen wir die RecoilPHP-Bibliothek verwenden, um Versprechen in Form von Coroutine zu schreiben.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amp sind</a> Coroutinen sofort verf√ºgbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453296/">https://habr.com/ru/post/de453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453280/index.html">Technische Schulden</a></li>
<li><a href="../de453286/index.html">Der teuerste Fehler in meinem Leben: Details zum Angriff auf den SIM-Kartenanschluss</a></li>
<li><a href="../de453290/index.html">Data Science Digest (Mai 2019)</a></li>
<li><a href="../de453292/index.html">"Ein kleines Buch √ºber Schwarze L√∂cher"</a></li>
<li><a href="../de453294/index.html">Reagiere Faules Laden</a></li>
<li><a href="../de453298/index.html">Sommer: Upgrade-Zeit ... selbst</a></li>
<li><a href="../de453300/index.html">3D Game Shader f√ºr Anf√§nger</a></li>
<li><a href="../de453302/index.html">Die erste Lebensstunde mit Yandex.Module</a></li>
<li><a href="../de453304/index.html">Hauptvorteile von Zextras PowerStore</a></li>
<li><a href="../de453306/index.html">Kubernetes wird die Welt √ºbernehmen. Wann und wie?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>