<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèª üë©üèº‚Äç‚öñÔ∏è üà≤ Comment rendre les conteneurs encore plus isol√©s: un examen des technologies de bac √† sable pour conteneurs üë©üèª üñåÔ∏è üéôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgr√© le fait que la plupart de l'industrie informatique impl√©mente des solutions d'infrastructure bas√©es sur des conteneurs et des solutions cloud, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre les conteneurs encore plus isol√©s: un examen des technologies de bac √† sable pour conteneurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/">  Malgr√© le fait que la plupart de l'industrie informatique impl√©mente des solutions d'infrastructure bas√©es sur des conteneurs et des solutions cloud, il est n√©cessaire de comprendre les limites de ces technologies.  Traditionnellement, Docker, Linux Containers (LXC) et Rocket (rkt) ne sont pas vraiment isol√©s car ils partagent le c≈ìur du syst√®me d'exploitation parent dans leur travail.  Oui, ils sont efficaces en termes de ressources, mais le nombre total de vecteurs d'attaque estim√©s et les pertes potentielles dues au piratage sont toujours importants, en particulier dans le cas d'un environnement cloud multi-locataire dans lequel se trouvent des conteneurs. <br><br><img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br><br>  La racine de notre probl√®me r√©side dans la faible d√©limitation des conteneurs au moment o√π le syst√®me d'exploitation h√¥te cr√©e une zone utilisateur virtuelle pour chacun d'eux.  Oui, des recherches et d√©veloppements ont √©t√© men√©s pour cr√©er de v√©ritables ¬´conteneurs¬ª avec un bac √† sable √† part enti√®re.  Et la plupart des solutions qui en r√©sultent conduisent √† une restructuration des fronti√®res entre les conteneurs pour am√©liorer leur isolation.  Dans cet article, nous examinerons quatre projets uniques d'IBM, Google, Amazon et OpenStack, respectivement, qui utilisent diff√©rentes m√©thodes pour atteindre le m√™me objectif: cr√©er un isolement fiable.  Ainsi, IBM Nabla d√©ploie des conteneurs au-dessus d'Unikernel, Google gVisor cr√©e un noyau invit√© sp√©cialis√©, Amazon Firecracker utilise un hyperviseur extr√™mement l√©ger pour les applications sandbox et OpenStack place les conteneurs dans une machine virtuelle sp√©cialis√©e optimis√©e pour les outils d'orchestration. <br><a name="habracut"></a><br><h3>  Aper√ßu de la technologie moderne des conteneurs </h3><br>  Les conteneurs sont un moyen moderne de regrouper, de partager et de d√©ployer une application.  Contrairement √† une application monolithique, dans laquelle toutes les fonctions sont regroup√©es dans un seul programme, les applications de conteneur ou les microservices sont destin√©s √† une utilisation √©troite cibl√©e et sont sp√©cialis√©s dans une seule t√¢che. <br><br>  Un conteneur comprend toutes les d√©pendances (par exemple, packages, biblioth√®ques et fichiers binaires) dont une application a besoin pour effectuer sa t√¢che sp√©cifique.  Par cons√©quent, les applications conteneuris√©es sont ind√©pendantes de la plate-forme et peuvent s'ex√©cuter sur n'importe quel syst√®me d'exploitation, quelle que soit la version ou les packages install√©s.  Cette commodit√© sauve les d√©veloppeurs d'un √©norme travail sur l'adaptation de diff√©rentes versions de logiciels pour diff√©rentes plates-formes ou clients.  Bien que conceptuellement pas tout √† fait exact, de nombreuses personnes aiment consid√©rer les conteneurs comme des ¬´machines virtuelles l√©g√®res¬ª. <br><br>  Lorsqu'un conteneur est d√©ploy√© sur un h√¥te, les ressources de chaque conteneur, telles que son syst√®me de fichiers, son processus et sa pile r√©seau, sont plac√©es dans un environnement pratiquement isol√© auquel les autres conteneurs ne peuvent pas acc√©der.  Cette architecture permet √† des centaines et des milliers de conteneurs de s'ex√©cuter simultan√©ment dans un seul cluster, et chaque application (ou microservice) peut ensuite √™tre facilement mise √† l'√©chelle en r√©pliquant un grand nombre d'instances. <br><br>  Dans ce cas, la disposition du conteneur est bas√©e sur deux ¬´blocs de construction¬ª cl√©s: l'espace de noms Linux et les groupes de contr√¥le Linux (cgroups). <br><br>  L'espace de noms cr√©e un espace utilisateur pratiquement isol√© et fournit √† l'application des ressources syst√®me d√©di√©es telles que le syst√®me de fichiers, la pile r√©seau, l'ID de processus et l'ID utilisateur.  Dans cet espace utilisateur isol√©, l'application contr√¥le le r√©pertoire racine du syst√®me de fichiers et peut √™tre ex√©cut√©e en tant que root.  Cet espace abstrait permet √† chaque application de fonctionner ind√©pendamment, sans interf√©rer avec d'autres applications vivant sur le m√™me h√¥te.  Six espaces de noms sont actuellement disponibles: montage, communication inter-processus (ipc), syst√®me de partage de temps UNIX (uts), identifiant de processus (pid), r√©seau et utilisateur.  Il est propos√© de compl√©ter cette liste par deux espaces de noms suppl√©mentaires: time et syslog, mais la communaut√© Linux n'a pas encore d√©cid√© des sp√©cifications finales. <br><br>  Les groupes de contr√¥le assurent la limitation des ressources mat√©rielles, la priorisation, la surveillance et le contr√¥le des applications.  Un exemple des ressources mat√©rielles qu'ils peuvent contr√¥ler est le processeur, la m√©moire, le p√©riph√©rique et le r√©seau.  Lors de la combinaison de l'espace de noms et des groupes de contr√¥le, nous pouvons ex√©cuter en toute s√©curit√© plusieurs applications sur le m√™me h√¥te, chaque application dans son propre environnement isol√© - qui est la propri√©t√© fondamentale du conteneur. <br><br>  La principale diff√©rence entre une machine virtuelle (VM) et un conteneur est que la machine virtuelle est la virtualisation au niveau mat√©riel et le conteneur est la virtualisation au niveau du syst√®me d'exploitation.  L'hyperviseur VM √©mule l'environnement mat√©riel de chaque machine, o√π le runtime du conteneur √©mule d√©j√† √† son tour le syst√®me d'exploitation pour chaque objet.  Les machines virtuelles partagent le mat√©riel physique de l'h√¥te et les conteneurs partagent √† la fois le mat√©riel et le c≈ìur du syst√®me d'exploitation.  √âtant donn√© que les conteneurs partagent g√©n√©ralement plus de ressources avec l'h√¥te, leur travail avec les cycles de stockage, de m√©moire et de processeur est beaucoup plus efficace qu'avec une machine virtuelle.  Cependant, l'inconv√©nient de cet acc√®s partag√© r√©side dans les probl√®mes de s√©curit√© de l'information, car trop de confiance s'√©tablit entre les conteneurs et l'h√¥te.  La figure 1 illustre la diff√©rence architecturale entre un conteneur et une machine virtuelle. <br><br><img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br><br>  En g√©n√©ral, l'isolement des √©quipements virtualis√©s cr√©e un p√©rim√®tre de s√©curit√© beaucoup plus solide que la simple isolation d'un espace de noms.  Le risque qu'un attaquant quitte avec succ√®s un processus isol√© est beaucoup plus √©lev√© que la chance de quitter avec succ√®s la machine virtuelle.  La raison du risque plus √©lev√© d'aller au-del√† de l'environnement de conteneur limit√© est la mauvaise isolation cr√©√©e par l'espace de noms et les groupes de contr√¥le.  Linux les impl√©mente en associant de nouveaux champs de propri√©t√© √† chaque processus.  Ces champs du syst√®me de fichiers <code>/proc</code> indiquent au syst√®me d'exploitation h√¥te si un processus peut en voir un autre ou la quantit√© de ressources processeur / m√©moire qu'un processus particulier peut utiliser.  Lors de l'affichage des processus et des threads en cours d'ex√©cution √† partir du syst√®me d'exploitation parent (par exemple, la commande top ou ps), le processus de conteneur ressemble √† n'importe quel autre.  En r√®gle g√©n√©rale, les solutions traditionnelles, telles que LXC ou Docker, ne sont pas consid√©r√©es comme enti√®rement isol√©es car elles utilisent le m√™me c≈ìur au sein du m√™me h√¥te.  Par cons√©quent, il n'est pas surprenant que les conteneurs pr√©sentent un nombre suffisant de vuln√©rabilit√©s.  Par exemple, CVE-2014-3519, CVE-2016-5195, CVE-2016-9962, CVE-2017-5123 et CVE-2019-5736 pourraient permettre √† un attaquant d'acc√©der aux donn√©es en dehors du conteneur. <br><br>  La plupart des exploits du noyau cr√©ent un vecteur pour une attaque r√©ussie, car ils entra√Ænent g√©n√©ralement une escalade de privil√®ges et permettent √† un processus compromis de prendre le contr√¥le en dehors de son espace de noms pr√©vu.  En plus d'attaquer les vecteurs dans le contexte des vuln√©rabilit√©s logicielles, une configuration incorrecte peut √©galement jouer un r√¥le.  Par exemple, le d√©ploiement d'images avec des privil√®ges excessifs (CAP_SYS_ADMIN, acc√®s privil√©gi√©) ou des points de montage critiques ( <code>/var/run/docker.sock</code> ) peut entra√Æner une fuite.  Compte tenu de ces cons√©quences potentiellement catastrophiques, vous devez comprendre le risque que vous prenez lors du d√©ploiement du syst√®me dans un espace multi-locataire ou lors de l'utilisation de conteneurs pour stocker des donn√©es sensibles. <br><br>  Ces probl√®mes incitent les chercheurs √† cr√©er des p√©rim√®tres de s√©curit√© plus solides.  L'id√©e est de cr√©er un v√©ritable conteneur sandbox aussi isol√© que possible du syst√®me d'exploitation principal.  La plupart de ces solutions incluent le d√©veloppement d'une architecture hybride qui utilise une distinction stricte entre l'application et la machine virtuelle, et se concentre sur l'am√©lioration de l'efficacit√© des solutions de conteneurs. <br><br>  Au moment d'√©crire ces lignes, aucun projet ne pouvait √™tre qualifi√© de suffisamment m√ªr pour √™tre accept√© comme standard, mais √† l'avenir, les d√©veloppeurs accepteront sans aucun doute certains de ces concepts comme √©tant les principaux. <br><br>  Nous commen√ßons notre examen avec Unikernel, le plus ancien syst√®me hautement sp√©cialis√© qui regroupe une application dans une image en utilisant un ensemble minimal de biblioth√®ques de syst√®me d'exploitation.  Le concept d'Unikernel lui-m√™me s'est av√©r√© fondamental pour de nombreux projets dont l'objectif √©tait de cr√©er des images s√ªres, compactes et optimis√©es.  Apr√®s cela, nous allons passer √† IBM Nabla, un projet de lancement d'applications Unikernel, y compris des conteneurs.  De plus, nous avons Google gVisor, un projet de lancement de conteneurs dans l'espace du noyau utilisateur.  Ensuite, nous passerons √† des solutions de conteneurs bas√©es sur des machines virtuelles - Amazon Firecracker et OpenStack Kata.  Pour r√©sumer ce message en comparant toutes les solutions ci-dessus. <br><br><h3>  Unikernel </h3><br>  Le d√©veloppement des technologies de virtualisation nous a permis de passer au cloud computing.  Des hyperviseurs comme Xen et KVM ont jet√© les bases de ce que nous connaissons aujourd'hui sous le nom d'Amazon Web Services (AWS) et de Google Cloud Platform (GCP).  Et bien que les hyperviseurs modernes soient capables de travailler avec des centaines de machines virtuelles combin√©es en un seul cluster, les syst√®mes d'exploitation √† usage g√©n√©ral traditionnels ne sont pas trop adapt√©s et optimis√©s pour fonctionner dans un tel environnement.  Le syst√®me d'exploitation √† usage g√©n√©ral est d'abord destin√© √† prendre en charge et √† travailler avec autant d'applications diff√©rentes que possible.Par cons√©quent, leurs noyaux incluent toutes sortes de pilotes, biblioth√®ques, protocoles, planificateurs, etc.  Cependant, la plupart des machines virtuelles qui sont maintenant d√©ploy√©es quelque part dans le cloud sont utilis√©es pour ex√©cuter une seule application, par exemple, pour fournir DNS, un proxy ou une sorte de base de donn√©es.  Puisqu'une telle application prise s√©par√©ment ne d√©pend dans son travail que d'une partie sp√©cifique et petite du noyau du syst√®me d'exploitation, toutes ses autres ¬´jupes¬ª gaspillent simplement les ressources du syst√®me et, du fait m√™me de leur existence, elles augmentent le nombre de vecteurs pour une attaque potentielle.  En effet, plus la base de code est grande, plus il est difficile d'√©liminer tous les d√©fauts, et plus les vuln√©rabilit√©s, erreurs et autres faiblesses potentielles sont nombreuses.  Ce probl√®me encourage les sp√©cialistes √† d√©velopper des syst√®mes d'exploitation hautement sp√©cialis√©s avec un ensemble minimum de fonctionnalit√©s du noyau, c'est-√†-dire √† cr√©er des outils pour prendre en charge une application sp√©cifique. <br><br>  Pour la premi√®re fois, l'id√©e d'Unikernel est n√©e dans les ann√©es 90.  Il a ensuite pris la forme d'une image sp√©cialis√©e d'une machine avec un seul espace d'adressage pouvant fonctionner directement sur des hyperviseurs.  Il regroupe les applications et les fonctions d√©pendantes du noyau et du noyau dans une seule image.  Nemesis et Exokernel sont les deux premi√®res versions de recherche du projet Unikernel.  Le processus de mise en package et de d√©ploiement est illustr√© √† la figure 2. <br><br><img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>  <i>Figure 2. Syst√®mes d'exploitation polyvalents con√ßus pour prendre en charge tous les types d'applications, de nombreuses biblioth√®ques et pilotes sont donc charg√©s √† l'avance.</i>  <i>Les Unikernels sont des syst√®mes d'exploitation hautement sp√©cialis√©s con√ßus pour prendre en charge une application sp√©cifique.</i> <i><br></i> <br>  Unikernel divise le noyau en plusieurs biblioth√®ques et ne met que les composants n√©cessaires dans l'image.  Comme les machines virtuelles classiques, unikernel se d√©ploie et s'ex√©cute sur l'hyperviseur VM.  En raison de sa petite taille, il peut se charger rapidement et aussi √©voluer rapidement.  Les fonctionnalit√©s les plus importantes d'Unikernel sont une s√©curit√© accrue, un encombrement r√©duit, un degr√© √©lev√© d'optimisation et un chargement rapide.  √âtant donn√© que ces images ne contiennent que des biblioth√®ques d√©pendantes de l'application et que le shell du syst√®me d'exploitation n'est pas accessible s'il n'√©tait pas connect√© de mani√®re cibl√©e, le nombre de vecteurs d'attaque que les attaquants peuvent utiliser sur eux est minime. <br><br>  Autrement dit, il est non seulement difficile pour les attaquants de prendre pied dans ces c≈ìurs uniques, mais leur influence est √©galement limit√©e √† une instance principale.  √âtant donn√© que la taille des images Unikernel n'est que de quelques m√©gaoctets, elles sont t√©l√©charg√©es en quelques dizaines de millisecondes et des centaines d'instances peuvent litt√©ralement s'ex√©cuter sur un seul h√¥te.  En utilisant l'allocation de m√©moire dans le m√™me espace d'adressage au lieu d'une table de pages √† plusieurs niveaux, comme c'est le cas dans la plupart des syst√®mes d'exploitation modernes, les applications unikernel ont un d√©lai d'acc√®s √† la m√©moire inf√©rieur √† la m√™me application ex√©cut√©e sur une machine virtuelle standard.  √âtant donn√© que les applications sont associ√©es au noyau lors de la cr√©ation de l'image, les compilateurs peuvent simplement effectuer une v√©rification de type statique pour optimiser les fichiers binaires. <br><br>  Unikernel.org maintient une liste de projets unikernel.  Mais avec toutes ses caract√©ristiques et propri√©t√©s distinctives, unikernel n'est pas largement utilis√©.  Lorsque Docker a acquis Unikernel Systems en 2016, la communaut√© a d√©cid√© que l'entreprise y emballerait d√©sormais des conteneurs.  Mais trois ans se sont √©coul√©s et il n'y a toujours aucun signe d'int√©gration.  L'une des principales raisons de cette lente impl√©mentation est qu'il n'existe toujours pas d'outil mature pour cr√©er des applications Unikernel, et la plupart de ces applications ne peuvent fonctionner que sur certains hyperviseurs.  De plus, le portage d'une application vers unikernel peut n√©cessiter une r√©√©criture manuelle du code dans d'autres langues, y compris la r√©√©criture des biblioth√®ques du noyau d√©pendantes.  Il est √©galement important que la surveillance ou le d√©bogage dans unikernels soit impossible ou ait un impact significatif sur les performances. <br><br>  Toutes ces restrictions emp√™chent les d√©veloppeurs de passer √† cette technologie.  Il convient de noter que le noyau unique et les conteneurs ont de nombreuses propri√©t√©s similaires.  La premi√®re et la seconde sont des images immuables hautement focalis√©es, ce qui signifie que les composants qu'elles contiennent ne peuvent pas √™tre mis √† jour ou corrig√©s, c'est-√†-dire que vous devez toujours cr√©er une nouvelle image pour le correctif d'application.  Aujourd'hui, Unikernel est similaire √† l'anc√™tre de Docker: alors le runtime du conteneur n'√©tait pas disponible, et les d√©veloppeurs ont d√ª utiliser les outils de base pour construire un environnement d'application isol√© (chroot, unshare et cgroups). <br><br><h3>  Ibm nabla </h3><br>  Une fois, les chercheurs d'IBM ont propos√© le concept de ¬´Unikernel en tant que processus¬ª, c'est-√†-dire l'application unikernel qui s'ex√©cuterait en tant que processus sur un hyperviseur sp√©cialis√©.  Le projet IBM ¬´Nabla containers¬ª a renforc√© le p√©rim√®tre de s√©curit√© d'unikernel, en rempla√ßant l'hyperviseur universel (par exemple, QEMU) par son propre d√©veloppement appel√© Nabla Tender.  La logique derri√®re cette approche est que les appels entre unikernel et l'hyperviseur fournissent toujours le plus de vecteurs d'attaque.  C'est pourquoi l'utilisation d'un hyperviseur d√©di√© √† unikernel avec moins d'appels syst√®me autoris√©s peut renforcer consid√©rablement le p√©rim√®tre de s√©curit√©.  Nabla Tender intercepte les appels que le noyau achemine vers l'hyperviseur et les traduit d√©j√† en requ√™tes syst√®me.  Dans le m√™me temps, la politique seccomp Linux bloque tous les autres appels syst√®me qui ne sont pas n√©cessaires au fonctionnement de Tender.  Ainsi, Unikernel en conjonction avec Nabla Tender s'ex√©cute comme un processus dans l'espace utilisateur de l'h√¥te.  Ci-dessous, dans la figure # 3, il est montr√© comment Nabla cr√©e une interface mince entre unikernel et l'h√¥te. <br><br><img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>  <i>Figure 3. Pour lier Nabla aux plates-formes d'ex√©cution de conteneur existantes, Nabla utilise un environnement compatible OCI, qui √† son tour peut √™tre connect√© √† Docker ou Kubernetes.</i> <br><br>  Les d√©veloppeurs affirment que Nabla Tender utilise moins de sept appels syst√®me dans son travail pour interagir avec l'h√¥te.  Puisque les appels syst√®me servent de pont entre les processus dans l'espace utilisateur et le noyau du syst√®me d'exploitation, moins nous avons d'appels syst√®me, plus le nombre de vecteurs disponibles pour attaquer le noyau est petit.  Un autre avantage de l'ex√©cution d'unikernel en tant que processus est que vous pouvez d√©boguer de telles applications √† l'aide d'un grand nombre d'outils, par exemple, √† l'aide de gdb. <br><br>  Pour fonctionner avec les plates-formes d'orchestration de conteneurs, Nabla fournit un <code>runnc</code> d√©di√© qui est impl√©ment√© √† l'aide de la norme Open Container Initiative (OCI).  Ce dernier d√©finit une API entre les clients (par exemple Docker, Kubectl) et l'environnement d'ex√©cution (par exemple, runc).  Nabla est √©galement livr√© avec un constructeur d'images que <code>runnc</code> pourra plus tard ex√©cuter.  Cependant, en raison des diff√©rences dans le syst√®me de fichiers entre les unikernels et les conteneurs traditionnels, les images Nabla ne r√©pondent pas aux sp√©cifications des images OCI et, par cons√©quent, les images Docker ne sont pas compatibles avec <code>runnc</code> .  Au moment de la r√©daction, le projet en √©tait encore aux premiers stades de d√©veloppement.  Il existe d'autres restrictions, par exemple, le manque de prise en charge pour le montage / acc√®s aux syst√®mes de fichiers h√¥tes, l'ajout de plusieurs interfaces r√©seau (n√©cessaires pour Kubernetes) ou l'utilisation d'images provenant d'autres images de noyau unique (par exemple, MirageOS). <br><br><h3>  Google gVisor </h3><br>  Google gVisor est une technologie sandbox utilisant le moteur d'application Google Cloud Platform (GCP), des fonctionnalit√©s cloud et CloudML.  √Ä un moment donn√©, Google a r√©alis√© le risque d'ex√©cuter des applications non fiables dans l'infrastructure de cloud public et l'inefficacit√© des applications sandbox utilisant des machines virtuelles.  En cons√©quence, un noyau d'espace utilisateur a √©t√© d√©velopp√© pour un environnement isol√© de telles applications peu fiables.  gVisor place ces applications dans le bac √† sable, intercepte tous les appels syst√®me de celles-ci vers le noyau h√¥te et les traite dans l'environnement utilisateur √† l'aide du noyau gVisor Sentry.  En substance, il fonctionne comme une combinaison d'un noyau invit√© et d'un hyperviseur.  La figure 4 montre l'architecture gVisor. <br><br><img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>  <i>Figure 4. Impl√©mentation du noyau gVisor // Les syst√®mes de fichiers Sentry et gVisor Gofer utilisent un petit nombre d'appels syst√®me pour interagir avec l'h√¥te</i> <br><br>  gVisor cr√©e un solide p√©rim√®tre de s√©curit√© entre l'application et son h√¥te.  Il limite les appels syst√®me que les applications peuvent utiliser dans l'espace utilisateur.  Sans s'appuyer sur la virtualisation, gVisor fonctionne comme un processus h√¥te qui interagit entre une application autonome et un h√¥te.  Sentry prend en charge la plupart des appels syst√®me Linux et les principales fonctions du noyau telles que la livraison du signal, la gestion de la m√©moire, la pile r√©seau et le mod√®le de flux.  Sentry impl√©mente plus de 70% des 319 appels syst√®me Linux pour prendre en charge les applications en bac √† sable.  Cependant, Sentry utilise moins de 20 appels syst√®me Linux pour interagir avec le noyau h√¥te.  Il convient de noter que gVisor et Nabla ont une strat√©gie tr√®s similaire: la protection du syst√®me d'exploitation h√¥te et ces deux solutions utilisent moins de 10% des appels syst√®me Linux pour interagir avec le noyau.  Mais vous devez comprendre que gVisor cr√©e un noyau polyvalent et, par exemple, Nabla s'appuie sur des noyaux uniques.  Dans le m√™me temps, les deux solutions lancent un noyau invit√© sp√©cialis√© dans l'espace utilisateur pour prendre en charge les applications isol√©es auxquelles elles font confiance. <br><br>  Quelqu'un peut se demander pourquoi gVisor a besoin de son propre noyau, alors que le noyau Linux est d√©j√† open source et facilement accessible.  ,  gVisor,   Golang,  ,   ‚Äã‚ÄãLinux,   C.           Golang.      gVisor ‚Äî    Docker, Kubernetes   OCI.   Docker        gVisor,     gVisor runsc.   Kubernetes  ¬´¬ª       gVisor    ¬´¬ª-. <br><br>  gVisor      ,     .  gVisor     ,    ,   ,       . ( ,   Nabla   ,   unikernel    . Nabla        hypercall).  gVisor     (passthrough),  ,   , ,  GPU,     . ,  gVisor   70%   Linux, ,       ,     gVisor. <br><br><h3> Amazon Firecracker </h3><br> Amazon Firecracker ‚Äî  ,     AWS Lambda  AWS Fargate.  ,   ¬´  ¬ª (MicroVM)   multi-tenant     .   Firecracker  Lambda  Fargate         EC2  ,    .            ,      ,                . Firecracker    ,   ,      .  Firecracker                ,   .       Linux     ext4      . Amazon   Firecracker  2017 ,   2018      . <br><br>   unikernel, Firecracker          .       micro-VM      ,        .  ,  micro-VM  Firecracker   5      ~125        2 CPU + 256  RAM.   5   Firecracker    . <br><br><img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br> <i> 5.  Firecracker         </i> <br><br> Firecracker   KVM,         .   Firecracker   seccomp, cgroups  namespaces,   ,  ,         .    Firecracker   . ,  API         microVM.        virtIO (  ). Firecracker        microVM: virtio-block, virtio-net, serial console  1-button  ,     microVM.               .   ,   ,   microVM  File Block Devices,       .       ,      cgroups.         ,           . <br><br>      Firecracker         Docker  Kubernetes. Firecracker      ,  ,          ,   .               .   ,     ,        OCI     . <br><br><h3> OpenStack Kata </h3><br>     ,  2015   Intel         Clear Containers. Clear Containers      Intel VT     QEMU-KVM <code>qemu-lite</code> .   2017   Clear Containers   Hyper RunV,     OCI,     Kata.    Clear Containers, Kata        . <br><br> Kata    OCI,    (CRI)    (CNI).       (, passthrough, MacVTap, bridge, tc mirroring)    ,        ,       .   6 ,      Kata     . <br><br><img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br> <i> 6.    Kata  Docker  Kubernetes</i> <br><br>   Kata     .       Kata     Kata Shim,    API   (, docker  kubectl)         VSock.  Kata   . NEMU ‚Äî    QEMU    ~80%   . VM-Templating     Kata VM         .          ,          ,  ,  CVE-2015-2877.   ¬´ ¬ª        (, , ,  virtio),      . <br><br>  Kata  Firecracker ‚Äî   ¬´¬ª    ,    .    ,   . Firecracker ‚Äî   ,        ,      Kata ‚Äî    ,      .      Kata  Firecracker.         ,        . <br><br><h3>  Conclusion </h3><br>    ,   ‚Äî        . <br><br> IBM Nabla ‚Äî     unikernel,       . <br><br> Google gVisor ‚Äî        ,         . <br><br> Amazon Firecracker ‚Äî   ,           . <br><br> OpenStack Kata ‚Äî        ,      . <br><br>  ,       ,         .             . Nabla   ,     ,   unikernel-,   MirageOS  IncludeOS. gVisor      Docker  Kubernetes,  -         . Firecracker         ,         .  Kata    OCI      KVM,     Xen.        . <br><br><img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br><br>  ,      ,   ,      ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457760/">https://habr.com/ru/post/fr457760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457750/index.html">Travailler avec JSON RPC dans Symfony 4</a></li>
<li><a href="../fr457752/index.html">Pas des rovers lunaires et pas des farceurs. Que savons-nous des robots √† Fukushima</a></li>
<li><a href="../fr457754/index.html">State et T-killers</a></li>
<li><a href="../fr457756/index.html">Le livre Kafka Streams en action. Applications et microservices en temps r√©el ¬ª</a></li>
<li><a href="../fr457758/index.html">Les ing√©nieurs sauvent les gens perdus dans la for√™t, mais la for√™t ne s'est pas encore rendue</a></li>
<li><a href="../fr457762/index.html">R√®gle CCD: avec quoi il est mang√©</a></li>
<li><a href="../fr457764/index.html">10 erreurs de PO jeune (partie II)</a></li>
<li><a href="../fr457766/index.html">Nous g√©n√©rons des niveaux de tuiles et cachons des carr√©s au joueur</a></li>
<li><a href="../fr457768/index.html">Comment je suis devenu vuln√©rable: analyser l'infrastructure informatique avec Qualys</a></li>
<li><a href="../fr457770/index.html">Nous √©crivons un transformateur personnalis√© AST sur TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>