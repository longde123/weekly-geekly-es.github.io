<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐰 👨🏿‍✈️ 🍕 介绍Sass模块 👩🏼‍🤝‍👨🏿 🔖 🧕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍了Miriam Suzanne的文章“介绍Sass模块” 。 

 最近，Sass中出现了一个您以其他语言熟悉的功能： 模块化系统 。 这是@import一大进步，@ @import是Sass中最常用的功能之一。 尽管现有的@import指令允许您连接第三方程序包并将样式分隔为受...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>介绍Sass模块</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471924/">哈Ha！ 我向您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍</a>了Miriam Suzanne的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“介绍Sass模块”</a> 。 <br><br> 最近，Sass中出现了一个您以其他语言熟悉的功能： <b>模块化系统</b> 。 这是<code>@import</code>一大进步，@ <code>@import</code>是Sass中最常用的功能之一。 尽管现有的<code>@import</code>指令允许您连接第三方程序包并将样式分隔为受支持的元素，但它仍然存在一些局限性 <a name="habracut"></a>  ： <br><br><ul><li>  <code>@import</code>也存在于CSS中，其行为上的任何差异都可能造成混淆。 </li><li> 如果对一个文件执行<code>@import</code>几次，这会减慢编译速度，导致重新定义冲突，并且您在输出中会得到重复的代码。 </li><li> 一切都在全球范围内，包括第三方软件包-这就是我的<code>color</code>功能可以覆盖现有<code>color</code>功能的方式，反之亦然。 </li><li> 当您使用诸如<code>color</code>之类的函数时，不可能确切知道它的定义位置。 哪个<code>@import</code>连接了它？ </li></ul><br>  Sass软件包的作者（像我一样）试图通过手动设置变量和函数的前缀来解决名称空间问题-但是Sass模块是一个更强大的解决方案。 简而言之， <code>@use</code> <code>@forward</code>被更明确的<code>@use</code>和<code>@forward</code> <code>@import</code>代替。 在接下来的几年中，Sass中的<code>@import</code>将被弃用，然后将其删除。 您仍然可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CSS Import</code>的</a> ，但是Sass不会编译它们。 但请放心，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个迁移工具</a>可以帮助您升级。 <br><br><h2> 使用<code>@use</code>导入文件 </h2><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br> 新的<code>@use</code>与<code>@import</code>相似，但是有一些明显的区别： <br><br><ul><li> 无论您在项目中使用<code>@use</code>多少次，文件都会被导入一次。 </li><li> 以下划线（ <code>_</code> ）或连字符（ <code>-</code> ）开头的变量，混入和函数（在Sass中被称为“成员”）被认为是私有的，不会被导入。 </li><li> 通过<code>@use</code> （在我们的示例中为<code>@use</code>连接的文件中的成员只能在本地访问，而不会传输到后续导入。 </li><li> 同样， <code>@extends</code>仅适用于上游； 也就是说，扩展名仅适用于导入的样式，不适用于导入的样式。 </li><li> 默认情况下，所有导入的成员都有自己的<i>名称空间</i> 。 </li></ul><br> 当我们通过<code>@use</code>附加文件时，Sass会根据文件名自动生成一个名称空间。 <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `buttons`*/</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `forms`*/</span></span></code> </pre><br> 现在，我们可以访问<code>buttons.scss</code>文件和<code>forms.scss</code>文件的成员，但是这种访问权限不会在导入之间转移： <code>forms.scss</code>仍然无法访问<code>buttons.scss</code>定义的变量。 由于导入的实体具有名称空间，因此我们必须使用新的点分隔语法来访问它们： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.$variable */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.function() */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-background</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.background</span></span>(); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.border</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/* : @include &lt;namespace&gt;.mixin() */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> buttons.submit(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input();</code> </pre><br> 我们可以通过将<code>as &lt;name&gt;</code>添加到导入中来更改或删除默认名称空间。 <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as *; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as <span class="hljs-string"><span class="hljs-string">'f'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* buttons.$color    */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* forms.$input-border    */</span></span></code> </pre><br> 使用<code>as *</code>将模块添加到根名称空间，因此不需要前缀，但是其成员仍受当前文档的本地限制。 <br><br><h2> 导入Sass嵌入式模块 </h2><br>  Sass的内部功能也已移至模块化系统，因此我们可以完全控制全局名称空间。 有几个内置模块<code>math</code> ， <code>color</code> ， <code>string</code> ， <code>list</code> ， <code>map</code> ， <code>selector</code>和<code>meta</code> ，在使用前必须将其显式导入文件中。 <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.percentage</span></span>(1/2);</code> </pre><br> 嵌入式模块也可以导入全局空间： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span> as *; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">percentage</span></span>(1/2);</code> </pre><br> 可以使用已经具有前缀名称的内置函数，例如<code>map-get</code>或<code>str-index</code> ，而无需复制此前缀： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:map'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:string'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">map-get</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">map</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get</span></span>(('<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>': '<span class="hljs-selector-tag"><span class="hljs-selector-tag">value</span></span>'), '<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>'); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">str-index</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.index</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span>', '<span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>');</code> </pre><br> 您可以在<a href="">Sass模块规范中</a>找到内置模块，功能和名称更改的完整列表。 <br><br><h2> 新增和更改的核心功能 </h2><br> 另外一个好处是，这意味着Sass可以安全地添加新的内部mixin和函数，而不会引起名称冲突。 最令人惊讶的示例是<code>sass:meta</code>模块中的<code>load-css</code> <code>sass:meta</code> 。 它的工作方式类似于<code>@use</code> ，但仅返回生成的CSS并在代码中的任何位置动态地工作： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:meta'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">theme-name</span></span>: '<span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>'; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-theme='#{$theme-name}']</span></span> { @include meta.load-css($theme-name); }</code> </pre><br> 第一个参数是模块URL（如<code>@use</code> ），但是可以使用变量（甚至使用插值）来动态更改它，例如<code>theme-#{$name}</code> 。 第二个（可选）参数采用具有以下配置的<code>map</code>结构： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*   $base-color  'theme/dark'   */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> meta.load-css( <span class="hljs-string"><span class="hljs-string">'theme/dark'</span></span>, $with: (<span class="hljs-string"><span class="hljs-string">'base-color'</span></span>: rebeccapurple) );</code> </pre><br>  <code>$with</code>参数允许您使用<code>map</code>结构配置已加载模块中的任何变量，并且该变量必须满足以下条件： <br><br><ul><li> 它不是以<code>_</code>或<code>-</code>开头的私有变量<code>-</code> </li><li> 标有<code>!default</code>默认指令 </li></ul><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* theme/_dark.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">base-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> $_<span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,      !default */</span></span></code> </pre><br> 注意，键<code>'base-color'</code>设置变量<code>$base-color</code> 。 <br><br>  <code>sass:meta</code>模块还有另外两个新功能<code>sass:meta</code> ： <code>module-variables()</code>和<code>module-functions()</code> 。 它们每个都从已经导入的模块的名称和值返回<code>map</code>结构。 它们采用与模块名称空间相对应的一个参数： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-vars</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-variables</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( button-color: blue, input-border: thin, ) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-functions</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-functions</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( background: get-function('background'), border: get-function('border'), ) */</span></span></code> </pre><br>  <code>sass:meta</code>其他几个函数<code>sass:meta</code> - <code>global-variable-exists()</code> ， <code>function-exists()</code> ， <code>mixin-exists()</code>和<code>get-function()</code> -将接收其他<code>$module</code>参数，这些参数允许我们显式检查每个命名空间。 <br><br><h3> 调整和缩放颜色 </h3><br>  <code>sass:color</code>模块对于解决我们的一些旧问题也有一些有趣的保留。 不再推荐使用许多传统函数，例如<code>color.adjust()</code>或<code>color.scale()</code> <code>adjust-hue()</code>支持显式函数<code>color.adjust()</code>和<code>color.scale()</code> ： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  lighten(red, 20%) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%); <span class="hljs-comment"><span class="hljs-comment">/*  adjust-hue(red, 180deg) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">complement</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">hue</span></span>: 180<span class="hljs-selector-tag"><span class="hljs-selector-tag">deg</span></span>);</code> </pre><br><br> 其中一些不推荐使用的功能（例如<code>adjust-hue</code> ）是多余且不必要的。 其他-如<code>lighten</code> ， <code>darken</code> ， <code>saturate</code>等。  -需要重新实现以改善内部逻辑。 原始函数基于<code>adjust()</code> ，它使用了线性数学运算：在上面的示例中，当前<code>red</code>亮度增加了<code>20%</code> 。 在大多数情况下，我们希望相对于当前值以一定百分比更改（ <code>scale()</code> ）颜色： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*        20,   0.2,     */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scale</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%);</code> </pre><br> 在完全弃用并删除这些函数之后，这些函数最终将重新出现在<code>sass:color</code>具有基于<code>color.scale()</code>而不是<code>color.adjust()</code>的新行为。 这将逐渐发生，以避免突然的向后兼容性问题。 同时，我建议手动检查您的代码以查看<code>color.scale()</code>在哪里更有用。 <br><br><h2> 配置导入的库 </h2><br> 第三方库或可重用库通常带有一些您可以覆盖的默认值的变量。 我们在导入之前使用变量来完成此操作： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _buttons.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">blue</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* old.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br> 由于使用模块时不再能访问局部变量，因此我们需要一种新的方式来设置值。 我们可以通过将设置通过<code>map</code>传递给<code>@use</code>来<code>@use</code> ： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> with ( $color: red, $style: <span class="hljs-string"><span class="hljs-string">'flat'</span></span>, );</code> </pre><br> 这类似于<code>load-css()</code>的<code>$with</code>参数，但不是将变量名用作键，而是将变量本身与<code>$</code>符号一起使用。 <br><br> 我喜欢设置的显式性，但是有一条规则使我感到困惑： <b>第一次使用模块只能配置一次</b> 。 即使使用<code>@import</code> ，连接顺序对于Sass来说也一直很重要，但是这些问题并未引起注意。 现在我们得到一个明显的错误，这既好又有点意外。 确保通过<code>@use</code>连接库，并在文件输入点（导入所有其他文件的中央文档）中配置它们，以便在通过<code>@use</code>连接其他库之前先编译这些设置。 <br><br> 目前（目前）无法将配置“绑定”在一起，使其可编辑，但是您可以包装已配置的模块并将其作为新模块进行传输。 <br><br><h2> 使用<code>@forward</code>传输文件 </h2><br> 我们并不总是需要使用文件并引用其成员。 有时我们只想将其传递给后续导入。 假设我们有几个与表单关联的文件，我们想将它们作为一个命名空间连接在一起。 我们可以使用<code>@forward</code>做到这<code>@forward</code> ： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'textarea'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'select'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br> 这些转发文件的成员在当前文档中不可用，也没有创建名称空间，但是当另一个文件通过<code>@use</code>连接它们或通过<code>@use</code>整个集合时，这些变量，函数和mixins将可用。 如果提交的单个文件包含实际的CSS，则在不使用包本身的情况下，也将直接传输它而不生成它。 在此阶段，所有这些都将被视为具有一个名称空间的一个模块： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* styles.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        `forms` */</span></span></code> </pre><br>  <b>注意</b> ：如果您要求Sass附加文件夹，它将在其中查找<code>index</code>或<code>_index</code>文件。 <br><br> 默认情况下，所有公共成员将与模块一起转发。 但是，通过使用<code>show</code>和<code>hide</code>条件并指定要添加或排除的特定成员，我们可以更具选择性。 <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*    `border()`   `$border-color`   `input` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> show border, $border-color; <span class="hljs-comment"><span class="hljs-comment">/*     `buttons`    `gradient()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> hide gradient;</code> </pre><br>  <b>注意</b> ：当函数和混合模块具有通用名称时，它们会一起添加和隐藏。 <br><br> 为了澄清来源或避免转发模块名称的冲突，我们可以使用<code>as</code>连接文件的成员添加前缀： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* @forward "&lt;url&gt;" as &lt;prefix&gt;-*; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,      `background()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> as input-*; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as btn-*; <span class="hljs-comment"><span class="hljs-comment">/* style.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input-background(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.btn-background();</code> </pre><br> 而且，如果需要，我们总是可以通过<code>@use</code>使用，并通过<code>@use</code> <code>@forward</code>相同的模块，添加两个规则： <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br> 如果要预配置库或添加其他工具，然后再将其传输到其他文件，此功能特别有用。 这可以帮助简化连接路径： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _tools.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span> with ( $font-path: <span class="hljs-string"><span class="hljs-string">'../fonts/'</span></span>, ); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* -  ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* _anywhere-else.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>;</code> </pre><br>  <code>@use</code>和<code>@forward</code>必须在文档的根目录（未嵌套）和文件的开头声明。 在导入指令之前，只能出现<code>@charset</code>和简单变量定义。 <br><br><h2> 过渡到模块化系统 </h2><br> 为了测试新的语法，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为我的小组</a>创建了一个新的开源Sass库（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cascading Color Systems</a> ）和一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新站点</a> -两者仍在开发中。 我需要从库作者和站点开发人员的角度来理解模块。 让我们从使用模块语法编写站点样式的“最终用户”的经验开始... <br><br><h3> 支持和写作风格 </h3><br> 使用站点上的模块非常有趣。 新语法支持我已经使用的代码体系结构。 我所有的全局设置和工具导入都在同一目录（我称为<code>config</code> ）中，该目录带有一个索引文件，该文件传输了我需要的所有内容： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* config/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'fonts'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'scale'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'colors'</span></span>;</code> </pre><br> 通过开发站点的其他部分，我可以在需要的地方导入这些工具和配置： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* layout/_banner.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'../config'</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.page-title</span></span> { @include config.font-family('header'); }</code> </pre><br> 它甚至可以与我现有的库一起使用，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Accoutrement</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Herman</a> ，它们仍然使用旧的<code>@import</code>语法。 由于<code>@import</code>规则不会一次到处替换，因此Sass开发人员已经花了一些时间进行过渡。 这些模块现在可用，但是<code>@import</code>不会再过一两年<code>@import</code> -只会在一年后从该语言中删除。 同时，两个系统将以任何方式协同工作： <br><br><ul><li> 如果我们对包含新的<code>@use/@forward</code>语法的文件执行<code>@import</code> ，则仅导入公共成员而没有名称空间。 </li><li> 如果我们对包含旧<code>@import</code>语法的文件执行<code>@use</code>或<code>@forward</code> ，则可以作为单个名称空间访问所有嵌套的导入。 </li></ul><br> 这意味着您可以立即开始使用新的模块语法，而不必等待发布您喜欢的库的新版本：而且我可以花一些时间来更新我的所有库！ <br><br><h3> 迁移工具 </h3><br> 如果使用Jennifer Thakar创建的迁移工具，升级将不会花费很长时间。 可以使用NPM，Chocolatey或Homebrew安装： <br><br><pre> <code class="bash hljs">npm install -g sass-migrator choco install sass-migrator brew install sass/sass/migrator</code> </pre><br> 这不是用于迁移到模块的一次性工具。 现在，Sass恢复了活跃的开发（请参阅下文），迁移工具还将获得定期的更新，以帮助移植每个新功能。 最好在全局安装此工具，并保存以备将来使用。 <br><br> 迁移器可以从命令行启动，希望将其添加到CodeKit和Scout等第三方应用程序中。 将他指向单个Sass文件，例如<code>style.scss</code>并告诉他要应用哪些迁移。 目前，只有一个迁移称为<code>module</code> ： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sass-migrator &lt;migration&gt; &lt;entrypoint.scss...&gt; sass-migrator module style.scss</span></span></code> </pre><br> 默认情况下，迁移器仅更新一个文件，但是在大多数情况下，我们希望更新主文件及其所有依赖项：通过<code>@forward</code> <code>@use</code> ， <code>@forward</code>或<code>@use</code>连接的任何元素。 我们可以通过单独指定每个文件或简单地添加<code>--migrate-deps</code>标志来实现。 <br><br><pre> <code class="bash hljs">sass-migrator --migrate-deps module style.scss</code> </pre><br> 对于测试运行，我们可以添加<code>--dry-run --verbose</code> （或缩写为<code>-nv</code> ）并查看结果，而无需更改源文件。 我们可以使用许多其他选项来配置迁移-甚至还有一个专门用于帮助库作者删除旧的手动创建的名称空间的选项-但在此我将不对其进行描述。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移工具已</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Sass网站</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完整记录</a> 。 <br><br><h3> 更新已发布的图书馆 </h3><br> 我在库方面遇到了几个问题，特别是当我试图使用户配置可用于多个文件并找到解决方案以解决缺少“链”配置时。 与订单相关的错误可能很难调试，但是值得付出努力，而且我认为我们很快会看到一些其他修复程序。 我仍然需要对复杂软件包的迁移工具进行试验，也许还要为图书馆作者写一篇额外的文章。 <br><br> 现在要知道的重要一点是，Sass在过渡期间为我们提供了保护。 旧的导入和模块不仅可以一起使用，我们还可以创建“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仅导入</a> ”文件，为仍通过<code>@import</code>连接我们的库的用户提供更便捷的工作。 在大多数情况下，这将是主软件包文件的替代版本，并且您希望它们位于附近：对于模块用户，为<code>&lt;name&gt;.import.scss</code>对于旧用户，为<code>&lt;name&gt;.import.scss</code> 。 每次用户调用<code>@import &lt;name&gt;</code> ，他都会加载文件的<code>.import</code> ： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  `_forms.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  `_forms.import.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br><br> 这对于为不使用模块的开发人员添加前缀特别有用： <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _forms.import.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as forms-*;</code> </pre><br><br><h2>  Sass更新 </h2><br> 您可能还记得，几年前Sass冻结了新功能的添加，因此其各种实现（LibSass，Node Sass，Dart Sass）赶上了原始的Ruby实现，从而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完全放弃了它</a> 。 冻结在去年以GitHub上的几个新功能以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">活跃的讨论和开发</a>而结束-但不是那么庄重。 如果您错过了这些发行版，则可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sass博客</a> ： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS导入和CSS兼容性</a> （Dart Sass v1.11） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容指令参数和颜色函数（Dart Sass v1.15）</a> </li></ul><br> 当前，Dart Sass是一种规范的实现，通常是第一个引入新功能的实现。 如果您想接收所有最新消息，我建议您切换到它。 您可以使用NPM，Chocolatey或Homebrew <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装Dart Sass</a> 。 它也适用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gulp-sass</a> 。 <br><br> 像CSS（从CSS3开始）一样，新版本不再有单个版本号。 所有Sass实现都使用相同的规范，但是每个实现都有唯一的发布时间表和编号，这在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jina</a>设计<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的精美新文档</a>中的支持信息中得到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>体现。 <br><br><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1400,f_auto,q_auto/v1570122240/sass-modules-01_gapdpb.png" alt="图片"><br><br>  Sass模块<b>将于2019年10月1日</b>在<b>Dart Sass 1.23.0中可用</b> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471924/">https://habr.com/ru/post/zh-CN471924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471906/index.html">优化不当的危险</a></li>
<li><a href="../zh-CN471908/index.html">素数的意外之美</a></li>
<li><a href="../zh-CN471912/index.html">学习英语：扩大词汇量的7种实用方法</a></li>
<li><a href="../zh-CN471914/index.html">Sega Mega Drive图形系统如何工作：视频显示处理器</a></li>
<li><a href="../zh-CN471918/index.html">SwiftUI：熟人</a></li>
<li><a href="../zh-CN471928/index.html">自动还原Mikrotik路由器中最后保存的配置</a></li>
<li><a href="../zh-CN471930/index.html">原子设计mitap-字母，颜色，制服，团队和金钱</a></li>
<li><a href="../zh-CN471938/index.html">布局说明：2019年有用的Google Chrome扩展程序</a></li>
<li><a href="../zh-CN471940/index.html">如何减少延期结算中的违约风险：业务因素</a></li>
<li><a href="../zh-CN471942/index.html">根据您的要求：金士顿DC500R和DC500M SSD的专业测试</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>