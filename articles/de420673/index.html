<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚀 📔 🤘🏽 Docker für Symfony 4 - vom LAN bis zur Produktion 🖐🏽 🧑🏿‍🤝‍🧑🏼 👨🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorgeschichte 
 Eines schönen Tages musste ich eine Entwicklungsumgebung für mein Projekt bereitstellen. Vagrant hatte es bereits satt und wollte eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker für Symfony 4 - vom LAN bis zur Produktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420673/"><h2>  Vorgeschichte </h2><br>  Eines schönen Tages musste ich eine Entwicklungsumgebung für mein Projekt bereitstellen.  Vagrant hatte es bereits satt und wollte eine einzige Entwicklungsumgebung für alle Projektteilnehmer, die mit dem Produktionsserver identisch ist.  Nachdem ich mir Informationen über den Hipster-Docker angehört hatte, beschloss ich, mich damit zu befassen.  Als Nächstes werde ich versuchen, alle Schritte von der Installation eines Dockers in einem LAN bis zur Bereitstellung eines Produkts für KVM so detailliert wie möglich zu beschreiben. <br><br>  <b>Ursprünglicher Technologie-Stapel:</b> <br><br>  - Hafenarbeiter <br>  - Symfonie 4 <br>  - Nginx <br>  - php-fpm <br>  - postgresql <br>  - Elasticsearch <br>  - rabbitmq <br>  - Jenkins <br><br>  <b>Eisen:</b> <br><br>  - Laptop unter OS Ubuntu 16.04 <br>  - Produktionsserver auf KVM-Hosting <br><br>  <i>Warum habe ich neben dem technologischen Stapel auch den Eisenstapel aufgelistet?</i> <br><br>  Wenn Sie noch nie mit einem Docker gearbeitet haben, kann es zu einer Reihe von Problemen kommen, die speziell mit der Hardware, dem Betriebssystem Ihres Laptops oder der Art der Hosting-Virtualisierung zusammenhängen. <br><br>  Der erste und wahrscheinlich wichtigste Aspekt bei der Arbeit mit dem Docker ist das Betriebssystem Ihres Laptops.  Der einfachste Weg, mit Docker zu arbeiten, ist auf Linux-Systemen.  Wenn Sie unter Windows oder Mac arbeiten, haben Sie zu 100% einige Schwierigkeiten, aber diese Schwierigkeiten sind nicht kritisch. Wenn Sie "googeln" möchten, wie dies behoben wird, treten keine Probleme auf. <br><br>  Die zweite Frage ist Hosting.  Warum wird Hosting mit KVM-Virtualisierungstyp benötigt?  Der Grund dafür ist, dass sich die VPS-Virtualisierung stark von KVM unterscheidet und Sie Docker einfach nicht auf VPS installieren können, da VPS Serverressourcen dynamisch zuweist. <br><br>  Zwischensumme: Für den schnellsten Start auf dem Docker ist es am sinnvollsten, Ubuntu als lokales Betriebssystem und KVM-Hosting (oder als eigenen Server) zu wählen.  Darüber hinaus wird sich die Geschichte genau auf diese beiden Komponenten stützen. <br><a name="habracut"></a><br><h2>  Docker-Compose für LAN </h2><br><h3>  Installation </h3><br>  Zuerst müssen Sie das Docker selbst lokal installieren.  Sie können die Installationsanweisungen auf der offiziellen Website sehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die auf die offizielle Dokumentation für Ubuntu verweist</a> (Sie müssen Docker und Docker-Compose installieren) oder indem Sie den Befehl in der Konsole ausführen: <br><br><pre><code class="bash hljs">curl -sSl https://get.docker.com/ | sh</code> </pre> <br>  Dieser Befehl installiert sowohl Docker als auch Docker-Compose.  Überprüfen Sie danach die Docker-Version mit dem folgenden Befehl: <br><br><pre> <code class="bash hljs">docker --version</code> </pre> <br>  Ich beginne diese ganze Sache mit Docker Version 18.06.0-ce. <br><br>  Die Installation ist abgeschlossen! <br><br><h3>  Bewusstsein </h3><br>  Um mit etwas weniger erfolgreich arbeiten zu können, müssen Sie eine Vorstellung davon haben, wie es funktioniert.  Wenn Sie zuvor nur mit Vagrant oder ähnlichem gearbeitet haben, ist dies zunächst äußerst ungewöhnlich und unverständlich, dies ist jedoch zunächst nur der Fall. <br><br>  Ich werde versuchen, eine Analogie für Vagrant zu ziehen.  Jetzt können viele sagen, dass der Vergleich von Vagrant und Docker grundsätzlich falsch ist.  Ja, ich stimme dem zu, aber ich werde sie nicht vergleichen. Ich werde nur versuchen, den Neuankömmlingen, die nur mit Vagrant gearbeitet haben, das Docker-Arbeitssystem zu vermitteln, um das anzusprechen, was die Neuankömmlinge wissen. <br><br>  Meine Vision des Containers „an den Fingern“ lautet wie folgt: Jeder Container ist eine winzige isolierte Welt.  Jeder Container kann sich so vorstellen, als wäre es ein winziger Vagrant, auf dem nur 1 Tool installiert ist, zum Beispiel Nginx oder PHP.  Anfangs sind Container im Allgemeinen von allem isoliert, aber durch knifflige Manipulationen können Sie alles so konfigurieren, dass sie miteinander kommunizieren und zusammenarbeiten.  Dies bedeutet nicht, dass jeder der Container eine separate virtuelle Maschine ist, überhaupt nicht.  Aber es ist einfacher für das anfängliche Verständnis, wie es mir scheint. <br><br>  Vagrant beißt einfach einen Teil der Ressourcen Ihres Computers ab, erstellt eine virtuelle Maschine, installiert ein Betriebssystem darauf, installiert Bibliotheken und installiert alles, was Sie nach dem Vagrant-Up in das Skript geschrieben haben.  Letztendlich sieht es ungefähr so ​​aus: <br><br>  → <a href="">Schaltplan anzeigen</a> <br><br>  Docker wiederum arbeitet radikal anders.  Es werden keine virtuellen Maschinen erstellt.  Docker erstellt Container (im Moment können Sie sie sich als mikro-virtuelle Maschinen vorstellen) mit seinem alpinen Betriebssystem und 1-3 Bibliotheken, die für das Funktionieren der Anwendung erforderlich sind, z. B. PHP oder Nginx.  Gleichzeitig blockiert Docker die Ressourcen Ihres Systems nicht für sich selbst, sondern verwendet sie einfach nach Bedarf.  Letztendlich wird es zur Veranschaulichung ungefähr so ​​aussehen: <br><br>  → <a href="">Schaltplan anzeigen</a> <br><br>  Jeder der Container verfügt über ein Image, aus dem er erstellt wird.  Die überwiegende Mehrheit der Images ist eine Erweiterung eines anderen Images, z. B. Ubuntu xenial oder Alpine oder Debian, auf dem zusätzliche Treiber und andere Komponenten bereitgestellt werden. <br><br>  Mein erstes Bild war für PHP-Fpm.  Mein Bild erweitert das offizielle PHP-Bild: 7.2-fpm-alpine3.6.  Das heißt, es nimmt im Wesentlichen das offizielle Image und liefert die Komponenten, die ich benötige, z. B. pdo_pgsql, imagick, zip und so weiter.  So können Sie das Bild erstellen, das Sie benötigen.  Wenn Sie möchten, können Sie es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier verwenden</a> . <br><br>  Bei der Erstellung von Bildern ist meiner Meinung nach alles recht einfach, wenn sie beispielsweise auf der Basis von Xenial hergestellt werden, aber sie liefern ein wenig Hämorrhoiden, wenn sie auf der Grundlage von Alpine hergestellt werden.  Bevor ich mit dem Docker anfing, hörte ich im Grunde nichts von Alpine, da Vagrant immer unter Ubuntu Xenial für mich arbeitete.  Alpine ist ein leeres Linux-Betriebssystem, in dem es im Wesentlichen gar nichts gibt (extremes Minimum).  Daher ist es zunächst äußerst unpraktisch, damit zu arbeiten, da es zum Beispiel nicht die gleiche apt-get-Installation gibt (an die Sie sich gewöhnt haben), sondern nur apk add und eine nicht ganz vernünftige Reihe von Paketen.  Ein großes Plus von Alpine ist sein Gewicht. Wenn Xenial beispielsweise (abstrakt) 500 Säcke wiegt, beträgt Alpine (abstrakt) etwa 78 Säcke.  Was betrifft das überhaupt?  Dies wirkt sich auf die Erstellungsgeschwindigkeit und das Endgewicht aller Bilder aus, die am Ende auf Ihrem Server gespeichert werden.  Nehmen wir an, Sie haben 5 verschiedene Container und alles, was auf Xenial basiert, hat ein Gesamtgewicht von mehr als 2,5 Gigs und alpine - nur etwa 500 Taschen.  Daher sollten wir uns im Idealfall bemühen, dass die Behälter so dünn wie möglich sind.  (Nützlicher Link zum Installieren von Paketen in Alpine - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpine-Paketen</a> ). <br><br>  Überall auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-Hub</a> schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie</a> , wie der Container mit dem <code>docker run</code> gestartet wird, und aus irgendeinem Grund schreiben sie nicht, wie er über Docker-Compose gestartet werden kann, und über Docker-Compose wird er die meiste Zeit gestartet, da nur sehr wenig gejagt wird Starten Sie alle Container, Netze, offenen Ports und mehr manuell.  Docker-Compose im Auftrag des Benutzers sieht aus wie eine Yaml-Datei mit Einstellungen.  Es enthält eine Beschreibung aller Dienste, die gestartet werden müssen.  Mein Build für die lokale Umgebung lautet wie folgt: <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> volumes: - ../:/app working_dir: /app container_name: <span class="hljs-string"><span class="hljs-string">'php-fpm'</span></span> nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'7777:80'</span></span> volumes: - ../:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'postgresql'</span></span> working_dir: /app restart: always environment: POSTGRES_DB: <span class="hljs-string"><span class="hljs-string">'db_name'</span></span> POSTGRES_USER: <span class="hljs-string"><span class="hljs-string">'db_user'</span></span> POSTGRES_PASSWORD: <span class="hljs-string"><span class="hljs-string">'db_pass'</span></span> volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> working_dir: /app hostname: rabbit<span class="hljs-literal"><span class="hljs-literal">-mq</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'rabbit-mq'</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> environment: RABBITMQ_DEFAULT_USER: user RABBITMQ_DEFAULT_PASS: password RABBITMQ_DEFAULT_VHOST: my_vhost elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'elastic-search'</span></span> environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - <span class="hljs-string"><span class="hljs-string">"discovery.zen.ping.unicast.hosts=elasticsearch"</span></span> - bootstrap.memory_lock=true - <span class="hljs-string"><span class="hljs-string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - ../:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> volumes: elasticsearch: postgresql:</code> </pre><br>  docker-compose.yaml für SF4 ist eine bestimmte Reihe von Diensten: nginx, php-fpm, postgresql, rabbitmq (falls erforderlich), elasticsearch (falls erforderlich).  Für die lokale Umgebung ist dies ausreichend.  Damit alles funktioniert, gibt es nur minimale Einstellungen, ohne die nichts funktioniert.  Am häufigsten sind dies Image, Volumes, Ports, Umgebung, Arbeitsverzeichnis und Containername.  Alles zum Starten dieses oder jenes Images ist in der Dokumentation auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hub.docker.com beschrieben</a> .  Es gibt nicht immer eine Beschreibung für Docker-Compose, aber dies bedeutet nicht, dass es nicht damit funktioniert.  Es ist nur notwendig, alle eingehenden Daten vom Docker-Ausführungsbefehl an Docker-Compose zu übertragen, und alles wird funktionieren. <br><br>  Zum Beispiel gibt es hier ein Bild für RabbitMQ.  Wenn Sie DIESES zum ersten Mal sehen, verursacht es gemischte Gefühle und Emotionen, aber nicht alles ist so beängstigend.  Tags sind in diesem Bild angegeben.  Normalerweise Tags - repräsentieren verschiedene Bilder, verschiedene Versionen der Anwendung mit verschiedenen erweiterbaren Bildern.  Zum Beispiel bedeutet das Tag 3.7.7-alpine, dass dieses Bild dünner ist als zum Beispiel 3.7.7, da es auf Alpine basiert.  Nun und auch in den Tags werden meistens die Versionen der Anwendung angegeben.  Normalerweise wähle ich die neueste Version und die stabile Version der Anwendung selbst und das Alpenbild. <br><br>  Nachdem Sie ein Tag studiert und ausgewählt haben, sehen Sie häufig etwas in dieser Art: <br><br><pre> <code class="bash hljs">docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</code> </pre> <br>  Und der erste Gedanke ist WTF?  Wie übertrage ich das auf Docker-Compose? <br><br>  Alles ist ziemlich einfach.  Tatsächlich zeigt diese Zeile dieselben Parameter wie in der yaml-Datei an, nur abgekürzt.  Zum Beispiel ist -e eine Umgebung, in die verschiedene Parameter übergeben werden. Es kann auch Einträge wie -p geben. Dies sind Ports, die in yaml als Ports bezeichnet werden.  Dementsprechend müssen Sie nur die Abkürzungen für die Docker-Ausführung "googeln" und die vollständigen Namen in der Yaml-Datei anwenden, um ein unbekanntes Bild in einer qualitativ hochwertigen Weise zu verwenden. <br><br>  Nun zurück zu docker-compose.yml, das ich oben als Beispiel zitiert habe. <br><br>  In diesem Beispiel wird mein php7.2-Image als Erweiterung für das offizielle php7.2-fpm-alpine-Image verwendet. Wenn Sie jedoch nicht so viele zusätzliche Bibliotheken benötigen, können Sie Ihre Erweiterung für das offizielle Image erstellen und verwenden.  Die restlichen Bilder für LAN sind vollständig original und offiziell. <br><br>  <b>Bild</b> - Geben Sie an, welches Bild heruntergeladen werden soll.  Zum Beispiel (rabbitmq: 3.7.7-management-alpine). <br><br>  <b>Ports</b> - Geben Sie die Ports an, die der Container verwenden soll (siehe Bilddokumentation).  Beispiel nginx Port ist standardmäßig 80.  Wenn Sie Port 80 verwenden möchten, müssen Sie hier 80:80 angeben, und Ihre Site ist auf localhost verfügbar.  Oder Sie können 7777: 80 angeben, und dann befindet sich Ihre Site unter der URL localhost: 7777.  Dies ist erforderlich, damit mehrere Projekte auf demselben Host bereitgestellt werden können. <br><br>  <b>Volumes</b> - Freigegebene Verzeichnisse werden hier angezeigt.  Ihr Projekt befindet sich beispielsweise im Verzeichnis ~ / projects / my-sf4-app, und der PHP-Container ist so konfiguriert, dass er mit dem Verzeichnis / app zusammenarbeitet (wie in / var / www / my-sf4-app).  Dementsprechend wäre es für den Container bequem, Zugang zum Projekt zu haben.  Dementsprechend schreiben wir in Bänden <code>~/projects/my-sf4-app:/app</code> (siehe dieses Beispiel in docker-compose.yml oben (ich habe es relativ angegeben ../:/app)). <br><br>  Auf diese Weise wird der Ordner für den Container freigegeben und kann verschiedene Aktionen ausführen, z. B. <code>php bin/console doctrine:migrations:migrate</code> .  Es ist auch bequem, diese Verzeichnisse zu verwenden, um Anwendungsdaten zu speichern.  In postgresql können Sie beispielsweise ein Verzeichnis zum Speichern von Datenbankdaten angeben. Wenn Sie den Container neu erstellen, müssen Sie weder einen Speicherauszug noch Fixtures rollen. <br><br>  <b>Arbeitsverzeichnis</b> - <b>Gibt</b> das Arbeitsverzeichnis des Containers an.  In diesem Fall / app (oder analog zum Vagabund / var / www / my-sf4-app). <br><br>  <b>Umgebung</b> - Hier werden alle Variablen für den Container übergeben.  Beispielsweise werden für rabbitmq der Benutzername und das Passwort übertragen, für postgresql werden der Basisname, der Benutzername und das Passwort übergeben. <br><br>  <b>container_name</b> ist ein optionales Feld, das ich jedoch lieber angeben möchte, um die Verbindung zu Containern zu vereinfachen.  Wenn nicht angegeben, werden Standardnamen mit Hashes zugewiesen. <br><br>  Dies sind die Hauptparameter, die angegeben werden müssen.  Der Rest kann optional für zusätzliche Einstellungen oder gemäß der Dokumentation für den Container sein. <br><br>  Um dies alles zu starten, müssen Sie den <code>docker-compose up -d</code> in dem Verzeichnis ausführen <code>docker-compose up -d</code> in dem sich die Docker-compose-Datei befindet. <br><br><h3>  Wie und wo soll das alles für LAN gespeichert werden? </h3><br>  Für LAN verwende ich den Docker-Ordner im Stammverzeichnis des Projekts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/rg/a8/pvrga87xk7vcujz2-qwbjnqmtjk.png"></div><br>  Es enthält den Datenordner, in dem ich alle Informationen postgresql und elasticsearch speichere, sodass Sie beim Neuerstellen des Projekts keine Fixtures von Grund auf neu rollen müssen.  Es gibt auch einen Nginx-Daddy, in dem ich die Konfiguration für den lokalen Nginx-Container speichere.  Ich synchronisiere diese Ordner in docker-compose.yml mit den entsprechenden Dateien und Ordnern in den Containern.  Auch meiner Meinung nach ist es sehr praktisch, Bash-Skripte für die Arbeit mit Docker zu schreiben.  Das Skript start.sh startet beispielsweise Container, installiert Composer, bereinigt den Cache und migriert.  Es ist auch praktisch für Projektkollegen, sie müssen nichts tun, sie führen nur das Skript aus und alles funktioniert. <br><br>  Beispiel für ein Start.sh-Skript <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash green=$(tput setf 2) toend=$(tput hpa $(tput cols))$(tput cub 6) echo -n '   ?: ' read name echo "  $name!       tutmesto.ru" echo -n "$name,      ? (y/n): " read use_dump echo '    !' docker-compose up -d || exit echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    .' ./composer-install.sh echo -en '\n' echo -n "   ${green}${toend}[OK]" echo -en '\n' echo '     40 ,    postgres-' sleep 5 echo '  35 ...' sleep 5 echo '  30 ...' sleep 5 echo '  25 ...' sleep 5 echo '  20 ...' sleep 5 echo '  15 ...' sleep 5 echo '  10 ...' sleep 5 echo '  5 ...' sleep 5 echo ' .   postgres-        !' case "$use_dump" in y|Y) ./dump.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' ;; *) echo "$name, ,   ! =)" ;; esac echo '    !' ./migrations-migrate.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '  !' ./php-fpm-command.sh rm -rf var/cache/* ./php-fpm-command.sh chmod 777 var/ -R ./cache-clear.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    !' ./env.sh echo -en '\n' echo -n "   ! ${green}${toend}[OK]" echo -en '\n' echo ", $name,    !    localhost:7777  !" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo "    :" echo "./cache-clear.sh |  symfony 4" echo "./composer.sh [command(ex. install)] |  " echo "./composer-install.sh | composer install" echo "./connect-to-php-fpm.sh |   php" echo "./console.sh [command(ex. cache:clear)] |  php bin/console" echo "./destroy.sh |  .    ." echo "./dump.sh | ,     (dump.sql)" echo "./env.sh |   " echo "./migrations-migrate.sh | " echo "./php-fpm-command.sh [command(ex. php -m)] |   php-fpm " echo "./start.sh |  ( )" echo "./stop.sh |Gracefull shutdown " echo -en '\n' echo "        :" echo "client@c.cc | QWEasd123" echo "admin@a.aa | QWEasd123" echo "moderator@m.mm | QWEasd123" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo -en '\n' echo 'OtezVikentiy brain corporation!' echo -en '\n' echo -en '\n'</span></span></code> </pre><br>  <i>Beispiel für ein</i> Skript in <i>Php-fpm-command.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash cd "`dirname \"$0\"`" &amp;&amp; \ docker-compose exec -T "php-fpm" sh -c "cd /app &amp;&amp; $*"</span></span></code> </pre><br>  <i>Beispiel für das</i> Skript <i>Connect-to-php-fpm.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env bash docker exec -i -t --privileged php-fpm bash</span></span></code> </pre><br>  Hier endet die lokale Entwicklungsumgebung.  Herzlichen Glückwunsch, Sie können das fertige Ergebnis mit Ihren Kollegen teilen!  ) <br><br><h2>  Produktiv </h2><br><h3>  Vorbereitung </h3><br>  Angenommen, Sie haben bereits etwas in ein LAN geschrieben und möchten es auf einem Produktionsserver oder einem Testserver ablegen.  Sie haben Hosting auf KVM-Virtualisierung oder Ihren Server im nächsten Raum mit Klimaanlage. <br><br>  Um ein Produkt oder eine Betaversion bereitzustellen, muss auf dem Server ein Betriebssystem (idealerweise Linux) und ein Docker installiert sein.  Docker kann auf die gleiche Weise wie im LAN installiert werden, es gibt keine Unterschiede. <br><br>  Die Produktivität von Docker unterscheidet sich geringfügig von LAN.  Erstens können Sie nicht nur Passwörter und andere Informationen verwenden und Docker erstellen.  Zweitens können Sie Docker-Compose nicht direkt verwenden. <br><br>  Docker verwendet Docker-Schwarm und Docker-Stack für die Produktivität.  Wenn es direkt an den Fingern liegt, unterscheidet sich dieses System nur in anderen Befehlen und in diesem Docker-Schwarm ist es ein Load Balancer für den Cluster (wieder ein bisschen abstrakt, aber es wird leichter zu verstehen sein). <br><br>  PS: Ich rate Ihnen, das Einrichten eines Docker-Schwarms auf Vagrant zu üben (egal wie paradox dies klingen mag).  Ein einfaches Rezept für das Training: Nehmen Sie einen leeren Vagrant mit demselben Betriebssystem wie im Produkt und konfigurieren Sie ihn zum Starten. <br><br>  Um den Docker-Schwarm zu konfigurieren, müssen Sie nur einige Befehle ausführen: <br><br><pre> <code class="bash hljs">docker swarm init --advertise-addr 192.168.***.** (ip-  ) mkdir /app (          app) chown docker /app (     ) docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</code> </pre><br>  Lassen Sie uns dies alles etwas genauer betrachten. <br><br>  <b>Docker-Schwarm init --advertise-addr</b> - <b>Startet</b> Docker-Schwarm selbst direkt und fummelt an einem Link <b>herum,</b> sodass Sie einen anderen Server an diesen "Schwarm" anschließen können, damit er im Cluster funktioniert. <br>  <b>mkdir / app &amp;&amp; chown ..</b> - Sie müssen alle erforderlichen Verzeichnisse erstellen, damit der Docker im Voraus arbeiten kann, damit er sich während des <b>Builds</b> nicht über das Fehlen von Verzeichnissen beschwert. <br>  <b>Docker Stack Deploy -c Docker-Compose.yml My-First-SF4-Docker-App</b> - Dieser Befehl startet die Assemblierung Ihrer Anwendung selbst, ein Analogon von Docker-Compose Up -d nur für Docker-Schwarm. <br><br>  Um eine Assembly zu starten, benötigen Sie dieselbe docker-compose.yaml, die jedoch speziell für Productive / Beta bereits geringfügig geändert wurde. <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres - rabbitmq volumes: - /app:/app working_dir: /app deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'80:80'</span></span> depends_on: - php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span> volumes: - /app:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> working_dir: /app networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> secrets: - postgres_db - postgres_user - postgres_pass environment: POSTGRES_DB_FILE: /run/secrets/postgres_db POSTGRES_USER_FILE: /run/secrets/postgres_user POSTGRES_PASSWORD_FILE: /run/secrets/postgres_pass volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app hostname: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-sf4</span></span><span class="hljs-literal"><span class="hljs-literal">-app</span></span><span class="hljs-literal"><span class="hljs-literal">-rabbit</span></span><span class="hljs-literal"><span class="hljs-literal">-mq</span></span> volumes: - /app:/app ports: - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> secrets: - rabbitmq_default_user - rabbitmq_default_pass - rabbitmq_default_vhost environment: RABBITMQ_DEFAULT_USER_FILE: /run/secrets/rabbitmq_default_user RABBITMQ_DEFAULT_PASS_FILE: /run/secrets/rabbitmq_default_pass RABBITMQ_DEFAULT_VHOST_FILE: /run/secrets/rabbitmq_default_vhost deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - discovery.zen.ping.unicast.hosts=elasticsearch - bootstrap.memory_lock=true - ES_JAVA_OPTS=<span class="hljs-literal"><span class="hljs-literal">-Xms512m</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx512m</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] jenkins: image: otezvikentiy/jenkins:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'8080:8080'</span></span> - <span class="hljs-string"><span class="hljs-string">'50000:50000'</span></span> volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/jenkins:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] volumes: elasticsearch: postgresql: jenkins: networks: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span>: secrets: rabbitmq_default_user: file: ./secrets/rabbitmq_default_user rabbitmq_default_pass: file: ./secrets/rabbitmq_default_pass rabbitmq_default_vhost: file: ./secrets/rabbitmq_default_vhost postgres_db: file: ./secrets/postgres_db postgres_user: file: ./secrets/postgres_user postgres_pass: file: ./secrets/postgres_pass</code> </pre><br>  Wie Sie sehen können, unterscheidet sich die Einstellungsdatei für das Produkt geringfügig von der LAN-Datei.  Es wurden Geheimnisse, Bereitstellungen und Netzwerke hinzugefügt. <br><br>  <b>Geheimnisse</b> - Dateien zum Speichern von Schlüsseln.  Schlüssel werden ganz einfach erstellt.  Sie erstellen eine Datei mit dem Namen des Schlüssels - schreiben Sie den Wert hinein.  Danach geben Sie in docker-compose.yml den Abschnitt Geheimnisse an und übertragen die gesamte Liste der Dateien mit Schlüsseln darauf.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Details</a> . <br>  <b>Netzwerke</b> - Dadurch wird ein bestimmtes internes Raster erstellt, über das Container miteinander kommunizieren.  Im LAN - dies erfolgt automatisch, aber im produktiven Bereich - muss dies ein wenig manuell erfolgen.  Außerdem können Sie zusätzliche Einstellungen außer den Standardeinstellungen festlegen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Details</a> . <br>  <b>Die Bereitstellung</b> ist der Hauptunterschied zwischen LAN und Produkt / Beta. <br><br><pre> <code class="hljs powershell"> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>]</code> </pre><br>  Mindestanzahl an Kämpfern: <br><br>  <b>Replikate</b> - Geben Sie die Anzahl der Replikate an, die Sie ausführen müssen (dies wird tatsächlich verwendet, wenn Sie über einen Cluster verfügen und den Load Balancer vom Docker aus verwenden).  Sie haben beispielsweise zwei Server und haben diese über einen Docker-Schwarm verbunden.  Wenn Sie hier beispielsweise die Nummer 2 angeben, wird 1 Instanz auf 1 Server und die zweite auf dem zweiten Server erstellt.  Somit wird die Belastung des Servers in zwei Hälften geteilt. <br>  <b>restart_policy</b> - Die Richtlinie zum automatischen "erneuten Anheben" des Containers für den Fall, dass er aus irgendeinem Grund <b>herunterfällt</b> . <br>  <b>Platzierung</b> - der Speicherort der Containerinstanz.  Es gibt beispielsweise Zeiten, in denen alle Instanzen eines Containers auf nur einem von fünf Servern gedreht und nicht zwischen ihnen verteilt werden sollen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich möchte die Dokumentation lesen!</a> <br><br>  Wir haben also etwas besser verstanden, was docker-compose.yaml für LAN von der Produkt- / Beta-Version unterscheidet.  Versuchen wir nun, dieses Geschäft zu führen. <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie trainieren in Vagrant und haben im Stammverzeichnis des Servers bereits die konfigurierte Datei für das Produkt docker-compose.yml</font></font></i> <br><br><pre> <code class="bash hljs">sudo apt-get update sudo apt-get -y upgrade sudo apt-get install -y language-pack-en-base <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LC_ALL=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANGUAGE=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANG=en_US.UTF-8 curl -sSl https://get.docker.com/ | sh sudo usermod -aG docker ubuntu sudo apt-get install git sudo docker swarm init --advertise-addr 192.168.128.77 sudo mkdir /app sudo chmod 777 /app -R docker stack deploy -c /docker-compose.yml my-app git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@bitbucket.org:JohnDoe/my-app.git /app docker stack ps my-app docker stack ls docker stack services my-app</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten Sie nicht für Sudo und 777, natürlich lohnt es sich nicht, dies für die Produktivität zu tun. </font><font style="vertical-align: inherit;">Dies ist nur für die Lerngeschwindigkeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind also am meisten an den Zeilen interessiert, die mit dem Docker verbunden sind. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst initialisieren wir den „Schwarm“ (Docker-Schwarm). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann erstellen wir die für die Arbeit notwendigen Verzeichnisse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie die Rübe mit unserem SF4-Code im Verzeichnis / app herunter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach gibt es drei Befehle: ps, ls und services. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder von ihnen ist auf seine Weise nützlich. </font><font style="vertical-align: inherit;">Ich verwende ps am häufigsten, da es den Status der Container und einen Teil des Fehlers anzeigt, falls vorhanden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, die Container sind gestiegen, aber einige von ihnen stürzen ständig mit einem Fehler ab, und im Docker-Stack ps my-app werden einige Neustarts angezeigt. </font><font style="vertical-align: inherit;">Um den Grund für den Sturz zu erkennen, müssen Sie den Docker-Container ps -a ausführen. Dort wird ein Container angezeigt, der ständig fällt. </font><font style="vertical-align: inherit;">Es wird viele Instanzen desselben Containers geben, zum Beispiel my-app_php-fpm.1. * Ein heftiger Hash *. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dementsprechend führen Sie jetzt, wenn Sie den Namen des Containers kennen, Docker-Protokolle my-app_php-fpm.1 aus. * Etwas heftiger Hash * und sehen Sie sich die Protokolle an. </font><font style="vertical-align: inherit;">Korrigieren Sie den Fehler und starten Sie ALLES neu. </font><font style="vertical-align: inherit;">Um alle Container zu knallen, können Sie dies tun:</font></font><br><br><pre> <code class="bash hljs">docker stack rm my-app</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach haben Sie einen sauberen Schwarm ohne Behälter. </font><font style="vertical-align: inherit;">Beheben Sie den Fehler - und stellen Sie den Docker-Stack erneut -c docker-compose.yml my-app bereit.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420673/">https://habr.com/ru/post/de420673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420663/index.html">Einfache Metriken und eine Möglichkeit, Zeit zu sparen, wenn Sie nach Problemen in der Infrastruktur suchen</a></li>
<li><a href="../de420665/index.html">Erstellen einer Anwendung auf .NET Core und Kubernetes: Unsere Erfahrung</a></li>
<li><a href="../de420667/index.html">Funktionsprinzipien des EIGRP-Protokolls</a></li>
<li><a href="../de420669/index.html">Marktüberblick über Enterprise Automation: Lösungen für Bau- und Verwaltungsunternehmen für Wohnungsbau und Versorgungsunternehmen</a></li>
<li><a href="../de420671/index.html">[Ekaterinburg, Ankündigung] UralJS # 9 - drei Berichte über Microservices, Tests und Fehlerprotokollierung an der Vorderseite</a></li>
<li><a href="../de420675/index.html">SOC sind Menschen. „Hallo, wir suchen Talente“ oder woher kommen die Analysten des Überwachungs- und Reaktionszentrums für Cyberangriffe</a></li>
<li><a href="../de420677/index.html">Die Geschichte, wie Epson den Planeten mit 30 Millionen "Fabriken" versorgte</a></li>
<li><a href="../de420679/index.html">Neue Python-Kurse von Mail.Ru Group</a></li>
<li><a href="../de420681/index.html">AMD ThreadRipper 2: Erste Einführung</a></li>
<li><a href="../de420685/index.html">Fix und neutralisieren: wie wir Silber gezähmt haben. Ein Wort zu Bakteriziden für Wasser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>