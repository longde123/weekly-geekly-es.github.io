<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤖 🧛🏾 👩🏽‍🔬 Kami menulis di bawah FPGA tanpa HDL. Perbandingan alat pengembangan tingkat tinggi 💩 ☯️ ◼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, produsen FPGA dan perusahaan pihak ketiga telah secara aktif mengembangkan metode pengembangan untuk FPGA yang berbeda dari pendekatan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis di bawah FPGA tanpa HDL. Perbandingan alat pengembangan tingkat tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  Baru-baru ini, produsen FPGA dan perusahaan pihak ketiga telah secara aktif mengembangkan metode pengembangan untuk FPGA yang berbeda dari pendekatan konvensional menggunakan alat pengembangan tingkat tinggi. <br><br>  Sebagai pengembang FPGA, saya menggunakan bahasa deskripsi perangkat keras Verilog ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDL</a> ) sebagai alat utama, tetapi semakin populernya metode baru membangkitkan minat besar saya, jadi dalam artikel ini saya memutuskan untuk mencari tahu apa yang terjadi. <br><br>  Artikel ini bukan panduan atau instruksi untuk digunakan, ini adalah ulasan dan kesimpulan saya tentang apa yang dapat diberikan berbagai alat pengembangan tingkat tinggi kepada pengembang atau programmer FPGA yang ingin terjun ke dunia FPGA.  Untuk membandingkan alat pengembangan yang paling menarik menurut saya, saya menulis beberapa tes dan menganalisis hasilnya.  Di bawah luka - apa yang terjadi. <br><a name="habracut"></a><br><h2>  Mengapa Anda membutuhkan alat pengembangan tingkat tinggi untuk FPGA? </h2><br><ul><li>  Mempercepat pengembangan proyek <br>  - karena penggunaan kembali kode yang sudah ditulis dalam bahasa tingkat tinggi; <br>  - Melalui penggunaan semua keunggulan bahasa tingkat tinggi, saat menulis kode dari awal; <br>  - dengan mengurangi waktu kompilasi dan verifikasi kode. <br></li><li>  Kemampuan untuk membuat kode universal yang akan bekerja pada keluarga FPGA apa pun. </li><li>  Kurangi ambang pengembangan untuk FPGA, misalnya, menghindari konsep "frekuensi clock" dan entitas tingkat rendah lainnya.  Kemampuan menulis kode untuk FPGA ke pengembang yang tidak terbiasa dengan HDL. </li></ul><br><h2>  Dari mana datangnya alat pengembangan tingkat tinggi? </h2><br>  Sekarang banyak yang tertarik dengan gagasan pembangunan tingkat tinggi.  Kedua penggemar, seperti, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quokka</a> dan pembuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode Python</a> , dan perusahaan, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mathworks</a> , dan produsen FPGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xilinx</a> terlibat dalam hal ini. <br><br>  Setiap orang menggunakan metode dan alatnya untuk mencapai tujuannya.  Penggemar dalam perjuangan untuk dunia yang sempurna dan indah menggunakan bahasa pengembangan favorit mereka, seperti Python atau C #.  Perusahaan, berusaha menyenangkan klien, menawarkan alat mereka sendiri atau mengadaptasi yang ada.  Mathworks menawarkan alat pembuat kode HDL sendiri untuk menghasilkan kode HDL dari model m-scripts dan Simulink, sementara Intel dan Xilinx menawarkan kompiler untuk C / C ++ yang umum. <br><br>  Saat ini, perusahaan dengan sumber daya keuangan dan sumber daya manusia yang signifikan telah mencapai kesuksesan yang lebih besar, sementara penggemar agak di belakang.  Artikel ini akan dikhususkan untuk pertimbangan produk HDL coder dari Mathworks dan HLS Compiler dari Intel. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan Xilinx</b> <div class="spoiler_text">  Dalam artikel ini, saya tidak mempertimbangkan HIL dari Xilinx, karena arsitektur yang berbeda dan sistem CAD dari Intel dan Xilinx, yang membuatnya tidak mungkin untuk membuat perbandingan hasil yang jelas.  Tetapi saya ingin mencatat bahwa Xilinx HLS, seperti Intel HLS, menyediakan kompiler C / C ++ dan secara konsep keduanya mirip. <br></div></div><br>  Mari kita mulai membandingkan koder HDL dari Mathworks dan Intel HLS Compiler, setelah memecahkan beberapa masalah menggunakan pendekatan yang berbeda. <br><br><h2>  Perbandingan alat pengembangan tingkat tinggi </h2><br><h3>  Tes satu.  “Dua pengganda dan satu penambah” </h3><br>  Solusi untuk masalah ini tidak memiliki nilai praktis, tetapi sangat cocok sebagai tes pertama.  Fungsi ini mengambil 4 parameter, mengalikan yang pertama dengan yang kedua, yang ketiga dengan yang keempat dan menambahkan hasil perkalian.  Tidak ada yang rumit, tetapi mari kita lihat bagaimana subjek kita mengatasi hal ini. <br><br><h4>  HDL coder oleh Mathworks </h4><br>  Untuk mengatasi masalah ini, skrip-m terlihat sebagai berikut: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Mari kita lihat apa yang ditawarkan Mathworks untuk mengubah kode menjadi HDL. <br><br>  Saya tidak akan mempertimbangkan secara rinci pekerjaan dengan HDL-coder, saya hanya akan fokus pada pengaturan yang akan saya ubah di masa depan untuk mendapatkan hasil yang berbeda dalam FPGA, dan perubahannya harus dipertimbangkan oleh programmer MATLAB yang perlu menjalankan kodenya dalam FPGA. <br><br>  Jadi, hal pertama yang harus dilakukan adalah mengatur jenis dan rentang nilai input.  Tidak ada char, int, float, double di FPGA.  Kedalaman bit angka dapat berupa apa saja, logis untuk memilihnya, berdasarkan rentang nilai input yang Anda rencanakan untuk digunakan. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="gambar"><br>  <i>Gambar 1</i> <br><br>  MATLAB memeriksa jenis variabel, nilainya dan memilih ukuran bit yang benar untuk bus dan register, yang benar-benar nyaman.  Jika tidak ada masalah dengan kedalaman bit dan pengetikan, Anda dapat melanjutkan ke poin-poin berikut. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="gambar"></a> <br>  <i>Gambar 2</i> <br><br>  Ada beberapa tab dalam Pembuatan Kode HDL tempat Anda dapat memilih bahasa yang akan dikonversi (Verilog atau VHDL);  gaya kode  nama-nama sinyal.  Tab yang paling menarik, menurut saya, adalah Optimasi, dan saya akan bereksperimen dengannya, tetapi nanti, untuk sekarang, mari kita tinggalkan semua default dan lihat apa yang terjadi dengan HDL coder “out of the box”. <br><br>  Tekan tombol Run dan dapatkan kode berikut: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Kode terlihat bagus.  MATLAB memahami bahwa menulis seluruh ekspresi pada satu baris di Verilog adalah praktik yang buruk.  Membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kabel</a> terpisah untuk pengganda dan penambah, tidak ada yang perlu dikeluhkan. <br><br>  Sangat mengkhawatirkan bahwa deskripsi register tidak ada.  Ini terjadi karena kami tidak meminta HDL-coder tentang ini, dan membiarkan semua bidang dalam pengaturan ke nilai standarnya. <br><br>  Inilah yang disintesis Quartus dari kode tersebut. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Gambar 3</i> <br><br>  Tidak masalah, semuanya sesuai rencana. <br><br>  Dalam FPGA kami menerapkan sirkuit sinkron, dan saya masih ingin melihat register.  HDL-coder menawarkan mekanisme untuk menempatkan register, tetapi di mana menempatkannya tergantung pada pengembang.  Kita dapat menempatkan register pada input pengganda, pada keluaran pengganda di depan penambah, atau pada keluaran penambah. <br><br>  Untuk mensintesis contoh, saya memilih keluarga FPGA Cyclone V, di mana blok DSP khusus dengan built-in adders dan multipliers digunakan untuk mengimplementasikan operasi aritmatika.  Blok DSP terlihat seperti ini: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Gambar 4</i> <br><br>  Blok DSP memiliki register input dan output.  Tidak perlu mencoba menjepret hasil perkalian dalam register sebelum penambahan, ini hanya akan melanggar arsitektur (dalam kasus tertentu, opsi ini mungkin dan bahkan diperlukan).  Terserah pengembang untuk memutuskan bagaimana menangani input dan output register berdasarkan pada persyaratan latensi dan frekuensi maksimum yang diperlukan.  Saya memutuskan untuk hanya menggunakan register keluaran.  Agar register ini dijelaskan dalam kode yang dihasilkan oleh HDL-coder, pada tab Options di HDL coder Anda perlu memeriksa kotak centang Register output dan memulai kembali konversi. <br><br>  Ternyata kode berikut: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Seperti yang Anda lihat, kode memiliki perbedaan mendasar dibandingkan dengan versi sebelumnya.  Blok selalu muncul, yang merupakan deskripsi register (hanya apa yang kita inginkan).  Untuk operasi selalu-blok, input dari modul CLK (frekuensi clock) dan reset (reset) juga muncul.  Dapat dilihat bahwa output dari penambah terkunci pada pemicu yang dijelaskan dalam selalu.  Ada juga beberapa sinyal izin ena, tetapi mereka tidak terlalu menarik bagi kami. <br><br>  Mari kita lihat diagram yang sekarang disintesis Quartus. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Gambar 5</i> <br><br>  Dan lagi, hasilnya bagus dan diharapkan. <br><br>  Tabel di bawah ini menunjukkan tabel sumber daya yang digunakan - kami selalu mengingatnya. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Gambar 6</i> <br><br>  Untuk pencarian pertama ini, Mathworks menerima kredit.  Semuanya tidak rumit, dapat diprediksi dan dengan hasil yang diinginkan. <br><br>  Saya menjelaskan secara rinci contoh sederhana, memberikan diagram blok DSP, dan menjelaskan kemungkinan menggunakan pengaturan penggunaan register dalam HDL-coder, yang berbeda dari pengaturan "default".  Ini dilakukan karena suatu alasan.  Dengan ini saya ingin menekankan bahwa bahkan dalam contoh sederhana seperti itu, ketika menggunakan HDL-coder, pengetahuan tentang arsitektur FPGA dan dasar-dasar sirkuit digital diperlukan, dan pengaturan harus diubah secara sadar. <br><br><h4>  Intel HLS Compiler </h4><br>  Mari kita coba mengkompilasi kode dengan fungsi yang sama yang ditulis dalam C ++ dan melihat apa yang akhirnya disintesis dalam FPGA menggunakan kompiler HLS. <br><br>  Jadi kode C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  Saya memilih tipe data untuk menghindari variabel yang meluap. <br><br>  Ada metode canggih untuk mengatur kedalaman bit, tetapi tujuan kami adalah menguji kemampuan untuk merakit fungsi yang ditulis dalam gaya C / C ++ di bawah FPGA tanpa membuat perubahan apa pun, semuanya keluar dari kotak. <br><br>  Karena kompiler HLS adalah alat asli Intel, kami mengumpulkan kode dengan kompiler khusus dan segera memeriksa hasilnya di Quartus. <br><br>  Mari kita lihat sirkuit yang disintesis Quartus. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Gambar 7</i> <br><br>  Kompiler membuat register pada input dan output, tetapi esensinya tersembunyi dalam modul wrapper.  Kami mulai menggunakan bungkus dan ... melihat lebih banyak, lebih banyak modul bersarang. <br><br>  Struktur proyek terlihat seperti ini. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Gambar 8</i> <br><br>  Petunjuk yang jelas dari Intel adalah "jangan lakukan itu!".  Tapi kami akan coba, terutama fungsinya tidak rumit. <br><br>  Di perut pohon proyek | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 adalah modul yang Anda cari. <br><br>  Kita dapat melihat diagram dari modul yang diinginkan yang disintesis oleh Quartus. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Gambar 9</i> <br><br>  Kesimpulan apa yang bisa ditarik dari skema ini. <br><br>  Jelaslah bahwa sesuatu terjadi yang kami coba hindari ketika bekerja di MATLAB: kasing pada keluaran dari pengali disintesis - ini tidak terlalu baik.  Dapat dilihat dari diagram blok DSP (Gambar 4) bahwa hanya ada satu register pada outputnya, yang berarti bahwa setiap perkalian harus dilakukan dalam blok yang terpisah. <br><br>  Tabel sumber daya yang digunakan menunjukkan apa yang menyebabkan hal ini. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Gambar 10</i> <br><br>  Bandingkan hasilnya dengan tabel koder HDL (Gambar 6). <br><br>  Jika menggunakan register dalam jumlah yang lebih besar, maka menghabiskan blok DSP yang berharga untuk fungsi sederhana seperti itu sangat tidak menyenangkan. <br><br>  Tetapi ada nilai tambah besar di Intel HLS dibandingkan dengan HDL coder.  Dengan pengaturan default, kompiler HLS mengembangkan desain sinkron dalam FPGA, meskipun menghabiskan lebih banyak sumber daya.  Arsitektur seperti itu mungkin, jelas bahwa Intel HLS dikonfigurasikan untuk mencapai kinerja maksimum, dan bukan untuk menghemat sumber daya. <br><br>  Mari kita lihat bagaimana subjek kita berperilaku dengan proyek yang lebih kompleks. <br><br><h3>  Tes kedua.  “Penggandaan matriks secara elemen dengan penjumlahan dari hasil” </h3><br>  Fungsi ini banyak digunakan dalam pemrosesan gambar: yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"filter matriks"</a> .  Kami menjualnya menggunakan alat tingkat tinggi. <br><br><h4>  HDL coder oleh Mathwork </h4><br>  Pekerjaan segera dimulai dengan batasan.  HDL Coder tidak dapat menerima fungsi matriks 2-D sebagai input.  Mengingat bahwa MATLAB adalah alat untuk bekerja dengan matriks, ini merupakan pukulan serius untuk seluruh kode yang diwarisi, yang dapat menjadi masalah serius.  Jika kode ditulis dari awal, ini adalah fitur yang tidak menyenangkan yang harus dipertimbangkan.  Jadi, Anda harus menggunakan semua matriks ke dalam vektor dan mengimplementasikan fungsi dengan memperhitungkan vektor input. <br><br>  Kode untuk fungsi di MATLAB adalah sebagai berikut <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Kode HDL yang dihasilkan ternyata sangat membengkak dan berisi ratusan baris, jadi saya tidak akan memberikannya di sini.  Mari kita lihat skema apa yang disintesis Quartus dari kode ini. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Gambar 11</i> <br><br>  Skema ini terlihat tidak berhasil.  Secara formal, ini berfungsi, tetapi saya berasumsi bahwa itu akan bekerja pada frekuensi yang sangat rendah, dan hampir tidak dapat digunakan pada perangkat keras nyata.  Tetapi asumsi apa pun harus diverifikasi.  Untuk melakukan ini, kami akan menempatkan register pada input dan output dari rangkaian ini dan dengan bantuan Timing Analyzer kami akan mengevaluasi situasi sebenarnya.  Untuk melakukan analisis, Anda harus menentukan frekuensi operasi yang diinginkan dari sirkuit sehingga Quartus tahu apa yang harus diperjuangkan ketika kabel, dan jika terjadi kegagalan, memberikan laporan pelanggaran. <br><br>  Kami mengatur frekuensinya menjadi 100 MHz, mari kita lihat apa yang bisa Quartus peras dari rangkaian yang diusulkan. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Gambar 12</i> <br><br>  Dapat dilihat bahwa ternyata sedikit: 33 MHz terlihat sembrono.  Keterlambatan dalam rantai pengganda dan pengaya adalah sekitar 30 ns.  Untuk menghilangkan "bottleneck" ini, Anda perlu menggunakan conveyor: masukkan register setelah operasi aritmatika, sehingga mengurangi jalur kritis. <br><br>  HDL coder memberi kita kesempatan ini.  Di tab Opsi, Anda bisa mengatur variabel Pipeline.  Karena kode yang dimaksud ditulis dalam gaya MATLAB, tidak ada cara untuk menyalurkan variabel (kecuali variabel mult dan jumlah), yang tidak sesuai dengan kita.  Penting untuk memasukkan register ke sirkuit perantara yang tersembunyi dalam kode HDL kami. <br><br>  Apalagi situasi dengan optimasi bisa lebih buruk.  Misalnya, tidak ada yang mencegah kita dari menulis kode <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  ini cukup memadai untuk MATLAB, tetapi benar-benar menghalangi kita dari kemungkinan mengoptimalkan HDL. <br><br>  Jalan keluar selanjutnya adalah mengedit kode dengan tangan.  Ini adalah poin yang sangat penting, karena kami menolak untuk mewarisi dan mulai menulis ulang skrip-m, dan BUKAN dengan gaya MATLAB. <br><br>  Kode baru adalah sebagai berikut <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Di Quartus, kami mengumpulkan kode yang dihasilkan oleh HDL Coder.  Dapat dilihat bahwa jumlah lapisan dengan primitif telah menurun, dan skema terlihat jauh lebih baik. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Gambar 12</i> <br><br>  Dengan tata letak primitif yang benar, frekuensi tumbuh hampir 3 kali, hingga 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Gambar 13</i> <br><br>  Sekarang sentuhan terakhir: di pengaturan Optimasi, tentukan sum_1, summ_2 dan summ_3 sebagai elemen dari pipeline.  Kami mengumpulkan kode yang dihasilkan di Quartus.  Skema berubah sebagai berikut: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Gambar 14</i> <br><br>  Frekuensi maksimum meningkat lagi dan sekarang nilainya sekitar 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Gambar 15</i> <br><br>  Berapa banyak sumber daya pada chip akan mengambil desain seperti itu?  Gambar 16 menunjukkan tabel sumber daya yang digunakan untuk kasus yang dijelaskan. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Gambar 16</i> <br><br>  Kesimpulan apa yang bisa ditarik setelah mempertimbangkan contoh ini? <br><br>  Kerugian utama dari HDL coder adalah tidak mungkin menggunakan kode MATLAB dalam bentuk murni. <br>  Tidak ada dukungan untuk matriks sebagai input fungsi, tata letak kode dalam gaya MATLAB biasa-biasa saja. <br><br>  Bahaya utama adalah kurangnya register dalam kode yang dihasilkan tanpa pengaturan tambahan.  Tanpa register-register ini, bahkan setelah menerima kode HDL yang berfungsi secara resmi tanpa kesalahan sintaksis, penggunaan kode semacam itu dalam realitas dan perkembangan modern tidak diinginkan. <br><br>  Dianjurkan untuk segera menulis kode yang dipertajam untuk konversi ke HDL.  Dalam hal ini, Anda bisa mendapatkan hasil yang cukup dapat diterima dalam hal kecepatan dan intensitas sumber daya. <br><br>  Jika Anda seorang pengembang MATLAB, jangan buru-buru mengklik tombol Jalankan dan kompilasi kode Anda di bawah FPGA, ingatlah bahwa kode Anda akan disintesis menjadi rangkaian nyata.  =) <br><br><h4>  Intel HLS Compiler </h4><br>  Untuk fungsi yang sama, saya menulis kode C / C ++ berikut <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  Hal pertama yang menarik perhatian Anda adalah jumlah sumber daya yang digunakan. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Gambar 17</i> <br><br>  Dapat dilihat dari tabel bahwa hanya 1 blok DSP yang digunakan, sehingga terjadi kesalahan, dan perkalian tidak dilakukan secara paralel.  Jumlah register yang digunakan juga mengejutkan, dan bahkan melibatkan memori, tetapi kami akan menyerahkan ini kepada hati nurani dari kompiler HLS. <br><br>  Perlu dicatat bahwa kompiler HLS telah mengembangkan sub-optimal, menggunakan sejumlah besar sumber daya tambahan, tetapi masih merupakan sirkuit kerja yang, menurut laporan Quartus, akan bekerja pada frekuensi yang dapat diterima, dan kegagalan seperti koder HDL tidak akan. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Gambar 18</i> <br><br>  Mari kita coba untuk memperbaiki situasi.  Apa yang dibutuhkan untuk ini?  Itu benar, tutup mata Anda untuk warisan dan merangkak ke dalam kode, tetapi untuk saat ini, hanya sedikit. <br><br>  HLS memiliki arahan khusus untuk mengoptimalkan kode untuk FPGA.  Kami memasukkan arahan membuka gulungan, yang akan memperluas loop kami secara paralel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Mari kita lihat bagaimana reaksi Quartus terhadapnya <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Gambar 19</i> <br><br>  Pertama-tama, perhatikan jumlah blok DSP - ada 16 di antaranya, yang berarti bahwa perkalian dilakukan secara paralel. <br><br>  Hore!  membuka gulungan bekerja!  Tetapi sudah sulit untuk bertahan dengan seberapa banyak pemanfaatan sumber daya lain telah tumbuh.  Sirkuit menjadi benar-benar tidak dapat dibaca. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Gambar 20</i> <br><br>  Saya percaya ini karena fakta bahwa tidak ada yang menunjukkan kepada kompiler bahwa perhitungan dalam angka-angka tetap cukup cocok untuk kita, dan dia dengan jujur ​​menerapkan semua matematika titik-mengambang pada logika dan register.  Kita perlu menjelaskan kepada kompiler apa yang diperlukan, dan untuk ini kita kembali memasukkan kode. <br><br>  Untuk tujuan menggunakan titik tetap, kelas template diimplementasikan. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Gambar 21</i> <br><br>  Berbicara dengan kata-kata kami sendiri, kami dapat menggunakan variabel yang kedalaman bitnya diatur secara manual hingga sedikit.  Bagi mereka yang menulis dalam HDL, Anda tidak dapat membiasakan diri dengannya, tetapi para programmer C / C ++ mungkin akan berusaha keras.  Kedalaman bit, seperti pada MATLAB, dalam hal ini, tidak ada yang akan memberi tahu, dan pengembang sendiri harus menghitung jumlah bit. <br><br>  Mari kita lihat tampilannya dalam praktik. <br><br>  Kami mengedit kode sebagai berikut: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  Dan alih-alih pasta menyeramkan dari Gambar 20, kita mendapatkan keindahan ini: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Gambar 22</i> <br><br>  Sayangnya, sesuatu yang aneh terus terjadi dengan sumber daya yang digunakan. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Gambar 23</i> <br><br>  Tetapi tinjauan terperinci atas laporan menunjukkan bahwa modul yang menarik bagi kita secara langsung terlihat lebih dari cukup: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Gambar 24</i> <br><br>  Konsumsi register dan memori blok yang sangat besar dikaitkan dengan sejumlah besar modul periferal.  Saya masih belum sepenuhnya memahami makna mendalam dari keberadaan mereka, dan ini perlu diselesaikan, tetapi masalahnya selesai.  Dalam kasus ekstrem, Anda dapat dengan hati-hati memotong satu modul yang menarik bagi kami dari struktur umum proyek, yang akan menyelamatkan kami dari modul periferal yang menghabiskan sumber daya. <br><br><h3>  Tes ketiga.  “Transisi dari RGB ke HSV” </h3><br>  Mulai menulis artikel ini, saya tidak berharap itu menjadi sangat produktif.  Tapi saya tidak bisa menolak yang ketiga dan terakhir dalam kerangka artikel ini, contohnya. <br><br>  Pertama, ini adalah contoh nyata dari praktik saya, dan karena itulah saya mulai mencari alat pengembangan tingkat tinggi. <br><br>  Kedua, dari dua contoh pertama, kita dapat membuat asumsi bahwa semakin kompleks desain, semakin buruk alat tingkat tinggi mengatasi tugas tersebut. <br><br>  Saya ingin menunjukkan bahwa penilaian ini keliru, dan pada kenyataannya, semakin kompleks tugasnya, semakin banyak keuntungan dari alat pengembangan tingkat tinggi terwujud. <br><br>  Tahun lalu, ketika mengerjakan salah satu proyek, saya tidak suka kamera yang dibeli di Aliexpress, yaitu, warnanya tidak cukup jenuh.  Salah satu cara populer untuk memvariasikan saturasi warna adalah beralih dari ruang warna RGB ke ruang HSV, di mana salah satu parameternya adalah saturasi.  Saya ingat bagaimana saya membuka formula transisi dan mengambil napas dalam-dalam ... Menerapkan perhitungan seperti itu di FPGA bukanlah sesuatu yang luar biasa, tetapi tentu saja akan memakan waktu untuk menulis kode.  Jadi, rumus untuk beralih dari RGB ke HSV adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Gambar 25</i> <br><br>  Implementasi algoritma seperti itu di FPGA tidak akan memakan waktu berhari-hari, tetapi berjam-jam, dan semua ini harus dilakukan dengan sangat hati-hati karena spesifikasi HDL, dan implementasi dalam C ++ atau di MATLAB akan memakan waktu, saya pikir, beberapa menit. <br><br>  Di C ++, Anda dapat menulis kode langsung di dahi dan masih mendapatkan hasil yang baik. <br>  Saya menulis opsi berikut di C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  Dan Quartus berhasil mengimplementasikan hasilnya, seperti dapat dilihat dari tabel sumber daya yang digunakan. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Gambar 26</i> <br><br>  Frekuensinya sangat bagus. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Gambar 27</i> <br><br>  Dengan HDL coder, segalanya menjadi sedikit lebih rumit. <br><br>  Agar tidak mengembang artikel, saya tidak akan menyediakan skrip-m untuk tugas ini, seharusnya tidak menyebabkan kesulitan.  Sebuah m-script yang ditulis di dahi hampir tidak dapat berhasil digunakan, tetapi jika Anda mengedit kode dan menentukan tempat pipelining dengan benar, kami mendapatkan hasil yang baik.  Ini, tentu saja, akan memakan waktu beberapa puluh menit, tetapi bukan jam. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam C ++, juga diinginkan untuk mengatur arahan dan menerjemahkan perhitungan ke titik tetap, yang juga akan memakan waktu sangat sedikit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, menggunakan alat pengembangan tingkat tinggi, kami menghemat waktu, dan semakin kompleks algoritme, semakin banyak waktu yang dihemat - ini akan terus berlanjut hingga kami mengalami batas sumber daya FPGA atau batas kecepatan komputasi yang ketat di mana Anda harus menangani HDL.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang bisa dikatakan sebagai kesimpulan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, palu emas belum ditemukan, tetapi ada alat tambahan yang dapat digunakan dalam pengembangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan utama alat tingkat tinggi, menurut pendapat saya, adalah kecepatan pengembangan. Adalah kenyataan untuk mendapatkan kualitas yang cukup dalam hal waktu, terkadang urutan besarnya lebih kecil daripada ketika mengembangkan menggunakan HDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya waspada terhadap keuntungan seperti menggunakan kode lama untuk FPGA dan menghubungkan ke pengembangan untuk programmer FPGA tanpa persiapan awal. Untuk mendapatkan hasil yang memuaskan, Anda harus meninggalkan banyak teknik pemrograman yang sudah dikenal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali lagi, saya ingin mencatat bahwa artikel ini hanyalah tampilan dangkal pada alat pengembangan tingkat tinggi untuk FPGA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler HLS memiliki peluang besar untuk optimasi: pragma, perpustakaan khusus dengan fungsi yang dioptimalkan, deskripsi antarmuka, banyak artikel di Internet tentang “praktik terbaik”, dll. Chip MATLAB, yang belum dipertimbangkan, adalah kemampuan untuk secara langsung menghasilkan, misalnya, filter dari GUI tanpa menulis satu baris kode, hanya menunjukkan karakteristik yang diinginkan, yang selanjutnya mempercepat waktu pengembangan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siapa yang memenangkan studi hari ini? Pendapat saya adalah kompiler HLS Intel. Ini menghasilkan desain yang berfungsi bahkan dari kode yang tidak dioptimalkan. HDL coder tanpa analisis yang cermat dan pemrosesan kode saya akan takut untuk menggunakannya. Saya juga ingin mencatat bahwa HDL coder adalah alat yang cukup lama, tetapi seperti yang saya tahu, itu belum mendapatkan pengakuan luas. Tapi HLS, meskipun muda, jelas bahwa produsen FPGA bertaruh, saya pikir kita akan melihat perkembangan lebih lanjut dan pertumbuhan popularitas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perwakilan Xilinx memastikan bahwa pengembangan dan implementasi alat tingkat tinggi adalah satu-satunya peluang di masa depan untuk mengembangkan chip FPGA yang lebih besar dan lebih besar. Alat tradisional tidak akan mampu mengatasinya, dan Verilog / VHDL mungkin ditakdirkan untuk assembler, tetapi ini di masa depan. Dan sekarang kita memiliki alat pengembangan tangan (dengan pro dan kontra), yang harus kita pilih berdasarkan tugas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah saya akan menggunakan alat pengembangan tingkat tinggi dalam pekerjaan saya? Sebaliknya, ya, sekarang perkembangan mereka berjalan dengan cepat, jadi kita setidaknya harus mengikuti, tetapi saya tidak melihat alasan obyektif untuk segera meninggalkan HDL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada akhirnya, saya ingin mencatat sekali lagi bahwa pada tahap pengembangan alat desain tingkat tinggi ini, pengguna tidak boleh lupa sejenak bahwa ia menulis sebuah program yang tidak dapat dieksekusi dalam prosesor, tetapi membuat sirkuit dengan kabel, pemicu, dan elemen logika nyata. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455668/">https://habr.com/ru/post/id455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455650/index.html">Bagaimana kami melatih jaringan saraf untuk mengklasifikasikan sekrup</a></li>
<li><a href="../id455652/index.html">Deep Learning vs akal sehat: mengembangkan bot obrolan</a></li>
<li><a href="../id455658/index.html">Legendaris Intel Core i7-2600K: menguji Sandy Bridge pada 2019 (bagian 3)</a></li>
<li><a href="../id455662/index.html">Tampilan mekanis besar dengan mekanisme cam sebagai decoder</a></li>
<li><a href="../id455666/index.html">Membangun Penjualan Outbound di Perusahaan Layanan TI</a></li>
<li><a href="../id455670/index.html">Bagaimana printer 3D mencetak tulang, pembuluh darah, dan organ</a></li>
<li><a href="../id455676/index.html">Apakah gelembung pembelajaran mesin meledak, atau awal fajar baru</a></li>
<li><a href="../id455678/index.html">Di jalan Sergey Pavlovich Korolev. Proyek berawak Rusia modern. Bagian 1. "Federasi"</a></li>
<li><a href="../id455682/index.html">Berapa banyak yang Anda habiskan untuk infrastruktur? Dan bagaimana cara menghemat ini?</a></li>
<li><a href="../id455684/index.html">Mengapa kami melakukan hackathon untuk penguji</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>