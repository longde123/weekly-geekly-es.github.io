<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏻 🌤️ 🌺 Deterministische Ausnahmen und Fehlerbehandlung in „C ++ der Zukunft“ 🏮 🌘 ⏲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist seltsam, dass auf Habrt noch kein lauter Vorschlag für den C ++ - Standard namens "Zero-Overhead-deterministische Ausnahmen" erwähnt wurde. Kor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deterministische Ausnahmen und Fehlerbehandlung in „C ++ der Zukunft“</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Es ist seltsam, dass auf Habrt noch kein lauter Vorschlag für den C ++ - Standard namens "Zero-Overhead-deterministische Ausnahmen" erwähnt wurde.  Korrigieren Sie diese nervige Auslassung. </p><br><p>  Wenn Sie sich Sorgen über den Overhead von Ausnahmen machen oder Code ohne Ausnahmeunterstützung kompilieren mussten oder sich nur fragen, was mit der Fehlerbehandlung in C ++ 2b passieren wird (ein Verweis auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kürzlich veröffentlichten Beitrag</a> ), frage ich nach cat.  Sie warten auf einen Druck auf alles, was jetzt zu diesem Thema zu finden ist, und auf ein paar Umfragen. </p><a name="habracut"></a><br><p> Die folgende Diskussion wird nicht nur über statische Ausnahmen geführt, sondern auch über verwandte Vorschläge zum Standard und über alle möglichen anderen Möglichkeiten, mit Fehlern umzugehen.  Wenn Sie hierher gekommen sind, um sich die Syntax anzusehen, dann ist es hier: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Wenn der spezifische Fehlertyp unwichtig / unbekannt ist, können Sie einfach <code>throws</code> and <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Gut zu wissen </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> und <code>std::expected</code> </h3><br><p>  Lassen Sie uns entscheiden, dass der Fehler, der möglicherweise in der Funktion auftreten kann, nicht „schwerwiegend“ genug ist, um eine Ausnahme auszulösen.  Traditionell werden Fehlerinformationen mithilfe eines out-Parameters zurückgegeben.  Beispielsweise bietet das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateisystem TS</a> eine Reihe ähnlicher Funktionen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Keine Ausnahme auslösen, da die Datei nicht gefunden wurde?) Die Verarbeitung von Fehlercodes ist jedoch umständlich und fehleranfällig.  Der Fehlercode kann leicht vergessen werden.  Moderne Codestile <a href="">verbieten die</a> Verwendung von Ausgabeparametern. Stattdessen wird empfohlen, eine Struktur zurückzugeben, die das gesamte Ergebnis enthält. </p><br><p>  Boost bietet seit einiger Zeit eine elegante Lösung für die Behandlung solcher „nicht schwerwiegenden“ Fehler, die in bestimmten Szenarien im richtigen Programm zu Hunderten auftreten können: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  Der <code>expected</code> Typ ähnelt der <code>variant</code> , bietet jedoch eine praktische Schnittstelle für die Arbeit mit "Ergebnis" und "Fehler".  Standardmäßig wird das <code>expected</code> Ergebnis in <code>expected</code> gespeichert.  Die Implementierung von <code>file_size</code> könnte <code>file_size</code> aussehen: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Wenn die Fehlerursache für uns nicht interessant ist oder der Fehler nur in der „Abwesenheit“ des Ergebnisses bestehen kann, kann <code>optional</code> verwendet werden: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  In C ++ 17 von Boost kam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optional</a> zu std (ohne Unterstützung für <code>optional&lt;T&amp;&gt;</code> );  In C ++ 20 können sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwartete</a> hinzufügen (dies ist nur Vorschlag, danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">RamzesXI</a> für die Korrektur). </p><br><h3 id="contracts">  Verträge </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verträge</a> (nicht zu verwechseln mit Konzepten) sind eine neue Möglichkeit, Funktionsparameter einzuschränken, die in C ++ 20 hinzugefügt wurden.  3 Anmerkungen hinzugefügt: </p><br><ul><li>  <strong>erwartet</strong> prüft Funktionsparameter </li><li>  <strong>stellt sicher</strong> , dass der Rückgabewert der Funktion überprüft wird (nimmt ihn als Argument) </li><li>  <strong>assert</strong> - ein zivilisierter Ersatz für das Makro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Sie können für Vertragsbruch konfigurieren: </p><br><ul><li>  Undefiniertes Verhalten genannt, oder </li><li>  Es überprüfte und rief den User-Exit auf, wonach <code>std::terminate</code> </li></ul><br><p>  Es ist unmöglich, das Programm nach Vertragsbruch weiter auszuführen, da Compiler Garantien aus Verträgen verwenden, um den Funktionscode zu optimieren.  Im geringsten Zweifel an der Vertragserfüllung lohnt es sich, einen zusätzlichen Scheck hinzuzufügen. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  Mit der in C ++ 11 hinzugefügten Bibliothek <code>&lt;system_error&gt;</code> können Sie die Behandlung von Fehlercodes in Ihrem Programm standardisieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: error_code</a> besteht aus einem Fehlercode vom Typ <code>int</code> und einem Zeiger auf das Objekt einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untergeordneten Klasse std :: error_category</a> .  Dieses Objekt spielt tatsächlich die Rolle einer Tabelle virtueller Funktionen und bestimmt das Verhalten eines bestimmten <code>std::error_code</code> . </p><br><p>  Um Ihren <code>std::error_code</code> zu erstellen, müssen Sie <code>std::error_category</code> Nachkommenklasse <code>std::error_category</code> definieren und virtuelle Methoden implementieren. Die wichtigste davon ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Sie müssen auch eine globale Variable für Ihre <code>std::error_category</code> .  Die Fehlerbehandlung mit error_code + expected sieht ungefähr so ​​aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Es ist wichtig, dass in <code>std::error_code</code> Wert von 0 keinen Fehler bedeutet.  Wenn dies bei Ihren Fehlercodes nicht der Fall ist, müssen Sie vor der Konvertierung des Systemfehlercodes in <code>std::error_code</code> den Code 0 durch SUCCESS ersetzen und umgekehrt. </p><br><p>  Alle Systemfehlercodes werden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">errc</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">system_category beschrieben</a> .  Wenn zu einem bestimmten Zeitpunkt die manuelle Weiterleitung der Fehlercodes zu trostlos wird, können Sie den Fehlercode jederzeit in die <code>std::system_error</code> und wegwerfen. </p><br><h3 id="destructive-move--trivially-relocatable">  Zerstörerische Bewegung / Trivial umsetzbar </h3><br><p>  Sie müssen eine andere Klasse von Objekten erstellen, die einige Ressourcen besitzen.  Höchstwahrscheinlich möchten Sie es nicht kopierbar, sondern verschiebbar machen, da die Arbeit mit nicht verschiebbaren Objekten unpraktisch ist (vor C ++ 17 konnten sie nicht von einer Funktion zurückgegeben werden). </p><br><p>  Aber hier ist das Problem: In jedem Fall muss das verschobene Objekt gelöscht werden.  Daher ist ein spezieller Status "verschoben von" erforderlich, dh ein "leeres" Objekt, das nichts löscht.  Es stellt sich heraus, dass jede C ++ - Klasse einen leeren Zustand haben muss, dh es ist unmöglich, eine Klasse mit einer Invariante (Garantie) der Korrektheit vom Konstruktor zum Destruktor zu erstellen.  Beispielsweise ist es nicht möglich, die richtige <code>open_file</code> Klasse einer Datei zu erstellen, die während ihrer gesamten Lebensdauer geöffnet ist.  Es ist seltsam, dies in einer der wenigen Sprachen zu beobachten, die RAII aktiv verwenden. </p><br><p>  Ein weiteres Problem ist das Nullstellen alter Objekte beim Verschieben, was einen zusätzlichen Aufwand verursacht: Das Füllen von <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> kann bis zu zweimal langsamer sein als <code>std::vector&lt;T*&gt;</code> da alte Zeiger beim Verschieben auf Null gesetzt werden , gefolgt von der Entfernung von Dummies. </p><br><p>  C ++ - Entwickler haben lange an Rust geleckt, wo Destruktoren nicht für verschobene Objekte aufgerufen werden.  Diese Funktion wird als destruktiver Zug bezeichnet.  Leider bietet Proposal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trivially relocatable</a> nicht an, es zu C ++ hinzuzufügen.  Das Overhead-Problem wird jedoch gelöst. </p><br><p>  Eine Klasse wird als trivial verschiebbar angesehen, wenn zwei Vorgänge: Verschieben und Löschen des alten Objekts gleichbedeutend mit memcpy vom alten zum neuen Objekt sind.  Das alte Objekt wird nicht gelöscht, die Autoren nennen es "auf den Boden fallen lassen". </p><br><p>  Ein Typ ist aus Compilersicht trivial verschiebbar, wenn eine der folgenden (rekursiven) Bedingungen erfüllt ist: </p><br><ol><li>  Es ist trivial beweglich + trivial zerstörbar (z. B. <code>int</code> oder POD-Struktur) </li><li>  Dies ist die Klasse, die mit dem Attribut <code>[[trivially_relocatable]]</code> </li><li>  Dies ist eine Klasse, deren Mitglieder alle trivial umsetzbar sind. </li></ol><br><p>  Sie können diese Informationen mit <code>std::uninitialized_relocate</code> , das move init + delete auf die übliche Weise ausführt oder wenn möglich beschleunigt.  Es wird empfohlen, die meisten Typen der Standardbibliothek als <code>[[trivially_relocatable]]</code> zu markieren, einschließlich <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> diesem Hintergrund wird der Vorschlag verschwinden. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  Was ist jetzt mit Ausnahmen los? </h2><br><p>  Der C ++ - Ausnahmemechanismus wurde 1992 entwickelt.  Es wurden verschiedene Implementierungsoptionen vorgeschlagen.  Von diesen wurde ein Ausnahmetabellenmechanismus ausgewählt, der das Fehlen eines Overheads für den Hauptpfad der Programmausführung garantiert.  Denn vom Moment ihrer Entstehung an wurde angenommen, dass <em>Ausnahmen sehr selten ausgelöst werden sollten</em> . </p><br><p>  Nachteile dynamischer (d. H. Regelmäßiger) Ausnahmen: </p><br><ol><li>  Im Fall der ausgelösten Ausnahme beträgt der Overhead im Durchschnitt etwa 10.000 bis 100.000 CPU-Zyklen und kann im schlimmsten Fall die Größenordnung von Millisekunden erreichen </li><li>  Erhöhung der Binärdateigröße um 15-38% </li><li>  Inkompatibilität mit C-Programmierschnittstelle </li><li>  Unterstützung für implizite Ausnahmewürfe in allen Funktionen außer <code>noexcept</code> .  Eine Ausnahme kann fast überall im Programm ausgelöst werden, auch wenn der Funktionsautor dies nicht erwartet </li></ol><br><p>  Aufgrund dieser Mängel ist der Umfang der Ausnahmen erheblich eingeschränkt.  Wenn Ausnahmen nicht gelten können: </p><br><ol><li>  Wo Determinismus wichtig ist, dh wo es nicht akzeptabel ist, dass der Code "manchmal" 10, 100, 1000 Mal langsamer als gewöhnlich arbeitet </li><li>  Wenn sie in ABI nicht unterstützt werden, z. B. in Mikrocontrollern </li><li>  Wenn ein großer Teil des Codes in C geschrieben ist </li><li>  In Unternehmen mit einer großen Menge an Legacy-Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt</a> ).  Wenn der Code mindestens eine nicht ausnahmesichere Funktion enthält, wird gemäß dem Gesetz der Gemeinheit früher oder später eine Ausnahme durch den Code geworfen und ein Fehler verursacht </li><li>  In Unternehmen, die Programmierer einstellen, die keine Ahnung von Ausnahmesicherheit haben </li></ol><br><p>  Umfragen zufolge sind an den Arbeitsplätzen von 52% (!) Entwicklern Ausnahmen nach Unternehmensregeln verboten. </p><br><p>  Ausnahmen sind jedoch ein wesentlicher Bestandteil von C ++!  Durch das <code>-fno-exceptions</code> des <code>-fno-exceptions</code> verlieren Entwickler die Möglichkeit, einen wesentlichen Teil der Standardbibliothek zu verwenden.  Dies regt Unternehmen außerdem dazu an, ihre eigenen „Standardbibliotheken“ einzurichten und ihre eigene String-Klasse zu erfinden. </p><br><p>  Dies ist jedoch nicht das Ende.  Ausnahmen sind die einzige Standardmethode, um die Erstellung eines Objekts im Konstruktor abzubrechen und einen Fehler auszulösen.  Wenn sie ausgeschaltet sind, erscheint ein Gräuel wie eine zweiphasige Initialisierung.  Bediener können auch keine Fehlercodes verwenden, daher werden sie durch Funktionen wie <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Vorschlag: Ausnahmen der Zukunft </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Neuer Ausnahmeübertragungsmechanismus </h3><br><p>  Herb Sutter in P709 beschrieb einen neuen Mechanismus zur Übertragung von Ausnahmen.  Im Prinzip gibt die Funktion <code>std::expected</code> . Anstelle eines separaten Diskriminators vom Typ <code>bool</code> , der zusammen mit der Ausrichtung bis zu 8 Byte auf dem Stapel belegt, wird dieses Informationsbit jedoch schneller an Carry Flag übertragen. </p><br><p>  Funktionen, die CF nicht berühren (die meisten von ihnen), erhalten die Möglichkeit, statische Ausnahmen kostenlos zu verwenden - sowohl bei einer normalen Rückgabe als auch bei einer Ausnahme!  Funktionen, die zum Speichern und Wiederherstellen gezwungen sind, erhalten einen minimalen Overhead und sind weiterhin schneller als <code>std::expected</code> und alle normalen Fehlercodes. </p><br><p>  Statische Ausnahmen sehen folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  In der alternativen Version wird vorgeschlagen, das Schlüsselwort <code>try</code> im selben Ausdruck wie den Funktionsaufruf <code>try i + safe_divide(j, k)</code> zu verpflichten: <code>try i + safe_divide(j, k)</code> .  Dadurch wird die Anzahl der Fälle, in denen <code>throws</code> in Code verwendet werden, der für Ausnahmen nicht sicher ist, auf nahezu Null reduziert.  Im Gegensatz zu dynamischen Ausnahmen kann die IDE in jedem Fall Ausdrücke hervorheben, die Ausnahmen auslösen. </p><br><p>  Die Tatsache, dass die ausgelöste Ausnahme nicht separat gespeichert wird, sondern direkt an die Stelle des zurückgegebenen Werts gesetzt wird, führt zu Einschränkungen hinsichtlich der Art der Ausnahme.  Erstens muss es trivial verlagerbar sein.  Zweitens sollte seine Größe nicht sehr groß sein (aber es kann so etwas wie <code>std::unique_ptr</code> ), sonst reservieren alle Funktionen mehr Platz auf dem Stapel. </p><br><h3 id="status_code">  status_code </h3><br><p>  Die von Niall Douglas entwickelte Bibliothek <code>&lt;system_error2&gt;</code> enthält den <code>status_code&lt;T&gt;</code> - "neuen, besseren" <code>error_code</code> .  Die Hauptunterschiede zu <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - Ein Vorlagentyp, mit dem fast alle denkbaren Fehlercodes (zusammen mit einem Zeiger auf <code>status_code_category</code> ) ohne statische Ausnahmen <code>status_code_category</code> werden können </li><li>  <code>T</code> sollte trivial verlagerbar und kopierbar sein (letzteres, IMHO, sollte nicht obligatorisch sein).  Beim Kopieren und Löschen werden virtuelle Funktionen aus <code>status_code_category</code> </li><li>  <code>status_code</code> kann nicht nur <code>status_code</code> speichern, sondern auch zusätzliche Informationen zu einem erfolgreich abgeschlossenen Vorgang </li><li>  Die "virtuelle" Funktion <code>code.message()</code> gibt nicht <code>std::string</code> , aber <code>string_ref</code> ist ein ziemlich schwerer String-Typ, der eine virtuelle "möglicherweise besitzende" <code>std::string_view</code> .  Dort können Sie <code>string_view</code> oder <code>string</code> oder <code>std::shared_ptr&lt;string&gt;</code> oder eine andere verrückte Art, einen String zu besitzen, <code>string_view</code> .  Niall behauptet, dass <code>#include &lt;string&gt;</code> den Header <code>&lt;system_error2&gt;</code> unannehmbar "schwer" machen würde. </li></ol><br><p>  Als nächstes wird <code>errored_status_code&lt;T&gt;</code> eingegeben - ein Wrapper über <code>status_code&lt;T&gt;</code> mit dem folgenden Konstruktor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  Fehler </h3><br><p>  Der Standardausnahmetyp ( <code>throws</code> ohne Typ) sowie der Grundtyp der Ausnahmen, in die alle anderen umgewandelt werden (wie <code>std::exception</code> ), sind <code>error</code> .  Es ist ungefähr so ​​definiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Das heißt, <code>error</code> ist ein solcher "Fehler" <code>status_code</code> , bei dem der Wert ( <code>value</code> ) in einen Zeiger gesetzt wird.  Da der <code>status_code_category</code> Mechanismus das korrekte Löschen, <code>status_code_category</code> und Kopieren sicherstellt, kann theoretisch jede Datenstruktur <code>error</code> gespeichert <code>error</code> .  In der Praxis ist dies eine der folgenden Optionen: </p><br><ol><li>  Ganzzahlen (int) </li><li>  <code>std::exception_handle</code> , d. h. ein Zeiger auf eine ausgelöste dynamische Ausnahme </li><li>  <code>status_code_ptr</code> , d. <code>status_code_ptr</code> . <code>unique_ptr</code> zu einem beliebigen <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  Das Problem ist, dass Fall 3 nicht geplant ist, um die Möglichkeit zu geben, <code>error</code> auf <code>status_code&lt;T&gt;</code> .  Sie können nur die <code>message()</code> gepackten <code>status_code&lt;T&gt;</code> .  Um den <code>error</code> Wert wieder zurückzubekommen, werfen Sie ihn als dynamische Ausnahme (!). Fangen Sie ihn dann ab und verpacken Sie ihn <code>error</code> .  Im Allgemeinen ist Niall der Ansicht, dass nur Fehlercodes und Zeichenfolgenmeldungen <code>error</code> gespeichert <code>error</code> , was für jedes Programm ausreicht. </p><br><p>  Um zwischen verschiedenen Arten von Fehlern zu unterscheiden, wird vorgeschlagen, den "virtuellen" Vergleichsoperator zu verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  Die Verwendung mehrerer Catch-Blöcke oder <code>dynamic_cast</code> zur Auswahl des Ausnahmetyps <code>dynamic_cast</code> fehl! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaktion mit dynamischen Ausnahmen </h3><br><p>  Eine Funktion kann eine der folgenden Spezifikationen haben: </p><br><ul><li>  <code>noexcept</code> : <code>noexcept</code> keine Ausnahmen aus </li><li>  <code>throws(E)</code> : Wirft nur statische Ausnahmen </li><li>  (nichts): löst nur dynamische Ausnahmen aus </li></ul><br><p>  <code>throws</code> implizieren <code>noexcept</code> .  Wenn eine dynamische Ausnahme von einer "statischen" Funktion ausgelöst wird, wird sie in einen <code>error</code> .  Wenn eine statische Ausnahme von einer "dynamischen" Funktion ausgelöst wird, wird sie in eine <code>status_error</code> Ausnahme eingeschlossen.  Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Ausnahmen in C ?! </h3><br><p>  Der Vorschlag sieht das Hinzufügen von Ausnahmen zu einem der zukünftigen C-Standards vor. Diese Ausnahmen sind ABI-kompatibel mit statischen C ++ - Ausnahmen.  Bei einer ähnlichen Struktur wie <code>std::expected&lt;T, U&gt;</code> muss der Benutzer unabhängig deklarieren, obwohl Redundanz mithilfe von Makros entfernt werden kann.  Die Syntax besteht aus (der Einfachheit halber nehmen wir dies an) den Schlüsselwörtern fehlgeschlagen, fehlgeschlagen, abfangen. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Gleichzeitig ist es in C ++ auch möglich, <code>fails</code> Funktionen von C aus aufzurufen und in <code>extern C</code> Blöcken zu deklarieren.  In C ++ gibt es also eine ganze Galaxie von Schlüsselwörtern für die Arbeit mit Ausnahmen: </p><br><ul><li>  <code>throw()</code> - in C ++ 20 entfernt </li><li>  <code>noexcept</code> - Funktionsspezifizierer, die Funktion löst keine dynamischen Ausnahmen aus </li><li>  <code>noexcept(expression)</code> - Funktionsspezifizierer, die Funktion löst keine bereitgestellten dynamischen Ausnahmen aus </li><li>  <code>noexcept(expression)</code> - <code>noexcept(expression)</code> ein Ausdruck dynamische Ausnahmen? </li><li>  <code>throws(E)</code> - Funktionsspezifizierer, die Funktion löst statische Ausnahmen aus </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - Eine aus C importierte Funktion löst statische Ausnahmen aus </li></ul><br><p>  In C ++ haben sie also einen Wagen mit neuen Tools für die Fehlerbehandlung eingeführt (oder vielmehr geliefert).  Als nächstes stellt sich eine logische Frage: </p><br><h2 id="kogda-chto-ispolzovat">  Wann was verwenden? </h2><br><h3 id="napravlenie-v-celom">  Allgemeine Richtung </h3><br><p>  Fehler sind in mehrere Ebenen unterteilt: </p><br><ul><li>  Programmiererfehler.  Mit Verträgen verarbeitet.  Sie führen zur Erfassung von Protokollen und zur Beendigung des Programms gemäß dem Konzept des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fail-Fast</a> .  Beispiele: Nullzeiger (wenn dieser ungültig ist);  Division durch Null;  Speicherzuordnungsfehler, die vom Programmierer nicht vorhergesehen wurden. </li><li>  Schwerwiegende Fehler des Programmierers.  Wird millionenfach seltener als eine normale Rückgabe einer Funktion ausgegeben, wodurch die Verwendung dynamischer Ausnahmen für sie gerechtfertigt ist.  In solchen Fällen müssen Sie normalerweise das gesamte Subsystem des Programms neu starten oder bei der Ausführung des Vorgangs einen Fehler angeben.  Beispiele: plötzlich verlorene Verbindung zur Datenbank;  Vom Programmierer bereitgestellte Speicherzuordnungsfehler. </li><li>  Behebbare Fehler, wenn <em>etwas</em> die Funktion daran gehindert hat, ihre Aufgabe zu erledigen, die aufrufende Funktion jedoch möglicherweise weiß, was damit zu tun ist.  Wird durch statische Ausnahmen behandelt.  Beispiele: Arbeiten mit dem Dateisystem;  andere Eingabe- / Ausgabefehler (E / A);  Falsche Benutzerdaten  <code>vector::at()</code> . </li><li>  Die Funktion hat ihre Aufgabe erfolgreich abgeschlossen, wenn auch mit einem unerwarteten Ergebnis.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Beispiele: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  In der Standardbibliothek ist es am zuverlässigsten, die Verwendung dynamischer Ausnahmen vollständig aufzugeben, um die Kompilierung "ohne Ausnahmen" legal zu machen. </p><br><h3 id="errno">  errno </h3><br><p>  Funktionen, die <code>errno</code> um schnell und einfach mit C- und C ++ - Fehlercodes zu arbeiten, sollten durch <code>throws(std::errc)</code> <code>fails(int)</code> bzw. <code>throws(std::errc)</code> ersetzt werden.  Für einige Zeit werden die alte und die neue Version der Funktionen der Standardbibliothek nebeneinander existieren, dann wird die alte für veraltet erklärt. </p><br><h3 id="out-of-memory">  Nicht genügend Speicher </h3><br><p>  Speicherzuordnungsfehler werden vom globalen Hook <code>new_handler</code> , der: </p><br><ol><li>  Beseitigen Sie Speichermangel und setzen Sie die Ausführung fort </li><li>  Eine Ausnahme auslösen </li><li>  Absturzprogramm </li></ol><br><p>  Jetzt wird standardmäßig <code>std::bad_alloc</code> ausgelöst.  Es wird empfohlen, standardmäßig <code>std::terminate()</code> aufzurufen.  Wenn Sie das alte Verhalten benötigen, ersetzen Sie den Handler durch den am Anfang von <code>main()</code> . </p><br><p>  Alle vorhandenen Funktionen der Standardbibliothek werden nicht mehr <code>noexcept</code> und stürzen das Programm ab, wenn <code>std::bad_alloc</code> .  Gleichzeitig werden neue APIs wie <code>vector::try_push_back</code> hinzugefügt, die Speicherzuordnungsfehler zulassen. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Ausnahmen <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> melden einen Verstoß gegen eine Funktionsvoraussetzung.  Das neue Fehlermodell sollte stattdessen Verträge verwenden.  Die aufgeführten Arten von Ausnahmen werden <strong>nicht</strong> veraltet sein, aber fast alle Fälle ihrer Verwendung in der Standardbibliothek werden durch <code>[[expects: …]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Aktueller Angebotsstatus </h2><br><p>  Der Vorschlag befindet sich derzeit in einem Entwurfszustand.  Es hat sich bereits sehr verändert und kann sich noch sehr verändern.  Einige Entwicklungen konnten nicht veröffentlicht werden, daher ist die vorgeschlagene API <code>&lt;system_error2&gt;</code> nicht vollständig relevant. </p><br><p>  Der Vorschlag ist in 3 Dokumenten beschrieben: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P709</a> - Originaldokument aus dem Wappen von Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1095</a> - Bestimmte Ausnahmen in Niall Douglas Vision, einige Momente geändert, Kompatibilität mit C-Sprache hinzugefügt </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1028</a> - API aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testimplementierung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> <code>std::error</code> </li></ol><br><p>  Derzeit gibt es keinen Compiler, der statische Ausnahmen unterstützt.  Dementsprechend ist es noch nicht möglich, ihre Benchmarks zu erstellen. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430690/">https://habr.com/ru/post/de430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430680/index.html">Schreiben eines einfachen Prozessors und einer Umgebung dafür</a></li>
<li><a href="../de430682/index.html">Drei Jahre Mond-Mikrosatelliten-Projekt: Stadien des Erwachsenwerdens</a></li>
<li><a href="../de430684/index.html">Scannen von Live Ethereum-Verträgen auf nicht aktivierte Sendefehler. Teil 2</a></li>
<li><a href="../de430686/index.html">Überblick: WAZERs erste Wasserstrahlschneidemaschine</a></li>
<li><a href="../de430688/index.html">Datenübertragung per animiertem QR an Gomobile und GopherJS</a></li>
<li><a href="../de430692/index.html">Social Engineering mit APPX-Software (Universal Windows Platform)</a></li>
<li><a href="../de430694/index.html">Eine kurze Anleitung zum Erlernen von C ++: Was, wann und worauf soll erstellt werden?</a></li>
<li><a href="../de430700/index.html">Ein einheitliches System zur Aufzeichnung von Online-Filmansichten wird in Russland funktionieren</a></li>
<li><a href="../de430702/index.html">Sehr seltsames Training</a></li>
<li><a href="../de430704/index.html">Wie Technologien für künstliche Intelligenz das Wachstum von Aviasales fördern: Sieben Beispiele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>