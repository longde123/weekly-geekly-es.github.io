<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèª üå§Ô∏è üå∫ Deterministische Ausnahmen und Fehlerbehandlung in ‚ÄûC ++ der Zukunft‚Äú üèÆ üåò ‚è≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist seltsam, dass auf Habrt noch kein lauter Vorschlag f√ºr den C ++ - Standard namens "Zero-Overhead-deterministische Ausnahmen" erw√§hnt wurde. Kor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deterministische Ausnahmen und Fehlerbehandlung in ‚ÄûC ++ der Zukunft‚Äú</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Es ist seltsam, dass auf Habrt noch kein lauter Vorschlag f√ºr den C ++ - Standard namens "Zero-Overhead-deterministische Ausnahmen" erw√§hnt wurde.  Korrigieren Sie diese nervige Auslassung. </p><br><p>  Wenn Sie sich Sorgen √ºber den Overhead von Ausnahmen machen oder Code ohne Ausnahmeunterst√ºtzung kompilieren mussten oder sich nur fragen, was mit der Fehlerbehandlung in C ++ 2b passieren wird (ein Verweis auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzlich ver√∂ffentlichten Beitrag</a> ), frage ich nach cat.  Sie warten auf einen Druck auf alles, was jetzt zu diesem Thema zu finden ist, und auf ein paar Umfragen. </p><a name="habracut"></a><br><p> Die folgende Diskussion wird nicht nur √ºber statische Ausnahmen gef√ºhrt, sondern auch √ºber verwandte Vorschl√§ge zum Standard und √ºber alle m√∂glichen anderen M√∂glichkeiten, mit Fehlern umzugehen.  Wenn Sie hierher gekommen sind, um sich die Syntax anzusehen, dann ist es hier: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Wenn der spezifische Fehlertyp unwichtig / unbekannt ist, k√∂nnen Sie einfach <code>throws</code> and <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Gut zu wissen </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> und <code>std::expected</code> </h3><br><p>  Lassen Sie uns entscheiden, dass der Fehler, der m√∂glicherweise in der Funktion auftreten kann, nicht ‚Äûschwerwiegend‚Äú genug ist, um eine Ausnahme auszul√∂sen.  Traditionell werden Fehlerinformationen mithilfe eines out-Parameters zur√ºckgegeben.  Beispielsweise bietet das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateisystem TS</a> eine Reihe √§hnlicher Funktionen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Keine Ausnahme ausl√∂sen, da die Datei nicht gefunden wurde?) Die Verarbeitung von Fehlercodes ist jedoch umst√§ndlich und fehleranf√§llig.  Der Fehlercode kann leicht vergessen werden.  Moderne Codestile <a href="">verbieten die</a> Verwendung von Ausgabeparametern. Stattdessen wird empfohlen, eine Struktur zur√ºckzugeben, die das gesamte Ergebnis enth√§lt. </p><br><p>  Boost bietet seit einiger Zeit eine elegante L√∂sung f√ºr die Behandlung solcher ‚Äûnicht schwerwiegenden‚Äú Fehler, die in bestimmten Szenarien im richtigen Programm zu Hunderten auftreten k√∂nnen: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  Der <code>expected</code> Typ √§hnelt der <code>variant</code> , bietet jedoch eine praktische Schnittstelle f√ºr die Arbeit mit "Ergebnis" und "Fehler".  Standardm√§√üig wird das <code>expected</code> Ergebnis in <code>expected</code> gespeichert.  Die Implementierung von <code>file_size</code> k√∂nnte <code>file_size</code> aussehen: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Wenn die Fehlerursache f√ºr uns nicht interessant ist oder der Fehler nur in der ‚ÄûAbwesenheit‚Äú des Ergebnisses bestehen kann, kann <code>optional</code> verwendet werden: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  In C ++ 17 von Boost kam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optional</a> zu std (ohne Unterst√ºtzung f√ºr <code>optional&lt;T&amp;&gt;</code> );  In C ++ 20 k√∂nnen sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwartete</a> hinzuf√ºgen (dies ist nur Vorschlag, danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">RamzesXI</a> f√ºr die Korrektur). </p><br><h3 id="contracts">  Vertr√§ge </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vertr√§ge</a> (nicht zu verwechseln mit Konzepten) sind eine neue M√∂glichkeit, Funktionsparameter einzuschr√§nken, die in C ++ 20 hinzugef√ºgt wurden.  3 Anmerkungen hinzugef√ºgt: </p><br><ul><li>  <strong>erwartet</strong> pr√ºft Funktionsparameter </li><li>  <strong>stellt sicher</strong> , dass der R√ºckgabewert der Funktion √ºberpr√ºft wird (nimmt ihn als Argument) </li><li>  <strong>assert</strong> - ein zivilisierter Ersatz f√ºr das Makro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Sie k√∂nnen f√ºr Vertragsbruch konfigurieren: </p><br><ul><li>  Undefiniertes Verhalten genannt, oder </li><li>  Es √ºberpr√ºfte und rief den User-Exit auf, wonach <code>std::terminate</code> </li></ul><br><p>  Es ist unm√∂glich, das Programm nach Vertragsbruch weiter auszuf√ºhren, da Compiler Garantien aus Vertr√§gen verwenden, um den Funktionscode zu optimieren.  Im geringsten Zweifel an der Vertragserf√ºllung lohnt es sich, einen zus√§tzlichen Scheck hinzuzuf√ºgen. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  Mit der in C ++ 11 hinzugef√ºgten Bibliothek <code>&lt;system_error&gt;</code> k√∂nnen Sie die Behandlung von Fehlercodes in Ihrem Programm standardisieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: error_code</a> besteht aus einem Fehlercode vom Typ <code>int</code> und einem Zeiger auf das Objekt einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untergeordneten Klasse std :: error_category</a> .  Dieses Objekt spielt tats√§chlich die Rolle einer Tabelle virtueller Funktionen und bestimmt das Verhalten eines bestimmten <code>std::error_code</code> . </p><br><p>  Um Ihren <code>std::error_code</code> zu erstellen, m√ºssen Sie <code>std::error_category</code> Nachkommenklasse <code>std::error_category</code> definieren und virtuelle Methoden implementieren. Die wichtigste davon ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Sie m√ºssen auch eine globale Variable f√ºr Ihre <code>std::error_category</code> .  Die Fehlerbehandlung mit error_code + expected sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Es ist wichtig, dass in <code>std::error_code</code> Wert von 0 keinen Fehler bedeutet.  Wenn dies bei Ihren Fehlercodes nicht der Fall ist, m√ºssen Sie vor der Konvertierung des Systemfehlercodes in <code>std::error_code</code> den Code 0 durch SUCCESS ersetzen und umgekehrt. </p><br><p>  Alle Systemfehlercodes werden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">errc</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">system_category beschrieben</a> .  Wenn zu einem bestimmten Zeitpunkt die manuelle Weiterleitung der Fehlercodes zu trostlos wird, k√∂nnen Sie den Fehlercode jederzeit in die <code>std::system_error</code> und wegwerfen. </p><br><h3 id="destructive-move--trivially-relocatable">  Zerst√∂rerische Bewegung / Trivial umsetzbar </h3><br><p>  Sie m√ºssen eine andere Klasse von Objekten erstellen, die einige Ressourcen besitzen.  H√∂chstwahrscheinlich m√∂chten Sie es nicht kopierbar, sondern verschiebbar machen, da die Arbeit mit nicht verschiebbaren Objekten unpraktisch ist (vor C ++ 17 konnten sie nicht von einer Funktion zur√ºckgegeben werden). </p><br><p>  Aber hier ist das Problem: In jedem Fall muss das verschobene Objekt gel√∂scht werden.  Daher ist ein spezieller Status "verschoben von" erforderlich, dh ein "leeres" Objekt, das nichts l√∂scht.  Es stellt sich heraus, dass jede C ++ - Klasse einen leeren Zustand haben muss, dh es ist unm√∂glich, eine Klasse mit einer Invariante (Garantie) der Korrektheit vom Konstruktor zum Destruktor zu erstellen.  Beispielsweise ist es nicht m√∂glich, die richtige <code>open_file</code> Klasse einer Datei zu erstellen, die w√§hrend ihrer gesamten Lebensdauer ge√∂ffnet ist.  Es ist seltsam, dies in einer der wenigen Sprachen zu beobachten, die RAII aktiv verwenden. </p><br><p>  Ein weiteres Problem ist das Nullstellen alter Objekte beim Verschieben, was einen zus√§tzlichen Aufwand verursacht: Das F√ºllen von <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> kann bis zu zweimal langsamer sein als <code>std::vector&lt;T*&gt;</code> da alte Zeiger beim Verschieben auf Null gesetzt werden , gefolgt von der Entfernung von Dummies. </p><br><p>  C ++ - Entwickler haben lange an Rust geleckt, wo Destruktoren nicht f√ºr verschobene Objekte aufgerufen werden.  Diese Funktion wird als destruktiver Zug bezeichnet.  Leider bietet Proposal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trivially relocatable</a> nicht an, es zu C ++ hinzuzuf√ºgen.  Das Overhead-Problem wird jedoch gel√∂st. </p><br><p>  Eine Klasse wird als trivial verschiebbar angesehen, wenn zwei Vorg√§nge: Verschieben und L√∂schen des alten Objekts gleichbedeutend mit memcpy vom alten zum neuen Objekt sind.  Das alte Objekt wird nicht gel√∂scht, die Autoren nennen es "auf den Boden fallen lassen". </p><br><p>  Ein Typ ist aus Compilersicht trivial verschiebbar, wenn eine der folgenden (rekursiven) Bedingungen erf√ºllt ist: </p><br><ol><li>  Es ist trivial beweglich + trivial zerst√∂rbar (z. B. <code>int</code> oder POD-Struktur) </li><li>  Dies ist die Klasse, die mit dem Attribut <code>[[trivially_relocatable]]</code> </li><li>  Dies ist eine Klasse, deren Mitglieder alle trivial umsetzbar sind. </li></ol><br><p>  Sie k√∂nnen diese Informationen mit <code>std::uninitialized_relocate</code> , das move init + delete auf die √ºbliche Weise ausf√ºhrt oder wenn m√∂glich beschleunigt.  Es wird empfohlen, die meisten Typen der Standardbibliothek als <code>[[trivially_relocatable]]</code> zu markieren, einschlie√ülich <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> diesem Hintergrund wird der Vorschlag verschwinden. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  Was ist jetzt mit Ausnahmen los? </h2><br><p>  Der C ++ - Ausnahmemechanismus wurde 1992 entwickelt.  Es wurden verschiedene Implementierungsoptionen vorgeschlagen.  Von diesen wurde ein Ausnahmetabellenmechanismus ausgew√§hlt, der das Fehlen eines Overheads f√ºr den Hauptpfad der Programmausf√ºhrung garantiert.  Denn vom Moment ihrer Entstehung an wurde angenommen, dass <em>Ausnahmen sehr selten ausgel√∂st werden sollten</em> . </p><br><p>  Nachteile dynamischer (d. H. Regelm√§√üiger) Ausnahmen: </p><br><ol><li>  Im Fall der ausgel√∂sten Ausnahme betr√§gt der Overhead im Durchschnitt etwa 10.000 bis 100.000 CPU-Zyklen und kann im schlimmsten Fall die Gr√∂√üenordnung von Millisekunden erreichen </li><li>  Erh√∂hung der Bin√§rdateigr√∂√üe um 15-38% </li><li>  Inkompatibilit√§t mit C-Programmierschnittstelle </li><li>  Unterst√ºtzung f√ºr implizite Ausnahmew√ºrfe in allen Funktionen au√üer <code>noexcept</code> .  Eine Ausnahme kann fast √ºberall im Programm ausgel√∂st werden, auch wenn der Funktionsautor dies nicht erwartet </li></ol><br><p>  Aufgrund dieser M√§ngel ist der Umfang der Ausnahmen erheblich eingeschr√§nkt.  Wenn Ausnahmen nicht gelten k√∂nnen: </p><br><ol><li>  Wo Determinismus wichtig ist, dh wo es nicht akzeptabel ist, dass der Code "manchmal" 10, 100, 1000 Mal langsamer als gew√∂hnlich arbeitet </li><li>  Wenn sie in ABI nicht unterst√ºtzt werden, z. B. in Mikrocontrollern </li><li>  Wenn ein gro√üer Teil des Codes in C geschrieben ist </li><li>  In Unternehmen mit einer gro√üen Menge an Legacy-Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt</a> ).  Wenn der Code mindestens eine nicht ausnahmesichere Funktion enth√§lt, wird gem√§√ü dem Gesetz der Gemeinheit fr√ºher oder sp√§ter eine Ausnahme durch den Code geworfen und ein Fehler verursacht </li><li>  In Unternehmen, die Programmierer einstellen, die keine Ahnung von Ausnahmesicherheit haben </li></ol><br><p>  Umfragen zufolge sind an den Arbeitspl√§tzen von 52% (!) Entwicklern Ausnahmen nach Unternehmensregeln verboten. </p><br><p>  Ausnahmen sind jedoch ein wesentlicher Bestandteil von C ++!  Durch das <code>-fno-exceptions</code> des <code>-fno-exceptions</code> verlieren Entwickler die M√∂glichkeit, einen wesentlichen Teil der Standardbibliothek zu verwenden.  Dies regt Unternehmen au√üerdem dazu an, ihre eigenen ‚ÄûStandardbibliotheken‚Äú einzurichten und ihre eigene String-Klasse zu erfinden. </p><br><p>  Dies ist jedoch nicht das Ende.  Ausnahmen sind die einzige Standardmethode, um die Erstellung eines Objekts im Konstruktor abzubrechen und einen Fehler auszul√∂sen.  Wenn sie ausgeschaltet sind, erscheint ein Gr√§uel wie eine zweiphasige Initialisierung.  Bediener k√∂nnen auch keine Fehlercodes verwenden, daher werden sie durch Funktionen wie <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Vorschlag: Ausnahmen der Zukunft </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Neuer Ausnahme√ºbertragungsmechanismus </h3><br><p>  Herb Sutter in P709 beschrieb einen neuen Mechanismus zur √úbertragung von Ausnahmen.  Im Prinzip gibt die Funktion <code>std::expected</code> . Anstelle eines separaten Diskriminators vom Typ <code>bool</code> , der zusammen mit der Ausrichtung bis zu 8 Byte auf dem Stapel belegt, wird dieses Informationsbit jedoch schneller an Carry Flag √ºbertragen. </p><br><p>  Funktionen, die CF nicht ber√ºhren (die meisten von ihnen), erhalten die M√∂glichkeit, statische Ausnahmen kostenlos zu verwenden - sowohl bei einer normalen R√ºckgabe als auch bei einer Ausnahme!  Funktionen, die zum Speichern und Wiederherstellen gezwungen sind, erhalten einen minimalen Overhead und sind weiterhin schneller als <code>std::expected</code> und alle normalen Fehlercodes. </p><br><p>  Statische Ausnahmen sehen folgenderma√üen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  In der alternativen Version wird vorgeschlagen, das Schl√ºsselwort <code>try</code> im selben Ausdruck wie den Funktionsaufruf <code>try i + safe_divide(j, k)</code> zu verpflichten: <code>try i + safe_divide(j, k)</code> .  Dadurch wird die Anzahl der F√§lle, in denen <code>throws</code> in Code verwendet werden, der f√ºr Ausnahmen nicht sicher ist, auf nahezu Null reduziert.  Im Gegensatz zu dynamischen Ausnahmen kann die IDE in jedem Fall Ausdr√ºcke hervorheben, die Ausnahmen ausl√∂sen. </p><br><p>  Die Tatsache, dass die ausgel√∂ste Ausnahme nicht separat gespeichert wird, sondern direkt an die Stelle des zur√ºckgegebenen Werts gesetzt wird, f√ºhrt zu Einschr√§nkungen hinsichtlich der Art der Ausnahme.  Erstens muss es trivial verlagerbar sein.  Zweitens sollte seine Gr√∂√üe nicht sehr gro√ü sein (aber es kann so etwas wie <code>std::unique_ptr</code> ), sonst reservieren alle Funktionen mehr Platz auf dem Stapel. </p><br><h3 id="status_code">  status_code </h3><br><p>  Die von Niall Douglas entwickelte Bibliothek <code>&lt;system_error2&gt;</code> enth√§lt den <code>status_code&lt;T&gt;</code> - "neuen, besseren" <code>error_code</code> .  Die Hauptunterschiede zu <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - Ein Vorlagentyp, mit dem fast alle denkbaren Fehlercodes (zusammen mit einem Zeiger auf <code>status_code_category</code> ) ohne statische Ausnahmen <code>status_code_category</code> werden k√∂nnen </li><li>  <code>T</code> sollte trivial verlagerbar und kopierbar sein (letzteres, IMHO, sollte nicht obligatorisch sein).  Beim Kopieren und L√∂schen werden virtuelle Funktionen aus <code>status_code_category</code> </li><li>  <code>status_code</code> kann nicht nur <code>status_code</code> speichern, sondern auch zus√§tzliche Informationen zu einem erfolgreich abgeschlossenen Vorgang </li><li>  Die "virtuelle" Funktion <code>code.message()</code> gibt nicht <code>std::string</code> , aber <code>string_ref</code> ist ein ziemlich schwerer String-Typ, der eine virtuelle "m√∂glicherweise besitzende" <code>std::string_view</code> .  Dort k√∂nnen Sie <code>string_view</code> oder <code>string</code> oder <code>std::shared_ptr&lt;string&gt;</code> oder eine andere verr√ºckte Art, einen String zu besitzen, <code>string_view</code> .  Niall behauptet, dass <code>#include &lt;string&gt;</code> den Header <code>&lt;system_error2&gt;</code> unannehmbar "schwer" machen w√ºrde. </li></ol><br><p>  Als n√§chstes wird <code>errored_status_code&lt;T&gt;</code> eingegeben - ein Wrapper √ºber <code>status_code&lt;T&gt;</code> mit dem folgenden Konstruktor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  Fehler </h3><br><p>  Der Standardausnahmetyp ( <code>throws</code> ohne Typ) sowie der Grundtyp der Ausnahmen, in die alle anderen umgewandelt werden (wie <code>std::exception</code> ), sind <code>error</code> .  Es ist ungef√§hr so ‚Äã‚Äãdefiniert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Das hei√üt, <code>error</code> ist ein solcher "Fehler" <code>status_code</code> , bei dem der Wert ( <code>value</code> ) in einen Zeiger gesetzt wird.  Da der <code>status_code_category</code> Mechanismus das korrekte L√∂schen, <code>status_code_category</code> und Kopieren sicherstellt, kann theoretisch jede Datenstruktur <code>error</code> gespeichert <code>error</code> .  In der Praxis ist dies eine der folgenden Optionen: </p><br><ol><li>  Ganzzahlen (int) </li><li>  <code>std::exception_handle</code> , d. h. ein Zeiger auf eine ausgel√∂ste dynamische Ausnahme </li><li>  <code>status_code_ptr</code> , d. <code>status_code_ptr</code> . <code>unique_ptr</code> zu einem beliebigen <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  Das Problem ist, dass Fall 3 nicht geplant ist, um die M√∂glichkeit zu geben, <code>error</code> auf <code>status_code&lt;T&gt;</code> .  Sie k√∂nnen nur die <code>message()</code> gepackten <code>status_code&lt;T&gt;</code> .  Um den <code>error</code> Wert wieder zur√ºckzubekommen, werfen Sie ihn als dynamische Ausnahme (!). Fangen Sie ihn dann ab und verpacken Sie ihn <code>error</code> .  Im Allgemeinen ist Niall der Ansicht, dass nur Fehlercodes und Zeichenfolgenmeldungen <code>error</code> gespeichert <code>error</code> , was f√ºr jedes Programm ausreicht. </p><br><p>  Um zwischen verschiedenen Arten von Fehlern zu unterscheiden, wird vorgeschlagen, den "virtuellen" Vergleichsoperator zu verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  Die Verwendung mehrerer Catch-Bl√∂cke oder <code>dynamic_cast</code> zur Auswahl des Ausnahmetyps <code>dynamic_cast</code> fehl! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaktion mit dynamischen Ausnahmen </h3><br><p>  Eine Funktion kann eine der folgenden Spezifikationen haben: </p><br><ul><li>  <code>noexcept</code> : <code>noexcept</code> keine Ausnahmen aus </li><li>  <code>throws(E)</code> : Wirft nur statische Ausnahmen </li><li>  (nichts): l√∂st nur dynamische Ausnahmen aus </li></ul><br><p>  <code>throws</code> implizieren <code>noexcept</code> .  Wenn eine dynamische Ausnahme von einer "statischen" Funktion ausgel√∂st wird, wird sie in einen <code>error</code> .  Wenn eine statische Ausnahme von einer "dynamischen" Funktion ausgel√∂st wird, wird sie in eine <code>status_error</code> Ausnahme eingeschlossen.  Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Ausnahmen in C ?! </h3><br><p>  Der Vorschlag sieht das Hinzuf√ºgen von Ausnahmen zu einem der zuk√ºnftigen C-Standards vor. Diese Ausnahmen sind ABI-kompatibel mit statischen C ++ - Ausnahmen.  Bei einer √§hnlichen Struktur wie <code>std::expected&lt;T, U&gt;</code> muss der Benutzer unabh√§ngig deklarieren, obwohl Redundanz mithilfe von Makros entfernt werden kann.  Die Syntax besteht aus (der Einfachheit halber nehmen wir dies an) den Schl√ºsselw√∂rtern fehlgeschlagen, fehlgeschlagen, abfangen. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Gleichzeitig ist es in C ++ auch m√∂glich, <code>fails</code> Funktionen von C aus aufzurufen und in <code>extern C</code> Bl√∂cken zu deklarieren.  In C ++ gibt es also eine ganze Galaxie von Schl√ºsselw√∂rtern f√ºr die Arbeit mit Ausnahmen: </p><br><ul><li>  <code>throw()</code> - in C ++ 20 entfernt </li><li>  <code>noexcept</code> - Funktionsspezifizierer, die Funktion l√∂st keine dynamischen Ausnahmen aus </li><li>  <code>noexcept(expression)</code> - Funktionsspezifizierer, die Funktion l√∂st keine bereitgestellten dynamischen Ausnahmen aus </li><li>  <code>noexcept(expression)</code> - <code>noexcept(expression)</code> ein Ausdruck dynamische Ausnahmen? </li><li>  <code>throws(E)</code> - Funktionsspezifizierer, die Funktion l√∂st statische Ausnahmen aus </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - Eine aus C importierte Funktion l√∂st statische Ausnahmen aus </li></ul><br><p>  In C ++ haben sie also einen Wagen mit neuen Tools f√ºr die Fehlerbehandlung eingef√ºhrt (oder vielmehr geliefert).  Als n√§chstes stellt sich eine logische Frage: </p><br><h2 id="kogda-chto-ispolzovat">  Wann was verwenden? </h2><br><h3 id="napravlenie-v-celom">  Allgemeine Richtung </h3><br><p>  Fehler sind in mehrere Ebenen unterteilt: </p><br><ul><li>  Programmiererfehler.  Mit Vertr√§gen verarbeitet.  Sie f√ºhren zur Erfassung von Protokollen und zur Beendigung des Programms gem√§√ü dem Konzept des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fail-Fast</a> .  Beispiele: Nullzeiger (wenn dieser ung√ºltig ist);  Division durch Null;  Speicherzuordnungsfehler, die vom Programmierer nicht vorhergesehen wurden. </li><li>  Schwerwiegende Fehler des Programmierers.  Wird millionenfach seltener als eine normale R√ºckgabe einer Funktion ausgegeben, wodurch die Verwendung dynamischer Ausnahmen f√ºr sie gerechtfertigt ist.  In solchen F√§llen m√ºssen Sie normalerweise das gesamte Subsystem des Programms neu starten oder bei der Ausf√ºhrung des Vorgangs einen Fehler angeben.  Beispiele: pl√∂tzlich verlorene Verbindung zur Datenbank;  Vom Programmierer bereitgestellte Speicherzuordnungsfehler. </li><li>  Behebbare Fehler, wenn <em>etwas</em> die Funktion daran gehindert hat, ihre Aufgabe zu erledigen, die aufrufende Funktion jedoch m√∂glicherweise wei√ü, was damit zu tun ist.  Wird durch statische Ausnahmen behandelt.  Beispiele: Arbeiten mit dem Dateisystem;  andere Eingabe- / Ausgabefehler (E / A);  Falsche Benutzerdaten  <code>vector::at()</code> . </li><li>  Die Funktion hat ihre Aufgabe erfolgreich abgeschlossen, wenn auch mit einem unerwarteten Ergebnis.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Beispiele: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  In der Standardbibliothek ist es am zuverl√§ssigsten, die Verwendung dynamischer Ausnahmen vollst√§ndig aufzugeben, um die Kompilierung "ohne Ausnahmen" legal zu machen. </p><br><h3 id="errno">  errno </h3><br><p>  Funktionen, die <code>errno</code> um schnell und einfach mit C- und C ++ - Fehlercodes zu arbeiten, sollten durch <code>throws(std::errc)</code> <code>fails(int)</code> bzw. <code>throws(std::errc)</code> ersetzt werden.  F√ºr einige Zeit werden die alte und die neue Version der Funktionen der Standardbibliothek nebeneinander existieren, dann wird die alte f√ºr veraltet erkl√§rt. </p><br><h3 id="out-of-memory">  Nicht gen√ºgend Speicher </h3><br><p>  Speicherzuordnungsfehler werden vom globalen Hook <code>new_handler</code> , der: </p><br><ol><li>  Beseitigen Sie Speichermangel und setzen Sie die Ausf√ºhrung fort </li><li>  Eine Ausnahme ausl√∂sen </li><li>  Absturzprogramm </li></ol><br><p>  Jetzt wird standardm√§√üig <code>std::bad_alloc</code> ausgel√∂st.  Es wird empfohlen, standardm√§√üig <code>std::terminate()</code> aufzurufen.  Wenn Sie das alte Verhalten ben√∂tigen, ersetzen Sie den Handler durch den am Anfang von <code>main()</code> . </p><br><p>  Alle vorhandenen Funktionen der Standardbibliothek werden nicht mehr <code>noexcept</code> und st√ºrzen das Programm ab, wenn <code>std::bad_alloc</code> .  Gleichzeitig werden neue APIs wie <code>vector::try_push_back</code> hinzugef√ºgt, die Speicherzuordnungsfehler zulassen. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Ausnahmen <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> melden einen Versto√ü gegen eine Funktionsvoraussetzung.  Das neue Fehlermodell sollte stattdessen Vertr√§ge verwenden.  Die aufgef√ºhrten Arten von Ausnahmen werden <strong>nicht</strong> veraltet sein, aber fast alle F√§lle ihrer Verwendung in der Standardbibliothek werden durch <code>[[expects: ‚Ä¶]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Aktueller Angebotsstatus </h2><br><p>  Der Vorschlag befindet sich derzeit in einem Entwurfszustand.  Es hat sich bereits sehr ver√§ndert und kann sich noch sehr ver√§ndern.  Einige Entwicklungen konnten nicht ver√∂ffentlicht werden, daher ist die vorgeschlagene API <code>&lt;system_error2&gt;</code> nicht vollst√§ndig relevant. </p><br><p>  Der Vorschlag ist in 3 Dokumenten beschrieben: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P709</a> - Originaldokument aus dem Wappen von Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1095</a> - Bestimmte Ausnahmen in Niall Douglas Vision, einige Momente ge√§ndert, Kompatibilit√§t mit C-Sprache hinzugef√ºgt </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1028</a> - API aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testimplementierung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> <code>std::error</code> </li></ol><br><p>  Derzeit gibt es keinen Compiler, der statische Ausnahmen unterst√ºtzt.  Dementsprechend ist es noch nicht m√∂glich, ihre Benchmarks zu erstellen. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430690/">https://habr.com/ru/post/de430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430680/index.html">Schreiben eines einfachen Prozessors und einer Umgebung daf√ºr</a></li>
<li><a href="../de430682/index.html">Drei Jahre Mond-Mikrosatelliten-Projekt: Stadien des Erwachsenwerdens</a></li>
<li><a href="../de430684/index.html">Scannen von Live Ethereum-Vertr√§gen auf nicht aktivierte Sendefehler. Teil 2</a></li>
<li><a href="../de430686/index.html">√úberblick: WAZERs erste Wasserstrahlschneidemaschine</a></li>
<li><a href="../de430688/index.html">Daten√ºbertragung per animiertem QR an Gomobile und GopherJS</a></li>
<li><a href="../de430692/index.html">Social Engineering mit APPX-Software (Universal Windows Platform)</a></li>
<li><a href="../de430694/index.html">Eine kurze Anleitung zum Erlernen von C ++: Was, wann und worauf soll erstellt werden?</a></li>
<li><a href="../de430700/index.html">Ein einheitliches System zur Aufzeichnung von Online-Filmansichten wird in Russland funktionieren</a></li>
<li><a href="../de430702/index.html">Sehr seltsames Training</a></li>
<li><a href="../de430704/index.html">Wie Technologien f√ºr k√ºnstliche Intelligenz das Wachstum von Aviasales f√∂rdern: Sieben Beispiele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>