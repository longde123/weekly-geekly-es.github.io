<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ üëú üìå dies und ScopeChain in EcmaScript üë©üèø‚Äçü§ù‚Äçüë®üèΩ üê± ü§ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 In einem fr√ºheren Artikel haben wir die allgemeine Theorie von OOP in Bezug auf EcmaScript und den popul√§ren Irrtum von unerfahrenen En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>dies und ScopeChain in EcmaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468943/"> Hallo Habr! <br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel haben</a> wir die allgemeine Theorie von OOP in Bezug auf EcmaScript und den popul√§ren Irrtum von unerfahrenen Entwicklern hinsichtlich der Unterschiede zwischen OOP in JS und klassischen Sprachen untersucht. <br><br>  Heute werden wir √ºber zwei andere gleich wichtige EcmaScript-Konzepte sprechen, n√§mlich die Beziehung der Entit√§t zum Ausf√ºhrungskontext ( <b>dies</b> ist diese Verbindung) und die Beziehung der Entit√§t zum generierenden Kontext ( <b>ScopeChain</b> ). <br><br>  Also fangen wir an! <br><br><h3>  das </h3><br>  Bei Interviews als Antwort auf die Frage: "Erz√§hlen Sie uns mehr dar√ºber."  Anf√§ngerentwickler geben in der Regel sehr vage Antworten: " <i>Dies</i> ist das Objekt" vor dem Punkt ", mit dem die Methode aufgerufen wurde", " <i>Dies</i> ist der Kontext, in dem die Funktion aufgerufen wurde" usw. ... <br><br>  Tats√§chlich ist die Situation mit diesem Konzept, das f√ºr EcmaScript von zentraler Bedeutung ist, etwas komplizierter.  Lassen Sie es uns in der richtigen Reihenfolge herausfinden. <br><br>  Angenommen, wir haben ein JavaScript-Programm, dessen Variablen global deklariert sind.  globale Funktionen;  lokale Funktionen (innerhalb anderer Funktionen deklariert), von Funktionen zur√ºckgegebene Funktionen. <br><a name="habracut"></a><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBaz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } fooBar()();</code> </pre> <br>  Bei der √úbertragung der Steuerung auf den ausf√ºhrbaren Code wird ein Eintrag in den Ausf√ºhrungskontext vorgenommen.  Ausf√ºhrbarer Code - Dies ist jeder Code, den wir zu einem bestimmten Zeitpunkt ausf√ºhren. Es kann sich um einen globalen Code oder einen Code einer beliebigen Funktion handeln. <br><br>  <b>Der Ausf√ºhrungskontext</b> ist eine Abstraktion, die Code typisiert und begrenzt.  Unter dem Gesichtspunkt dieser Abstraktion ist der Code in globalen (alle verbundenen Skripte, Inline-Skripte) und Funktionscode (der Code verschachtelter Funktionen geh√∂rt nicht zum Kontext √ºbergeordneter Funktionen) unterteilt. <br><br>  Es gibt einen dritten Typ - EvalCode.  In diesem Artikel vernachl√§ssigen wir es. <br><br>  Logischerweise ist die Menge der Ausf√ºhrungskontexte ein <b>Stapel</b> , der nach dem Prinzip des Last-in-First-out (lifo) arbeitet.  Das Ende des Stapels ist immer der globale Kontext, und das Ende ist die aktuelle ausf√ºhrbare Datei.  Bei jedem Aufruf einer Funktion wird ein Eintrag in ihren Kontext vorgenommen.  Wenn eine Funktion abgeschlossen ist, endet ihr Kontext.  Verbrauchte Kontexte werden nacheinander und in umgekehrter Reihenfolge vom Stapel entfernt. <br><br>  Schauen Sie sich den obigen Code an.  Wir haben einen Aufruf der Funktion <b>fooBar</b> im globalen Code.  In der Funktion <b>fooBar geben</b> wir <b>eine anonyme Funktion zur√ºck</b> , die wir sofort aufrufen.  Die folgenden √Ñnderungen treten beim Stapel auf: Ein <b>globaler Kontext</b> wird in ihn <b>eingef√ºgt</b> - wenn <b>fooBar</b> aufgerufen wird <b>, wird</b> sein Kontext in den Stapel aufgenommen - <b>fooBar wird</b> beendet, gibt <b>eine anonyme Funktion zur√ºck</b> und wird aus dem Stapel entfernt - eine <b>anonyme Funktion</b> wird aufgerufen, ihr Kontext wird in den Stapel aufgenommen - eine <b>anonyme Funktion</b> erf√ºllt, gibt einen Wert zur√ºck und sein Kontext wird aus dem Stapel gel√∂scht - am Ende des Skripts wird der <b>globale Kontext</b> aus dem Stapel gel√∂scht. <br><cut></cut><br>  Der Ausf√ºhrungskontext kann bedingt als Objekt dargestellt werden.  Eine der Eigenschaften dieses Objekts ist die Lexical Environment (LO). <br><br>  <b>Die lexikalische Umgebung</b> enth√§lt: <br><br><ul><li>  alle Kontextvariablendeklarationen </li><li>  alle Funktionsdeklarationen </li><li>  alle formalen Parameter der Funktion (wenn wir √ºber den Kontext von Funktionen sprechen) </li></ul><br>  Bei der Eingabe des Ausf√ºhrungskontexts scannt der Interpreter den Kontext.  Alle Variablendeklarationen und Funktionsdeklarationen stehen am Anfang des Kontexts.  Variablen werden gleich undefiniert erstellt und Funktionen sind vollst√§ndig einsatzbereit. <br><br>  <b>Dies ist</b> auch eine Eigenschaft des Ausf√ºhrungskontexts, aber nicht des Kontexts selbst, wie einige unerfahrene Interviewer antworten!  <b>Dies wird</b> beim Eingeben des Kontexts definiert und bleibt bis zum Ende der Lebensdauer des Kontexts unver√§ndert (bis der Kontext vom Stapel entfernt wird). <br><br>  Im globalen Ausf√ºhrungskontext wird <b>dies</b> durch den <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strengen Modus bestimmt</a></b> : Wenn der strenge Modus deaktiviert ist, enth√§lt dieser ein globales Objekt (im Browser wird es auf die oberste Ebene im Fensterobjekt √ºbertragen), wobei 'use strict' undefiniert ist. <br><cut></cut><br>  <b>dies</b> im Kontext von Funktionen - die Frage ist viel interessanter! <br>  Diese Funktion wird vom Aufrufer festgelegt und h√§ngt von der Syntax des Aufrufs ab.  Wie wir wissen, gibt es beispielsweise Methoden, mit denen dies beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> starr festgelegt werden kann ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwenden</a> ), und eine Methode, mit der Sie einen Wrapper mit "Fixed This" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binden</a> ) erstellen k√∂nnen.  In diesen Situationen geben wir dies ausdr√ºcklich an und es kann kein Zweifel an seiner Definition bestehen. <br><br>  Bei einem normalen Funktionsaufruf ist die Situation viel komplizierter! <br><br>  Einer der in EcmaScript integrierten Typen, <b>ReferenceType</b> , hilft uns zu verstehen, wie dies in Funktionen angebracht ist.  Dies ist einer der internen Typen, die auf Implementierungsebene verf√ºgbar sind.  Logischerweise handelt es sich um ein Objekt mit zwei Eigenschaften <b>base</b> (eine Referenz auf ein bestimmtes Basisobjekt, f√ºr das ein ReferenceType zur√ºckgegeben wird), <b>propertyName</b> (eine Zeichenfolgendarstellung des Bezeichners des Objekts, f√ºr das ein ReferenceType zur√ºckgegeben wird). <br><br>  <b>ReferenceType wird</b> f√ºr alle Variablendeklarationen, Funktionsdeklarationen und Eigenschaftsreferenzen zur√ºckgegeben (dies ist der Fall, der uns unter dem Gesichtspunkt des Verst√§ndnisses interessiert). <br><br>  Die Regel, um <b>dies</b> f√ºr Funktionen zu definieren, die auf die √ºbliche Weise aufgerufen werden: <br>  <i>Befindet sich der <b>ReferenceType</b> links von den Aktivierungsklammern der Funktion, wird die <b>Basis</b> dieses <b>ReferenceType</b> in <code>this</code> Funktion eingef√ºgt.</i>  <i>Befindet sich ein anderer Typ links von den Klammern, <code>this</code> es sich entweder um ein globales Objekt oder um ein <code>undefined</code> Objekt (tats√§chlich <code>null</code> , aber da null aus Sicht von Ecmascript keinen bestimmten Wert hat, wird es in ein globales Objekt umgewandelt, auf das m√∂glicherweise verwiesen wird entspricht <code>undefined</code> je nach striktem Modus).</i> <br><br>  Schauen wir uns ein Beispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo();<span class="hljs-comment"><span class="hljs-comment">//  10 ..    ReferenceType  base     obj const test = obj.foo;//       test();//  0 ..  test()   .test(),..  base    ,       0.</span></span></code> </pre><br>  Ich denke, die Definitionsmethode ist klar dargestellt.  Betrachten Sie nun einige weniger offensichtliche F√§lle. <br><br><h4>  Funktionsausdr√ºcke </h4><br>  Kehren wir f√ºr eine Sekunde zu unserem Referenztyp zur√ºck.  Dieser Typ verf√ºgt √ºber eine integrierte <b>GetValue-</b> Methode, die den wahren Typ des √ºber den ReferenceType empfangenen Objekts zur√ºckgibt.  In der Ausdruckszone wird GetValue immer ausgel√∂st. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;<span class="hljs-comment"><span class="hljs-comment">// this     undefined    strict mode })()</span></span></code> </pre><br>  Dies liegt daran, dass GetValue immer in der Ausdruckszone ausgel√∂st wird.  GetValue gibt einen Funktionstyp zur√ºck und links von den Aktivierungsklammern befindet sich kein ReferenceType.  Erinnern Sie sich an unsere Regel, um <b>dies</b> zu bestimmen: <i>Wenn sich ein anderer Typ links von den Klammern befindet, wird ein globales Objekt in <code>this</code> oder <code>undefined</code> (tats√§chlich <code>null</code> , aber da null aus Sicht von Ecmascript keinen bestimmten Wert hat, wird es in ein globales Objekt konvertiert , dessen Verkn√ºpfung je nach striktem Modus gleich undefiniert sein kann)</i> . <br><br>  Ausdruckszonen sind: Zuweisung (=), Operatoren ||  oder andere logische Operatoren, tern√§rer Operator, Array-Initialisierer, durch Kommas getrennte Liste. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo(); <span class="hljs-comment"><span class="hljs-comment">//        //  ? (obj.foo)(); // ,    , GetValue   // ? (obj.foo = obj.foo)(); //        GetValue,     Fuction,   ReferenceType,   0   (   this) //  ||    ,    ..? (obj.foo || obj.foo)();// 0    ,     //  [obj.foo][0]();// 0    ,     // ..</span></span></code> </pre><br>  Identische Situation in benannten funktionalen Ausdr√ºcken.  Auch bei einem rekursiven Aufruf dieses globalen Objekts oder <code>undefined</code> <br><br><h4>  Diese verschachtelten Funktionen werden im √ºbergeordneten Element aufgerufen </h4><br>  Auch eine wichtige Situation! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}; obj.test = foo; obj.test();<span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br>  Dies liegt daran, dass der Aufruf von <code>bar()</code> dem Aufruf von <code>LE_foo.bar</code> und das Objekt der lexikalischen Umgebung dies nicht definiert. <br><br><h4>  Konstruktorfunktionen </h4><br>  Wie ich oben geschrieben habe: <blockquote>  Diese Funktion wird vom Aufrufer festgelegt und h√§ngt von der Syntax des Aufrufs ab. </blockquote><br>  Wir rufen Konstruktorfunktionen mit dem neuen Schl√ºsselwort auf.  Die Besonderheit dieser Methode zur Funktionsaktivierung besteht darin, dass die interne Funktionsmethode <i><b>[[Konstrukt]]</b></i> aufgerufen wird, die bestimmte Operationen ausf√ºhrt (der Mechanismus zum Erstellen von Entit√§ten durch Designer wird im zweiten oder dritten Artikel √ºber OOP erl√§utert!) Und die interne <i><b>[[Aufruf]]</b></i> -Methode aufruft, die niedergelegt wird in <b>dieser</b> erstellten Instanz der Konstruktorfunktion. <br><br><h3>  Scope Chain </h3><br>  Die Scope-Kette ist auch eine Eigenschaft des Ausf√ºhrungskontexts wie dieser.  Es ist eine Liste von Objekten der lexikalischen Umgebungen des aktuellen Kontexts und aller generierenden Kontexte.  In dieser Kette erfolgt die Suche nach Variablen beim Aufl√∂sen von Bezeichnernamen. <br><br>  Hinweis: Dadurch wird eine Funktion einem Ausf√ºhrungskontext und ScopeChain einem untergeordneten Kontext zugeordnet. <br><br>  Die Spezifikation besagt, dass ScopeChain ein Array ist: <br><br><pre> <code class="javascript hljs"> SC = [LO, LO1, LO2,..., LOglobal];</code> </pre><br>  In einigen Implementierungen, wie z. B. JS, wird die Bereichskette jedoch √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verkn√ºpfte Listen</a> implementiert. <br><br>  Um ScopeChain besser zu verstehen, werden wir den Lebenszyklus von Funktionen diskutieren.  Es ist in die Erstellungsphase und die Ausf√ºhrungsphase unterteilt. <br><br>  Wenn eine Funktion erstellt wird, wird ihr die interne Eigenschaft <i><b>[[SCOPE]]</b></i> zugewiesen. <br>  In <i><b>SCOPE</b></i> wird eine hierarchische Kette von Objekten aus lexikalischen Umgebungen mit h√∂heren (generierenden) Kontexten aufgezeichnet.  Diese Eigenschaft bleibt unver√§ndert, bis die Funktion vom Garbage Collector zerst√∂rt wird. <br><br>  Beachten Sie!  <i><b>[[SCOPE]]</b></i> ist im Gegensatz zu ScopeChain eine Eigenschaft der Funktion selbst, nicht ihres Kontexts. <br><br>  Wenn eine Funktion aufgerufen wird, wird ihr Ausf√ºhrungskontext initialisiert und gef√ºllt.  Der Kontext ist mit ScopeChain = LO (der Funktion selbst) + [[SCOPE]] (hierarchische Kette von LO, die Kontexte beeinflusst) verbunden. <br><br>  <b>Aufl√∂sung von Bezeichnernamen</b> - sequentielle Abfrage von <b>LO-</b> Objekten in der <b>ScopeChain-</b> Kette <b>von</b> links nach rechts.  Die Ausgabe ist ein ReferenceType, dessen Basiseigenschaft auf das LO-Objekt verweist, in dem der Bezeichner gefunden wurde, und PropertyName ist eine Zeichenfolgendarstellung des Bezeichnernamens. <br><br>  So ist der Verschluss unter der Haube angeordnet!  Ein Abschluss ist im Wesentlichen das Ergebnis einer Suche in ScopeChain nach allen Variablen, deren Bezeichner in der Funktion vorhanden sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>; foo();<span class="hljs-comment"><span class="hljs-comment">// 10 ..     &lt;b&gt;&lt;i&gt;[[SCOPE]]&lt;/i&gt;&lt;/b&gt; foo          })()</span></span></code> </pre><br>  Das folgende Beispiel zeigt den Lebenszyklus <b><i>[[SCOPE]]</i></b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x,y]; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = foo();<span class="hljs-comment"><span class="hljs-comment">//   ,   foo    bar();// [10,20] .. [[SCOPE]]    foo         </span></span></code> </pre><br>  Eine wichtige Ausnahme ist <b>die Konstruktorfunktion</b> .  Bei dieser Art von Funktion zeigt [[SCOPE]] immer auf ein globales Objekt. <br><br>  Vergessen Sie auch nicht, dass die Suche auch im Prototyp durchgef√ºhrt wird, wenn eines der Glieder in der ScopeChain-Kette einen Prototyp hat. <br><br><h3>  Fazit </h3><br>  Wir werden die Schl√ºsselideen theoretisch darlegen: <br><br><ul><li>  Dies ist die Beziehung der Entit√§t zum Ausf√ºhrungskontext </li><li>  ScopeChain ist die Beziehung einer Entit√§t zu allen Spawning-Kontexten </li><li>  this und ScopeChain sind Ausf√ºhrungskontexteigenschaften </li><li>  Diese Funktion wird vom Anrufer festgelegt und h√§ngt von der Syntax des Anrufs ab </li><li>  ScopeChain ist die lexikalische Umgebung des aktuellen Kontexts + [[Scope]] </li><li>  [[Scope]] - Dies ist eine Eigenschaft der Funktion selbst und enth√§lt eine hierarchische Kette von lexikalischen Umgebungen zum Generieren von Kontexten </li></ul><br>  Hoffe der Artikel war hilfreich.  Bis zu zuk√ºnftigen Artikeln, Freunde! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468943/">https://habr.com/ru/post/de468943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468929/index.html">Das Mini-Handbuch zum Einrichten eines Hackintosh ist so einfach und schmerzlos wie m√∂glich</a></li>
<li><a href="../de468931/index.html">F√ºhren Sie systemd im Container aus</a></li>
<li><a href="../de468933/index.html">Stachelig und scharf, wohin Sie auch schauen: der Mechanismus des Selbstsch√§rfens der Z√§hne von Seeigeln</a></li>
<li><a href="../de468935/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Experten im Bereich IT im Oktober 2019</a></li>
<li><a href="../de468937/index.html">Kontaktlose Bankkartenangriffe</a></li>
<li><a href="../de468945/index.html">ITIL und ITSM sind eine Geschichte gro√üer T√§uschung. Gibt es einen Vorteil? Wie viel kostet es und wer genau implementiert ITIL NICHT?</a></li>
<li><a href="../de468951/index.html">Gro√üe Konfigurationsprobleme f√ºr kleine Ger√§te</a></li>
<li><a href="../de468953/index.html">Codestil als Entwicklungsstandard</a></li>
<li><a href="../de468955/index.html">Die Kommunikation ist eine weitere konfigurierbare Remote-Option</a></li>
<li><a href="../de468957/index.html">Zyklische Dungeon-Generierung am Beispiel von Unexplored</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>