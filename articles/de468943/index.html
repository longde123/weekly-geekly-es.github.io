<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 👜 📌 dies und ScopeChain in EcmaScript 👩🏿‍🤝‍👨🏽 🐱 🤚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 In einem früheren Artikel haben wir die allgemeine Theorie von OOP in Bezug auf EcmaScript und den populären Irrtum von unerfahrenen En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>dies und ScopeChain in EcmaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468943/"> Hallo Habr! <br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel haben</a> wir die allgemeine Theorie von OOP in Bezug auf EcmaScript und den populären Irrtum von unerfahrenen Entwicklern hinsichtlich der Unterschiede zwischen OOP in JS und klassischen Sprachen untersucht. <br><br>  Heute werden wir über zwei andere gleich wichtige EcmaScript-Konzepte sprechen, nämlich die Beziehung der Entität zum Ausführungskontext ( <b>dies</b> ist diese Verbindung) und die Beziehung der Entität zum generierenden Kontext ( <b>ScopeChain</b> ). <br><br>  Also fangen wir an! <br><br><h3>  das </h3><br>  Bei Interviews als Antwort auf die Frage: "Erzählen Sie uns mehr darüber."  Anfängerentwickler geben in der Regel sehr vage Antworten: " <i>Dies</i> ist das Objekt" vor dem Punkt ", mit dem die Methode aufgerufen wurde", " <i>Dies</i> ist der Kontext, in dem die Funktion aufgerufen wurde" usw. ... <br><br>  Tatsächlich ist die Situation mit diesem Konzept, das für EcmaScript von zentraler Bedeutung ist, etwas komplizierter.  Lassen Sie es uns in der richtigen Reihenfolge herausfinden. <br><br>  Angenommen, wir haben ein JavaScript-Programm, dessen Variablen global deklariert sind.  globale Funktionen;  lokale Funktionen (innerhalb anderer Funktionen deklariert), von Funktionen zurückgegebene Funktionen. <br><a name="habracut"></a><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBaz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } fooBar()();</code> </pre> <br>  Bei der Übertragung der Steuerung auf den ausführbaren Code wird ein Eintrag in den Ausführungskontext vorgenommen.  Ausführbarer Code - Dies ist jeder Code, den wir zu einem bestimmten Zeitpunkt ausführen. Es kann sich um einen globalen Code oder einen Code einer beliebigen Funktion handeln. <br><br>  <b>Der Ausführungskontext</b> ist eine Abstraktion, die Code typisiert und begrenzt.  Unter dem Gesichtspunkt dieser Abstraktion ist der Code in globalen (alle verbundenen Skripte, Inline-Skripte) und Funktionscode (der Code verschachtelter Funktionen gehört nicht zum Kontext übergeordneter Funktionen) unterteilt. <br><br>  Es gibt einen dritten Typ - EvalCode.  In diesem Artikel vernachlässigen wir es. <br><br>  Logischerweise ist die Menge der Ausführungskontexte ein <b>Stapel</b> , der nach dem Prinzip des Last-in-First-out (lifo) arbeitet.  Das Ende des Stapels ist immer der globale Kontext, und das Ende ist die aktuelle ausführbare Datei.  Bei jedem Aufruf einer Funktion wird ein Eintrag in ihren Kontext vorgenommen.  Wenn eine Funktion abgeschlossen ist, endet ihr Kontext.  Verbrauchte Kontexte werden nacheinander und in umgekehrter Reihenfolge vom Stapel entfernt. <br><br>  Schauen Sie sich den obigen Code an.  Wir haben einen Aufruf der Funktion <b>fooBar</b> im globalen Code.  In der Funktion <b>fooBar geben</b> wir <b>eine anonyme Funktion zurück</b> , die wir sofort aufrufen.  Die folgenden Änderungen treten beim Stapel auf: Ein <b>globaler Kontext</b> wird in ihn <b>eingefügt</b> - wenn <b>fooBar</b> aufgerufen wird <b>, wird</b> sein Kontext in den Stapel aufgenommen - <b>fooBar wird</b> beendet, gibt <b>eine anonyme Funktion zurück</b> und wird aus dem Stapel entfernt - eine <b>anonyme Funktion</b> wird aufgerufen, ihr Kontext wird in den Stapel aufgenommen - eine <b>anonyme Funktion</b> erfüllt, gibt einen Wert zurück und sein Kontext wird aus dem Stapel gelöscht - am Ende des Skripts wird der <b>globale Kontext</b> aus dem Stapel gelöscht. <br><cut></cut><br>  Der Ausführungskontext kann bedingt als Objekt dargestellt werden.  Eine der Eigenschaften dieses Objekts ist die Lexical Environment (LO). <br><br>  <b>Die lexikalische Umgebung</b> enthält: <br><br><ul><li>  alle Kontextvariablendeklarationen </li><li>  alle Funktionsdeklarationen </li><li>  alle formalen Parameter der Funktion (wenn wir über den Kontext von Funktionen sprechen) </li></ul><br>  Bei der Eingabe des Ausführungskontexts scannt der Interpreter den Kontext.  Alle Variablendeklarationen und Funktionsdeklarationen stehen am Anfang des Kontexts.  Variablen werden gleich undefiniert erstellt und Funktionen sind vollständig einsatzbereit. <br><br>  <b>Dies ist</b> auch eine Eigenschaft des Ausführungskontexts, aber nicht des Kontexts selbst, wie einige unerfahrene Interviewer antworten!  <b>Dies wird</b> beim Eingeben des Kontexts definiert und bleibt bis zum Ende der Lebensdauer des Kontexts unverändert (bis der Kontext vom Stapel entfernt wird). <br><br>  Im globalen Ausführungskontext wird <b>dies</b> durch den <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strengen Modus bestimmt</a></b> : Wenn der strenge Modus deaktiviert ist, enthält dieser ein globales Objekt (im Browser wird es auf die oberste Ebene im Fensterobjekt übertragen), wobei 'use strict' undefiniert ist. <br><cut></cut><br>  <b>dies</b> im Kontext von Funktionen - die Frage ist viel interessanter! <br>  Diese Funktion wird vom Aufrufer festgelegt und hängt von der Syntax des Aufrufs ab.  Wie wir wissen, gibt es beispielsweise Methoden, mit denen dies beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> starr festgelegt werden kann ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwenden</a> ), und eine Methode, mit der Sie einen Wrapper mit "Fixed This" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binden</a> ) erstellen können.  In diesen Situationen geben wir dies ausdrücklich an und es kann kein Zweifel an seiner Definition bestehen. <br><br>  Bei einem normalen Funktionsaufruf ist die Situation viel komplizierter! <br><br>  Einer der in EcmaScript integrierten Typen, <b>ReferenceType</b> , hilft uns zu verstehen, wie dies in Funktionen angebracht ist.  Dies ist einer der internen Typen, die auf Implementierungsebene verfügbar sind.  Logischerweise handelt es sich um ein Objekt mit zwei Eigenschaften <b>base</b> (eine Referenz auf ein bestimmtes Basisobjekt, für das ein ReferenceType zurückgegeben wird), <b>propertyName</b> (eine Zeichenfolgendarstellung des Bezeichners des Objekts, für das ein ReferenceType zurückgegeben wird). <br><br>  <b>ReferenceType wird</b> für alle Variablendeklarationen, Funktionsdeklarationen und Eigenschaftsreferenzen zurückgegeben (dies ist der Fall, der uns unter dem Gesichtspunkt des Verständnisses interessiert). <br><br>  Die Regel, um <b>dies</b> für Funktionen zu definieren, die auf die übliche Weise aufgerufen werden: <br>  <i>Befindet sich der <b>ReferenceType</b> links von den Aktivierungsklammern der Funktion, wird die <b>Basis</b> dieses <b>ReferenceType</b> in <code>this</code> Funktion eingefügt.</i>  <i>Befindet sich ein anderer Typ links von den Klammern, <code>this</code> es sich entweder um ein globales Objekt oder um ein <code>undefined</code> Objekt (tatsächlich <code>null</code> , aber da null aus Sicht von Ecmascript keinen bestimmten Wert hat, wird es in ein globales Objekt umgewandelt, auf das möglicherweise verwiesen wird entspricht <code>undefined</code> je nach striktem Modus).</i> <br><br>  Schauen wir uns ein Beispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo();<span class="hljs-comment"><span class="hljs-comment">//  10 ..    ReferenceType  base     obj const test = obj.foo;//       test();//  0 ..  test()   .test(),..  base    ,       0.</span></span></code> </pre><br>  Ich denke, die Definitionsmethode ist klar dargestellt.  Betrachten Sie nun einige weniger offensichtliche Fälle. <br><br><h4>  Funktionsausdrücke </h4><br>  Kehren wir für eine Sekunde zu unserem Referenztyp zurück.  Dieser Typ verfügt über eine integrierte <b>GetValue-</b> Methode, die den wahren Typ des über den ReferenceType empfangenen Objekts zurückgibt.  In der Ausdruckszone wird GetValue immer ausgelöst. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;<span class="hljs-comment"><span class="hljs-comment">// this     undefined    strict mode })()</span></span></code> </pre><br>  Dies liegt daran, dass GetValue immer in der Ausdruckszone ausgelöst wird.  GetValue gibt einen Funktionstyp zurück und links von den Aktivierungsklammern befindet sich kein ReferenceType.  Erinnern Sie sich an unsere Regel, um <b>dies</b> zu bestimmen: <i>Wenn sich ein anderer Typ links von den Klammern befindet, wird ein globales Objekt in <code>this</code> oder <code>undefined</code> (tatsächlich <code>null</code> , aber da null aus Sicht von Ecmascript keinen bestimmten Wert hat, wird es in ein globales Objekt konvertiert , dessen Verknüpfung je nach striktem Modus gleich undefiniert sein kann)</i> . <br><br>  Ausdruckszonen sind: Zuweisung (=), Operatoren ||  oder andere logische Operatoren, ternärer Operator, Array-Initialisierer, durch Kommas getrennte Liste. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo(); <span class="hljs-comment"><span class="hljs-comment">//        //  ? (obj.foo)(); // ,    , GetValue   // ? (obj.foo = obj.foo)(); //        GetValue,     Fuction,   ReferenceType,   0   (   this) //  ||    ,    ..? (obj.foo || obj.foo)();// 0    ,     //  [obj.foo][0]();// 0    ,     // ..</span></span></code> </pre><br>  Identische Situation in benannten funktionalen Ausdrücken.  Auch bei einem rekursiven Aufruf dieses globalen Objekts oder <code>undefined</code> <br><br><h4>  Diese verschachtelten Funktionen werden im übergeordneten Element aufgerufen </h4><br>  Auch eine wichtige Situation! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}; obj.test = foo; obj.test();<span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br>  Dies liegt daran, dass der Aufruf von <code>bar()</code> dem Aufruf von <code>LE_foo.bar</code> und das Objekt der lexikalischen Umgebung dies nicht definiert. <br><br><h4>  Konstruktorfunktionen </h4><br>  Wie ich oben geschrieben habe: <blockquote>  Diese Funktion wird vom Aufrufer festgelegt und hängt von der Syntax des Aufrufs ab. </blockquote><br>  Wir rufen Konstruktorfunktionen mit dem neuen Schlüsselwort auf.  Die Besonderheit dieser Methode zur Funktionsaktivierung besteht darin, dass die interne Funktionsmethode <i><b>[[Konstrukt]]</b></i> aufgerufen wird, die bestimmte Operationen ausführt (der Mechanismus zum Erstellen von Entitäten durch Designer wird im zweiten oder dritten Artikel über OOP erläutert!) Und die interne <i><b>[[Aufruf]]</b></i> -Methode aufruft, die niedergelegt wird in <b>dieser</b> erstellten Instanz der Konstruktorfunktion. <br><br><h3>  Scope Chain </h3><br>  Die Scope-Kette ist auch eine Eigenschaft des Ausführungskontexts wie dieser.  Es ist eine Liste von Objekten der lexikalischen Umgebungen des aktuellen Kontexts und aller generierenden Kontexte.  In dieser Kette erfolgt die Suche nach Variablen beim Auflösen von Bezeichnernamen. <br><br>  Hinweis: Dadurch wird eine Funktion einem Ausführungskontext und ScopeChain einem untergeordneten Kontext zugeordnet. <br><br>  Die Spezifikation besagt, dass ScopeChain ein Array ist: <br><br><pre> <code class="javascript hljs"> SC = [LO, LO1, LO2,..., LOglobal];</code> </pre><br>  In einigen Implementierungen, wie z. B. JS, wird die Bereichskette jedoch über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verknüpfte Listen</a> implementiert. <br><br>  Um ScopeChain besser zu verstehen, werden wir den Lebenszyklus von Funktionen diskutieren.  Es ist in die Erstellungsphase und die Ausführungsphase unterteilt. <br><br>  Wenn eine Funktion erstellt wird, wird ihr die interne Eigenschaft <i><b>[[SCOPE]]</b></i> zugewiesen. <br>  In <i><b>SCOPE</b></i> wird eine hierarchische Kette von Objekten aus lexikalischen Umgebungen mit höheren (generierenden) Kontexten aufgezeichnet.  Diese Eigenschaft bleibt unverändert, bis die Funktion vom Garbage Collector zerstört wird. <br><br>  Beachten Sie!  <i><b>[[SCOPE]]</b></i> ist im Gegensatz zu ScopeChain eine Eigenschaft der Funktion selbst, nicht ihres Kontexts. <br><br>  Wenn eine Funktion aufgerufen wird, wird ihr Ausführungskontext initialisiert und gefüllt.  Der Kontext ist mit ScopeChain = LO (der Funktion selbst) + [[SCOPE]] (hierarchische Kette von LO, die Kontexte beeinflusst) verbunden. <br><br>  <b>Auflösung von Bezeichnernamen</b> - sequentielle Abfrage von <b>LO-</b> Objekten in der <b>ScopeChain-</b> Kette <b>von</b> links nach rechts.  Die Ausgabe ist ein ReferenceType, dessen Basiseigenschaft auf das LO-Objekt verweist, in dem der Bezeichner gefunden wurde, und PropertyName ist eine Zeichenfolgendarstellung des Bezeichnernamens. <br><br>  So ist der Verschluss unter der Haube angeordnet!  Ein Abschluss ist im Wesentlichen das Ergebnis einer Suche in ScopeChain nach allen Variablen, deren Bezeichner in der Funktion vorhanden sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>; foo();<span class="hljs-comment"><span class="hljs-comment">// 10 ..     &lt;b&gt;&lt;i&gt;[[SCOPE]]&lt;/i&gt;&lt;/b&gt; foo          })()</span></span></code> </pre><br>  Das folgende Beispiel zeigt den Lebenszyklus <b><i>[[SCOPE]]</i></b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x,y]; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = foo();<span class="hljs-comment"><span class="hljs-comment">//   ,   foo    bar();// [10,20] .. [[SCOPE]]    foo         </span></span></code> </pre><br>  Eine wichtige Ausnahme ist <b>die Konstruktorfunktion</b> .  Bei dieser Art von Funktion zeigt [[SCOPE]] immer auf ein globales Objekt. <br><br>  Vergessen Sie auch nicht, dass die Suche auch im Prototyp durchgeführt wird, wenn eines der Glieder in der ScopeChain-Kette einen Prototyp hat. <br><br><h3>  Fazit </h3><br>  Wir werden die Schlüsselideen theoretisch darlegen: <br><br><ul><li>  Dies ist die Beziehung der Entität zum Ausführungskontext </li><li>  ScopeChain ist die Beziehung einer Entität zu allen Spawning-Kontexten </li><li>  this und ScopeChain sind Ausführungskontexteigenschaften </li><li>  Diese Funktion wird vom Anrufer festgelegt und hängt von der Syntax des Anrufs ab </li><li>  ScopeChain ist die lexikalische Umgebung des aktuellen Kontexts + [[Scope]] </li><li>  [[Scope]] - Dies ist eine Eigenschaft der Funktion selbst und enthält eine hierarchische Kette von lexikalischen Umgebungen zum Generieren von Kontexten </li></ul><br>  Hoffe der Artikel war hilfreich.  Bis zu zukünftigen Artikeln, Freunde! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468943/">https://habr.com/ru/post/de468943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468929/index.html">Das Mini-Handbuch zum Einrichten eines Hackintosh ist so einfach und schmerzlos wie möglich</a></li>
<li><a href="../de468931/index.html">Führen Sie systemd im Container aus</a></li>
<li><a href="../de468933/index.html">Stachelig und scharf, wohin Sie auch schauen: der Mechanismus des Selbstschärfens der Zähne von Seeigeln</a></li>
<li><a href="../de468935/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT im Oktober 2019</a></li>
<li><a href="../de468937/index.html">Kontaktlose Bankkartenangriffe</a></li>
<li><a href="../de468945/index.html">ITIL und ITSM sind eine Geschichte großer Täuschung. Gibt es einen Vorteil? Wie viel kostet es und wer genau implementiert ITIL NICHT?</a></li>
<li><a href="../de468951/index.html">Große Konfigurationsprobleme für kleine Geräte</a></li>
<li><a href="../de468953/index.html">Codestil als Entwicklungsstandard</a></li>
<li><a href="../de468955/index.html">Die Kommunikation ist eine weitere konfigurierbare Remote-Option</a></li>
<li><a href="../de468957/index.html">Zyklische Dungeon-Generierung am Beispiel von Unexplored</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>