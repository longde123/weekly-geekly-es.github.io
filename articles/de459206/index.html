<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔘 🐃 😚 9 Jahre in einem Monolithen bei Node.JS 🏳️ 👃🏿 🧙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einer Woche sprach ich auf einem Node.JS-Treffen und versprach vielen, eine Aufzeichnung der Aufführung zu veröffentlichen. Später stellte ich fes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 Jahre in einem Monolithen bei Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459206/"><p><img src="https://habrastorage.org/webt/p-/5g/we/p-5gweh68uzyj3_baevjuocr8xi.png" alt="Monolith von https://reneaigner.deviantart.com"></p><br><p>  Vor einer Woche sprach ich auf einem Node.JS-Treffen und versprach vielen, eine Aufzeichnung der Aufführung zu veröffentlichen.  Später stellte ich fest, dass ich in einer geregelten halben Stunde einige interessante Fakten nicht berücksichtigen konnte.  Ja, und ich selbst lese lieber als zu sehen und zuzuhören. Deshalb habe ich beschlossen, meine Präsentation im Format eines Artikels zu veröffentlichen.  Das Video befindet sich jedoch auch am Ende des Beitrags im Abschnitt "Links". </p><br><p>  Ich habe beschlossen, Ihnen von einem wunden Punkt zu erzählen - dem Leben in einem Monolithen.  Es gibt bereits Hunderte von Artikeln darüber auf dem Hub, Tausende von Kopien sind in den Kommentaren gebrochen, die Wahrheit ist seit langem in Kontroversen gestorben, aber ... Tatsache ist, dass wir in OneTwoTrip eine sehr spezifische Erfahrung haben, im Gegensatz zu vielen Menschen, die über bestimmte Architekturmuster in schreiben Vakuum: </p><br><ul><li>  Erstens ist unser Monolith bereits 9 Jahre alt. </li><li>  Zweitens verbrachte er sein ganzes Leben unter hoher Last (jetzt sind es 23 Millionen Anfragen pro Stunde). </li><li>  Und in NaN schreiben wir unseren Monolithen auf Node.JS, der sich in den letzten 9 Jahren bis zur Unkenntlichkeit verändert hat.  Ja, wir haben 2010 angefangen, auf dem Knoten zu schreiben. Wir singen ein Lied zur Raserei der Tapferen! </li></ul><br><p>  Wir haben also viel Spezifität und echte Erfahrung.  Interessant?  Lass uns gehen! </p><a name="habracut"></a><br><p>  <strong>Haftungsausschlusszeiten</strong> </p><br><blockquote>  Diese Präsentation spiegelt nur die private Meinung des Autors wider.  Es kann mit der Position von OneTwoTrip übereinstimmen oder nicht.  So viel Glück.  Ich arbeite als technischer Experte in einem der Unternehmensteams und gebe nicht vor, objektiv zu sein oder eine andere Meinung als meine eigene zu äußern. </blockquote><p>  <strong>Haftungsausschluss Zwei</strong> </p><br><blockquote>  Dieser Artikel beschreibt historische Ereignisse, und im Moment ist alles völlig falsch, seien Sie also nicht beunruhigt. </blockquote><br><h2 id="0-kak-zhe-tak-vyshlo">  0. Wie ist es passiert? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Abfragetrend des</a> Wortes "Microservice" in Google: <br><img src="https://habrastorage.org/webt/i5/ss/lm/i5sslmpta1fldeztaxgmmnd50ag.png"><br>  Alles ist sehr einfach - vor neun Jahren wusste niemand etwas über Microservices.  Also haben wir wie alle anderen angefangen zu schreiben - in einem Monolithen. </p><br><h2 id="1-bol-v-monolite">  1. Schmerzen im Monolithen </h2><br><p>  Hier werde ich die Problemsituationen beschreiben, die wir in diesen 9 Jahren hatten.  Einige von ihnen wurden gelöst, andere durch Hacks umgangen, andere verloren einfach an Relevanz.  Aber die Erinnerung an sie, wie Kampfnarben, wird mich niemals verlassen. </p><br><h3 id="11-obnovlenie-svyaznyh-komponentov">  1.1 Aktualisieren verbundener Komponenten </h3><br><p><img src="https://habrastorage.org/webt/0a/h-/8f/0ah-8f7ijb259t-blaohq1_dceg.png"><br>  Dies ist der Fall, wenn Synergie böse ist.  Da jede Komponente mehrere hundert Mal wiederverwendet wurde und es möglich war, sie schief zu verwenden, ging sie nicht verloren.  Jede Aktion kann völlig unvorhersehbare Auswirkungen haben, und nicht alle werden von Einheiten und Integrationstests verfolgt.  Erinnerst du dich an die Geschichte über Mops, einen Ventilator und einen Ballon?  Wenn nicht, googeln Sie es.  Sie ist die beste Illustration des Codes im Monolithen. </p><br><h3 id="12-migraciya-na-novye-tehnologii">  1.2 Migration zu neuen Technologien </h3><br><p>  Möchten Sie Express?  Linter?  Ein weiterer Rahmen für Tests oder Moks?  Validator aktualisieren oder zumindest lodash?  Node.js aktualisieren?  Es tut mir leid.  Dazu müssen Sie Tausende von Codezeilen bearbeiten. </p><br><p>  Viele sprechen über den Vorteil des Monolithen, dass <strong>jede Revision ein atomares Commit ist</strong> .  Diese Leute schweigen über eine <strong>Sache</strong> - <strong>diese Überarbeitung wird niemals durchgeführt werden</strong> . </p><br><p>  Kennen Sie den alten Witz über semantische Versionierung? </p><br><blockquote>  die wahre Semantik der semantischen Versionierung: <br><br>  major = eine bahnbrechende Veränderung <br>  geringfügig = eine geringfügige Änderung <br>  Patch = eine kleine Veränderung </blockquote><p>  Stellen Sie sich nun vor, dass mit ziemlicher Sicherheit jede kleine Änderung in Ihrem Code auftaucht.  Nein, es ist möglich, damit zu leben, und wir haben regelmäßig Kraft gesammelt und sind migriert, aber es war wirklich sehr schwierig.  Sehr. </p><br><h3 id="13-relizy">  1.3 Veröffentlichungen </h3><br><p>  Hier muss ich zu einigen Besonderheiten unseres Produktes sagen.  Wir haben eine große Anzahl externer Integrationen und verschiedene Zweige der Geschäftslogik, die ziemlich selten separat auftauchen.  Ich beneide die Produkte wirklich, die tatsächlich alle Zweige ihres Codes in 10 Minuten in der Produktion ausführen, aber das ist hier nicht der Fall.  Durch Versuch und Irrtum haben wir für uns einen optimalen Veröffentlichungszyklus gefunden, der die Anzahl der Fehler, die Endbenutzer erreichen, minimiert: </p><br><ol><li>  Die Veröffentlichung läuft und die Integrationstests dauern einen halben Tag </li><li>  dann steht es einen Tag lang unter sorgfältiger Aufsicht auf der Bühne (für 10% der Benutzer) </li><li>  dann liegt ein weiterer Tag in der Produktion unter noch sorgfältigerer Aufsicht. </li><li>  Und erst danach geben wir ihm grünes Licht im Meister. </li></ol><br><p>  Da wir unsere Kollegen lieben und freitags nicht veröffentlichen, bedeutet dies letztendlich, dass die Veröffentlichung etwa 1,5 bis 2 Mal pro Woche an den Master geht.  Dies führt dazu, dass das Release 60 oder mehr Aufgaben haben kann.  Ein solcher Betrag führt zu Zusammenführungskonflikten, plötzlichen Synergieeffekten, einer vollständigen QS-Arbeitsbelastung bei der Protokollanalyse und anderen Problemen.  Im Allgemeinen war es für uns sehr schwierig, einen Monolithen freizugeben. </p><br><h3 id="14-prosto-ochen-mnogo-koda">  1.4 Nur viel Code </h3><br><p>  Es scheint, dass die Menge an Code nicht von grundlegender Bedeutung sein sollte.  Aber ... nicht wirklich.  In der realen Welt ist es: </p><br><ul><li>  Höhere Eintrittsschwelle </li><li>  Riesige Build-Artefakte für jede Aufgabe </li><li>  Lange CI-Prozesse, einschließlich Integrationstests, Komponententests und sogar Code-Flusen </li><li>  Langsame IDE-Arbeit (zu Beginn der Entwicklung von Jetbrains haben wir sie mehr als einmal mit unseren Protokollen geschockt) </li><li>  Anspruchsvolle kontextbezogene Suche (nicht vergessen, wir haben keine statische Eingabe) </li><li>  Schwierigkeiten beim Finden und Entfernen von nicht verwendetem Code </li></ul><br><h3 id="15-otsutstvuyut-vladelcy-koda">  1.5 Fehlende Codebesitzer </h3><br><p>  Sehr oft entstehen Aufgaben mit einem unverständlichen Verantwortungsbereich - zum Beispiel in verwandten Bibliotheken.  Und der ursprüngliche Entwickler könnte bereits zu einem anderen Team wechseln oder sogar das Unternehmen verlassen.  Der einzige Weg, um in diesem Fall verantwortlich zu sein, ist administrative Willkür - eine Person zu nehmen und zu ernennen.  Das ist nicht immer angenehm für den Entwickler und denjenigen, der es tut. </p><br><h3 id="16-slozhnost-otladki">  1.6 Debugging-Schwierigkeit </h3><br><p>  Fließt die Erinnerung?  Erhöhter CPU-Verbrauch?  Wollten Sie Flammengraphen erstellen?  Es tut mir leid.  In einem Monolithen passieren so viele Dinge gleichzeitig, dass es wahnsinnig schwierig wird, ein Problem zu lokalisieren.  Es ist beispielsweise fast unrealistisch zu verstehen, welche der 60 Aufgaben bei der Einführung in die Produktion einen erhöhten Ressourcenverbrauch verursacht (obwohl dies in Test- und Staging-Umgebungen nicht lokal reproduziert wird). </p><br><h3 id="17-odin-stek">  1.7 Ein Stapel </h3><br><p>  Einerseits ist es gut, wenn alle Entwickler dieselbe Sprache „sprechen“.  Im Fall von JS stellt sich heraus, dass sich selbst Backend mit Frontend-Entwicklern verstehen.  Aber ... </p><br><ul><li>  Es gibt keine Silberkugel, und für einige Aufgaben möchten Sie manchmal etwas anderes verwenden.  Aber wir haben einen Monolithen, und wir können nirgendwo andere Entwickler festhalten. </li><li>  Wir können nicht einfach ein gutes Team auf die Empfehlung setzen, die uns auf Anraten von Freunden zugekommen ist - wir können es nirgendwo sagen. </li><li>  Im Laufe der Zeit ruhen wir uns auf der Tatsache aus, dass der Markt einfach nicht genug Entwickler auf dem richtigen Stack hat. </li></ul><br><h3 id="18-mnogo-komand-s-raznym-predstavleniem-o-schaste">  1.8 Viele Teams mit unterschiedlichen Vorstellungen von Glück </h3><br><p><img src="https://habrastorage.org/webt/1k/bc/k1/1kbck116yjf9-ozmoee08oeacxi.png"></p><br><p>  Wenn Sie zwei Entwickler haben, haben Sie bereits zwei unterschiedliche Vorstellungen darüber, welches das beste Framework ist, welche Standards eingehalten werden sollten, Bibliotheken verwenden usw. <br>  Wenn Sie zehn Teams haben, von denen jedes mehrere Entwickler hat, ist dies nur eine Katastrophe. <br>  Und es gibt nur zwei Möglichkeiten, dies zu lösen - entweder „demokratisch“ (jeder tut, was er will) oder totalitär (Standards werden von oben auferlegt).  Im ersten Fall leiden Qualität und Standardisierung, im zweiten Fall Menschen, die ihre Vorstellung von Glück nicht verwirklichen dürfen. </p><br><h2 id="2-plyusy-monolita">  2. Die Vorteile des Monolithen </h2><br><p>  Natürlich gibt es einige Vorteile des Monolithen, die für verschiedene Stapel, Produkte und Teams unterschiedlich sein können.  Natürlich gibt es viel mehr als drei, aber ich werde nicht für alles Mögliche verantwortlich sein, sondern nur für diejenigen, die für uns relevant waren. </p><br><h3 id="21-prostota-razvyortyvaniya">  2.1 Einfache Bereitstellung </h3><br><p>  Wenn Sie einen Dienst haben, ist das Aufrufen und Testen viel einfacher als ein Dutzend Dienste.  Dieses Plus ist zwar nur in der Anfangsphase relevant. Sie können beispielsweise die Testumgebung erhöhen und alle Dienste außer den daraus entwickelten verwenden.  Oder aus Containern.  Oder was auch immer. </p><br><h3 id="22-net-overheda-na-peredachu-dannyh">  2.2 Kein Datenübertragungsaufwand </h3><br><p>  Ein zweifelhaftes Plus, wenn Sie keine Hochlast haben.  Aber wir haben genau einen solchen Fall - daher sind die Transportkosten zwischen Microservices für uns spürbar.  Egal wie Sie dies schnell versuchen, speichern und übertragen Sie alles schneller als alles andere im RAM - dies ist offensichtlich. </p><br><h3 id="22-odna-sborka">  2.2 Eine Baugruppe </h3><br><p>  Wenn Sie irgendwann in der Geschichte ein Rollback durchführen müssen, ist es wirklich einfach, dies mit einem Monolithen zu tun - nehmen Sie es und rollen Sie es zurück.  Bei Microservices müssen kompatible Versionen von Diensten ausgewählt werden, die zu einem bestimmten Zeitpunkt miteinander verwendet wurden, was nicht immer einfach sein kann.  Dies wird zwar auch mit Hilfe der Infrastruktur gelöst. </p><br><h2 id="3-mnimye-plyusy-monolita">  3. Imaginäre Vorteile eines Monolithen </h2><br><p>  Hier habe ich all die Dinge genommen, die normalerweise als Pluspunkte gelten, aber aus meiner Sicht sind sie es nicht. </p><br><h3 id="31-kod---eto-i-est-dokumentaciya">  3.1 Code - Dies ist die Dokumentation </h3><br><p>  Habe oft diese Meinung gehört.  Aber normalerweise folgen unerfahrene Entwickler, die keine Dateien in Zehntausenden von Codezeilen gesehen haben, die von Leuten geschrieben wurden, die vor Jahren gegangen sind.  Aus irgendeinem Grund wird dieser Artikel meistens zugunsten der Monolith-Unterstützer hinzugefügt - sie sagen, wir brauchen keine Dokumentation, wir haben keinen Transport oder keine API - alles ist im Code enthalten, es ist einfach und klar.  Ich werde mit dieser Aussage nicht streiten, sondern nur sagen, dass ich nicht daran glaube. </p><br><h3 id="32-net-raznyh-versiy-bibliotek-servisov-i-api-net-raznyh-repozitoriev">  3.2 Es gibt keine unterschiedlichen Versionen von Bibliotheken, Diensten und APIs.  Es gibt keine unterschiedlichen Repositorys. </h3><br><p>  Ja  Aber nein.  Denn auf den zweiten Blick verstehen Sie, dass der Service nicht im luftleeren Raum existiert.  Und unter einer Vielzahl anderer Codes und Produkte, in die es integriert wird - angefangen bei Bibliotheken von Drittanbietern über Server-Softwareversionen bis hin zu externen Integrationen, einer IDE-Version, CI-Tools usw.  Und sobald Sie verstehen, wie viele verschiedene versionierte Dinge Ihr Service indirekt enthält, wird sofort klar, dass dieses Plus nur Demagogie ist. </p><br><h3 id="33-prosche-monitoring">  3.3 einfachere Überwachung </h3><br><p>  Einfacher.  Weil Sie ungefähr ein Dashboard haben, anstatt ein paar Dutzend.  Dies ist jedoch komplizierter und manchmal sogar unmöglich, da Sie Ihre Diagramme nicht in verschiedene Teile des Codes zerlegen können und nur die durchschnittliche Temperatur im Krankenhaus haben.  Im Allgemeinen habe ich bereits im Abschnitt alles über die Komplexität des Debuggens gesagt. Ich möchte nur klarstellen, dass dieselbe Komplexität für die Überwachung gilt. </p><br><h3 id="34-prosche-soblyudat-edinye-standarty">  3.4 Es ist einfacher, gemeinsame Standards einzuhalten </h3><br><p>  Ja  Aber, wie ich bereits in dem Absatz über viele Teams mit der Idee des Glücks geschrieben habe, werden die Standards entweder totalitär auferlegt oder fast bis zum Fehlen geschwächt. </p><br><h3 id="35-menshe-veroyatnost-dublirovaniya-koda">  3.5 Geringere Wahrscheinlichkeit einer Codeduplizierung </h3><br><p>  Die seltsame Meinung ist, dass der Code im Monolithen nicht dupliziert wird.  Aber traf ihn ziemlich oft.  In meiner Praxis stellt sich heraus, dass die Vervielfältigung von Code ausschließlich von der Entwicklungskultur im Unternehmen abhängt.  Wenn dies der Fall ist, wird der allgemeine Code allen Arten von Bibliotheken, Modulen und Mikrodiensten zugewiesen.  Wenn es nicht vorhanden ist, wird der Monolith zwanzig Mal kopiert und eingefügt. </p><br><h2 id="4-plyusy-mikroservisov">  4. Vorteile von Microservices </h2><br><p>  Jetzt schreibe ich darüber, was wir nach der Migration erhalten haben.  Auch dies sind echte Schlussfolgerungen aus einer realen Situation. </p><br><h3 id="41-mozhno-delat-geterogennuyu-infrastrukturu">  4.1 Sie können eine heterogene Infrastruktur erstellen </h3><br><p>  Jetzt können wir Code auf einen Stapel schreiben, der für die Lösung eines bestimmten Problems optimal ist.  Und es ist vernünftig, gute Entwickler zu verwenden, die zu uns gekommen sind.  Hier ist zum Beispiel eine Beispielliste der Technologien, über die wir derzeit verfügen: <br><img src="https://habrastorage.org/webt/mt/oc/nr/mtocnrvjvhfhxxtsjfnjx3z8knc.png"></p><br><h3 id="42-mozhno-delat-mnogo-chastyh-relizov">  4.2 Sie können viele häufige Veröffentlichungen vornehmen </h3><br><p>  Jetzt können wir viele kleine unabhängige Veröffentlichungen machen, die einfacher, schneller und nicht schmerzhaft sind.  Früher hatten wir nur ein Team, jetzt sind es bereits 18. Es hätte eine Pause gegeben, wenn alle im Monolithen geblieben wären.  Oder die Leute, die dafür verantwortlich sind ... </p><br><h3 id="43-prosche-delat-nezavisimye-testy">  4.3 Einfachere unabhängige Tests </h3><br><p>  Wir haben die Zeit für Integrationstests verkürzt, die jetzt nur das testen, was sich wirklich geändert hat, und gleichzeitig haben wir keine Angst vor den Auswirkungen plötzlicher Synergien.  Natürlich musste ich anfangen, um den Rechen herumzulaufen - zum Beispiel zu lernen, wie man abwärtskompatible APIs erstellt -, aber im Laufe der Zeit beruhigte sich alles. </p><br><h3 id="44-legche-vnedryat-i-testirovat-novye-fichi">  4.4 Einfachere Implementierung und Test neuer Funktionen </h3><br><p>  Jetzt sind wir offen für Experimente.  Alle Frameworks, Stacks, Bibliotheken - Sie können alles ausprobieren und bei Erfolg weitermachen. </p><br><h3 id="45-mozhno-obnovlyat-chto-ugodno">  4.5 Sie können alles aktualisieren </h3><br><p>  Sie können die Version der Engine, Bibliotheken, aber alles aktualisieren!  Als Teil eines kleinen Dienstes ist das Auffinden und Beheben aller wichtigen Änderungen eine Frage von Minuten.  Und nicht Wochen wie vorher. </p><br><h3 id="46--a-mozhno-ne-obnovlyat">  4.6 Und Sie können nicht aktualisieren </h3><br><p>  Seltsamerweise ist dies eines der coolsten Features von Microservices.  Wenn Sie einen stabilen Arbeitscode haben, können Sie ihn einfach einfrieren und vergessen.  Und Sie müssen es beispielsweise nie aktualisieren, um den Produktcode auf einer neuen Engine auszuführen.  Das Produkt selbst arbeitet mit einem neuen Motor, und der Microservice lebt so weiter, wie er gelebt hat.  Fliegen mit Schnitzel können endlich separat gefressen werden. </p><br><h2 id="5-minusy-mikroservisov">  5 Nachteile von Microservices </h2><br><p>  Natürlich war eine Fliege in der Salbe nicht vollständig, und eine perfekte Lösung, um nur zu sitzen und bezahlt zu werden, funktionierte nicht.  Was ist uns begegnet: </p><br><h3 id="51-nuzhna-shina-dlya-obmena-dannymi-i-vnyatnoe-logirovanie">  5.1 Benötigen Sie einen Bus für den Datenaustausch und die Löschprotokollierung. </h3><br><p>  Die Interaktion von Diensten über HTTP ist ein klassisches und im Allgemeinen sogar ein funktionierendes Modell, vorausgesetzt, es gibt Protokollierungs- und Ausgleichsebenen zwischen ihnen.  Es ist jedoch besser, einen deutlicheren Reifen zu haben.  Darüber hinaus sollten Sie darüber nachdenken, wie Sie Protokolle untereinander sammeln und kombinieren können. Andernfalls haben Sie nur Brei in der Hand. </p><br><h3 id="52-nuzhno-sledit-za-tem-chto-delayut-razrabotchiki">  5.2 Verfolgen Sie, was Entwickler tun. </h3><br><p>  Im Allgemeinen sollte dies immer getan werden, aber in Microservices haben Entwickler offensichtlich mehr Freiheit, was manchmal zu Dingen führen kann, von denen Stephen King Gänsehaut bekommen würde.  Auch wenn es äußerlich so aussieht, als ob der Dienst funktioniert - vergessen Sie nicht, dass es eine Person geben sollte, die überwacht, was sich in ihm befindet. </p><br><h3 id="53-nuzhna-horoshaya-komanda-devops-chtoby-vsem-etim-upravlyat">  5.3 Sie benötigen ein gutes DevOps-Team, um alles zu verwalten. </h3><br><p>  Fast jeder Entwickler kann einen Monolithen auf die eine oder andere Weise bereitstellen und seine Releases hochladen (zum Beispiel über FTP oder SSH, das habe ich gesehen).  Bei Microservices gibt es jedoch alle Arten von zentralisierten Diensten zum Sammeln von Protokollen, Metriken, Dashboards, Köchen zum Verwalten von Konfigurationen, Volt, Jenkins und anderen guten Dingen, ohne die Sie im Allgemeinen leben können - aber es ist schlecht und unverständlich, warum.  Um Microservices verwalten zu können, benötigen Sie ein gutes DevOps-Team. </p><br><h3 id="54-mozhno-popytatsya-slovit-hayp-i-vystrelit-sebe-v-nogu">  5.4 Sie können versuchen, einen Hype zu fangen und sich in den Fuß zu schießen. </h3><br><p>  Vielleicht ist dies das Hauptnegativ der Architektur und ihrer Gefahr.  Sehr oft folgen Menschen blind Trends und beginnen, Architektur und Technologie einzuführen, ohne sie zu verstehen.  Danach fällt alles in dem daraus resultierenden Chaos und sie schreiben einen Artikel über den Habr, "wie wir zum Beispiel von Microservices zu einem Monolithen gewechselt sind".  Bewegen Sie sich im Allgemeinen nur, wenn Sie wissen, warum Sie dies tun und welche Probleme Sie lösen werden.  Und welche bekommst du? </p><br><h2 id="6-haki-v-monolite">  6 Khaki im Monolithen </h2><br><p>  Einige der Hacks, mit denen wir in einem Monolithen leben konnten, sind etwas besser und etwas länger. </p><br><h3 id="61-linting">  6.1 Flusen </h3><br><p>  Die Einführung eines Liners in einen Monolithen ist keine so einfache Aufgabe, wie es auf den ersten Blick scheint.  Natürlich können Sie strenge Regeln festlegen, eine Konfiguration hinzufügen und ... Nichts wird sich ändern, jeder schaltet nur den Linter aus, da die Hälfte des Codes rot wird. </p><br><p>  Um das Flusen schrittweise einzuführen, haben wir ein einfaches Add-On für eslint geschrieben - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slowlint</a> , mit dem Sie eine einfache Sache tun können - eine Liste vorübergehend ignorierter Dateien.  Ergebend: </p><br><ul><li>  Jeder falsche Code wird in der IDE hervorgehoben </li><li>  Neue Dateien werden gemäß den Flusenregeln erstellt, andernfalls werden sie von CI nicht übersehen </li><li>  Alte regieren allmählich und gehen von Ausnahmen weg </li></ul><br><p>  Im Laufe des Jahres war es möglich, etwa die Hälfte des Monolith-Codes in einen einzigen Stil zu bringen, dh fast alle aktiv hinzugefügten Codes. </p><br><h3 id="62-dorabotki-yunit-testov">  6.2 Verbesserungen des Unit-Tests </h3><br><p>  Einmal wurden bei uns drei Minuten lang Unit-Tests durchgeführt.  Die Entwickler wollten nicht so lange warten, daher wurde alles nur in CI auf dem Server überprüft.  Nach einiger Zeit stellte der Entwickler fest, dass die Tests fielen, verfluchten, eine Filiale eröffneten und zum Code zurückkehrten ... Im Allgemeinen litt er.  Was haben wir damit gemacht: </p><br><ol><li>  Für den Anfang haben wir begonnen, Tests mit mehreren Threads durchzuführen.  Yandex hat eine Variante von Multithread-Mokka, aber bei uns ist sie nicht gestartet, deshalb haben sie selbst einen einfachen Wrapper geschrieben.  Die Tests wurden eineinhalb Mal schneller durchgeführt. </li><li>  Dann sind wir von 0,12 auf den 8. Knoten übergegangen (ja, der Prozess selbst zeichnet auf einen separaten Bericht).  So seltsam es auch scheinen mag, es gab keinen grundlegenden Produktivitätsgewinn in der Produktion, aber die Tests wurden 20% schneller durchgeführt. </li><li>  Und dann haben wir uns hingesetzt, um die Tests zu debuggen und sie individuell zu optimieren.  Was die größte Geschwindigkeitssteigerung ergab. </li></ol><br><p>  Im Allgemeinen werden derzeit Unit-Tests im Vorbereitungshaken ausgeführt und dauern 10 Sekunden. Dies ist sehr komfortabel und ermöglicht es Ihnen, sie ohne Unterbrechung der Produktion auszuführen. </p><br><h3 id="63--oblegchenie-vesa-artefakta">  6.3 Erleichterung des Artefaktgewichts </h3><br><p>  Das Monolith-Artefakt nahm schließlich 400 Megabyte ein.  In Anbetracht der Tatsache, dass es für jedes Commit erstellt wird, stellte sich heraus, dass das Gesamtvolumen ziemlich groß war.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Durchfallmodul</a> , eine Abzweigung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modclean-</a> Moduls, hat uns dabei geholfen.  Wir haben Unit-Tests aus dem Artefakt entfernt und es von verschiedenen Abfällen wie Readme-Dateien, Tests in Paketen usw. befreit.  Die Zunahme betrug ungefähr 30% des Gewichts! </p><br><h3 id="64--keshirovanie-zavisimostey">  6.4 Abhängigkeits-Caching </h3><br><p>  Früher dauerte die Installation von Abhängigkeiten mit npm so lange, dass Sie nicht nur Kaffee trinken, sondern beispielsweise auch Pizza backen konnten.  Deshalb haben wir zuerst das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm-Cache-</a> Modul verwendet, das gegabelt und ein wenig fertig war.  Sie konnten Abhängigkeiten auf einem freigegebenen Netzlaufwerk speichern, von dem alle anderen Builds sie dann übernehmen würden. </p><br><p>  Dann haben wir über die Reproduzierbarkeit von Baugruppen nachgedacht.  Wenn Sie einen Monolithen haben, ist die Veränderung der transitiven Abhängigkeiten Gottes Geißel.  ,        ,  -        .     npm-shrinkwrap.     ,     —    . </p><br><p><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'de', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script> Und dann erschienen schließlich die <code>npm ci</code> und der ausgezeichnete Befehl <code>npm ci</code> der nur geringfügig <code>npm ci</code> lief als die Installation von Abhängigkeiten aus dem Dateicache.  Daher haben wir nur damit begonnen und das Speichern von Abhängigkeitsassemblys gestoppt.  An diesem Tag brachte ich mehrere Kisten Donuts zur Arbeit. </p><br><h3 id="65--raspredelenie-ocheryodnosti-relizov">  6.5 Verteilung der Reihenfolge der Veröffentlichungen. </h3><br><p>  Und dies ist eher ein administrativer Hack, kein technischer.  Anfangs war ich gegen ihn, aber die Zeit zeigte, dass der zweite technische Experte Recht hatte und im Allgemeinen gut gemacht war.  Als die Releases nacheinander auf mehrere Teams verteilt wurden, wurde klar, wo genau die Fehler auftraten, und was noch wichtiger ist, jedes Team fühlte sich für die Geschwindigkeit verantwortlich und versuchte, Probleme zu lösen und so schnell wie möglich einzuführen. </p><br><h3 id="66-udalenie-myortvogo-koda">  6.6 Dead Code löschen </h3><br><p>  In einem Monolithen ist es sehr beängstigend, den Code zu löschen - Sie wissen nie, wo Sie daran hängen bleiben könnten.  Daher bleibt es meistens nur auf der Seite zu liegen.  Im Laufe der Jahre.  Und selbst toter Code muss unterstützt werden, ganz zu schweigen von der damit verbundenen Verwirrung.  Daher haben wir im Laufe der Zeit begonnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Require-Analysis</a> für eine oberflächliche Suche nach totem Code und Integrationstests sowie den Start im Coverage-Check-Modus für eine tiefere Suche zu verwenden. </p><br><h2 id="7-raspil-monolita">  7 Monolithenschnitt </h2><br><p>  Aus irgendeinem Grund denken viele Menschen, dass Sie Ihren Monolithen verlassen, eine Reihe von Mikrodiensten von Grund auf neu schreiben und alles auf einmal starten müssen, um zu Microservices zu wechseln - und es wird Glück geben.  Aber dieses Modell ... Hmm ... Es ist mit der Tatsache behaftet, dass Sie nichts tun und einfach viel Zeit und Geld für das Schreiben von Code aufwenden, den Sie wegwerfen müssen. </p><br><p>  Ich schlage eine andere Option vor, die mir besser zu funktionieren scheint und die bei uns umgesetzt wurde: </p><br><ol><li>  Wir fangen an, neue Dienste in Microservices zu schreiben.  Wir betreiben die Technologie, springen auf den Rechen, wir verstehen, ob wir das überhaupt wollen. </li><li>  Wir extrahieren den Code in Module, Bibliotheken oder was auch immer dort verwendet wird. </li><li>  Wir unterscheiden Dienstleistungen von einem Monolithen. </li><li>  Wir unterscheiden Microservices von Services.  Ohne Eile und nacheinander. </li></ol><br><h2 id="8-i-naposledok">  8 Und schließlich </h2><br><p><img src="https://habrastorage.org/webt/z8/tl/cv/z8tlcv6aibivr83m9q-fxzhusay.png" alt="Bild aufgenommen von https://fvl1-01.livejournal.com/"></p><br><p>  Am Ende habe ich beschlossen, das Wichtigste zu verlassen. </p><br><p>  Denken Sie daran: </p><br><ul><li>  Sie sind nicht Google </li><li>  Sie sind nicht Microsoft </li><li>  Du bist nicht Facebook </li><li>  Du bist nicht Yandex </li><li>  Du bist kein Netflix </li><li>  Sie sind nicht OneTwoTrip </li></ul><br><p>  Wenn etwas in anderen Unternehmen funktioniert, ist es absolut keine Tatsache, dass es Ihnen zugute kommt.  Wenn Sie versuchen, die Erfahrungen anderer Unternehmen blind mit den Worten "es funktioniert für sie" zu kopieren, wird dies höchstwahrscheinlich schlecht enden.  Jedes Unternehmen, jedes Produkt und jedes Team ist einzigartig.  Was für einige funktioniert, funktioniert für andere nicht.  Ich mag es nicht, offensichtliche Dinge zu sagen, aber zu viele Leute beginnen, einen Frachtkult um andere Unternehmen herum aufzubauen, Ansätze blind zu kopieren und sich unter gefälschten Weihnachtsbaumschmuck zu begraben.  Tu das nicht.  Experimentieren Sie, versuchen Sie, entwickeln Sie die für Sie optimalen Lösungen.  Und nur dann wird alles klappen. </p><br><h2 id="poleznye-ssylki">  Nützliche Links: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mein Bericht</a> im Videoformat </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständige Wiedergabeliste</a> von mitap von Node.JS </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459206/">https://habr.com/ru/post/de459206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459188/index.html">Debian 10 Buster und Linux 5.2 veröffentlicht</a></li>
<li><a href="../de459194/index.html">Wie wir SCSS-Freunde mit CSS-Variablen mithilfe des UI-Kit-Themas gefunden haben</a></li>
<li><a href="../de459196/index.html">Von Monolithen zu modularen Teams</a></li>
<li><a href="../de459198/index.html">Abfrageleistungsanalyse in ClickHouse. Yandex-Bericht</a></li>
<li><a href="../de459204/index.html">10 ++ Möglichkeiten, mit Hardwareregistern in C ++ zu arbeiten (z. B. IAR und Cortex M)</a></li>
<li><a href="../de459208/index.html">Laufen mit Prothesen: Nekstgen-Simulation der menschlichen Bewegung mit Muskeln, Knochen und einem neuronalen Netzwerk</a></li>
<li><a href="../de459212/index.html">Eigenschaftsimplementierung in C ++</a></li>
<li><a href="../de459214/index.html">Fehlertoleranz im Qsan-Speicher</a></li>
<li><a href="../de459216/index.html">B-Baum-Datenstruktur</a></li>
<li><a href="../de459220/index.html">Integrationstests zur Überprüfung auf Speicherlecks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>