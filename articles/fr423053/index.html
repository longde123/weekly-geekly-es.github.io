<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèª ‚òòÔ∏è üò∏ Structurer et lire uniquement: comment √©viter la d√©gradation des performances ü§≥üèæ üç≥ üöõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'utilisation du type Struct et du modificateur en lecture seule peut parfois entra√Æner une d√©gradation des performances. Aujourd'hui, nous allons dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structurer et lire uniquement: comment √©viter la d√©gradation des performances</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423053/">  L'utilisation du type Struct et du modificateur en lecture seule peut parfois entra√Æner une d√©gradation des performances.  Aujourd'hui, nous allons discuter de la fa√ßon d'√©viter cela en utilisant un analyseur de code Open Source - ErrorProne.NET. <br><br><img src="https://habrastorage.org/webt/wc/aa/xn/wcaaxny16t6cvqvl2euetypst3o.jpeg"><a name="habracut"></a><br><br>  Comme vous le savez probablement dans mes publications pr√©c√©dentes " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le modificateur 'in' et les structures en lecture seule en C #</a> " ("Le modificateur dans et les structures en lecture seule en C #") et " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les pi√®ges de performance des sections locales ref et les retours ref en C #</a> " (" Pi√®ges de performance lors de l'utilisation de variables locales et de valeurs de retour avec le modificateur ref)), travailler avec des structures est plus difficile qu'il n'y para√Æt.  Laissant de c√¥t√© la question de la mutabilit√©, je note que le comportement des structures avec modificateur en lecture seule (lecture seule) et sans lui dans des contextes en lecture seule varie consid√©rablement. <br><br>  Il est suppos√© que les structures sont utilis√©es dans des scripts de programmation qui n√©cessitent de hautes performances, et pour travailler efficacement avec elles, vous devez savoir quelque chose sur les diverses op√©rations cach√©es g√©n√©r√©es par le compilateur pour vous assurer que la structure reste inchang√©e. <br><br>  Voici une br√®ve liste des mises en garde dont vous devez vous souvenir: <br><br><ul><li>  L'utilisation de grandes structures transmises ou renvoy√©es par valeur peut entra√Æner des probl√®mes de performances sur les chemins d'ex√©cution de programme critiques. </li><li> <code>xY</code> entra√Æne la <code>xY</code> une copie de protection de x si: <br><ul><li>  <code>x</code> est un champ en lecture seule; </li><li>  le type <code>x</code> est une structure sans modificateur en lecture seule; </li><li>  <code>Y</code> n'est pas un champ. </li></ul></li></ul><br>  Les m√™mes r√®gles fonctionnent si x est un param√®tre avec le modificateur in, une variable locale avec le modificateur ref en lecture seule, ou le r√©sultat de l'appel d'une m√©thode qui renvoie une valeur via une r√©f√©rence en lecture seule. <br><br>  Voici quelques r√®gles √† garder √† l'esprit.  Et, plus important encore, le code qui s'appuie sur ces r√®gles est tr√®s fragile (c'est-√†-dire que les modifications apport√©es au code provoquent imm√©diatement des changements importants dans d'autres parties du code ou de la documentation - environ la traduction).  Combien de personnes remarqueront que remplacer <code>public readonly int X</code> ;  sur <code>public int X { get; }</code>  <code>public int X { get; }</code> dans une structure fr√©quemment utilis√©e sans modificateur en lecture seule affecte-t-elle consid√©rablement les performances?  Ou est-il facile de voir que le passage d'un param√®tre √† l'aide du modificateur in au lieu de passer par la valeur peut r√©duire les performances?  C'est vraiment possible lorsque vous utilisez la propri√©t√© in d'un param√®tre dans une boucle, lorsqu'une copie de protection est cr√©√©e √† chaque it√©ration. <br><br>  De telles propri√©t√©s des structures font litt√©ralement appel au d√©veloppement d'analyseurs.  Et l'appel a √©t√© entendu.  <a href="">D√©couvrez ErrorProne.NET</a> - un ensemble d'analyseurs qui vous informe sur la possibilit√© de modifier le code du programme pour am√©liorer sa conception et ses performances lorsque vous travaillez avec des structures. <br><br><h2>  Analyse de code avec sortie de message "Rendre la structure X en lecture seule" </h2><br>  La meilleure fa√ßon d'√©viter les erreurs subtiles et les impacts n√©gatifs sur les performances lors de l'utilisation de structures est de les rendre en lecture seule chaque fois que possible.  Le modificateur en lecture seule dans la d√©claration de structure exprime clairement l'intention du d√©veloppeur (soulignant que la structure est immuable) et aide le compilateur √† √©viter de g√©n√©rer des copies de s√©curit√© dans de nombreux contextes mentionn√©s ci-dessus. <br><br><img src="https://habrastorage.org/webt/tx/fp/5v/txfp5vx1h-8wtkuv_9epx4ulsqe.png"><br><br>  La d√©claration d'une structure en lecture seule ne viole pas l'int√©grit√© du code.  Vous pouvez ex√©cuter le fixateur (processus de correction du code) en mode batch en toute s√©curit√© et d√©clarer toutes les structures de la solution logicielle enti√®re en lecture seule. <br><br><h2>  Convivialit√© pour le modificateur de lecture seule de la r√©f√©rence </h2><br>  L'√©tape suivante consiste √† √©valuer la s√©curit√© de l'utilisation de nouvelles fonctionnalit√©s (dans le modificateur, les variables de lecture locales, les variables de r√©f√©rence, etc.).  Cela signifie que le compilateur ne cr√©era pas de copies de protection cach√©es susceptibles de r√©duire les performances. <br><br>  Trois types de types peuvent √™tre envisag√©s: <br><br><ul><li>  les structures amies en lecture seule dont l'utilisation n'entra√Æne jamais la cr√©ation de copies de protection; </li><li>  les structures qui ne sont pas conviviales √† r√©f√©rencer en lecture seule, dont l'utilisation dans le contexte de la lecture seule conduit toujours √† la cr√©ation de copies de protection; </li><li>  structures neutres - structures dont l'utilisation peut donner lieu √† des copies de protection selon l'√©l√©ment utilis√© dans le contexte de lecture seule. </li></ul><br>  La premi√®re cat√©gorie comprend les structures en lecture seule et les structures POCO.  Le compilateur ne g√©n√©rera jamais de copie de protection si la structure est en lecture seule.  Il est √©galement s√ªr d'utiliser les structures POCO dans le contexte de la lecture seule: l'acc√®s aux champs est consid√©r√© comme s√ªr et aucune copie de protection n'est cr√©√©e. <br><br>  La deuxi√®me cat√©gorie est constitu√©e des structures sans modificateur en lecture seule qui ne contiennent pas de champs ouverts.  Dans ce cas, tout acc√®s au membre public dans le contexte de lecture seule entra√Ænera la cr√©ation d'une copie de protection. <br><br>  La derni√®re cat√©gorie est constitu√©e des structures avec des champs publics ou internes et des propri√©t√©s ou m√©thodes publiques ou internes.  Dans ce cas, le compilateur cr√©e des copies de protection en fonction du membre utilis√©. <br><br>  Cette s√©paration permet de g√©n√©rer instantan√©ment des avertissements si la structure "hostile" est transmise avec le modificateur in, stock√©e dans la variable locale ref en lecture seule, etc. <br><br><img src="https://habrastorage.org/webt/nc/5a/0p/nc5a0pkfa3xsvrzqxznstyxn5yc.png"><br><br>  L'analyseur n'affiche pas d'avertissement si la structure "hostile" est utilis√©e comme champ en lecture seule, car il n'y a pas d'alternative dans ce cas.  Les modificateurs in et ref en lecture seule sont con√ßus pour √™tre optimis√©s sp√©cifiquement pour √©viter de cr√©er des copies redondantes.  Si la structure est "hostile" par rapport √† ces modificateurs, vous avez d'autres options: passer un argument par valeur ou enregistrer une copie dans une variable locale.  √Ä cet √©gard, les champs en lecture seule se comportent diff√©remment: si vous souhaitez rendre le type immuable, vous devez utiliser ces champs.  N'oubliez pas: le code doit √™tre clair et √©l√©gant, et seulement secondairement rapide. <br><br><h2>  Analyse Cci </h2><br>  Le compilateur effectue de nombreuses actions cach√©es √† l'utilisateur.  Comme indiqu√© dans un article pr√©c√©dent, il est assez difficile de voir quand une copie de protection est cr√©√©e. <br><br>  L'analyseur d√©tecte les copies cach√©es suivantes: <br><br><ol><li>  Cci du champ en lecture seule. </li><li>  Cci de po. </li><li>  Cci de la variable locale en lecture seule ref. </li><li>  Bcc return ref en lecture seule. </li><li>  Cci lors de l'appel d'une m√©thode d'extension qui prend un param√®tre avec ce modificateur par valeur pour une instance de la structure. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> NonReadOnlyStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublicMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NonReadOnlyStruct _ros; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Samples</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NonReadOnlyStruct nrs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok. Public field access causes no hidden copies var x = nrs.PublicField; // Ok. No hidden copies. x = _ros.PublicField; // Hidden copy: Property access on 'in'-parameter x = nrs.PublicProperty; // Hidden copy: Method call on readonly field _ros.PublicMethod(); ref readonly var local = ref nrs; // Hidden copy: method call on ref readonly local local.PublicMethod(); // Hidden copy: method call on ref readonly return Local().PublicMethod(); ref readonly NonReadOnlyStruct Local() =&gt; ref _ros; } }</span></span></code> </pre> <br>  Veuillez noter que les analyseurs affichent des messages de diagnostic uniquement si la taille de la structure est ‚â• 16 octets. <br><br><h2>  Utiliser des analyseurs dans des projets r√©els </h2><br>  Le transfert de grandes structures en valeur et, par cons√©quent, la cr√©ation de copies de protection par le compilateur affectent consid√©rablement les performances.  Au moins, cela est d√©montr√© par les r√©sultats des tests de performance.  Mais comment ces ph√©nom√®nes affecteront-ils les applications r√©elles en termes de temps de bout en bout? <br><br>  Pour tester les analyseurs √† l'aide de code r√©el, je les ai utilis√©s pour deux projets: le projet Roslyn et le projet interne sur lequel je travaille actuellement chez Microsoft (le projet est une application informatique ind√©pendante avec des exigences de performances strictes);  appelons-le ¬´Projet D¬ª pour plus de clart√©. <br><br>  Voici les r√©sultats: <br><br><ol><li>  Les projets avec des exigences de performances √©lev√©es contiennent g√©n√©ralement de nombreuses structures, et la plupart d'entre elles peuvent √™tre en lecture seule.  Par exemple, dans le projet Roslyn, l'analyseur a trouv√© environ 400 structures qui peuvent √™tre en lecture seule, et dans le projet D, environ 300. </li><li>  Dans les projets n√©cessitant des performances √©lev√©es, les copies aveugles ne doivent √™tre cr√©√©es que dans des situations exceptionnelles.  Je n'ai trouv√© que quelques cas de ce type dans le projet Roslyn, car la plupart des structures ont des champs publics au lieu de propri√©t√©s publiques.  Cela √©vite de cr√©er des copies de protection dans des situations o√π les structures sont stock√©es dans des champs en lecture seule.  Il y avait plus de copies aveugles dans le projet D, car au moins la moiti√© d'entre elles avaient des propri√©t√©s en lecture seule (acc√®s en lecture seule). </li><li>  Le transfert de structures m√™me assez grandes √† l'aide du modificateur in est susceptible d'avoir tr√®s peu d'effets (presque imperceptibles) sur la dur√©e du programme. </li></ol><br>  J'ai chang√© les 300 structures du projet D, les rendant en lecture seule, puis j'ai corrig√© des centaines de cas de leur utilisation, indiquant qu'elles sont pass√©es avec le modificateur in.  J'ai ensuite mesur√© le temps de transit de bout en bout pour diff√©rents sc√©narios de performances.  Les diff√©rences √©taient statistiquement insignifiantes. <br><br>  Est-ce √† dire que les fonctionnalit√©s d√©crites ci-dessus sont inutiles?  Pas du tout. <br><br>  Travailler sur un projet avec des exigences de performance √©lev√©es (par exemple, sur Roslyn ou ¬´Project D¬ª) implique qu'un grand nombre de personnes passent beaucoup de temps sur diff√©rents types d'optimisation.  En fait, dans certains cas, les structures de notre code ont √©t√© transmises avec le modificateur ref et certains champs ont √©t√© d√©clar√©s sans le modificateur readonly pour exclure la g√©n√©ration de copies de protection.  L'absence de croissance de la productivit√© lors du transfert de structures avec le modificateur in peut signifier que le code a √©t√© bien optimis√© et qu'il n'y a pas de copie excessive des structures sur les chemins critiques de son passage. <br><br><h2>  Que dois-je faire avec ces fonctionnalit√©s? </h2><br>  Je crois que la question de l'utilisation du modificateur en lecture seule pour les structures ne n√©cessite pas beaucoup de r√©flexion.  Si la structure est immuable, le modificateur en lecture seule force simplement explicitement le compilateur √† une telle d√©cision de conception.  Et le manque de copies de protection pour de telles structures n'est qu'un bonus. <br><br>  Aujourd'hui, mes recommandations sont les suivantes: si la structure peut √™tre lue seule, alors certainement proc√©dez de cette fa√ßon. <br><br>  L'utilisation des autres options envisag√©es pr√©sente des nuances. <br><br><h2>  Pr√©-optimisation contre pr√©-pessimisation? </h2><br>  Herb Sutter introduit le concept de ¬´pessimisation pr√©liminaire¬ª dans son livre √©tonnant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Coding Standards: 101 Rule, Recommendations, and Best Practices</a> . <br><br>  ¬´Ceteris paribus, la complexit√© et la lisibilit√© du code, certains mod√®les de conception efficaces et les idiomes de codage devraient naturellement s'√©couler du bout des doigts.  Un tel code n'est pas plus difficile √† √©crire que ses alternatives pessimis√©es.  Vous ne faites pas d'optimisation pr√©liminaire, mais √©vitez la pessimisation volontaire. ¬ª <br><br>  De mon point de vue, un param√®tre avec le modificateur in est juste le cas.  Si vous savez que la structure est relativement grande (40 octets ou plus), vous pouvez toujours la passer avec le modificateur in.  Le co√ªt d'utilisation du modificateur in est relativement faible, car vous n'avez pas besoin d'ajuster les appels et les avantages peuvent √™tre r√©els. <br><br>  En revanche, pour les variables locales et les valeurs de retour avec le modificateur ref en lecture seule, ce n'est pas le cas.  Je dirais que ces fonctionnalit√©s devraient √™tre utilis√©es lors du codage des biblioth√®ques, et il vaut mieux les refuser dans le code de l'application (uniquement si le profilage du code ne r√©v√®le pas que l'op√©ration de copie est vraiment un probl√®me).  L'utilisation de ces fonctionnalit√©s n√©cessite des efforts suppl√©mentaires et il devient plus difficile pour le lecteur de code de les comprendre. <br><br><h2>  Conclusion </h2><br><ol><li>  Utilisez le modificateur en lecture seule pour les structures lorsque cela est possible. </li><li>  Pensez √† utiliser le modificateur in pour les grandes structures. </li><li>  Pensez √† utiliser des variables locales et √† renvoyer des valeurs avec le modificateur ref readonly pour coder les biblioth√®ques ou dans les cas o√π les r√©sultats du profilage de code indiquent que cela peut √™tre utile. </li><li>  Utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ErrorProne.NET</a> pour d√©tecter les probl√®mes de code et partager les r√©sultats. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423053/">https://habr.com/ru/post/fr423053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423043/index.html">En raison d'une vuln√©rabilit√© du syst√®me de protection des v√©hicules √©lectriques Tesla, une voiture peut √™tre vol√©e en quelques secondes</a></li>
<li><a href="../fr423045/index.html">Quelle imprimante 3D choisir? Revue vid√©o 3Dtool</a></li>
<li><a href="../fr423047/index.html">Nous r√©servons les syst√®mes informatiques √† un prix raisonnable</a></li>
<li><a href="../fr423049/index.html">Processus d'apprentissage sous Linux</a></li>
<li><a href="../fr423051/index.html">La lutte pour les ressources, partie 1: les bases des groupes de contr√¥le</a></li>
<li><a href="../fr423055/index.html">Analystes de Wall Street: ¬´Apple nous a fait manger nos chapeaux¬ª</a></li>
<li><a href="../fr423057/index.html">Python refuse √©galement partiellement les termes ma√Ætre / esclave</a></li>
<li><a href="../fr423059/index.html">Mieux qu'ils ne le disent: trois √©l√©ments essentiels pour que le prochain MacBook devienne l'un des meilleurs ordinateurs portables d'Apple</a></li>
<li><a href="../fr423061/index.html">ref locaux et ref renvoie en C #: pi√®ges de performance</a></li>
<li><a href="../fr423063/index.html">Epson WorkForce Pro: Chroniques de la fa√ßon dont une impression de bureau √† jet d'encre ¬´a tir√© une couverture¬ª d'un laser et ce qu'elle est devenue aujourd'hui</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>