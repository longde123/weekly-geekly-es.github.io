<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍆 🐠 🏍️ Siri快速命令 ♋️ 🙋🏻 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siri Shortcuts是在WWDC 2018上引入的有用的iOS 12功能之一（在我看来）。 


 快捷方式（ shortcut ）-快速命令，一种绕过标准脚本执行任何操作的快捷方式。 


 在您的应用程序中，您可以为某些操作捕捉快捷方式。 了解用户执行方式的方式以及何时执行它们，Siri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siri快速命令</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  <strong>Siri Shortcuts</strong>是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://">WWDC 2018</a>上引入的有用的iOS 12功能之一（在我看来）。 </p><br><p> 快捷方式（ <em>shortcut</em> ）-快速命令，一种绕过标准脚本执行任何操作的快捷方式。 </p><br><p> 在您的应用程序中，您可以为某些操作捕捉快捷方式。 了解用户执行方式的方式以及何时执行它们，Siri会在正确的时间和地点明智地启动，​​为他提供这些快捷方式，最重要的是，用户将能够使用附加到他们的短语来调用它们！ 下猫多。 </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet"> 如何运作 </h2><br><p> 我们使用可以执行某些操作的应用程序，这些应用程序可以创建快捷方式并将其传递给系统。 </p><br><p> 您可以在<strong>“设置”→“ Siri和搜索”中</strong>查看这些快捷方式。 <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br> 上面的屏幕截图显示了系统从不同应用程序捕获的最后三个快捷方式。 如果单击“更多快捷方式”按钮，我们将看到每个应用程序交付给系统的所有快捷方式。 </p><br><p> 通过在快捷方式创建代码中进行某些设置，Siri将在通知和搜索中心的锁定屏幕上为用户提供这些快捷方式，重点是我们使用这些操作的频率，时间，时间，星期几以及其他因素。 </p><br><p> 例如，如果您通常在星期五晚上寻找自动提款机，然后经过培训，Siri将在星期五晚上为您提供此操作的捷径。 </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p> 如果单击“ <strong>+</strong> ”图标，则可以将语音命令添加到每个快捷方式。 </p><br><p> 我们说出语音命令，按“完成”，现在我们可以通过Siri使用语音执行快捷方式后面的操作。  <em>事实证明，用户无需打开应用程序本身即可通过Siri执行应用程序的功能。</em> 该短语的快捷方式保留在“我的快捷方式”中。 </p><br><h2 id="sozdanie-shortkatov"> 创建快捷方式 </h2><br><p>为了进行开发，我们将需要Xcode 10和iOS12。在编写本文时，它们都处于<strong>Beta</strong>阶段。 </p><br><p>可以通过<code>NSUserActivity</code>或<code>Intent</code>创建快捷方式。 </p><br><p> 第一种情况： </p><br><p> 用户单击快捷方式，该快捷方式会将带有参数（ <code>NSUserActivity</code> ）的命令传递给我们的应用程序，并决定应如何处理此命令（打开当前USD汇率的窗口，或我们最喜欢的披萨的订购窗口）。 这是众所周知的很好的旧Spotlight快捷方式，但Siri巧妙地提供了这种快捷方式。 </p><br><p> 第二种情况： </p><br><p> 通过<code>Intent</code>创建的快捷方式更有趣-它们使您无需启动应用程序即可在Siri界面中立即执行命令。 以前，这组<code>Intent</code>对Apple来说很难：转账，发送消息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等</a> 。 现在，我们的开发人员有机会创建我们的<code>Intent</code> ！ </p><br><p> 无论快捷方式是如何创建的，它都会经历生命周期的三个阶段： </p><br><ol><li> 公告（ <strong><em>定义</em></strong> ） </li><li> 交付给系统（ <strong><em>捐赠</em></strong> ） </li><li> 按应用程序处理（ <strong><em>句柄</em></strong> ） </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p> 我的研究表明，一个应用程序最多可以为系统提供20个快捷方式。 </p><br><p> 此外，我们将考虑如何使我们的应用程序具有创建快捷方式的能力以及如何在其中使用快捷方式。 </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity"> 通过<code>NSUserActivity</code>创建快捷方式 </h2><br><p> 让我们分析通过<code>NSUserActivity</code>打开的第一种简单类型的快捷方式。 </p><br><p> 例如，在移动银行应用程序中，我们有一个ATM搜索屏幕，我经常在寻找它们。 为了进入带有ATM卡的屏幕，我必须启动该应用程序，转到选项卡中的“更多”选项卡，选择“信息”部分，然后单击那里的“ ATM”按钮。 <br> 如果我们创建了可立即转到该屏幕的快捷方式，则当Siri将其提供给他时，例如在锁定屏幕上，用户将可以一键进入它。 </p><br><h3 id="obyavlyaem-shortkat-declare"> 声明快捷方式 </h3><br><p> 第一步是在<code>NSUserActivity</code>声明一个类似于我们的<code>NSUserActivity</code>的类型（可以说这是它的标识符）： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 宣布了。 </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate"> 将快捷方式传递给系统（捐赠） </h3><br><p> 声明之后，我们可以在应用程序的代码中使用上面在<strong>info.playlist中</strong>设置的类型创建<strong>NSUserActivity</strong> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p> 为了使活动进入系统快捷方式列表，需要将其设置为<code>title</code> ，并将<code>isEligibleForSearch</code>属性设置为<code>true</code> 。 其他属性对于添加到快捷方式不是必需的，但是它们的存在使快捷方式更具可读性和用户友好性。 </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p> 火！  <code>NSUserActivity</code>是将其交付给系统的最后一步。 </p><br><p>  <code>ViewConroller</code>具有<code>userActivity</code>属性，我们需要向其分配上面创建的<code>activity</code> ： </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p> 一旦执行了此行，就会从该活动中创建一个快捷方式。 它会被传送到系统并显示在Siri设置中（ <strong>设置→Siri和搜索</strong> ）。 然后，Siri将能够将其提供给用户，并且用户将能够为其分配语音命令。 </p><br><p>  <em><strong>注意</strong> ：Apple文档说，无需将活动分配给视图控制器，只需在<code>becomeCurrent()</code>上调用<code>becomeCurrent()</code>方法即可。</em>  <em>但是，此操作未将活动传递给我的系统，并且快捷方式未出现在列表中</em> </p><br><blockquote> 接下来，调用用户活动对象上的<code>becomeCurrent()</code>方法以将其标记为当前，该活动将活动捐赠给Siri。 或者，您可以将对象附加到UIViewController或UIResponder对象，这也将活动标记为当前。 </blockquote><p> 要检查一切是否正常，请打开<strong>“设置”&gt;“ Siri”并搜索</strong> -基于我们活动的快捷方式应在列表中。 </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle"> 按应用程序处理快捷方式（句柄） </h3><br><p> 当用户从通知中心浏览快捷方式或通过语音激活快捷方式时，应用程序将启动，我们必须处理此快捷方式。 </p><br><p>  <code>activity</code> <code>AppDelegate</code>方法抛出给我们： </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo"> 合计 </h3><br><p>  NSUserActivity <code>NSUserActivity</code>创建如下： </p><br><ol><li> 在<code>NSUserActivity</code>声明<code>NSUserActivity</code>的类型（标识符）。 </li><li> 我们在代码中创建<code>NSUserActivity</code>并配置 </li><li>  <code>viewController'</code> 。 </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya"> 从应用程序创建语音命令 </h2><br><p> 因此，如果用户打开<strong>“设置”&gt;“ Siri”并进行搜索</strong> ，他将看到由各种应用程序（包括我们的应用程序）创建的快捷方式列表。 通过单击“ <strong>+</strong> ”，用户可以创建任何语音命令并将其与选定的快捷方式关联。 然而，每次输入设置对于用户来说都是不方便的，许多人甚至没有意识到这种可能性。 </p><br><p> 您可以直接在应用程序内部将语音命令附加到特定操作，这很酷。 </p><br><p> 假设用户执行了某项操作并将其传递到系统，他想保存该操作。 我们可以在应用程序的屏幕上添加按钮“ <em>将动作添加到Siri</em> ”（您可以随意命名和绘制按钮），然后用户单击它就可以将该动作与应用程序中的语音命令相关联，而无需进行设置。 </p><br><p> 通过单击按钮，应该已打开用于将语音命令添加到Siri <code>INUIAddVoiceShortcutViewController</code>的快捷方式的屏幕，或用于编辑语音命令<code>INUIEditVoiceShortcutViewController</code>的屏幕（如果已创建）。 这种按钮的未反应<code>action</code>大致如下： </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p> 因此，用于添加和编辑Siri快捷方式的语音命令的屏幕如下所示： </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p> 我们还必须实现这些viewController的委托方法，在这些方法中，它们需要隐藏<code>dismiss(animated: true, completion: nil)</code>并在必要时更新当前屏幕。 例如，如果较早的屏幕上有一个“添加语音命令”按钮，则在添加语音命令后，该按钮应消失或变为“编辑语音命令”。 </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent"> 意向捷径 </h2><br><p> 到目前为止，我们仅讨论了打开应用程序并将其中的<code>NSUserActivity</code>数据传递给<code>NSUserActivity</code>快捷方式。 </p><br><p> 但是回到通过<code>Intent</code>创建的快捷方式，它们使您无需打开应用程序即可执行某些操作。 从这里开始乐趣。 </p><br><p> 想象一个用户订购他最喜欢的披萨。 他会在需要时多次订购该产品，甚至在该披萨的快捷方式中添加了语音命令-这简化了他的生活。 但是我们可以为他做更多的事情-我们可以通过发出Siri语音命令来确保系统不会将其扔到应用程序中，而是立即在Siri界面中显示订单信息和比萨饼订单！ 当用户不需要打开应用程序本身来执行某些操作时，就是这种情况。 </p><br><p> 首先，转到项目设置，选择主要目标，“ <code>Capabilities</code>选项卡并启用对Siri的访问。 </p><br><p> 我们的应用程序可以与Siri交互，但这不会在应用程序的主代码中发生，而是在单独的target-extensions中<strong>扩展。</strong> </p><br><p> 首先，必须创建此目标： <strong>文件→新建→目标</strong> ，选择<strong>意图扩展</strong> 。  Xcode将为在Siri中显示您的操作的窗口创建另一个目标扩展，如果有需要，我们表示同意。 </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1"> 声明快捷方式 </h3><br><p>  iOS 12中SiriKit的主要创新之处在于能够创建您的<code>Inetnts</code> ，而以前的<code>Inetnts</code>则没有。 </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p> 为此，请创建一个新文件： <strong>File→New→File</strong> ，从<strong>Resource</strong>部分中选择<strong>SiriKit Intent Definition File</strong> 。 </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p> 结果， <em>出现</em>扩展名为<em>.intentdefinition</em>的文件，您可以在其中创建自己的<code>Intents</code> 。 我们打开文件，文件底部显示“ <strong>No Intents</strong> ”（ <strong>无意图</strong> ），然后单击“ <strong>+</strong> ”图标。  “ <strong>新意图</strong> ”。 意向将出现在列表中，您可以在其中添加参数。 如果要订购披萨，则可以添加订购的披萨数量和披萨类型作为参数。 对于数量，我们选择<code>Integer</code>类型，对于披萨类型，我们选择<code>Custom</code>类型，这在代码中将由<code>INObject</code>类<code>INObject</code> 。 </p><br><p> 现在有几行沮丧： </p><br><p>  <strong>用户将无法将不同的参数传输到同一已保存的语音命令。</strong>  <strong>las！</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p> 什么是参数： </p><br><p> 假设您创建一个实体“ Show rate <code>%currency</code> ”，其中<code>currency</code>是一个实体参数。 这并不意味着用户可以说短语“显示美元汇率”，“显示比特币汇率”等。 开箱即用，这将无法正常工作。 但这意味着，如果用户查看美元汇率，则会创建“显示美元汇率”快捷方式，然后，当他查看比特币汇率时，将创建“显示BTC汇率”快捷方式，依此类推。 换句话说，他可能有几个基于相同意图但具有不同参数的Shorkata。 每个快捷方式，用户将能够询问他的语音命令。 </p><br><p> 好了，通过在<em>.intentdefinition</em>文件中创建一个意图， <em>Xcode</em>会自动为该意图生成一个类（注意：它不会出现在项目文件中，但可以使用）。这个自动生成的文件将仅在拥有<em>.intentdefinition</em>文件的那些目标中。 </p><br><p> 在.intentdefinition文件中创建了意图之后<em>，</em>我们可以在代码中创建意图。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1"> 将快捷方式传递给系统（捐赠） </h3><br><p> 为了将此实体包含在快捷方式列表中，您需要将其嵌入。 为此，将使用您的意图实例创建一个<code>INInteraction</code>对象，并在此<code>.donate</code>调用.donate方法 </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p> 执行此代码后，基于意图的快捷方式将被传送到系统并显示在Siri设置中。 </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle"> 我们处理快捷方式应用程序（句柄） </h3><br><p> 下一步是当用户在Siri的最上端单击该意图或使用语音命令对其进行调用时，对其进行处理。 </p><br><p> 我们已经为Siri创建了一个目标扩展，它具有一个预先创建的IntentHandler类，该类具有一个单一方法-``handle（for intent）`` </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote> 注意：如果编译器看不到您的意图类，则您尚未为Siri添加<em>.intentdefinition</em>目标扩展文件。 </blockquote><p> 在此方法中，我们确定传入意图的类型，并为每种类型创建一个处理该意图的处理程序对象。 为我们的<code>OrderPizzaIntent</code>创建一个处理程序，并在其中实现<code>OrderPizzaIntentHandling</code>协议，该协议在<code>OrderPizzaIntentHandling</code>中创建了Intent后已经自动生成。 </p><br><p> 该协议包含<code>confirm</code>和<code>handle</code>两种方法。 首先，在所有数据都被检查并检查动作的可用性的地方调用确认。 然后<code>handle</code>将在短时间内动作。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p> 这两个方法都必须使用<code>OrderPizzaIntentResponse</code>响应（它也是自动生成的）来调用<code>completion</code> <code>OrderPizzaIntentResponse</code> ，否则Siri将等待很长时间然后给出错误。 </p><br><h3 id="bolee-podrobnye-otvety-ot-siri"> 来自Siri的更多详细答案 </h3><br><p> 有一个标准的，自动生成的响应代码集- <code>enum OrderPizzaIntentResponseCode</code> ，但是对于友好的界面<code>enum OrderPizzaIntentResponseCode</code> ，它们可能还不够。 例如，在<code>confirm</code>阶段，可能会发生几个不同的错误-披萨已用完，比萨店此时不工作，等等。 用户应该了解这些事实，而不是标准消息“应用程序错误”。 还记得我们在<em>.intentdefinition</em>文件中创建了<code>Intent</code>吗？ 连同意图本身一起， <code>Response</code>了它的<code>Response</code> ，您可以在其中添加自己的错误和成功答案选项，并使用参数进行配置： </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p> 现在我们可以告诉用户更多有用的错误和答案： </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  <code>Intent</code>渲染 </h3><br><p> 如果创建了<strong>Intent Extension UI</strong>目标扩展，则可以在Siri中为所需的意图绘制自定义视图。 我们有<code>MainInterface.storyboard</code>和<code>IntentViewController</code>在其中可以草绘它们的设计。 该视图控制器实现INUIHostedViewControlling协议，并且该视图在<code>configureView</code>方法中进行<code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p> 要调用此方法，您需要将我们的意图名称添加到<code>IntentsSupported</code>的数组<code>NSExtension</code> &gt; <code>NSExtensionAttributes</code> &gt; <code>IntentsSupported</code>该数组引用扩展目标Intents UI </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 根据Siri中视图的设计以及该方法中的<code>interaction.intent</code> ，可以按所需方式绘制此视图。 以下是我们在搜索和锁定屏幕上使用Siri的意图时的屏幕截图。 </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p> 值得考虑的是，用户将无法与视图上的按钮，滚动和其他控件进行交互，因为该方法是使用参数<code>interactiveBehavior = .none</code> ，因此这肯定会带来许多限制。 </p><br><h3 id="itogo-1"> 合计 </h3><br><p> 基于<code>Intent</code>的快捷方式可以在siri界面或通知中心中呈现，并且无需打开应用程序即可执行操作。 要创建它，您需要： </p><br><ol><li> 启用使用Siri的功能 </li><li> 创建<strong>意图扩展</strong>和<strong>意图扩展UI</strong> </li><li> 创建<strong>SiriKit意向定义文件</strong> </li><li> 我们在此文件中创建<code>Intent</code>并为其分配参数。 </li><li> 创建一个<code>IntentHandler</code>在其中我们实现<code>hanlde</code>和<code>hanlde</code> </li></ol><br><h2 id="rekomendacii"> 推荐建议 </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Siri扩展目标和主要应用程序中的通用代码 </h3><br><p> 如果您的代码同时在Siri的目标和主项目的目标中使用，则有两种方法可以解决此问题： </p><br><ol><li> 突出显示通用类，将它们添加到两个目标中。  （ <strong>查看→实用工具→显示文件检查器</strong> 'e，在“ <strong>目标成员身份”</strong>部分中，向需要访问所选文件的<strong>目标</strong>添加复选标记） </li><li> 创建一个或多个目标框架，然后在此处获取常规代码。 </li></ol><br><p> 后一种方法比较可取，因为您可以在其他扩展和项目中使用这些框架。 还值得注意的是，对于这些框架，建议设置<code>Allow app extension API only</code>标志，然后在开发框架时，如果您尝试使用在开发扩展中非法的API（例如<code>UIApplication</code> ），则编译器会发誓。 </p><br><p> 可以通过<strong>应用组</strong>在目标之间翻阅共享资源 </p><br><h3 id="otladka"> 侦错 </h3><br><p> 测试快捷方式将有助于： </p><br><ol><li> 电话<strong>设置设置→开发人员</strong> ： <strong>在锁定屏幕</strong>开关<strong>上</strong> <strong>显示最近的快捷方式</strong>和<strong>显示捐赠</strong> ： </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li> 要测试Intens，您可以通过在Xcode中指定Siri打开时使用的短语来立即启动目标扩展。 为此，请为目标扩展Siri选择方案 </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p> 单击此目标，单击<strong>编辑方案...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p> 在<strong>Siri Intent Query</strong>字段中，输入一个短语，Siri将以该短语开始，就像您已经说过的一样。 </p><br><h2 id="itogo-2"> 合计 </h2><br><p> 我建议停止并总结我们所做的事情： </p><br><ol><li> 可以通过<code>NSUserActivity</code>或<code>INIntent</code>创建快捷方式 </li><li> 快捷方式需要声明（声明），报告给系统（捐赠）和处理（处理）。 </li><li> 您可以将“ <em>添加到Siri</em> ”按钮<em>添加到</em>应用程序，方法是单击该按钮，用户可以在其中添加该动作的短语，然后用他的声音对其进行调用。 </li><li> 除了内置之外，您还可以创建自己的<code>Intents</code> 。 </li><li> 通过基于Intent的<code>Intents</code>您可以创建将通过Siri界面执行的操作（在锁定屏幕上或在搜索中），而无需打开应用程序本身。 </li></ol><br><p> 在Apple文档中，有一个指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Demo项目</a>的链接，该链接对于在开发过程中进行下载和重点关注很有用。 </p><br><p> 我想强调的是，在撰写本文时，它是处于<code>beta</code>阶段的API。 而且我经常发现问题和错误。 在工作期间，我定期遇到以下问题： </p><br><ul><li>  ,  Intent  Siri,  . </li><li>   Siri     . </li><li>        Siri. </li></ul><br><h2 id="ssylki"> 参考文献 </h2><br><ol><li> WWDC 2018, session 211: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Introduction to Siri Shortcuts</a> </li><li> WWDC 2018, session 214: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Building for Voice with Siri Shortcuts</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SiriKit</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">INUIHostedViewControlling</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Demo  <strong><em>Soup Chef</em></strong>  Apple</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414677/">https://habr.com/ru/post/zh-CN414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414663/index.html">职业倦怠：专家感言</a></li>
<li><a href="../zh-CN414667/index.html">[迷你粉丝主题]终点站FIFA冠军桌</a></li>
<li><a href="../zh-CN414669/index.html">开发新的静态分析仪：PVS-Studio Java</a></li>
<li><a href="../zh-CN414673/index.html">不再是阿比巴斯：中国的技术奇迹</a></li>
<li><a href="../zh-CN414675/index.html">IT经理职业：从命令行到团队合作</a></li>
<li><a href="../zh-CN414679/index.html">Box-shadows.css</a></li>
<li><a href="../zh-CN414683/index.html">为儿童创建一个移动应用程序的故事，使您可以用自己的思想赚钱。 延续性</a></li>
<li><a href="../zh-CN414687/index.html">如何管理团队和自己：为项目经理准备的15本书</a></li>
<li><a href="../zh-CN414689/index.html">公开课“ Spring Boot 2.0上的Web应用程序和微服务”</a></li>
<li><a href="../zh-CN414691/index.html">背景 YouTube音乐和YouTube高级版：它是什么以及它们之间的不同</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>