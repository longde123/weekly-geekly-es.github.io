<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìµ ‚ö°Ô∏è ü§∞ Fragmento de blockchain üî∞ ‚úçüèΩ üëâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos, soy uno de los desarrolladores de Near Protocol, que, entre otras cosas, implementa el fragmentaci√≥n, y en este art√≠culo quiero decir en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fragmento de blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Hola a todos, soy uno de los desarrolladores de Near Protocol, que, entre otras cosas, implementa el fragmentaci√≥n, y en este art√≠culo quiero decir en detalle qu√© fragmentaci√≥n hay en la cadena de bloques, c√≥mo funciona y abordar una serie de problemas que surgen al intentar construirlo. </p><br><p>  Es bien sabido que Ethereum, la plataforma dApps m√°s popular, procesa menos de 20 transacciones por segundo.  Debido a esta restricci√≥n, el precio de las transacciones y el tiempo para confirmarlas son muy altos: a pesar del hecho de que un bloque se publica en Ethereum una vez cada 10-12 segundos, seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ETH Gas Station, el</a> tiempo entre el env√≠o de una transacci√≥n y c√≥mo realmente cae en el bloque es un promedio de 1.2 minutos  El ancho de banda bajo, los precios altos y la confirmaci√≥n de transacciones largas no permiten lanzar servicios de alto rendimiento en Ethereum. </p><br><p>  La raz√≥n principal por la que Ethereum no puede procesar m√°s de 20 transacciones por segundo es porque cada nodo en Ethereum tiene que verificar cada transacci√≥n.  Durante los cinco a√±os transcurridos desde el lanzamiento de Ethereum, se han propuesto muchas ideas para resolver este problema.  Estas soluciones se pueden dividir en dos grupos: aquellos que ofrecen delegar transacciones a un peque√±o grupo de nodos con muy buen hardware, y aquellos que ofrecen a cada nodo procesar solo un subconjunto de todas las transacciones.  Un ejemplo del primer enfoque es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thunder</a> , en el que los bloques son creados por un solo nodo, lo que permite, seg√∫n los desarrolladores, recibir 1200 transacciones por segundo, que es 100 veces m√°s que Ethereum.  Otros ejemplos de la primera categor√≠a son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solana</a> .  Todos estos protocolos mejoran varios aspectos del protocolo y le permiten realizar m√°s transacciones que en Ethereum, pero todos est√°n limitados por la velocidad de una m√°quina (aunque muy poderosa). </p><a name="habracut"></a><br><p>  El segundo enfoque, en el que cada nodo procesa solo un subconjunto de transacciones, se llama Sharding.  As√≠ es como la Fundaci√≥n Ethereum planea aumentar el ancho de banda de Ethereum. </p><br><p>  En esta publicaci√≥n, te contar√© c√≥mo funciona Sharding en Blockchain usando el ejemplo de varios protocolos que se encuentran actualmente en desarrollo. </p><br><div class="spoiler">  <b class="spoiler_title">Terminolog√≠a</b> <div class="spoiler_text"><p>  Como la terminolog√≠a no est√° estandarizada, utilizar√© los siguientes t√©rminos rusos en el art√≠culo: </p><br><p>  <strong>Un blockchain</strong> es una tecnolog√≠a en general o una estructura de datos que contiene todos los bloques, incluidos los tenedores. </p><br><p>  <strong>Una cadena</strong> es una cadena particular en la cadena de bloques, es decir, todos los bloques a los que se puede acceder a partir de un bloque que usa enlaces al bloque anterior. </p><br><p>  <strong>La cadena can√≥nica</strong> es una cadena en la cadena de bloques que el participante que observa la cadena de bloques considera la cadena actual.  Por ejemplo, en la cadena de bloques de Prueba de trabajo, ser√° la cadena con la mayor complejidad. </p><br><p>  <strong>Una red</strong> es una gran cantidad de participantes que construyen y usan blockchain. </p><br><p>  <strong>Un nodo</strong> es un servidor que admite o utiliza una red. </p></div></div><br><h2 id="samyy-prostoy-sharding">  El fragmentado m√°s f√°cil </h2><br><p>  En la implementaci√≥n m√°s simple, en lugar de admitir una cadena de bloques, admitiremos varias y llamaremos a cada una de estas cadenas de bloques un "fragmento".  Cada fragmento es compatible con un conjunto independiente de nodos que verifican las transacciones y crean bloques.  En lo sucesivo, llamar√© a tales validadores de nodos. </p><br><p>  Cada fragmento es responsable de un subconjunto de contratos y cuentas.  Suponga por ahora que las transacciones siempre operan solo con contratos y cuentas dentro del mismo fragmento.  Un dise√±o tan simplificado es suficiente para mostrar algunos problemas interesantes y caracter√≠sticas de fragmentaci√≥n. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Nombramiento de validadores y Blockchain central </h2><br><p>  El primer problema con el hecho de que cada fragmento tiene sus propios validadores es que si tenemos 10 shadras, entonces cada fragmento es ahora 10 veces menos confiable de lo que ser√≠a una cadena de bloques.  Entonces, si una cadena de bloques con validadores X decide hacer una bifurcaci√≥n dura en un sistema de fragmentos con 10 fragmentos, y rompe los validadores X entre 10 fragmentos, solo hay validadores X / 10 en cada fragmento, y obtener el control sobre el fragmento requiere obtener un control superior al 5.1% (51 % / 10) validadores. </p><br><p>  Lo que lleva a la primera pregunta interesante: ¬øqui√©n asigna validadores a los fragmentos?  Tener control sobre el 5.1% de los validadores es un problema solo si todos los 5.1% de los validadores est√°n en el mismo fragmento.  Si los validadores mismos no pueden elegir a qu√© fragmento est√°n asignados, obtener el control sobre el 5,1% de los validadores antes de asignarlos a los fragmentos no les permitir√° obtener el control sobre ning√∫n fragmento. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="imagen"></p><br><p>  Casi todos los dise√±os de fragmentos propuestos existentes utilizan alguna fuente de n√∫meros aleatorios para asignar validadores a los fragmentos.  Obtener n√∫meros aleatorios en un sistema distribuido en el que los participantes no conf√≠an entre s√≠ es un problema que hoy no se resuelve por completo, que no abordaremos en este art√≠culo, y simplemente asumimos que tenemos una fuente de n√∫meros aleatorios. </p><br><p>  Tanto la recepci√≥n de n√∫meros aleatorios como la designaci√≥n de validadores son c√°lculos a escala de todo el sistema que no son espec√≠ficos de ning√∫n fragmento en particular.  Para tales c√°lculos, los dise√±os modernos de blockchain de fragmentos tienen una blockchain dedicada adicional que existe √∫nicamente para realizar c√°lculos en todo el sistema.  Adem√°s de los n√∫meros aleatorios y la designaci√≥n de validadores, dichos c√°lculos pueden incluir obtener hashes de los √∫ltimos bloques de fragmentos y almacenarlos;  procesar colaterales en sistemas de Prueba de Estaca, y estudiar evidencia de comportamiento inapropiado con la selecci√≥n asociada de tales colaterales;  reequilibrar fragmentos, si se proporciona dicha funci√≥n.  Tal cadena de bloques se llama la cadena Beacon en Ethereum 2.0 y Near Protocol, la cadena Relay en PolkaDot y el Cosmos Hub en Cosmos. </p><br><p>  En esta publicaci√≥n llamaremos a dicha cadena de bloques la "cadena de bloques central".  La existencia de una cadena de bloques central nos lleva al siguiente tema interesante: fragmentaci√≥n cuadr√°tica. </p><br><h2 id="kvadratichnoe-shardirovanie">  Fragmentaci√≥n cuadr√°tica </h2><br><p>  El fragmentaci√≥n a menudo se presenta como una soluci√≥n que se escala infinitamente con el n√∫mero creciente de nodos.  Probablemente, realmente puede crear un sistema con esta propiedad, pero los sistemas con una cadena de bloques central tienen un l√≠mite superior en la cantidad de fragmentos y, como resultado, no tienen una escalabilidad infinita.  Es f√°cil entender por qu√©: la cadena de bloques central realiza algunos c√°lculos, como asignar validadores y preservar los √∫ltimos estados de fragmentos, cuya complejidad es proporcional al n√∫mero de fragmentos.  Dado que la cadena de bloques central en s√≠ no est√° fragmentada, y su rendimiento est√° limitado por el rendimiento de cada nodo, el n√∫mero de fragmentos que puede soportar es limitado. </p><br><p>  Veamos c√≥mo cambia el rendimiento de todo el sistema si la potencia de los nodos que lo soportan aumenta k veces.  Cada fragmento podr√° procesar k veces m√°s transacciones, y la cadena de bloques central podr√° admitir k veces m√°s fragmentos.  Por lo tanto, el rendimiento de todo el sistema crecer√° k ^ 2 veces.  De ah√≠ el nombre de "fragmentaci√≥n cuadr√°tica". </p><br><p>  Es dif√≠cil predecir cu√°nto fragmento puede soportar la cadena de bloques central hoy en d√≠a, pero lo m√°s probable es que en el futuro cercano no nos acerquemos al l√≠mite de transacci√≥n para una cadena de bloques fragmentada con fragmentaci√≥n cuadr√°tica.  Lo m√°s probable es que pronto nos encontremos con el l√≠mite de cu√°ntos nodos se necesitan para admitir tal cantidad de fragmentos. </p><br><h2 id="shardirovanie-sostoyaniya">  Fragmentaci√≥n del estado </h2><br><p>  El estado es toda la informaci√≥n sobre todas las cuentas y contratos.  Hasta ahora, hemos hablado de fragmentaci√≥n en general, sin especificar qu√© es exactamente fragmentaci√≥n.  Los nodos en la cadena de bloques realizan las siguientes tres tareas: 1) realizar transacciones 2) reenviar transacciones y bloques a otros nodos y 3) almacenar el estado y la historia de la cadena de bloques.  Cada una de estas tres tareas est√° asociada con una carga cada vez mayor en los nodos: </p><br><ol><li>  La necesidad de realizar transacciones requiere m√°s potencia inform√°tica con un aumento en el n√∫mero de transacciones; </li><li>  La necesidad de reenviar transacciones requiere m√°s ancho de banda de red a medida que crecen las transacciones; </li><li>  La necesidad de mantener el estado y el historial requiere m√°s espacio en disco a medida que aumenta el tama√±o del estado y / o el historial.  Es importante tener en cuenta que, a diferencia de los dos primeros puntos, la cantidad de espacio en disco requerido aumenta incluso si el n√∫mero de transacciones por unidad de tiempo no cambia. </li></ol><br><p>  De la lista anterior, puede parecer que el espacio en disco es el mayor problema, ya que solo el espacio en disco aumenta incluso si el n√∫mero de transacciones no aumenta, pero en la pr√°ctica no lo es.  Hoy, el estado de Ethereum toma aproximadamente 100 GB, que se pueden guardar f√°cilmente en cualquier m√°quina moderna, pero la cantidad de transacciones que Ethereum puede procesar se limita a varias decenas por segundo, dependiendo de la potencia inform√°tica y la red. </p><br><p>  Zilliqa es el proyecto m√°s famoso que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fragmenta la inform√°tica y la red</a> pero no el estado.  Calcular el fragmentaci√≥n es m√°s simple que el estado de fragmentaci√≥n, porque todos los nodos tienen todos los estados, y a√∫n pueden ejecutar f√°cilmente contratos que causan otros contratos o afectan cuentas en diferentes fragmentos.  En estos aspectos, el dise√±o de Zilliqa es demasiado simplificado, las cr√≠ticas al dise√±o en ingl√©s se pueden leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Si bien se propuso la fragmentaci√≥n de estado sin fragmentaci√≥n de c√°lculo, no conozco ning√∫n proyecto que realmente haga esto, por lo que asumiremos que la fragmentaci√≥n de estado implica la fragmentaci√≥n de los c√°lculos. </p><br><p>  En la pr√°ctica, el hecho de que el estado est√© fragmentado de alguna manera a√≠sla los fragmentos, lo que les permite ser cadenas de bloques independientes, como definimos anteriormente.  Los validadores en fragmentos solo almacenan un estado espec√≠fico de su fragmento, y solo las transacciones que afectan a este estado se ejecutan y reenv√≠an.  Esto reduce la carga en el procesador, el disco y la red linealmente con el n√∫mero de fragmentos, pero trae nuevos problemas, como las transacciones entre fragmentos. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Transacciones entre fragmentos </h2><br><p>  Hasta ahora, hemos visto fragmentos como cadenas de bloques independientes en t√©rminos de c√≥mo ejecutan transacciones.  Con este dise√±o, por ejemplo, es imposible completar una transacci√≥n que transfiere dinero entre dos cuentas en dos fragmentos diferentes, o causar contacto en un fragmento de un contrato en otro.  Me gustar√≠a apoyar ambos escenarios. </p><br><p>  Por simplicidad, solo consideraremos las transacciones que transfieren dinero, y asumiremos que cada participante tiene una cuenta en exactamente un fragmento.  Si un participante en un fragmento desea transferir dinero a un participante en el mismo fragmento, los validadores de este fragmento pueden procesar esta transacci√≥n y aplicarla al estado.  Pero si, por ejemplo, Alice tiene una cuenta en el fragmento n. ¬∞ 1 y quiere enviar dinero a Bob con una cuenta en el fragmento n. ¬∞ 2, ni los validadores del fragmento n. ¬∞ 1 (que no pueden agregar dinero a Bob) ni los validadores del fragmento n. ¬∞ 2 (que no pueden obtener el dinero de Alice ) no puede completar la transacci√≥n y actualizar el estado. </p><br><p>  Hay dos grandes grupos de enfoques para resolver este problema: </p><br><ol><li><p>  <strong>Sincr√≥nico</strong> : para cualquier transacci√≥n que involucre varios fragmentos, los bloques en fragmentos que contienen actualizaciones de estado para esta transacci√≥n se producen simult√°neamente, y los validadores en estos fragmentos trabajan juntos para crear tales bloques.  El dise√±o m√°s elaborado de este enfoque, conocido por m√≠, es Merge Blocks, descrito (en ingl√©s) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br></li><li><p>  <strong>As√≠ncrono</strong> : una transacci√≥n entre fragmentos se ejecuta en fragmentos que afecta, de forma as√≠ncrona: la parte de la transacci√≥n que agrega dinero a Bob se ejecuta en el fragmento # 2 cuando los validadores en el fragmento tienen alguna evidencia de que la parte de la transacci√≥n que resta dinero de Alice se ejecut√≥ en fragmento # 1.  Este enfoque es m√°s popular en los sistemas que se desarrollan actualmente debido al hecho de que no requiere sincronizaci√≥n adicional entre fragmentos para la producci√≥n de bloques.  Tales sistemas se ofrecen hoy en Cosmos, Ethereum Serenity, Near Protocol, Kadena y otros.  El problema con este enfoque es que si los bloques se producen de forma independiente, es probable que uno de los bloques que contiene la actualizaci√≥n de estado para la transacci√≥n no est√© en la cadena can√≥nica en su fragmento y, por lo tanto, la transacci√≥n solo se completar√° parcialmente.  Por ejemplo, considere la figura a continuaci√≥n.  Muestra dos fragmentos en los que se produjeron los tenedores y una transacci√≥n entre fragmentos, cuya actualizaci√≥n de estado se refleja en los bloques A y X ', respectivamente.  Si las cadenas AB y V'-X'-Y'-Z 'resultan ser can√≥nicas en sus fragmentos, entonces la transacci√≥n est√° completamente finalizada.  Si las cadenas A'-B'-C'-D 'y VX son can√≥nicas, entonces la transacci√≥n se cancela por completo, lo cual es aceptable.  Pero si, por ejemplo, AB y VX se vuelven can√≥nicos, una parte de la transacci√≥n se finaliza, la otra se cancela y la transacci√≥n se completa parcialmente. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="imagen"></p><br><p>  El escenario descrito anteriormente es uno de los grandes problemas de fragmentaci√≥n, en el que todas las soluciones propuestas no son √≥ptimas.  Lo tocaremos un poco m√°s abajo. </p><br><h2 id="plohoe-povedenie">  Mal comportamiento </h2><br><p>  Ahora que hemos descubierto c√≥mo funcionan las cadenas de bloques de fragmentos y estudiamos los conceptos de cadena de bloques central, la designaci√≥n de validadores y las transacciones de fragmentos cruzados, al final de este art√≠culo veremos otro tema interesante: ¬øqu√© puede hacer un participante que intenta atacar el sistema si logra obtener control sobre un n√∫mero suficientemente grande de validadores en un fragmento. </p><br><h3 id="celenapravlennye-forki">  Horquillas dirigidas </h3><br><p>  Si el participante tiene suficiente control sobre el fragmento, puede crear tenedores a prop√≥sito.  Para crear tenedores, no importa qu√© consenso se use en los fragmentos, en particular, no importa si es BFT o no, si un n√∫mero suficiente de validadores est√°n bajo el control de un atacante, puede crear un tenedor.  Por ejemplo, el objetivo de la bifurcaci√≥n podr√≠a ser deshacer una transacci√≥n que pag√≥ por algo fuera de la cadena de bloques. </p><br><p>  Se afirma que obtener el control del 50% del fragmento es m√°s f√°cil que el 50% de toda la red (por ejemplo, porque un participante puede intentar piratear o sobornar validadores despu√©s de haber sido asignado al fragmento).  Por definici√≥n, las transacciones entre fragmentos cambian de estado en varios fragmentos.  Tales cambios caer√°n en algunos bloques en las cadenas de bloques de los fragmentos correspondientes.  Es necesario que todos estos bloques est√©n finalizados (es decir, pertenezcan a la cadena can√≥nica en sus fragmentos respectivos) o que no todos est√©n finalizados (es decir, no pertenezcan a la cadena can√≥nica en sus fragmentos).  Dado que asumimos que algunos participantes con malas intenciones pueden, en principio, obtener el control sobre el fragmento, no podemos suponer que los tenedores no ocurrir√°n incluso si se alcanza el consenso bizantino, o si se construy√≥ un gran n√∫mero de bloques en la parte superior del bloque con la transacci√≥n. </p><br><p>  Este problema tiene muchas soluciones, la m√°s simple de las cuales es a veces guardar el hash del √∫ltimo bloque en el fragmento en la cadena de bloques central.  El algoritmo de selecci√≥n de cadena can√≥nica en fragmentos luego se cambia para que ning√∫n objetivo que contenga el √∫ltimo bloque almacenado en la cadena de bloques central can√≥nico.  Luego, para evitar por completo situaciones en las que la transacci√≥n se complet√≥ parcialmente debido al hecho de que algunos de los bloques que contienen su actualizaci√≥n de estado quedaron fuera de las cadenas can√≥nicas, puede cambiar el algoritmo para ejecutar transacciones entre fragmentos de modo que el fragmento A no acepte la prueba de la transacci√≥n en el fragmento B hasta el bloque que contiene la actualizaci√≥n de estado para la transacci√≥n en el fragmento B no se guard√≥ en la cadena de bloques central. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Crear bloques inv√°lidos </h3><br><p>  Si el participante pudo obtener el control sobre un n√∫mero suficientemente grande de validadores en el fragmento, puede intentar crear un bloque completamente inv√°lido.  Por ejemplo, suponga que antes del bloque, el estado era tal que Alice ten√≠a 10 tokens, y en Bob - 0, el bloque contiene solo una transacci√≥n, que env√≠a 10 tokens de la cuenta de Alice a la cuenta de Bob, pero en el nuevo estado refleja 0 tokens de Alice, y 1000 con Bob </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="imagen"></p><br><p>  En una cadena de bloques cl√°sica, sin fragmentos, es imposible crear dicho bloque, porque todos los participantes, como aquellos que crean bloques y aquellos que simplemente usan la cadena de bloques, verifican todos los bloques e inmediatamente descartan cualquier bloque que contenga tales errores.  Incluso si los validadores controlados por el atacante pueden construir la cadena m√°s r√°pido, esto no les permitir√° pasar la cadena m√°s larga que contiene el bloque no v√°lido como el can√≥nico, porque todos los participantes de la red descartar√°n inmediatamente el bloque no v√°lido y cualquier bloque que se haya construido encima.  Los validadores honestos continuar√°n construyendo sobre el √∫ltimo bloque v√°lido, y todos los participantes de la red ver√°n su cadena como can√≥nica. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="imagen"></p><br><p>  La figura anterior muestra cinco validadores, tres de los cuales est√°n bajo el control del atacante.  Crearon el bloque no v√°lido A ', y luego continuaron construyendo la cadena en la parte superior.  Dos validadores privados descartaron inmediatamente el bloque A 'como no v√°lido y continuaron construyendo sobre el √∫ltimo bloque v√°lido que conoc√≠an, creando as√≠ una bifurcaci√≥n.  Como hay menos validadores en una cadena honesta que en una deshonesta, su cadena es m√°s corta.  Sin embargo, en la cl√°sica cadena de bloques sin sombrear, todos los participantes en el sistema validan todos los bloques que ven.  Por lo tanto, cualquier participante que use la cadena de bloques ver√° que A 'no es v√°lido, lo descartar√° y, por lo tanto, descartar√° B', C 'y D' como est√° construido sobre el bloque no v√°lido, y as√≠ todos los participantes ver√°n AB como una cadena can√≥nica. </p><br><p>  En un dise√±o de fragmento, ning√∫n participante puede validar todos los bloques en todas las cadenas de bloques.  Por lo tanto, necesitamos alg√∫n tipo de mecanismo que permita a los validadores en un fragmento particular asegurarse de que en ning√∫n momento en el pasado se haya creado un bloque no v√°lido en otro fragmento del que recibieron una transacci√≥n entre fragmentos. </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     ‚Äî   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escribo mucho sobre blockchain y sharding en ingl√©s. </font><font style="vertical-align: inherit;">Tambi√©n entrevistamos peri√≥dicamente a autores de otros protocolos como Cosmos y Solana, profundizando en detalles t√©cnicos. </font><font style="vertical-align: inherit;">Si est√° interesado en el tema, puede seguir nuevas publicaciones y videos suscribi√©ndose a mi Twitter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437924/">https://habr.com/ru/post/437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437912/index.html">Un peque√±o cuaderno para un administrador del sistema</a></li>
<li><a href="../437914/index.html">Generaci√≥n de clases Jaxb (XJC) a partir del esquema XML (XSD) con descripciones de clase y campo en forma de anotaciones. Complemento XJC</a></li>
<li><a href="../437916/index.html">¬°Dale al lector de libros electr√≥nicos en cada bolsillo! Revisi√≥n de las √∫ltimas innovaciones de ONYX BOOX</a></li>
<li><a href="../437918/index.html">Grabaci√≥n de video con expulsi√≥n autom√°tica de pausa mediante software gratuito con construcci√≥n de bicicletas</a></li>
<li><a href="../437922/index.html">Modelo de ataque: donde se abusa principalmente en adquisiciones electr√≥nicas y c√≥mo tratarlo</a></li>
<li><a href="../437926/index.html">La gu√≠a autorizada para Fragmentos de Blockchain</a></li>
<li><a href="../437928/index.html">Como aprender ingles</a></li>
<li><a href="../437930/index.html">Combo de accesorios de iluminaci√≥n</a></li>
<li><a href="../437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../437934/index.html">Gesti√≥n del tiempo en la vida real.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>