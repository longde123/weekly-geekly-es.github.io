<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé™ üë¶üèº üë©‚Äçüç≥ TelegramBot. Die Grundfunktionalit√§t. Fliegen getrennt, Schnitzel getrennt. (Teil 2) üë®üèø‚Äçüíª üìÇ üßúüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir entwickeln die Grundfunktionalit√§t f√ºr den Bot in Telegrammen weiter. In den vorangegangenen Abschnitten haben wir den Punkt besprochen, dass die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TelegramBot. Die Grundfunktionalit√§t. Fliegen getrennt, Schnitzel getrennt. (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481354/"> Wir entwickeln die Grundfunktionalit√§t f√ºr den Bot in Telegrammen weiter.  In den vorangegangenen Abschnitten haben wir den Punkt besprochen, dass die Arbeit des Bots beim Empfangen, Verarbeiten und Senden von Nachrichten aufgeteilt werden sollte.  Versuchen wir, die grundlegenden Java Core-Tools zu verwenden, um unseren Bot multithreading- und asynchron zu machen.  Wir werden eine Aufgabe entwickeln, deren Bearbeitung viel Zeit in Anspruch nimmt.  Mal sehen, wie die Befehle im Telegramm funktionieren und wie sie verarbeitet werden m√ºssen. <br><br>  Dies ist eine Fortsetzung des ersten Teils des Artikels √ºber das Programmieren von Bots f√ºr Telegramme in Java <br>  <a href="https://habr.com/ru/post/476306/">TelegramBot-Anweisungen zum Erstellen grundlegender Funktionen f√ºr den Bot.</a>  <a href="https://habr.com/ru/post/476306/">(Teil 1)</a> <br>  F√ºr wen es weiter interessant ist, sind Sie herzlich willkommen‚Ä¶ <br><a name="habracut"></a><br>  Ich muss sofort sagen, dass in diesem Teil viel auf einmal hinzugef√ºgt wurde und wir im Hintergrund alle Funktionen analysieren werden, die es dem Bot erm√∂glichten, Multithreading durchzuf√ºhren, und warum es √ºberhaupt ben√∂tigt wird. <br><br>  Wie √ºblich aus der Hauptsache: <br>  Sie finden den fertigen Code f√ºr diesen Artikel im Zweig <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers" rel="nofollow">Part2-Handlers</a> im Git-Repository. <br>  Der Code ist voll funktionsf√§hig, es reicht aus, die Daten f√ºr die Autorisierung des Bots (Name und Token) zu √§ndern und die Hauptmethode in der App.class-Klasse auszuf√ºhren. <br><br>  <i>Bitte beachten Sie, dass diese Klasse eine Benachrichtigung an den Bot-Administrator sendet, wenn der Bot startet, dass der Bot gestartet wurde.</i>  <i>Die Administrator-ID des Bots wird auch in der App.class-Klasse angegeben. Wenn Sie diese nicht √§ndern, versucht Ihr Bot, Nachrichten an mich zu senden :)</i> <br><br>  Und weiter unten werden wir die √Ñnderungen analysieren, die nach der Ver√∂ffentlichung des ersten Teils aufgetreten sind. <br><br><h3>  Befehlsverarbeitung </h3><br>  Zun√§chst wollen wir uns mit diesem Konzept befassen, was ein Team im Allgemeinen in einem System zur Kommunikation mit einem Telegrammbot darstellt.  Abh√§ngig von den Einstellungen des Bots k√∂nnen entweder Nachrichten in einem beliebigen Format oder nur speziell gestaltete Befehle angezeigt werden.  Was ist der Unterschied und <br>  wo Sie diese Nachrichtenoptionen treffen k√∂nnen. <br><br><ol><li>  <b>Klartext, normale Nachrichten.</b> <br>  In dieser Form erh√§lt der Bot Nachrichten, wenn er in PM an ihn schreibt.  Wenn jedoch in den Einstellungen des Bots <a href="https://core.telegram.org/bots" rel="nofollow">der Datenschutzmodus in Gruppen</a> deaktiviert ist, werden alle Nachrichten vom Bot vollst√§ndig angezeigt.  Wenn diese Einstellung aktiviert ist, werden dem Bot beim Hinzuf√ºgen zur Gruppe nur die an ihn gerichteten Befehle angezeigt.  Wie sie aussehen - siehe den zweiten Absatz </li><li>  <b>Speziell entwickelte Teams</b> <br>  Solche Befehle beginnen immer mit einem Schr√§gstrich: <b>/</b> <br>  Danach kommt das Team selbst.  Der Befehlstext sollte keine Leerzeichen enthalten.  Ein Beispiel: <br>  <b>Ich fange an</b> <br>  Mit diesem Befehl startet jeder Benutzer immer die Kommunikation mit Ihrem Bot.  Daher muss nach den Regeln der guten Form die Reaktion auf diesen Befehl vorgeschrieben werden. <br><img src="https://habrastorage.org/webt/ol/pi/ud/olpiudptbqgig5zhoqzpnpjquyq.png"><br>  Bei allen Befehlen, mit denen Ihr Bot umgehen kann, ist es ratsam, die Liste der F√§higkeiten in den Einstellungen Ihres Bot zu erweitern.  Dies geschieht alles in einem Telegramm mit @BotFather. <br><br>  <b>W√§hlen Sie mit dem Befehl / myBots</b> Ihren Bot und dann die Schaltfl√§che ‚ÄûBot bearbeiten‚Äú aus <br>  Sie erhalten ein Fenster, in dem alle Parameter des Bots angezeigt werden. Anschlie√üend k√∂nnen Sie die gesamte Benutzeroberfl√§che konfigurieren und angeben, mit welchen Befehlen Ihr Bot arbeiten kann. <br><br><img src="https://habrastorage.org/webt/u6/7o/cl/u67oclalxrv7v3v83h1wzp91gr4.png"><br><br>  Sie sind in diesem Format festgelegt: <br><br><img src="https://habrastorage.org/webt/-a/4x/i-/-a4xi-kqpuxjoielhmog7oh1tom.png"><br><br>  Wenn Sie danach einen Befehl in Ihren Bot eingeben, wird die Hilfe mit einer Liste der aufgef√ºhrten Befehle angezeigt: <br><br><img src="https://habrastorage.org/webt/hn/yi/wa/hnyiwabkhmbrc7zn0rbuzkfvook.png"><br><br>  Und es gibt noch eine Nuance.  Eine Gruppe kann mehrere Bots enthalten. Wenn sie gemeinsame Befehle haben (und gemeinsame Befehle obligatorisch sind, werden in den meisten Bots derselbe Start und dieselbe Hilfe implementiert), wird dem Befehl selbst ein Teil hinzugef√ºgt, der angibt, zu welchem ‚Äã‚ÄãBot dieser Befehl geh√∂rt.  Und der Befehl sieht komplett so aus: <br>  <b>/ start @ test_habr_bot</b> <br></li></ol><br>  Und jetzt, da wir all diese Nuancen kennen, wollen wir mit Ihnen eine solche Verarbeitungsoption erstellen, die Befehle verstehen sollte, die mit einem Schr√§gstrich beginnen und zu unterscheiden wissen, ob der Befehl speziell an Ihren Bot oder an einen anderen gerichtet ist. <br><br>  Erstellen Sie ein Paket, das die Klassen enth√§lt, die f√ºr die Verarbeitung der Befehle verantwortlich sind. <br>  <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/command" rel="nofollow">package com.example.telegrambot.command</a> <br><br>  In der Command-Klasse listen wir alle Befehle auf, die unser Bot verstehen sollte. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Command { NONE, NOTFORME, NOTIFY, START, HELP, ID }</code> </pre> <br>  Wie du vorher gesehen hast, habe ich bei @BotFather darauf hingewiesen, dass der Bot 4 Teams verstehen sollte.  Dies ist der Standardstart und die Standardhilfe.  Wir f√ºgen eine n√ºtzliche ID hinzu.  Und noch eine, benachrichtige, wor√ºber ich etwas sp√§ter sprechen werde.  Und zwei Teams, NONE und NOTFORME, die uns mitteilen, dass es sich bei der Textnachricht entweder gar nicht um einen Befehl handelt oder dass dieser Befehl nicht f√ºr unseren Bot bestimmt ist. <br><br>  <a href="" rel="nofollow">F√ºgen Sie eine</a> weitere <a href="" rel="nofollow">Hilfsklasse ParsedCommand hinzu</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.AllArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Getter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NoArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Setter; <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedCommand</span></span></span><span class="hljs-class"> </span></span>{ Command command = Command.NONE; String text=<span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Der Hauptzweck ist das Speichern des Ergebnisses der Textanalyse in Objekten dieser Klasse.  Es wird nur das Team selbst und den gesamten Text enthalten, der nach dem Team kommt. <br><br>  Und wir werden eine separate Klasse schreiben, die die Teams f√ºr uns parsen wird.  <a href="" rel="nofollow">Parser-</a> Klasse <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javafx.util.Pair; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(Parser.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PREFIX_FOR_COMMAND = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DELIMITER_COMMAND_BOTNAME = <span class="hljs-string"><span class="hljs-string">"@"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String botName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String botName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.botName = botName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String trimText = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) trimText = text.trim(); ParsedCommand result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedCommand(Command.NONE, trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(trimText)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; Pair&lt;String, String&gt; commandAndText = getDelimitedCommandFromText(trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommand(commandAndText.getKey())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommandForMe(commandAndText.getKey())) { String commandForParse = cutCommandFromFullText(commandAndText.getKey()); Command commandFromText = getCommandFromText(commandForParse); result.setText(commandAndText.getValue()); result.setCommand(commandFromText); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.setCommand(Command.NOTFORME); result.setText(commandAndText.getValue()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutCommandFromFullText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(DELIMITER_COMMAND_BOTNAME) ? text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, text.indexOf(DELIMITER_COMMAND_BOTNAME)) : text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String upperCaseText = text.toUpperCase().trim(); Command command = Command.NONE; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { command = Command.valueOf(upperCaseText); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IllegalArgumentException e) { log.debug(<span class="hljs-string"><span class="hljs-string">"Can't parse command: "</span></span> + text); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Pair&lt;String, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDelimitedCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String trimText)</span></span></span><span class="hljs-function"> </span></span>{ Pair&lt;String, String&gt; commandText; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trimText.contains(<span class="hljs-string"><span class="hljs-string">" "</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexOfSpace = trimText.indexOf(<span class="hljs-string"><span class="hljs-string">" "</span></span>); commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, indexOfSpace), trimText.substring(indexOfSpace + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> commandText; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommandForMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command.contains(DELIMITER_COMMAND_BOTNAME)) { String botNameForEqual = command.substring(command.indexOf(DELIMITER_COMMAND_BOTNAME) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> botName.equals(botNameForEqual); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.startsWith(PREFIX_FOR_COMMAND); } }</code> </pre> <br>  Kurz gesagt.  Beim Initialisieren des Parsers m√ºssen wir den Namen unseres Bots im Konstruktor √ºbergeben, damit der Parser seine Befehle von Fremden unterscheiden kann. <br><br>  Dann rufen wir einfach die √∂ffentliche Methode auf <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span></span></code> </pre> <br>  An die wir den Nachrichtentext in den Argumenten √ºbergeben, und er muss uns einen Befehl und den Nachrichtentext zur√ºckgeben, der nach dem Befehl kommt. <br><br>  Sie k√∂nnen sehen, wie der Parser in der Testklasse funktioniert. <br><br><h3>  Fliegen getrennt, Schnitzel getrennt </h3><br>  Jetzt m√ºssen wir unserem Bot beibringen, Nachrichten separat zu empfangen, zu verarbeiten und Antworten zu senden.  Nach einer Reihe von Versuchen bin ich zu dieser Logik der Anwendung gekommen. <br>  Der Hauptklassen- <a href="" rel="nofollow">Bot</a> arbeitet im Haupt-Thread der Anwendung und ist nur damit besch√§ftigt, dass er alle empfangenen Nachrichten in eine spezielle Warteschlange stellt und auch ein Container f√ºr Nachrichten ist, die wir als Antwort an den Benutzer senden m√∂chten. <br><br>  Die √Ñnderungen in dieser Klasse sind sehr gering.  Wir haben zwei Warteschlangen hinzugef√ºgt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; sendQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; receiveQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;();</code> </pre><br>  und den Funktionscode <b>public void onUpdateReceived (Update update)</b> leicht umgeschrieben <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdateReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"Receive new Update. updateID: "</span></span> + update.getUpdateId()); receiveQueue.add(update); }</code> </pre> <br>  Warum so?  Wieder habe ich verschiedene Optionen ausprobiert.  Das Hauptproblem beim Multithreading ist das Arbeiten mit gemeinsam genutzten Daten.  Und am meisten hat mir gefallen, wie die Implementierung von Multithread-Warteschlangen <b>ConcurrentLinkedQueue &lt;&gt; () damit</b> umgeht. <br>  Und wie Sie sehen, werden in beiden Warteschlangen Objektdatentypen gespeichert.  Dies ist ein weiteres Lesezeichen f√ºr die Zukunft.  Wir sind also nicht an die Art der empfangenen Nachrichten gebunden.  In der eingehenden Warteschlange k√∂nnen wir nicht nur Objekte vom Typ Update hinzuf√ºgen, sondern auch einige andere Objekte, die wir ben√∂tigen. <br><br>  Das gleiche gilt f√ºr die Warteschlange zum Senden.  Da wir verschiedene Arten von Nachrichten senden k√∂nnen und sie kein gemeinsames √ºbergeordnetes Objekt haben, verwenden wir auch einen gemeinsamen Datentyp - Object. <br>  Wenn Sie den Bot in dieser Form ausf√ºhren, wird es funktionieren, aber nichts tun.  Er zeichnet alle empfangenen Nachrichten im Protokoll auf und stellt sie in die Warteschlange. <br>  Aus diesem Grund ben√∂tigen wir einen Thread, der sich darum k√ºmmert, empfangene Nachrichten aus der Warteschlange zu √ºbernehmen, einige Aktionen <b>auszuf√ºhren</b> und die Ergebnisse seiner Arbeit in die <b>sendQueue-</b> Warteschlange zu stellen. <br><br>  Lassen Sie uns ein separates Paket erstellen: <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/service" rel="nofollow">service</a> und darin werden wir nur 2 Klassen haben: <br><br>  <b>MessageReciever</b> - Handler f√ºr empfangene Nachrichten <br>  <b>MessageSender</b> ist der Message Queue Handler, der an den Benutzer gesendet werden soll. <br><br>  Wir werden ihre Arbeit etwas niedriger betrachten, aber im Moment werden wir ihre Verwendung in unserer Startklasse- <a href="" rel="nofollow">App beschreiben</a> <br><br>  Nachdem sich unser Bot verbunden hat, starten wir unsere Handler in separaten Threads: <br><br><pre> <code class="java hljs">MessageReciever messageReciever = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageReciever(test_habr_bot); MessageSender messageSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageSender(test_habr_bot); test_habr_bot.botConnect(); Thread receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageReciever); receiver.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); receiver.setName(<span class="hljs-string"><span class="hljs-string">"MsgReciever"</span></span>); receiver.setPriority(PRIORITY_FOR_RECEIVER); receiver.start(); Thread sender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageSender); sender.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); sender.setName(<span class="hljs-string"><span class="hljs-string">"MsgSender"</span></span>); sender.setPriority(PRIORITY_FOR_SENDER); sender.start();</code> </pre><br>  F√ºr beide Threads geben wir den Daemon-Modus an.  Dies ist erforderlich, damit die Threads funktionieren, solange der Haupt-Thread ausgef√ºhrt wird, und sich selbst beenden, sobald er seine Arbeit beendet. <br><br>  Wir m√∂chten uns nicht zuerst mit dem Handler f√ºr eingehende Nachrichten befassen - schauen wir uns die Funktionsweise der <a href="" rel="nofollow">MessageSender-</a> Klasse an. <br><br>  Werfen wir einen Blick darauf, was er kann und was er tut: <br><br><ul><li>  Dies ist nat√ºrlich eine Vererbung der Schnittstelle f√ºr Multithreading: <br>  <b>ger√§te lauff√§hig</b> <br>  und Implementierung der <b>Run-</b> Funktion <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Hier starten wir die Endlosschleife, die nur damit besch√§ftigt ist, dass sie die Sendewarteschlange √ºberpr√ºft und den Sendebefehl aufruft <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  wenn etwas in der Warteschlange erscheint. <br></li><li>  Im Klassenkonstruktor √ºbergeben wir das Objekt der Bot-Klasse, weil  von ihm werden wir Objekte zum Versenden von Nachrichten nehmen und mit ihm werden wir sie senden. </li><li>  Die send-Methode bestimmt den Typ der zu sendenden Nachricht und wendet den entsprechenden Befehl darauf an. </li></ul><br>  Nun <a href="" rel="nofollow">schauen</a> wir <a href="" rel="nofollow">uns die</a> Arbeit der <a href="" rel="nofollow">MessageReciever-</a> Klasse an <br><br>  Er muss, wie MessageSender, Multithreading-f√§hig sein, im Konstruktor ein Objekt der Klasse Bot erhalten, in dem er empfangene Nachrichten in einer Endlosschleife aufnimmt, verarbeitet und in die Warteschlange stellt, um die Ergebnisse seiner Arbeit zu senden. <br><br>  Hier verwenden wir den zuvor erstellten Befehlsparser.  Und dann f√ºgen wir die M√∂glichkeit hinzu, verschiedene Arten von Handlern f√ºr unsere Teams zu verwenden, und einige von ihnen werden Multi-Thread-f√§hig sein. <br><br>  Der Arbeitszyklus ist sehr einfach: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"[STARTED] MsgReciever. Bot class: "</span></span> + bot); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object = bot.receiveQueue.poll(); object != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; object = bot.receiveQueue.poll()) { log.debug(<span class="hljs-string"><span class="hljs-string">"New object for analyze in queue "</span></span> + object.toString()); analyze(object); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(WAIT_FOR_NEW_MESSAGE_DELAY); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { log.error(<span class="hljs-string"><span class="hljs-string">"Catch interrupt. Exit"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  √úberpr√ºfen Sie die Warteschlange.  Wenn es etwas gibt, f√ºhren Sie den Analysator aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  Wenn es nichts gibt, warten wir. <br><br>  Der Analysator √ºberpr√ºft den Objekttyp.  Wenn er wei√ü, wie er mit ihm arbeiten soll, startet er den n√§chsten Analysator.  Wenn Sie nicht k√∂nnen - schw√∂rt :) <br><br>  Warum so?  Auch dies ist ein Lesezeichen f√ºr die Zukunft und ich hoffe, dass ich es in den n√§chsten Teilen dieser Artikelserie ver√∂ffentlichen werde.  Eine solche Implementierung erm√∂glicht es uns, eigene Aufgaben f√ºr den Bot zu erstellen, Mailinglisten zu erstellen und Tagesaufgaben zu erledigen.  Dazu muss der Empf√§nger nicht nur Objekte vom Typ Update verarbeiten k√∂nnen, sondern auch etwas von uns.  Aber dazu sp√§ter mehr :) <br><br>  Betrachten Sie den Analyzer f√ºr den Aktualisierungstyp genauer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyzeForUpdateType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ Long chatId = update.getMessage().getChatId(); String inputText = update.getMessage().getText(); ParsedCommand parsedCommand = parser.getParsedCommand(inputText); AbstractHandler handlerForCommand = getHandlerForCommand(parsedCommand.getCommand()); String operationResult = handlerForCommand.operate(chatId.toString(), parsedCommand, update); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(operationResult)) { SendMessage message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendMessage(); message.setChatId(chatId); message.setText(operationResult); bot.sendQueue.add(message); } }</code> </pre> <br>  Es definiert die Chat-ID.  Ruft den Nachrichtentext ab.  Mit dem Parser wird bestimmt, ob es sich bei der Nachricht um einen Befehl handelt und welcher Handler f√ºr diesen Befehl verwendet werden soll.  Die Verarbeitung des Befehls wird gestartet, und wenn bei der Verarbeitung des Befehls nicht leerer Text zur√ºckgegeben wird, wird eine Nachricht zum Senden an den Benutzer erstellt und in die Warteschlange eingereiht. <br><br>  Und dann sollten Sie eine Frage haben: "Was f√ºr ein Handler?".  Es wurde vorher nicht √ºber ihn gesprochen, und er wurde im Kodex nicht erw√§hnt.  Alles ist richtig.  Nun werden wir diese Funktionalit√§t analysieren. <br><br>  Erstellen Sie dazu ein separates Paket, in dem alle unsere Handler gespeichert werden.  Nennen Sie es <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/handler" rel="nofollow">Handler</a> <br>  Lassen Sie uns eine abstrakte Klasse <a href="" rel="nofollow">AbstractHandler</a> erstellen <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ Bot bot; AbstractHandler(Bot bot) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bot = bot; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span></span>; }</code> </pre> <br>  Er wird einen grundlegenden Konstruktor haben, in dem wir √ºbergeben, mit welchem ‚Äã‚ÄãBot-Objekt er interagieren muss.  Und es wird eine abstrakte Funktion deklariert, deren Implementierung wir bei den Erben unserer Klasse registrieren m√ºssen. <br><br>  Und sofort werden wir den einfachsten Handler implementieren, der nichts tut, und wir werden ihn verwenden, wenn wir nicht verstehen k√∂nnen, welche Art von Befehl uns gegeben wurde und keine Antwort vom Bot erforderlich ist. <br><br>  <a href="" rel="nofollow">DefaultHandler.java</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(DefaultHandler.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Wie wir es anwenden werden und wo wir die Ergebnisse seiner Arbeit erhalten werden, werden wir etwas sp√§ter analysieren. <br><br>  Als n√§chstes folgt <a href="" rel="nofollow">SystemHandler</a> <br>  Er wird sich mit grundlegenden Befehlen wie start, help befassen und wir werden ihn auch anweisen, den Befehl id auszuf√ºhren <br><br>  Die Basis sieht so aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.Command; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.methods.send.SendMessage; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(SystemHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String END_LINE = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ Command command = parsedCommand.getCommand(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: bot.sendQueue.add(getMessageStart(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: bot.sendQueue.add(getMessageHelp(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Sie k√∂nnen sehen, wie die Antwort auf den Start- und Hilfebefehl im Code gebildet wird :) <br>  Wir bilden Textnachrichten und stellen sie zum Versenden in eine Warteschlange.  Daraufhin stoppt die Arbeit des Handlers.  Wer und wie wird diese Nachrichten senden - es interessiert ihn √ºberhaupt nicht. <br>  Und denken Sie daran, ich habe ein wenig dar√ºber erw√§hnt, dass der Handler einige Textdaten zur√ºckgibt.  Und wenn diese Zeile nicht leer ist, m√ºssen wir diesen Text an den Benutzer senden.  Dies ist genau die Funktionalit√§t, die wir beim Ausarbeiten des ID-Befehls verwendet haben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId();</code> </pre> <br>  Der Handler gibt den Text mit der Benutzer-ID an die Person zur√ºck, die ihn angerufen hat, und bereits dort wird eine Nachricht zum Senden generiert, die dann in die Warteschlange eingereiht wird. <br><br>  Und am Anfang des Artikels erw√§hnte ich, dass wir diese Option implementieren, um eine Nachricht von einem Benutzer zu verarbeiten, der Zeit zum Arbeiten ben√∂tigt.  Und damit es unsere Handler nicht st√∂rt, werden wir es in einem separaten Stream zuordnen und es seinem Gesch√§ft √ºberlassen, ohne den Rest abzulenken. <br>  Als solch ein "Schwergewichts" -Thread habe ich mir den Befehl notify ausgedacht.  Das Prinzip ihrer Arbeit ist dies. <br><br>  Durch Senden eines Befehls des Formulars an den Bot: <br>  <b>Ich benachrichtige 300</b> <br><br>  Der Bot sollte Sie dar√ºber informieren, dass das Team es verstanden hat. Nach 300 Sekunden erhalten Sie eine Benachrichtigung, dass 300 Sekunden vergangen sind.  Dieses Team kann sogar einen praktischen Nutzen haben :) <br><br>  Zum Beispiel setzen Sie Kn√∂del in Brand und Sie m√ºssen sie nach 5 Minuten entfernen.  Der Bot macht das perfekt und benachrichtigt Sie im Chat, dass die Zeit abgelaufen ist. <br><br>  Oder nehmen Sie eine ernstere Aufgabe.  Sie gehen zu einem wichtigen Meeting und wissen, dass Sie bei der Kommunikation mit jemandem das Gespr√§ch unterbrechen m√ºssen.  Zu diesem Zweck bitten sie Freunde in der Regel, entweder anzurufen oder eine Nachricht zu schreiben. Dies ist ein Motiv, um das Gespr√§ch nicht √ºber einen l√§ngeren Zeitraum hinweg abzulenken und Ma√ünahmen zu ergreifen.  Aber warum Freunde st√∂ren, wenn Sie einen Bot haben?  Nachdem Sie ihn zuvor um eine Aufgabe gebeten und die Uhrzeit angegeben haben, erhalten Sie die erforderliche Benachrichtigung in Form von Telegrammen.  Aber das ist alles der Text.  Die Aufgabe und dieser Befehl wurden nur erfunden, um Ihnen zu zeigen, wie Sie in einem separaten Stream etwas zuordnen, dessen Arbeit einen sehr langen Zeitraum in Anspruch nehmen kann. <br><br>  Also, <a href="" rel="nofollow">NotifyHandler</a> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.ability.Notify; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(NotifyHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MILLISEC_IN_SEC = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String WRONG_INPUT_MESSAGE = <span class="hljs-string"><span class="hljs-string">"Wrong input. Time must be specified as an integer greater than 0"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ String text = parsedCommand.getText(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(text)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"You must specify the delay time. Like this:\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"/notify 30"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeInSec; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { timeInSec = Long.parseLong(text.trim()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NumberFormatException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeInSec &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notify(bot, chatId, timeInSec * MILLISEC_IN_SEC)); thread.start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Wir pr√ºfen, ob uns die Versp√§tungszeit im Text mitgeteilt wurde.  Wenn nicht, schw√∂ren wir.  Wenn ja, starten wir einen neuen Thread, in dem wir die Einleitung zu unserer Anleitung weitergeben.  Diese Aufgabe wird von einer separaten <a href="" rel="nofollow">Notify-</a> Klasse erledigt. <br>  Die Funktionalit√§t ist sehr einfach.  Er schl√§ft die angegebene Anzahl von Sekunden.  W√§hrend des Schlafens kann Ihr Bot jedoch andere Nachrichten empfangen, mit Ihnen kommunizieren und zus√§tzliche Benachrichtigungen ausl√∂sen.  Und das alles funktioniert getrennt voneinander. <br><br>  Um diesen ganzen Haufen mit aufrufenden Handlern logisch zu vervollst√§ndigen, kehren wir zu unserer <a href="" rel="nofollow">MessageReciever-</a> Klasse zur√ºck und sehen, wie wir verstehen, welche Handler wir ben√∂tigen und wie wir sie ausf√ºhren. <br>  Der erforderliche Handler wird uns vom Befehl zur√ºckgesandt <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AbstractHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHandlerForCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Command command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.warn(<span class="hljs-string"><span class="hljs-string">"Null command accepted. This is not good scenario."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: SystemHandler systemHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + systemHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemHandler; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NOTIFY: NotifyHandler notifyHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + notifyHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notifyHandler; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] not Set. Return DefaultHandler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } }</code> </pre> <br>  Wenn Sie nun weitere Befehle hinzuf√ºgen m√∂chten, m√ºssen Sie folgende Schritte ausf√ºhren: <br><br><ol><li>  F√ºgen Sie in der <a href="" rel="nofollow">Command-</a> Klasse die Befehlssyntax hinzu. </li><li>  <b>Geben Sie</b> im <a href="" rel="nofollow">Empf√§nger</a> in der Funktion <b>getHandlerForCommand an,</b> wer f√ºr die Verarbeitung dieses Befehls verantwortlich sein soll. </li><li>  Und tats√§chlich diesen Handler schreiben. </li></ol><br>  Ich werde im Voraus sagen, dass der Prozess des Hinzuf√ºgens neuer Teams vereinfacht werden kann.  Verantwortliche Bearbeiter k√∂nnen sofort mit einer Liste von Befehlen in der Klasse registriert werden.  Ich bef√ºrchte jedoch, dass der Code nicht einfach zu verstehen ist.  Der Text ist sehr lang.  Aber ich kann ihn nicht in St√ºcke schlagen.  Hier werden drei grundlegende Bot-Funktionen beschrieben, die nur zusammenarbeiten und √ºber die nicht einzeln gesprochen werden darf. <br><br>  Wor√ºber werden wir in den folgenden Abschnitten sprechen? <br><br>  Wir m√ºssen verstehen, wie man verschiedene Arten von Nachrichten formt.  So arbeiten Sie mit Tastatur und Tasten.  So bearbeiten Sie Ihre alten Beitr√§ge.  So arbeiten Sie mit R√ºckrufen.  Wie man dem Bot Aufgaben gibt, um einige Aktionen auszuf√ºhren.  So erstellen Sie eine interaktive Nachricht mit einem Bot und vielem mehr.  Alle weiteren Teile liegen bei Ihnen und Ihrer T√§tigkeit. <br>  In den Kommentaren freue ich mich auf Ihr Feedback und Ihre Anweisungen, die wir als Priorit√§t betrachten werden. <br><br>  F√ºhlen Sie sich frei, Fragen zu stellen.  Wenn etwas in dem Artikel nicht angegeben ist oder irgendwann nicht klar ist - schreiben Sie mir dar√ºber.  Ich werde auf jeden Fall kontroverse Themen korrigieren, bearbeiten oder kl√§ren. <br><br>  Programmiere mit Vergn√ºgen und m√∂ge die Kraft und der sch√∂ne Code mit dir kommen :) <br><br>  py.s. <br><br>  Der in diesem Teil des Artikels beschriebene Bot funktioniert.  Du kannst ihn hier qu√§len: <a href="http://t.me/test_habr_bot" rel="nofollow">@test_habr_bot</a> <br>  Sie k√∂nnen auch meinen Planer qu√§len: <a href="http://t.me/EventCheckPlanner_Bot" rel="nofollow">@EventCheckPlanner_Bot</a> <br>  Und der <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">freche Filmfan</a> : <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">@FilmFanAmateurBot</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481354/">https://habr.com/ru/post/de481354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481344/index.html">Pl√§ne des IntelliJ Platform-Teams f√ºr 2020</a></li>
<li><a href="../de481346/index.html">5 gro√üe Ver√§nderungen in der Automobilindustrie</a></li>
<li><a href="../de481348/index.html">Pentest Active Directory. Teil 1</a></li>
<li><a href="../de481350/index.html">Wer arbeitet am Kosmodrom Plesetsk?</a></li>
<li><a href="../de481352/index.html">DBA: L√∂schen von Klons√§tzen aus einer Tabelle ohne PK</a></li>
<li><a href="../de481356/index.html">Vielen Dank, 2019</a></li>
<li><a href="../de481358/index.html">C ++ Russland: wie es war</a></li>
<li><a href="../de481360/index.html">Die Ergebnisse der Woche: Rambler und Twitch waren sich einig, in der Russischen F√∂deration wird die elektronische Arbeit eingef√ºhrt und Facebook wird ein eigenes Betriebssystem erstellen</a></li>
<li><a href="../de481362/index.html">SSL Zertifikat f√ºr Docker Web-App</a></li>
<li><a href="../de481364/index.html">Sensibles Zuhause ersetzt intelligentes Zuhause</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>