<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎪 👦🏼 👩‍🍳 TelegramBot. Die Grundfunktionalität. Fliegen getrennt, Schnitzel getrennt. (Teil 2) 👨🏿‍💻 📂 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir entwickeln die Grundfunktionalität für den Bot in Telegrammen weiter. In den vorangegangenen Abschnitten haben wir den Punkt besprochen, dass die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TelegramBot. Die Grundfunktionalität. Fliegen getrennt, Schnitzel getrennt. (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481354/"> Wir entwickeln die Grundfunktionalität für den Bot in Telegrammen weiter.  In den vorangegangenen Abschnitten haben wir den Punkt besprochen, dass die Arbeit des Bots beim Empfangen, Verarbeiten und Senden von Nachrichten aufgeteilt werden sollte.  Versuchen wir, die grundlegenden Java Core-Tools zu verwenden, um unseren Bot multithreading- und asynchron zu machen.  Wir werden eine Aufgabe entwickeln, deren Bearbeitung viel Zeit in Anspruch nimmt.  Mal sehen, wie die Befehle im Telegramm funktionieren und wie sie verarbeitet werden müssen. <br><br>  Dies ist eine Fortsetzung des ersten Teils des Artikels über das Programmieren von Bots für Telegramme in Java <br>  <a href="https://habr.com/ru/post/476306/">TelegramBot-Anweisungen zum Erstellen grundlegender Funktionen für den Bot.</a>  <a href="https://habr.com/ru/post/476306/">(Teil 1)</a> <br>  Für wen es weiter interessant ist, sind Sie herzlich willkommen… <br><a name="habracut"></a><br>  Ich muss sofort sagen, dass in diesem Teil viel auf einmal hinzugefügt wurde und wir im Hintergrund alle Funktionen analysieren werden, die es dem Bot ermöglichten, Multithreading durchzuführen, und warum es überhaupt benötigt wird. <br><br>  Wie üblich aus der Hauptsache: <br>  Sie finden den fertigen Code für diesen Artikel im Zweig <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers" rel="nofollow">Part2-Handlers</a> im Git-Repository. <br>  Der Code ist voll funktionsfähig, es reicht aus, die Daten für die Autorisierung des Bots (Name und Token) zu ändern und die Hauptmethode in der App.class-Klasse auszuführen. <br><br>  <i>Bitte beachten Sie, dass diese Klasse eine Benachrichtigung an den Bot-Administrator sendet, wenn der Bot startet, dass der Bot gestartet wurde.</i>  <i>Die Administrator-ID des Bots wird auch in der App.class-Klasse angegeben. Wenn Sie diese nicht ändern, versucht Ihr Bot, Nachrichten an mich zu senden :)</i> <br><br>  Und weiter unten werden wir die Änderungen analysieren, die nach der Veröffentlichung des ersten Teils aufgetreten sind. <br><br><h3>  Befehlsverarbeitung </h3><br>  Zunächst wollen wir uns mit diesem Konzept befassen, was ein Team im Allgemeinen in einem System zur Kommunikation mit einem Telegrammbot darstellt.  Abhängig von den Einstellungen des Bots können entweder Nachrichten in einem beliebigen Format oder nur speziell gestaltete Befehle angezeigt werden.  Was ist der Unterschied und <br>  wo Sie diese Nachrichtenoptionen treffen können. <br><br><ol><li>  <b>Klartext, normale Nachrichten.</b> <br>  In dieser Form erhält der Bot Nachrichten, wenn er in PM an ihn schreibt.  Wenn jedoch in den Einstellungen des Bots <a href="https://core.telegram.org/bots" rel="nofollow">der Datenschutzmodus in Gruppen</a> deaktiviert ist, werden alle Nachrichten vom Bot vollständig angezeigt.  Wenn diese Einstellung aktiviert ist, werden dem Bot beim Hinzufügen zur Gruppe nur die an ihn gerichteten Befehle angezeigt.  Wie sie aussehen - siehe den zweiten Absatz </li><li>  <b>Speziell entwickelte Teams</b> <br>  Solche Befehle beginnen immer mit einem Schrägstrich: <b>/</b> <br>  Danach kommt das Team selbst.  Der Befehlstext sollte keine Leerzeichen enthalten.  Ein Beispiel: <br>  <b>Ich fange an</b> <br>  Mit diesem Befehl startet jeder Benutzer immer die Kommunikation mit Ihrem Bot.  Daher muss nach den Regeln der guten Form die Reaktion auf diesen Befehl vorgeschrieben werden. <br><img src="https://habrastorage.org/webt/ol/pi/ud/olpiudptbqgig5zhoqzpnpjquyq.png"><br>  Bei allen Befehlen, mit denen Ihr Bot umgehen kann, ist es ratsam, die Liste der Fähigkeiten in den Einstellungen Ihres Bot zu erweitern.  Dies geschieht alles in einem Telegramm mit @BotFather. <br><br>  <b>Wählen Sie mit dem Befehl / myBots</b> Ihren Bot und dann die Schaltfläche „Bot bearbeiten“ aus <br>  Sie erhalten ein Fenster, in dem alle Parameter des Bots angezeigt werden. Anschließend können Sie die gesamte Benutzeroberfläche konfigurieren und angeben, mit welchen Befehlen Ihr Bot arbeiten kann. <br><br><img src="https://habrastorage.org/webt/u6/7o/cl/u67oclalxrv7v3v83h1wzp91gr4.png"><br><br>  Sie sind in diesem Format festgelegt: <br><br><img src="https://habrastorage.org/webt/-a/4x/i-/-a4xi-kqpuxjoielhmog7oh1tom.png"><br><br>  Wenn Sie danach einen Befehl in Ihren Bot eingeben, wird die Hilfe mit einer Liste der aufgeführten Befehle angezeigt: <br><br><img src="https://habrastorage.org/webt/hn/yi/wa/hnyiwabkhmbrc7zn0rbuzkfvook.png"><br><br>  Und es gibt noch eine Nuance.  Eine Gruppe kann mehrere Bots enthalten. Wenn sie gemeinsame Befehle haben (und gemeinsame Befehle obligatorisch sind, werden in den meisten Bots derselbe Start und dieselbe Hilfe implementiert), wird dem Befehl selbst ein Teil hinzugefügt, der angibt, zu welchem ​​Bot dieser Befehl gehört.  Und der Befehl sieht komplett so aus: <br>  <b>/ start @ test_habr_bot</b> <br></li></ol><br>  Und jetzt, da wir all diese Nuancen kennen, wollen wir mit Ihnen eine solche Verarbeitungsoption erstellen, die Befehle verstehen sollte, die mit einem Schrägstrich beginnen und zu unterscheiden wissen, ob der Befehl speziell an Ihren Bot oder an einen anderen gerichtet ist. <br><br>  Erstellen Sie ein Paket, das die Klassen enthält, die für die Verarbeitung der Befehle verantwortlich sind. <br>  <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/command" rel="nofollow">package com.example.telegrambot.command</a> <br><br>  In der Command-Klasse listen wir alle Befehle auf, die unser Bot verstehen sollte. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Command { NONE, NOTFORME, NOTIFY, START, HELP, ID }</code> </pre> <br>  Wie du vorher gesehen hast, habe ich bei @BotFather darauf hingewiesen, dass der Bot 4 Teams verstehen sollte.  Dies ist der Standardstart und die Standardhilfe.  Wir fügen eine nützliche ID hinzu.  Und noch eine, benachrichtige, worüber ich etwas später sprechen werde.  Und zwei Teams, NONE und NOTFORME, die uns mitteilen, dass es sich bei der Textnachricht entweder gar nicht um einen Befehl handelt oder dass dieser Befehl nicht für unseren Bot bestimmt ist. <br><br>  <a href="" rel="nofollow">Fügen Sie eine</a> weitere <a href="" rel="nofollow">Hilfsklasse ParsedCommand hinzu</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.AllArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Getter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NoArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Setter; <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedCommand</span></span></span><span class="hljs-class"> </span></span>{ Command command = Command.NONE; String text=<span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Der Hauptzweck ist das Speichern des Ergebnisses der Textanalyse in Objekten dieser Klasse.  Es wird nur das Team selbst und den gesamten Text enthalten, der nach dem Team kommt. <br><br>  Und wir werden eine separate Klasse schreiben, die die Teams für uns parsen wird.  <a href="" rel="nofollow">Parser-</a> Klasse <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javafx.util.Pair; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(Parser.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PREFIX_FOR_COMMAND = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DELIMITER_COMMAND_BOTNAME = <span class="hljs-string"><span class="hljs-string">"@"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String botName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String botName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.botName = botName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String trimText = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) trimText = text.trim(); ParsedCommand result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedCommand(Command.NONE, trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(trimText)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; Pair&lt;String, String&gt; commandAndText = getDelimitedCommandFromText(trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommand(commandAndText.getKey())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommandForMe(commandAndText.getKey())) { String commandForParse = cutCommandFromFullText(commandAndText.getKey()); Command commandFromText = getCommandFromText(commandForParse); result.setText(commandAndText.getValue()); result.setCommand(commandFromText); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.setCommand(Command.NOTFORME); result.setText(commandAndText.getValue()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutCommandFromFullText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(DELIMITER_COMMAND_BOTNAME) ? text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, text.indexOf(DELIMITER_COMMAND_BOTNAME)) : text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String upperCaseText = text.toUpperCase().trim(); Command command = Command.NONE; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { command = Command.valueOf(upperCaseText); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IllegalArgumentException e) { log.debug(<span class="hljs-string"><span class="hljs-string">"Can't parse command: "</span></span> + text); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Pair&lt;String, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDelimitedCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String trimText)</span></span></span><span class="hljs-function"> </span></span>{ Pair&lt;String, String&gt; commandText; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trimText.contains(<span class="hljs-string"><span class="hljs-string">" "</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexOfSpace = trimText.indexOf(<span class="hljs-string"><span class="hljs-string">" "</span></span>); commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, indexOfSpace), trimText.substring(indexOfSpace + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> commandText; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommandForMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command.contains(DELIMITER_COMMAND_BOTNAME)) { String botNameForEqual = command.substring(command.indexOf(DELIMITER_COMMAND_BOTNAME) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> botName.equals(botNameForEqual); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.startsWith(PREFIX_FOR_COMMAND); } }</code> </pre> <br>  Kurz gesagt.  Beim Initialisieren des Parsers müssen wir den Namen unseres Bots im Konstruktor übergeben, damit der Parser seine Befehle von Fremden unterscheiden kann. <br><br>  Dann rufen wir einfach die öffentliche Methode auf <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span></span></code> </pre> <br>  An die wir den Nachrichtentext in den Argumenten übergeben, und er muss uns einen Befehl und den Nachrichtentext zurückgeben, der nach dem Befehl kommt. <br><br>  Sie können sehen, wie der Parser in der Testklasse funktioniert. <br><br><h3>  Fliegen getrennt, Schnitzel getrennt </h3><br>  Jetzt müssen wir unserem Bot beibringen, Nachrichten separat zu empfangen, zu verarbeiten und Antworten zu senden.  Nach einer Reihe von Versuchen bin ich zu dieser Logik der Anwendung gekommen. <br>  Der Hauptklassen- <a href="" rel="nofollow">Bot</a> arbeitet im Haupt-Thread der Anwendung und ist nur damit beschäftigt, dass er alle empfangenen Nachrichten in eine spezielle Warteschlange stellt und auch ein Container für Nachrichten ist, die wir als Antwort an den Benutzer senden möchten. <br><br>  Die Änderungen in dieser Klasse sind sehr gering.  Wir haben zwei Warteschlangen hinzugefügt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; sendQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; receiveQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;();</code> </pre><br>  und den Funktionscode <b>public void onUpdateReceived (Update update)</b> leicht umgeschrieben <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdateReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"Receive new Update. updateID: "</span></span> + update.getUpdateId()); receiveQueue.add(update); }</code> </pre> <br>  Warum so?  Wieder habe ich verschiedene Optionen ausprobiert.  Das Hauptproblem beim Multithreading ist das Arbeiten mit gemeinsam genutzten Daten.  Und am meisten hat mir gefallen, wie die Implementierung von Multithread-Warteschlangen <b>ConcurrentLinkedQueue &lt;&gt; () damit</b> umgeht. <br>  Und wie Sie sehen, werden in beiden Warteschlangen Objektdatentypen gespeichert.  Dies ist ein weiteres Lesezeichen für die Zukunft.  Wir sind also nicht an die Art der empfangenen Nachrichten gebunden.  In der eingehenden Warteschlange können wir nicht nur Objekte vom Typ Update hinzufügen, sondern auch einige andere Objekte, die wir benötigen. <br><br>  Das gleiche gilt für die Warteschlange zum Senden.  Da wir verschiedene Arten von Nachrichten senden können und sie kein gemeinsames übergeordnetes Objekt haben, verwenden wir auch einen gemeinsamen Datentyp - Object. <br>  Wenn Sie den Bot in dieser Form ausführen, wird es funktionieren, aber nichts tun.  Er zeichnet alle empfangenen Nachrichten im Protokoll auf und stellt sie in die Warteschlange. <br>  Aus diesem Grund benötigen wir einen Thread, der sich darum kümmert, empfangene Nachrichten aus der Warteschlange zu übernehmen, einige Aktionen <b>auszuführen</b> und die Ergebnisse seiner Arbeit in die <b>sendQueue-</b> Warteschlange zu stellen. <br><br>  Lassen Sie uns ein separates Paket erstellen: <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/service" rel="nofollow">service</a> und darin werden wir nur 2 Klassen haben: <br><br>  <b>MessageReciever</b> - Handler für empfangene Nachrichten <br>  <b>MessageSender</b> ist der Message Queue Handler, der an den Benutzer gesendet werden soll. <br><br>  Wir werden ihre Arbeit etwas niedriger betrachten, aber im Moment werden wir ihre Verwendung in unserer Startklasse- <a href="" rel="nofollow">App beschreiben</a> <br><br>  Nachdem sich unser Bot verbunden hat, starten wir unsere Handler in separaten Threads: <br><br><pre> <code class="java hljs">MessageReciever messageReciever = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageReciever(test_habr_bot); MessageSender messageSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageSender(test_habr_bot); test_habr_bot.botConnect(); Thread receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageReciever); receiver.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); receiver.setName(<span class="hljs-string"><span class="hljs-string">"MsgReciever"</span></span>); receiver.setPriority(PRIORITY_FOR_RECEIVER); receiver.start(); Thread sender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageSender); sender.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); sender.setName(<span class="hljs-string"><span class="hljs-string">"MsgSender"</span></span>); sender.setPriority(PRIORITY_FOR_SENDER); sender.start();</code> </pre><br>  Für beide Threads geben wir den Daemon-Modus an.  Dies ist erforderlich, damit die Threads funktionieren, solange der Haupt-Thread ausgeführt wird, und sich selbst beenden, sobald er seine Arbeit beendet. <br><br>  Wir möchten uns nicht zuerst mit dem Handler für eingehende Nachrichten befassen - schauen wir uns die Funktionsweise der <a href="" rel="nofollow">MessageSender-</a> Klasse an. <br><br>  Werfen wir einen Blick darauf, was er kann und was er tut: <br><br><ul><li>  Dies ist natürlich eine Vererbung der Schnittstelle für Multithreading: <br>  <b>geräte lauffähig</b> <br>  und Implementierung der <b>Run-</b> Funktion <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Hier starten wir die Endlosschleife, die nur damit beschäftigt ist, dass sie die Sendewarteschlange überprüft und den Sendebefehl aufruft <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  wenn etwas in der Warteschlange erscheint. <br></li><li>  Im Klassenkonstruktor übergeben wir das Objekt der Bot-Klasse, weil  von ihm werden wir Objekte zum Versenden von Nachrichten nehmen und mit ihm werden wir sie senden. </li><li>  Die send-Methode bestimmt den Typ der zu sendenden Nachricht und wendet den entsprechenden Befehl darauf an. </li></ul><br>  Nun <a href="" rel="nofollow">schauen</a> wir <a href="" rel="nofollow">uns die</a> Arbeit der <a href="" rel="nofollow">MessageReciever-</a> Klasse an <br><br>  Er muss, wie MessageSender, Multithreading-fähig sein, im Konstruktor ein Objekt der Klasse Bot erhalten, in dem er empfangene Nachrichten in einer Endlosschleife aufnimmt, verarbeitet und in die Warteschlange stellt, um die Ergebnisse seiner Arbeit zu senden. <br><br>  Hier verwenden wir den zuvor erstellten Befehlsparser.  Und dann fügen wir die Möglichkeit hinzu, verschiedene Arten von Handlern für unsere Teams zu verwenden, und einige von ihnen werden Multi-Thread-fähig sein. <br><br>  Der Arbeitszyklus ist sehr einfach: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"[STARTED] MsgReciever. Bot class: "</span></span> + bot); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object = bot.receiveQueue.poll(); object != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; object = bot.receiveQueue.poll()) { log.debug(<span class="hljs-string"><span class="hljs-string">"New object for analyze in queue "</span></span> + object.toString()); analyze(object); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(WAIT_FOR_NEW_MESSAGE_DELAY); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { log.error(<span class="hljs-string"><span class="hljs-string">"Catch interrupt. Exit"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Überprüfen Sie die Warteschlange.  Wenn es etwas gibt, führen Sie den Analysator aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  Wenn es nichts gibt, warten wir. <br><br>  Der Analysator überprüft den Objekttyp.  Wenn er weiß, wie er mit ihm arbeiten soll, startet er den nächsten Analysator.  Wenn Sie nicht können - schwört :) <br><br>  Warum so?  Auch dies ist ein Lesezeichen für die Zukunft und ich hoffe, dass ich es in den nächsten Teilen dieser Artikelserie veröffentlichen werde.  Eine solche Implementierung ermöglicht es uns, eigene Aufgaben für den Bot zu erstellen, Mailinglisten zu erstellen und Tagesaufgaben zu erledigen.  Dazu muss der Empfänger nicht nur Objekte vom Typ Update verarbeiten können, sondern auch etwas von uns.  Aber dazu später mehr :) <br><br>  Betrachten Sie den Analyzer für den Aktualisierungstyp genauer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyzeForUpdateType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ Long chatId = update.getMessage().getChatId(); String inputText = update.getMessage().getText(); ParsedCommand parsedCommand = parser.getParsedCommand(inputText); AbstractHandler handlerForCommand = getHandlerForCommand(parsedCommand.getCommand()); String operationResult = handlerForCommand.operate(chatId.toString(), parsedCommand, update); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(operationResult)) { SendMessage message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendMessage(); message.setChatId(chatId); message.setText(operationResult); bot.sendQueue.add(message); } }</code> </pre> <br>  Es definiert die Chat-ID.  Ruft den Nachrichtentext ab.  Mit dem Parser wird bestimmt, ob es sich bei der Nachricht um einen Befehl handelt und welcher Handler für diesen Befehl verwendet werden soll.  Die Verarbeitung des Befehls wird gestartet, und wenn bei der Verarbeitung des Befehls nicht leerer Text zurückgegeben wird, wird eine Nachricht zum Senden an den Benutzer erstellt und in die Warteschlange eingereiht. <br><br>  Und dann sollten Sie eine Frage haben: "Was für ein Handler?".  Es wurde vorher nicht über ihn gesprochen, und er wurde im Kodex nicht erwähnt.  Alles ist richtig.  Nun werden wir diese Funktionalität analysieren. <br><br>  Erstellen Sie dazu ein separates Paket, in dem alle unsere Handler gespeichert werden.  Nennen Sie es <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/handler" rel="nofollow">Handler</a> <br>  Lassen Sie uns eine abstrakte Klasse <a href="" rel="nofollow">AbstractHandler</a> erstellen <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ Bot bot; AbstractHandler(Bot bot) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bot = bot; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span></span>; }</code> </pre> <br>  Er wird einen grundlegenden Konstruktor haben, in dem wir übergeben, mit welchem ​​Bot-Objekt er interagieren muss.  Und es wird eine abstrakte Funktion deklariert, deren Implementierung wir bei den Erben unserer Klasse registrieren müssen. <br><br>  Und sofort werden wir den einfachsten Handler implementieren, der nichts tut, und wir werden ihn verwenden, wenn wir nicht verstehen können, welche Art von Befehl uns gegeben wurde und keine Antwort vom Bot erforderlich ist. <br><br>  <a href="" rel="nofollow">DefaultHandler.java</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(DefaultHandler.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Wie wir es anwenden werden und wo wir die Ergebnisse seiner Arbeit erhalten werden, werden wir etwas später analysieren. <br><br>  Als nächstes folgt <a href="" rel="nofollow">SystemHandler</a> <br>  Er wird sich mit grundlegenden Befehlen wie start, help befassen und wir werden ihn auch anweisen, den Befehl id auszuführen <br><br>  Die Basis sieht so aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.Command; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.methods.send.SendMessage; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(SystemHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String END_LINE = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ Command command = parsedCommand.getCommand(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: bot.sendQueue.add(getMessageStart(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: bot.sendQueue.add(getMessageHelp(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Sie können sehen, wie die Antwort auf den Start- und Hilfebefehl im Code gebildet wird :) <br>  Wir bilden Textnachrichten und stellen sie zum Versenden in eine Warteschlange.  Daraufhin stoppt die Arbeit des Handlers.  Wer und wie wird diese Nachrichten senden - es interessiert ihn überhaupt nicht. <br>  Und denken Sie daran, ich habe ein wenig darüber erwähnt, dass der Handler einige Textdaten zurückgibt.  Und wenn diese Zeile nicht leer ist, müssen wir diesen Text an den Benutzer senden.  Dies ist genau die Funktionalität, die wir beim Ausarbeiten des ID-Befehls verwendet haben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId();</code> </pre> <br>  Der Handler gibt den Text mit der Benutzer-ID an die Person zurück, die ihn angerufen hat, und bereits dort wird eine Nachricht zum Senden generiert, die dann in die Warteschlange eingereiht wird. <br><br>  Und am Anfang des Artikels erwähnte ich, dass wir diese Option implementieren, um eine Nachricht von einem Benutzer zu verarbeiten, der Zeit zum Arbeiten benötigt.  Und damit es unsere Handler nicht stört, werden wir es in einem separaten Stream zuordnen und es seinem Geschäft überlassen, ohne den Rest abzulenken. <br>  Als solch ein "Schwergewichts" -Thread habe ich mir den Befehl notify ausgedacht.  Das Prinzip ihrer Arbeit ist dies. <br><br>  Durch Senden eines Befehls des Formulars an den Bot: <br>  <b>Ich benachrichtige 300</b> <br><br>  Der Bot sollte Sie darüber informieren, dass das Team es verstanden hat. Nach 300 Sekunden erhalten Sie eine Benachrichtigung, dass 300 Sekunden vergangen sind.  Dieses Team kann sogar einen praktischen Nutzen haben :) <br><br>  Zum Beispiel setzen Sie Knödel in Brand und Sie müssen sie nach 5 Minuten entfernen.  Der Bot macht das perfekt und benachrichtigt Sie im Chat, dass die Zeit abgelaufen ist. <br><br>  Oder nehmen Sie eine ernstere Aufgabe.  Sie gehen zu einem wichtigen Meeting und wissen, dass Sie bei der Kommunikation mit jemandem das Gespräch unterbrechen müssen.  Zu diesem Zweck bitten sie Freunde in der Regel, entweder anzurufen oder eine Nachricht zu schreiben. Dies ist ein Motiv, um das Gespräch nicht über einen längeren Zeitraum hinweg abzulenken und Maßnahmen zu ergreifen.  Aber warum Freunde stören, wenn Sie einen Bot haben?  Nachdem Sie ihn zuvor um eine Aufgabe gebeten und die Uhrzeit angegeben haben, erhalten Sie die erforderliche Benachrichtigung in Form von Telegrammen.  Aber das ist alles der Text.  Die Aufgabe und dieser Befehl wurden nur erfunden, um Ihnen zu zeigen, wie Sie in einem separaten Stream etwas zuordnen, dessen Arbeit einen sehr langen Zeitraum in Anspruch nehmen kann. <br><br>  Also, <a href="" rel="nofollow">NotifyHandler</a> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.ability.Notify; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(NotifyHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MILLISEC_IN_SEC = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String WRONG_INPUT_MESSAGE = <span class="hljs-string"><span class="hljs-string">"Wrong input. Time must be specified as an integer greater than 0"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ String text = parsedCommand.getText(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(text)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"You must specify the delay time. Like this:\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"/notify 30"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeInSec; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { timeInSec = Long.parseLong(text.trim()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NumberFormatException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeInSec &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notify(bot, chatId, timeInSec * MILLISEC_IN_SEC)); thread.start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Wir prüfen, ob uns die Verspätungszeit im Text mitgeteilt wurde.  Wenn nicht, schwören wir.  Wenn ja, starten wir einen neuen Thread, in dem wir die Einleitung zu unserer Anleitung weitergeben.  Diese Aufgabe wird von einer separaten <a href="" rel="nofollow">Notify-</a> Klasse erledigt. <br>  Die Funktionalität ist sehr einfach.  Er schläft die angegebene Anzahl von Sekunden.  Während des Schlafens kann Ihr Bot jedoch andere Nachrichten empfangen, mit Ihnen kommunizieren und zusätzliche Benachrichtigungen auslösen.  Und das alles funktioniert getrennt voneinander. <br><br>  Um diesen ganzen Haufen mit aufrufenden Handlern logisch zu vervollständigen, kehren wir zu unserer <a href="" rel="nofollow">MessageReciever-</a> Klasse zurück und sehen, wie wir verstehen, welche Handler wir benötigen und wie wir sie ausführen. <br>  Der erforderliche Handler wird uns vom Befehl zurückgesandt <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AbstractHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHandlerForCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Command command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.warn(<span class="hljs-string"><span class="hljs-string">"Null command accepted. This is not good scenario."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: SystemHandler systemHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + systemHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemHandler; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NOTIFY: NotifyHandler notifyHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + notifyHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notifyHandler; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] not Set. Return DefaultHandler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } }</code> </pre> <br>  Wenn Sie nun weitere Befehle hinzufügen möchten, müssen Sie folgende Schritte ausführen: <br><br><ol><li>  Fügen Sie in der <a href="" rel="nofollow">Command-</a> Klasse die Befehlssyntax hinzu. </li><li>  <b>Geben Sie</b> im <a href="" rel="nofollow">Empfänger</a> in der Funktion <b>getHandlerForCommand an,</b> wer für die Verarbeitung dieses Befehls verantwortlich sein soll. </li><li>  Und tatsächlich diesen Handler schreiben. </li></ol><br>  Ich werde im Voraus sagen, dass der Prozess des Hinzufügens neuer Teams vereinfacht werden kann.  Verantwortliche Bearbeiter können sofort mit einer Liste von Befehlen in der Klasse registriert werden.  Ich befürchte jedoch, dass der Code nicht einfach zu verstehen ist.  Der Text ist sehr lang.  Aber ich kann ihn nicht in Stücke schlagen.  Hier werden drei grundlegende Bot-Funktionen beschrieben, die nur zusammenarbeiten und über die nicht einzeln gesprochen werden darf. <br><br>  Worüber werden wir in den folgenden Abschnitten sprechen? <br><br>  Wir müssen verstehen, wie man verschiedene Arten von Nachrichten formt.  So arbeiten Sie mit Tastatur und Tasten.  So bearbeiten Sie Ihre alten Beiträge.  So arbeiten Sie mit Rückrufen.  Wie man dem Bot Aufgaben gibt, um einige Aktionen auszuführen.  So erstellen Sie eine interaktive Nachricht mit einem Bot und vielem mehr.  Alle weiteren Teile liegen bei Ihnen und Ihrer Tätigkeit. <br>  In den Kommentaren freue ich mich auf Ihr Feedback und Ihre Anweisungen, die wir als Priorität betrachten werden. <br><br>  Fühlen Sie sich frei, Fragen zu stellen.  Wenn etwas in dem Artikel nicht angegeben ist oder irgendwann nicht klar ist - schreiben Sie mir darüber.  Ich werde auf jeden Fall kontroverse Themen korrigieren, bearbeiten oder klären. <br><br>  Programmiere mit Vergnügen und möge die Kraft und der schöne Code mit dir kommen :) <br><br>  py.s. <br><br>  Der in diesem Teil des Artikels beschriebene Bot funktioniert.  Du kannst ihn hier quälen: <a href="http://t.me/test_habr_bot" rel="nofollow">@test_habr_bot</a> <br>  Sie können auch meinen Planer quälen: <a href="http://t.me/EventCheckPlanner_Bot" rel="nofollow">@EventCheckPlanner_Bot</a> <br>  Und der <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">freche Filmfan</a> : <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">@FilmFanAmateurBot</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481354/">https://habr.com/ru/post/de481354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481344/index.html">Pläne des IntelliJ Platform-Teams für 2020</a></li>
<li><a href="../de481346/index.html">5 große Veränderungen in der Automobilindustrie</a></li>
<li><a href="../de481348/index.html">Pentest Active Directory. Teil 1</a></li>
<li><a href="../de481350/index.html">Wer arbeitet am Kosmodrom Plesetsk?</a></li>
<li><a href="../de481352/index.html">DBA: Löschen von Klonsätzen aus einer Tabelle ohne PK</a></li>
<li><a href="../de481356/index.html">Vielen Dank, 2019</a></li>
<li><a href="../de481358/index.html">C ++ Russland: wie es war</a></li>
<li><a href="../de481360/index.html">Die Ergebnisse der Woche: Rambler und Twitch waren sich einig, in der Russischen Föderation wird die elektronische Arbeit eingeführt und Facebook wird ein eigenes Betriebssystem erstellen</a></li>
<li><a href="../de481362/index.html">SSL Zertifikat für Docker Web-App</a></li>
<li><a href="../de481364/index.html">Sensibles Zuhause ersetzt intelligentes Zuhause</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>