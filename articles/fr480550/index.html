<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶à üßõ üïé Hello World de Bytecode pour JVM üåßÔ∏è üåë üÖ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous compilons un programme simple qui affiche "Hello World" et parcourons sa structure 


 Je ne pense pas que l'article sera suffisamment informatif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hello World de Bytecode pour JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480550/"><p>  Nous compilons un programme simple qui affiche "Hello World" et parcourons sa structure </p><br><p>  Je ne pense pas que l'article sera suffisamment informatif pour ceux qui ne savent pas superficiellement √† quoi ressemble le bytecode et comment la JVM fonctionne avec lui (par exemple, au moins les instructions les plus simples (connaissance de leur existence)). </p><br><p> En fait, ce n'est pas si difficile.  Il suffit d'utiliser l'outil <code>javap</code> du JDK et de consid√©rer le code d√©sassembl√©. </p><br><p>  Et nous allons commencer √† analyser la structure du bytecode pour la JVM </p><a name="habracut"></a><br><p>  Un livre tr√®s utile pour cela √©tait la sp√©cification JVM officielle - La sp√©cification de la machine virtuelle Java sur <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">oracle</a> </p><br><p>  Pour commencer, cr√©ez un programme simple: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ... args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>); } }</code> </pre><br><p>  Compilez-le avec l'√©quipe <code>javac Main.java</code> et effectuez le d√©montage </p><br><pre> <code class="plaintext hljs"> javap -c -v Main</code> </pre> <br><p>  <em>Main.class</em> </p><br><pre> <code class="plaintext hljs">Classfile /C:/Users/Arthur/playground/java/jvm/Main.class Last modified 26.10.2019; size 413 bytes MD5 checksum 6449121a3bb611fee394e4f322401ee1 Compiled from "Main.java" public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V { public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World 5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8 } SourceFile: "Main.java"</code> </pre><br><p>  Ceci est juste une repr√©sentation de bytecode qui est plus facile √† voir pour une personne que le bytecode original, mais cela a l'air diff√©rent: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d 0a00 0600 0f09 0010 0011 0800 120a 0013 0014 0700 1507 0016 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0a53 6f75 7263 6546 696c 6501 0009 4d61 696e 2e6a 6176 610c 0007 0008 0700 170c 0018 0019 0100 0b48 656c 6c6f 2057 6f72 6c64 0700 1a0c 001b 001c 0100 044d 6169 6e01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 1d00 0100 0100 0000 052a b700 01b1 0000 0001 000a 0000 0006 0001 0000 0001 0089 000b 000c 0001 0009 0000 0025 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0100 0a00 0000 0a00 0200 0000 0400 0800 0500 0100 0d00 0000 0200 0e</code> </pre> <br><p>  (Vous pouvez ouvrir votre fichier <code>.class</code> via Sublime Text indiquant File-&gt; Save with Encoding -&gt; Hexademical) </p><br><p>  Nous travaillerons avec ce code. </p><br><p>  Mais d'abord, nous devons le formater afin de ne pas se tromper o√π il se trouve, et le bytecode, en fait, a une structure tr√®s rigide: </p><br><pre> <code class="plaintext hljs"> ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  Vous pouvez le trouver dans la sp√©cification JVM <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Chapitre 4.1 La structure ClassFile</a> </p><br><p>  Ici, tout est simple - la dimension en octets est indiqu√©e √† gauche et la description √† droite. </p><br><p>  Nous analyserons le bytecode en hexad√©cimal, o√π chaque chiffre prend 4 bits, et donc, pour deux octets - 4 chiffres et pour quatre octets - 8 chiffres. </p><br><p>  <strong>la magie</strong> </p><br><p>  la magie est une valeur qui identifie le format de notre classe.  Il est √©gal √† <code>0xCAFEBABE</code> , qui a sa propre <a href="https://en.wikipedia.org/wiki/Java_class_file">histoire de cr√©ation</a> . </p><br><p>  <strong>minor_version, major_version</strong> </p><br><p>  Ce sont des versions de votre fichier de <code>class</code> .  Si nous appelons <code>major_version</code> M et <code>minor_version</code> m, nous obtenons la version de notre fichier de <code>class</code> comme <code>Mm</code> </p><br><p>  Maintenant, je vais imm√©diatement donner des exemples de notre programme "Hello World" pour voir comment ils sont utilis√©s: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 -- minor_version 0034 -- major_version</code> </pre> <br><p>  Nous pouvons le voir dans le code d√©mont√©, mais d√©j√† dans le syst√®me de nombre d√©cimal: </p><br><pre> <code class="plaintext hljs"> ... public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ...</code> </pre> <br><p>  <strong>constant_pool_count</strong> </p><br><p>  Le nombre de variables dans le pool constant est indiqu√© ici.  En m√™me temps, si vous d√©cidez d'√©crire du code en bytecode pur, alors vous devez certainement surveiller sa valeur, car si vous sp√©cifiez une valeur incorrecte, tout le programme ira en enfer (v√©rifi√©!). </p><br><p>  N'oubliez pas non plus que vous devez y inscrire le <code>___ + 1</code> de_variables_ dans le <code>___ + 1</code> </p><br><p>  Total nous obtenons: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 0034 -- version 001d -- constant_pool_count</code> </pre> <br><p>  <strong>constant_pool []</strong> </p><br><p>  Chaque type de variable dans le pool constant a sa propre structure: </p><br><pre> <code class="plaintext hljs"> cp_info { u1 tag; u1 info[]; }</code> </pre> <br><p>  Tout doit √™tre fait ici dans l'ordre.  Nous lisons d'abord la <code>tag</code> pour d√©couvrir le type de la variable et par le type de cette variable nous regardons quelle structure sa valeur suivante a <code>info[]</code> </p><br><p>  Un tableau avec des balises se trouve dans le <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tableau 4.3</a> Sp√©cification des <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">balises de pool constant</a> . </p><br><p>  En fait, voici la tablette: </p><br><div class="scrollable-table"><table><thead><tr><th>  Type constant </th><th>  Valeur </th></tr></thead><tbody><tr><td> <code>CONSTANT_Class</code> </td> <td>  7 </td></tr><tr><td> <code>CONSTANT_Fieldref</code> </td> <td>  9 </td></tr><tr><td> <code>CONSTANT_Methodref</code> </td> <td>  10 </td></tr><tr><td> <code>CONSTANT_InterfaceMethodref</code> </td> <td>  11 </td></tr><tr><td> <code>CONSTANT_String</code> </td> <td>  8 </td></tr><tr><td> <code>CONSTANT_Integer</code> </td> <td>  3 </td></tr><tr><td> <code>CONSTANT_Float</code> </td> <td>  4 </td></tr><tr><td> <code>CONSTANT_Long</code> </td> <td>  5 </td></tr><tr><td> <code>CONSTANT_Double</code> </td> <td>  6 </td></tr><tr><td> <code>CONSTANT_NameAndType</code> </td> <td>  12 </td></tr><tr><td> <code>CONSTANT_Utf8</code> </td> <td>  1 </td></tr><tr><td> <code>CONSTANT_MethodHandle</code> </td> <td>  15 </td></tr><tr><td> <code>CONSTANT_MethodType</code> </td> <td>  16 </td></tr><tr><td> <code>CONSTANT_InvokeDynamic</code> </td> <td>  18 </td></tr></tbody></table></div><br><p>  Comme mentionn√© pr√©c√©demment, chaque type de constante a sa propre structure. </p><br><p>  Voici, par exemple, la structure <code>CONSTANT_Class</code> : </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  Structure du champ et de la m√©thode: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Fieldref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Il est important de noter ici que diff√©rentes structures peuvent avoir des longueurs diff√©rentes. </p><br><p>  Consid√©rez une partie de notre code: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a00 0600 0f09 0010 0011 0800 12 ...</code> </pre> <br><p>  Donc, nous regardons la structure de la constante et d√©couvrons que le premier octet est r√©serv√© au type de constante.  Ici, nous voyons <code>0a</code> (10) - et donc, c'est <code>CONSTANT_Methodref</code> </p><br><p>  Nous regardons sa structure: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Apr√®s un octet pour la balise, nous avons besoin de 4 octets suppl√©mentaires pour <code>class_index</code> et <code>name_and_type_index</code> </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 0900 1000 1108 0012 ...</code> </pre> <br><p>  Eh bien, nous avons trouv√© l'une des valeurs du pool constant.  Allez-y.  Nous regardons, <code>09</code> - signifie le type <code>CONSTANT_Fieldref</code> </p><br><p>  Nous obtenons: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 ...</code> </pre> <br><p>  Vous pourriez penser que la plupart des types ont la m√™me forme, mais ce n'est pas le cas. <br>  Par exemple, une structure du type suivant ressemble √† <code>CONSTANT_String</code> : </p><br><pre> <code class="plaintext hljs"> CONSTANT_String_info { u1 tag; u2 string_index; }</code> </pre> <br><p>  Toutes ces structures se trouvent au <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">chapitre 4.4 Le bassin constant.</a> </p><br><p>  Voyons maintenant ce que signifient les types d' <code>info</code> internes. </p><br><p>  Les m√©thodes qui rel√®vent du mod√®le <code>*_index</code> contiennent g√©n√©ralement l'adresse de la table de pool constante.  Par exemple, <code>class_index</code> pour une valeur de type <code>CONSTANT_Class_info</code> et <code>string_index</code> pour une <code>string_index</code> <code>CONSTANT_Utf8_info</code> </p><br><p>  Nous pouvons voir cela dans le code d√©mont√©: </p><br><pre> <code class="plaintext hljs"> #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18</code> </pre> <br><pre> <code class="plaintext hljs"> 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 -- CONSTANT_String</code> </pre> <br><p>  Vous pouvez √©galement mettre en √©vidence la repr√©sentation des nombres et des cha√Ænes. </p><br><p>  Vous pouvez lire sur la repr√©sentation des nombres √† partir du chapitre <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.4.4</a> , mais pour l'instant nous n'analyserons que les lignes, car les nombres ne sont pas encore inclus dans le programme Hello World </p><br><p>  En fait, voici comment la ligne appara√Æt: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; }</code> </pre> <br><p>  Par exemple, notre Hello World: </p><br><pre> <code class="plaintext hljs"> 01 -- tag 000b -- length 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- bytes[length] // H ello W orld</code> </pre> <br><p>  En analysant l'ensemble du pool de constantes de bytecode, nous obtenons: </p><br><div class="spoiler">  <b class="spoiler_title">L'ensemble du pool de constantes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> -- [Constant Pool] -- methodref 0a 0006 000f -- fieldref 09 0010 0011 -- string 08 0012 -- methodref 0a 0013 0014 -- Class 07 0015 -- Class 07 0016 -- Utf8 01 0006 3c 69 6e 69 74 3e -- Utf8 01 0003 28 29 56 -- Utf8 01 0004 43 6f 64 65 -- Utf8 01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 -- Utf8 01 0004 6d 61 69 6e -- Utf8 01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- Utf8 01 000a 53 6f 75 72 63 65 46 69 6c 65 -- Utf8 01 0009 4d 61 69 6e 2e 6a 61 76 61 -- NameAndType 0c 0007 0008 -- Class 07 0017 -- NameAndType 0c 0018 0019 -- Utf8 01 000b 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- Class 07 001a -- NameAndType 0c 001b 001c -- Utf8 01 0004 4d 61 69 6e -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d -- Utf8 01 0003 6f 75 74 -- Utf8 01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b -- Utf8 01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d -- Utf8 01 0007 70 72 69 6e 74 6c 6e -- Utf8 01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- [Constant Pool END]</code> </pre> </div></div><br><p>  Aussi, nous pouvons le comparer avec du code d√©mont√©: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V</code> </pre> <br><p>  V√©rifier ainsi que tout correspond, car en fait <code>javap</code> traite simplement ce bytecode et nous le montre sous une forme format√©e. </p><br><p>  Le pool constant est n√©cessaire pour les instructions.  Par exemple: </p><br><pre> <code class="plaintext hljs"> public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 //    1    4: return</code> </pre> <br><p>  Pour plus d'informations sur tous les types du pool constant, voir le <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">chapitre 4.4 Le pool constant.</a> </p><br><p>  Aller plus loin dans la structure <em>ClassFile</em> </p><br><p>  <strong>access_flags</strong> </p><br><p>  Il s'agit d'un masque de bits pour les propri√©t√©s des modificateurs. </p><br><div class="scrollable-table"><table><thead><tr><th>  Nom du drapeau </th><th>  Valeur </th><th>  Interpr√©tation </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  D√©clar√© <code>public</code> ;  peut √™tre consult√© de l'ext√©rieur de son emballage. </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  D√©clar√©e <code>final</code> ;  aucune sous-classe n'est autoris√©e. </td></tr><tr><td> <code>ACC_SUPER</code> </td> <td>  0x0020 </td><td>  Traitez les m√©thodes de superclasse sp√©cialement lorsqu'elles sont invoqu√©es par l'instruction <em>invokespecial</em> . </td></tr><tr><td> <code>ACC_INTERFACE</code> </td> <td>  0x0200 </td><td>  Est une interface, pas une classe. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  <code>abstract</code> d√©clar√©;  ne doit pas √™tre instanci√©. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Synth√©tique d√©clar√©;  non pr√©sent dans le code source. </td></tr><tr><td> <code>ACC_ANNOTATION</code> </td> <td>  0x2000 </td><td>  D√©clar√© comme type d'annotation. </td></tr><tr><td> <code>ACC_ENUM</code> </td> <td>  0x4000 </td><td>  D√©clar√© comme type <code>enum</code> . </td></tr></tbody></table></div><br><p>  <strong>cette_classe</strong> </p><br><p>  Doit contenir une adresse sur <code>this</code> classe.  Dans notre cas, il se situe √† l'adresse 5: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object ...</code> </pre> <br><p>  Il est √† noter que la structure de cette variable doit √™tre conforme √† <code>CONSTANT_Class_info</code> </p><br><p>  <strong>super_class</strong> </p><br><p>  Adresse de l'anc√™tre de la classe.  Dans notre cas, la valeur est √† l'adresse <code>#6</code> .  Eh bien, la structure de valeurs <code>CONSTANT_Class_info</code> est √©galement requise </p><br><p>  Les noms de ces classes sont d√©finis dans la structure de la constante <code>CONSTANT_Utf8_info</code> .  Si nous regardons les cellules <code>#21</code> et <code>#22</code> , nous verrons: </p><br><pre> <code class="plaintext hljs"> ... #21 = Utf8 Main #22 = Utf8 java/lang/Object ...</code> </pre> <br><p>  Autrement dit, dans ces cellules, le <code>name_index</code> de la structure est indiqu√©: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  <strong>interfaces_count, fields_count</strong> </p><br><p>  Ils ne sont pas dans notre programme, donc leurs valeurs seront √©gales √† 0000, et il n'y aura tout simplement pas de valeurs ult√©rieures des <code>fields[]</code> , <code>interfaces[]</code> . </p><br><p>  En savoir plus <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.1 La structure ClassFile</a> </p><br><p>  <strong>m√©thodes_comptes</strong> </p><br><p>  Nombre de m√©thodes.  Bien que dans le code, nous voyons une m√©thode dans la classe, il y en a en fait deux.  En plus de la m√©thode <code>main</code> , il existe √©galement un constructeur par d√©faut.  Par cons√©quent, leur nombre est de deux, dans notre cas. </p><br><p>  <strong>m√©thodes []</strong> </p><br><p>  Chaque √©l√©ment doit √™tre conforme √† la structure <code>method_info</code> d√©crite au <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">chapitre 4.6 M√©thodes</a> </p><br><pre> <code class="plaintext hljs"> method_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  Dans notre bytecode (format√©, avec commentaires), cela ressemble √† ceci: </p><br><pre> <code class="plaintext hljs"> -- [methods] -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 0001 -- max_stack 0001 -- max_locals 0000 0005 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 000a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01 -- public static void main(java.lang.String...); 0089 --access_flags 000b -- name_index 000c -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 0025 -- attribute_length 0002 -- max_stack 0001 -- max_locals 0000 0009 -- code_length b2 00 02 12 03 b6 00 04 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count 000a -- attribute_name_index 0000 000a -- attribute_length 00 02 00 00 00 04 00 08 00 05 -- [methods END]</code> </pre> <br><p>  Analysons plus en d√©tail la structure des m√©thodes: </p><br><p>  <strong>access_flags</strong> </p><br><p>  Masque modificateur.  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tableau 4.5 Indicateurs d'acc√®s aux m√©thodes et de propri√©t√©</a> </p><br><div class="scrollable-table"><table><thead><tr><th>  Nom du drapeau </th><th>  Valeur </th><th>  Interpr√©tation </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  D√©clar√© <code>public</code> ;  peut √™tre consult√© de l'ext√©rieur de son emballage. </td></tr><tr><td> <code>ACC_PRIVATE</code> </td> <td>  0x0002 </td><td>  D√©clar√© <code>private</code> ;  accessible uniquement dans la classe de d√©finition. </td></tr><tr><td> <code>ACC_PROTECTED</code> </td> <td>  0x0004 </td><td>  D√©clar√© <code>protected</code> ;  sont accessibles dans les sous-classes. </td></tr><tr><td> <code>ACC_STATIC</code> </td> <td>  0x0008 </td><td>  D√©clar√© <code>static</code> . </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  D√©clar√©e <code>final</code> ;  ne doit pas √™tre outrepass√© ( <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">¬ß5.4.5</a> ). </td></tr><tr><td> <code>ACC_SYNCHRONIZED</code> </td> <td>  0x0020 </td><td>  D√©clar√© <code>synchronized</code> ;  l'invocation est encapsul√©e par une utilisation de moniteur. </td></tr><tr><td> <code>ACC_BRIDGE</code> </td> <td>  0x0040 </td><td>  Une m√©thode de pont, g√©n√©r√©e par le compilateur. </td></tr><tr><td> <code>ACC_VARARGS</code> </td> <td>  0x0080 </td><td>  D√©clar√© avec un nombre variable d'arguments. </td></tr><tr><td> <code>ACC_NATIVE</code> </td> <td>  0x0100 </td><td>  <code>native</code> d√©clar√©;  impl√©ment√© dans un langage autre que Java. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  <code>abstract</code> d√©clar√©;  aucune impl√©mentation n'est fournie. </td></tr><tr><td> <code>ACC_STRICT</code> </td> <td>  0x0800 </td><td>  D√©clar√© <code>strictfp</code> ;  le mode virgule flottante est FP-strict. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Synth√©tique d√©clar√©;  non pr√©sent dans le code source. </td></tr></tbody></table></div><br><p>  Comme nous pouvons le voir dans le bytecode, dans la m√©thode <code>public Main();</code>  (constructeur) est le masque <code>0001</code> , ce qui signifie <code>ACC_PUBLIC</code> . </p><br><p>  Essayons maintenant d'assembler la m√©thode <code>main</code> nous-m√™mes.  Voici ce qu'il a: </p><br><ul><li>  public - ACC_PUBLIC - 0x0001 </li><li>  statique - ACC_STATIC - 0x0008 </li><li>  Cha√Æne ... args - ACC_VARARGS - 0x0080 </li></ul><br><p>  Nous collectons le masque: 0x0001 + 0x0008 + 0x0080 = <code>0x0089</code> .  Nous avons donc obtenu <code>access_flag</code> </p><br><blockquote>  Soit dit en passant, ACC_VARARGS est facultatif ici, dans le sens o√π si nous <br>  utilis√© String [] args au lieu de String ... args, alors cet indicateur ne serait pas </blockquote><p>  <strong>nom_index</strong> </p><br><p>  Adresse du nom de la m√©thode ( <code>CONSTANT_Utf8_info</code> ) dans le pool constant.  Il est important de noter ici que le nom du constructeur n'est pas Main, mais <code>&lt;init&gt;</code> , situ√© dans la cellule # 7. </p><br><p>  En savoir plus sur <code>&lt;init&gt;</code> et <code>&lt;clinit&gt;</code> au <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">chapitre 2.9 M√©thodes sp√©ciales</a> </p><br><p>  <strong>descriptor_index</strong> </p><br><p>  En gros, il s'agit d'une adresse pointant vers un descripteur de m√©thode.  Ce descripteur contient le type de la valeur de retour et le type de sa signature. </p><br><p>  De plus, la JVM utilise des abr√©viations interpr√©t√©es: </p><br><div class="scrollable-table"><table><thead><tr><th>  Caract√®re <em>BaseType</em> </th><th>  Tapez </th><th>  Interpr√©tation </th></tr></thead><tbody><tr><td> <code>B</code> </td> <td> <code>byte</code> </td> <td>  octet sign√© </td></tr><tr><td> <code>C</code> </td> <td> <code>char</code> </td> <td>  Point de code de caract√®re Unicode dans le plan multilingue de base, cod√© avec UTF-16 </td></tr><tr><td> <code>D</code> </td> <td> <code>double</code> </td> <td>  valeur √† virgule flottante double pr√©cision </td></tr><tr><td> <code>F</code> </td> <td> <code>float</code> </td> <td>  valeur √† virgule flottante simple pr√©cision </td></tr><tr><td> <code>I</code> </td> <td> <code>int</code> </td> <td>  entier </td></tr><tr><td> <code>J</code> </td> <td> <code>long</code> </td> <td>  entier long </td></tr><tr><td>  <code>L</code> <em>ClassName</em> <code>;</code> </td><td> <code>reference</code> </td> <td>  une instance de classe <em>ClassName</em> </td></tr><tr><td> <code>S</code> </td> <td> <code>short</code> </td> <td>  sign√© court </td></tr><tr><td> <code>Z</code> </td> <td> <code>boolean</code> </td> <td>  <code>true</code> ou <code>false</code> </td></tr><tr><td> <code>[</code> </td> <td> <code>reference</code> </td> <td>  une dimension de tableau </td></tr></tbody></table></div><br><p>  En g√©n√©ral, cela ressemble √† ceci: </p><br><pre> <code class="plaintext hljs"> ( ParameterDescriptor* ) ReturnDescriptor</code> </pre> <br><p>  Par exemple, la m√©thode suivante: </p><br><pre> <code class="plaintext hljs"> Object method(int i, double d, Thread t) {..}</code> </pre> <br><p>  Peut √™tre repr√©sent√© comme </p><br><pre> <code class="plaintext hljs"> (IDLjava/lang/Thread;)Ljava/lang/Object</code> </pre> <br><p>  En fait, <code>I</code> est <code>int</code> , <code>D</code> est <code>double</code> et <code>Ljava/lang/Thread;</code>  classe <code>Thread</code> de la biblioth√®que <code>java.lang</code> standard. </p><br><p>  Ensuite, il existe des attributs qui ont √©galement leur propre structure. </p><br><p>  Mais d'abord, comme toujours, son nombre d' <code>attributes_count</code> </p><br><p>  Ensuite, les attributs eux-m√™mes avec la structure d√©crite au <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">chapitre 4.7 Attributs</a> </p><br><pre> <code class="plaintext hljs"> attribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; }</code> </pre> <br><p>  <strong>nom_attribut_index</strong> </p><br><p>  Sp√©cifie un nom d'attribut.  Dans notre cas, les deux m√©thodes ont un <code>Code</code> .  Les attributs sont un grand sujet distinct dans lequel vous pouvez m√™me cr√©er vos propres attributs par sp√©cification.  Mais pour l'instant, nous devons savoir que <code>attribute_name_index</code> pointe simplement vers l'adresse dans le pool constant avec la structure <code>CONSTANT_Utf8_info</code> </p><br><p>  <strong>longueur_attribut</strong> </p><br><p>  Contient la longueur de l'attribut, sans compter l' <code>attribute_name_index</code> et l' <code>attribute_length</code> </p><br><p>  <strong>info</strong> </p><br><p>  Ensuite, nous utiliserons la structure <code>Code</code> , car dans la valeur de <code>attribute_name_index</code> nous avons point√© la valeur dans le pool de constantes <code>Code</code> . </p><br><p>  En savoir plus: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Chapitre 4.7.3 L'attribut de code</a> </p><br><p>  Voici sa structure: </p><br><pre> <code class="plaintext hljs"> Code_attribute { u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  <strong>max_stack</strong> </p><br><p>  Il me semble que le nom de cet attribut peut √™tre trompeur en raison du pr√©fixe max.  En fait, il s'agit de la taille de pile minimale requise pour terminer l'op√©ration.  Eh bien, ce nom prend une logique, c'est-√†-dire la taille de pile maximale qui sera atteinte pendant l'op√©ration. </p><br><p>  Autrement dit, la JVM allouera de l'espace pour la pile d'op√©randes.  L√†, vous pouvez sp√©cifier une valeur plus grande que n√©cessaire, mais d√©finir une valeur dans cet attribut moins que n√©cessaire entra√Ænera une erreur. </p><br><p>  Sur le sujet de la pile, vous pouvez lire " <a href="https%253A%252F%252Fwww.tune-it.ru%252Fweb%252Fbleizard%252Fblog%253Fp_p_id%253Dcom_liferay_blogs_web_portlet_BlogsPortlet%2526p_p_lifecycle%253D0%2526p_p_state%253Dnormal%2526p_p_mode%253Dview%2526_com_liferay_blogs_web_portlet_BlogsPortlet_cur%253D2%2526_com_liferay_blogs_web_portlet_BlogsPortlet_delta%253D10%2526p_r_p_resetCur%253Dfalse">Sur la pile et le tas dans le contexte du monde Java</a> " ou dans " <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a> " </p><br><p>  <strong>max_locals</strong> </p><br><p>  Taille maximale des variables locales </p><br><p>  Vous pouvez vous familiariser avec les variables locales soit dans <a href="https://jrebel.com/rebellabs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">Mastering Java Bytecode au c≈ìur de la JVM</a> ou dans les m√™mes <a href="http://blog.jamesdbloom.com/JVMInternals.html">internes JVM</a> </p><br><p>  <strong>code_length</strong> </p><br><p>  La taille du code qui sera ex√©cut√© √† l'int√©rieur de la m√©thode </p><br><p>  <strong>code []</strong> </p><br><p>  Chaque code pointe vers une instruction.  Le tableau de corr√©lation de l' <code>optcode</code> et des commandes avec les mn√©moniques se trouve sur Wikipedia - <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Liste d'instructions du bytecode Java</a> ou dans la sp√©cification elle-m√™me √† la fin du livre </p><br><p>  Par exemple, prenez notre constructeur: </p><br><pre> <code class="plaintext hljs"> -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 00 01 -- max_stack 00 01 -- max_locals 00 00 00 05 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 00 0a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01</code> </pre> <br><p>  Ici, nous pouvons trouver notre code: </p><br><pre> <code class="plaintext hljs"> 2a b7 00 01 b1</code> </pre> <br><p>  Nous recherchons des commandes dans le tableau et comparons: </p><br><pre> <code class="plaintext hljs"> 2a - aload_0 b7 0001 - invokespecial #1 b1 - return</code> </pre> <br><p>  Vous trouverez √©galement des descriptions de ces commandes ici: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Chapitre 4.10.1.9.</a>  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Instructions de v√©rification de type</a> </p><br><p>  <strong>exception_table_length</strong> </p><br><p>  Sp√©cifie le nombre d'√©l√©ments dans la table d'exceptions.  Nous n'avons pas de hooks d'exception donc nous ne le analyserons pas.  Mais vous pouvez √©galement lire le <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">chapitre 4.7.3 L'attribut de code</a> </p><br><p>  <strong>table_exceptions []</strong> </p><br><p>  Il a la structure suivante: </p><br><pre> <code class="plaintext hljs"> { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; }</code> </pre> <br><p>  Pour simplifier, vous devez sp√©cifier le d√©but, la fin ( <code>start_pc</code> , <code>end_pc</code> ) du code que <code>handler_pc</code> g√©rera et le <code>catch_type</code> exception <code>catch_type</code> </p><br><p>  <strong>attributs_count</strong> </p><br><p>  Nombre d'attributs dans le <code>Code</code> </p><br><p>  <strong>attributs []</strong> </p><br><p>  Les attributs sont souvent utilis√©s par les analyseurs ou les d√©bogueurs. </p><br><hr><br><h3 id="sredstva-dlya-raboty-s-bayt-kodom">  Outils de bytecode </h3><br><p>  Ce n'est pas le sujet qui se rapporte √† cet article, mais il y est toujours indirectement li√©. </p><br><p>  Il existe de nombreux outils pour travailler avec le bytecode.  Ici, je voudrais examiner la <a href="https://commons.apache.org/proper/commons-bcel/">biblioth√®que d'ing√©nierie de code d'octets</a> (BCEL) d'Apache Commons. </p><br><p>  Pour commencer, en l'utilisant, nous pouvons obtenir des attributs de bytecode: </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes());</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Liste compl√®te des codes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import org.apache.bcel.classfile.*; import org.apache.commons.codec.binary.Hex; import java.io.*; public class ClassParserExample { public static void main(String... args) throws IOException, ClassNotFoundException { // read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes()); System.out.println( "minor: " + MINOR_VER ); // 0 System.out.println( "major: " + MAJOR_VER ); // 34 System.out.println( "constant pool: " + CONSTANT_POOL); // not correctly System.out.println( "access flags: " + ACCESS_FLAGS ); // 21 System.out.println( "this class: " + THIS_CLASS ); System.out.println( "super class: " + SUPER_CLASS ); // Object System.out.println( "interfaces: " + INTERFACES ); // &lt;empty&gt; System.out.println( "fields: " + FIELDS ); // &lt;empty&gt; System.out.println( "methods: " + METHODS ); // one method: psvm hello world System.out.println( "attributes: " + ATTRIBUTES ); // 536f7572636546696c65 - I think it's instructions for Java tools } private static String getHex(byte[] bytes){ return Hex.encodeHexString(bytes); } private static String getHex(int intNum){ return Integer.toHexString(intNum); } private static String getHex(Constant[] constants){ if (constants == null) return null; StringBuilder sb = new StringBuilder(); for (Constant c : constants){ if (c == null) continue; sb.append(getHex(c.getTag())).append(" "); } return sb.toString(); } private static String getHex(JavaClass[] clazzes){ if (clazzes == null) return null; StringBuilder sb = new StringBuilder(); for (JavaClass c : clazzes){ sb.append(getHex(c.getClassName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Field[] fields){ if (fields == null) return null; StringBuilder sb = new StringBuilder(); for (Field c : fields){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Method[] methods){ if (methods == null) return null; StringBuilder sb = new StringBuilder(); for (Method c : methods){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Attribute[] attributes){ if (attributes == null) return null; StringBuilder sb = new StringBuilder(); for (Attribute c : attributes){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } } /* Class A: public class ClassA { public static void main(String[] args) { System.out.println("Hello world"); } } */ /* Class A bytecode: cafe babe 0000 0034 0022 0a00 0600 1409 0015 0016 0800 170a 0018 0019 0700 1a07 001b 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 124c 6f63 616c 5661 7269 6162 6c65 5461 626c 6501 0004 7468 6973 0100 1d4c 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 413b 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0461 7267 7301 0013 5b4c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b01 000a 536f 7572 6365 4669 6c65 0100 0b43 6c61 7373 412e 6a61 7661 0c00 0700 0807 001c 0c00 1d00 1e01 000b 4865 6c6c 6f20 776f 726c 6407 001f 0c00 2000 2101 001b 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 4101 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 2f00 0100 0100 0000 052a b700 01b1 0000 0002 000a 0000 0006 0001 0000 0006 000b 0000 000c 0001 0000 0005 000c 000d 0000 0009 000e 000f 0001 0009 0000 0037 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0200 0a00 0000 0a00 0200 0000 0800 0800 0900 0b00 0000 0c00 0100 0000 0900 1000 1100 0000 0100 1200 0000 0200 13 */ /* Assembled code: Classfile /C:/java/BCEL/src/main/resources/compiled/ClassA.class Last modified 08.12.2019; size 563 bytes MD5 checksum bcd0198f6764a1dc2f3967fef701452e Compiled from "ClassA.java" public class com.apploidxxx.parse.ClassA minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#20 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // Hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // com/apploidxxx/parse/ClassA #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/apploidxxx/parse/ClassA; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 ClassA.java #20 = NameAndType #7:#8 // "&lt;init&gt;":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 Hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 com/apploidxxx/parse/ClassA #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V { public com.apploidxxx.parse.ClassA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/apploidxxx/parse/ClassA; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 8: 0 line 9: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; } SourceFile: "ClassA.java */</code> </pre> </div></div><br><p>     ,    (,  Jasmin) -. </p><br><p>      <a href="https://github.com/AppLoidx/JVM-research"> </a>   <a href="https://github.com/apache/commons-bcel/tree/master/src/examples"> </a> </p><br><p> ,     <strong>Jasmin</strong> .   ,   ,     ,         JVM  -. </p><br><p>         : </p><br><div class="spoiler"> <b class="spoiler_title">Hello World</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.bytecode 52.0 .source Main.j .class public Main .super java/lang/Object .method public static main([Ljava/lang/String;)V .limit stack 2 .limit locals 2 getstatic java/lang/System/out Ljava/io/PrintStream; ldc "Hello world!" invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V return .end method</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">; ClassCreating.j .bytecode 52.0 .source ClassCreating.java .class public ClassCreating .super java/lang/Object .method public &lt;init&gt;()V .limit stack 1 .limit locals 1 .line 1 0: aload_0 1: invokespecial java/lang/Object/&lt;init&gt;()V 4: return .end method .method public static main([Ljava/lang/String;)V ; Flag ACC_VARARGS set, see JVM spec .limit stack 2 .limit locals 3 .line 3 0: new java/lang/String 3: dup 4: invokespecial java/lang/String/&lt;init&gt;()V 7: astore_1 .line 4 8: new ClassCreating 11: dup 12: invokespecial ClassCreating/&lt;init&gt;()V 15: astore_2 .line 5 16: aload_2 17: invokevirtual ClassCreating/sayHello()V .line 6 20: return .end method .method public sayHello()V .limit stack 2 .limit locals 1 .line 9 0: getstatic java/lang/System/out Ljava/io/PrintStream; 3: ldc "Hello, User!" 5: invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V .line 10 8: return .end method</code> </pre> </div></div><br><hr><br><p>       Hello World </p><br><p>  -       : <a href="https://gist.github.com/AppLoidx/7173d7277dd73025ae06377a7cc75ed0">gist.github</a> </p><br><p>          . </p><br><p>  <strong>Litt√©rature utilis√©e</strong> </p><br><ul><li> The Java Virtual Machine Specification ‚Äî <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">docs.oracle</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480550/">https://habr.com/ru/post/fr480550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480534/index.html">16 conseils de d√©veloppement pour Android dans Kotlin. 2e partie</a></li>
<li><a href="../fr480538/index.html">Quoi de mieux pour les jeux: Intel Optane ou SSD?</a></li>
<li><a href="../fr480540/index.html">Sortie d'Umbraco 8.4: le CMS est encore plus pratique</a></li>
<li><a href="../fr480542/index.html">Sensibilisation √† la s√©curit√© des adultes: comment supprimer une vuln√©rabilit√© de phishing</a></li>
<li><a href="../fr480544/index.html">5 secrets cach√©s en Java</a></li>
<li><a href="../fr480552/index.html">Firefox se bat pour l'avenir du Web</a></li>
<li><a href="../fr480554/index.html">L'avenir du cloud computing de Sun qui n'est jamais venu</a></li>
<li><a href="../fr480556/index.html">NGINX: V√©rification de la communaut√© informatique russe</a></li>
<li><a href="../fr480558/index.html">Comment le niveau d'√©quilibre du minage vous permet de d√©terminer le point de pivot du bitcoin</a></li>
<li><a href="../fr480560/index.html">ICD robotique partie des fonctions dans le d√©partement des op√©rations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>