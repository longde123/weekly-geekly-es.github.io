<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 👳🏿 💎 Unwissenschaftlich über Monaden 👨🏼‍⚖️ 🗣️ 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. 

 Nach vier Jahren Programmierung auf Scala ist mein Verständnis von Monaden endlich so weit gewachsen, dass man es anderen erklären k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unwissenschaftlich über Monaden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454534/">  Hallo an alle. <br><br>  Nach vier Jahren Programmierung auf Scala ist mein Verständnis von Monaden endlich so weit gewachsen, dass man es anderen erklären kann, ohne auf die Kategorietheorie und die klassische <i>Monade</i> Bezug zu nehmen <i>- es ist nur ein Monoid in der Kategorie der Endofunder</i> , das Programmierer nicht schlechter macht als Dichlorvos-Kakerlaken. <br><br>  Codebeispiele werden in Kotlin, as geschrieben  es ist sehr beliebt und gleichzeitig sehr funktional (in beiden Sinne des Wortes). <br><a name="habracut"></a><br>  Beginnen wir mit dem Konzept eines <i>Funktors</i> , hier ist es: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br>  Was bedeutet es?  Ein Funktor ist eine Abstraktion einer beliebigen Berechnung, die ein Ergebnis vom Typ A zurückgibt. Wir abstrahieren davon, wie ein neuer Funktor erstellt wird und vor allem, wie sein Wert A berechnet wird. Insbesondere kann sich eine Funktion hinter einer Funktorschnittstelle verstecken mit einer beliebigen Anzahl von Argumenten und nicht unbedingt einer reinen Funktion. <br><br>  Beispiele für Funktorimplementierungen: <br><br><ul><li>  konstant </li><li>  Funktion mit einer beliebigen Anzahl von Argumenten, die ein Ergebnis vom Typ <code>A</code> zurückgibt </li><li>  Zustand Pseudozufallsgenerator (Random) </li><li>  Hardware-Zufallszahlengenerator </li><li>  Lesen eines Objekts von der Festplatte oder vom Netzwerk </li><li>  asynchrone Berechnung - Ein Rückruf wird an die Funktorimplementierung übergeben, die später aufgerufen wird </li></ul><br>  Alle diese Beispiele mit Ausnahme der Konstanten haben eine wichtige Eigenschaft - sie sind faul, d.h.  Die Berechnung selbst erfolgt nicht beim Erstellen des Funktors, sondern beim Berechnen. <br><br>  Die Funktorschnittstelle ermöglicht weder das Abrufen eines Werts vom Typ <code>A</code> von Funktor <code>Functor&lt;A&gt;</code> noch das Erstellen eines neuen <code>Functor&lt;A&gt;</code> aus einem vorhandenen Wert vom Typ <code>A</code>  Aber selbst mit solchen Einschränkungen ist der Funktor nicht nutzlos - wenn wir für einen Typ <code>B</code> <code>A</code> in <code>B</code> konvertieren können (mit anderen Worten, es gibt eine Funktion <code>(a: A) -&gt; B</code> ), dann können wir eine Funktion schreiben <code>(f: Functor&lt;A&gt;) -&gt; Functor&lt;B&gt;</code> und nennen Sie es <code>map</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;B&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; B): Functor&lt;B&gt; }</code> </pre><br>  Im Gegensatz zum Funktor selbst kann die Kartenmethode keine beliebige Funktion sein: <br>  - <code>map((a) -&gt; a)</code> sollte denselben Funktor zurückgeben <br>  - <code>map((a) -&gt; f(a)).map((b) -&gt; g(b))</code> muss mit <code>map(a -&gt; g(f(a))</code> identisch sein. <br><br>  Als Beispiel implementieren wir einen Funktor, der einen A-Wert zurückgibt, der eine bestimmte Anzahl von Zufallsbits enthält.  Unsere Schnittstelle in Kotlin kann nicht so einfach verwendet werden (aber Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können es</a> , falls gewünscht), daher werden wir eine Erweiterungsmethode schreiben: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  - ,     ,   map data class MyRandom&lt;A&gt;( val get: (bits: Int) -&gt; A ) { companion object { val intRandom: MyRandom&lt;Int&gt; = MyRandom { Random.nextBits(it) } val hexRandom: MyRandom&lt;String&gt; = intRandom.map { it.toString(16) } } } //  map   fun &lt;A, B&gt; MyRandom&lt;A&gt;.map(f: (A) -&gt; B): MyRandom&lt;B&gt; = MyRandom(get = {bits -&gt; f(get(bits)) }) fun main(args: Array&lt;String&gt;) { println("random=" + MyRandom.intRandom.get(12)) //  random=1247 println("hexRandom=" + MyRandom.hexRandom.get(12)) //  hexRandom=c25 }</span></span></code> </pre><br>  Andere Beispiele für Funktoren mit einer nützlichen <code>map</code> <br><br><ul><li>  unveränderliche <code>List&lt;A&gt;</code> </li><li> <code>MyInputStream&lt;A&gt;</code> </li> <li> <code>Optional&lt;A&gt;</code> </li> </ul><br>  Jetzt können Sie zu Monaden gehen. <br><br>  Eine Monade ist ein Funktor mit zwei zusätzlichen Operationen.  Erstens enthält die Monade im Gegensatz zum Funktor die Operation des Erzeugens aus einer Konstanten. Diese Operation wird als <code>lift</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Monad&lt;A&gt; = TODO()</code> </pre><br>  Die zweite Operation heißt <code>flatMap</code> und ist komplizierter. Zuerst geben wir unsere gesamte Monadenschnittstelle an: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,  map     - //    flatMap  lift fun &lt;B&gt; map(f: (A) -&gt; B): Monad&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } fun &lt;B&gt; flatMap(f: (A) -&gt; Monad&lt;B&gt;): Monad&lt;B&gt; } fun &lt;A&gt; lift(value: A): Monad&lt;A&gt; = TODO()</span></span></code> </pre><br>  Der wichtigste Unterschied zwischen einer Monade und einem Funktor besteht darin, dass Monaden miteinander <i>kombiniert</i> werden können, um neue Monaden zu erzeugen und von der Implementierung der Monade zu abstrahieren - ob sie von der Festplatte liest, ob sie zusätzliche Parameter zur Berechnung ihres Werts akzeptiert, existiert dieser Wert .  Der zweite wichtige Punkt - Monaden werden nicht parallel, sondern nacheinander kombiniert, sodass je nach Ergebnis der ersten Monade Logik hinzugefügt werden kann. <br><br>  Ein Beispiel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     Int //       -      //           val readInt: Monad&lt;Int&gt; = TODO() // ,      -  fun readBytes(len: Int): Monad&lt;ByteArray&gt; = TODO() // ,     ,    val bytes: Monad&lt;ByteArray&gt; = readInt.flatMap {len -&gt; if (len &gt; 0) readBytes(len) //    -   else lift(ByteArray(0)) //  ,    }</span></span></code> </pre><br>  In diesem Beispiel wird jedoch kein Netzwerk erwähnt.  Ebenso gut können Daten aus einer Datei oder aus einer Datenbank gelesen werden.  Sie können synchron oder asynchron gelesen werden, hier kann es zu einer Fehlerbehandlung kommen - alles hängt von der spezifischen Implementierung der Monade ab, der Code selbst bleibt unverändert. <br><br>  Das Beispiel ist zunächst einfacher, Option Monade.  In Kotlin wird es nicht wirklich benötigt, aber in Java / Scala ist es äußerst nützlich: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: A?) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; map(f: (A) -&gt; B): Option&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; flatMap(f: (A) -&gt; Option&lt;B&gt;): Option&lt;B&gt; = </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function">(value) { </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> -&gt; Option(</span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> -&gt; f(value) } } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;A&gt; lift(value: A?): Option&lt;A&gt; = Option(value) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> mul(a: Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt;, b: Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt;): Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt; = a.flatMap { a -&gt; b.map { b -&gt; a * b } } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { println(mul(Option(<span class="hljs-number"><span class="hljs-number">4</span></span>), Option(<span class="hljs-number"><span class="hljs-number">5</span></span>)).value) <span class="hljs-comment"><span class="hljs-comment">// 20 println(mul(Option(null), Option(5)).value) // null println(mul(Option(4), Option(null)).value) // null println(mul(Option(null), Option(null)).value) // null }</span></span></code> </pre><br>  Lassen Sie uns als Monade der Pozakovyristie die Arbeit mit der Datenbank in der Monade abschließen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DB</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: (Connection) -&gt; A) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; map(f: (A) -&gt; B): DB&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; flatMap(f: (A) -&gt; DB&lt;B&gt;): DB&lt;B&gt; = DB { conn -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this.f(conn)</span></span></span></span>).f(conn) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DB&lt;A&gt; = DB { value } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DB&lt;String&gt; = DB { conn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> st = conn.createStatement() <span class="hljs-comment"><span class="hljs-comment">// .... TODO() } fun update(value: String): DB&lt;Unit&gt; = DB { conn -&gt; val st = conn.createStatement() // .... TODO() } fun selectThenUpdate(id: Int): DB&lt;Unit&gt; = select(id).flatMap { value -&gt; update(value) } fun executeTransaction(c: Connection): Unit { //  ,     //          val body: DB&lt;Unit&gt; = selectThenUpdate(42) //  ,   select  update body.f(c) c.commit() }</span></span></code> </pre><br><h3>  Ist das Kaninchenloch tief? </h3><br>  Es gibt eine Vielzahl von Monaden, aber ihr Hauptzweck besteht darin, die Geschäftslogik der Anwendung von einigen Details der durchgeführten Berechnungen zu abstrahieren: <br><br><ul><li>  dass der Wert möglicherweise nicht vorhanden ist: <code>data class Option&lt;A&gt;(value: A?)</code> </li><li>  dass die Berechnung fehlschlägt: <code>data class Either&lt;Error, A&gt;(value: Pair&lt;Error?, A?&gt;)</code> </li><li>  dass die Berechnung faul sein kann: <code>data class Defer&lt;A&gt;(value: () -&gt; A)</code> </li><li>  oder asynchron: <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code> </li><li>  oder einen Funktionszustand haben: <code>data class State&lt;S, A&gt;(value: (S) -&gt; Pair&lt;S, A&gt;)</code> </li></ul><br>  Liste der unbeantworteten Fragen: <br><br><ul><li>  Applikative Funktoren - eine Zwischenverbindung zwischen Funktoren und Monaden </li><li>  Sammlungen wie Monaden </li><li>  Kompositionen monotypischer Monaden - Pfeilkleber, monadische Transformatoren </li><li>  Sequenz / Traverse </li><li>  Monaden als Effekte </li><li>  Monaden und Rekursion, Stapelüberlauf, Trampolin </li><li>  Tagless endgültige Codierung </li><li>  Io Monade </li><li>  und im Allgemeinen der ganze Zoo der Standardmonaden </li></ul><br><h3>  Was weiter? </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfeil-kt.io</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typelevel.org/cats/typeclasses.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki.haskell.org/All_About_Monads</a> <br><br>  Mein Experiment ist eine vollwertige FP-Anwendung auf Scala: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/scf37/fpscala2</a> <br><br>  PS Ich wollte eine kleine Notiz, es stellte sich wie immer heraus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454534/">https://habr.com/ru/post/de454534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454522/index.html">Node.js: Verwalten des Speichers, der für Anwendungen verfügbar ist, die in Containern ausgeführt werden</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnbändern Samsung Level On Pro</a></li>
<li><a href="../de454530/index.html">DJI hat einen Oktokopter entwickelt, der Filme machen kann</a></li>
<li><a href="../de454532/index.html">Ich werde ein Wort über den technischen Ansatz sagen</a></li>
<li><a href="../de454536/index.html">Verstärker zum klassischen Herzfrequenzsensor</a></li>
<li><a href="../de454538/index.html">Frontend Weekly Digest (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454540/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 367 (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454542/index.html">Kabelfernsehnetze für die Kleinsten. Teil 7: Optische Empfänger</a></li>
<li><a href="../de454546/index.html">Wie viele Programmierer brauchen Sie, um eine Tasse Kaffee zu trinken?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>