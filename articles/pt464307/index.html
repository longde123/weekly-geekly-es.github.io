<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé® üë´ üë©üèº‚Äçüî¨ Teste de integra√ß√£o de microsservi√ßos no Scala üïâÔ∏è üôçüèº üîï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O teste de unidade √© √≥timo, mas um n√£o √© suficiente. Freq√ºentemente, voc√™ tamb√©m deseja garantir que o aplicativo em execu√ß√£o funcione. O teste de int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de integra√ß√£o de microsservi√ßos no Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  O teste de unidade √© √≥timo, mas um n√£o √© suficiente.  Freq√ºentemente, voc√™ tamb√©m deseja garantir que o aplicativo em execu√ß√£o funcione.  O teste de integra√ß√£o vem em socorro.  √â cada vez mais usado para testar servi√ßos, e o Docker permite gerenciar convenientemente seu ambiente de teste.  Mas, como sempre, as coisas n√£o s√£o t√£o simples quando h√° muito mais microsservi√ßos e depend√™ncias. <br><br>  Yuri Badalyants, do RIT ++, contou como, no 2GIS, eles est√£o testando v√°rios servi√ßos e um zool√≥gico de tecnologia inteiro.  Sob o corte, a vers√£o deste relat√≥rio √© complementada e atualizada sob a cuidadosa supervis√£o do orador: quais op√ß√µes voc√™ tentou, o que criou, que problemas n√£o precisa resolver agora.  Ser√° sobre Docker, Testcontainers e tamb√©m sobre Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LMnet</a> ) iniciou sua carreira em 2011 como desenvolvedor web, trabalhou com PHP, JavaScript e Java.  Agora ele escreve sobre Scala em 2GIS. <br><br><h2>  Cassino </h2><br>  A 2GIS fornece mapas de cidades e diret√≥rios de empresas convenientes h√° 20 anos e, recentemente, temos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nova vers√£o</a> com um mapa ilimitado da R√∫ssia.  Vou contar sobre a experi√™ncia adquirida enquanto trabalhei na equipe do cassino.  Essa equipe est√° envolvida em tr√™s √°reas principais: <br><br><ul><li>  Publicidade - quais anunciantes exibir, quais ocultar, quais aumentar e como diminuir a classifica√ß√£o. </li></ul><br><ul><li>  O BigData est√° relacionado √† publicidade e sua personaliza√ß√£o, al√©m da constru√ß√£o de an√°lises e m√©tricas. </li><li>  O Crawler √© um programa que procura organiza√ß√µes na Internet para adicion√°-las automaticamente ao banco de dados. </li></ul><br>  Essas tr√™s √°reas s√£o as principais tarefas, as quais, por sua vez, possuem um grande n√∫mero de subtarefas.  Atualmente, existem mais de 25 microsservi√ßos escritos em Scala.  Este √© exclusivamente nosso c√≥digo, no entanto, tamb√©m usamos sistemas de terceiros, por exemplo, PostgreSQL, Cassandra e Kafka.  Armazenamos os dados no Hadoop e os processamos no Spark.  Al√©m disso, usamos os m√©todos de aprendizado de m√°quina fornecidos pela equipe de ci√™ncia de dados. <br><br>  Como resultado, temos um grande n√∫mero de servi√ßos e microsservi√ßos, um grande n√∫mero de depend√™ncias e, √© claro, tudo isso precisa ser testado de alguma maneira. <br><br>  Obviamente, escrevemos testes de unidade.  No entanto, mesmo que todos os testes sejam verdes, isso n√£o significa que tudo funcione.  Algo pode dar errado durante a fase de integra√ß√£o de componentes ou microsservi√ßos.  Portanto, escrevemos testes de integra√ß√£o. <br><br><h2>  Testes de integra√ß√£o </h2><br>  Cada microsservi√ßo desenvolvido pela equipe do Casino resolve seu problema de neg√≥cios e est√° localizado em um reposit√≥rio separado no GitLab.  Este artigo focar√° no teste de integra√ß√£o em um reposit√≥rio (microsservi√ßo) com depend√™ncias bloqueadas, que √© de responsabilidade dos pr√≥prios desenvolvedores.  A equipe de controle de qualidade est√° testando a intera√ß√£o dos microsservi√ßos e n√£o vou abordar esse t√≥pico. <br><br>  Quando entrei para a equipe, no final de 2016, havia aproximadamente o seguinte esquema de teste de integra√ß√£o: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  O desenvolvedor envia seu c√≥digo no GIT, ap√≥s o qual o c√≥digo do microsservi√ßo entra no TeamCity.  O TeamCity come√ßa a criar c√≥digo e executar testes. </li><li>  O TeamCity pega o arquivo de configura√ß√£o (config) do Chef (um sistema de gerenciamento de configura√ß√µes semelhante ao Ansible, escrito apenas em Ruby).  O Chef tamb√©m serve para automatizar a implanta√ß√£o.  Quando tenho 100 m√°quinas, n√£o quero ir a cada uma delas e instalar o que preciso no SSH, e o Chef me permite automatizar isso. </li><li>  O TeamCity coleta o arquivo jar (desde que escrevemos no Scala, o artefato que publicamos √© o jar) e o programa o carrega no ambiente do IC.  Nosso aplicativo √© implantado l√°, tamb√©m existem algumas depend√™ncias.  No diagrama, uma das depend√™ncias √© representada como um banco de dados.  Pode haver tantas depend√™ncias quanto poss√≠vel e, gra√ßas ao Chef, nosso aplicativo as conhece e come√ßa a interagir com elas. </li><li>  Em seguida, o TeamCity lan√ßa o <strong>SBT</strong> (este √© o nosso sistema de compila√ß√£o, onde a compila√ß√£o e os testes s√£o executados) e executa os pr√≥prios testes.  Eles s√£o relativamente semelhantes aos testes de unidade, mas trabalham principalmente com esse princ√≠pio: v√° via http para um endere√ßo espec√≠fico, verifique algum m√©todo e veja o que ele retorna;  ou fa√ßa alguma prepara√ß√£o e veja se o que √© necess√°rio retornou. </li></ol><br>  <strong>O que se pode dizer sobre esse esquema?</strong>  Mais importante ainda, funciona.  Quando tudo est√° configurado, a execu√ß√£o de testes √© f√°cil, pois eles se parecem com testes de unidade.  Mas as vantagens terminam a√≠. <br><br>  E os contras come√ßam.  <strong>O ambiente do IC est√° sempre ativado</strong> , e isso √© um desperd√≠cio extra de recursos.  Como o Chef √© uma configura√ß√£o est√°tica, voc√™ sempre deve ter algum tipo de m√°quina onde todas as depend√™ncias ser√£o configuradas, onde os aplicativos ser√£o implantados independentemente.  Essa m√°quina consumir√° recursos extras, pois os testes s√£o executados periodicamente e a m√°quina deve estar pronta o tempo todo.  Al√©m disso, o ambiente do IC est√° inclu√≠do em todas as depend√™ncias. <br><br>  <strong>N√£o √© poss√≠vel executar testes em duas ramifica√ß√µes ao mesmo tempo</strong> .  Isso segue o par√°grafo anterior: como temos um ambiente, simplesmente n√£o podemos execut√°-los em paralelo. <br><br>  <strong>N√£o √© poss√≠vel testar iniciar, parar e reiniciar</strong> .  Vou explicar por que isso √© necess√°rio: todas as nossas aplica√ß√µes obedecem √† l√≥gica do chamado <strong>desligamento normal</strong> , ou seja, quando obtemos o SIGTERM, n√£o paramos o processo no meio, mas interceptamos esse sinal e entendemos que precisamos desligar o programa.  Nesse ponto, certa l√≥gica √© ativada, por exemplo, as solicita√ß√µes HTTP "em andamento" s√£o processadas ou, se trabalhamos com o Kafka, cometemos todos os erros - em outras palavras, executamos determinadas a√ß√µes para poder concluir o trabalho com seguran√ßa e depois, quando tudo estiver pronto, desligue. <br><br>  Essa l√≥gica nem sempre √© simples e voc√™ pode test√°-la com esse esquema apenas manualmente, porque a partir dos testes n√£o controlamos o ciclo de vida do aplicativo.  Acontece que o TeamCity de alguma forma implantou algo atrav√©s do Chef, enquanto os testes est√£o em um est√°gio diferente e n√£o sabem como o aplicativo √© implantado. <br><br>  O pr√≥ximo ponto negativo √© que √© muito <strong>dif√≠cil configurar tudo isso localmente</strong> .  Ou seja, existem muitas depend√™ncias, elas t√™m suas pr√≥prias configura√ß√µes, precisam ser geradas na m√°quina local.  O pr√≥prio aplicativo tamb√©m possui seu pr√≥prio arquivo de configura√ß√£o, no qual existem muitos valores.  Os testes em si t√™m uma configura√ß√£o que precisa ser correspondida com a configura√ß√£o do aplicativo e tamb√©m pode haver mais de um valor de configura√ß√£o.  Parece que tudo isso n√£o parece t√£o assustador, como "v√° e conserte as configura√ß√µes em tr√™s lugares", mas, na realidade, pode levar horas para os novos funcion√°rios fazerem isso. <br><br><h3>  CI do GitLab + Docker </h3><br>  Com o tempo, esse esquema se transformou em outro: <strong>GitLab CI</strong> e <strong>Docker</strong> .  Isso n√£o aconteceu porque o esquema anterior n√£o era o ideal, mas porque a empresa mudou ligeiramente de rumo em termos de organiza√ß√£o administrativa. <br><br>  Anteriormente, cada equipe, e n√≥s temos muitos deles, como quer√≠amos ou como poder√≠amos, e implantamos seu trabalho.  Por exemplo, t√≠nhamos TeamCity, Chef e outras equipes que poderiam usar Jenkins ou Ansible. <br><br>  Agora estamos caminhando para a nuvem local e o Kubernetes, e h√° uma equipe separada que gerencia tudo isso, tanto o GitLab CI quanto o Kubernetes.  Outras equipes apenas usam isso como um servi√ßo.  Isso √© muito mais conveniente, pois voc√™ n√£o precisa administrar tudo isso manualmente. <br><br>  Usando o Kubernetes, implantamos o seguinte esquema: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  Em vez do TeamCity, o Gitlab CI agora √© usado. </li><li>  O GitLab CI cria uma imagem do docker e a implanta no Kubernetes.  A configura√ß√£o agora √© armazenada diretamente no reposit√≥rio e n√£o separadamente no Chef. Portanto, para a implanta√ß√£o, voc√™ n√£o precisa trabalhar com um servi√ßo de configura√ß√£o de terceiros. </li><li>  As depend√™ncias s√£o levantadas com anteced√™ncia, tamb√©m no Kubernetes. </li><li>  Em seguida, o GitLab CI lan√ßa o SBT e os testes em uma etapa separada. </li></ol><br>  Tudo √© bastante semelhante ao esquema anterior e n√£o √© fundamentalmente diferente, ou seja, at√© os pr√≥s e os contras ser√£o exatamente os mesmos, mas o Docker aparece. <br><br>  Com o docker, voc√™ pode fazer coisas diferentes e mais divertidas, e um deles √© o docker-compondo. <br><br><h3>  Docker-compor </h3><br>  Esse √© um tipo de "sobreposi√ß√£o" no Docker, que permite executar v√°rias imagens do docker como uma √∫nica entidade. <br><br>  Um bom exemplo de onde o docker-compose realmente ajuda √© o Kafka.  Ela precisa do ZooKeeper para executar.  Se voc√™ levantar o Kafka e o ZooKeeper sem compor a janela de encaixe, precisar√° criar o ZooKeeper separadamente na janela de encaixe, separadamente - Kafka, e manter esses dois cont√™ineres consistentes.  Isso n√£o √© muito conveniente e o docker-compose permite que voc√™ descreva os dois cont√™ineres em um arquivo docker-compose.yml e use o <code>docker-compose run Kafka</code> simple <code>docker-compose run Kafka</code> aumentar o Kafka e o ZooKeeper. <br><br>  Voc√™ pode criar testes de integra√ß√£o na janela de encaixe-composi√ß√£o.  Vamos ver como ficar√°. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Mais uma vez, empurre tudo no GitLab. </li><li>  O GitLab CI lan√ßa a janela de encaixe-composi√ß√£o. </li><li>  No docker-compose, o aplicativo √© ativado, todas as depend√™ncias e o SBT s√£o ativados, e o SBT realiza os testes para esse aplicativo - tudo acontece dentro do docker-compondo. </li></ol><br>  Gra√ßas a esse esquema, n√£o h√° necessidade de manter um ambiente e depend√™ncias separados, porque tudo vai diretamente para o corredor de IC do GitLab, onde apenas o docker e o docker-componham.  Durante o in√≠cio, ele ir√° bombear as imagens necess√°rias e execut√°-las. <br><br>  Al√©m disso, voc√™ pode testar diferentes ramos ao mesmo tempo, porque tudo acontece no corredor. <br><br>  Agora <strong>√© mais f√°cil configurar o</strong> ambiente <strong>localmente</strong> , mas voc√™ ainda precisa coordenar v√°rios locais.  O ponto √© que agora, quando fazemos a configura√ß√£o local, n√£o precisamos colocar tudo na m√°quina local, tudo est√° escrito no arquivo docker-compose.yml.  Portanto, voc√™ deve configurar em dois locais diferentes - este √© o docker-compose.yml e a configura√ß√£o dos nossos testes. <br><br>  Quanto √†s desvantagens, <strong>ainda √© imposs√≠vel testar iniciar, parar e reiniciar</strong> , porque a partir do SBT, a partir de testes, n√£o controlamos o ciclo de vida do aplicativo.  √â executado pelo docker-compose, executa o SBT e os testes s√£o executados no SBT.  Portanto, n√£o h√° gerenciamento de ciclo de vida completo do aplicativo.  Tamb√©m h√° dificuldades com o lan√ßamento, sobre o qual gostaria de falar mais. <br><br><h4>  docker-compor 2 </h4><br>  Nos dias de docker-compose 2, docker-compose.yml, o arquivo era assim: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Os servi√ßos s√£o registrados aqui, ou seja, o que iremos aumentar como parte dessa janela de encaixe.  Nesse caso, apenas peguei um exemplo da documenta√ß√£o do docker-compose.  Existem tr√™s servi√ßos: web, redis e db (banco de dados). <br><br>  Web √© a nossa aplica√ß√£o, e redis e db s√£o algum tipo de depend√™ncia. <br><br>  H√° um item no bloco da Web chamado <code>depends_on</code> .  Isso sugere que o aplicativo Web depende de alguns outros cont√™ineres e √© descrito abaixo nos quais: do banco de dados e redis. <br><br>  Al√©m disso, h√° uma cl√°usula de <code>condition</code> .  Para redis, √© <code>service_started</code> , o que significa que, at√© que o redis seja iniciado, o cont√™iner n√£o tentar√° iniciar o aplicativo da web. <br><br>  Quanto ao banco de dados, sua condi√ß√£o √© <code>service_healthy</code> e a verifica√ß√£o de integridade √© descrita abaixo.  Ou seja, precisamos n√£o apenas iniciar o cont√™iner do docker, mas tamb√©m executar uma determinada verifica√ß√£o de integridade.  Pode ser qualquer l√≥gica personalizada. <br><br>  Por exemplo, usamos o PostgreSQL, que usa a extens√£o PostGIS, e ele precisa de algum tempo para inicializar.  Quando iniciamos o cont√™iner do docker, n√£o podemos trabalhar imediatamente com a extens√£o postgis - precisamos aguardar a inicializa√ß√£o da extens√£o.  Portanto, apenas <code>SELECT PostGIS_Version();</code> consultas <code>SELECT PostGIS_Version();</code> para <code>SELECT PostGIS_Version();</code>  .  At√© que a extens√£o seja inicializada, a solicita√ß√£o gerar√° um erro e, quando a extens√£o for inicializada, come√ßar√° a retornar a vers√£o.  Isso √© muito conveniente e l√≥gico - <strong>primeiro aumentaremos todas as depend√™ncias e depois o aplicativo</strong> . <br><br><h4>  docker-compor 3 </h4><br>  Quando o docker-compose 3 saiu, come√ßamos a us√°-lo. <br><br>  Mas na documenta√ß√£o para isso, um item apareceu na altera√ß√£o da l√≥gica depende_on.  Os desenvolvedores do docker decidiram que uma descri√ß√£o do gr√°fico de depend√™ncia era suficiente.  Isso significa que, ao iniciar o <code>docker-compose run web</code> , o aplicativo em si e o banco de dados do qual depende ser√£o iniciados simultaneamente. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  O pr√≥ximo par√°grafo da documenta√ß√£o diz que depende_on n√£o √© mais uma condi√ß√£o. <br><br>  Portanto, se voc√™ ainda deseja obter a funcionalidade usada na segunda vers√£o, precisar√° levar tudo em suas pr√≥prias m√£os. <br><br>  A p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Controlando pedidos de inicializa√ß√£o</a> oferece v√°rias solu√ß√µes.  A primeira op√ß√£o √© usar <strong>wait-for-it.sh</strong> . <br><br>  Agora o docker-compose.yml parece um pouco diferente: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> √© apenas uma matriz, n√£o h√° condi√ß√µes. <br><br>  Em nossas depend√™ncias, redefinimos o comando, ou seja, no docker-compose voc√™ pode anexar um comando com o qual o cont√™iner do docker √© iniciado. <br><br>  L√° devemos escrever wait-for-it.sh, e outra coisa.  Em vez dos tr√™s pontos no exemplo acima, devemos escrever o que precisamos esperar, bem como o comando original que inicia o cont√™iner do docker. <br><br>  Para fazer isso, voc√™ precisa encontrar o arquivo docker, copiar o comando para redis e col√°-lo, o mesmo vale para o banco de dados.  Uma <strong>desvantagem</strong> enorme √© que a <strong>abstra√ß√£o √© interrompida</strong> - n√£o quero saber qual comando inicia o cont√™iner do docker.  Esses comandos podem n√£o ser triviais, muito complexos, mas n√£o quero me preocupar, s√≥ quero inserir o <code>docker run</code> e √© isso. <br><br>  Pessoalmente, n√£o gosto muito dessa solu√ß√£o, mas t√≠nhamos alguns servi√ßos que funcionam assim. <br><br><h4>  Script na parte superior da janela de encaixe </h4><br>  Ent√£o decidi que havia chegado a hora de " <strong>construir</strong> bicicletas" e tinha o <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Deixe-me dar um exemplo semi-realista: existe o postgres no docker-compose.yml, existe o aplicativo my_service, que depende do postgres, e o SBT, no qual os testes s√£o executados e o que depende do meu servi√ßo. <br><br>  Eu executo o programa n√£o atrav√©s da <code>docker run</code> , mas atrav√©s do script docker-compose-run.sh. <br><br>  Primeiro, ele inicia a depend√™ncia mais profunda primeiro, no meu caso, √© o postgres.  O script inicia a depend√™ncia no modo "daemon", ou seja, n√£o bloqueia o terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  Ent√£o, espero que a condi√ß√£o seja atendida pela fun√ß√£o wait_until.  √â quase o mesmo que wait-for-it.sh, apenas, por assim dizer, em um estilo imperativo.  Enquanto o PostGIS est√° inicializando, o terminal est√° bloqueado, ou seja, o programa tamb√©m espera e, se n√£o esperar, um erro √© gerado e os testes param de funcionar. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Quando o PostGIS for inicializado, continue com a pr√≥xima etapa e fa√ßa o mesmo com o servi√ßo.  Para ele, o teste √© um pouco mais simples: a porta 80 deve ser ligada. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  A √∫ltima etapa √© executar o SBT atrav√©s do comando run, no qual os testes s√£o executados. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Assim, tudo √© gerado na ordem correta, mas manualmente. <br><br>  No final, a fun√ß√£o <code>down</code> √© chamada, que aceita o resultado do comando anterior.  Se for "0", os testes foram aprovados e simplesmente desativamos o docker-composite;  caso contr√°rio, primeiro "cuspimos" os logs para descobrir o que deu errado e, em seguida, desativamos o docker-compondo. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Esse esquema funciona, mas n√£o escala bem.  Cada servi√ßo precisar√° descrever seu docker-compose-run.sh com sua pr√≥pria l√≥gica.  Al√©m disso, a configura√ß√£o de inicializa√ß√£o se estende entre o docker-compose-run.sh e o docker-compose.yml.  Bem, em geral, parece que n√£o estamos usando o docker-compose, mas estamos lutando com suas defici√™ncias. <br><br><h4>  Executando a janela de encaixe a partir do c√≥digo </h4><br>  Quando o esquema anterior foi criado, pensei: se eu j√° tenho tudo na janela de encaixe, por que n√£o execut√°-lo a partir do c√≥digo?  Comecei a procurar uma solu√ß√£o e encontrei v√°rias op√ß√µes. <br><br>  A primeira op√ß√£o √© simplesmente <strong>usar o cliente docker</strong> .  Existem dois principais clientes docker no mundo da JVM: <strong>docker-java</strong> e <strong>spotify docker-client</strong> . <br><br>  O cliente docker permite executar comandos do docker diretamente do c√≥digo usando a API.  Ou seja, em vez de concatenar cadeias para criar comandos como <code>`docker run ...`</code> , voc√™ pode simplesmente formar um comando no c√≥digo e execut√°-lo.  √â muito mais conveniente. <br><br>  Esse m√©todo funciona bem e, com certeza, eles podem fazer tudo, no entanto, esse √© um n√≠vel muito baixo.  Eu teria que criar meu pr√≥prio anal√≥gico de docker-compositing, que √© uma tarefa muito grande. <br><br>  A pr√≥xima op√ß√£o √© a <strong>biblioteca docker-it-scala</strong> , que agrupa esses dois clientes e permite escolher qual back-end usar.  Ela pode executar os cont√™ineres que voc√™ precisa. <br><br>  Mas o menos desta biblioteca √© que ela n√£o possui uma API muito flex√≠vel e n√£o h√° controle do ciclo de vida. <br><br>  Tamb√©m n√£o gostei dessa op√ß√£o, continuei pesquisando e encontrei os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cont√™ineres de teste</a> .  Eu gostaria de lhe contar mais sobre isso. <br><br><h2>  Cont√™ineres de teste </h2><br>  Esse √© um tipo de biblioteca java para iniciar e testar cont√™ineres de docker.  H√° uma fachada Scala, testcontainers-scala.  Fora da caixa, existem v√°rios servi√ßos populares, por exemplo, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Voc√™ pode executar qualquer outro cont√™iner.  A biblioteca possui uma API bastante simples e flex√≠vel, na qual vou me aprofundar mais detalhadamente. <br><br><h3>  Cont√™ineres predefinidos </h3><br>  Ent√£o, como trabalhar com cont√™ineres predefinidos, que est√£o na biblioteca: de fato, tudo √© bem simples, pois os cont√™ineres s√£o representados como objetos: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  Nesse caso, criamos o <code>PostgreSQLContainer</code> , podemos inici√°-lo e come√ßar a trabalhar com ele.  Em seguida, obtemos o <code>jbdcUrl</code> , com o qual voc√™ pode se conectar ao PostgreSQL.  Depois disso, temos o <code>mappedPort</code> . <br><br>  Isso significa que o PostgreSQL se destaca da porta 5432 do docker, e o Testcontainers v√™ essa porta e a atribui automaticamente a alguma porta aleat√≥ria.  Ou seja, a partir dos testes que vemos, por exemplo, 32422. A atribui√ß√£o acontece automaticamente. <br><br><h3>  Cont√™iner personalizado </h3><br>  A seguinte exibi√ß√£o, o chamado cont√™iner personalizado, tamb√©m √© bastante simples: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  H√° um <code>GenericContainer</code> do qual voc√™ precisa herdar e substituir v√°rios campos.  Certifique-se de definir apenas <code>imageName</code> - este √© o nome do cont√™iner que queremos criar. <br><br>  Voc√™ pode definir <code>exposedPorts</code> : aquelas portas que o cont√™iner se destacar√°.  No env, voc√™ pode definir vari√°veis ‚Äã‚Äãde ambiente e tamb√©m definir o <code>command</code> para executar. <br><br>  <code>classpathResourceMapping</code> permite lan√ßar recursos do caminho de classe no cont√™iner do Docker.  Isso √© muito conveniente, por exemplo, se a configura√ß√£o do aplicativo estiver diretamente nos recursos de teste.  Voc√™ simplesmente mapeia o interior, e o aplicativo dentro do docker obt√©m acesso a essa configura√ß√£o. <br><br>  <code>waitStrategy</code> √© uma coisa muito conveniente que estava faltando no docker-compose 3; na verdade, √© o HealthCheck.  Existem v√°rias <code>waitStrategy</code> predefinidas, por exemplo, voc√™ pode esperar at√© que uma liga√ß√£o de porta ocorra ou um m√©todo http espec√≠fico retornar√° 200. Mas voc√™ pode gravar qualquer um dos seus HealthCheck. <br><br>  Como voc√™ escreve o HealthCheck simplesmente no seu c√≥digo, voc√™ pode usar, primeiro, um idioma normal, n√£o o bash, e, segundo, quaisquer bibliotecas dispon√≠veis no seu c√≥digo: se voc√™ deseja criar o HealthCheck personalizado no Cassandra - leve o driver e escreva qualquer HealthCheck. <br><br><h3>  Executando testes </h3><br>  E agora um pouco sobre como executar testes: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Vou falar sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScalaTest</a> , o padr√£o de fato para testes no mundo do Scala. <br><br>  Por exemplo, queremos escrever testes para o Postgres.  Crie um teste <code>PostgresqlSpec</code> e herde-o do <code>ForAllTestContainer</code> .  Essa √© uma caracter√≠stica fornecida pela biblioteca.  Ele iniciar√° os cont√™ineres necess√°rios antes de todos os testes e os interromper√° ap√≥s todos os testes.  Ou voc√™ pode usar o <code>ForeachTestContainer</code> , em seguida, os cont√™ineres iniciam antes de cada teste e param depois de cada um deles. <br><br>  Ent√£o voc√™ precisa redefinir o cont√™iner.  Isso pode ser feito substituindo a propriedade do <code>container</code> .  No meu caso, estou usando o <code>PostgreSQLContainer</code> . <br><br>  Ent√£o escrevemos testes.  No exemplo, eu crio uma conex√£o, recebo jdbcUrl, nome de usu√°rio, senha, escreva testes espec√≠ficos, envie solicita√ß√µes. <br><br>  Normalmente, os testes de integra√ß√£o requerem v√°rios cont√™ineres.  Eu posso cri√°-los usando <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Ou seja, eu crio cont√™ineres, os adiciono a <code>MultipleContainers</code> e os uso como <code>container</code> . <br><br>  O esquema para executar testes com Testcontainers √© o seguinte: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Empurre o c√≥digo no GitLa. </li><li>  O corredor de CI do GitLab lan√ßa o SBT. </li><li>  O SBT executa testes.  Dentro dos testes, nosso aplicativo e depend√™ncias s√£o lan√ßados. </li></ol><br>  As vantagens deste esquema: <br><br><ul><li>  N√£o h√° necessidade de manter um ambiente e depend√™ncias separados, tudo acontece no corredor. </li><li>  Voc√™ pode testar diferentes ramos ao mesmo tempo. </li><li>  Voc√™ pode testar iniciar, parar e reiniciar, porque podemos controlar o ciclo de vida do aplicativo (tudo come√ßa no c√≥digo de teste). </li><li>  Existem HealthChecks flex√≠veis que estavam em falta. </li><li>  N√£o h√° arquivos * .sh no reposit√≥rio, voc√™ pode configurar os testes no aplicativo da maneira mais flex√≠vel poss√≠vel. </li><li>  Gra√ßas ao mapeamento classpathResource, voc√™ pode usar a mesma configura√ß√£o nos testes e no aplicativo. </li><li>  Voc√™ pode configurar testes a partir do c√≥digo. </li><li>  Tudo isso √© executado com a mesma facilidade tanto no IC quanto no local, porque esses s√£o apenas testes que parecem e s√£o executados como testes de unidade, apenas tudo acontece no cont√™iner do docker. </li></ul><br>  Acontece que tudo √© suspeito e bom, mas isso √© apenas √† primeira vista; de fato, encontramos v√°rios problemas. <br><br><h3>  Cont√™ineres dependentes </h3><br>  O primeiro problema que encontramos foram os <strong>cont√™ineres dependentes</strong> .  Digamos que exista algum tipo de teste: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Executa o postgres e o AppContainer.  O appContainer do postgres recebe jdbcUrl, o nome de usu√°rio e a senha da conex√£o.  Em seguida, MultipleContainers √© criado e o pr√≥prio teste √© descrito. <br><br>  Eu executo o programa e vejo um erro: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  O ponto √© que a porta atribu√≠da n√£o pode ser tomada at√© que o cont√™iner seja iniciado.  Por que isso est√° acontecendo? <br><br>  O fato √© que <code>ForAllTestContainer</code> ou <code>ForEachTestContainer</code> iniciam cont√™ineres imediatamente antes dos testes e n√£o no momento em que crio inst√¢ncias de cont√™iner.  Acontece que, no momento em que crio o AppContainer, ainda n√£o tenho o <code>PostgreSQLContainer</code> ativado, o que significa que n√£o consigo obter a porta atribu√≠da e preciso que ela forme <code>jdbcUrl</code> . <br><br>  O problema √© que a ess√™ncia do cont√™iner √© mut√°vel: possui v√°rios estados.  Por exemplo, pode ser desligado e ligado. <br><br>  Como resolver este problema?  O primeiro m√©todo que eu chamaria de "pregui√ßoso". <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  A id√©ia principal √© criar cont√™ineres usando <strong>val pregui√ßoso</strong> .  Ent√£o eles n√£o ser√£o inicializados imediatamente no construtor de teste, mas aguardar√£o a primeira chamada.  Inicializaremos nos <code>afterAll</code> e <code>afterAll</code> , fornecidos pela <code>BeforeAndAfterAll</code> BeforeAndAfterAll do ScalaTest.  No <code>beforeAll</code> cont√™ineres s√£o iniciados e no <code>afterAll</code> , eles s√£o desativados.  Como os cont√™ineres s√£o declarados pregui√ßosos, no momento em que o m√©todo start √© chamado beforeAll, eles ser√£o criados, inicializados e iniciados. <br><br>  No entanto, ainda ocorre um erro que n√£o consigo ingressar no localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Parece que usamos o jdbcUrl, por que o localhost aparece?  Vamos ver como o jdbcUrl funciona: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  √â apenas uma concatena√ß√£o de strings.  Tudo fica claro com constantes, elas n√£o podem quebrar.  <code>getMappedPort</code> deve funcionar, porque j√° o corrigimos.  <code>databaseName</code> √© uma constante codificada.  Mas com <code>getContainerIpAddress</code> mais interessante.  Por nome, podemos assumir que ele deve retornar o endere√ßo IP do cont√™iner.  Mas se voc√™ executar esse c√≥digo, ele sempre retornar√° localhost.  Como se viu, esse m√©todo n√£o se destina √† intera√ß√£o entre cont√™ineres: <code>getContainerIpAddress</code> <strong>fornece intera√ß√£o a partir de testes dentro do cont√™iner</strong> . <br><br>  Recomenda√ß√£o do desenvolvedor de testcontainers: <strong>crie uma rede personalizada para comunica√ß√£o entre cont√™ineres</strong> .  O Docker-compose funciona assim: cria uma rede e resolve tudo por conta pr√≥pria. <br><br>  Ent√£o voc√™ precisa criar uma rede. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Agora temos que configurar manualmente nosso jdbcUrl.  Tamb√©m precisamos ativar nossos cont√™ineres na rede e definir o alias para o PostgreSQLContainer para que ele seja acess√≠vel na rede por algum nome de dom√≠nio.  No final, voc√™ deve se lembrar de "matar" a rede. <br><br>  Finalmente, esse programa funcionar√°. <br><br>  Nas vers√µes recentes do testcontainers-scala, a inicializa√ß√£o lenta do cont√™iner √© suportada imediatamente: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Voc√™ pode usar <code>ForAllTestContainer</code> e <code>MultipleContainers</code> novamente.  No <code>beforeAll</code> n√£o precisa mais <code>beforeAll</code> manualmente <code>beforeAll</code> ordem de in√≠cio.  Agora <code>MultipleContainers</code> pode trabalhar com val lento e execut√°-los na ordem correta, e n√£o faz inicializa√ß√£o estrita imediatamente ap√≥s a cria√ß√£o.  Ao mesmo tempo, as manipula√ß√µes com a rede personalizada e o jdbcUrl tamb√©m precisam ser feitas manualmente. <br><br><h3>  Zombaria </h3><br>  No entanto, ainda existem problemas.  Por exemplo moki.  √Äs vezes, n√£o √© muito conveniente criar algum tipo de depend√™ncia em um cont√™iner de docker.  Usamos o Spark JobServer, que cria tarefas do Spark e controla seu ciclo de vida no Spark.  Usamos dois de seus m√©todos: "create" e "give status". <br><br>  Para executar o Spark JobServer dentro da janela de encaixe.  √â necess√°rio elevar o Spark e, at√© recentemente, ele n√£o possu√≠a um cont√™iner de ancoragem e era necess√°rio mont√°-lo voc√™ mesmo.  Al√©m disso, o Spark JobServer usa o PostgreSQL para armazenar estados.  Como resultado, voc√™ precisa fazer muito trabalho dif√≠cil quando realmente precisa apenas de dois m√©todos com uma API simples. <br><br>  Mas voc√™ pode espiar a implementa√ß√£o do Spark JobServer e criar uma simula√ß√£o que se comporta da mesma maneira, mas n√£o requer as depend√™ncias do Spark JobServer original. <br><br>  Parece com isso (no exemplo, um pseudoc√≥digo simplificado): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    ¬´¬ª    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    ¬´¬ª docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       ‚Äî    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Sum√°rio </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers ‚Äî   ,    . API   ,      . <br><br>     Java-,        .      ‚Äî     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>‚Äî       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>‚Äî   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>‚Äî         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube ‚Äî     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>‚Äî     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag ‚Äî   , ‚Äî       ,        .    ,    latest   . <br><br> <strong><em>‚Äî ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>‚Äî  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , ‚Äî   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deseja mais detalhes sobre os microsservi√ßos e n√£o apenas sobre o Scala - nosso programa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem respostas para v√°rias perguntas. </font><font style="vertical-align: inherit;">Mais interessados ‚Äã‚Äãna arquitetura e nas interconex√µes de suas v√°rias partes - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visite o HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos dias 7 e 8 de novembro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo √© muito saboroso, e n√£o est√° claro o que escolher; em seguida, assine a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em que falamos sobre relat√≥rios e coletamos materiais √∫teis sobre o assunto.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464307/">https://habr.com/ru/post/pt464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464293/index.html">Os ganchos s√£o substitu√≠dos no React Redux?</a></li>
<li><a href="../pt464295/index.html">Exemplos de uso de alguns novos recursos JavaScript</a></li>
<li><a href="../pt464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../pt464303/index.html">Dados de s√©ries temporais em um DBMS relacional. Extens√µes TimescaleDB e PipelineDB for PostgreSQL</a></li>
<li><a href="../pt464305/index.html">Pequeno sim. Desembalagem do microvirtual Firecracker</a></li>
<li><a href="../pt464309/index.html">Bot√£o de chamada DIY. Raspberry Pi, MajorDoMo, Freeswitch e Linphonec</a></li>
<li><a href="../pt464315/index.html">O filme em que havia solo. Pesquisa Yandex e um breve hist√≥rico de pesquisa por significado</a></li>
<li><a href="../pt464317/index.html">Projeto Konbanwa</a></li>
<li><a href="../pt464325/index.html">Como o Scrumban une o melhor das metodologias Kanban e Scrum</a></li>
<li><a href="../pt464327/index.html">Compara√ß√£o do uso de mem√≥ria de diferentes GUIs do kit de ferramentas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>