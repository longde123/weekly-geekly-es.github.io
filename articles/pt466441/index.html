<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧 👃🏻 💊 Código de bugs Python: 10 erros mais comuns que os desenvolvedores cometem 👩🏻‍🎓 🤧 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sobre o Python 
 Python é uma linguagem de programação interpretada, orientada a objetos e de alto nível, com semântica dinâmica. As estruturas de dad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Código de bugs Python: 10 erros mais comuns que os desenvolvedores cometem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  Sobre o Python </h3><br>  Python é uma linguagem de programação interpretada, orientada a objetos e de alto nível, com semântica dinâmica.  As estruturas de dados de alto nível integradas, combinadas com a digitação dinâmica e a ligação dinâmica, o tornam muito atraente para o BRPS (desenvolvimento rápido de ferramentas de aplicativo), bem como para ser usado como uma linguagem de script e conexão para conectar componentes ou serviços existentes.  O Python suporta módulos e pacotes, incentivando a modularidade do programa e a reutilização de código. <br><br><h3>  Sobre este artigo </h3><br>  A simplicidade e a facilidade de dominar essa linguagem podem ser confusas para os desenvolvedores (especialmente aqueles que estão começando a aprender Python), para que você perca de vista algumas sutilezas importantes e subestime o poder da variedade de soluções possíveis usando o Python. <br><br>  Com isso em mente, este artigo apresenta o "top 10" de erros sutis e difíceis de encontrar que até mesmo desenvolvedores avançados de Python podem cometer. <br><a name="habracut"></a><br>
<h3>  Erro nº 1: usar expressões incorretas como valores padrão para argumentos de função </h3><br>  O Python permite que você indique que uma função pode ter argumentos opcionais, definindo um valor padrão para eles.  Isso, é claro, é um recurso muito conveniente da linguagem, mas pode levar a conseqüências desagradáveis ​​se o tipo desse valor for mutável.  Por exemplo, considere a seguinte definição de função: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Um erro comum nesse caso é pensar que o valor de um argumento opcional será definido como o valor padrão sempre que uma função for chamada sem um valor para esse argumento.  No código acima, por exemplo, podemos assumir que, chamando repetidamente a função foo () (ou seja, sem especificar um valor para o argumento bar), ele sempre retornará "baz", pois é assumido que toda vez que foo () é chamado (sem especificando a barra de argumentos), bar é definido como [] (ou seja, uma nova lista vazia). <br><br>  Mas vamos ver o que realmente acontecerá: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Hein?  Por que a função continua a adicionar o valor padrão "baz" à lista existente toda vez que foo () é chamado, em vez de criar uma nova lista a cada vez? <br><br>  A resposta a esta pergunta será uma compreensão mais profunda do que está acontecendo com o Python "sob o capô".  A saber: o valor padrão da função é inicializado apenas uma vez, durante a definição da função.  Portanto, o argumento da barra é inicializado por padrão (ou seja, uma lista vazia) somente quando foo () é definido pela primeira vez, mas as chamadas subseqüentes para foo () (ou seja, sem especificar o argumento da barra) continuarão usando a mesma lista que foi criado para a barra de argumentos no momento da primeira definição da função. <br><br>  Para referência, uma "solução alternativa" comum para esse erro é a seguinte definição: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Erro # 2: uso indevido de variáveis ​​de classe </h3><br>  Considere o seguinte exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Tudo parece estar em ordem. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Sim, tudo estava como o esperado. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Que diabos ?!  Acabamos de mudar o Ax. Por que o Cx também mudou? <br><br>  No Python, as variáveis ​​de classe são tratadas como dicionários e seguem o que geralmente é chamado MRO (Method Resolution Order).  Portanto, no código acima, como o atributo x não é encontrado na classe C, ele será encontrado em suas classes base (apenas A no exemplo acima, embora o Python suporte herança múltipla).  Em outras palavras, C não possui sua própria propriedade x independente de A. Portanto, as referências a Cx são na verdade referências a Ax. Isso causará problemas se esses casos não forem tratados adequadamente.  Portanto, ao aprender Python, preste atenção especial aos atributos da classe e trabalhe com eles. <br><br><h3>  Erro nº 3: parâmetros incorretos para o bloco de exceção </h3><br>  Suponha que você tenha o seguinte trecho de código: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  O problema aqui é que a expressão de exceção não aceita a lista de exceções especificadas dessa maneira.  Em vez disso, no Python 2.x, a expressão “exceto Exceção, e” é usada para vincular a exceção a um segundo parâmetro opcional fornecido (neste caso, e) para disponibilizá-la para uma inspeção adicional.  Como resultado, no código acima, uma exceção IndexError não é capturada pela instrução exceto;  em vez disso, a exceção termina com a ligação a um parâmetro chamado IndexError. <br><br>  A maneira correta de capturar várias exceções com a expressão de exceção é especificar o primeiro parâmetro como uma tupla contendo todas as exceções que você deseja capturar.  Além disso, para obter compatibilidade máxima, use a palavra-chave as, pois essa sintaxe é suportada no Python 2 e no Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Erro # 4: interpretando mal as regras de escopo do Python </h3><br>  O escopo no Python é baseado na regra LEGB, que é uma abreviação de Local (nomes atribuídos de qualquer forma a uma função (def ou lambda) e não declarada global nesta função), Enclosing (nome no escopo local de qualquer função que inclua estaticamente) ( def ou lambda), de interno para externo), Global (nomes atribuídos no nível superior do arquivo do módulo ou executando instruções globais em def dentro do arquivo), Interno (nomes previamente atribuídos no módulo de nome interno: aberto, intervalo, SyntaxError, ...).  Parece bastante simples, certo?  Bem, na verdade, existem algumas sutilezas sobre como isso funciona no Python, o que nos leva ao problema de programação Python geral mais complexo abaixo.  Considere o seguinte exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Qual é o problema? <br><br>  O erro acima ocorre porque quando você atribui uma variável no escopo, o Python automaticamente a considera local para esse escopo e oculta qualquer variável com o mesmo nome em qualquer escopo pai. <br><br>  Assim, muitos ficam surpresos quando recebem UnboundLocalError no código em execução anterior, quando são modificados adicionando um operador de atribuição em algum lugar do corpo da função. <br><br>  Esse recurso é especialmente confuso para os desenvolvedores ao usar listas.  Considere o seguinte exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Hein?  Por que o foo2 trava enquanto o foo1 está funcionando bem? <br><br>  A resposta é a mesma do exemplo anterior, mas, segundo a crença popular, a situação aqui é mais sutil.  foo1 não aplica o operador de atribuição a lst, enquanto foo2 não.  Tendo em mente que lst + = [5] é apenas uma abreviação de lst = lst + [5], vemos que estamos tentando atribuir o valor lst (então o Python assume que está no escopo local).  No entanto, o valor que queremos atribuir ao lst é baseado no próprio lst (novamente, agora é assumido que esteja no escopo local), que ainda não foi determinado.  E temos um erro. <br><br><h3>  Erro # 5: alterando uma lista durante a iteração sobre ela </h3><br>  O problema no seguinte trecho de código deve ser bastante óbvio: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  A remoção de um item de uma lista ou matriz durante a iteração é um problema do Python que é bem conhecido por qualquer desenvolvedor de software experiente.  Mas, embora o exemplo acima possa ser bastante óbvio, até desenvolvedores experientes podem embarcar nesse rake em um código muito mais complexo. <br><br>  Felizmente, o Python inclui vários paradigmas de programação elegantes que, quando usados ​​corretamente, podem levar a uma simplificação e otimização significativa do código.  Uma conseqüência agradável adicional disso é que, no código mais simples, a probabilidade de cair no erro de excluir acidentalmente um item da lista durante a iteração é muito menor.  Um desses paradigmas é o de geradores de lista.  Além disso, entender a operação dos geradores de lista é especialmente útil para evitar esse problema específico, conforme mostrado nesta implementação alternativa do código acima, que funciona perfeitamente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Erro nº 6: mal entendendo como o Python vincula variáveis ​​nos fechamentos </h3><br>  Considere o seguinte exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Você pode esperar a seguinte saída: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Mas na verdade você entende o seguinte: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Surpresa! <br><br>  Isso ocorre devido à ligação tardia no Python, o que significa que os valores das variáveis ​​usadas nos fechamentos são consultados durante a chamada para a função interna.  Assim, no código acima, sempre que qualquer uma das funções retornadas é chamada, o valor de i é pesquisado no escopo circundante durante sua chamada (e nessa época o ciclo já havia sido concluído, portanto, o resultado final já havia sido atribuído - valor 4) . <br><br>  A solução para esse problema comum do Python seria: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Usamos os argumentos padrão aqui para gerar funções anônimas e obter o comportamento desejado.  Alguns chamariam essa solução de elegante.  Alguns são <br>  fino.  Algumas pessoas odeiam essas coisas.  Mas se você é um desenvolvedor de Python, é importante entender. <br><br><h3>  Erro # 7: criando dependências de módulo cíclico </h3><br>  Suponha que você tenha dois arquivos, a.py e b.py, cada um deles importando o outro, da seguinte maneira: <br><br>  No a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  Em b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Primeiro, tente importar a.py: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Funcionou muito bem.  Isso pode surpreendê-lo.  Afinal, os módulos se importam ciclicamente e isso provavelmente deve ser um problema, certo? <br><br>  A resposta é que simplesmente ter importação cíclica de módulos não é, por si só, um problema no Python.  Se o módulo já foi importado, o Python é inteligente o suficiente para não tentar importá-lo novamente.  No entanto, dependendo do ponto em que cada módulo está tentando acessar funções ou variáveis ​​definidas em outro, você pode realmente ter problemas. <br><br>  Portanto, voltando ao nosso exemplo, quando importamos o a.py, não houve problemas ao importar o b.py, pois o b.py não exige que nenhum dos a.py seja definido durante a importação.  A única referência em b.py a a é uma chamada para af ().  Mas essa chamada em g () e nada em a.py ou b.py não chama g ().  Então, tudo funciona bem. <br><br>  Mas o que acontece se tentarmos importar o b.py (sem antes importar o a.py): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh oh  Isso não é bom!  O problema aqui é que, durante o processo de importação do b.py, ele tenta importar o a.py, que por sua vez chama f (), que tenta acessar o bx. Mas o bx ainda não foi definido.  Daí a exceção AttributeError. <br><br>  Pelo menos uma solução para esse problema é bastante trivial.  Basta modificar b.py para importar a.py para g (): <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Agora, quando o importamos, tudo está bem: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Erro # 8: cruzando nomes com nomes de módulos na biblioteca padrão do Python </h3><br>  Um dos encantos do Python são seus muitos módulos que saem da caixa.  Mas, como resultado, se você não seguir conscientemente isso, poderá descobrir que o nome do seu módulo pode ter o mesmo nome que o módulo na biblioteca padrão que acompanha o Python (por exemplo, no seu código, pode haver um módulo com o nome email.py, que entrará em conflito com o módulo de biblioteca padrão com o mesmo nome). <br><br>  Isso pode levar a problemas sérios.  Por exemplo, se algum dos módulos tentar importar a versão do módulo da biblioteca padrão do Python, e você tiver um módulo com o mesmo nome no projeto, que será importado por engano em vez do módulo da biblioteca padrão. <br><br>  Portanto, deve-se tomar cuidado para não usar os mesmos nomes dos módulos da biblioteca padrão do Python.  É muito mais fácil alterar o nome do módulo em seu projeto do que enviar uma solicitação para alterar o nome do módulo na biblioteca padrão e obter aprovação para ele. <br><br><h3>  Erro # 9: falha em levar em consideração as diferenças entre o Python 2 e o Python 3 </h3><br>  Considere o seguinte arquivo foo.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  No Python 2, funcionará bem: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Mas agora vamos ver como funcionará no Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  O que aconteceu aqui?  O "problema" é que, no Python 3, um objeto em um bloco de exceção não está disponível fora dele.  (A razão para isso é que, caso contrário, os objetos nesse bloco serão armazenados na memória até que o coletor de lixo seja iniciado e remova as referências a partir daí). <br><br>  Uma maneira de evitar esse problema é manter a referência ao objeto do bloco de exceção fora desse bloco, para que ele permaneça disponível.  Aqui está a versão do exemplo anterior que usa essa técnica, obtendo assim um código adequado para o Python 2 e o Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  Execute-o no Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Viva! <br><br><h3>  Erro # 10: uso inadequado do método __del__ </h3><br>  Digamos que você tenha um arquivo mod.py como este: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  E você está tentando fazer isso de outro another_mod.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  E obtenha um terrível AttributeError. <br><br>  Porque  Como, conforme relatado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , quando o intérprete é desligado, todas as variáveis ​​globais do módulo têm o valor Nenhum.  Como resultado, no exemplo acima, quando __del__ foi chamado, o nome foo já estava definido como Nenhum. <br><br>  A solução para esta "tarefa com um asterisco" é usar atexit.register ().  Portanto, quando seu programa conclui a execução (ou seja, quando sai normalmente), seus identificadores são excluídos antes que o intérprete conclua seu trabalho. <br><br>  Com isso em mente, a correção para o código mod.py acima pode ser algo como isto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Essa implementação fornece uma maneira simples e confiável de chamar qualquer limpeza necessária após o término normal do programa.  Obviamente, a decisão sobre como lidar com o objeto que está associado ao nome self.myhandle é deixada para fo.cleanup, mas acho que você entende a idéia. <br><br><h3>  Conclusão </h3><br>  Python é uma linguagem poderosa e flexível, com muitos mecanismos e paradigmas que podem melhorar significativamente o desempenho.  No entanto, como em qualquer ferramenta ou idioma de software, com uma compreensão ou avaliação limitada de seus recursos, problemas imprevistos podem surgir durante o desenvolvimento. <br><br>  Uma introdução às nuances do Python abordadas neste artigo ajudará a otimizar o uso da linguagem, evitando alguns erros comuns. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466441/">https://habr.com/ru/post/pt466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466431/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 40. Família padrão 802.1X e protocolo AAA</a></li>
<li><a href="../pt466433/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 41. VLAN nativa do DHCP Snooping e Nondefault</a></li>
<li><a href="../pt466435/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 42. Roteamento Inter-VLAN e SVI</a></li>
<li><a href="../pt466437/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 43. Protocolos de Roteamento Distância do Vetor e Estado do Link</a></li>
<li><a href="../pt466439/index.html">Verifique você mesmo: quantas perguntas você pode responder à ChGK?</a></li>
<li><a href="../pt466443/index.html">ShIoTiny e o mundo: sensores analógicos ou ADCs para os menores</a></li>
<li><a href="../pt466445/index.html">Ataques entre relações de confiança entre domínios</a></li>
<li><a href="../pt466447/index.html">Para que devemos construir uma CDN?</a></li>
<li><a href="../pt466449/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 44. Introdução ao OSPF</a></li>
<li><a href="../pt466451/index.html">Read_You'n não pode jogar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>