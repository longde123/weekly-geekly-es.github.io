<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòæ üèÅ ‚òïÔ∏è Escribir una interfaz de usuario de Snapchat en Swift üßíüèø ü•Ñ üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologo 


 En uno de mis proyectos, necesitaba hacer una interfaz como esa en Snepchat. Cuando una tarjeta con informaci√≥n sale encima de la imagen d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir una interfaz de usuario de Snapchat en Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Prologo </h2><br><p> En uno de mis proyectos, necesitaba hacer una interfaz como esa en Snepchat.  Cuando una tarjeta con informaci√≥n sale encima de la imagen de la c√°mara, reemplaz√°ndola suavemente por un color s√≥lido, y tambi√©n en la direcci√≥n opuesta.  Personalmente, me fascin√≥ especialmente la transici√≥n de la ventana de la c√°mara a la tarjeta lateral, y con gran placer fui a contar formas de resolver este problema. </p><br><p>  A la izquierda hay un ejemplo de Snepchat, a la derecha hay un ejemplo de una aplicaci√≥n que crearemos. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> Probablemente la primera soluci√≥n que se le ocurra es adaptar el <code>UIScrollView</code> , organizar de alguna manera las vistas en √©l, usar la paginaci√≥n, pero, francamente, el desplazamiento est√° pensado para resolver problemas completamente diferentes, recoger animaciones adicionales requiere mucho tiempo y no tiene la flexibilidad necesaria ajustes  Por lo tanto, usarlo para resolver este problema es absolutamente injustificado. </p><br><p>  El desplazamiento entre la ventana de la c√°mara y la pesta√±a lateral es enga√±oso: no es un desplazamiento en absoluto, es una transici√≥n interactiva entre las vistas que pertenecen a diferentes controladores.  Los botones en su parte inferior son pesta√±as normales, haciendo clic en lo que nos arroja entre los controladores. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  De esta manera, Snatch usa su propia versi√≥n de un controlador de navegaci√≥n como <code>UITabBarController</code> con transiciones interactivas personalizadas. </p><br><p>  <code>UIKit</code> incluye dos opciones para los controladores de navegaci√≥n que le permiten personalizar las transiciones: estos son <code>UINavigationController</code> y <code>UITabBarController</code> .  Ambos tienen <code>navigationController(_:interactionControllerFor:)</code> m√©todos <code>navigationController(_:interactionControllerFor:)</code> y <code>tabBarController(_:interactionControllerFor:)</code> en sus delegados, respectivamente, que nos permiten usar nuestra propia animaci√≥n interactiva para la transici√≥n. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabBarController (_: InteractionControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navigationController (_: InteractionControllerFor :)</a> </p><br><p>  Pero no me gustar√≠a estar limitado por la implementaci√≥n de <code>UITabBarController</code> o <code>UINavigationController</code> , especialmente porque no podemos controlar su l√≥gica interna.  Por lo tanto, decid√≠ escribir mi controlador similar, y ahora quiero contar y mostrar lo que sali√≥ de √©l. </p><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  Cree su propio controlador de contenedor, en el que puede cambiar entre controladores secundarios utilizando animaciones interactivas para las transiciones, utilizando el mecanismo est√°ndar en <code>UITabBarController</code> y <code>UINavigationController</code> .  Necesitamos este mecanismo est√°ndar para usar animaciones de transici√≥n listas para usar del tipo <code>UIViewControllerAnimatedTransitioning</code> ya escrito. </p><br><h2 id="podgotovka-proekta">  Preparaci√≥n del proyecto </h2><br><p>  Por lo general, trato de mover los m√≥dulos a marcos separados, para esto creo un nuevo proyecto de aplicaci√≥n y agrego un objetivo adicional de <code>Cocoa Touch Framework</code> all√≠, y luego disperso las fuentes en el proyecto para los objetivos correspondientes.  De esta manera obtengo un marco separado con una aplicaci√≥n de prueba para la depuraci√≥n. </p><br><p>  Crea una <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> ser√° nuestro objetivo. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Haga clic en <code>+</code> para agregar el objetivo. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  Elija <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Llamamos a nuestro marco el nombre apropiado, Xcode selecciona autom√°ticamente el proyecto para nuestro objetivo y ofrece vincular el binario directamente a la aplicaci√≥n.  Estamos de acuerdo </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  No necesitaremos el <code>Main.storyboard</code> y <code>ViewController.swift</code> predeterminados, los eliminaremos. </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  Adem√°s, no olvide eliminar el valor de la <code>Main Interface</code> en el objetivo de la aplicaci√≥n en la pesta√±a <code>General</code> . </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Ahora vamos a <code>AppDelegate.swift</code> y dejamos solo el m√©todo de <code>application</code> de los siguientes contenidos: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Aqu√≠ configuramos nuestro controlador en el lugar principal para que aparezca despu√©s del lanzador. </p><br><p>  Ahora cree este mismo <code>MasterViewController</code> .  Se relacionar√° con la aplicaci√≥n, por lo que es importante elegir el destino correcto al crear el archivo. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  Heredaremos <code>MasterViewController</code> de <code>SnapchatNavigationController</code> , que implementaremos m√°s adelante en el marco.  No olvides especificar la <code>import</code> nuestro framework.  No proporciono el c√≥digo del controlador completo aqu√≠, las omisiones se muestran con puntos suspensivos <code>...</code> , coloqu√© la aplicaci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> , all√≠ puede ver todos los detalles.  En este controlador, solo nos interesa el m√©todo <code>viewDidLoad()</code> , que inicializa el controlador de fondo con la c√°mara + un controlador transparente (ventana principal) + el controlador que contiene la tarjeta de salida. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  ¬øQu√© est√° pasando aqu√≠?  Creamos un controlador con una c√°mara y lo configuramos en segundo plano utilizando el m√©todo <code>setBackground</code> de <code>SnapchatNavigationController</code> .  Este controlador contiene una imagen estirada para toda la vista desde la c√°mara.  Luego creamos un controlador transparente vac√≠o y lo agregamos a la matriz, simplemente pasa la imagen de la c√°mara a trav√©s de √©l, podemos colocar controles sobre √©l, crear otro controlador transparente, agregarle un desplazamiento, agregar una vista con contenido dentro del desplazamiento, agregar un segundo controlador a matriz y establezca esta matriz utilizando el m√©todo especial <code>setViewControllers</code> del <code>SnapchatNavigationController</code> padre. </p><br><p>  No olvide agregar una solicitud para usar la c√°mara en <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  En este sentido, consideramos que la aplicaci√≥n de prueba est√° lista y pasamos a la parte m√°s interesante: la implementaci√≥n del marco. </p><br><h2 id="struktura-roditelskogo-kontrollera">  Estructura del controlador principal </h2><br><p>  Primero, cree un <code>SnapchatNavigationController</code> vac√≠o, es importante elegir el objetivo adecuado para √©l.  Si todo se hizo correctamente, entonces la aplicaci√≥n deber√≠a estar construida.  Este estado del proyecto se puede descargar por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencia</a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  Ahora agregue los componentes internos en los que consistir√° el controlador.  No traigo todo el c√≥digo aqu√≠, me concentro solo en puntos importantes. </p><br><p>  Establecemos las variables para almacenar la matriz de controladores secundarios.  Ahora establecemos r√≠gidamente su cantidad requerida: 2 piezas.  En el futuro, ser√° posible expandir la l√≥gica del controlador para usar con cualquier n√∫mero de controladores.  Tambi√©n establecemos una variable para almacenar el controlador actual que se muestra. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Crea las vistas.  Necesitamos una vista para el fondo, una vista con el efecto que queremos aplicar al fondo al cambiar el controlador.  Tambi√©n tenemos un contenedor de vista para el controlador secundario actual y un indicador de vista que le indicar√° al usuario c√≥mo trabajar con la navegaci√≥n. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  En el siguiente bloque, establecemos dos variables, <code>swipeAnimator</code> es responsable de la animaci√≥n, <code>swipeInteractor</code> es responsable de la interacci√≥n (la capacidad de controlar el progreso de la animaci√≥n), debemos inicializarla durante el arranque del controlador, por lo que forzamos el desenvolvimiento. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  Tambi√©n establecemos la transformaci√≥n para el indicador.  Cambiamos el indicador por el ancho del contenedor + doble desplazamiento desde el borde + el ancho del propio indicador para que el indicador est√© en el extremo opuesto del contenedor.  El ancho del contenedor se conocer√° durante la aplicaci√≥n, por lo que la variable se calcula sobre la marcha. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  Mientras cargamos el controlador, nos asignamos a la animaci√≥n (implementaremos el protocolo correspondiente a continuaci√≥n), inicializamos el interactor en funci√≥n de nuestra animaci√≥n, cuyo progreso controlar√°.  Tambi√©n lo nombramos como delegado.  El delegado responder√° al comienzo del gesto del usuario y comenzar√° la animaci√≥n o cancelar√° dependiendo del estado del controlador.  Luego agregamos todas las vistas a la principal y llamamos a <code>setupViews()</code> , que establece las restricciones. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  A continuaci√≥n, pasamos a la l√≥gica de instalar y quitar controladores secundarios en un contenedor.  Todo aqu√≠ es simple como en la documentaci√≥n de Apple.  Utilizamos los m√©todos prescritos para este tipo de operaci√≥n. </p><br><p>  <code>addChildViewController(vc)</code> : agrega un controlador secundario al actual. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> : agrega la vista del controlador a la jerarqu√≠a de vistas. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> : <code>vc.view.frame = contentViewContainer.bounds</code> la vista a todo el contenedor.  Como usamos marcos aqu√≠ en lugar del dise√±o autom√°tico, necesitamos cambiar sus tama√±os cada vez que cambia el tama√±o del controlador, omitiremos esta l√≥gica y asumiremos que el contenedor no cambiar√° el tama√±o de la aplicaci√≥n mientras se ejecuta. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> : pone fin a la operaci√≥n de agregar un controlador secundario. </p><br><p>  <code>swipeInteractor.wireTo</code> : <code>swipeInteractor.wireTo</code> el controlador actual a los gestos del usuario.  M√°s adelante analizaremos este m√©todo. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Hay dos m√©todos m√°s cuyo c√≥digo no dar√© aqu√≠: <code>setViewControllers</code> y <code>setBackground</code> .  En el m√©todo <code>setViewControllers</code> simplemente configuramos la matriz de controladores secundarios en la variable correspondiente de nuestro controlador y llamamos a <code>addChild</code> para mostrar uno de ellos en la vista.  En el m√©todo <code>setBackground</code> hacemos lo mismo que en <code>addChild</code> , solo para el controlador de fondo. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  L√≥gica de animaci√≥n de controlador de contenedor </h2><br><p>  Total, la base de nuestro controlador principal es: </p><br><ul><li>  UIView dividido en dos tipos <br><ul><li>  Contenedores </li><li>  Ordinario </li></ul></li><li>  Lista de ni√±os UIViewController </li><li>  Un objeto de control de animaci√≥n de <code>swipeAnimator</code> tipo <code>AnimatedTransitioning</code> </li><li>  Un objeto que controla el curso interactivo de una animaci√≥n de <code>CustomSwipeInteractor</code> de tipo <code>CustomSwipeInteractor</code> </li><li>  Delegar animaci√≥n interactiva </li><li>  Implementaci√≥n del Protocolo de Animaci√≥n </li></ul><br><p>  Ahora analizaremos los dos √∫ltimos puntos, luego pasaremos a la implementaci√≥n de <code>AnimatedTransitioning</code> y <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  Delegar animaci√≥n interactiva </h3><br><p>  El delegado consta de un solo <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> m√©todo <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> , que informa al controlador sobre el comienzo del gesto y su direcci√≥n.  En respuesta, espera informaci√≥n sobre si la animaci√≥n puede considerarse iniciada. </p><br><p>  Como delegado, verificamos el orden actual de los controladores para comprender si podemos comenzar la animaci√≥n en la direcci√≥n dada, y si todo est√° bien, comenzamos el m√©todo de <code>transition</code> , con los par√°metros: el controlador desde el cual nos estamos moviendo, el controlador al que nos estamos moviendo, la direcci√≥n del movimiento, la bandera de interactividad (en caso de <code>false</code> , se inicia una animaci√≥n de transici√≥n de tiempo fijo). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Examinemos de inmediato el cuerpo del m√©todo de <code>transition</code> .  En primer lugar, creamos el contexto de animaci√≥n para la animaci√≥n <code>CustomControllerContext</code> .  Tambi√©n analizaremos esta clase un poco m√°s tarde; implementa el protocolo <code>UIViewControllerContextTransitioning</code> .  En el caso de <code>UINavigationController</code> y <code>UITabBarController</code> el sistema crea autom√°ticamente <code>UITabBarController</code> instancia de la implementaci√≥n de este protocolo y su l√≥gica est√° oculta para nosotros, necesitamos crear la nuestra. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Luego simplemente llamamos animaci√≥n fija o interactiva.  En el futuro, ser√° posible colgar uno fijo en las pesta√±as de los botones de navegaci√≥n entre controladores, en este ejemplo no haremos esto. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Protocolo de animaci√≥n </h3><br><p>  <code>TransitionAnimation</code> protocolo de animaci√≥n <code>TransitionAnimation</code> consta de 4 m√©todos: </p><br><p>  <code>addTo</code> es un m√©todo dise√±ado para crear la estructura correcta de vistas secundarias en el contenedor, de modo que la vista anterior se superponga con la nueva seg√∫n la idea de la animaci√≥n. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> es el m√©todo llamado antes de la animaci√≥n para preparar la vista. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> : la animaci√≥n en s√≠ misma. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> : las acciones necesarias despu√©s de la finalizaci√≥n de la animaci√≥n. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  No consideraremos la implementaci√≥n utilizada, todo es bastante transparente all√≠, iremos directamente a las tres clases principales, gracias a las cuales tiene lugar la animaci√≥n. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  El contexto de la animaci√≥n.  Para describir su funci√≥n, nos referimos a la ayuda del protocolo <code>UIViewControllerContextTransitioning</code> : </p><br><blockquote>  Un objeto de contexto encapsula informaci√≥n sobre las vistas y los controladores de vista involucrados en la transici√≥n.  Tambi√©n contiene detalles sobre c√≥mo ejecutar la transici√≥n. </blockquote><p>  Lo m√°s interesante es la prohibici√≥n de la adaptaci√≥n de este protocolo: </p><br><blockquote>  No adopte este protocolo en sus propias clases, ni debe crear directamente objetos que adopten este protocolo. </blockquote><p>  Pero realmente lo necesitamos para ejecutar el motor de animaci√≥n est√°ndar, por lo que lo adaptamos de todos modos.  Casi no tiene l√≥gica; solo almacena el estado.  Por lo tanto, ni siquiera lo traer√© aqu√≠.  Puedes verlo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p><br><p>  Funciona muy bien en animaciones de tiempo fijo.  Pero cuando se usa para animaciones interactivas, surge un problema: <code>UIPercentDrivenInteractiveTransition</code> invoca un m√©todo no documentado en el contexto.  La √∫nica soluci√≥n correcta en esta situaci√≥n es adaptar otro protocolo: <code>UIViewControllerInteractiveTransitioning</code> para usar su propio contexto. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Aqu√≠ est√°: el coraz√≥n del proyecto, permitiendo que existan animaciones interactivas en controladores de contenedores personalizados.  Vamos a tomarlo en orden. </p><br><p>  La clase se inicializa con un par√°metro del tipo <code>UIViewControllerAnimatedTransitioning</code> , este es el protocolo est√°ndar para animar la transici√≥n entre controladores.  De esta manera, podemos usar cualquiera de las animaciones ya escritas junto con nuestra clase. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  La interfaz p√∫blica es bastante simple, cuatro m√©todos, cuya funcionalidad deber√≠a ser obvia. </p><br><p>  Solo hay que tener en cuenta el momento en que comienza la animaci√≥n, tomamos la vista principal del contenedor y establecemos la velocidad de la capa en 0, para que podamos controlar el progreso de la animaci√≥n manualmente. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Ahora pasamos al bloque l√≥gico privado de nuestra clase. </p><br><p>  <code>setPercentComplete</code> establece el desplazamiento de tiempo del progreso de la animaci√≥n para la capa de supervista, calculando el valor a partir del porcentaje de finalizaci√≥n y duraci√≥n de la animaci√≥n. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  Se llama a <code>completeTransition</code> cuando el usuario ha detenido su gesto.  Aqu√≠ creamos una instancia de la clase <code>CADisplayLink</code> , que nos permitir√° completar autom√°ticamente la animaci√≥n desde el punto en que el usuario ya no controla su progreso.  <code>displayLink</code> nuestro <code>displayLink</code> al <code>run loop</code> para que el sistema llame a nuestro selector cada vez que necesite mostrar un nuevo marco en la pantalla del dispositivo. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  En nuestro selector, calculamos y establecemos el desplazamiento temporal del progreso de la animaci√≥n, como lo hicimos antes durante el gesto del usuario, o completamos la animaci√≥n cuando llega a su punto inicial o final. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Al finalizar la animaci√≥n, <code>displayLink</code> nuestro <code>displayLink</code> , devolvemos la velocidad de la capa, y si la animaci√≥n no se ha cancelado, es decir, ha alcanzado su fotograma final, calculamos el momento en que debe comenzar la animaci√≥n de la capa.  Puede obtener m√°s informaci√≥n sobre esto en la Gu√≠a de programaci√≥n de animaci√≥n principal, o en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta respuesta</a> a stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  La √∫ltima clase que a√∫n no hemos examinado es la implementaci√≥n del protocolo <code>UIViewControllerAnimatedTransitioning</code> , en el que controlamos el orden de ejecuci√≥n de los m√©todos de protocolo de nuestra animaci√≥n <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>finalize</code> .  Todo aqu√≠ es bastante prosaico, vale la pena se√±alar solo el uso de <code>UIViewPropertyAnimator</code> para realizar animaciones en lugar del m√°s t√≠pico <code>UIView.animate(withDuration:animations:)</code> .  Esto se hace para que sea posible controlar a√∫n m√°s el progreso de la animaci√≥n, y si se cancela, devu√©lvala a su posici√≥n <code>finishAnimation(at: .start)</code> llamando a <code>finishAnimation(at: .start)</code> , lo que evita el parpadeo innecesario del cuadro final de la animaci√≥n en la pantalla. </p><br><h2 id="epilog">  Ep√≠logo </h2><br><p>  Hemos creado una demostraci√≥n funcional de una interfaz similar a la de Snapchat.  En mi versi√≥n, configur√© las constantes para que haya campos a la derecha y a la izquierda de la tarjeta, adem√°s, dej√© la c√°mara en la vista de fondo para crear un efecto detr√°s de la tarjeta.  Esto se hace √∫nicamente para demostrar las capacidades de este enfoque, c√≥mo afectar√° el rendimiento del dispositivo y no verifiqu√© la carga de la bater√≠a. </p><br><p>   ‚Äî        ,    -  ,          .      ,    -    . </p><br><p>      GitHub  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p>   ,   ,  ,  ! </p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii">   </h2><br><p>        : </p><br><ol><li><p>  Custom Container View Controller Transitions,  Joachim Bondo. </p><br><p>        Objective C.          Swift. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek √Östr√∂m </p><br><p>               ,   Objective C,           Swift. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415795/">https://habr.com/ru/post/es415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415783/index.html">Los discos estelares nos revelan los secretos de la aparici√≥n de planetas</a></li>
<li><a href="../es415785/index.html">SpaceX env√≠a robot de inteligencia artificial a ISS</a></li>
<li><a href="../es415789/index.html">Algoritmos de patentes para programas de computadora</a></li>
<li><a href="../es415791/index.html">Optimizaci√≥n de contratos inteligentes. C√≥mo los tipos de solidez afectan los costos de transacci√≥n</a></li>
<li><a href="../es415793/index.html">Gu√≠a completa de pedidos pendientes de dominio</a></li>
<li><a href="../es415797/index.html">Expresiones regulares + programaci√≥n l√≥gica. Cual es el resultado?</a></li>
<li><a href="../es415801/index.html">Google: nuestra IA de "tel√©fono" no es lo suficientemente buena como para ser peligrosa</a></li>
<li><a href="../es415805/index.html">Modificaci√≥n del m√≥dulo de barrera GSM Doorhan para control de Internet</a></li>
<li><a href="../es415809/index.html">C√≥mo usar soja, requirejs, backbone js en complementos para Atlassian Jira</a></li>
<li><a href="../es415811/index.html">AI, curso pr√°ctico. Descripci√≥n general de las redes neuronales para la clasificaci√≥n de im√°genes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>