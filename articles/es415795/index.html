<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😾 🏁 ☕️ Escribir una interfaz de usuario de Snapchat en Swift 🧒🏿 🥄 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologo 


 En uno de mis proyectos, necesitaba hacer una interfaz como esa en Snepchat. Cuando una tarjeta con información sale encima de la imagen d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir una interfaz de usuario de Snapchat en Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Prologo </h2><br><p> En uno de mis proyectos, necesitaba hacer una interfaz como esa en Snepchat.  Cuando una tarjeta con información sale encima de la imagen de la cámara, reemplazándola suavemente por un color sólido, y también en la dirección opuesta.  Personalmente, me fascinó especialmente la transición de la ventana de la cámara a la tarjeta lateral, y con gran placer fui a contar formas de resolver este problema. </p><br><p>  A la izquierda hay un ejemplo de Snepchat, a la derecha hay un ejemplo de una aplicación que crearemos. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> Probablemente la primera solución que se le ocurra es adaptar el <code>UIScrollView</code> , organizar de alguna manera las vistas en él, usar la paginación, pero, francamente, el desplazamiento está pensado para resolver problemas completamente diferentes, recoger animaciones adicionales requiere mucho tiempo y no tiene la flexibilidad necesaria ajustes  Por lo tanto, usarlo para resolver este problema es absolutamente injustificado. </p><br><p>  El desplazamiento entre la ventana de la cámara y la pestaña lateral es engañoso: no es un desplazamiento en absoluto, es una transición interactiva entre las vistas que pertenecen a diferentes controladores.  Los botones en su parte inferior son pestañas normales, haciendo clic en lo que nos arroja entre los controladores. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  De esta manera, Snatch usa su propia versión de un controlador de navegación como <code>UITabBarController</code> con transiciones interactivas personalizadas. </p><br><p>  <code>UIKit</code> incluye dos opciones para los controladores de navegación que le permiten personalizar las transiciones: estos son <code>UINavigationController</code> y <code>UITabBarController</code> .  Ambos tienen <code>navigationController(_:interactionControllerFor:)</code> métodos <code>navigationController(_:interactionControllerFor:)</code> y <code>tabBarController(_:interactionControllerFor:)</code> en sus delegados, respectivamente, que nos permiten usar nuestra propia animación interactiva para la transición. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabBarController (_: InteractionControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navigationController (_: InteractionControllerFor :)</a> </p><br><p>  Pero no me gustaría estar limitado por la implementación de <code>UITabBarController</code> o <code>UINavigationController</code> , especialmente porque no podemos controlar su lógica interna.  Por lo tanto, decidí escribir mi controlador similar, y ahora quiero contar y mostrar lo que salió de él. </p><br><h2 id="postanovka-zadachi">  Declaración del problema. </h2><br><p>  Cree su propio controlador de contenedor, en el que puede cambiar entre controladores secundarios utilizando animaciones interactivas para las transiciones, utilizando el mecanismo estándar en <code>UITabBarController</code> y <code>UINavigationController</code> .  Necesitamos este mecanismo estándar para usar animaciones de transición listas para usar del tipo <code>UIViewControllerAnimatedTransitioning</code> ya escrito. </p><br><h2 id="podgotovka-proekta">  Preparación del proyecto </h2><br><p>  Por lo general, trato de mover los módulos a marcos separados, para esto creo un nuevo proyecto de aplicación y agrego un objetivo adicional de <code>Cocoa Touch Framework</code> allí, y luego disperso las fuentes en el proyecto para los objetivos correspondientes.  De esta manera obtengo un marco separado con una aplicación de prueba para la depuración. </p><br><p>  Crea una <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> será nuestro objetivo. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Haga clic en <code>+</code> para agregar el objetivo. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  Elija <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Llamamos a nuestro marco el nombre apropiado, Xcode selecciona automáticamente el proyecto para nuestro objetivo y ofrece vincular el binario directamente a la aplicación.  Estamos de acuerdo </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  No necesitaremos el <code>Main.storyboard</code> y <code>ViewController.swift</code> predeterminados, los eliminaremos. </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  Además, no olvide eliminar el valor de la <code>Main Interface</code> en el objetivo de la aplicación en la pestaña <code>General</code> . </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Ahora vamos a <code>AppDelegate.swift</code> y dejamos solo el método de <code>application</code> de los siguientes contenidos: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Aquí configuramos nuestro controlador en el lugar principal para que aparezca después del lanzador. </p><br><p>  Ahora cree este mismo <code>MasterViewController</code> .  Se relacionará con la aplicación, por lo que es importante elegir el destino correcto al crear el archivo. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  Heredaremos <code>MasterViewController</code> de <code>SnapchatNavigationController</code> , que implementaremos más adelante en el marco.  No olvides especificar la <code>import</code> nuestro framework.  No proporciono el código del controlador completo aquí, las omisiones se muestran con puntos suspensivos <code>...</code> , coloqué la aplicación en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> , allí puede ver todos los detalles.  En este controlador, solo nos interesa el método <code>viewDidLoad()</code> , que inicializa el controlador de fondo con la cámara + un controlador transparente (ventana principal) + el controlador que contiene la tarjeta de salida. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  ¿Qué está pasando aquí?  Creamos un controlador con una cámara y lo configuramos en segundo plano utilizando el método <code>setBackground</code> de <code>SnapchatNavigationController</code> .  Este controlador contiene una imagen estirada para toda la vista desde la cámara.  Luego creamos un controlador transparente vacío y lo agregamos a la matriz, simplemente pasa la imagen de la cámara a través de él, podemos colocar controles sobre él, crear otro controlador transparente, agregarle un desplazamiento, agregar una vista con contenido dentro del desplazamiento, agregar un segundo controlador a matriz y establezca esta matriz utilizando el método especial <code>setViewControllers</code> del <code>SnapchatNavigationController</code> padre. </p><br><p>  No olvide agregar una solicitud para usar la cámara en <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  En este sentido, consideramos que la aplicación de prueba está lista y pasamos a la parte más interesante: la implementación del marco. </p><br><h2 id="struktura-roditelskogo-kontrollera">  Estructura del controlador principal </h2><br><p>  Primero, cree un <code>SnapchatNavigationController</code> vacío, es importante elegir el objetivo adecuado para él.  Si todo se hizo correctamente, entonces la aplicación debería estar construida.  Este estado del proyecto se puede descargar por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencia</a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  Ahora agregue los componentes internos en los que consistirá el controlador.  No traigo todo el código aquí, me concentro solo en puntos importantes. </p><br><p>  Establecemos las variables para almacenar la matriz de controladores secundarios.  Ahora establecemos rígidamente su cantidad requerida: 2 piezas.  En el futuro, será posible expandir la lógica del controlador para usar con cualquier número de controladores.  También establecemos una variable para almacenar el controlador actual que se muestra. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Crea las vistas.  Necesitamos una vista para el fondo, una vista con el efecto que queremos aplicar al fondo al cambiar el controlador.  También tenemos un contenedor de vista para el controlador secundario actual y un indicador de vista que le indicará al usuario cómo trabajar con la navegación. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  En el siguiente bloque, establecemos dos variables, <code>swipeAnimator</code> es responsable de la animación, <code>swipeInteractor</code> es responsable de la interacción (la capacidad de controlar el progreso de la animación), debemos inicializarla durante el arranque del controlador, por lo que forzamos el desenvolvimiento. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  También establecemos la transformación para el indicador.  Cambiamos el indicador por el ancho del contenedor + doble desplazamiento desde el borde + el ancho del propio indicador para que el indicador esté en el extremo opuesto del contenedor.  El ancho del contenedor se conocerá durante la aplicación, por lo que la variable se calcula sobre la marcha. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  Mientras cargamos el controlador, nos asignamos a la animación (implementaremos el protocolo correspondiente a continuación), inicializamos el interactor en función de nuestra animación, cuyo progreso controlará.  También lo nombramos como delegado.  El delegado responderá al comienzo del gesto del usuario y comenzará la animación o cancelará dependiendo del estado del controlador.  Luego agregamos todas las vistas a la principal y llamamos a <code>setupViews()</code> , que establece las restricciones. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  A continuación, pasamos a la lógica de instalar y quitar controladores secundarios en un contenedor.  Todo aquí es simple como en la documentación de Apple.  Utilizamos los métodos prescritos para este tipo de operación. </p><br><p>  <code>addChildViewController(vc)</code> : agrega un controlador secundario al actual. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> : agrega la vista del controlador a la jerarquía de vistas. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> : <code>vc.view.frame = contentViewContainer.bounds</code> la vista a todo el contenedor.  Como usamos marcos aquí en lugar del diseño automático, necesitamos cambiar sus tamaños cada vez que cambia el tamaño del controlador, omitiremos esta lógica y asumiremos que el contenedor no cambiará el tamaño de la aplicación mientras se ejecuta. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> : pone fin a la operación de agregar un controlador secundario. </p><br><p>  <code>swipeInteractor.wireTo</code> : <code>swipeInteractor.wireTo</code> el controlador actual a los gestos del usuario.  Más adelante analizaremos este método. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Hay dos métodos más cuyo código no daré aquí: <code>setViewControllers</code> y <code>setBackground</code> .  En el método <code>setViewControllers</code> simplemente configuramos la matriz de controladores secundarios en la variable correspondiente de nuestro controlador y llamamos a <code>addChild</code> para mostrar uno de ellos en la vista.  En el método <code>setBackground</code> hacemos lo mismo que en <code>addChild</code> , solo para el controlador de fondo. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  Lógica de animación de controlador de contenedor </h2><br><p>  Total, la base de nuestro controlador principal es: </p><br><ul><li>  UIView dividido en dos tipos <br><ul><li>  Contenedores </li><li>  Ordinario </li></ul></li><li>  Lista de niños UIViewController </li><li>  Un objeto de control de animación de <code>swipeAnimator</code> tipo <code>AnimatedTransitioning</code> </li><li>  Un objeto que controla el curso interactivo de una animación de <code>CustomSwipeInteractor</code> de tipo <code>CustomSwipeInteractor</code> </li><li>  Delegar animación interactiva </li><li>  Implementación del Protocolo de Animación </li></ul><br><p>  Ahora analizaremos los dos últimos puntos, luego pasaremos a la implementación de <code>AnimatedTransitioning</code> y <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  Delegar animación interactiva </h3><br><p>  El delegado consta de un solo <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> método <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> , que informa al controlador sobre el comienzo del gesto y su dirección.  En respuesta, espera información sobre si la animación puede considerarse iniciada. </p><br><p>  Como delegado, verificamos el orden actual de los controladores para comprender si podemos comenzar la animación en la dirección dada, y si todo está bien, comenzamos el método de <code>transition</code> , con los parámetros: el controlador desde el cual nos estamos moviendo, el controlador al que nos estamos moviendo, la dirección del movimiento, la bandera de interactividad (en caso de <code>false</code> , se inicia una animación de transición de tiempo fijo). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Examinemos de inmediato el cuerpo del método de <code>transition</code> .  En primer lugar, creamos el contexto de animación para la animación <code>CustomControllerContext</code> .  También analizaremos esta clase un poco más tarde; implementa el protocolo <code>UIViewControllerContextTransitioning</code> .  En el caso de <code>UINavigationController</code> y <code>UITabBarController</code> el sistema crea automáticamente <code>UITabBarController</code> instancia de la implementación de este protocolo y su lógica está oculta para nosotros, necesitamos crear la nuestra. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Luego simplemente llamamos animación fija o interactiva.  En el futuro, será posible colgar uno fijo en las pestañas de los botones de navegación entre controladores, en este ejemplo no haremos esto. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Protocolo de animación </h3><br><p>  <code>TransitionAnimation</code> protocolo de animación <code>TransitionAnimation</code> consta de 4 métodos: </p><br><p>  <code>addTo</code> es un método diseñado para crear la estructura correcta de vistas secundarias en el contenedor, de modo que la vista anterior se superponga con la nueva según la idea de la animación. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> es el método llamado antes de la animación para preparar la vista. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> : la animación en sí misma. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> : las acciones necesarias después de la finalización de la animación. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  No consideraremos la implementación utilizada, todo es bastante transparente allí, iremos directamente a las tres clases principales, gracias a las cuales tiene lugar la animación. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  El contexto de la animación.  Para describir su función, nos referimos a la ayuda del protocolo <code>UIViewControllerContextTransitioning</code> : </p><br><blockquote>  Un objeto de contexto encapsula información sobre las vistas y los controladores de vista involucrados en la transición.  También contiene detalles sobre cómo ejecutar la transición. </blockquote><p>  Lo más interesante es la prohibición de la adaptación de este protocolo: </p><br><blockquote>  No adopte este protocolo en sus propias clases, ni debe crear directamente objetos que adopten este protocolo. </blockquote><p>  Pero realmente lo necesitamos para ejecutar el motor de animación estándar, por lo que lo adaptamos de todos modos.  Casi no tiene lógica; solo almacena el estado.  Por lo tanto, ni siquiera lo traeré aquí.  Puedes verlo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p><br><p>  Funciona muy bien en animaciones de tiempo fijo.  Pero cuando se usa para animaciones interactivas, surge un problema: <code>UIPercentDrivenInteractiveTransition</code> invoca un método no documentado en el contexto.  La única solución correcta en esta situación es adaptar otro protocolo: <code>UIViewControllerInteractiveTransitioning</code> para usar su propio contexto. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Aquí está: el corazón del proyecto, permitiendo que existan animaciones interactivas en controladores de contenedores personalizados.  Vamos a tomarlo en orden. </p><br><p>  La clase se inicializa con un parámetro del tipo <code>UIViewControllerAnimatedTransitioning</code> , este es el protocolo estándar para animar la transición entre controladores.  De esta manera, podemos usar cualquiera de las animaciones ya escritas junto con nuestra clase. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  La interfaz pública es bastante simple, cuatro métodos, cuya funcionalidad debería ser obvia. </p><br><p>  Solo hay que tener en cuenta el momento en que comienza la animación, tomamos la vista principal del contenedor y establecemos la velocidad de la capa en 0, para que podamos controlar el progreso de la animación manualmente. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Ahora pasamos al bloque lógico privado de nuestra clase. </p><br><p>  <code>setPercentComplete</code> establece el desplazamiento de tiempo del progreso de la animación para la capa de supervista, calculando el valor a partir del porcentaje de finalización y duración de la animación. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  Se llama a <code>completeTransition</code> cuando el usuario ha detenido su gesto.  Aquí creamos una instancia de la clase <code>CADisplayLink</code> , que nos permitirá completar automáticamente la animación desde el punto en que el usuario ya no controla su progreso.  <code>displayLink</code> nuestro <code>displayLink</code> al <code>run loop</code> para que el sistema llame a nuestro selector cada vez que necesite mostrar un nuevo marco en la pantalla del dispositivo. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  En nuestro selector, calculamos y establecemos el desplazamiento temporal del progreso de la animación, como lo hicimos antes durante el gesto del usuario, o completamos la animación cuando llega a su punto inicial o final. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Al finalizar la animación, <code>displayLink</code> nuestro <code>displayLink</code> , devolvemos la velocidad de la capa, y si la animación no se ha cancelado, es decir, ha alcanzado su fotograma final, calculamos el momento en que debe comenzar la animación de la capa.  Puede obtener más información sobre esto en la Guía de programación de animación principal, o en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta respuesta</a> a stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  La última clase que aún no hemos examinado es la implementación del protocolo <code>UIViewControllerAnimatedTransitioning</code> , en el que controlamos el orden de ejecución de los métodos de protocolo de nuestra animación <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>finalize</code> .  Todo aquí es bastante prosaico, vale la pena señalar solo el uso de <code>UIViewPropertyAnimator</code> para realizar animaciones en lugar del más típico <code>UIView.animate(withDuration:animations:)</code> .  Esto se hace para que sea posible controlar aún más el progreso de la animación, y si se cancela, devuélvala a su posición <code>finishAnimation(at: .start)</code> llamando a <code>finishAnimation(at: .start)</code> , lo que evita el parpadeo innecesario del cuadro final de la animación en la pantalla. </p><br><h2 id="epilog">  Epílogo </h2><br><p>  Hemos creado una demostración funcional de una interfaz similar a la de Snapchat.  En mi versión, configuré las constantes para que haya campos a la derecha y a la izquierda de la tarjeta, además, dejé la cámara en la vista de fondo para crear un efecto detrás de la tarjeta.  Esto se hace únicamente para demostrar las capacidades de este enfoque, cómo afectará el rendimiento del dispositivo y no verifiqué la carga de la batería. </p><br><p>   —        ,    -  ,          .      ,    -    . </p><br><p>      GitHub  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p>   ,   ,  ,  ! </p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii">   </h2><br><p>        : </p><br><ol><li><p>  Custom Container View Controller Transitions,  Joachim Bondo. </p><br><p>        Objective C.          Swift. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek Åström </p><br><p>               ,   Objective C,           Swift. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415795/">https://habr.com/ru/post/es415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415783/index.html">Los discos estelares nos revelan los secretos de la aparición de planetas</a></li>
<li><a href="../es415785/index.html">SpaceX envía robot de inteligencia artificial a ISS</a></li>
<li><a href="../es415789/index.html">Algoritmos de patentes para programas de computadora</a></li>
<li><a href="../es415791/index.html">Optimización de contratos inteligentes. Cómo los tipos de solidez afectan los costos de transacción</a></li>
<li><a href="../es415793/index.html">Guía completa de pedidos pendientes de dominio</a></li>
<li><a href="../es415797/index.html">Expresiones regulares + programación lógica. Cual es el resultado?</a></li>
<li><a href="../es415801/index.html">Google: nuestra IA de "teléfono" no es lo suficientemente buena como para ser peligrosa</a></li>
<li><a href="../es415805/index.html">Modificación del módulo de barrera GSM Doorhan para control de Internet</a></li>
<li><a href="../es415809/index.html">Cómo usar soja, requirejs, backbone js en complementos para Atlassian Jira</a></li>
<li><a href="../es415811/index.html">AI, curso práctico. Descripción general de las redes neuronales para la clasificación de imágenes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>