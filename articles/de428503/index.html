<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 🕹️ 🎂 Übersicht über die Referenzvektor-Methode (SVM) des Algorithmus für maschinelles Lernen 👨‍👨‍👦 🏖️ 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 


 In diesem Artikel werden wir verschiedene Aspekte von SVM untersuchen: 



- theoretische Komponente von SVM; 
- wie der Algorithmus bei S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Übersicht über die Referenzvektor-Methode (SVM) des Algorithmus für maschinelles Lernen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428503/"><h2>  Vorwort </h2><br><img src="https://habrastorage.org/webt/eg/fk/rq/egfkrqshjcqqzkc7ktnnyyx9iuy.jpeg"><br><br>  In diesem Artikel werden wir verschiedene Aspekte von SVM untersuchen: <br><br><ul><li>  theoretische Komponente von SVM; </li><li>  wie der Algorithmus bei Stichproben funktioniert, die nicht linear in Klassen unterteilt werden können; </li><li>  Python-Beispiel und Implementierung des Algorithmus in der SciKit Learn-Bibliothek. </li></ul><a name="habracut"></a><br>  In den folgenden Artikeln werde ich versuchen, über die mathematische Komponente dieses Algorithmus zu sprechen. <br><br>  Wie Sie wissen, werden maschinelle Lernaufgaben in zwei Hauptkategorien unterteilt - Klassifizierung und Regression.  Abhängig davon, mit welcher dieser Aufgaben wir konfrontiert sind und welchen Datensatz wir für diese Aufgabe haben, wählen wir den zu verwendenden Algorithmus aus. <br><br>  Die Support Vector Machines-Methode oder SVM (von den englischen Support Vector Machines) ist ein linearer Algorithmus, der bei Klassifizierungs- und Regressionsproblemen verwendet wird.  Dieser Algorithmus ist in der Praxis weit verbreitet und kann sowohl lineare als auch nichtlineare Probleme lösen.  Das Wesen der „Maschinen“ von Unterstützungsvektoren ist einfach: Der Algorithmus erstellt eine Linie oder Hyperebene, die die Daten in Klassen unterteilt. <br><br><h4>  Theorie </h4><br>  Die Hauptaufgabe des Algorithmus besteht darin, die korrekteste Linie oder Hyperebene zu finden und die Daten in zwei Klassen zu unterteilen.  SVM ist ein Algorithmus, der Daten am Eingang empfängt und eine solche Trennlinie zurückgibt. <br><br>  Betrachten Sie das folgende Beispiel.  Angenommen, wir haben einen Datensatz und möchten die roten Quadrate von den blauen Kreisen klassifizieren und trennen (sagen wir positiv und negativ).  Das Hauptziel dieser Aufgabe wird es sein, die „ideale“ Linie zu finden, die diese beiden Klassen trennt. <br><br><img src="https://habrastorage.org/webt/lj/e4/oy/lje4oybbp_pbe_slxkvhm6yqaoy.png"><br><br>  Suchen Sie die perfekte Linie oder Hyperebene, die den Datensatz in blaue und rote Klassen unterteilt. <br><br>  Auf den ersten Blick ist es nicht so schwierig, oder? <br><br>  Aber wie Sie sehen, gibt es keine einzige Linie, die ein solches Problem lösen könnte.  Wir können unendlich viele Zeilen aufnehmen, die diese beiden Klassen trennen können.  Wie genau findet SVM die „ideale“ Linie und was ist in ihrem Verständnis „ideal“? <br><br>  Schauen Sie sich das folgende Beispiel an und überlegen Sie, welche der beiden Linien (gelb oder grün) die beiden Klassen am besten trennt und zur Beschreibung des „Ideals“ passt. <br><br><img src="https://habrastorage.org/webt/w4/_f/kz/w4_fkz5krspejxz1o73l1yjnidy.png"><br><br>  Welche Zeile trennt den Datensatz Ihrer Meinung nach besser? <br><br>  Wenn Sie die gelbe Linie gewählt haben, gratuliere ich Ihnen: Dies ist die Linie, die der Algorithmus wählen würde.  In diesem Beispiel können wir intuitiv verstehen, dass die gelbe Linie die beiden Klassen besser trennt und entsprechend klassifiziert als die grüne. <br><br>  Bei der grünen Linie befindet sie sich zu nahe an der roten Klasse.  Trotz der Tatsache, dass sie alle Objekte des aktuellen Datensatzes korrekt klassifiziert hat, wird eine solche Zeile nicht verallgemeinert - sie verhält sich nicht so gut wie ein unbekannter Datensatz.  Die Aufgabe, eine verallgemeinerte Trennung zwischen zwei Klassen zu finden, ist eine der Hauptaufgaben beim maschinellen Lernen. <br><br><h4>  Wie SVM die beste Linie findet </h4><br>  Der SVM-Algorithmus ist so konzipiert, dass er nach Punkten im Diagramm sucht, die sich direkt an der nächstgelegenen Trennlinie befinden.  Diese Punkte werden Referenzvektoren genannt.  Dann berechnet der Algorithmus den Abstand zwischen den Stützvektoren und der Teilungsebene.  Dies ist der Abstand, der als Lücke bezeichnet wird.  Das Hauptziel des Algorithmus ist die Maximierung des Abstandes.  Die beste Hyperebene wird als Hyperebene betrachtet, für die diese Lücke so groß wie möglich ist. <br><br><img src="https://habrastorage.org/webt/ps/iy/he/psiyhexemtrhnqukbvmvaqzafvi.png"><br><br>  Ziemlich einfach, oder?  Betrachten Sie das folgende Beispiel mit einem komplexeren Datensatz, der nicht linear geteilt werden kann. <br><br><img src="https://habrastorage.org/webt/jh/5v/bx/jh5vbxwn7vfzyzeuxibxpleejyk.png"><br><br>  Offensichtlich kann dieser Datensatz nicht linear geteilt werden.  Wir können keine gerade Linie zeichnen, die diese Daten klassifizieren würde.  Dieser Datensatz kann jedoch linear geteilt werden, indem eine zusätzliche Dimension hinzugefügt wird, die wir als Z-Achse bezeichnen. Stellen Sie sich vor, die Koordinaten auf der Z-Achse werden durch die folgende Einschränkung reguliert: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>z</mi><mo>=</mo><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow><mo>+</mo><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.717ex" height="2.419ex" viewBox="0 -780.1 4614.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-7A" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-3D" x="746" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-78" x="1802" y="0"></use><g transform="translate(2375,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-2B" x="2856" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-79" x="3857" y="0"></use><g transform="translate(4354,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>z</mi><mo>=</mo><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow><mo>+</mo><mi>y</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> z = x² + y² </script></p><br>  Somit wird die Ordinate Z vom Quadrat des Abstandes des Punktes zum Anfang der Achse dargestellt. <br>  Unten sehen Sie eine Visualisierung desselben Datensatzes auf der Z-Achse. <br><br><img src="https://habrastorage.org/webt/vd/nj/ce/vdnjce7p5csbhfp12tkaj6t-4-s.png"><br><br>  Jetzt können die Daten linear aufgeteilt werden.  Angenommen, die Magenta-Linie trennt die Daten z = k, wobei k eine Konstante ist.  Wenn <p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>z</mi><mo>=</mo><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow><mo>+</mo><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.717ex" height="2.419ex" viewBox="0 -780.1 4614.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-7A" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-3D" x="746" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-78" x="1802" y="0"></use><g transform="translate(2375,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-2B" x="2856" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-79" x="3857" y="0"></use><g transform="translate(4354,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>z</mi><mo>=</mo><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow><mo>+</mo><mi>y</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> z = x² + y² </script></p>  dann <p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>k</mi><mo>=</mo><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow><mo>+</mo><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xB2;</mo></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.84ex" height="2.419ex" viewBox="0 -780.1 4667.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-6B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-3D" x="799" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-78" x="1855" y="0"></use><g transform="translate(2428,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMAIN-2B" x="2909" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/428503/&amp;usg=ALkJrhhKXGsXJCs4upDPhwXNzjGOPcunhw#MJMATHI-79" x="3910" y="0"></use><g transform="translate(4407,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">²</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>k</mi><mo>=</mo><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow><mo>+</mo><mi>y</mi><mrow class="MJX-TeXAtom-ORD"><mo>²</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> k = x² + y² </script></p>  - Kreisformel.  Auf diese Weise können wir unseren linearen Teiler mithilfe dieser Transformation auf die ursprüngliche Anzahl der Probendimensionen zurückprojizieren. <br><br><img src="https://habrastorage.org/webt/we/nu/zn/wenuznqe4e7n4isscmunomrwzfw.png"><br><br>  Infolgedessen können wir einen nichtlinearen Datensatz klassifizieren, indem wir ihm eine zusätzliche Dimension hinzufügen und ihn dann mithilfe der mathematischen Transformation wieder in seine ursprüngliche Form bringen.  Nicht bei allen Datensätzen ist es jedoch genauso einfach, eine solche Transformation in Gang zu setzen.  Glücklicherweise löst die Implementierung dieses Algorithmus in der sklearn-Bibliothek dieses Problem für uns. <br><br><h4>  Hyperebene </h4><br>  Nachdem wir uns mit der Logik des Algorithmus vertraut gemacht haben, fahren wir mit der formalen Definition einer Hyperebene fort <br><br>  Eine Hyperebene ist eine n-1-dimensionale Unterebene in einem n-dimensionalen euklidischen Raum, der den Raum in zwei separate Teile unterteilt. <br><br>  Stellen Sie sich zum Beispiel vor, dass unsere Linie als eindimensionaler euklidischer Raum dargestellt wird (d. H. Unser Datensatz liegt auf einer geraden Linie).  Wählen Sie einen Punkt auf dieser Linie.  Dieser Punkt teilt den Datensatz, in unserem Fall die Linie, in zwei Teile.  Die Linie hat einen Takt und der Punkt hat 0 Takte.  Daher ist ein Punkt eine Hyperebene einer Linie. <br><br>  Für den zweidimensionalen Datensatz, den wir zuvor getroffen haben, war die Trennlinie dieselbe Hyperebene.  Einfach ausgedrückt, für einen n-dimensionalen Raum gibt es eine n-1-dimensionale Hyperebene, die diesen Raum in zwei Teile teilt. <br><br>  CODE <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np X = np.array([[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>], [<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]]) y = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>])</code> </pre> <br>  Punkte werden als Array von X und die Klassen, zu denen sie gehören, als Array von y dargestellt. <br>  Jetzt werden wir unser Modell mit diesem Beispiel trainieren.  In diesem Beispiel habe ich den linearen Parameter des „Kernels“ des Klassifikators (Kernels) festgelegt. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.svm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SVC clf = SVC(kernel=<span class="hljs-string"><span class="hljs-string">'linear'</span></span>) clf = SVC.fit(X, y)</code> </pre><br>  Klassenvorhersage eines neuen Objekts <br><br><pre> <code class="python hljs">prediction = clf.predict([[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>]])</code> </pre> <br><h4>  Parametereinstellung </h4><br>  Parameter sind die Argumente, die Sie beim Erstellen des Klassifikators übergeben.  Im Folgenden habe ich einige der wichtigsten benutzerdefinierten SVM-Einstellungen angegeben: <br><br>  <b>"C"</b> <br><br>  Dieser Parameter hilft dabei, diese feine Linie zwischen „Glätte“ und der Genauigkeit der Klassifizierung von Objekten in der Trainingsprobe anzupassen.  Je höher der C-Wert ist, desto mehr Objekte im Trainingssatz werden korrekt klassifiziert. <br><br><img src="https://habrastorage.org/webt/rq/01/6s/rq016soikp4qfockp86li66s5mq.png"><br><br>  In diesem Beispiel gibt es mehrere Entscheidungsschwellen, die wir für diese bestimmte Stichprobe definieren können.  Achten Sie auf die direkte Entscheidungsschwelle (in der Tabelle als grüne Linie dargestellt).  Es ist ganz einfach und aus diesem Grund wurden mehrere Objekte falsch klassifiziert.  Diese falsch klassifizierten Punkte werden in den Daten als Ausreißer bezeichnet. <br><br>  Wir können die Parameter auch so einstellen, dass wir am Ende eine stärker gekrümmte Linie (hellblaue Entscheidungsschwelle) erhalten, die absolut alle Trainingsmusterdaten korrekt klassifiziert.  In diesem Fall sind die Chancen, dass unser Modell in der Lage sein wird, neue Daten zu verallgemeinern und gleich gute Ergebnisse zu erzielen, natürlich katastrophal gering.  Wenn Sie also versuchen, beim Training des Modells Genauigkeit zu erreichen, sollten Sie etwas Gleichmäßigeres und Direkteres anstreben.  Je höher die C-Zahl ist, desto stärker ist die Hyperebene in Ihrem Modell verwickelt, aber desto höher ist die Anzahl der korrekt klassifizierten Objekte im Trainingssatz.  Daher ist es wichtig, die Modellparameter für einen bestimmten Datensatz zu „verdrehen“, um eine Umschulung zu vermeiden und gleichzeitig eine hohe Genauigkeit zu erzielen. <br><br>  <b>Gamma</b> <br><br>  In der offiziellen Dokumentation der SciKit Learn-Bibliothek heißt es, dass das Gamma bestimmt, inwieweit jedes der Elemente im Datensatz einen Einfluss auf die Bestimmung der „idealen Linie“ hat.  Je niedriger das Gamma, desto mehr Elemente, auch diejenigen, die weit genug von der Trennlinie entfernt sind, nehmen an der Auswahl dieser Linie teil.  Wenn das Gamma hoch ist, "verlässt" sich der Algorithmus nur auf die Elemente, die der Linie selbst am nächsten liegen. <br>  Wenn der Gammapegel zu hoch eingestellt ist, nehmen nur die Elemente, die der Linie am nächsten liegen, am Entscheidungsprozess an der Position der Linie teil.  Dies hilft, Ausreißer in den Daten zu ignorieren.  Der SVM-Algorithmus ist so konzipiert, dass die Punkte, die am nächsten beieinander liegen, bei einer Entscheidung mehr Gewicht haben.  Mit den richtigen Einstellungen für "C" und "Gamma" kann jedoch ein optimales Ergebnis erzielt werden, das eine linearere Hyperebene erzeugt, die Ausreißer ignoriert und daher allgemeiner ist. <br><br><h4>  Fazit </h4><br>  Ich hoffe aufrichtig, dass dieser Artikel Ihnen geholfen hat, die Essenz der Arbeit von SVM oder der Referenzvektormethode zu verstehen.  Ich erwarte von Ihnen Kommentare und Ratschläge.  In nachfolgenden Veröffentlichungen werde ich über die mathematische Komponente von SVM und Optimierungsprobleme sprechen. <br><br>  Quellen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle SVM-Dokumentation in SciKit Learn</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://towardsdatascience.com/">TowardsDataScience Blog</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siraj Raval: Unterstützen Sie Vektormaschinen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in das maschinelle Lernen Udacity SVM: Gammakursvideo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia: SVM</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428503/">https://habr.com/ru/post/de428503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428493/index.html">Git subrepo</a></li>
<li><a href="../de428495/index.html">Wie ich 13 Jahre lang einen Fußballsimulator gemacht habe</a></li>
<li><a href="../de428497/index.html">Noolite SUF-1-300 Custom Wireless Dimmer</a></li>
<li><a href="../de428499/index.html">Gruselige blaue Riesen können die Geheimnisse der Sternentwicklung enthüllen</a></li>
<li><a href="../de428501/index.html">DartUP: Die erste russischsprachige Konferenz über Dart und Flutter am 1. Dezember in St. Petersburg</a></li>
<li><a href="../de428505/index.html">Erhalten von Links zu Audio ohne VKApi</a></li>
<li><a href="../de428507/index.html">Wir schreiben einen Bot-Chat für VKontakte auf Python mit Longpoll</a></li>
<li><a href="../de428509/index.html">Wie H & M versucht, sich mit KI und Big Data zu retten</a></li>
<li><a href="../de428511/index.html">Wasserstoffenergie: Der Beginn eines langen Weges</a></li>
<li><a href="../de428513/index.html">500 Laserpointer an einem Ort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>