<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèª üë´ üëáüèº Reconhecimento de fontes de luz em mapas ambientais üñáÔ∏è ‚Ñ¢Ô∏è ü§ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo apresenta uma implementa√ß√£o em Python do algoritmo para reconhecer fontes de luz em mapas do ambiente (LDR ou HDR) usando uma proje√ß√£o equ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconhecimento de fontes de luz em mapas ambientais</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458598/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png" alt="imagem"></div><br>  Este artigo apresenta uma implementa√ß√£o em Python do algoritmo para reconhecer fontes de luz em mapas do ambiente (LDR ou HDR) usando uma proje√ß√£o equiretangular.  No entanto, depois de fazer pequenas altera√ß√µes, ele tamb√©m pode ser usado com imagens de fundo simples ou mapas c√∫bicos.  Exemplos da poss√≠vel aplica√ß√£o do algoritmo: programas de rastreamento de raios nos quais √© necess√°rio reconhecer fontes de luz prim√°rias para emitir raios a partir delas;  em renderizadores rasterizados, pode ser usado para projetar sombras usando um mapa do ambiente;  al√©m disso, o algoritmo tamb√©m pode ser usado em programas de elimina√ß√£o de destaque, por exemplo, em RA. <br><br>  O algoritmo consiste nas seguintes etapas: <br><br><ol><li>  Diminua a resolu√ß√£o da imagem original, por exemplo, para 1024. </li><li>  Converta a imagem em brilho (lumin√¢ncia), se necess√°rio, com desfoque de imagem. </li><li>  Aplica√ß√£o do m√©todo quase-Monte Carlo. </li><li>  Transforma√ß√£o de coordenadas esf√©ricas em coordenadas equidistantes. </li><li>  Filtrando amostras com base no brilho de um vizinho. </li><li>  Classifique as amostras com base no brilho. </li><li>  Filtrando amostras com base na m√©trica euclidiana. </li><li>  Mesclando amostras usando o algoritmo de Bresenham. </li><li>  C√°lculo da posi√ß√£o do cluster de ilumina√ß√£o com base em seu brilho. </li></ol><br>  Existem muitos algoritmos para reduzir a resolu√ß√£o das imagens.  A filtragem bilinear √© a mais r√°pida ou f√°cil de implementar e, al√©m disso, √© mais adequada na maioria dos casos.  Para converter o brilho nas imagens LDR e HDR, voc√™ pode usar a f√≥rmula padr√£o: <br><br><pre><code class="python hljs">lum = img[:, :, <span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">0.2126</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">0.7152</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">0.0722</span></span></code> </pre> <br>  Al√©m disso, voc√™ pode aplicar um leve desfoque na imagem do brilho, por exemplo, 1-2 pixels para uma imagem com uma resolu√ß√£o de 1024, para eliminar todos os detalhes de alta frequ√™ncia (em particular, causados ‚Äã‚Äãpor uma diminui√ß√£o na resolu√ß√£o). <br><a name="habracut"></a><br><h3>  Proje√ß√£o Equidistante </h3><br>  A proje√ß√£o mais comum em mapas ambientais √© a proje√ß√£o equidistante <sup>3</sup> .  Meu algoritmo pode trabalhar com outras proje√ß√µes, por exemplo, com mapas panor√¢micos e c√∫bicos, no entanto, no artigo, consideraremos apenas uma proje√ß√£o igualmente espa√ßada.  Primeiro voc√™ precisa normalizar as coordenadas da imagem: <br><br><pre> <code class="python hljs">pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = x / width pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = y / height</code> </pre> <br>  Precisamos converter de e para coordenadas cartesianas usando coordenadas esf√©ricas, ou seja,  Œ∏ e œÜ, onde Œ∏ = x * 2œÄ e œÜ = y * œÄ. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereToEquirectangular</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> invAngles = (<span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) xy = (math.atan2(pos[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos[<span class="hljs-number"><span class="hljs-number">0</span></span>]), math.asin(pos[<span class="hljs-number"><span class="hljs-number">2</span></span>])) xy = (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">0</span></span>], xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equirectangularToSphere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> angles = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) thetaPhi = (pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) thetaPhi = (thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">0</span></span>], thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) length = math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><h3>  Hammersley Sampling </h3><br>  O pr√≥ximo passo ser√° aplicar o m√©todo quase-Monte Carlo, por exemplo, a amostragem de Hammersley <sup>2</sup> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f9/b07/70f/4f9b0770f72e69ede59e56a25258343d.png"></div><br>  Voc√™ pode usar outros m√©todos de amostragem, como Holton <sup>4</sup> , mas Hammersley √© mais r√°pido e fornece uma boa distribui√ß√£o de amostras pela esfera.  Holton seria uma boa escolha para amostras de avi√£o se uma imagem simples for usada em vez do mapa do ambiente.  Um requisito obrigat√≥rio para a amostragem de Hammersley √© a invers√£o das ra√≠zes (linha) de van der Corpute, para obter mais detalhes, consulte os links <sup>2</sup> .  Aqui est√° sua r√°pida implementa√ß√£o: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vdcSequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> bits = (bits &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (bits &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xAAAAAAAA</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xCCCCCCCC</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xF0F0F0F0</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float(bits) * <span class="hljs-number"><span class="hljs-number">2.3283064365386963e-10</span></span> <span class="hljs-comment"><span class="hljs-comment"># / 0x100000000 def hammersleySequence(i, N): return (float(i) / float(N), vdcSequence(i))</span></span></code> </pre> <br>  Em seguida, usamos sobreposi√ß√£o uniforme na esfera: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span> phi = v * <span class="hljs-number"><span class="hljs-number">2.0</span></span> * PI cosTheta = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * u - <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment"># map to -1,1 sinTheta = math.sqrt(1.0 - cosTheta * cosTheta); return (math.cos(phi) * sinTheta, math.sin(phi) * sinTheta, cosTheta)</span></span></code> </pre> <br>  Para amostrar Hammersley, usamos um n√∫mero fixo de amostras, dependendo da resolu√ß√£o da imagem, e convertemos de coordenadas esf√©ricas em cartesiana e depois em equidistante: <br><br><pre> <code class="python hljs"> samplesMultiplier = <span class="hljs-number"><span class="hljs-number">0.006</span></span> samples = int(samplesMultiplier * width * height) samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos[0] * width, imagePos[1] * height]</span></span></code> </pre> <br>  Isso nos dar√° uma boa distribui√ß√£o de amostras que ser√£o verificadas quanto √† presen√ßa de fontes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/0a6/470/aa80a64703ef6e38cd0b73f9b02a5852.png"></div><br><h3>  Filtrando fontes de luz </h3><br>  Na primeira etapa da filtragem, ignoramos todas as amostras que n√£o excedem o limite de brilho (para cart√µes HDR, pode ser maior) e, em seguida, classificamos todas as amostras pelo brilho: <br><br><pre> <code class="python hljs"> localSize = int(float(<span class="hljs-number"><span class="hljs-number">12</span></span>) * (width / <span class="hljs-number"><span class="hljs-number">1024.0</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span> samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos [0] * width, imagePos [1] * height] sample = Sample(luminance, imagePos , xyz) luminanceThreshold = 0.8 #do a neighbour search for the maximum luminance nLum = computeNeighborLuminance(lum, width, height, sample.imagePos, localSize) if nLum &gt; luminanceThreshold: samplesList.append(sample) samplesList = sorted(samplesList, key=lambda obj: obj.luminance, reverse=True)</span></span></code> </pre> <br>  A pr√≥xima passagem realizar√° a filtragem com base na m√©trica euclidiana e na dist√¢ncia limite entre os pixels (dependendo da resolu√ß√£o da imagem) - essa √© uma estrutura de dados espaciais que pode ser usada para se livrar da complexidade O (N <sup>2</sup> ): <br><br><pre> <code class="python hljs"> euclideanThreshold = int(float(euclideanThresholdPixel) * (width / <span class="hljs-number"><span class="hljs-number">2048.0</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># filter based euclidian distance filteredCount = len(samplesList) localIndices = np.empty(filteredCount); localIndices.fill(-1) for i in range(0, filteredCount): cpos = samplesList[i].pos if localIndices[i] == -1: localIndices[i] = i for j in range(0, filteredCount): if i != j and localIndices[j] == -1 and distance2d(cpos, samplesList[j].pos) &lt; euclideanThreshold: localIndices[j] = i</span></span></code> </pre> <br>  As amostras resultantes passam pelo est√°gio de fus√£o para reduzir ainda mais o n√∫mero de fontes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/152/e1e/d39152e1e587c40c3ed29888faf02120.png"></div><br><h3>  Mesclando fontes de luz </h3><br>  No √∫ltimo est√°gio, √© realizada a mesclagem de amostras pertencentes ao mesmo cluster de ilumina√ß√£o.  Para fazer isso, podemos usar o algoritmo de Bresenham e come√ßar com as amostras com o brilho mais alto, porque elas j√° est√£o ordenadas.  Quando encontramos uma fonte de luz que satisfaz o teste de Bresenham, usamos sua posi√ß√£o para alterar a posi√ß√£o da fonte com base no peso da corrida: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># apply bresenham check and compute position of the light clusters lights = [] finalIndices = np.empty(filteredCount); finalIndices.fill(-1) for i in localIndices: sample = samplesList[i] startPos = sample.pos if finalIndices[i] == -1: finalIndices[i] = i light = Light() light.originalPos = np.array(sample.pos) # position of the local maxima light.worldPos = np.array(sample.worldPos) light.pos = np.array(sample.pos) light.luminance = sample.luminance for j in localIndices: if i != j and finalIndices[j] == -1: endPos = samplesList[j].pos if bresenhamCheck(lum, width, height, startPos[0], startPos[1], endPos[0], endPos[1]): finalIndices[j] = i # compute final position of the light source sampleWeight = samplesList[j].luminance / sample.luminance light.pos = light.pos + np.array(endPos) * sampleWeight light.pos = light.pos / (1.0 + sampleWeight) imagePos = light.pos * np.array([1.0 / width, 1.0 / height) light.worldPos = equirectangularToSphere(imagePos) lights.append(light)</span></span></code> </pre> <br>  A fun√ß√£o Bresenham verifica se h√° uma linha cont√≠nua com o mesmo brilho.  Se o delta no pixel atual exceder um determinado limite, a verifica√ß√£o falhar√°: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bresenhamCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lum, imageSize, x0, y0, x1, y1)</span></span></span><span class="hljs-function">:</span></span> dX = int(x1 - x0) stepX = int((dX &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dX = abs(dX) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> dY = int(y1 - y0) stepY = int((dY &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dY = abs(dY) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> luminanceThreshold = <span class="hljs-number"><span class="hljs-number">0.15</span></span> prevLum = lum[x0][y0] sumLum = <span class="hljs-number"><span class="hljs-number">0.0</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt;= dY): <span class="hljs-comment"><span class="hljs-comment"># delta may go below zero delta = int (dY - (dX &gt;&gt; 1)) while (x0 != x1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepX &gt; 0))): delta -= dX y0 += stepY delta += dY x0 += stepX sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 else: # delta may go below zero delta = int(dX - (dY &gt;&gt; 1)) while (y0 != y1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepY &gt; 0))): delta -= dY x0 += stepX delta += dX y0 += stepY sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 return 1</span></span></code> </pre> <br>  Deve-se notar que, se necess√°rio, melhorias podem ser feitas no teste de Bresenham, o que levar√° a uma melhor fus√£o das amostras, por exemplo, pode levar em considera√ß√£o a transfer√™ncia horizontal de fontes de luz localizadas nas bordas da imagem.  Al√©m disso, a fun√ß√£o pode ser facilmente expandida para aproximar a √°rea das fontes de luz.  Outra melhoria: voc√™ pode adicionar um limite de dist√¢ncia para n√£o combinar amostras muito distantes.  Resultados Finais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/4a8/fd9/4224a8fd98cec4203235bb4678ee6826.png"></div><br>  Azul indica o m√°ximo local dos clusters de ilumina√ß√£o, azul indica as posi√ß√µes finais das fontes de luz e vermelho indica amostras que fazem parte do mesmo cluster de ilumina√ß√£o e s√£o conectadas por linhas. <br><br>  Outros exemplos de resultados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png"></div><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detec√ß√£o de fontes de luz em fotografias digitais por Maciej Laskowski</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pontos de Hammersley no Hemisf√©rio por Holger Dammertz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Proje√ß√£o Equiretangular por Paul Reed</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Amostragem com Hammersley e Halton Points por Tien-Tsin Wong</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458598/">https://habr.com/ru/post/pt458598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458572/index.html">Anatoly Slyusar: ‚ÄúO per√≠odo do computador da UE nos permitiu treinar programadores de sistemas e aplicados‚Äù</a></li>
<li><a href="../pt458574/index.html">Como passar de desenvolvedor para l√≠der de equipe e conviver com ele ainda mais</a></li>
<li><a href="../pt458576/index.html">Gerenciamento e localiza√ß√£o de texto em um aplicativo Web</a></li>
<li><a href="../pt458594/index.html">N√£o se esque√ßa de aumentar a chance de uma resposta ao cliente usando uma solicita√ß√£o repetida no balanceamento L7</a></li>
<li><a href="../pt458596/index.html">Petty little joy # 6: OpenAI Gym - jogue jogos e controle de rob√¥s</a></li>
<li><a href="../pt458600/index.html">O que s√£o bicicletas el√©tricas (revis√£o em grupo em duas partes de cinco modelos de dois fabricantes), parte 1</a></li>
<li><a href="../pt458602/index.html">Como perfuramos o grande firewall chin√™s (parte 1)</a></li>
<li><a href="../pt458604/index.html">Por que os dois maiores fabricantes de eletr√¥nicos uniram for√ßas em um novo projeto de GPU</a></li>
<li><a href="../pt458606/index.html">Execute o OpenVPN no Docker em 2 segundos</a></li>
<li><a href="../pt458608/index.html">Ferramentas de desenvolvedor do Node.js. Fila de tarefas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>