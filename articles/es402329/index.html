<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÖ ü§û üë∞üèæ Memo. AVR Buzic üë©üèΩ‚Äçüöí üóìÔ∏è ‚¨áÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esencia 
 Ya he creado varios dispositivos electr√≥nicos para pasatiempos diferentes, y tengo una caracter√≠stica extra√±a: si hay un emisor de sonido pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memo. AVR Buzic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402329/"><img src="https://habrastorage.org/files/a62/a7b/0f9/a62a7b0f93e34b378c415b8d4b1873bb.jpg"><br><h3>  Esencia </h3><br>  Ya he creado varios dispositivos electr√≥nicos para pasatiempos diferentes, y tengo una caracter√≠stica extra√±a: si hay un emisor de sonido piezoel√©ctrico (zumbador) en el tablero, despu√©s de terminar el trabajo principal del proyecto, empiezo a sufrir tonter√≠as y hago que toque varias melod√≠as (tanto como sea posible) )  Es especialmente √∫til incluir una melod√≠a al final de un largo proceso para llamar la atenci√≥n.  Por ejemplo, lo us√© cuando constru√≠ una c√°mara de exposici√≥n improvisada para iluminar la fotorresistencia, etc. <br><br>  Pero cuando comenc√© a buscar ejemplos de generaci√≥n de frecuencia para AVR en la red, por alguna raz√≥n me encontr√© con proyectos monstruosos o insuficientemente concisos que implementan la generaci√≥n de frecuencia de sonido de una manera puramente program√°tica.  Y luego decid√≠ resolverlo yo mismo ... <br><a name="habracut"></a><br><h3>  Digresi√≥n l√≠rica </h3><br>  Mi hobby incluye la creaci√≥n de varios dispositivos en microcontroladores, porque esto no se cruza con mi profesor.  actividad (desarrollo de software), me considero un autodidacta absoluto, y en electr√≥nica no es demasiado fuerte.  De hecho, prefiero los microcontroladores PIC, pero sucedi√≥ que acumul√© una cierta cantidad de microcontroladores Atmel AVR (ahora Microchip).  Inmediatamente haga una reserva de que nunca tuve AVR en mis manos, es decir  Este es mi primer proyecto en Atmel MCU, a saber, Atmega48pa.  El proyecto en s√≠ lleva a cabo una carga √∫til, pero aqu√≠ describir√© solo una parte de ella relacionada con la generaci√≥n de frecuencias de sonido.  La prueba para generar frecuencias la llam√© "buzic", como abreviatura de la m√∫sica del timbre.  S√≠, casi lo olvido: en Habr hay un usuario con el apodo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">buzic</a> , quer√≠a advertir de inmediato que este memo no se aplica a √©l de ninguna manera, y por si acaso, inmediatamente me disculpo por usar la combinaci√≥n de letras "Buzic". <br><br><h3>  As√≠ que vamos </h3><br>  Conoc√≠ una gran cantidad de ejemplos de la red, todos ellos se basan en el ciclo m√°s simple en el cuerpo principal del firmware o en la interrupci√≥n del temporizador.  Pero todos usan el mismo enfoque para generar frecuencia: <br><br><ol><li>  alimentar un alto nivel al pie del microcontrolador </li><li>  hacer un retraso </li><li>  alimentarse al pie del microcontrolador </li></ol><br>  Cambiando los retrasos y la configuraci√≥n del temporizador: ajuste la frecuencia. <br><br>  Este enfoque no me conven√≠a mucho, porque  No deseaba escribir c√≥digo para el control manual del pie del microcontrolador.  Me gustar√≠a que la "piedra" genere la frecuencia de sonido para m√≠, y simplemente configuro los valores de ciertos registros, y as√≠ la cambio (frecuencia). <br><br>  Al estudiar la hoja de datos (en lo sucesivo, DS), todav√≠a encontr√© el modo de temporizador que necesitaba, y este modo, como habr√°s adivinado, es el modo CTC (Clear Timer on Compare Match).  Como la funci√≥n de reproducir m√∫sica es, por decirlo suavemente, no es la funcionalidad principal, prefer√≠ seleccionar el temporizador 2 para ello (p√°rrafo 22 de la SD). <br><br>  Todo el mundo sabe que pr√°cticamente cualquier microcontrolador tiene un modo de generaci√≥n de se√±al PWM que se implementa en temporizadores y es completamente hardware.  Pero en esta tarea, PWM no es adecuado porque  solo se generar√° una frecuencia en el hardware.  Por lo tanto, necesitamos PFM (modulaci√≥n de frecuencia de pulso).  Alguna similitud de PFM es el modo de temporizador CTC (cl√°usula 22.7.2 LH). <br><br><h3>  Modo CTC </h3><br>  El temporizador 2 en el microcontrolador Atmega48pa es de 8 bits, es decir, "marca" de 0 a 255 y luego va en un c√≠rculo.  Por cierto, el temporizador puede ir en una direcci√≥n diferente, pero no en nuestro caso.  El siguiente componente requerido es la Unidad de comparaci√≥n.  Hablando muy crudamente, este m√≥dulo es el iniciador de cualquier evento relacionado con el temporizador.  Los eventos pueden ser diferentes, como interrupciones, cambios en el nivel de ciertas patas del microcontrolador, etc. (Obviamente, estamos interesados ‚Äã‚Äãen el segundo).  Como puede suponer, el m√≥dulo de comparaci√≥n no solo se llama, sino que compara un valor espec√≠fico seleccionado por el desarrollador del firmware con el valor actual del temporizador.  Si el valor del temporizador alcanza el valor que establecemos, se produce un evento.  Los eventos tambi√©n pueden ocurrir cuando el temporizador se desborda o durante un reinicio.  <b>Bien, hemos llegado a la conclusi√≥n de que es conveniente para nosotros en ciertos momentos que el temporizador, junto con el m√≥dulo de comparaci√≥n, cambie independientemente el nivel en el pie del microcontrolador al contrario, generando pulsos.</b> <br><br>  La segunda tarea es establecer los intervalos entre estos pulsos, es decir  controlar la frecuencia de generaci√≥n.  Toda la singularidad del modo CTC radica en el hecho de que en este modo el temporizador no llega al final (255), sino que se restablece cuando se alcanza el valor establecido.  En consecuencia, al cambiar este valor, podemos controlar la frecuencia.  Por ejemplo, si establecemos el valor del m√≥dulo de comparaci√≥n en 10, entonces el cambio de nivel en el pie del microcontrolador ocurrir√° 20 veces m√°s a menudo que si lo establecemos (el valor del m√≥dulo de comparaci√≥n) en 200. ¬° <b>Ahora podemos controlar la frecuencia!</b> <br><br><img src="https://habrastorage.org/files/d45/90e/b7a/d4590eb7acd543a59fc71057cc6ae5b5.png"><br><br><h3>  Hierro </h3><br><img src="https://habrastorage.org/files/8f9/dbb/8f5/8f9dbb8f514f4819863dff1a4dff4690.png"><br>  El pinout del microcontrolador muestra que necesitamos conectar nuestro zumbador a la pata de PB3 (OC2A) o la pata de PD3 (OC2B), porque  OC2A y OC2B significan exactamente que en estas patas, el temporizador 2 puede generar se√±ales. <br><br>  El esquema que suelo usar para conectar el timbre es: <br><img src="https://habrastorage.org/files/8c8/a1e/7c6/8c8a1e7c67cf433989b5b94b89fa3e55.png"><br><br>  <b>Y as√≠ armamos el dispositivo.</b> <br><br><h3>  Registros </h3><br>  En el p√°rrafo anterior, decidimos la elecci√≥n de la pierna: esta es PB3 (OC2A), trabajaremos con ella.  Si necesita PD3, para ella todo ser√° igual, lo que ser√° claramente visible en la historia. <br><br>  Configuraremos nuestro temporizador 2 cambiando 3 registros: <br><ol><li>  TCCR2A - configuraci√≥n de modo y selecci√≥n de comportamiento </li><li>  TCCR2B - ajustes de modo y divisor de frecuencia del temporizador (tambi√©n bits FOC - no los usamos) </li><li>  OCR2A (OCR2B para el caso de pierna PD3) - valor del m√≥dulo de comparaci√≥n </li></ol><br><br>  Considere primero los registros TCCR2A y TCCR2B <br><img src="https://habrastorage.org/files/37b/def/522/37bdef52208b48b381b06405d9eddcb5.png"><br>  Como puede ver, tenemos 3 grupos de bits que son importantes para nosotros: estos son bits de las series COM2xx, WGM2x y CS2x <br>  Lo primero que necesitamos cambiar es WGM2x, esto es lo principal para elegir el modo de generaci√≥n, estos bits se utilizan para seleccionar nuestro modo CTC. <br><br><img src="https://habrastorage.org/files/f34/28d/3e3/f3428d3e3ecc4e1aafcef3c82b061d23.png"><br>  <i>nota: obviamente en LH el error tipogr√°fico en "Actualizaci√≥n de OCR0x en" deber√≠a ser OCR2x</i> <br><br>  Es decir  el c√≥digo ser√° as√≠: <br><pre><code class="cpp hljs">TCCR2A = _BV(WGM21) ;</code> </pre> <br>  Como puede ver, TCCR2B a√∫n no se utiliza.  WGM22 deber√≠a ser cero, pero ya es cero. <br><br>  El siguiente paso es configurar los bits COM2xx, m√°s precisamente COM2Ax, porque  trabajamos con la pata PB3 (para PD3 COM2Bx se usan de la misma manera).  Lo que suceder√° con nuestra pierna PB3 depende de ellos. <br><br>  Los bits COM2xx dependen del modo que seleccionamos con los bits WGM2x, por lo que tendremos que encontrar la secci√≥n correspondiente en la LH.  Porque  tenemos el modo CTC, es decir  no PWM, entonces estamos buscando una placa "Comparar modo de salida, no PWM", aqu√≠ est√°: <br><img src="https://habrastorage.org/files/771/054/3e2/7710543e25404353b1c1056cd3a58483.png"><br>  Aqu√≠ debe seleccionar "Alternar", de modo que el nivel en el tramo cambie al opuesto cuando el temporizador alcance el valor establecido.  Cambio de nivel constante e implementa la generaci√≥n de la frecuencia que necesitamos. <br><br>  Porque  los bits COM2xx tambi√©n est√°n en el registro TCCR2A, solo que cambia: <br><pre> <code class="cpp hljs">TCCR2A = _BV(COM2A0) | _BV(WGM21) ;</code> </pre><br>  Naturalmente, tambi√©n debe seleccionar el divisor de frecuencia con bits CS2x y, por supuesto, ajustar el pie PB3 a la salida ... pero a√∫n no lo haremos para que cuando activemos el MK, no obtengamos un chirrido penetrante a una frecuencia incomprensible, pero cuando hagamos todos los dem√°s ajustes y Gire el pie para salir - se describir√° a continuaci√≥n. <br><br>  As√≠ que llevemos nuestra inicializaci√≥n a un aspecto completo: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; //set bit - using bitwise OR operator #define sbi(x,y) x |= _BV(y) //clear bit - using bitwise AND operator #define cbi(x,y) x &amp;= ~(_BV(y)) #define BUZ_PIN PB3 void timer2_buzzer_init() { // PB3 cbi(PORTB, BUZ_PIN); // PB3  ,    cbi(DDRB, BUZ_PIN); //  TCCR2A = _BV(COM2A0) | _BV(WGM21) ; //   (      ) OCR2A = 0; }</span></span></span></span></code> </pre><br>  Us√© las macros cbi y sbi (espiadas en alg√∫n lugar de la red) para configurar bits individuales, y lo dej√© as√≠.  Estas macros, por supuesto, se han colocado en el archivo de encabezado, pero para mayor claridad, las puse aqu√≠. <br><br><h3>  C√°lculo de la frecuencia y duraci√≥n de las notas. </h3><br>  Ahora llegamos a la esencia misma del problema.  Hace alg√∫n tiempo, conocidos de m√∫sicos intentaron introducir una cierta cantidad de informaci√≥n sobre un equipo musical en el cerebro de mi programador, mi cerebro casi herv√≠a, pero a√∫n as√≠ saqu√© un grano √∫til de estas conversaciones. <br>  Te advierto de inmediato: son posibles grandes inexactitudes. <br><ol><li>  cada medida consta de 4 cuartos </li><li>  Cada melod√≠a tiene un tempo, es decir  la cantidad de esos cuartos por minuto </li><li>  Cada nota se puede tocar como una medida completa, as√≠ como su parte 1/2, 1/3, 1/4, etc. </li><li>  Cada nota, por supuesto, tiene una cierta frecuencia </li></ol><br>  Examinamos el caso m√°s com√∫n, de hecho, todo es m√°s complicado all√≠, al menos para m√≠, por lo que no discutir√© este tema en el marco de esta historia. <br><br>  Bueno, est√° bien, trabajaremos con lo que tenemos.  Lo m√°s importante para nosotros es obtener la frecuencia de la nota (de hecho, el valor del registro OCR2A) y su duraci√≥n, por ejemplo, en milisegundos.  En consecuencia, es necesario hacer algunos c√°lculos. <br><br>  Porque  estamos dentro del marco de un lenguaje de programaci√≥n, las melod√≠as son m√°s f√°ciles de almacenar en una matriz.  La forma m√°s l√≥gica de establecer cada elemento de la matriz en el formato es nota + duraci√≥n.  Es necesario calcular el tama√±o del elemento en bytes, porque escribimos debajo del microcontrolador y con recursos aqu√≠ es escaso; eso significa que el tama√±o del elemento en bytes debe ser adecuado. <br><br><h4>  Frecuencia </h4><br>  Comencemos con la frecuencia.  Porque  tenemos el temporizador 2 de 8 bits, el registro de comparaci√≥n OCR2A tambi√©n es de 8 bits.  Es decir, nuestro elemento de la matriz de melod√≠as ya ser√° de al menos 2 bytes, porque a√∫n necesita guardar la duraci√≥n.  De hecho, 2 bytes es el l√≠mite para este tipo de embarcaciones.  Todav√≠a no obtenemos un buen sonido, por decirlo suavemente, y gastar m√°s bytes no es razonable.  <b>Entonces, nos detuvimos en 2 bytes.</b> <br><br>  <b>Al contar la frecuencia, de hecho, surge otro gran problema.</b> <br>  Si observa las frecuencias de las notas, veremos que est√°n divididas en octavas. <br><img src="https://habrastorage.org/files/240/294/17a/24029417a547408aa6806c9ddf66d593.jpg"><br>  Para la mayor√≠a de las melod√≠as simples, 3 octavas son suficientes, pero decid√≠ esquivar e implementar 6: grande, peque√±o y los siguientes 4. <br><br>  Ahora pasemos de la m√∫sica y volvamos al mundo de la programaci√≥n de microcontroladores. <br>  Cualquier temporizador en el AVR (y la gran mayor√≠a de otros MK) est√° vinculado a la frecuencia del MK en s√≠.  La frecuencia del cuarzo en mi circuito es de 16Mhz.  En mi caso, la "definici√≥n" de F_CPU determina que la misma frecuencia es igual a 16000000. En el registro TCCR2B, podemos seleccionar divisores de frecuencia para que nuestro temporizador 2 no "marque" a una velocidad fren√©tica de 16000000 veces por segundo, sino un poco m√°s lento.  El divisor de frecuencia se selecciona por bits CS2x, como se mencion√≥ anteriormente. <br><br><img src="https://habrastorage.org/files/9bd/ca6/247/9bdca624740e4dd787574c6604291dc3.png"><br>  <i>nota: obviamente en LH un error tipogr√°fico en lugar de "CA2x" deber√≠a ser CS2x</i> <br><br>  Surge la pregunta: ¬øc√≥mo configurar el divisor? <br><br>  Para hacer esto, comprenda c√≥mo calcular los valores para el registro OCR2A.  Y calcularlo es bastante simple: <br>  <b>OCR2A = F_CPU / (divisor de frecuencia de cuarzo * 2) / frecuencia de nota</b> <br>  Por ejemplo, tome la nota ANTES de la primera octava y el divisor 256 (CS22 = 1, CS21 = 1, CS20 = 0): <br>  OCR2A = 16000000 / (256 * 2) / 261 = 119 <br><br>  Explicar√© de inmediato de d√≥nde vino la multiplicaci√≥n por 2. El hecho es que seleccionamos el modo "Alternar" con los registros COM2Ax, lo que significa que el cambio de niveles en el pie de menor a mayor (o viceversa) y viceversa ocurrir√° en 2 pases del temporizador: primero el temporizador alcanza el valor de OCR2A y cambia el pie del microcontrolador, por ejemplo, de 1 a 0, se reinicia y solo en la segunda vuelta cambia 0 de nuevo a 1. Por lo tanto, 2 vueltas del temporizador van para cada onda completa, respectivamente, el divisor debe multiplicarse por 2, de lo contrario solo obtendremos la mitad de la frecuencia de nuestra nota <br><br>  De ah√≠ la desgracia antes mencionada ... <br><br>  Si tomamos la nota ANTES de la gran octava y dejamos el divisor 256: <br>  ¬°OCR2A = 16000000 / (256 * 2) / 65 = 480! <br>  <b>480: este n√∫mero es claramente m√°s de 255 y no cabe f√≠sicamente en el registro OCR2A de 8 bits.</b> <br><br>  Que hacer  Obviamente cambiando el divisor, pero si ponemos el divisor 1024, entonces con una octava grande, todo estar√° bien.  Los problemas comenzar√°n con las octavas superiores: <br>  LA 4ta octava - OCR2A = 16000000 / (1024 * 2) / 3520 = 4 <br>  Una cuarta octava aguda - OCR2A = 16000000 / (1024 * 2) / 3729 = 4 <br>  <b>Los valores de OCR2A ya no son diferentes, lo que significa que el sonido tambi√©n dejar√° de ser diferente.</b> <br><br>  <b>Solo hay una salida: para la frecuencia de las notas, necesita almacenar no solo los valores del registro OCR2A, sino tambi√©n los bits del divisor de frecuencia de cuarzo.</b>  <b>Porque</b>  <b>¬°para diferentes octavas habr√° un valor diferente del divisor de frecuencia de cuarzo, que tendremos que establecer en el registro TCCR2B!</b> <br><br>  Ahora todo cae en su lugar, y finalmente expliqu√© por qu√© no pod√≠amos completar de inmediato el valor del divisor en la funci√≥n timer2_buzzer_init (). <br><br>  Desafortunadamente, el divisor de frecuencia es de 3 bits m√°s.  Y deber√°n tomarse en el segundo byte del elemento del conjunto de melod√≠as. <br><br><div class="spoiler">  <b class="spoiler_title">Larga vida a las macros</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_MASK (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_1024 (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_256 (_BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_128 (_BV(CS20) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_64 _BV(CS22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_32 (_BV(CS20) | _BV(CS21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_1024( x ) ((F_CPU / (1024 * 2) / x) | (DIV_1024 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_256( x ) ((F_CPU / (256 * 2) / x) | (DIV_256 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_128( x ) ((F_CPU / (128 * 2) / x) | (DIV_128 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_64( x ) ((F_CPU / (64 * 2) / x) | (DIV_64 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_32( x ) ((F_CPU / (32 * 2) / x) | (DIV_32 &lt;&lt; 8)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define DOB NOTE_1024( 65 ) #define DO_B NOTE_1024( 69 ) #define REB NOTE_1024 ( 73 ) #define RE_B NOTE_1024 ( 78 ) #define MIB NOTE_1024 ( 82 ) #define FAB NOTE_1024 ( 87 ) #define FA_B NOTE_1024 ( 93 ) #define SOLB NOTE_1024 ( 98 ) #define SOL_B NOTE_1024 ( 104 ) #define LAB NOTE_1024 ( 110 ) #define LA_B NOTE_1024 ( 116 ) #define SIB NOTE_1024 ( 123 ) //  #define DOS NOTE_256( 131 ) #define DO_S NOTE_256( 138 ) #define RES NOTE_256 ( 146 ) #define RE_S NOTE_256 ( 155 ) #define MIS NOTE_256 ( 164 ) #define FAS NOTE_256 ( 174 ) #define FA_S NOTE_256 ( 185 ) #define SOLS NOTE_256 ( 196 ) #define SOL_S NOTE_256 ( 207 ) #define LAS NOTE_256 ( 219 ) #define LA_S NOTE_256 ( 233 ) #define SIS NOTE_256 ( 246 ) //  #define DO1 NOTE_256( 261 ) #define DO_1 NOTE_256( 277 ) #define RE1 NOTE_256 ( 293 ) #define RE_1 NOTE_256 ( 310 ) #define MI1 NOTE_256 ( 329 ) #define FA1 NOTE_256 ( 348 ) #define FA_1 NOTE_256 ( 369 ) #define SOL1 NOTE_256 ( 391 ) #define SOL_1 NOTE_256 ( 414 ) #define LA1 NOTE_256 ( 439 ) #define LA_1 NOTE_256 ( 465 ) #define SI1 NOTE_256 ( 493 ) //  #define DO2 NOTE_128( 522 ) #define DO_2 NOTE_128( 553 ) #define RE2 NOTE_128 ( 586 ) #define RE_2 NOTE_128 ( 621 ) #define MI2 NOTE_128 ( 658 ) #define FA2 NOTE_128 ( 697 ) #define FA_2 NOTE_128 ( 738 ) #define SOL2 NOTE_128 ( 782 ) #define SOL_2 NOTE_128 ( 829 ) #define LA2 NOTE_128 ( 878 ) #define LA_2 NOTE_128 ( 930 ) #define SI2 NOTE_128 ( 985 ) //  #define DO3 NOTE_64( 1047 ) #define DO_3 NOTE_64( 1109 ) #define RE3 NOTE_64 ( 1175 ) #define RE_3 NOTE_64 ( 1245 ) #define MI3 NOTE_64 ( 1319 ) #define FA3 NOTE_64 ( 1397 ) #define FA_3 NOTE_64 ( 1480 ) #define SOL3 NOTE_64 ( 1568 ) #define SOL_3 NOTE_64 ( 1661 ) #define LA3 NOTE_64 ( 1760 ) #define LA_3 NOTE_64 ( 1865 ) #define SI3 NOTE_64 ( 1976 ) //  #define DO4 NOTE_32( 2093 ) #define DO_4 NOTE_32( 2217 ) #define RE4 NOTE_32 ( 2349 ) #define RE_4 NOTE_32 ( 2489 ) #define MI4 NOTE_32 ( 2637 ) #define FA4 NOTE_32 ( 2794 ) #define FA_4 NOTE_32 ( 2960 ) #define SOL4 NOTE_32 ( 3136 ) #define SOL_4 NOTE_32 ( 3322 ) #define LA4 NOTE_32 ( 3520 ) #define LA_4 NOTE_32 ( 3729 ) #define SI4 NOTE_32 ( 3951 )</span></span></span></span></code> </pre><br></div></div><br><br>  Y para la duraci√≥n de la nota, solo nos quedan 5 bits, as√≠ que calculemos la duraci√≥n. <br><br><h4>  Duraci√≥n </h4><br>  Primero necesita traducir el valor del tempo en unidades temporales (por ejemplo, en milisegundos). Lo hice as√≠: <br>  <b>Duraci√≥n de una medida musical en ms = (60,000 ms * 4 trimestres) / valor de tempo.</b> <br><br>  En consecuencia, si estamos hablando de partes de ritmo, entonces este valor debe dividirse, y al principio pens√© que el desplazamiento a la izquierda habitual para los divisores ser√≠a suficiente.  Es decir  el c√≥digo era este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / _BV((note &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>)); }</code> </pre> <br><br>  Es decir  Us√© 3 bits (de los 5 restantes) y obtuve partes del ritmo musical desde grados 2 hasta 1/128.  Pero cuando le di a un amigo que me ped√≠a que escribiera alg√∫n tipo de tono de llamada para mi pieza de hierro, surgieron preguntas sobre por qu√© no hay 1/3 o 1/6 y comenc√© a pensar ... <br><br>  Al final, hice un sistema complicado para obtener tales duraciones.  Un poco del 2x restante: gast√© en el signo de multiplicaci√≥n por 3 para el divisor de reloj obtenido despu√©s del turno.  Y el √∫ltimo bit es indicar si es necesario restar 1. Esto es dif√≠cil de describir, es m√°s f√°cil ver el c√≥digo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> divider = _BV(note &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>); note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; divider *= ((note &amp; <span class="hljs-number"><span class="hljs-number">0b01</span></span>) ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); divider -= (note &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider); }</code> </pre> <br>  Luego "defin√≠" todas las notas posibles (excepto las que son menores de 1/128). <br><div class="spoiler">  <b class="spoiler_title">Aqui estan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MINUS_1 0b10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MUL_3 0b01000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N2 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N3 (2 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N4 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N5 (1 | DEL_MINUS_1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N6 (1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N7 (3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N8 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N11 (2 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N12 (2 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N15 (4 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N16 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N23 (3 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N24 (3 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N31 (5 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N32 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N47 (4 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N48 (4 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N63 (6 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N64 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N95 (5 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N96 (5 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N127 (7 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N128 7</span></span></code> </pre><br></div></div><br><br><h4>  Poniendo todo junto </h4><br>  Total, tenemos el siguiente formato para el elemento de nuestra matriz de tonos de llamada. <br><br><ul><li>  1 bit: divisor de retraso - 1 </li><li>  1 bit: divisor de retraso * 3 </li><li>  3 bits: demora el cambio del divisor </li><li>  3 bits: divisor de reloj de la CPU </li><li>  8 bits: valor OCR2A </li></ul><br>  Solo 16 bits. <br><br>  Estimado lector, si lo desea, puede so√±ar con el formato usted mismo, tal vez nazca algo m√°s espacioso que el m√≠o. <br><br>  Olvidamos agregar una nota vac√≠a, es decir  silencio  Y finalmente, expliqu√© por qu√© al principio, en la funci√≥n timer2_buzzer_init (), configuramos especialmente el tramo PB3 a la entrada y no a la salida.  Cambiando el registro DDRB, activaremos y desactivaremos la reproducci√≥n de "silencio" o la composici√≥n en su conjunto.  Porque  no podemos tener notas con un valor de 0, ser√° una nota "vac√≠a". <br><br>  Defina las macros faltantes y la funci√≥n para habilitar la generaci√≥n de sonido: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY_NOTE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE(delay, note) (uint16_t)((delay </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 11) | note) ........ ........ ........ void play_music_note(uint16_t note) { if (note) { TCCR2B = (note &gt;&gt; 8) &amp; DIV_MASK; OCR2A = note &amp; 0xff; sbi(DDRB, BUZ_PIN); } else cbi(DDRB, BUZ_PIN); }</span></span></span></span></code> </pre><br>  Ahora te mostrar√© c√≥mo se ve un tono de llamada escrito de acuerdo con este principio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> king[] PROGMEM = { NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N2, SI3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, EMPTY_NOTE), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, FA3), NOTE(DEL_1N2, LA3), NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, MI4), NOTE(DEL_1N4, RE4), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N2, RE4), NOTE(DEL_1N2, EMPTY_NOTE), };</code> </pre><br><br><h3>  Tocando tono de llamada </h3><br>  Todav√≠a tenemos una tarea: tocar la melod√≠a.  Para hacer esto, necesitamos "ejecutar" a trav√©s de la matriz de tonos de llamada, resistir las pausas apropiadas y cambiar las frecuencias de las notas.  Obviamente, necesitamos otro temporizador, que, por cierto, puede usarse para otras tareas generales, como suelo hacer.  Adem√°s, puede cambiar entre elementos de la matriz en la interrupci√≥n de este temporizador o en el bucle principal, y usar el temporizador para calcular el tiempo.  En este ejemplo, utilic√© la segunda opci√≥n. <br><br>  Como sabes, el cuerpo de cualquier programa para MK incluye un bucle infinito: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">//   } return 0; }</span></span></code> </pre><br>  En ella "correremos" a lo largo de nuestra matriz.  Pero necesitamos una funci√≥n similar a GetTickCount de WinApi, que devuelve el n√∫mero de milisegundos en los sistemas operativos Windows.  Pero, naturalmente, en el mundo de MK no existen tales funciones "fuera de la caja", por lo que debemos escribirlo nosotros mismos. <br><br><h4>  Temporizador 1 </h4><br>  Para calcular los intervalos de tiempo (intencionalmente no escribo milisegundos, m√°s tarde comprender√° por qu√©) utilic√© el temporizador 1 junto con el modo CTC ya conocido.  El temporizador 1 es un temporizador de 16 bits, lo que significa que el valor del m√≥dulo de comparaci√≥n ya est√° indicado por 2 registros de 8 bits OCR1AH ‚Äã‚Äãy OCR1AL, para los bytes alto y bajo, respectivamente.  No quiero describir en detalle el trabajo con el temporizador 1, ya que esto no se aplica al tema principal de este memo.  Por lo tanto, te dir√© solo en 2 palabras. <br><br>  En realidad necesitamos 3 funciones: <br><ul><li>  Inicializaci√≥n del temporizador. </li><li>  Manejador de interrupci√≥n de temporizador </li><li>  funci√≥n que devuelve el n√∫mero de intervalos de tiempo. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Archivo de c√≥digo C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include "timer1_ticks.h" volatile unsigned long timer1_ticks; //  ISR (TIMER1_COMPA_vect) { timer1_ticks++; } void timer1_ticks_init() { //   // CTC ,     8 TCCR1B |= (1 &lt;&lt; WGM12) | (1 &lt;&lt; CS11); //     OCR1AH = (uint8_t)(CTC_MATCH_OVERFLOW &gt;&gt; 8); OCR1AL = (uint8_t) CTC_MATCH_OVERFLOW; //    TIMSK1 |= (1 &lt;&lt; OCIE1A); } unsigned long ticks() { unsigned long ticks_return; //  ,   ticks_return   //     ATOMIC_BLOCK(ATOMIC_FORCEON) { ticks_return = timer1_ticks; } return ticks_return; }</span></span></span></span></code> </pre><br></div></div><br><br>  Antes de mostrar el archivo de encabezado con una cierta constante CTC_MATCH_OVERFLOW, necesitamos retroceder en el tiempo a la <b>secci√≥n "Duraci√≥n"</b> y determinar la macro m√°s importante para la melod√≠a, que calcula el tempo de la melod√≠a.  Esper√© mucho tiempo para determinarlo, ya que est√° conectado directamente al reproductor y, por lo tanto, con el temporizador 1. <br>  En una primera aproximaci√≥n, se ve√≠a as√≠ (ver c√°lculos en la secci√≥n "Duraci√≥n"): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * 4 / x)</span></span></code> </pre><br>  El valor que obtenemos en la salida posteriormente debemos sustituir el primer argumento en la funci√≥n <b>calc_note_delay</b> .  Ahora observe de cerca la funci√≥n calc_note_delay, es decir, la l√≠nea: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider);</code> </pre><br>  Vemos que el valor obtenido al calcular la macro TEMPO se divide por un cierto divisor.  Recuerde que el divisor m√°ximo que hemos definido es <b>DEL_1N128</b> , es decir  el divisor ser√° 128. <br><br>  Ahora tomemos el valor de tempo com√∫n igual a 240 y hagamos algunos c√°lculos simples: <br>  <b>60000 * 4/240 = 1000</b> <br>  ¬°Oh horror!  Obtuvimos solo 1000, ya que este valor a√∫n se dividir√° entre 128, corremos el riesgo de caer a 0, a tasas altas.  <b>Este es el segundo problema de duraci√≥n.</b> <br><br>  ¬øC√≥mo solucionarlo?  Obviamente, para expandir el rango de valores de tempo, de alguna manera necesitamos aumentar el n√∫mero obtenido al calcular la macro TEMPO.  Esto se puede hacer de una sola manera: alejarse de milisegundos y contar el tiempo en ciertos intervalos de tiempo.  Ahora entiendes por qu√© todo este tiempo evit√© mencionar "milisegundos" en la historia.  Definamos otra macro: <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4</span></span></code> </pre> <br>  Deje que sea nuestro divisor del milisegundo: divida el milisegundo, por ejemplo, entre 4 (250 Œºs). <br>  Entonces necesita cambiar la macro TEMPO: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * MS_DIVIDER * 4 / x)</span></span></code> </pre> <br><br>  Ahora, con la conciencia tranquila, le dar√© el archivo de encabezado para trabajar con el temporizador 1: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTC_MATCH_OVERFLOW ((F_CPU / 1000) / (8 * MS_DIVIDER)) void timer1_ticks_init(); unsigned long ticks(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// TIMER1_TICKS_H_INCLUDED</span></span></span></span></code> </pre> <br>  Ahora podemos, cambiando MS_DIVIDER, ajustar el rango de nuestras tareas, tengo 4 en mi c√≥digo, esto fue suficiente para mis tareas.  <b>Atenci√≥n: si todav√≠a tiene alguna tarea "vinculada" al temporizador 1, no olvide multiplicar / dividir los valores de control de tiempo para ellos por MS_DIVIDER.</b> <br><br><h4>  Placa giratoria </h4><br>  Ahora escribamos a nuestro jugador.  Creo que todo quedar√° claro a partir del c√≥digo y los comentarios. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ timer1_ticks_init(); <span class="hljs-comment"><span class="hljs-comment">//   sei(); timer2_buzzer_init(); //    MS_DIVIDER long time_since = ticks(); //       MS_DIVIDER uint16_t note_delay = 0; //     uint16_t note_pos = 0; //  uint16_t length = sizeof(king) / sizeof(king[0]); //     uint16_t tempo = TEMPO(240); for(;;) { unsigned long time_current = ticks(); if (time_current - time_since &gt; note_delay) { //   uint16_t note = pgm_read_word(&amp;king[note_pos]); //   play_music_note(note); //    note_delay = calc_note_delay(tempo, note); //  if (++note_pos &gt;= length) note_pos = 0; time_since = time_current; } } return 0; }</span></span></code> </pre><br><br><h3>  Conclusi√≥n </h3><br>  Espero que este memo sea √∫til para un lector respetado y para m√≠, para no olvidar todos los matices de tocar melod√≠as, en caso de que vuelva a tomar los microcontroladores AVR. <br><br>  Bueno, tradicionalmente el video y el c√≥digo fuente (lo desarroll√© en el entorno de Code Blocks, as√≠ que no tengas miedo de los archivos oscuros): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j60UCr2q0Ak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es402329/">https://habr.com/ru/post/es402329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es402319/index.html">La Universidad Jagiellonian desarrolla una aplicaci√≥n de entrenamiento utilizando las capacidades de IBM Watson</a></li>
<li><a href="../es402321/index.html">Revisi√≥n de Livall: un casco inteligente con controlador, micr√≥fono y aplicaci√≥n nativa</a></li>
<li><a href="../es402323/index.html">"Tambi√©n trabajo": el arte de escuchar m√∫sica</a></li>
<li><a href="../es402325/index.html">"Mundo delgado". Cap√≠tulo 7</a></li>
<li><a href="../es402327/index.html">WayRay anuncia una asociaci√≥n estrat√©gica con Banma Technologies con el apoyo de inversi√≥n del Grupo Alibaba</a></li>
<li><a href="../es402345/index.html">Datos de diversidad de especies</a></li>
<li><a href="../es402347/index.html">Una selecci√≥n de auriculares deportivos de hasta 2500 rublos.</a></li>
<li><a href="../es402351/index.html">Internet mundial: Jap√≥n y Singapur</a></li>
<li><a href="../es402355/index.html">Ajedrez cu√°ntico</a></li>
<li><a href="../es402357/index.html">¬øPuedo reemplazar Adobe Premiere y Sony Vegas con editores de video gratuitos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>