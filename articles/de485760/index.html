<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎁 💻 👩🏿‍🍳 Erweiterungen in Kotlin. Gefährlicher Atavismus oder nützliches Werkzeug? 📀 🆚 👨🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin ist noch eine junge Sprache, hat aber bereits Einzug gehalten. Aus diesem Grund ist nicht immer klar, wie dieses oder jenes Funktionsmerkmal ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erweiterungen in Kotlin. Gefährlicher Atavismus oder nützliches Werkzeug?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/485760/"><img src="https://habrastorage.org/webt/kz/wk/5d/kzwk5d50usqqdehsvqpkpzmkogg.jpeg"><br><br>  Kotlin ist noch eine junge Sprache, hat aber bereits Einzug gehalten.  Aus diesem Grund ist nicht immer klar, wie dieses oder jenes Funktionsmerkmal korrekt implementiert werden soll und welche bewährten Methoden angewendet werden sollen. <br><br>  Besonders schwierig ist der Fall bei den Fähigkeiten der Sprache, die nicht in Java sind.  Einer dieser Stolpersteine ​​war die <a href="https://kotlinlang.org/docs/reference/extensions.html">Expansion</a> . <br><br>  Dies ist ein praktisches Tool, mit dem der Code besser lesbar ist und für das fast nichts zurückgegeben werden muss.  Gleichzeitig kenne ich aber mindestens einen Menschen, der, wenn er Expansion nicht als böse ansieht, diesen durchaus skeptisch gegenübersteht.  Im Folgenden möchte ich die Merkmale dieses Mechanismus erörtern, die zu Kontroversen und Missverständnissen führen können. <br><a name="habracut"></a><br><h3>  Erweiterungen zu DTO - Verstoß gegen die Datenübertragungsobjektvorlage </h3><br>  Zum Beispiel gibt es eine Klasse User <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String)</code> </pre> <br>  Ein ziemlicher DTO!  Ferner ist in dem Code an mehreren Stellen eine Überprüfung erforderlich, um festzustellen, ob der Benutzer ein Erwachsener ist.  Am einfachsten ist es, an allen Stellen eine Bedingung zu stellen <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) { ... }</code> </pre><br>  Da es jedoch beliebig viele solcher Stellen geben kann, ist es sinnvoll, diese Prüfung in die Methode aufzunehmen. <br>  Hier gibt es drei Möglichkeiten: <br><br><ol><li>  Funktionsspaß isAdult (Benutzer: Benutzer) - Dienstprogrammklassen bestehen normalerweise aus solchen Funktionen. <br></li><li>  Fügen Sie die isAdult-Funktion in die User-Klasse ein <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> }</code> </pre><br></li><li>  Schreiben Sie einen Wrapper für User, der ähnliche Funktionen enthält. <br></li></ol><br>  Alle drei Optionen sind technisch lebensberechtigt.  Der erste Nachteil besteht jedoch darin, dass alle Utility-Funktionen bekannt sein müssen, obwohl dies natürlich kein großes Problem darstellt. <br>  Die zweite Option scheint das Datenübertragungsobjektmuster zu verletzen, da es sich bei der Klasse nicht nur um Getter und Setter handelt.  Aber Muster zu brechen ist schlecht. <br><br>  Die dritte Option verstößt weder gegen die Prinzipien von OOP noch gegen Vorlagen. Sie müssen jedoch jedes Mal einen Wrapper erstellen, wenn Sie ähnliche Funktionen verwenden möchten.  Diese Option ist auch nicht sehr beliebt.  Am Ende stellt sich heraus, dass Sie noch Opfer bringen müssen. <br><br>  Meiner Meinung nach ist es einfacher, eine DTO-Vorlage zu opfern.  Erstens habe ich keine einzige Erklärung dafür gefunden, warum Funktionen (mit Ausnahme von Gettern und Setzern) nicht im DTO erstellt werden können.  Und zweitens ist ein solcher Code nur in Bezug auf die Bedeutung bequem neben den Daten zu haben, mit denen wir arbeiten. <br><br>  Es ist jedoch nicht immer möglich, einen solchen Code in den DTO-Shek einzufügen, da der Entwickler nicht immer die Möglichkeit hat, die Klassen zu bearbeiten, mit denen er arbeitet.  Dies können beispielsweise Klassen sein, die aus xsd generiert wurden.  Darüber hinaus kann es für jemanden ungewöhnlich und unangenehm sein, solchen Code in Datenklassen zu schreiben.  Kotlin bietet für solche Situationen eine Lösung in Form von Funktionen und Erweiterungsfeldern: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Dieser Code kann so verwendet werden, als ob er in der Benutzerklasse deklariert wäre: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user.isAdult()) {...}</code> </pre><br>  Das Ergebnis ist eine ziemlich genaue Lösung, die mit dem geringsten Kompromiss unsere Anforderungen erfüllt.  Wenn wir über die Tatsache sprechen, dass die DTO-Vorlage verletzt wird, möchten wir daran erinnern, dass es sich in Java um eine reguläre statische Methode des Formulars handelt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull User receiver)</span></span></span></span></code> </pre><br>  Wie Sie sehen, wird formal auch die Vorlage nicht verletzt.  Die Verwendung dieser Funktion sieht so aus, als ob sie in User deklariert wurde, und Idea bietet sie in automatischer Vervollständigung an.  Es ist sehr bequem. <br><br><h3>  Erweiterungen sind spezifisch.  Sie können nicht über deren Existenz Bescheid wissen und Methoden und Felder der Entität mit Erweiterungen verwechseln </h3><br>  Die Idee ist, dass der Entwickler zu dem Projekt gekommen ist und in Bezug auf den Code, der in Erweiterungen implementiert ist, nicht klar ist, welche Methode original ist und welche die Erweiterungsmethode ist. <br><br>  Dies ist kein Problem, da Idea dem Entwickler in dieser Angelegenheit hilft und solche Funktionen hervorhebt.  Obwohl fairerweise gesagt werden muss, dass der Unterschied im Darcula-Thema besser erkennbar ist.  Wenn Sie es in Light ändern, wird alles weniger offensichtlich und die Erweiterung unterscheidet sich nur in kursiver Schrift. <br><br>  Unten sehen wir ein Beispiel für den Aufruf von zwei Methoden: isAdult ist die Erweiterungsmethode, isMale ist die übliche Methode innerhalb der User-Klasse.  Der Screenshot links zeigt das Darcula-Thema, rechts das übliche Light-Thema. <br><br><img src="https://habrastorage.org/webt/qr/yx/j2/qryxj2ld3i7pyphvqsqd05njozi.png"><img src="https://habrastorage.org/webt/ik/ro/ed/ikroeddsainpwwaevfjjounzeva.png"><br><br>  Etwas schlimmer ist es mit den Feldern.  Wenn wir uns zum Beispiel dafür entscheiden, isAdult als Erweiterungsfeld zu implementieren, können wir es nur nach Schriftart von einem regulären Feld unterscheiden.  In diesem Beispiel ist name ein reguläres Feld.  Ein Erweiterungsfeld erzeugt nur Kursivschrift. <br><br><img src="https://habrastorage.org/webt/bt/w1/ej/btw1ejdtlclzohkqlucw8pfpihq.png"><img src="https://habrastorage.org/webt/bz/ok/ux/bzokuxqd_-bykhju0gylzq-g2wq.png"><br><br>  Mithilfe der Idea-Entwicklungsumgebung können Sie ermitteln, welche Methode eine Erweiterung ist und welche beim automatischen Vervollständigen das Original ist.  Das ist bequem. <br><br><img src="https://habrastorage.org/webt/7v/be/oe/7vbeoe1s9093-wjgwv5piavux1w.png"><br><br>  Ähnlich ist die Situation bei Feldern. <br><br><img src="https://habrastorage.org/webt/za/0q/jk/za0qjkyxmk94k8khz0atanwusgo.png"><br><br>  "Für Benutzer in &lt;root&gt;" bedeutet, dass es sich um eine Erweiterung handelt. <br><br>  Die Tatsache, dass Idea eine Erweiterung an eine erweiterbare Entität „bindet“, trägt außerdem erheblich zur Entwicklung bei, da Erweiterungsmethoden und -felder für die automatische Vervollständigung vorgeschlagen werden. <br><br><h3>  Erweiterungen sind über das gesamte Projekt verteilt und bilden eine Mülltonne </h3><br>  Wir haben kein solches Problem bei Projekten, da wir keine willkürlichen Erweiterungen einfügen und Code mit öffentlichen Erweiterungen in separaten Dateien oder Paketen entfernen. <br><br>  Beispielsweise könnte die Funktion isAdult aus dem obigen Beispiel in der Benutzerdatei des Erweiterungspakets angezeigt werden.  Wenn das Paket nicht ausreicht und Sie nur nicht verwechseln möchten, wo sich die Klasse befindet und wo sich die Funktionsdatei befindet, können Sie sie beispielsweise _User.kt nennen.  So auch die Entwickler von JetBrains für Kollektionen.  Wenn das Gewissen das Starten der Datei mit einem Unterstrich verbietet, können Sie user.kt aufrufen.  Tatsächlich gibt es keinen Unterschied in der Art und Weise, die Hauptsache ist, dass es eine Einheitlichkeit gibt, an der das gesamte Team festhält. <br><br>  Die Ersteller der Sprache haben sie bei der Entwicklung von Erweiterungsmethoden für Sammlungen in die Datei <a href="">_Collections.kt eingefügt</a> . <br><br>  Hierbei handelt es sich im Allgemeinen um die Organisation des Codes, nicht um das Problem von Erweiterungen.  Statische Funktionen in Java und nicht nur statische Funktionen können nicht weniger zufällig verteilt werden als Erweiterungen. <br><br><h3>  Übersehen Sie während des Gerätetests nicht die Erweiterungsfunktionen </h3><br>  Meiner Meinung nach besteht keine Notwendigkeit, Funktionen von Erweiterungen zu benetzen, genauso wie es keine Notwendigkeit gibt, statische Methoden zu benetzen.  In der Erweiterungsfunktion sollten Sie die Logik des Arbeitens mit vorhandenen Daten einfügen.  Im Fall der isAdult-Funktion für die User-Klasse befindet sich beispielsweise alles, was Sie benötigen, in isAdult.  Sie müssen nicht nass werden. <br><br>  Betrachten Sie ein etwas komplexeres Beispiel.  Es gibt eine bestimmte Komponente, die dazu dient, Benutzer von einem externen System abzurufen - UserComponent.  Die Methode zum Abrufen von Benutzern heißt getUsers.  Angenommen, es mussten alle aktiven Benutzer abgerufen werden, und es wurde beschlossen, eine Filterlogik in Form einer Funktion - einer Erweiterung - hinzuzufügen.  Als Ergebnis haben wir die Funktion: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> UserComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActiveUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Users&gt; = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().filter{it.status == “Active”}</code> </pre><br>  Es mag so aussehen, als ob es sich um eine Situation handelt, in der Sie einen Schein für eine Erweiterung benötigen.  Wenn Sie sich jedoch daran erinnern, dass getActiveUsers nur eine statische Methode ist, stellt sich heraus, dass kein Mock benötigt wird.  Dip sollte die Methoden und Funktionen sein, die in der Erweiterung aufgerufen werden, und nicht mehr. <br><br><h3>  Es ist möglich, dass sich die Erweiterungsfunktion mit der gleichnamigen Funktion innerhalb der erweiterten Klasse überschneidet </h3><br>  Wir werden diesen Fall anhand des Beispiels aus dem ersten Absatz betrachten.  Angenommen, es gibt eine Funktionserweiterung isAdult, die überprüft, ob der Benutzer ein Erwachsener ist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Danach implementieren wir die gleichnamige Funktion in User: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> }</code> </pre><br>  Wenn user.isAdult () aufgerufen wird, wird eine Funktion aus der Klasse aufgerufen, obwohl es eine gleichnamige Erweiterung und eine geeignete Funktion gibt.  Ein solcher Fall kann verwirrend sein, da Benutzer, die die in der Klasse deklarierte Funktion nicht kennen, auf den Abschluss der Erweiterungsfunktion warten.  Dies ist eine unangenehme Situation, die äußerst schwerwiegende Folgen haben kann.  In diesem Fall geht es nicht um die mögliche Unannehmlichkeit einer Überprüfung oder einer Vorlagenverletzung, sondern um das möglicherweise fehlerhafte Verhalten des Codes. <br><br>  Die oben beschriebene Situation zeigt, dass bei Verwendung der Erweiterungsfunktionen echte Probleme auftreten können. <br><br>  Um dies zu vermeiden, sollten Sie nicht vergessen, die Erweiterungsfunktionen so weit wie möglich mit Unit-Tests abzudecken.  Im schlimmsten Fall, wenn die Tests fehlschlagen, gibt es zwei Funktionen, die auf die gleiche Weise funktionieren.  Einer ist eine Erweiterung und der andere ist in der Klasse selbst.  Wenn die Tests fehlschlagen, wird darauf hingewiesen, dass eine Funktion eine andere überlappt. <br><br><h3>  Die Erweiterung ist an eine Klasse und nicht an ein Objekt gebunden, was zu Verwirrung führen kann </h3><br>  Betrachten Sie beispielsweise die Benutzerklasse aus dem ersten Absatz.  Lassen Sie uns es öffnen und seinen Nachfolger Student erstellen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span></span>(name: String, age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sex: String): User(name, age, sex)</code> </pre><br>  Wir definieren die Erweiterungsfunktion für Student, die auch bestimmt, ob der Student ein Erwachsener ist oder nicht.  Nur für den Schüler ändern wir die Bedingung: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Student.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age &gt;= <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  Und jetzt schreiben wir den folgenden Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user: User = Student(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-string"><span class="hljs-string">"M"</span></span>)</code> </pre><br>  Was gibt user.isAdult ()) zurück? <br>  Es scheint, dass ein Objekt vom Typ Student und die Funktion true zurückgeben sollten.  Aber es ist nicht so einfach.  Erweiterungen werden an die Klasse angehängt, nicht an das Objekt, und das Ergebnis ist falsch. <br><br>  Wenn wir uns daran erinnern, dass Erweiterungen statische Methoden sind und eine erweiterbare Entität der erste Parameter in dieser Methode ist, ist dies nichts Seltsames.  Dies ist ein weiterer Punkt, den Sie bei der Verwendung dieses Mechanismus berücksichtigen sollten.  Andernfalls können Sie einen unangenehmen und unerwarteten Effekt erzielen. <br><br><h3>  Anstelle der Ausgabe </h3><br>  Diese kontroversen Punkte scheinen nicht gefährlich zu sein, wenn Sie sich daran erinnern, dass wir Extension sagen - wir meinen eine statische Methode.  Wenn Sie diese Funktionen mit Komponententests abdecken, können Sie außerdem mögliche Unklarheiten im Zusammenhang mit der statischen Natur von Erweiterungen minimieren. <br><br>  Meiner Meinung nach sind Erweiterungen ein leistungsstarkes und praktisches Tool, mit dem sich die Qualität und Lesbarkeit des Codes verbessern lässt, ohne dass dafür fast nichts erforderlich ist.  Deshalb liebe ich sie: <br><br><ul><li>  Mit Erweiterungen können Sie Logik schreiben, die für den Kontext einer erweiterbaren Klasse spezifisch ist.  Dank dessen werden die Felder und Erweiterungsmethoden so gelesen, als wären sie immer in der erweiterten Entität vorhanden, was wiederum das Verständnis des Codes auf oberster Ebene verbessert.  In Java ist dies leider nicht möglich.  Darüber hinaus haben Erweiterungen dieselben Zugriffsmodifikatoren wie reguläre Funktionen.  Auf diese Weise können Sie ähnlichen Code mit dem Gültigkeitsbereich schreiben, der für eine bestimmte Funktion wirklich erforderlich ist. <br></li><li>  Es ist praktisch, die Erweiterungsfunktionen für das Mapping zu verwenden, die Sie bei der Lösung alltäglicher Aufgaben oft sehen müssen.  Zum Beispiel gibt es im Projekt eine Klasse UserFromExternalSystem, die beim Aufrufen eines externen Systems verwendet wird, und es wäre großartig, das Mapping in die Erweiterungsfunktion einzufügen, es zu vergessen und es so zu verwenden, als ob es ursprünglich in User wäre. <br><br><pre> <code class="kotlin hljs">callExternalSystem(user.getUserFromExternalSystem())</code> </pre><br>  Das gleiche kann natürlich mit der üblichen Methode gemacht werden, aber diese Option ist weniger lesbar: <br><br><pre> <code class="kotlin hljs">callExternalSystem(getUserFromExternalSystem(user))</code> </pre><br>  oder eine solche Option: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> externalUser = getUserFromExternalSystem(user) callExternalSystem(externalUser)</code> </pre><br>  Tatsächlich passiert keine Magie, aber dank solcher Kleinigkeiten ist es angenehmer, mit dem Code zu arbeiten. <br></li><li>  Unterstützung für Idee und automatische Vervollständigung.  Im Gegensatz zu Methoden aus Utility-Klassen werden Erweiterungen von der Entwicklungsumgebung gut unterstützt.  Bei der automatischen Vervollständigung werden Erweiterungen von der Umgebung als "native" Funktionen und Felder angeboten.  Dies ermöglicht eine gute Steigerung der Entwicklerproduktivität. <br></li><li>  Für Erweiterungen spricht, dass ein Großteil der Kotlin-Bibliotheken als Erweiterungen geschrieben ist.  Viele praktische und beliebte Methoden zum Arbeiten mit Sammlungen sind Erweiterungen (Filter, Map usw.).  Sie können dies überprüfen, indem Sie die Datei <a href="">_Collections.kt untersuchen</a> . <br></li></ul><br>  Vorteile von Erweiterungen decken mögliche Nachteile ab.  Natürlich besteht die Gefahr eines Missbrauchs dieses Mechanismus und der Versuchung, den gesamten Code in Erweiterungen zu packen.  Hier geht es aber eher um die Organisation des Codes und den kompetenten Umgang mit dem Tool.  Bei korrekter Verwendung werden Erweiterungen zu einem echten Freund und Helfer beim Schreiben von gut gelesenem und gepflegtem Code. <br><br>  Unten finden Sie Links zu Materialien, die zur Vorbereitung dieses Artikels verwendet wurden: <br><br><ol><li>  <a href="https://proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff">proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff</a> - hier werden interessante Gedanken darüber aufgegriffen, dass wir mithilfe von Erweiterungen enger mit dem Kontext arbeiten. <br></li><li>  <a href="https://www.nikialeksey.com/2017/11/14/kotlin-is-bad.html">www.nikialeksey.com/2017/11/14/kotlin-is-bad.html</a> - hier lehnt der Autor Erweiterungen ab und gibt ein interessantes Beispiel, das in einem der obigen Punkte diskutiert wird. <br></li><li>  <a href="https://medium.com/%40elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a">medium.com/@elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a</a> - Roman Elizarovs Meinung zur Benetzung von Extensionsmethoden. <br></li></ol><br>  Ich möchte mich auch bei Kollegen bedanken, die mit interessanten Fällen und Gedanken zu diesem Material geholfen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485760/">https://habr.com/ru/post/de485760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485738/index.html">Security Week 05: Kritische Schwachstellen von Medizinprodukten</a></li>
<li><a href="../de485742/index.html">Wie wir das Adressverzeichnis von Rostelecom erstellt haben</a></li>
<li><a href="../de485744/index.html">Intelligenz - die Fähigkeit eines Objekts, sein Verhalten an die Umgebung anzupassen, um zu erhalten (zu überleben)</a></li>
<li><a href="../de485746/index.html">4. Plattform fährt vom verwendeten Server ab</a></li>
<li><a href="../de485748/index.html">Optionale Verkettung, Vereinigung mit Null und wie sie unsere Herangehensweise beim Schreiben von Code ändern</a></li>
<li><a href="../de485764/index.html">React Token Auth</a></li>
<li><a href="../de485766/index.html">Fütterungsregeln</a></li>
<li><a href="../de485768/index.html">2020 Web-Trends sind es wert, ausprobiert zu werden</a></li>
<li><a href="../de485770/index.html">Falsche Polemik</a></li>
<li><a href="../de485772/index.html">Vom Desktop zum virtuellen Rechenzentrum - wie wir zur Virtualisierung gekommen sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>