<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÅ üíª üë©üèø‚Äçüç≥ Erweiterungen in Kotlin. Gef√§hrlicher Atavismus oder n√ºtzliches Werkzeug? üìÄ üÜö üë®üèæ‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin ist noch eine junge Sprache, hat aber bereits Einzug gehalten. Aus diesem Grund ist nicht immer klar, wie dieses oder jenes Funktionsmerkmal ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erweiterungen in Kotlin. Gef√§hrlicher Atavismus oder n√ºtzliches Werkzeug?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/485760/"><img src="https://habrastorage.org/webt/kz/wk/5d/kzwk5d50usqqdehsvqpkpzmkogg.jpeg"><br><br>  Kotlin ist noch eine junge Sprache, hat aber bereits Einzug gehalten.  Aus diesem Grund ist nicht immer klar, wie dieses oder jenes Funktionsmerkmal korrekt implementiert werden soll und welche bew√§hrten Methoden angewendet werden sollen. <br><br>  Besonders schwierig ist der Fall bei den F√§higkeiten der Sprache, die nicht in Java sind.  Einer dieser Stolpersteine ‚Äã‚Äãwar die <a href="https://kotlinlang.org/docs/reference/extensions.html">Expansion</a> . <br><br>  Dies ist ein praktisches Tool, mit dem der Code besser lesbar ist und f√ºr das fast nichts zur√ºckgegeben werden muss.  Gleichzeitig kenne ich aber mindestens einen Menschen, der, wenn er Expansion nicht als b√∂se ansieht, diesen durchaus skeptisch gegen√ºbersteht.  Im Folgenden m√∂chte ich die Merkmale dieses Mechanismus er√∂rtern, die zu Kontroversen und Missverst√§ndnissen f√ºhren k√∂nnen. <br><a name="habracut"></a><br><h3>  Erweiterungen zu DTO - Versto√ü gegen die Daten√ºbertragungsobjektvorlage </h3><br>  Zum Beispiel gibt es eine Klasse User <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String)</code> </pre> <br>  Ein ziemlicher DTO!  Ferner ist in dem Code an mehreren Stellen eine √úberpr√ºfung erforderlich, um festzustellen, ob der Benutzer ein Erwachsener ist.  Am einfachsten ist es, an allen Stellen eine Bedingung zu stellen <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) { ... }</code> </pre><br>  Da es jedoch beliebig viele solcher Stellen geben kann, ist es sinnvoll, diese Pr√ºfung in die Methode aufzunehmen. <br>  Hier gibt es drei M√∂glichkeiten: <br><br><ol><li>  Funktionsspa√ü isAdult (Benutzer: Benutzer) - Dienstprogrammklassen bestehen normalerweise aus solchen Funktionen. <br></li><li>  F√ºgen Sie die isAdult-Funktion in die User-Klasse ein <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> }</code> </pre><br></li><li>  Schreiben Sie einen Wrapper f√ºr User, der √§hnliche Funktionen enth√§lt. <br></li></ol><br>  Alle drei Optionen sind technisch lebensberechtigt.  Der erste Nachteil besteht jedoch darin, dass alle Utility-Funktionen bekannt sein m√ºssen, obwohl dies nat√ºrlich kein gro√ües Problem darstellt. <br>  Die zweite Option scheint das Daten√ºbertragungsobjektmuster zu verletzen, da es sich bei der Klasse nicht nur um Getter und Setter handelt.  Aber Muster zu brechen ist schlecht. <br><br>  Die dritte Option verst√∂√üt weder gegen die Prinzipien von OOP noch gegen Vorlagen. Sie m√ºssen jedoch jedes Mal einen Wrapper erstellen, wenn Sie √§hnliche Funktionen verwenden m√∂chten.  Diese Option ist auch nicht sehr beliebt.  Am Ende stellt sich heraus, dass Sie noch Opfer bringen m√ºssen. <br><br>  Meiner Meinung nach ist es einfacher, eine DTO-Vorlage zu opfern.  Erstens habe ich keine einzige Erkl√§rung daf√ºr gefunden, warum Funktionen (mit Ausnahme von Gettern und Setzern) nicht im DTO erstellt werden k√∂nnen.  Und zweitens ist ein solcher Code nur in Bezug auf die Bedeutung bequem neben den Daten zu haben, mit denen wir arbeiten. <br><br>  Es ist jedoch nicht immer m√∂glich, einen solchen Code in den DTO-Shek einzuf√ºgen, da der Entwickler nicht immer die M√∂glichkeit hat, die Klassen zu bearbeiten, mit denen er arbeitet.  Dies k√∂nnen beispielsweise Klassen sein, die aus xsd generiert wurden.  Dar√ºber hinaus kann es f√ºr jemanden ungew√∂hnlich und unangenehm sein, solchen Code in Datenklassen zu schreiben.  Kotlin bietet f√ºr solche Situationen eine L√∂sung in Form von Funktionen und Erweiterungsfeldern: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Dieser Code kann so verwendet werden, als ob er in der Benutzerklasse deklariert w√§re: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user.isAdult()) {...}</code> </pre><br>  Das Ergebnis ist eine ziemlich genaue L√∂sung, die mit dem geringsten Kompromiss unsere Anforderungen erf√ºllt.  Wenn wir √ºber die Tatsache sprechen, dass die DTO-Vorlage verletzt wird, m√∂chten wir daran erinnern, dass es sich in Java um eine regul√§re statische Methode des Formulars handelt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull User receiver)</span></span></span></span></code> </pre><br>  Wie Sie sehen, wird formal auch die Vorlage nicht verletzt.  Die Verwendung dieser Funktion sieht so aus, als ob sie in User deklariert wurde, und Idea bietet sie in automatischer Vervollst√§ndigung an.  Es ist sehr bequem. <br><br><h3>  Erweiterungen sind spezifisch.  Sie k√∂nnen nicht √ºber deren Existenz Bescheid wissen und Methoden und Felder der Entit√§t mit Erweiterungen verwechseln </h3><br>  Die Idee ist, dass der Entwickler zu dem Projekt gekommen ist und in Bezug auf den Code, der in Erweiterungen implementiert ist, nicht klar ist, welche Methode original ist und welche die Erweiterungsmethode ist. <br><br>  Dies ist kein Problem, da Idea dem Entwickler in dieser Angelegenheit hilft und solche Funktionen hervorhebt.  Obwohl fairerweise gesagt werden muss, dass der Unterschied im Darcula-Thema besser erkennbar ist.  Wenn Sie es in Light √§ndern, wird alles weniger offensichtlich und die Erweiterung unterscheidet sich nur in kursiver Schrift. <br><br>  Unten sehen wir ein Beispiel f√ºr den Aufruf von zwei Methoden: isAdult ist die Erweiterungsmethode, isMale ist die √ºbliche Methode innerhalb der User-Klasse.  Der Screenshot links zeigt das Darcula-Thema, rechts das √ºbliche Light-Thema. <br><br><img src="https://habrastorage.org/webt/qr/yx/j2/qryxj2ld3i7pyphvqsqd05njozi.png"><img src="https://habrastorage.org/webt/ik/ro/ed/ikroeddsainpwwaevfjjounzeva.png"><br><br>  Etwas schlimmer ist es mit den Feldern.  Wenn wir uns zum Beispiel daf√ºr entscheiden, isAdult als Erweiterungsfeld zu implementieren, k√∂nnen wir es nur nach Schriftart von einem regul√§ren Feld unterscheiden.  In diesem Beispiel ist name ein regul√§res Feld.  Ein Erweiterungsfeld erzeugt nur Kursivschrift. <br><br><img src="https://habrastorage.org/webt/bt/w1/ej/btw1ejdtlclzohkqlucw8pfpihq.png"><img src="https://habrastorage.org/webt/bz/ok/ux/bzokuxqd_-bykhju0gylzq-g2wq.png"><br><br>  Mithilfe der Idea-Entwicklungsumgebung k√∂nnen Sie ermitteln, welche Methode eine Erweiterung ist und welche beim automatischen Vervollst√§ndigen das Original ist.  Das ist bequem. <br><br><img src="https://habrastorage.org/webt/7v/be/oe/7vbeoe1s9093-wjgwv5piavux1w.png"><br><br>  √Ñhnlich ist die Situation bei Feldern. <br><br><img src="https://habrastorage.org/webt/za/0q/jk/za0qjkyxmk94k8khz0atanwusgo.png"><br><br>  "F√ºr Benutzer in &lt;root&gt;" bedeutet, dass es sich um eine Erweiterung handelt. <br><br>  Die Tatsache, dass Idea eine Erweiterung an eine erweiterbare Entit√§t ‚Äûbindet‚Äú, tr√§gt au√üerdem erheblich zur Entwicklung bei, da Erweiterungsmethoden und -felder f√ºr die automatische Vervollst√§ndigung vorgeschlagen werden. <br><br><h3>  Erweiterungen sind √ºber das gesamte Projekt verteilt und bilden eine M√ºlltonne </h3><br>  Wir haben kein solches Problem bei Projekten, da wir keine willk√ºrlichen Erweiterungen einf√ºgen und Code mit √∂ffentlichen Erweiterungen in separaten Dateien oder Paketen entfernen. <br><br>  Beispielsweise k√∂nnte die Funktion isAdult aus dem obigen Beispiel in der Benutzerdatei des Erweiterungspakets angezeigt werden.  Wenn das Paket nicht ausreicht und Sie nur nicht verwechseln m√∂chten, wo sich die Klasse befindet und wo sich die Funktionsdatei befindet, k√∂nnen Sie sie beispielsweise _User.kt nennen.  So auch die Entwickler von JetBrains f√ºr Kollektionen.  Wenn das Gewissen das Starten der Datei mit einem Unterstrich verbietet, k√∂nnen Sie user.kt aufrufen.  Tats√§chlich gibt es keinen Unterschied in der Art und Weise, die Hauptsache ist, dass es eine Einheitlichkeit gibt, an der das gesamte Team festh√§lt. <br><br>  Die Ersteller der Sprache haben sie bei der Entwicklung von Erweiterungsmethoden f√ºr Sammlungen in die Datei <a href="">_Collections.kt eingef√ºgt</a> . <br><br>  Hierbei handelt es sich im Allgemeinen um die Organisation des Codes, nicht um das Problem von Erweiterungen.  Statische Funktionen in Java und nicht nur statische Funktionen k√∂nnen nicht weniger zuf√§llig verteilt werden als Erweiterungen. <br><br><h3>  √úbersehen Sie w√§hrend des Ger√§tetests nicht die Erweiterungsfunktionen </h3><br>  Meiner Meinung nach besteht keine Notwendigkeit, Funktionen von Erweiterungen zu benetzen, genauso wie es keine Notwendigkeit gibt, statische Methoden zu benetzen.  In der Erweiterungsfunktion sollten Sie die Logik des Arbeitens mit vorhandenen Daten einf√ºgen.  Im Fall der isAdult-Funktion f√ºr die User-Klasse befindet sich beispielsweise alles, was Sie ben√∂tigen, in isAdult.  Sie m√ºssen nicht nass werden. <br><br>  Betrachten Sie ein etwas komplexeres Beispiel.  Es gibt eine bestimmte Komponente, die dazu dient, Benutzer von einem externen System abzurufen - UserComponent.  Die Methode zum Abrufen von Benutzern hei√üt getUsers.  Angenommen, es mussten alle aktiven Benutzer abgerufen werden, und es wurde beschlossen, eine Filterlogik in Form einer Funktion - einer Erweiterung - hinzuzuf√ºgen.  Als Ergebnis haben wir die Funktion: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> UserComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActiveUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Users&gt; = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().filter{it.status == ‚ÄúActive‚Äù}</code> </pre><br>  Es mag so aussehen, als ob es sich um eine Situation handelt, in der Sie einen Schein f√ºr eine Erweiterung ben√∂tigen.  Wenn Sie sich jedoch daran erinnern, dass getActiveUsers nur eine statische Methode ist, stellt sich heraus, dass kein Mock ben√∂tigt wird.  Dip sollte die Methoden und Funktionen sein, die in der Erweiterung aufgerufen werden, und nicht mehr. <br><br><h3>  Es ist m√∂glich, dass sich die Erweiterungsfunktion mit der gleichnamigen Funktion innerhalb der erweiterten Klasse √ºberschneidet </h3><br>  Wir werden diesen Fall anhand des Beispiels aus dem ersten Absatz betrachten.  Angenommen, es gibt eine Funktionserweiterung isAdult, die √ºberpr√ºft, ob der Benutzer ein Erwachsener ist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Danach implementieren wir die gleichnamige Funktion in User: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> }</code> </pre><br>  Wenn user.isAdult () aufgerufen wird, wird eine Funktion aus der Klasse aufgerufen, obwohl es eine gleichnamige Erweiterung und eine geeignete Funktion gibt.  Ein solcher Fall kann verwirrend sein, da Benutzer, die die in der Klasse deklarierte Funktion nicht kennen, auf den Abschluss der Erweiterungsfunktion warten.  Dies ist eine unangenehme Situation, die √§u√üerst schwerwiegende Folgen haben kann.  In diesem Fall geht es nicht um die m√∂gliche Unannehmlichkeit einer √úberpr√ºfung oder einer Vorlagenverletzung, sondern um das m√∂glicherweise fehlerhafte Verhalten des Codes. <br><br>  Die oben beschriebene Situation zeigt, dass bei Verwendung der Erweiterungsfunktionen echte Probleme auftreten k√∂nnen. <br><br>  Um dies zu vermeiden, sollten Sie nicht vergessen, die Erweiterungsfunktionen so weit wie m√∂glich mit Unit-Tests abzudecken.  Im schlimmsten Fall, wenn die Tests fehlschlagen, gibt es zwei Funktionen, die auf die gleiche Weise funktionieren.  Einer ist eine Erweiterung und der andere ist in der Klasse selbst.  Wenn die Tests fehlschlagen, wird darauf hingewiesen, dass eine Funktion eine andere √ºberlappt. <br><br><h3>  Die Erweiterung ist an eine Klasse und nicht an ein Objekt gebunden, was zu Verwirrung f√ºhren kann </h3><br>  Betrachten Sie beispielsweise die Benutzerklasse aus dem ersten Absatz.  Lassen Sie uns es √∂ffnen und seinen Nachfolger Student erstellen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span></span>(name: String, age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sex: String): User(name, age, sex)</code> </pre><br>  Wir definieren die Erweiterungsfunktion f√ºr Student, die auch bestimmt, ob der Student ein Erwachsener ist oder nicht.  Nur f√ºr den Sch√ºler √§ndern wir die Bedingung: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Student.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age &gt;= <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  Und jetzt schreiben wir den folgenden Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user: User = Student(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-string"><span class="hljs-string">"M"</span></span>)</code> </pre><br>  Was gibt user.isAdult ()) zur√ºck? <br>  Es scheint, dass ein Objekt vom Typ Student und die Funktion true zur√ºckgeben sollten.  Aber es ist nicht so einfach.  Erweiterungen werden an die Klasse angeh√§ngt, nicht an das Objekt, und das Ergebnis ist falsch. <br><br>  Wenn wir uns daran erinnern, dass Erweiterungen statische Methoden sind und eine erweiterbare Entit√§t der erste Parameter in dieser Methode ist, ist dies nichts Seltsames.  Dies ist ein weiterer Punkt, den Sie bei der Verwendung dieses Mechanismus ber√ºcksichtigen sollten.  Andernfalls k√∂nnen Sie einen unangenehmen und unerwarteten Effekt erzielen. <br><br><h3>  Anstelle der Ausgabe </h3><br>  Diese kontroversen Punkte scheinen nicht gef√§hrlich zu sein, wenn Sie sich daran erinnern, dass wir Extension sagen - wir meinen eine statische Methode.  Wenn Sie diese Funktionen mit Komponententests abdecken, k√∂nnen Sie au√üerdem m√∂gliche Unklarheiten im Zusammenhang mit der statischen Natur von Erweiterungen minimieren. <br><br>  Meiner Meinung nach sind Erweiterungen ein leistungsstarkes und praktisches Tool, mit dem sich die Qualit√§t und Lesbarkeit des Codes verbessern l√§sst, ohne dass daf√ºr fast nichts erforderlich ist.  Deshalb liebe ich sie: <br><br><ul><li>  Mit Erweiterungen k√∂nnen Sie Logik schreiben, die f√ºr den Kontext einer erweiterbaren Klasse spezifisch ist.  Dank dessen werden die Felder und Erweiterungsmethoden so gelesen, als w√§ren sie immer in der erweiterten Entit√§t vorhanden, was wiederum das Verst√§ndnis des Codes auf oberster Ebene verbessert.  In Java ist dies leider nicht m√∂glich.  Dar√ºber hinaus haben Erweiterungen dieselben Zugriffsmodifikatoren wie regul√§re Funktionen.  Auf diese Weise k√∂nnen Sie √§hnlichen Code mit dem G√ºltigkeitsbereich schreiben, der f√ºr eine bestimmte Funktion wirklich erforderlich ist. <br></li><li>  Es ist praktisch, die Erweiterungsfunktionen f√ºr das Mapping zu verwenden, die Sie bei der L√∂sung allt√§glicher Aufgaben oft sehen m√ºssen.  Zum Beispiel gibt es im Projekt eine Klasse UserFromExternalSystem, die beim Aufrufen eines externen Systems verwendet wird, und es w√§re gro√üartig, das Mapping in die Erweiterungsfunktion einzuf√ºgen, es zu vergessen und es so zu verwenden, als ob es urspr√ºnglich in User w√§re. <br><br><pre> <code class="kotlin hljs">callExternalSystem(user.getUserFromExternalSystem())</code> </pre><br>  Das gleiche kann nat√ºrlich mit der √ºblichen Methode gemacht werden, aber diese Option ist weniger lesbar: <br><br><pre> <code class="kotlin hljs">callExternalSystem(getUserFromExternalSystem(user))</code> </pre><br>  oder eine solche Option: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> externalUser = getUserFromExternalSystem(user) callExternalSystem(externalUser)</code> </pre><br>  Tats√§chlich passiert keine Magie, aber dank solcher Kleinigkeiten ist es angenehmer, mit dem Code zu arbeiten. <br></li><li>  Unterst√ºtzung f√ºr Idee und automatische Vervollst√§ndigung.  Im Gegensatz zu Methoden aus Utility-Klassen werden Erweiterungen von der Entwicklungsumgebung gut unterst√ºtzt.  Bei der automatischen Vervollst√§ndigung werden Erweiterungen von der Umgebung als "native" Funktionen und Felder angeboten.  Dies erm√∂glicht eine gute Steigerung der Entwicklerproduktivit√§t. <br></li><li>  F√ºr Erweiterungen spricht, dass ein Gro√üteil der Kotlin-Bibliotheken als Erweiterungen geschrieben ist.  Viele praktische und beliebte Methoden zum Arbeiten mit Sammlungen sind Erweiterungen (Filter, Map usw.).  Sie k√∂nnen dies √ºberpr√ºfen, indem Sie die Datei <a href="">_Collections.kt untersuchen</a> . <br></li></ul><br>  Vorteile von Erweiterungen decken m√∂gliche Nachteile ab.  Nat√ºrlich besteht die Gefahr eines Missbrauchs dieses Mechanismus und der Versuchung, den gesamten Code in Erweiterungen zu packen.  Hier geht es aber eher um die Organisation des Codes und den kompetenten Umgang mit dem Tool.  Bei korrekter Verwendung werden Erweiterungen zu einem echten Freund und Helfer beim Schreiben von gut gelesenem und gepflegtem Code. <br><br>  Unten finden Sie Links zu Materialien, die zur Vorbereitung dieses Artikels verwendet wurden: <br><br><ol><li>  <a href="https://proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff">proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff</a> - hier werden interessante Gedanken dar√ºber aufgegriffen, dass wir mithilfe von Erweiterungen enger mit dem Kontext arbeiten. <br></li><li>  <a href="https://www.nikialeksey.com/2017/11/14/kotlin-is-bad.html">www.nikialeksey.com/2017/11/14/kotlin-is-bad.html</a> - hier lehnt der Autor Erweiterungen ab und gibt ein interessantes Beispiel, das in einem der obigen Punkte diskutiert wird. <br></li><li>  <a href="https://medium.com/%40elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a">medium.com/@elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a</a> - Roman Elizarovs Meinung zur Benetzung von Extensionsmethoden. <br></li></ol><br>  Ich m√∂chte mich auch bei Kollegen bedanken, die mit interessanten F√§llen und Gedanken zu diesem Material geholfen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485760/">https://habr.com/ru/post/de485760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485738/index.html">Security Week 05: Kritische Schwachstellen von Medizinprodukten</a></li>
<li><a href="../de485742/index.html">Wie wir das Adressverzeichnis von Rostelecom erstellt haben</a></li>
<li><a href="../de485744/index.html">Intelligenz - die F√§higkeit eines Objekts, sein Verhalten an die Umgebung anzupassen, um zu erhalten (zu √ºberleben)</a></li>
<li><a href="../de485746/index.html">4. Plattform f√§hrt vom verwendeten Server ab</a></li>
<li><a href="../de485748/index.html">Optionale Verkettung, Vereinigung mit Null und wie sie unsere Herangehensweise beim Schreiben von Code √§ndern</a></li>
<li><a href="../de485764/index.html">React Token Auth</a></li>
<li><a href="../de485766/index.html">F√ºtterungsregeln</a></li>
<li><a href="../de485768/index.html">2020 Web-Trends sind es wert, ausprobiert zu werden</a></li>
<li><a href="../de485770/index.html">Falsche Polemik</a></li>
<li><a href="../de485772/index.html">Vom Desktop zum virtuellen Rechenzentrum - wie wir zur Virtualisierung gekommen sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>