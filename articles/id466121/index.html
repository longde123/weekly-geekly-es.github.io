<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😕 📵 📰 Pembuatan suara pada mikrokontroler AVR menggunakan metode wavetable dengan dukungan polifoni 🦇 👨🏻‍🎨 🌐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mikrokontroler AVR cukup murah dan tersebar luas. Mungkin, hampir semua pengembang tertanam mulai dengan mereka. Dan di antara para amatir, Arduino me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan suara pada mikrokontroler AVR menggunakan metode wavetable dengan dukungan polifoni</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/">  Mikrokontroler AVR cukup murah dan tersebar luas.  Mungkin, hampir semua pengembang tertanam mulai dengan mereka.  Dan di antara para amatir, Arduino menguasai bola, yang hatinya biasanya ATmega328p.  Tentunya banyak yang bertanya-tanya: bagaimana Anda bisa membuatnya terdengar? <br><br>  Jika Anda melihat proyek yang ada, ada beberapa jenis: <br><br><ol><li>  Generator pulsa persegi.  Hasilkan menggunakan PWM atau pin yank dalam interupsi.  Bagaimanapun, suara mencicit yang sangat khas diperoleh. </li><li>  Menggunakan peralatan eksternal seperti dekoder MP3. </li><li>  Menggunakan PWM untuk menghasilkan suara 8 bit (kadang-kadang 16 bit) dalam format PCM atau ADPCM.  Karena memori dalam mikrokontroler jelas tidak cukup untuk ini, mereka biasanya menggunakan kartu SD. </li><li>  Menggunakan PWM untuk menghasilkan suara berdasarkan tabel gelombang seperti MIDI. </li></ol><br>  Jenis yang terakhir ini sangat menarik bagi saya, karena  hampir tidak memerlukan peralatan tambahan.  Saya menyajikan opsi saya kepada komunitas.  Pertama, demo kecil: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Tertarik, saya minta kucing. <br><a name="habracut"></a><br>  Jadi, peralatannya: <br><br><ul><li>  ATmega8 atau ATmega328.  Porting ke ATmega lain tidak sulit.  Dan bahkan pada ATtiny, tetapi lebih lanjut tentang itu nanti; </li><li>  Resistor; </li><li>  Kapasitor; </li><li>  Speaker atau headphone; </li><li>  Nutrisi; </li></ul><br>  Suka semuanya. <br><br>  Sirkuit RC sederhana dengan speaker terhubung ke output mikrokontroler.  Outputnya adalah suara 8-bit dengan frekuensi sampling 31250Hz.  Pada frekuensi kristal 8 MHz, hingga 5 saluran suara + satu saluran derau untuk perkusi dapat dihasilkan.  Ia menggunakan hampir seluruh waktu prosesor, tetapi setelah mengisi buffer, prosesor dapat diisi dengan sesuatu yang berguna selain suara: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Contoh ini sangat cocok dengan memori ATmega8, 5 saluran + noise diproses pada frekuensi kristal 8 MHz dan ada sedikit waktu untuk animasi di layar. <br><br>  Dalam contoh ini, saya juga ingin menunjukkan bahwa perpustakaan dapat digunakan tidak hanya sebagai kartu pos musik biasa, tetapi juga untuk menghubungkan suara ke proyek yang ada, misalnya, untuk pemberitahuan.  Dan bahkan ketika menggunakan hanya satu saluran suara, notifikasi dapat jauh lebih menarik daripada tweeter sederhana. <br><br>  Dan sekarang detailnya ... <br><br><h2>  Tabel gelombang atau tabel gelombang </h2><br>  Matematika itu sangat sederhana.  Ada fungsi nada periodik, misalnya <i>nada (t) = sin (t * freq / (2 * Pi))</i> . <br><br>  Ada juga fungsi untuk mengubah volume nada fundamental dari waktu ke waktu, misalnya <i>volume (t) = e ^ (- t)</i> . <br><br>  Dalam kasus yang paling sederhana, bunyi suatu instrumen adalah produk dari <i>instrumen</i> fungsi ini <i>(t) = nada (t) * volume (t)</i> : <br><br>  Pada bagan, semuanya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br><br>  Selanjutnya, kami mengambil semua instrumen yang terdengar pada waktu tertentu dan merangkumnya dengan beberapa faktor volume (kode semu): <br><br><pre><code class="cmake hljs">for (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CHANNELS; i++) { value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume; }</code> </pre> <br>  Hanya perlu memilih volume sehingga tidak ada luapan.  Dan itu hampir semuanya. <br><br>  Saluran noise bekerja dengan cara yang hampir sama, tetapi alih-alih fungsi nada, generator urutan pseudo-acak. <br><br>  Perkusi adalah campuran saluran noise dan gelombang frekuensi rendah, sekitar 50-70 Hz. <br>  Tentu saja, suara berkualitas tinggi dengan cara ini sulit dicapai.  Tapi kami hanya punya 8 kilobyte untuk semuanya.  Semoga ini bisa dimaafkan. <br><br><h2>  Apa yang bisa saya peras dari 8 bit </h2><br>  Awalnya, saya fokus pada ATmega8.  Tanpa kuarsa eksternal, beroperasi pada frekuensi 8 MHz dan memiliki PWM 8-bit, yang memberikan frekuensi sampling dasar 8000000/256 = 31250 Hz.  Satu timer menggunakan PWM untuk mengeluarkan suara, dan menyebabkan gangguan selama overflow untuk mengirimkan nilai berikutnya ke generator PWM.  Oleh karena itu, kami memiliki 256 siklus untuk menghitung nilai sampel untuk semuanya, termasuk interupsi overhead, memperbarui parameter saluran suara, melacak waktu ketika Anda perlu memainkan nada berikutnya, dll. <br><br>  Untuk optimasi, kami akan secara aktif menggunakan trik berikut: <br><br><ul><li>  Karena kami memiliki prosesor delapan bit, kami akan mencoba membuat variabel yang sama.  Terkadang kita akan menggunakan 16 bit. </li><li>  Perhitungan secara kondisional dibagi menjadi sering dan tidak demikian.  Yang pertama perlu dihitung untuk setiap sampel, yang kedua - jauh lebih jarang, sekali setiap beberapa puluh / ratusan sampel. </li><li>  Untuk mendistribusikan beban secara merata, kami menggunakan buffer bundar.  Di loop utama program, kami mengisi buffer, kurangi di interrupt.  Jika semuanya baik-baik saja, maka buffer mengisi lebih cepat daripada yang dikosongkan dan kita punya waktu untuk sesuatu yang lain. </li><li>  Kode ditulis dalam C dengan banyak inline.  Latihan menunjukkan bahwa itu jauh lebih cepat. </li><li>  Semua itu dapat dihitung oleh preprocessor, terutama dengan partisipasi divisi, dilakukan oleh preprocessor. </li></ul><br>  Pertama, bagi waktu menjadi interval 4 milidetik (saya menyebutnya kutu).  Pada frekuensi sampling 31250Hz, kami mendapatkan 125 sampel per tick.  Fakta bahwa setiap sampel harus dibaca harus dihitung setiap sampel, dan sisanya - sekali per centang atau kurang.  Misalnya, dalam satu centang, volume instrumen akan konstan: <i>instrumen (t) = nada (t) * currentVolume</i> ;  dan currentVolume itu sendiri akan dihitung ulang sekali per centang dengan memperhitungkan volume akun (t) dan volume yang dipilih dari saluran suara. <br><br>  Durasi tick dari 4ms dipilih berdasarkan batas 8-bit sederhana: dengan penghitung sampel delapan-bit, Anda dapat bekerja dengan frekuensi sampling hingga 64 kHz, dengan penghitung centang delapan-bit kita dapat mengukur waktu hingga 1 detik. <br><br><h2>  Beberapa kode </h2><br>  Saluran itu sendiri dijelaskan oleh struktur ini: <br><br><pre> <code class="cmake hljs">typedef struct { // Info about wave const int8_t* waveForm; // Wave table array uint16_t waveSample; // High byte is an index in waveForm array uint16_t waveStep; // Frequency, how waveSample is changed in time // Info about volume envelope const uint8_t* volumeForm; // Array of volume change in time uint8_t volumeFormLength; // Length of volumeForm uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample // Info about volume uint8_t currentVolume; // Precalculated volume for current tick uint8_t instrumentVolume; // Volume of channel } waveChannel;</code> </pre> <br>  Secara kondisional, data di sini dibagi menjadi 3 bagian: <br><br><ol><li>  Informasi tentang bentuk gelombang, fase, frekuensi. <br><br>  waveForm: informasi tentang fungsi nada (t): referensi ke array dengan panjang 256 byte.  Mengatur nada, suara instrumen. <br><br>  waveSample: byte tinggi menunjukkan indeks array waveForm saat ini. <br><br>  waveStep: mengatur frekuensi di mana waveSample akan ditingkatkan saat menghitung sampel berikutnya. <br><br>  Setiap sampel dianggap seperti ini: <br><br><pre> <code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>]; channelData.waveSample += channelaData.waveStep; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tone * channelData.currentVolume;</code> </pre> <br></li><li>  Informasi volume.  Mengatur fungsi perubahan volume seiring waktu.  Karena volume tidak terlalu sering berubah, Anda dapat menghitungnya lebih jarang, sekali per centang.  Ini dilakukan seperti ini: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample; channel-&gt;volumeFormLength--; channel-&gt;volumeForm++; } channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br></li><li>  Setel volume saluran dan volume saat ini yang dihitung. <br></li></ol><br>  Harap dicatat: bentuk gelombang adalah delapan-bit, volumenya juga delapan-bit, dan hasilnya adalah 16-bit.  Dengan sedikit kehilangan kinerja, Anda dapat membuat suara (hampir) 16 bit. <br><br>  Dalam perjuangan untuk produktivitas, saya harus menggunakan sihir hitam. <br><br>  Contoh nomor 1. Cara menghitung ulang volume saluran: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tickSampleCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //    tickSampleCounter = SAMPLES_PER_TICK – <span class="hljs-number"><span class="hljs-number">1</span></span>; //   - } // volume recalculation should no be done so often for all channels <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickSampleCounter &lt; CHANNELS_SIZE) { recalculateVolume(channels[tickSampleCounter]); }</code> </pre> <br>  Dengan demikian, semua saluran menghitung volume sekali per centang, tetapi tidak secara bersamaan. <br><br>  Contoh nomor 2. Menyimpan informasi saluran dalam struktur statis lebih murah daripada dalam array.  Tanpa merinci implementasi wavechannel.h, saya akan mengatakan bahwa file ini dimasukkan ke dalam kode beberapa kali (sama dengan jumlah saluran) dengan arahan preprosesor yang berbeda.  Setiap sisipan membuat variabel global baru dan fungsi penghitungan saluran baru, yang kemudian dimasukkan ke dalam kode utama: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1 val += channel0NextSample(); #endif #if CHANNELS_SIZE &gt;= 2 val += channel1NextSample(); #endif …</span></span></code> </pre><br>  Contoh nomor 3. Jika kita mulai memainkan not berikutnya sedikit kemudian, maka tidak ada yang akan memperhatikan.  Mari kita bayangkan situasinya: kita mengambil prosesor dengan sesuatu dan selama ini buffer hampir kosong.  Kemudian kita mulai mengisinya dan tiba-tiba ternyata ada ukuran baru: kita perlu memperbarui catatan saat ini, membaca dari array apa selanjutnya, dll.  Jika kita tidak punya waktu, maka akan ada ciri kegagapan.  Adalah jauh lebih baik untuk mengisi buffer sedikit dengan data lama, dan hanya kemudian memperbarui keadaan saluran. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((samplesToWrite) &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { //          fillBuffer(SAMPLES_PER_TICK); //     -  updateMusicData(); //    }</code> </pre> <br>  Dengan cara yang baik, perlu untuk mengisi ulang buffer setelah loop, tetapi karena kita memiliki hampir semuanya inline, ukuran kode terasa meningkat. <br><br><h2>  Musik </h2><br>  Pencatat centang delapan bit digunakan.  Ketika nol tercapai, ukuran baru dimulai, penghitung diberikan durasi pengukuran (dalam kutu), sedikit kemudian array perintah musik diperiksa. <br><br>  Data musik disimpan dalam array byte.  Ada tertulis seperti ini: <br><br><pre> <code class="cmake hljs">const uint8_t demoSample[] PROGMEM = { DATA_TEMPO(<span class="hljs-number"><span class="hljs-number">160</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> beats per minute DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_PLAY(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOTE_A4, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A4 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_PLAY(<span class="hljs-number"><span class="hljs-number">1</span></span>, NOTE_A3, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_WAIT(<span class="hljs-number"><span class="hljs-number">63</span></span>), // Wait <span class="hljs-number"><span class="hljs-number">63</span></span> beats DATA_END() // End of data stream };</code> </pre> <br>  Semua yang dimulai dengan DATA_ adalah macro preprocessor yang memperluas parameter ke jumlah byte data yang diperlukan. <br><br>  Misalnya, perintah DATA_PLAY diperluas menjadi 2 byte, di mana disimpan: penanda perintah (1 bit), jeda sebelum perintah berikutnya (3 bit), nomor saluran tempat memainkan not (4 bit), informasi tentang not (8 bit).  Keterbatasan yang paling signifikan adalah bahwa perintah ini tidak dapat digunakan untuk jeda panjang, dengan maksimum 7 langkah.  Jika Anda membutuhkan lebih banyak, maka Anda perlu menggunakan perintah DATA_WAIT (hingga 63 tindakan).  Sayangnya, saya tidak menemukan apakah makro dapat diperluas ke jumlah byte array yang berbeda tergantung pada parameter makro.  Dan bahkan peringatan saya tidak tahu cara menampilkan.  Mungkin Anda memberi tahu saya. <br><br><h2>  Gunakan </h2><br>  Dalam direktori demo ada beberapa contoh untuk mikrokontroler yang berbeda.  Namun singkatnya, ini adalah bagian dari readme, saya benar-benar tidak perlu menambahkan: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h" #include "../../microsound/micromusic.h" // Make some settings #define CHANNELS_SIZE 5 #define SAMPLES_SIZE 16 #define USE_NOISE_CHANNEL initMusic(); // Init music data and sound control sei(); // Enable interrupts, silence sound should be generated setSample(0, instrument1); // Use instrument1 as sample 0 setSample(1, instrument2); // Init all other instruments… playMusic(mySong); // Start playing music at pointer mySong while (!isMusicStopped) { fillMusicBuffer(); // Fill music buffer in loop // Do some other stuff }</span></span></code> </pre> <br>  Jika Anda ingin melakukan hal lain selain musik, maka Anda dapat menambah ukuran buffer menggunakan BUFFER_SIZE.  Ukuran buffer harus 2 ^ n, tetapi, sayangnya, dengan ukuran 256, terjadi penurunan kinerja.  Sampai saya menemukan jawabannya. <br><br>  Untuk meningkatkan produktivitas, Anda dapat meningkatkan frekuensi dengan kuarsa eksternal, Anda dapat mengurangi jumlah saluran, Anda dapat mengurangi frekuensi pengambilan sampel.  Dengan trik terakhir, Anda dapat menggunakan interpolasi linier, yang agak mengompensasi penurunan kualitas suara. <br><br>  Penundaan tidak disarankan, karena  Waktu CPU terbuang sia-sia.  Sebagai gantinya, metode sendiri diimplementasikan dalam file <i>microsound / delay.h</i> , yang, selain jeda itu sendiri, terlibat dalam mengisi buffer.  Metode ini mungkin tidak bekerja dengan sangat akurat pada jeda pendek, tetapi pada jeda panjang lebih atau kurang waras. <br><br><h2>  Buat musik Anda sendiri </h2><br>  Jika Anda menulis perintah secara manual, Anda harus dapat mendengarkan apa yang terjadi.  Menuangkan setiap perubahan ke dalam mikrokontroler tidak nyaman, terutama jika ada alternatif. <br><br>  Ada layanan yang agak lucu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wavepot.com</a> - editor JavaScript online di mana Anda perlu mengatur fungsi sinyal suara dari waktu ke waktu, dan sinyal ini adalah output ke kartu suara.  Contoh paling sederhana: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dsp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * t * <span class="hljs-number"><span class="hljs-number">440</span></span>); }</code> </pre> <br>  Saya porting mesin ke JavaScript, itu terletak di <i>demo / wavepot.js</i> .  Isi file harus dimasukkan dalam editor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wavepot.com</a> dan Anda dapat melakukan percobaan.  Kami menulis data kami ke array soundData, dengarkan, jangan lupa untuk menyimpan. <br><br>  Kita juga harus menyebutkan variabel simulate8bits.  Dia, sesuai namanya, mensimulasikan suara delapan-bit.  Jika tiba-tiba terlihat bahwa drum berdengung, dan suara muncul dalam instrumen yang basah dengan suara yang tenang, maka inilah dia, sebuah distorsi dari suara delapan-bit.  Anda dapat mencoba menonaktifkan opsi ini dan mendengarkan perbedaannya.  Masalahnya kurang terlihat jika tidak ada keheningan dalam musik. <br><br><h2>  Koneksi </h2><br>  Dalam versi sederhana, rangkaiannya terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VC | R1 | Pin+---/\/\--+-----&gt; OUT | | | +---+GN | === C1 | +-------+ | | | --- Grnd --- Grnd</code> </pre> <br>  Pin output tergantung pada mikrokontroler.  Resistor R1 dan kapasitor C1 harus dipilih berdasarkan pada beban, penguat (jika ada), dll.  Saya bukan seorang insinyur elektronik dan saya tidak akan memberikan formula, mereka mudah di-google bersama dengan kalkulator online. <br><br>  Saya memiliki R1 = 130 Ohm, C1 = 0,33 uF.  Untuk output saya menghubungkan headphone Cina biasa. <br><br><h2>  Apa yang ada di sana tentang 16 bit suara? </h2><br>  Seperti yang saya katakan di atas, ketika kita mengalikan dua angka delapan-bit (frekuensi dan volume), kita mendapatkan angka 16-bit.  Anda tidak dapat membulatkannya menjadi delapan bit, tetapi output kedua byte dalam 2 saluran PWM.  Jika Anda mencampur 2 saluran ini dalam rasio 1/256, maka kami bisa mendapatkan suara 16 bit.  Perbedaan dengan delapan-bit sangat mudah didengar pada suara dan drum yang memudar dengan lancar di saat-saat ketika hanya satu instrumen yang berbunyi. <br><br>  Koneksi output 16-bit: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VCC | R1 | PinH+---/\/\--+-----&gt; OUT | | | | | R2 | | PinL+---/\/\--+ +---+GND | | | +-------+ === C1 | | --- Grnd --- Grnd</code> </pre> <br>  Penting untuk mencampur 2 output dengan benar: resistansi R2 harus 256 kali lebih besar dari resistansi R1.  Semakin akurat, semakin baik.  Sayangnya, bahkan resistor dengan kesalahan 1% tidak memberikan akurasi yang diperlukan.  Namun, bahkan dengan pemilihan resistor yang tidak terlalu akurat, distorsi dapat secara nyata dilemahkan. <br><br>  Sayangnya, ketika menggunakan suara 16-bit, kinerja menurun dan 5 saluran + noise tidak lagi punya waktu untuk diproses dalam siklus 256 jam yang diberikan. <br><br><h2>  Apakah mungkin di Arduino? </h2><br>  Ya kamu bisa.  Saya hanya memiliki klon nano Cina di ATmega328p, itu berfungsi di atasnya.  Kemungkinan besar, arduin lain pada ATmega328p juga harus berfungsi.  ATmega168 tampaknya memiliki register pengatur waktu yang sama.  Kemungkinan besar mereka akan bekerja tidak berubah.  Pada mikrokontroler lain yang perlu Anda periksa, Anda mungkin perlu menambahkan driver. <br><br>  Ada sketsa di <i>demo / arduino328p</i> , tetapi untuk itu bisa dibuka secara normal di IDE Arduino, Anda perlu menyalinnya ke root proyek. <br><br>  Dalam contoh, suara 16-bit dihasilkan dan output D9 dan D10 digunakan.  Untuk mempermudah, Anda dapat membatasi diri pada suara 8-bit dan hanya menggunakan satu output D9. <br><br>  Karena hampir semua arduin beroperasi pada 16 MHz, maka, jika diinginkan, Anda dapat menambah jumlah saluran menjadi 8. <br><br><h2>  Bagaimana dengan ATtiny? </h2><br>  ATtiny tidak memiliki perkalian perangkat keras.  Penggandaan perangkat lunak yang digunakan kompilator sangat lambat dan sebaiknya dihindari.  Saat menggunakan sisipan assembler yang dioptimalkan, kinerja turun 2 kali dibandingkan ATmega.  Tampaknya tidak ada gunanya menggunakan ATtiny sama sekali, tapi ... <br><br>  Beberapa ATtiny memiliki pengganda frekuensi, PLL.  Dan ini berarti bahwa pada mikrokontroler semacam itu ada 2 fitur menarik: <br><br><ol><li>  Frekuensi generator PWM adalah 64 MHz, yang memberikan periode PWM 250 kHz, yang jauh lebih baik daripada 31250 Hz pada 8 MHz atau 62500 Hz dengan kuarsa pada 16 MHz pada ATmega apa pun. </li><li>  Pengganda frekuensi yang sama memungkinkan kristal untuk clock pada 16 MHz tanpa kuarsa. </li></ol><br>  Maka kesimpulannya: beberapa ATtiny dapat digunakan untuk menghasilkan suara.  Mereka berhasil memproses 5 instrumen + saluran noise yang sama, tetapi pada 16 MHz dan mereka tidak memerlukan kuarsa eksternal. <br><br>  Kelemahannya adalah bahwa frekuensinya tidak dapat ditingkatkan lagi, dan perhitungannya memakan waktu hampir sepanjang waktu.  Untuk membebaskan sumber daya, Anda dapat mengurangi jumlah saluran atau laju sampel. <br><br>  Minus lainnya adalah kebutuhan untuk menggunakan dua timer sekaligus: satu untuk PWM, yang kedua untuk gangguan.  Di sinilah timer biasanya berakhir. <br><br>  Dari mikrokontroler PLL yang saya tahu, saya bisa menyebutkan ATtiny85 / 45/25 (8 kaki), ATtiny861 / 461/261 (20 kaki), ATtiny26 (20 kaki). <br><br>  Sedangkan untuk memori, perbedaannya dengan ATmega tidak besar.  Dalam 8kb, beberapa instrumen dan melodi cocok dengan sempurna.  Dalam 4kb Anda dapat menempatkan 1-2 instrumen dan 1-2 lagu.  Sulit untuk memasukkan sesuatu ke dalam 2 kilobyte, tetapi jika Anda benar-benar ingin, maka Anda bisa.  Penting untuk memisahkan metode, menonaktifkan beberapa fungsi seperti kontrol volume atas saluran, mengurangi frekuensi pengambilan sampel dan jumlah saluran.  Secara umum, untuk seorang amatir, tetapi ada contoh yang berfungsi pada ATtiny26. <br><br><h2>  Masalahnya </h2><br>  Ada masalah.  Dan masalah terbesar adalah kecepatan komputasi.  Kode ini sepenuhnya ditulis dalam C dengan sisipan multiplikasi assembler kecil untuk ATtiny.  Optimasi diberikan kepada kompiler dan terkadang berperilaku aneh.  Dengan perubahan kecil yang tampaknya tidak memengaruhi apa pun, Anda bisa mendapatkan penurunan kinerja yang nyata.  Selain itu, mengubah dari -O ke -O3 tidak selalu membantu.  Salah satu contohnya adalah penggunaan buffer 256 byte.  Terutama tidak menyenangkan adalah bahwa tidak ada jaminan bahwa dalam versi baru dari kompiler kita tidak akan mendapatkan penurunan kinerja pada kode yang sama. <br><br>  Masalah lain adalah bahwa mekanisme atenuasi sebelum not selanjutnya tidak diimplementasikan sama sekali.  Yaitu  ketika pada satu saluran satu not diganti dengan yang lain, suara lama tiba-tiba terganggu, kadang-kadang terdengar bunyi klik kecil.  Saya ingin menemukan cara untuk menyingkirkan ini tanpa kehilangan kinerja, tetapi sejauh ini. <br><br>  Tidak ada perintah untuk meningkatkan / mengurangi volume dengan lancar.  Ini sangat penting untuk nada dering notifikasi pendek, di mana pada akhirnya Anda perlu membuat redaman cepat pada volume sehingga tidak ada suara yang tajam.  Bagian dari masalah adalah dengan menulis serangkaian perintah dengan mengatur volume dan jeda singkat secara manual. <br><br>  Pendekatan yang dipilih, pada prinsipnya, tidak mampu memberikan suara naturalistik untuk instrumen.  Untuk suara yang lebih alami, Anda perlu membagi suara instrumen menjadi serangan-berkelanjutan-rilis, gunakan setidaknya 2 bagian pertama dan dengan durasi yang jauh lebih lama dari satu periode osilasi.  Tetapi kemudian data untuk alat tersebut akan membutuhkan lebih banyak.  Ada ide untuk menggunakan tabel gelombang yang lebih pendek, misalnya, dalam 32 byte, bukan 256, tetapi tanpa interpolasi, kualitas suara menurun secara dramatis, dan dengan interpolasi, kinerja menurun.  Dan 8 bit sampel lainnya jelas tidak cukup untuk musik, tetapi ini dapat dielakkan. <br><br>  Ukuran buffer dibatasi hingga 256 sampel.  Ini sesuai dengan sekitar 8 milidetik dan ini adalah periode waktu integral maksimum yang dapat diberikan untuk tugas-tugas lain.  Pada saat yang sama, pelaksanaan tugas masih ditangguhkan secara berkala oleh interupsi. <br><br>  Mengganti penundaan standar tidak bekerja dengan sangat akurat untuk jeda singkat. <br><br>  Saya yakin ini bukan daftar lengkap. <br><br><h2>  Referensi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github Link</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhitungan filter PWM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beberapa ide dan lagu demo diambil dari sini</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466121/">https://habr.com/ru/post/id466121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466105/index.html">Overclocking Magento Rest API dengan RoadRunner</a></li>
<li><a href="../id466107/index.html">Lakukan sistem Smart Home sendiri</a></li>
<li><a href="../id466109/index.html">Pemecahan masalah dengan pwnable.kr 22 - brainfuck. Serangan ret2libc</a></li>
<li><a href="../id466111/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 32. Pemulihan Kata Sandi, XMODEM / TFTPDNLD dan Aktivasi Lisensi Cisco</a></li>
<li><a href="../id466113/index.html">Menentukan pengodean teks dalam PHP, bukan mb_detect_encoding</a></li>
<li><a href="../id466123/index.html">Pertumbuhan. Berat Tiga tetangga</a></li>
<li><a href="../id466127/index.html">Kola NPP atau berdiri di reaktor</a></li>
<li><a href="../id466129/index.html">Efisiensi transportasi dengan bensin, baterai dan hidrogen</a></li>
<li><a href="../id466135/index.html">Megapack: bagaimana pengembang Factorio berhasil memecahkan masalah dengan 200 pemain multipemain</a></li>
<li><a href="../id466137/index.html">System.IO. Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>