<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›¹ğŸ¼ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ’ Gunakan kasing atau yang tidak dimiliki penyeimbang muatan ğŸ‘¨ğŸ¾â€ğŸ”§ ğŸ§’ğŸ¿ ğŸ›ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa tahun yang lalu, saya menyelesaikan proyek migrasi di jaringan salah satu klien kami, tugasnya adalah mengubah platform, yang mendistribusika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gunakan kasing atau yang tidak dimiliki penyeimbang muatan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424115/">  Beberapa tahun yang lalu, saya menyelesaikan proyek migrasi di jaringan salah satu klien kami, tugasnya adalah mengubah platform, yang mendistribusikan beban antar server.  Skema penyediaan layanan klien ini telah berkembang selama hampir 10 tahun, bersama dengan perkembangan baru dalam industri pusat data, sehingga "pilih-pilih", dalam arti yang baik, klien mengharapkan solusi yang akan memuaskan tidak hanya persyaratan toleransi kesalahan peralatan jaringan, penyeimbang beban dan server , tetapi juga akan memiliki sifat-sifat seperti skalabilitas, fleksibilitas, mobilitas dan kesederhanaan.  Pada artikel ini saya akan mencoba secara konsisten, dari yang sederhana hingga yang rumit, menguraikan contoh-contoh utama penggunaan penyeimbang beban tanpa merujuk pada pabrikan, fitur-fiturnya dan metode pemasangan dengan jaringan pengiriman data. <br><a name="habracut"></a><br>  Load balancers sekarang semakin disebut sebagai Application Delivery Controllers (ADCs).  Tetapi jika aplikasi sedang berjalan di server, mengapa harus dikirim ke suatu tempat?  Untuk alasan toleransi kesalahan atau penskalaan, aplikasi dapat dijalankan di lebih dari satu server, dalam hal ini Anda memerlukan jenis server proxy terbalik yang menyembunyikan kompleksitas internal dari konsumen, memilih server yang diinginkan, mengirimkan permintaan ke sana dan memastikan bahwa server mengembalikan yang benar , dari sudut pandang protokol, hasilnya, jika tidak, ia akan memilih server lain dan mengirim permintaan di sana.  Untuk mengimplementasikan fungsi-fungsi ini, ADC harus memahami semantik protokol lapisan aplikasi yang digunakannya, ini memungkinkan Anda untuk mengkonfigurasi aturan khusus aplikasi untuk pengiriman lalu lintas, analisis hasil, dan memeriksa status server.  Misalnya, pemahaman tentang semantik HTTP memungkinkan konfigurasi ketika permintaan HTTP <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /docs/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.html HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: www.company.com Accept-<span class="hljs-keyword"><span class="hljs-keyword">Language</span></span>: en-us Accept-<span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>: gzip, deflate</code> </pre> <br>  dikirim ke satu grup server dengan kompresi hasil dan caching, serta permintaan berikutnya <br><br><pre> <code class="hljs pgsql">POST /api/<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>-put HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> HOST: b2b.company.com X-Auth: <span class="hljs-number"><span class="hljs-number">76</span></span>GDjgtgdfsugs893Hhdjfpsj Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span></code> </pre><br>  diproses sesuai dengan aturan yang sama sekali berbeda. <br><br>  Memahami semantik protokol memungkinkan Anda untuk mengatur sesi di tingkat objek protokol aplikasi, misalnya, menggunakan HTTP Header, RDP Cookie, atau permintaan multipleks untuk mengisi satu sesi transportasi dengan banyak permintaan pengguna jika tingkat aplikasi protokol memungkinkan ini. <br>  Ruang lingkup aplikasi ADC kadang-kadang dibayangkan tanpa alasan hanya dengan melayani lalu lintas HTTP, pada kenyataannya, daftar protokol yang didukung untuk sebagian besar produsen jauh lebih luas.  Bahkan bekerja tanpa memahami semantik protokol lapisan aplikasi, ADC dapat berguna untuk menyelesaikan berbagai tugas, misalnya, saya mengambil bagian dalam membangun kebun virtual mandiri server SMTP, selama serangan spam, jumlah instance meningkat menggunakan kontrol umpan balik di sepanjang antrian pesan untuk memberikan waktu yang memuaskan untuk memeriksa pesan dengan algoritma sumber daya intensif.  Selama aktivasi, server terdaftar dengan ADC dan menerima bagiannya dari sesi TCP baru.  Dalam kasus SMTP, skema operasi seperti itu dibenarkan karena tingginya entropi koneksi di tingkat jaringan dan transportasi, untuk distribusi beban yang seragam selama serangan spam ADC, hanya dukungan TCP yang diperlukan.  Skema yang sama dapat digunakan untuk membangun tambak dari server database, DNS, DHCP, AAA, atau cluster server akses jarak jauh yang banyak ketika server dapat dianggap setara dalam domain dan ketika karakteristik kinerjanya tidak terlalu berbeda satu sama lain.  Saya tidak akan masuk lebih jauh ke topik fitur protokol, aspek ini terlalu luas untuk dinyatakan dalam pendahuluan, jika sesuatu tampak menarik - tulis, mungkin ini adalah kesempatan untuk artikel dengan presentasi yang lebih dalam dari beberapa aplikasi, dan sekarang mari kita langsung ke intinya. <br><br>  Paling sering, ADC menutup lapisan transport, sehingga sesi TCP end-to-end antara konsumen dan server menjadi komposit, konsumen membuat sesi dengan ADC, dan ADC dengan salah satu server. <br><br><img src="https://habrastorage.org/webt/qi/_9/vg/qi_9vglsdqfiqbtzbrsh-egpvwk.png" alt="gambar"><br>  <i>Fig. 1</i> <br><br>  Konfigurasi jaringan dan pengaturan pengalamatan harus menyediakan peningkatan lalu lintas sehingga dua bagian sesi TCP melewati ADC.  Opsi termudah untuk membuat lalu lintas bagian pertama yang datang ke ADC adalah dengan menetapkan alamat layanan ke salah satu alamat antarmuka ADC, dengan bagian kedua opsi berikut dimungkinkan: <br><br><ol><li>  ADC sebagai gateway default untuk jaringan server; </li><li>  Siaran ke alamat konsumen ADC di salah satu alamat antarmuka. </li></ol><br>  Bahkan, tampilan yang sedikit lebih realistis dari skema aplikasi pertama terlihat seperti ini, ini adalah dasar dari mana kita akan mulai: <br><br><img src="https://habrastorage.org/webt/6z/y8/5y/6zy85y1fcajgfndoybabz9geikk.png" alt="gambar"><br>  <i>Gbr.2</i> <br><br>  Kelompok server kedua dapat berupa basis data, aplikasi back-end, penyimpanan jaringan atau front-end untuk set layanan lain dalam hal penguraian aplikasi klasik menjadi layanan mikro.  Kelompok server ini dapat berupa domain perutean yang terpisah, dengan kebijakannya sendiri, yang terletak di pusat data lain atau sepenuhnya diisolasi untuk alasan keamanan.  Server jarang terletak di satu segmen, lebih sering mereka ditempatkan di segmen untuk tujuan yang dimaksudkan dengan kebijakan akses yang diatur dengan jelas, angka menunjukkan ini sebagai firewall. <br><br>  Studi menunjukkan bahwa aplikasi multi-tier modern menghasilkan lebih banyak lalu lintas Barat-Timur, dan Anda tidak mungkin ingin semua lalu lintas intra-kode / antar-segmen melewati ADC.  Switch pada Gambar 2 belum tentu fisik - domain routing dapat diimplementasikan menggunakan entitas virtual, yang disebut virtual-router, vrf, vr, vpn-instance atau tabel routing virtual untuk produsen yang berbeda. <br><br>  Omong-omong, ada varian pairing dengan jaringan, tanpa memerlukan simetri arus lalu lintas dari konsumen ke ADC dan dari ADC ke server, permintaan dalam kasus sesi berumur panjang, di mana sejumlah besar lalu lintas ditransmisikan dalam satu arah, misalnya streaming atau menyiarkan konten video.  Dalam hal ini, ADC hanya melihat aliran dari klien ke server, aliran ini dikirim ke alamat antarmuka ADC dan setelah pemrosesan sederhana, yang terdiri dari penggantian alamat MAC dengan antarmuka MAC dari salah satu server, permintaan dikirim ke server di mana alamat layanan ditugaskan ke salah satu antarmuka logis.  Lalu lintas terbalik dari server ke konsumen melewati ADC sesuai dengan tabel routing server.  Mendukung satu domain siaran untuk semua front-end bisa sangat sulit, apalagi, kemampuan ADC untuk menganalisis tanggapan dan dukungan sesi dalam hal ini sangat terbatas, pada kenyataannya itu hanya sebuah saklar, sehingga opsi ini tidak dipertimbangkan lebih lanjut, meskipun beberapa sempit tugas dapat digunakan. <br><br><img src="https://habrastorage.org/webt/hm/xb/vs/hmxbvspqknpgsvws5uqbycydaps.png" alt="gambar"><br>  <i>Gbr.3</i> <br><br>  Jadi, kita memiliki satu basis-data center, ditunjukkan pada Gambar 2, mari kita pikirkan masalah apa yang dapat mendorong basis-data center ke evolusi, saya melihat dua topik untuk analisis: <br><br><ol><li>  Misalkan subsistem switching sepenuhnya dicadangkan, jangan berpikir tentang bagaimana atau mengapa, topiknya terlalu luas.  Aplikasi berjalan di beberapa server dan didukung menggunakan ADC, tetapi bagaimana cara memesan ADC itu sendiri? </li><li>  Jika analisis menunjukkan bahwa beban puncak musiman berikutnya dapat melebihi kemampuan ADC, Anda tentu saja memikirkan skalabilitas. </li></ol><br>  Tugas-tugas ini serupa dalam hal itu, dalam proses penyelesaiannya, jumlah instance ADC pasti akan meningkat.  Pada saat yang sama, toleransi kesalahan dapat diatur sesuai dengan skema Active / Backup dan Active / Active, dan penskalaan hanya dapat dilakukan sesuai dengan skema Active / Active.  Mari kita coba selesaikan secara individual dan lihat properti apa yang dimiliki berbagai solusi. <br><br>  Banyak ADC produsen dapat dianggap sebagai elemen infrastruktur jaringan, RIP, OSPF, BGP - semua ini ada di sana, yang berarti Anda dapat membangun skema cadangan Active / Backup yang sepele.  ADC aktif meneruskan awalan layanan ke router hulu, dan menerima rute default untuk mengisi tabelnya dan untuk mentransfer ke pusat data ke tabel routing virtual yang sesuai.  ADC cadangan melakukan hal yang sama, tetapi, dengan menggunakan semantik dari protokol routing yang dipilih, menghasilkan pengumuman yang kurang menarik.  Dengan pendekatan ini, server dapat melihat alamat IP nyata dari konsumen, karena tidak ada alasan untuk menggunakan terjemahan alamat.  Skema ini juga berfungsi dengan baik jika ada lebih dari satu router hulu, tetapi untuk menghindari situasi ketika ADC aktif kehilangan default dan konektivitas dengan router, sementara masih menerima default dari ADC cadangan dan terus mengumumkannya ke pusat data, cobalah untuk menghindari kedekatan antara ADC dan penggunaan rute statis. <br><br><img src="https://habrastorage.org/webt/l8/bw/di/l8bwdie61pvk2wibngd9jwgcco4.png" alt="gambar"><br>  <i>Fig. 4</i> <br><br>  Jika server tidak harus beroperasi dengan alamat IP konsumen nyata, atau protokol lapisan aplikasi memungkinkan Anda untuk menanamkannya dalam header, seperti HTTP, skema berubah menjadi Aktif / Aktif dengan ketergantungan kinerja yang hampir linier pada jumlah ADC.  Dalam hal lebih dari satu router hulu, harus diperhatikan untuk memastikan bahwa lalu lintas masuk tiba dalam porsi yang kurang lebih seragam.  Tugas ini dapat dengan mudah diselesaikan jika dalam domain routing ECMP transfer mulai ke router ini, jika sulit atau jika domain routing tidak dilayani oleh Anda - Anda dapat menggunakan koneksi full-mesh antara ADX dan router sehingga transfer ECMP mulai langsung ke mereka. <br><br><img src="https://habrastorage.org/webt/z3/wr/bu/z3wrbuedtvq62eabsourkdgxkvy.png" alt="gambar"><br>  <i>Gbr.5</i> <br><br>  Pada awal bagian ini, saya menulis bahwa toleransi kesalahan dan penskalaan adalah dua perbedaan besar.  Solusi untuk masalah ini memiliki tingkat pemanfaatan sumber daya yang berbeda, jika Anda merancang skema Aktif / Siaga, Anda perlu menerima kenyataan bahwa setengah dari sumber daya akan menganggur.  Dan jika itu terjadi sehingga Anda perlu mengambil langkah kuantitatif berikutnya, bersiaplah untuk melipatgandakan sumber daya yang diperlukan dengan dua lagi di masa depan. <br><br>  Manfaat Aktif / Aktif mulai muncul ketika Anda beroperasi dengan lebih dari dua perangkat.  Misalkan Anda perlu memastikan kinerja 8 unit sewenang-wenang (8 ribu koneksi per detik, atau 8 juta sesi simultan) dan menyediakan skenario kegagalan perangkat tunggal, dalam versi Aktif / Aktif, Anda hanya perlu tiga instance ADC dengan kapasitas 4, dalam kasus Aktif / Siaga - dua oleh 8. Jika Anda menerjemahkan angka-angka ini ke sumber daya yang tidak digunakan, Anda mendapatkan sepertiga hingga setengah.  Prinsip perhitungan yang sama dapat digunakan untuk memperkirakan proporsi koneksi terputus selama periode kegagalan parsial.  Dengan peningkatan jumlah instance Aktif / Aktif, matematika menjadi lebih menyenangkan, dan sistem mendapat kesempatan untuk secara bertahap meningkatkan produktivitas alih-alih bertahap Aktif / Siaga. <br><br>  Akan benar untuk menyebutkan cara lain dari skema kerja Aktif / Aktif atau Aktif / Siaga - pengelompokan.  Tetapi tidak akan terlalu tepat untuk mencurahkan banyak waktu untuk ini, karena saya mencoba untuk menulis tentang pendekatan, dan bukan tentang fitur produsen.  Saat memilih solusi ini, Anda perlu memahami hal-hal berikut: <br><br><ol><li>  Arsitektur cluster kadang-kadang memaksakan pembatasan pada fungsi ini atau itu, dalam beberapa proyek ini adalah fundamental, dalam beberapa hal itu mungkin menjadi penting di masa depan, semua yang ada di sini sangat tergantung pada pabrikan dan setiap solusi perlu dikerjakan secara individual; </li><li>  Cluster sering satu domain kesalahan, akan ada kesalahan dalam perangkat lunak. </li><li>  Cluster mudah dirakit, tetapi sangat sulit dibongkar.  Teknologi memiliki mobilitas yang lebih rendah - Anda tidak dapat mengontrol bagian sistem. </li><li>  Anda jatuh ke dalam pelukan kuat produsen Anda. </li></ol><br>  Meskipun demikian, ada hal-hal positif: <br><br><ol><li>  Cluster ini mudah dipasang dan mudah dioperasikan. </li><li>  Terkadang Anda dapat mengharapkan pemanfaatan sumber daya yang hampir optimal. </li></ol><br>  Jadi, pusat data kami dari Gambar 5 terus bertambah, tugas yang mungkin harus Anda selesaikan adalah menambah jumlah server.  Tidak selalu mungkin untuk melakukan ini di pusat data yang ada, jadi anggaplah bahwa lokasi baru yang luas dengan server tambahan telah muncul. <br><br><img src="https://habrastorage.org/webt/o5/kq/fo/o5kqfoeksqpzk09cfrlmdluxts8.png" alt="gambar"><br>  <i>Gbr.6</i> <br><br>  Situs baru mungkin tidak terlalu jauh, maka Anda akan berhasil menyelesaikan masalah dengan memperbarui domain perutean.  Kasus yang lebih umum, yang tidak mengecualikan penampilan situs di kota lain atau di negara lain, akan menimbulkan tantangan baru untuk pusat data: <br><br><ol><li>  Pemanfaatan saluran antar situs; </li><li>  Perbedaan waktu pemrosesan untuk permintaan yang dikirim ADC untuk diproses ke server terdekat dan jauh. </li></ol><br>  Mempertahankan saluran yang luas antar situs dapat menjadi pekerjaan yang sangat mahal, dan memilih lokasi tidak akan lagi menjadi tugas sepele - situs yang kelebihan beban dengan waktu respons yang singkat atau gratis dengan yang besar.  Memikirkan hal ini akan mendorong Anda untuk membangun konfigurasi pusat data yang terdistribusi secara geografis.  Konfigurasi ini, di satu sisi, ramah bagi konsumen, karena memungkinkan Anda untuk menerima layanan pada titik yang dekat dengan Anda, di sisi lain, ini dapat secara signifikan mengurangi persyaratan untuk band saluran antara situs. <br><br>  Untuk kasus ketika alamat IP asli tidak harus dapat diakses ke server, atau ketika protokol lapisan aplikasi memungkinkan mereka untuk ditransmisikan dalam header, perangkat pusat data yang didistribusikan secara geografis tidak jauh berbeda dari apa yang saya sebut sebagai pusat data dasar.  ADC di situs mana pun dapat mengirim permintaan pemrosesan ke server lokal atau mengirimnya untuk diproses ke yang tetangga, menyiarkan alamat konsumen memungkinkan hal ini.  Beberapa perhatian harus diberikan untuk memantau volume lalu lintas yang masuk untuk mempertahankan jumlah ADC di dalam situs yang memadai dengan proporsi lalu lintas yang diterima situs.  Terjemahan alamat konsumen memungkinkan Anda untuk menambah / mengurangi jumlah ADC atau bahkan memindahkan instance antar situs sesuai dengan perubahan dalam matriks lalu lintas yang masuk, atau selama migrasi / peluncuran.  Terlepas dari kesederhanaannya, skema ini cukup fleksibel, memiliki karakteristik pengoperasian yang menyenangkan dan mudah direplikasi untuk lebih dari dua lokasi. <br><br><img src="https://habrastorage.org/webt/4f/3k/e0/4f3ke0imkvzickwdmswg76qo8ts.png" alt="gambar"><br>  <i>Gbr. 7</i> <br><br>  Jika Anda bekerja dengan protokol yang memungkinkan penerusan permintaan, seperti dalam kasus HTTP Redirect, fitur ini dapat digunakan sebagai tuas tambahan untuk mengontrol beban saluran antar situs, sebagai mekanisme untuk melakukan pemeliharaan rutin pada server atau sebagai metode membangun tambak server Active / Backup di berbagai situs.  Pada titik waktu yang ditentukan, secara otomatis atau setelah beberapa peristiwa pemicu, ADC dapat menghapus lalu lintas dari server lokal dan memindahkan konsumen ke situs tetangga.  Penting untuk memperhatikan pengembangan algoritma ini sehingga pekerjaan terkoordinasi ADC mengecualikan kemungkinan permintaan atau resonansi timbal balik. <br><br>  Yang menarik adalah kasus ketika server membutuhkan alamat IP nyata dari konsumen, dan protokol lapisan aplikasi tidak memiliki kemampuan untuk mengirimkan header tambahan, atau ketika ADC bekerja tanpa memahami semantik protokol lapisan aplikasi.  Dalam hal ini, tidak mungkin untuk menyediakan koneksi yang konsisten antara segmen sesi TCP dengan hanya menyatakan rute dalam ADC default.  Jika Anda melakukan ini, server situs pertama akan mulai menggunakan ADC lokal sebagai gateway default untuk sesi yang berasal dari situs kedua, sesi TCP tidak akan dibuat dalam kasus ini karena ADC situs pertama akan melihat hanya satu bahu sesi. <br><br><img src="https://habrastorage.org/webt/bh/zs/sg/bhzssgahst0iwxcsj_-rzpnzy4k.png" alt="gambar"><br>  <i>Gbr. 8</i> <br><br>  Ada trik kecil yang masih memungkinkan Anda untuk menjalankan ADC Aktif / Aktif dikombinasikan dengan Farm server Aktif / Aktif di situs yang berbeda (Saya tidak mempertimbangkan kasus Aktif / Cadangan di dua situs, pembacaan yang cermat di atas akan memungkinkan Anda untuk menyelesaikan masalah ini tanpa diskusi lebih lanjut).  Caranya adalah dengan menggunakan ADC situs kedua bukan alamat antarmuka server, tetapi alamat ADC logis, yang sesuai dengan server pertanian di situs pertama.  Pada saat yang sama, server menerima lalu lintas seolah-olah berasal dari ADC lokal dan menggunakan gateway default lokal.  Untuk mempertahankan mode operasi ini pada ADC, Anda harus mengaktifkan fungsi memori antarmuka dari mana paket pertama untuk mengatur sesi TCP datang.  Pabrikan yang berbeda menyebut fungsi ini secara berbeda, tetapi intinya sama - ingat antarmuka dalam tabel status sesi dan gunakan untuk lalu lintas respons tanpa memperhatikan tabel perutean.  Skema ini berfungsi penuh dan memungkinkan Anda untuk mendistribusikan beban secara fleksibel di semua server yang tersedia di mana pun mereka berada.  Dalam kasus dua atau lebih situs, kegagalan satu ADC tidak mempengaruhi ketersediaan layanan secara keseluruhan, tetapi sepenuhnya mengecualikan kemungkinan memproses lalu lintas di server situs dengan ADC yang gagal, ini harus diingat ketika memprediksi perilaku dan memuat selama kegagalan parsial. <br><br><img src="https://habrastorage.org/webt/j8/c5/n0/j8c5n0oqpzijkfiz3dbyrrxeaww.png" alt="gambar"><br>  <i>Gambar 9</i> <br><br>  Layanan klien kami berfungsi kira-kira dengan cara yang sama ketika saya mulai mengerjakan proyek migrasi ke platform ADC baru.  Tidak sulit untuk hanya menciptakan kembali perilaku perangkat dari platform lama pada yang baru dalam kerangka skema yang terbukti dan ramah pelanggan, ini adalah apa yang mereka harapkan dari kami. <br><br>  Tetapi lihat kembali Gambar 9, apakah Anda melihat apa yang dapat dioptimalkan di sana? <br>  Kerugian utama bekerja dengan rantai ADC adalah bahwa ia menghabiskan sumber daya dari dua ADC untuk memproses beberapa bagian dari sesi.  Dalam kasus klien ini, pilihannya benar-benar sadar, itu karena spesifik aplikasi dan kebutuhan untuk dapat dengan sangat cepat (dari 20 hingga 50 detik) mendistribusikan kembali beban antara server dari situs yang berbeda.  Pada periode waktu yang berbeda, pemrosesan ganda mengambil rata-rata 15 hingga 30 persen sumber daya ADC, yang cukup untuk memikirkan optimasi.  Setelah membahas hal ini dengan para insinyur klien, kami mengusulkan untuk mengganti dukungan untuk tabel sesi ADC dengan pengikatan antarmuka dengan perutean sumber pada server menggunakan PBR pada tumpukan IP Linux.  Sebagai kunci, kami mempertimbangkan opsi seperti: <br><br><ol><li>  alamat IP tambahan pada server pada antarmuka umum untuk setiap ADC; </li><li>  antarmuka alamat IP pada server pada 802.1q terpisah untuk setiap ADC; </li><li>  Pisahkan jaringan terowongan overlay pada server untuk setiap ADC. </li></ol><br>  Opsi pertama dan kedua akan memengaruhi jaringan secara keseluruhan.  Di antara efek samping opsi satu, tampaknya tidak dapat diterima bagi kami bahwa peningkatan yang merupakan kelipatan dari jumlah ADC, tabel ARP pada sakelar, dan opsi kedua akan membutuhkan peningkatan jumlah domain siaran end-to-end antara situs atau contoh individual tabel routing virtual.  Sifat lokal dari opsi ketiga tampak sangat menarik bagi kami, dan kami mulai bekerja, yang menghasilkan pengontrol sederhana yang mengotomatiskan konfigurasi terowongan pada server dan ADC, serta konfigurasi PBR pada tumpukan IP server Linux. <br><br><img src="https://habrastorage.org/webt/6a/io/9_/6aio9_jovjmxyo2n2qtuamfzlji.png" alt="gambar"><br>  <i>Gbr. 10</i> <br><br>  Ketika saya menulis, migrasi selesai, klien mendapatkan apa yang diinginkannya - platform baru, kesederhanaan, fleksibilitas, skalabilitas, dan, sebagai akibat beralih ke overlay, menyederhanakan konfigurasi peralatan jaringan sebagai bagian dari servis layanan ini - alih-alih beberapa salinan tabel virtual dan domain siaran besar, ternyata -   IP . <br><br> ,     ADC,       .    ,            ,          .        -,    ADC       ,       ,  Â« Â». <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, beberapa pelanggan mungkin merasa nyaman untuk beralih dari model interaksi PULL dengan server ke model PUSH. Kemampuan aplikasi pada server sangat luas, sehingga kadang-kadang lebih mudah untuk mengatur verifikasi aplikasi spesifik yang serius dari layanan pada agen itu sendiri. Jika cek memberikan hasil positif, agen mentransmisikan informasi, misalnya, dalam bentuk yang mirip dengan Komunitas Biaya BGP, untuk digunakan dalam algoritma perhitungan tertimbang. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seringkali, berbagai departemen organisasi melakukan pemeliharaan server dan ADC, beralih ke model interaksi PUSH mungkin menarik karena model ini menghilangkan kebutuhan untuk koordinasi antar departemen pada antarmuka manusia-ke-manusia. Layanan di mana server berpartisipasi dapat ditransfer langsung dari agen ke ADC dalam bentuk yang mirip dengan BGP Flow-Spec canggih.</font></font><br><br>     .     â€¦           ,      ,        .          -  ,     ,                ,      .         .  ,   ,    ,             SDN .     ,      ,            . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424115/">https://habr.com/ru/post/id424115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424105/index.html">NASA tahu cara membuat Mars hijau lagi</a></li>
<li><a href="../id424107/index.html">Sudah setahun sejak lubang menganga dalam penyimpanan jaringan rumah My Cloud WD</a></li>
<li><a href="../id424109/index.html">VSCE # 2: Podcast Pengusaha Media</a></li>
<li><a href="../id424111/index.html">Kontrak Cerdas Gelombang. Pengalaman pertama</a></li>
<li><a href="../id424113/index.html">Proses desain, penelitian dan pencarian pekerjaan</a></li>
<li><a href="../id424119/index.html">Apakah ada Scrum *?</a></li>
<li><a href="../id424121/index.html">Membuat fungsi pemicu di pgModeler</a></li>
<li><a href="../id424127/index.html">Bagaimana cara berteman Ovirt dan Let's Encrypt</a></li>
<li><a href="../id424129/index.html">Pengembangan Android. Sedikit tentang kerja cepat dengan daftar</a></li>
<li><a href="../id424131/index.html">Manifesto Pengembang Sistem Cerdas: 15 Prinsip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>