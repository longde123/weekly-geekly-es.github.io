<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏿 🆘 🧗🏿 关于RTOS的全部真相。 第十三条 任务数据结构和不受支持的API调用 🐺 ↗️ 💰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在第三篇也是最后一篇任务文章中，我将研究Nucleus SE数据结构，并描述未在Nucleus SE中实现的RTOS API调用以及其他兼容性问题。 

 该系列中的先前文章： 
 第十二条 任务处理服务 
 第11条 任务：API的配置和介绍 
 第10条 计划程序：高级功能和上下文保留 
 第9...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第十三条 任务数据结构和不受支持的API调用</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425353/"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br> 在第三篇也是最后一篇任务文章中，我将研究Nucleus SE数据结构，并描述未在Nucleus SE中实现的RTOS API调用以及其他兼容性问题。 <br><a name="habracut"></a><br> 该系列中的先前文章： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><h2> 资料结构 </h2><br> 任务使用各种数据结构（在RAM和ROM中），就像其他Nucleus SE对象一样，它们是一组表，其大小与所选任务和参数的数量相对应。 <br><br> 我强烈建议应用程序代码使用API​​函数而非直接访问这些数据结构。 这样可以避免不必要的副作用，与Nucleus SE的未来版本不兼容，并且还简化了将应用程序移植到Nucleus RTOS的过程。 为了更好地理解服务调用代码的操作和调试过程，下面对数据结构进行详细说明。 <br><br><h3>  RAM中托管的内核数据结构 </h3><br> 这些数据结构包括： <br><br>  <b>NUSE_Task_Context [] []</b> -类型为<b>ADDR</b>的二维数组，每个任务都有一行。 列数取决于控制器体系结构，并且由<b>NUSE_REGISTERS</b>符号确定，该符号在<b>nuse_types.h中</b>定义。 调度程序使用此数组保存每个任务的上下文，并在文章＃10的“保存上下文”一节中进行了详细说明。 如果使用RTC调度程序，则不会创建。 <br>  <b>NUSE_Task_Signal_Flags []-U8</b>类型的数组，如果启用了信号则创建该数组，并且每个任务包含8个信号标志。 信号将在以下文章之一中讨论。 <br>  <b>NUSE_Task_Timeout_Counter []</b>是<b>U16</b>类型的数组，由每个任务的减法计数器组成，并且在激活对API <b>NUSE_Task_Sleep（）</b>的调用时创建。 <br>  <b>NUSE_Task_Status []</b> -类型为U8的数组，包含每个任务的状态<b>-NUSE_READY</b>或挂起状态。 仅在激活任务挂起时创建。 <br>  <b>NUSE_Task_Blocking_Return []-U8</b>类型的数组，如果激活了API调用阻止，则创建该数组。 它包含一个返回代码，将在阻止API调用后使用。 它通常包含<b>NUSE_SUCCESS</b>或指示该对象已被重置的代码（例如<b>NUSE_MAILBOX_WAS_RESET</b> ）。 <br>  <b>NUSE_Task_Schedule_Count []-U16</b>类型的数组，包含每个任务的计数器，并且仅在调度程序计数已激活时才创建。 <br><br>  <b>NUSE_Task_Context [] []</b>主要由零初始化，除了与状态寄存器（状态寄存器，SR），程序计数器（程序计数器，PC）和堆栈指针（堆栈指针，SP）相对应的条目外，这些条目被分配了初始值（请参见“数据在“ ROM”下面），并且在启动Nucleus SE时，所有其他数据结构<b>NUSE_Init_Task（）都</b>分配为零。 以下文章之一将包含Nucleus SE启动过程的完整列表及其说明。 <br><br> 以下是nuse_init.c文件中包含的数据结构的定义。 <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  RAM用户数据 </h3><br> 用户必须为每个任务定义一个堆栈（如果未使用RTC调度程序）。 这些应该是<b>ADDR</b>阵列，通常在<b>nuse_config.c中</b>定义。 地址和堆栈大小应分别放在任务条目<b>NUSE_Task_Stack_Base []</b>和<b>NUSE_Task_Stack_Size []中</b> （请参阅ROM中的数据）。 <br><br><h3>  ROM数据 </h3><br>  ROM存储与任务相关的一到四个数据结构。 确切数量取决于所选参数： <br><br>  <b>NUSE_Task_Start_Address []</b>是<b>ADDR</b>类型的数组，每个任务都有一个条目，它是指向该任务的代码入口点的指针。 <br>  <b>NUSE_Task_Stack_Base []</b>是<b>ADDR</b>类型的数组，每个任务都有一个条目，它是指向该任务堆栈的基地址的指针。 如果使用RTC以外的任何调度程序，则创建此数组。 <br>  <b>NUSE_Task_Stack_Size []</b>是<b>U16</b>类型的数组，每个任务都有一个条目，该数组显示任务的堆栈大小（以字为单位）。 如果使用RTC以外的任何调度程序，则创建此数组。 <br>  <b>NUSE_Task_Initial_State []</b>是<b>U8</b>类型的数组，每个任务都有一个条目，它显示任务的初始状态。 它可以是<b>NUSE_READY</b>或<b>NUSE_PURE_SUSPEND</b> 。 如果选择了对任务初始状态的支持，则会创建此数组。 <br><br> 这些数据结构在<b>nuse_config.c</b>中声明和初始化（静态）： <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3> 用于存储任务数据的内存量（任务数据足迹） </h3><br> 像所有Nucleus SE核心对象一样，存储数据所需的内存量是可以预测的。 <br><br> 所有应用程序任务所需的ROM大小（以字节为单位）： <br>  <b>NUSE_TASK_NUMBER * sizeof（ADDR）</b> <br><br> 另外，如果选择了除RTC以外的任何调度程序： <br>  <b>NUSE_TASK_NUMBER *（sizeof（ADDR）+2）</b> <br><br> 另外，如果选择了对任务初始状态的支持： <br>  <b>NUSE_TASK_NUMBER</b> <br><br> 要将数据存储在RAM中，内存量（以字节为单位）由所选参数确定，如果没有选择任何参数，则内存量可以为零。 <br> 如果选择了RTC以外的调度程序： <br>  <b>NUSE_TASK_NUMBER * NUSE寄存器* sizeof（ADDR）</b> <br><br> 另外，如果选择了信号支持： <br>  <b>NUSE_TASK_NUMBER</b> <br><br> 另外，如果激活了对NUSE_Task_Sleep（）API的调用： <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br> 此外，如果激活了任务挂起： <br>  <b>NUSE_TASK_NUMBER</b> <br><br> 另外，如果激活了API调用阻止功能： <br>  <b>NUSE_TASK_NUMBER</b> <br><br> 另外，如果调度程序计数器已​​激活： <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  Nucleus SE中未实现的API调用 </h2><br> 下面列出了Nucleus SE中未实现的Nucleus RTOS中可用的七个API调用。 <br><br><h3> 创建任务 </h3><br> 此API调用创建一个应用程序任务。  Nucleus SE不需要此功能，因为任务是静态创建的。 <br><br> 调用原型： <br><br>  <b>状态NU_Create_Task（NU_TASK *任务，CHAR *名称，VOID（* task_entry）（UNSIGNED，VOID *），UNSIGNED argc，VOID * argv，VOID * stack_address，UNSIGNED stack_size，OPTION优先级，UNSIGNED time_slice，OPTION优先级</b> <br><br> 参数： <br><br>  <b>任务</b> -指向用户任务控制块的指针，可以用作其他API调用中任务的句柄/链接（“句柄”）； <br>  name-指向任务名称的指针，一个由7个字符组成的字符串，结尾为零； <br>  <b>task_entry-</b>指示任务的输入功能； <br>  <b>argc-</b>可用于将初始信息传递给任务的<b>UNSIGNED</b>数据元素； <br>  <b>argv-</b>可用于将信息传输到任务的指针； <br>  <b>stack_address-</b>设置任务堆栈的内存的初始扇区； <br>  <b>stack_size-</b>指示堆栈中的字节数； <br>  <b>优先级</b> -表示任务的优先级值：从0到255，其中较低的数字表示最高的优先级； <br>  <b>time_slice-</b>指示此任务期间可以经过的最大时间<b>片</b>数。 值为“ 0”将禁用此任务的时间片。 <br>  <b>preempt-</b>指示任务是否被取代。 可以具有值<b>NU_PREEMPT</b>和<b>NU_NO_PREEMPT</b> ; <br>  <b>auto_start-</b>显示任务的初始状态。  <b>NU_START</b>表示任务已准备好执行，而<b>NU_NO_START意味着</b>任务已挂起。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>表示服务成功完成； <br>  <b>NU_INVALID_TASK-</b>指示指向任务控制单元的指针为<b>NULL</b> ； <br>  <b>NU_INVALID_ENTRY-</b>指示任务输入功能的指针为<b>NULL</b> ； <br>  <b>NU_INVALID_MEMORY-</b>指示由stack_address参数分配的内存扇区为零（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SIZE-</b>指示指定的堆栈大小不足； <br>  <b>NU_INVALID_PREEMPT-</b>指示<b>抢占</b>参数设置不正确； <br>  <b>NU_INVALID_START-</b>指示<b>auto_start</b>参数设置不正确。 <br><br><h3> 删除任务 </h3><br> 此API调用将删除先前创建的必须<i>完成</i>或<i>终止的</i>应用程序任务。  Nucleus SE也不需要此调用，因为任务是静态创建的，无法删除。 <br><br> 调用原型： <br><br>  <b>状态NU_Delete_Task（NU_TASK *任务）;</b> <br><br> 参数： <br><br>  <b>task-</b>指向任务控制块的指针 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>表示服务成功完成； <br>  <b>NU_INVALID_TASK-</b>指示指向任务的指针设置不正确； <br>  <b>NU_INVALID_DELETE-</b>表示任务未处于“已完成”或“已终止”状态。 <br><br><h3> 获取任务指针 </h3><br> 该API调用构成了指向系统中所有任务的指针的顺序列表。  Nucleus SE不需要它，因为任务是使用简单的索引而不是指针来标识的。 <br><br> 调用原型： <br><br>  <b>UNSIGNED NU_Task_Pointers（NU_TASK **指针列表，UNSIGNED maximum_pointers）;</b> <br><br> 参数： <br><br>  <b>pointer_list-</b>指向<b>NU_TASK</b>指针数组的指针。 该数组将填充指向系统中安装的任务的指针。 <br>  <b>maximum_pointers-</b>可以放置在数组中的最大指针数。 <br><br> 返回值： <br><br> 放置在数组中的<b>NU_TASK</b>指针的数量。 <br><br><h3> 更改任务优先级 </h3><br> 此API调用为任务赋予了新的优先级。 在Nucleus SE中，由于任务优先级是恒定的，因此不需要。 <br><br> 调用原型： <br><br>  <b>OPTION NU_Change_Priority（NU_TASK *任务，OPTION new_priority）；</b> <br><br> 参数： <br><br>  <b>任务</b> -指向任务控制块的指针; <br>  <b>new_priority-</b>将优先级从0设置为255。 <br><br> 返回值： <br> 先前的任务优先级值。 <br><br><h3> 更改任务抢占算法 </h3><br> 此API调用更改了正在进行的任务排挤的顺序。  Nucleus SE不需要它，因为它使用了更简单的调度算法。 <br><br> 调用原型： <br>  <b>OPTION NU_Change_Preemption（OPTION抢占）；</b> <br><br> 参数： <br>  <b>preempt-</b>新的<b>抢占</b>算法，接受<b>NU_PREEMPT</b>或<b>NU_NO_PREEMPT</b> <br><br> 返回值： <br> 用于挤出任务的先前算法。 <br><br><h3> 更改任务时间片 </h3><br> 此API调用更改特定任务的时间片。  Nucleus SE不需要它，因为任务时间片是固定的。 <br><br> 调用原型： <br>  <b>UNSIGNED NU_Change_Time_Slice（NU_TASK *任务，UNSIGNED time_slice）；</b> <br><br> 参数： <br>  <b>任务</b> -指向任务控制块的指针; <br>  <b>time_slice-</b>在此任务期间可以经过的最大时间<b>片</b>数；此字段的值为零将禁用此任务的时间量化。 <br><br> 返回值： <br> 任务时间量的先前值。 <br><br><h3> 终止任务 </h3><br> 此API调用完成特定任务。  Nucleus SE不需要此功能，因为不支持<i>终止</i>状态。 <br><br> 调用原型： <br>  <b>状态NU_Terminate_Task（NU_TASK *任务）;</b> <br><br> 参数： <br>  <b>task-</b>指向任务控制块的指针。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>表示服务成功完成； <br>  <b>NU_INVALID_TASK-</b>指示任务指针不正确。 <br><br><h2> 兼容Nucleus RTOS </h2><br> 开发Nucleus SE时，主要目标之一是确保与Nucleus RTOS的代码高度兼容。 任务也不例外，从用户的角度来看，它们的实现方式与Nucleus RTOS中的实现方式几乎相同。 我得出了一些不兼容的结论，认为这种不兼容是可以接受的，因为最终代码更容易理解，并且可以更有效地使用内存。 但是，除了这些不兼容之外，其余的Nucleus RTOS API调用几乎都可以直接用作Nucleus SE调用。 以下文章之一将提供有关从Nucleus RTOS到Nucleus SE过渡的更多详细信息 <br><br><h3> 对象标识符 </h3><br> 在Nucleus RTOS中，所有对象均由特定类型的数据结构（控制单元）描述。 指向该控制单元的指针用作任务的标识符。 在Nucleus SE，我决定需要一种不同的方法来有效利用内存。 所有内核对象均由RAM和/或ROM中的一组表描述。 这些表的大小由对象类型的数量决定。 特定对象的标识符是这些表中的索引。 因此，我将<b>NUSE_TASK</b>定义为与<b>U8</b>等效。 这种类型的变量（不是指针）用作任务的标识符。 这是一个很小的不兼容性，很容易弄清楚代码是移植到Nucleus RTOS还是从Nucleus RTOS移植出来。 对象标识符通常被存储和发送不变。 <br><br>  Nucleus RTOS还支持任务命名。 这些名称仅用于调试。 我从Nucleus SE中排除了它们以节省内存。 <br><br><h3> 任务状态 </h3><br> 在Nucleus RTOS中，任务可以处于以下几种状态之一：正在<i>执行</i> ， <i>准备就绪</i> ， <i>已挂起</i> （这导致不确定性：任务处于待机状态或被API调用阻止），已<i>终止</i>或已完成。 <br><br>  Nucleus SE还支持<i>执行</i>和<i>就绪</i>状态。 所有三个“ <i>挂起”</i>选项均受支持。 不支持<i>终止</i>和完成。 没有API调用即可完成任务。 外部任务函数绝不应显式或隐式返回值（这将在Nucleus RTOS中导致<i>完成</i>状态）。 <br><br><h3> 未实现的API调用 </h3><br>  Nucleus RTOS支持16个办公室呼叫以处理任务。 其中有7个未在Nucleus SE中实现。 上面描述了它们的描述以及它们被排除的原因。 <br><br> 在下一篇文章中，我们将开始研究RTOS内存管理。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colin的</a>专业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，电子邮件：colin_walls@mentor.com。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425353/">https://habr.com/ru/post/zh-CN425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425343/index.html">25个有用的Kubernetes工具：部署和管理</a></li>
<li><a href="../zh-CN425345/index.html">名称的简化：802.11ax成为Wi-Fi 6</a></li>
<li><a href="../zh-CN425347/index.html">倾销面具：神话还是现实</a></li>
<li><a href="../zh-CN425349/index.html">积极Hack Days 9论坛将于5月21日至22日在番红花博览会上举行</a></li>
<li><a href="../zh-CN425351/index.html">DIY程序员失业</a></li>
<li><a href="../zh-CN425355/index.html">ICO项目安全等级</a></li>
<li><a href="../zh-CN425357/index.html">我们如何组合12层技术堆栈，但并没有发疯</a></li>
<li><a href="../zh-CN425359/index.html">中国人使用微芯片控制美国计算机</a></li>
<li><a href="../zh-CN425361/index.html">内容拦截，铬浏览器扩展</a></li>
<li><a href="../zh-CN425363/index.html">给学生程序员的提示</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>