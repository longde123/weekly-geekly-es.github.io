<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 🏖️ 👨‍👦‍👦 协调器模式问题以及RouteComposer与它有什么关系 🌳 🤠 🙈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我继续关于我们使用的RouteComposer库的系列文章，今天，我想谈谈Coordinator模式。 通过讨论其中一篇有关模式的文章，我被提示写这篇文章，这里的协调员是Habr。 


 不久前推出的Coordinator模式在iOS开发人员中越来越受欢迎，总的来说，这很清楚。 因为UIKit提供...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>协调器模式问题以及RouteComposer与它有什么关系</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446550/"><p> 我继续关于我们使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RouteComposer</a>库的系列文章，今天，我想谈谈Coordinator模式。 通过讨论其中一篇有关模式的文章，我被提示写这篇文章，这里的协调员是Habr。 </p><br><p> 不久前推出的Coordinator模式在iOS开发人员中越来越受欢迎，总的来说，这很清楚。 因为<strong>UIKit</strong>提供的开箱即用的工具并不是很普遍。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/304/47d/bd8/30447dbd8d2a0a39a34f7f6946a02383.png" alt="图片"></p><a name="habracut"></a><br><p> 我已经提出了在堆栈上构成控制器视图的方式的碎片化问题，并且为了避免重复，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关内容。 </p><br><p>说实话 在某个时候，Epole意识到，通过将控制器放在应用程序开发中心中，她没有提供任何明智的方式来在它们之间创建或传输数据，并且将解决此问题的解决方案委托给开发人员后，它已经由Xcode甚至UISearchConnroller开发人员自动完成了，在某些时候向我们介绍了情节提要和segues。 然后，Epolus意识到她自己编写了由2个屏幕组成的应用程序，并且在下一次迭代中，她建议将情节提要板分成几个组件，因为情节提要板达到一定大小时Xcode开始崩溃。  Segues伴随着这个概念而发生了变化，在几次迭代中彼此之间不太兼容。 他们的支持紧密地缝在了庞大的<code>UIViewController</code>类中，最后，我们得到了我们所得到的。 这是： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"showDetail"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForSelectedRow { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = objects[indexPath.row] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSDate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = (segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>).topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> controller.detailItem = object controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem controller.navigationItem.leftItemsSupplementBackButton = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre> <br><p> 此代码块中强制广播的数量令人惊叹，情节提要中的字符串常量也是如此，它们可以跟踪哪个Xcode根本不提供任何手段。 丝毫希望在导航过程中进行某些更改，这将使您能够毫不费力地编译项目，并且在运行时发生崩溃的情况下，如果没有Xcode的任何警告，它将崩溃。 最终结果就是这样的所见即所得。 所见即所得。 </p><br><p> 您可以在情节提要中争论这些灰色箭头的魅力很长时间，该故事板本来可以显示某人在屏幕之间的联系，但是，正如我的实践所示，我故意采访了几家来自不同公司的熟悉的开发人员，只要该项目扩展到5-6个屏幕以上，人们就会尝试找到更可靠的解决方案，最后开始将视图控制器堆栈的结构保留在我的脑海中。 而且，如果添加了对iPad和其他导航模型的支持或对推送的支持，那么那里的一切都是令人难过的。 </p><br><p> 从那时起，已经进行了数种尝试来解决该问题，其中一些尝试导致了单独的框架，而另一些尝试采用了不同的体系结构模式，因为在视图控制器内部创建视图控制器使此庞大而笨拙的代码段更加复杂。 </p><br><p> 让我们回到协调器模式。 出于明显的原因，您不会在Wikipedia上找到它的描述，因为它不是标准的编程/设计模式。 相反，它是一种抽象，建议将所有这些“丑陋的”代码隐藏在后台，以便在堆栈上创建和插入新的控制器扭曲，保存到控制器容器的链接以及在控制器之间推送数据。 描述此过程的最合适的文章是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">raywenderlich.com</a>上的文章。 在2015年NSSpain会议上，当公众被告知时，它开始变得流行。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>可以找到更详细的信息。 </p><br><p> 在继续之前，我将简要描述其组成。 </p><br><p> 所有解释中的协调器模式都大致适合此图片： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/4bb/f95/5544bbf95415d233060a7e4d515ff58d.png"></p><br><p> 也就是说，协调器是一个协议 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p> 并且所有丑陋的代码都应该隐藏在<code>start</code>函数中。 此外，协调器还可以具有指向子协调器的链接，也就是说，它们具有一定的组合能力，例如，您可以将一个实现替换为另一个实现。 也就是说，听起来很优雅。 </p><br><p> 但是，无罪现象很快就会开始： </p><br><ol><li> 一些实现建议将协调器从某种生成方式转变为更合理的方式，监视控制器堆栈，并<em>使其成为容器的委托</em> ，例如<code>UINavigationController</code> ，以处理按下“后退”按钮或向后滑动并删除子协调器。 出于自然原因，只有一个对象可以是委托，这限制了对容器本身的控制，并导致以下事实：该逻辑要么由协调器承担，要么需要将该逻辑进一步委托给列表中的其他人。 </li><li> 创建下一个控制器的逻辑通常<em>取决于业务逻辑</em> 。 例如，要转到下一个屏幕，用户必须登录到系统。 显然，这是一个异步过程，其中包括使用登录表单生成一些中间屏幕，登录过程本身能否成功结束。 为了避免将协调器转换为大规模协调器（类似于大规模视图控制器），我们需要分解。 也就是说，实际上，您需要创建一个协调器Coordinator。 </li><li> 协调器面临的另一个问题是，它们实际上是容器视图控制器（如<code>UINavigationController</code> ， <code>UITabBarController</code>等）的包装。 有人应该提供<em>到这些控制器的链接</em> 。 如果与儿童协调员之间的一切都不那么清楚，那么对于连锁店的最初协调员，并非一切都那么简单。 另外，在更改导航（例如进行A / B测试）时，此类协调器的重构和调整会导致单独的头痛。 特别是如果容器的类型发生变化。 </li><li> 当应用程序开始支持生成视图控制器的<em>外部事件</em>时，所有这些都变得更加复杂。 例如推送通知或通用链接（用户单击字母中的链接，然后在相应的应用程序屏幕中继续）。 这里出现了其他不确定性，而协调器模式没有确切的答案。 您需要确切知道用​​户当前在哪个屏幕上，以便向他显示外部事件请求的下一个屏幕。 <br> 最简单的示例是一个由三个屏幕组成的聊天应用程序-聊天列表，将聊天本身推送到聊天列表控制器的导航中以及以模态显示的设置屏幕。 当用户接收到推送通知并在其上点击时，他可以在这些屏幕之一上。 然后不确定性就开始了，如果他在聊天列表中，则需要与该特定用户开始聊天；如果他已经在聊天中，则需要进行切换；如果他已经在与该用户聊天中，则不执行任何操作并更新（如果该用户处于在线状态）设置屏幕-它显然需要关闭并按照前面的步骤进行操作。 还是可能无法关闭，只是在设置上模态显示聊天？ 如果设置在另一个选项卡中，而不是模态？ 这些（ <code>if/else</code>开始散布在协调器中，或者以一块意大利面条的形式转到另一个巨型协调器。 另外，它要么是控制器视图堆栈上的活动迭代，要么是确定用户当前所在的位置的尝试，要么是尝试构建某种监视其状态的应用程序，但这并不是一件容易的事，仅基于视图控制器堆栈本身的性质。 </li><li> 蛋糕上的樱桃是<em>UIKit故障</em> 。 一个简单的示例：一个<code>UITabBarController</code> ，在第二个选项卡中带有一个<code>UINavigationController</code> ，以及另一个<code>UIViewController</code> 。 第一个选项卡中的用户会导致某些事件，该事件需要切换选项卡并将另一个视图控制器<code>UINavigationController</code>入其<code>UINavigationController</code> 。 所有这些都需要按照这样的顺序进行。 如果用户在此之前从未打开过第二个选项卡，并且没有在<code>viewDidLoad</code>上调用<code>UINavigationController</code> <code>viewDidLoad</code>则<code>push</code>方法将不起作用，在控制台中仅留下不清楚的消息。 也就是说，在此示例中，不能简单地使协调器成为事件的侦听器，它们必须按一定顺序工作。 因此，他们必须彼此了解。 这已经与协调器模式的第一个陈述相矛盾，即协调器对生成协调器一无所知，仅与子协调器建立联系。 并且也限制了它们的互换性。 </li></ol><br><p> 该列表可以继续，但是总的来说，很明显，协调器模式是一个相当有限的，可扩展性差的解决方案。 如果您不戴粉红色眼镜观看它，那么它是一种将一部分逻辑分解为另一类的方法，该逻辑通常是在大量<code>UIViewController</code>内部编写的。 所有试图使它不仅仅是一个生成工厂，并在那里引入其他逻辑的尝试都没有很好地结束。 </p><br><p> 值得注意的是，有一些基于这种模式的库，以一种或另一种方式，可以部分缓解上述缺点。 我会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提到XCoordinator</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxFlow</a> 。 </p><br><h2 id="chto-sdelali-my"> 我们做了什么？ </h2><br><p> 在参与我们从另一个团队获得支持和开发的项目之后，在<em>VIPER</em>架构方法中使用了协调器及其简化的“曾祖母” <em>路由器</em> ，我们回滚到在公司先前的大型项目中运行良好的方法。 这种方法没有名称。 它位于表面上。 当我们有空闲时间时，它被编译到一个单独的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RouteComposer</a>库中，该库完全替代了协调器，并被证明更加灵活。 </p><br><p> 这是什么方法？ 这样，为了依赖堆栈（树），我按原样扭曲了控制器。 为了不创建不必要的实体，需要对其进行监视。 不要保存或跟踪条件。 </p><br><p> 让我们<em>更</em>仔细地看一下<em>UIKit</em>实体，并尝试找出最重要的内容以及可以使用的内容： </p><br><ol><li>  <strong>控制器堆栈</strong>是一棵树。 有一个具有子视图控制器的根视图控制器。 模态呈现的视图控制器是子视图控制器的一种特殊情况，因为它们也绑定到生成的视图控制器。 开箱即用。 </li><li> 我需要创建控制器的实体。 它们都有不同的构造函数；可以使用Xib文件或Storyboard创建它们。 它们具有不同的输入参数。 但是它们团结在一起，需要创建它们。 因此，在这里我们可以使用<strong>Factory</strong>模式，该模式知道如何创建所需的视图控制器。 每个工厂都很容易进行全面的单元测试，并且彼此独立。 </li><li> 我们将视图控制器分为2类：1.仅查看控制器，2. <strong>容器视图控制器（Container View Controller）</strong> 。 容器视图控制器与普通视图控制器的不同之处在于，它们可以包含子视图控制器，也可以包含容器或简单的子视图控制器。 这样的视图控制器可以直接使用： <code>UINavigationController</code> ， <code>UITabBarController</code>等等，但是也可以由用户创建。 如果忽略它，我们可以在所有容器中找到以下属性：1.它们具有包含的所有控制器的列表。  2.当前可以看到一个或多个控制器。  3.可能会要求他们使这些控制器之一可见。 这就是<em>UIKit</em>控制器所<em>能做的</em> 。 他们只是有不同的方法。 但是只有3个任务。 </li><li> 要嵌入工厂创建的视图控制器，控制器的父视图方法是<code>UINavigationController.pushViewController(...)</code> ， <code>UITabBarController.selectedViewController = ...</code> ， <code>UIViewController.present(...)</code>等。 您可能会注意到，始终需要2个视图控制器，其中一个已经在堆栈中，而另一个则需要嵌入在堆栈中。 用包装器将其包装，然后将其称为<strong>Action（Action）</strong> 。 每个动作都易于通过全面的单元测试来涵盖，并且每个动作都相互独立。 </li><li> 从上面可以看出，使用准备好的实体，您可以构建配置链<em>工厂-&gt;操作-&gt;工厂-&gt;操作-&gt;工厂</em> ，完成后，您可以构建任何复杂程度的控制器视图树。 您只需要指定入口点。 这些输入点通常是<em>UIWindow</em>拥有的<em>rootViewController</em>或当前视图控制器，它是树的最极端的分支。 也就是说，这样的配置正确编写为： <strong>启动ViewController-&gt; Action-&gt; Factory-&gt; ...-&gt; Factory</strong> 。 </li><li> 除了配置之外，您还将需要一些知道如何启动和构建所提供配置的实体。 我们将其称为<strong>Router</strong> 。 它没有状态，不包含任何链接。 它具有一种将配置传递给的方法，并且它顺序执行配置步骤。 </li><li> 通过将<strong>Interceptors</strong>类添加到配置链，为路由器增加责任。 拦截器有3种类型：1.在开始导航之前启动。 我们删除系统中的用户身份验证任务以及其中的其他异步任务。  2.在创建视图控制器时运行以设置值。  3.在导航和执行各种分析任务之后执行。 每个实体都容易被单元测试覆盖，并且不知道如何在配置中使用它。 她只有一项责任，她可以履行。 也就是说，复杂导航的配置可能看起来像<strong>[导航前任务...]-&gt;启动ViewController-&gt;操作-&gt;（Factory + [ContextTask ...]）-&gt; ...-&gt;（Factory + [ContextTask ...]）-&gt; [Post NavigationTask ...]</strong> 。 也就是说，所有任务将由路由器依次执行，依次执行小的，易于阅读的原子实体。 </li><li> 配置无法解决的最后一项任务仍然存在-这是当前应用程序的状态。 如果我们不需要构建整个配置链，而是仅构建其中的一部分，因为用户部分通过了该怎么办？ 视图控制器树始终可以明确回答这个问题。 因为如果链的一部分已经建立，那么它已经在树中了。 这意味着，如果链中的每个工厂都可以回答是否建厂的问题，那么路由器将能够了解链中哪一部分需要完成。 当然，这不是工厂的任务，因此引入了另一个原子实体<strong>-Finder，</strong>并且任何配置都如下所示： <strong>[预导航任务...]-&gt;启动ViewController-&gt;操作-&gt;（Finder / Factory + [ContextTask ...]） -&gt; ...-&gt;（Finder / Factory + [ContextTask ...]）-&gt; [Post NavigationTask ...]</strong> 。 如果路由器从头开始读取它，那么Finders之一将告诉他它已被构建，并且从这一点开始，路由器将开始重新构建链。 如果没有一个人发现自己在树中，那么您需要从初始控制器构建整个链。 <br><img src="https://habrastorage.org/getpro/habr/post_images/f50/a64/213/f50a64213fa1654fbde33e53b31f4e43.gif" alt="图片"></li><li> 该配置必须是强类型的。 因此，每个实体只能使用一种类型的控制器视图；一种类型的数据和配置完全取决于swift与<strong>关联类型</strong>一起工作的能力。 我们要依赖编译器，而不是运行时。 开发人员可以有意地减弱键入，但反之则不能。 </li></ol><br><p> 这种配置的示例： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .add(<span class="hljs-type"><span class="hljs-type">LoginInterceptor</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UUID</span></span>&gt;()) <span class="hljs-comment"><span class="hljs-comment">// Have to specify the context type till https://bugs.swift.org/browse/SR-8719 is fixed .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(UINavigationController.push()) .from(NavigationControllerStep()) .using(GeneralActions.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p> 上面描述的项目涵盖了整个库并描述了该方法。 我们剩下的就是提供当用户单击按钮或发生外部事件时路由器将执行的链配置。 如果这些设备是不同类型的设备（例如iPhone或iPad），那么我们将使用多态性提供不同的过渡配置。 如果我们有A / B测试，那也是一样。 在开始导航时，我们不需要考虑应用程序的状态，我们需要确保最初正确地编写了配置，并且可以确定路由器将以某种方式构建它。 </p><br><p> 所描述的方法比某种抽象或模式要复杂得多，但是我们还没有遇到还不够的问题。 当然， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RouteComposer</a>需要研究和理解其工作方式。 但是，这比学习AutoLayout或RunLoop的基础要容易得多。 没有更高的数学。 </p><br><p> 该库以及提供给它的路由器的实现，在运行时不使用任何客观技巧，而是完全遵循所有Cocoa Touch概念，仅有助于将合成过程分解为多个步骤并按给定顺序执行。 该库已通过iOS 9至12版进行了测试。 </p><br><p> 可以在以前的文章中找到更多详细信息： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UIViewController的组成以及它们之间的导航（不仅如此）/ Geek Magazine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用RouteComposer / Geek Magazine的UIViewControllers的配置示例</a> </p><br><p> 谢谢您的关注。 我很乐意在评论中回答问题。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446550/">https://habr.com/ru/post/zh-CN446550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446536/index.html">队列和JMeter：与发布者和订阅者进行交换</a></li>
<li><a href="../zh-CN446538/index.html">PhotoGuru切换到“暗面”和“更明智”</a></li>
<li><a href="../zh-CN446544/index.html">Microsoft通过Azure IoT创新者和初创公司的新IP优势扩展了Azure IP优势计划</a></li>
<li><a href="../zh-CN446546/index.html">Microsoft通过Azure IoT创新者和初创公司的新IP优势扩展了Azure IP优势</a></li>
<li><a href="../zh-CN446548/index.html">分析广告活动的统计信息-在DataFrame中创建一个新指标（python）</a></li>
<li><a href="../zh-CN446552/index.html">使用示例EToken处理APDU命令</a></li>
<li><a href="../zh-CN446554/index.html">Yandex居民计划，或如何使经验丰富的后端成为ML工程师</a></li>
<li><a href="../zh-CN446558/index.html">异国数据结构：修改后的Merkle Patricia Trie</a></li>
<li><a href="../zh-CN446560/index.html">“礼貌交流”：两家最著名的流媒体公司之间冲突的实质</a></li>
<li><a href="../zh-CN446562/index.html">编程异步</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>