<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø üèí ü§µüèæ Commutateur d'antenne automatique avec commande MK üçÄ üëãüèΩ #‚É£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la pratique de la radio amateur, il est parfois n√©cessaire de faire quelque chose sur le microcontr√¥leur. Si vous ne faites pas ce genre d'artisa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Commutateur d'antenne automatique avec commande MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/405581/"><div style="text-align:center;"><img src="https://habrastorage.org/web/263/1bc/d85/2631bcd85f59492fbe35cfccc226fb15.jpg" alt="image"></div><br>  Dans la pratique de la radio amateur, il est parfois n√©cessaire de faire quelque chose sur le microcontr√¥leur.  Si vous ne faites pas ce genre d'artisanat tout le temps, vous devez rechercher sur Google pendant longtemps la solution de circuit n√©cessaire et les biblioth√®ques appropri√©es pour MK, ce qui vous permet de r√©soudre rapidement le probl√®me.  R√©cemment, j'ai voulu faire un commutateur d'antenne automatique.  Dans le processus, j'ai d√ª utiliser de nombreuses fonctionnalit√©s d'Atmega MK dans un projet compact.  Ceux qui commencent √† √©tudier l'AVR, √† passer de l'arduino ou √† programmer occasionnellement MK peuvent √™tre des morceaux de code utiles que j'utilise dans le projet. <br><a name="habracut"></a><br>  J'ai pens√© au commutateur d'antenne comme un appareil qui connecte automatiquement l'antenne √† l'√©metteur-r√©cepteur, ce qui convient le mieux √† la plage de travail des ondes courtes.  J'ai deux antennes: V invers√© et plan de masse, elles sont connect√©es au tuner d'antenne MFJ, dans lequel elles peuvent √™tre commut√©es √† distance.  Il y a un interrupteur manuel de marque MFJ, que je voulais remplacer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b6e/63f/073/b6e63f07338f40babb1c1cfb06eed94f.gif" alt="image"></div><br>  Pour la commutation op√©rationnelle des antennes, un bouton est connect√© au MK.  Je l'ai adapt√© pour m√©moriser l'antenne pr√©f√©r√©e pour chaque gamme: lorsque vous appuyez sur le bouton pendant plus de 3 secondes, l'antenne s√©lectionn√©e est m√©moris√©e et s√©lectionn√©e correctement automatiquement apr√®s la prochaine mise sous tension de l'appareil.  Des informations sur la port√©e actuelle, l'antenne s√©lectionn√©e et l'√©tat de son r√©glage s'affichent sur un √©cran LCD √† ligne unique. <br><br>  Vous pouvez d√©couvrir de quelle mani√®re l'√©metteur-r√©cepteur travaille actuellement de diff√©rentes mani√®res: vous pouvez mesurer la fr√©quence du signal, vous pouvez recevoir des donn√©es via l'interface CAT, mais le plus simple pour moi est d'utiliser l'interface de l'√©metteur-r√©cepteur YAESU pour connecter un amplificateur externe.  Il dispose de 4 lignes de signaux, en code binaire, indiquant la plage actuelle.  Ils donnent un signal logique de 0 √† 5 volts et ils peuvent √™tre connect√©s aux jambes du MK via une paire de r√©sistances de terminaison. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/85f/6b9/ebf/85f6b9ebf2aa4fe496fc48501171675e.jpg" alt="image"></div><br>  Ce n'est pas tout.  En mode transmission, les signaux PTT et ALC sont transmis via la m√™me interface.  Il s'agit d'un signal logique sur la mise sous tension de l'√©metteur (tir√© au sol) et d'un signal analogique de 0 √† -4 V sur le fonctionnement du syst√®me de contr√¥le automatique de la puissance de l'√©metteur.  J'ai √©galement d√©cid√© de le mesurer et de l'afficher sur l'√©cran LCD en mode transmission. <br><br>  De plus, le syntoniseur MFJ peut transmettre √† la t√©l√©commande des signaux indiquant qu'il syntonise et que l'antenne est syntonis√©e.  Pour ce faire, le panneau de contr√¥le de la soci√©t√© MFJ dispose de deux LED de contr√¥le.  Au lieu de LED, j'ai connect√© les optocoupleurs et envoy√© un signal d'eux au MK, afin que je puisse voir toutes les informations sur un seul √©cran.  L'appareil fini ressemble √† ceci. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e33/38f/2f8/e3338f2f8fff4187b523c0adbdda2d23.jpg" alt="image"></div><br>  En bref sur le fait maison comme tout.  Maintenant sur la partie logicielle.  Le code est √©crit dans Atmel Studio (t√©l√©chargement gratuit sur le site Web d'Atmel).  Le projet pour d√©butants d√©montre les caract√©ristiques suivantes de l'utilisation du populaire Atmega8 MK: <br><br><ol><li>  Bouton de connexion </li><li>  Connectez l'entr√©e ligne pour le signal num√©rique de l'√©metteur-r√©cepteur et du tuner </li><li>  Connexion de la sortie de commande du relais de commutation d'antenne </li><li>  Connexion d'un √©cran LCD sur une seule ligne </li><li>  Connexion du buzzer et sortie audio </li><li>  Connexion de ligne d'entr√©e analogique ADC et mesure de tension </li><li>  Utilisation d'interruptions </li><li>  Utilisation d'une minuterie pour compter le temps o√π un bouton est enfonc√© </li><li>  Utilisation de Watchdog </li><li>  Utilisation d'une m√©moire non volatile pour stocker les antennes s√©lectionn√©es </li><li>  Utilisation de UART pour l'impression de d√©bogage </li><li>  √âconomie d'√©nergie dans le MK inactif </li></ol><br>  Commen√ßons donc.  Au cours du texte, il y aura toutes sortes de noms de registres et de constantes caract√©ristiques du MK appliqu√©.  Ce n'est pas de l'arduino, ici, malheureusement, vous devez lire la fiche technique sur MK.  Sinon, vous ne comprenez pas ce que signifient tous ces registres et comment vous pouvez modifier leurs valeurs.  Mais la structure du programme dans son ensemble restera la m√™me. <br><br><h3>  Tout d'abord, connectez le bouton au MK </h3><br>  C'est le plus simple.  Nous connectons un contact au pied MK, le deuxi√®me contact du bouton au sol.  Pour que le bouton fonctionne, vous devrez activer la r√©sistance de rappel dans MK.  Il connectera le bouton via la r√©sistance au bus + 5V.  Pour ce faire, c'est assez simple: <br><br><pre><code class="cpp hljs">PORTB |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB2); <span class="hljs-comment"><span class="hljs-comment">// pullup resistor  </span></span></code> </pre> <br>  De m√™me, toutes les entr√©es num√©riques contr√¥l√©es par un d√©faut √† la terre (optocoupleurs, lignes de signal de l'√©metteur-r√©cepteur, signal PTT) sont tir√©es vers le bus + 5V.  Parfois, il est pr√©f√©rable de souder physiquement une r√©sistance aussi petite (par exemple 10k) entre l'entr√©e du MK et le bus + 5V, mais la discussion de ce probl√®me d√©passe le cadre de l'article.  √âtant donn√© que tous les signaux d'entr√©e du projet changent rarement de valeurs, ils sont shunt√©s au sol par 10 condensateurs nanofarad pour se prot√©ger contre les interf√©rences. <br><br>  Maintenant, nous avons 1 logique √† l'entr√©e PB2, et lorsque vous appuyez sur le bouton, il sera logique 0. Lorsque vous appuyez sur \ presser, vous devez suivre le rebond de contact du bouton, en v√©rifiant que le niveau du signal n'a pas chang√© au fil du temps, disons 50 millisecondes.  Cela se fait dans le programme comme ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; !timer_on) { <span class="hljs-comment"><span class="hljs-comment">//    _delay_ms(50); if( !(PINB&amp;(1&lt;&lt;PINB2)) ) { //        -   passed_secs = 0; timer_on = 1; } }</span></span></code> </pre><br><h3>  Maintenant, connectez le squeaker </h3><br>  Il donnera un signal audio de confirmation que l'antenne est enregistr√©e dans la m√©moire MK.  Un tweeter n'est qu'un √©l√©ment pi√©zo√©lectrique.  Il est reli√© par une petite r√©sistance au pied MK, et par un deuxi√®me contact √† + 5V.  Pour que ce buzzer fonctionne, vous devez d'abord configurer le pied MK pour produire des donn√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_buzzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB0); <span class="hljs-comment"><span class="hljs-comment">// buzzer DDRB |= (1 &lt;&lt; PB0); // output PORTB &amp;= ~(1 &lt;&lt; PB0); }</span></span></code> </pre><br>  Maintenant, il peut √™tre utilis√©.  Pour ce faire, une petite fonction est √©crite qui utilise des retards pour commuter les jambes MK de 0 √† 1 et vice versa.  La commutation avec les retards n√©cessaires permet de g√©n√©rer un signal audio de 4 kHz d'une dur√©e d'environ un quart de seconde √† la sortie MK, qui est le son de l'√©l√©ment pi√©zo√©lectrique. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buzz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    4 0,25  for(int i=0; i&lt;1000; i++) { wdt_reset(); //    PORTB |= (1 &lt;&lt; PB0); _delay_us(125); PORTB &amp;= ~(1 &lt;&lt; PB0); _delay_us(125); } }</span></span></code> </pre><br>  Pour que les fonctions de d√©lai fonctionnent, n'oubliez pas d'inclure le fichier d'en-t√™te et de d√©finir la vitesse du processeur constante.  Elle est √©gale √† la fr√©quence du r√©sonateur √† quartz connect√© au MK.  Dans mon cas, il y avait du quartz √† 16 MHz. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> F_CPU # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;util/delay.h&gt;</span></span></span></span></code> </pre><br><h3>  Nous nous connectons aux antennes de commutation relais MK </h3><br>  Ici, il vous suffit de configurer le pied MK pour fonctionner √† la sortie.  Un relais reed est connect√© √† cette jambe via un transistor amplificateur de mani√®re standard. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_tuner_relay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB1); <span class="hljs-comment"><span class="hljs-comment">// relay DDRB |= (1 &lt;&lt; PB1); // output PORTB &amp;= ~(1 &lt;&lt; PB1); }</span></span></code> </pre><br><h3>  Connexion d'affichage </h3><br>  J'ai utilis√© un √©cran LCD 1601 √† une seule ligne de 16 caract√®res, extrait de l'ancien mat√©riel.  Il utilise le c√©l√®bre contr√¥leur HD44780, pour la gestion duquel de nombreuses biblioth√®ques sont disponibles sur le r√©seau.  Une personne gentille a √©crit une biblioth√®que de contr√¥le d'affichage l√©g√®re, que j'ai utilis√©e dans le projet.  La configuration de la biblioth√®que se r√©duit √† indiquer dans le fichier d'en-t√™te HD44780_Config.h le nombre de branches MK connect√©es aux broches d'affichage souhait√©es.  J'ai appliqu√© une connexion d'affichage sur 4 lignes de donn√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Data_Length 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NumberOfLines 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Font 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_E PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_E 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_RS PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_RS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_4 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_4 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_5 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_5 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_6 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_6 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_7 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_7 3</span></span></code> </pre><br>  Une caract√©ristique de mon instance d'affichage √©tait qu'une ligne sur l'√©cran √©tait affich√©e en deux lignes de 8 caract√®res, donc un tampon d'√©cran interm√©diaire a √©t√© cr√©√© dans le programme pour un travail plus pratique avec l'√©cran. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTC &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PC0); <span class="hljs-comment"><span class="hljs-comment">// display DDRC |= (1 &lt;&lt; PC0); // output PORTC &amp;= ~(1 &lt;&lt; PC0); PORTC &amp;= ~(1 &lt;&lt; PC1); // display DDRC |= (1 &lt;&lt; PC1); // output PORTC &amp;= ~(1 &lt;&lt; PC1); PORTC &amp;= ~(1 &lt;&lt; PC2); // display DDRC |= (1 &lt;&lt; PC2); // output PORTC &amp;= ~(1 &lt;&lt; PC2); PORTC &amp;= ~(1 &lt;&lt; PC3); // display DDRC |= (1 &lt;&lt; PC3); // output PORTC &amp;= ~(1 &lt;&lt; PC3); PORTC &amp;= ~(1 &lt;&lt; PC4); // display DDRC |= (1 &lt;&lt; PC4); // output PORTC &amp;= ~(1 &lt;&lt; PC4); PORTC &amp;= ~(1 &lt;&lt; PC5); // display DDRC |= (1 &lt;&lt; PC5); // output PORTC &amp;= ~(1 &lt;&lt; PC5); LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); } /*   16  0-3   40M     4-8   A:GP  A:IV     9-15    : TUNING=, TUNED==, HI-SWR= */ uchar display_buffer[]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '}; // 16    void update_display() { LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); //   16      8         LCD for (uchar i=0; i&lt;8; i++){ LCD_Show(display_buffer[i],1,i); LCD_Show(display_buffer[i+8],2,i); } }</span></span></code> </pre><br>  La fonction update_display () vous permet d'afficher le contenu du tampon √† l'√©cran.  Les valeurs d'octets dans le tampon sont les codes ASCII des caract√®res de sortie. <br><br><h3>  D√©boguer la sortie d'impression vers le port COM </h3><br>  MK a UART et je l'ai utilis√© pour d√©boguer le programme.  Lors de la connexion du MK √† l'ordinateur, vous devez simplement vous rappeler que les niveaux de signal √† la sortie MK sont dans la norme TTL, et non RS232, vous avez donc besoin d'un adaptateur simple.  J'ai utilis√© un adaptateur USB-s√©rie, similaire sur aliexpress.  Tout programme de terminal, par exemple d'arduino, convient √† la lecture de donn√©es.  Code de configuration du port UART: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BAUD 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;avr/io.h&gt; // UART      RS232 void uart_init( void ) { /* //   UBRRH = 0; UBRRL = 103; //9600   16  */ #include &lt;util/setbaud.h&gt; UBRRH = UBRRH_VALUE; UBRRL = UBRRL_VALUE; #if USE_2X UCSRA |= (1 &lt;&lt; U2X); #else UCSRA &amp;= ~(1 &lt;&lt; U2X); #endif //8  , 1  ,    UCSRC = ( 1 &lt;&lt; URSEL ) | ( 1 &lt;&lt; UCSZ1 ) | ( 1 &lt;&lt; UCSZ0 ); //     // UCSRB = ( 1 &lt;&lt; TXEN ) | ( 1 &lt;&lt;RXEN ); UCSRB = ( 1 &lt;&lt; TXEN ); } int uart_putc( char c, FILE *file ) { //     while( ( UCSRA &amp; ( 1 &lt;&lt; UDRE ) ) == 0 ); UDR = c; wdt_reset(); return 0; } FILE uart_stream = FDEV_SETUP_STREAM( uart_putc, NULL, _FDEV_SETUP_WRITE ); stdout = &amp;uart_stream;</span></span></span></span></code> </pre><br>  Apr√®s avoir configur√© le flux de sortie, vous pouvez utiliser le printf habituel pour imprimer sur le port: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"Start flag after reset = %u\r\n"</span></span>, mcusr_mirror );</code> </pre> <br>  Le programme utilise l'impression de nombres r√©els.  Les biblioth√®ques normales ne prennent pas en charge ce mode de sortie, j'ai donc d√ª connecter une biblioth√®que compl√®te lors de la liaison d'un projet.  Certes, cela augmente s√©rieusement la quantit√© de code, mais j'avais une grande quantit√© de m√©moire, donc ce n'√©tait pas critique.  Dans les options de l'√©diteur de liens, vous devez sp√©cifier la ligne: <br><br> <code>-Wl,-u,vfprintf -lprintf_flt</code> <br> <br><h3>  Travailler avec minuterie et interruptions </h3><br>  Pour compter les intervalles de temps dans un programme, il est important d'avoir un compteur de temps.  Il est n√©cessaire de v√©rifier que le bouton est enfonc√© pendant plus de 3 secondes et, par cons√©quent, vous devez vous souvenir des nouveaux param√®tres dans la m√©moire non volatile.  Pour mesurer le temps dans le style AVR, vous devez configurer le compteur d'impulsions du g√©n√©rateur d'horloge et l'interruption qui sera ex√©cut√©e lorsque le compteur atteindra la valeur d√©finie.  J'ai r√©gl√© la minuterie pour qu'elle produise une interruption environ une fois par seconde.  Le gestionnaire d'interruption lui-m√™me compte le nombre de secondes √©coul√©es.  La variable timer_on contr√¥le l'activation / d√©sactivation du temporisateur.  Il est important de ne pas oublier de d√©clarer toutes les variables qui sont mises √† jour dans le gestionnaire d'interruption comme volatiles, sinon le compilateur peut les ¬´optimiser¬ª et le programme ne fonctionnera pas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1    -     void timer1_init( void ) { TCCR1A = 0; //    1 -   /* 16000000 / 1024 = 15625 ,     15625      1  */ //  CTC, ICP1 interrupt sense (falling)(not used) + prescale /1024 +    (not used) TCCR1B = (0 &lt;&lt; WGM13) | (1 &lt;&lt; WGM12) | (0 &lt;&lt; ICES1) | ((1 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (1 &lt;&lt; CS10)) | (0 &lt;&lt; ICNC1); OCR1A = 15625; //  TIMSK |= (1 &lt;&lt; OCIE1A); } uchar timer_on = 0; volatile uchar passed_secs = 0; //      e ISR(TIMER1_COMPA_vect) { if (timer_on) passed_secs++; }</span></span></code> </pre><br>  La valeur depass_secs est v√©rifi√©e dans la boucle principale du programme.  Lorsque le bouton est enfonc√©, la minuterie d√©marre, puis dans le cycle de programme principal, la valeur de la minuterie est v√©rifi√©e lorsque le bouton est enfonc√©.  Si cette valeur d√©passe 3 secondes, l'EEPROM est √©crite et la minuterie s'arr√™te. <br><br>  Enfin et surtout, apr√®s toutes les initialisations, vous devez activer les interruptions avec la commande sei (). <br><br><h3>  Mesure de niveau ALC </h3><br>  Il est fabriqu√© √† l'aide du convertisseur analogique-num√©rique (ADC) int√©gr√©.  J'ai mesur√© la tension √† l'entr√©e de l'ADC7.  Il faut se rappeler que vous pouvez mesurer une valeur de 0 √† 2,5V.  et ma tension d'entr√©e √©tait de -4V √† 0V.  Par cons√©quent, j'ai connect√© le MK via le diviseur de tension le plus simple des r√©sistances, de sorte que le niveau de tension √† l'entr√©e MK √©tait √† un niveau donn√©.  De plus, je n'avais pas besoin d'une grande pr√©cision, j'ai donc appliqu√© une conversion 8 bits (il suffit de lire les donn√©es uniquement du registre ADCH).  Comme source de r√©f√©rence, j'ai utilis√© un ion interne √† 2,56 V, cela simplifie l√©g√®rement les calculs.  Pour que l'ADC fonctionne, assurez-vous de connecter un condensateur de 0,1 ¬µF au pied REF au sol. <br><br>  ADC dans mon cas fonctionne en continu, signalant la fin de la conversion en appelant l'interruption ADC_vect.  Il est recommand√© de faire la moyenne des valeurs de plusieurs cycles de conversion pour r√©duire l'erreur.  Dans mon cas, je d√©duis la moyenne de 2500 transformations.  Tout le code ADC ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ALC #define SAMPLES 2500 //    #define REFERENCEV 2.56 //       #define DIVIDER 2.0 double realV = 0; //     ALC double current_realV = 0; volatile int sampleCount = 0; volatile unsigned long tempVoltage = 0; //     volatile unsigned long sumVoltage = 0; //         void ADC_init() // ADC7 { //   2,56, 8 bit  -   ADCH ADMUX = (1 &lt;&lt; REFS0) | (1 &lt;&lt; REFS1) | (1 &lt;&lt; ADLAR) | (0 &lt;&lt; MUX3) | (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX1) | (1 &lt;&lt; MUX0); // ADC7 // , free running,   ADCSRA = (1 &lt;&lt; ADEN) | (1 &lt;&lt; ADFR) | (1 &lt;&lt; ADIE) | (1 &lt;&lt; ADPS2) | (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); //  128 ADCSRA |= (1 &lt;&lt; ADSC); // Start ADC Conversion } ISR(ADC_vect) //     2500  { if (sampleCount++) //    tempVoltage += ADCH; if (sampleCount &gt;= SAMPLES) { sampleCount = 0; sumVoltage = tempVoltage; tempVoltage = 0; } ADCSRA |=(1 &lt;&lt; ADIF); // Acknowledge the ADC Interrupt Flag } realV = -1.0*(DIVIDER * ((sumVoltage * REFERENCEV) / 256) / SAMPLES - 5.0); //   ALC if (realV &lt; 0.0) realV = 0.0; printf("ALC= -%4.2f\r\n", realV); //     </span></span></code> </pre><br><h3>  Utilisation de l'EEPROM </h3><br>  Il s'agit d'une m√©moire non volatile dans MK.  Il est pratique de l'utiliser pour stocker toutes sortes de param√®tres, valeurs de correction, etc.  Dans notre cas, il est utilis√© uniquement pour stocker l'antenne s√©lectionn√©e pour la port√©e souhait√©e.  √Ä cet effet, un tableau de 16 octets est allou√© dans l'EEPROM.  Mais vous pouvez y acc√©der via des fonctions sp√©ciales d√©finies dans le fichier d'en-t√™te avr / eeprom.h.  Au d√©marrage, le MK lit les informations sur les param√®tres enregistr√©s dans la RAM et allume l'antenne souhait√©e, en fonction de la port√©e actuelle.  Lorsque vous appuyez longuement sur le bouton, une nouvelle valeur est enregistr√©e dans la m√©moire, accompagn√©e d'un signal sonore.  Lors de l'√©criture dans l'EEPROM, les interruptions sont d√©sactiv√©es au cas o√π.  Code d'initialisation de la m√©moire: <br><br><pre> <code class="cpp hljs">EEMEM <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ee_bands[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//         unsigned char avr_bands[16]; void EEPROM_init(void) { for(int i=0; i&lt;16; i++) { avr_bands[i] = eeprom_read_byte(&amp;ee_bands[i]); if (avr_bands[i] &gt; 1) avr_bands[i] = ANT_IV; //    EEPROM   ,     FF } }</span></span></code> </pre><br>  Un extrait du code de traitement pour appuyer sur un bouton pendant 3 secondes et √©crire dans la m√©moire: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; passed_secs &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    3  timer_on = 0; //   read_ant = avr_bands[read_band]; //     cli(); EEPROM_init(); //          sei(); if (read_ant) { avr_bands[read_band] = ANT_GP; } else { avr_bands[read_band] = ANT_IV; } cli(); eeprom_write_byte(&amp;ee_bands[read_band], avr_bands[read_band]); //    EEPROM sei(); buzz(); }</span></span></code> </pre><br><h3>  Utilisation de Watchdog </h3><br>  Ce n'est un secret pour personne que dans des conditions de fortes interf√©rences √©lectromagn√©tiques, le MK peut geler.  Lorsque la radio est en fonctionnement, il y a une telle interf√©rence que ¬´les fers commencent √† parler¬ª, vous devez donc assurer un red√©marrage soigneux du MK en cas de blocage.  Une minuterie de surveillance sert √† cet effet.  Son utilisation est tr√®s simple.  Tout d'abord, incluez le fichier d'en-t√™te avr / wdt.h dans le projet.  Au d√©but du programme, apr√®s avoir termin√© tous les param√®tres, vous devez d√©marrer le minuteur en appelant la fonction wdt_enable (WDTO_2S), puis n'oubliez pas de le r√©initialiser p√©riodiquement en appelant wdt_reset (), sinon il red√©marrera le MK.  Pour le d√©bogage afin de savoir pourquoi le MK a √©t√© red√©marr√©, vous pouvez utiliser la valeur du registre MCUSR sp√©cial, dont la valeur peut √™tre m√©moris√©e puis sortie dans l'impression de d√©bogage. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        //     uint8_t mcusr_mirror __attribute__ ((section (".noinit"))); void get_mcusr(void) \ __attribute__((naked)) \ __attribute__((section(".init3"))); void get_mcusr(void) { mcusr_mirror = MCUSR; MCUSR = 0; wdt_disable(); } printf( "Start flag after reset = %u\r\n", mcusr_mirror );</span></span></code> </pre><br><h3>  √âconomiser de l'√©nergie pour les amoureux de l'environnement </h3><br>  Alors que MK n'est occup√© √† rien, il peut s'endormir et attendre la prochaine interruption.  Dans ce cas, un peu d'√©nergie √©lectrique est √©conomis√©e.  Une bagatelle, mais pourquoi ne pas l'utiliser dans un projet.  De plus, c'est tr√®s simple.  Incluez le fichier d'en-t√™te avr / sleep.h.  Le corps du programme se compose d'une boucle infinie dans laquelle vous devez appeler la fonction sleep_cpu (), apr√®s quoi le MC s'endort un peu et la boucle principale s'arr√™te jusqu'√† la prochaine interruption.  Ils se produisent pendant le fonctionnement de la minuterie et de l'ADC, donc MK ne dormira pas longtemps.  Le mode d'hibernation est d√©termin√© lorsque le MK est initialis√© en appelant deux fonctions: <br><br><pre> <code class="cpp hljs"> set_sleep_mode(SLEEP_MODE_IDLE); <span class="hljs-comment"><span class="hljs-comment">//     IDLE sleep_enable();</span></span></code> </pre><br>  C'est tout pour l'instant.  J'ai fait le changement, cela fonctionne avec succ√®s sur ma station de radio amateur sans √©checs.  J'esp√®re que le mat√©riel fourni sera utile aux d√©butants. <br><br>  73 de R2AJP </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr405581/">https://habr.com/ru/post/fr405581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr405571/index.html">√âl√©ments du syst√®me national d'innovation des √âtats-Unis, partie 1: environnement des affaires et politique fiscale, commerciale et √©conomique</a></li>
<li><a href="../fr405573/index.html">Syst√®me d'alerte automatique d'attaque de police</a></li>
<li><a href="../fr405575/index.html">Courte critique du smartphone ASUS ZenFone 4 Max</a></li>
<li><a href="../fr405577/index.html">Syst√®me national d'innovation am√©ricain</a></li>
<li><a href="../fr405579/index.html">"Bonjour Vietnam!": Comment d√©marrer votre radio Internet</a></li>
<li><a href="../fr405583/index.html">Haut-parleur portable Vibro PartyFon</a></li>
<li><a href="../fr405585/index.html">Lockheed Martin construit un prototype de module habitable pour l'espace lointain</a></li>
<li><a href="../fr405587/index.html">Nous comprenons la physique des particules: 4) les ondes, l'√©quation classique du mouvement</a></li>
<li><a href="../fr405589/index.html">Google aide les r√©acteurs √† fusion √† chauffer le plasma dans le r√©acteur √† l'aide d'un logiciel sp√©cial</a></li>
<li><a href="../fr405591/index.html">Les fonctionnaires du FAS choisissent un op√©rateur fiscal pour les biens achet√©s par des Russes √† l'√©tranger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>