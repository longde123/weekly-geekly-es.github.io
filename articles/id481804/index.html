<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßí ü§æ üßõüèº Meningkatkan allOf dan anyOf di CompletableFuture üöµüèº üêò üì≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo lagi. Untuk mengantisipasi dimulainya kursus, "Pengembang Java" menyiapkan terjemahan materi yang bermanfaat untuk Anda. 

 Ada dua metode di Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meningkatkan allOf dan anyOf di CompletableFuture</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/481804/"><img src="https://habrastorage.org/webt/gc/sm/pj/gcsmpjevr7eltr5um1rsj6iznly.png"><br><br>  <i>Halo lagi.</i>  <i>Untuk mengantisipasi dimulainya kursus, <a href="https://otus.pw/lzgB/">"Pengembang Java"</a> menyiapkan terjemahan materi yang bermanfaat untuk Anda.</i> <br><hr><br>  Ada dua metode di <code>CompletableFuture</code> yang desainnya mengejutkan saya: <br><br><ul><li>  CompletableFuture # allOf </li><li>  CompletableFuture # anyOf </li></ul><br><br>  Pada artikel ini kita akan melihat apa yang salah dengan mereka dan bagaimana mereka dapat dibuat lebih nyaman. <a name="habracut"></a><br><br><h4>  CompletableFuture # allOf </h4><br>  Mari kita lihat tanda tangan metode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  Setidaknya ada dua masalah yang diperdebatkan di sini: <br><br><ol><li>  Metode ini menerima beberapa objek <code>CompletableFuture</code> yang mengembalikan objek dari tipe yang berbeda. </li><li>  Metode mengembalikan <code>CompletableFuture</code> , yang mengembalikan <code>Void</code> </li></ol><br><br>  Juga, beberapa mungkin tidak suka jumlah variabel parameter, jadi mari kita lihat bagian ini juga. <br><br>  <code><code>CompletableFuture&lt;Void&gt;</code></code> sering digunakan sebagai sinyal untuk menyelesaikan operasi, namun, dengan membuat perubahan kecil pada API, <b>metode ini dapat digunakan baik sebagai perangkat pensinyalan dan sebagai pembawa hasil semua operasi selesai</b> .  Mari kita coba melakukannya. <br><br><h4>  Asynchronous CompletableFuture # allOf </h4><br>  Pertama, mari kita datang dengan tanda tangan yang tepat. <br><br>  Adalah wajar untuk mengasumsikan bahwa dalam kebanyakan kasus memproses daftar <code>CompletableFuture</code> homogen dan mengembalikan <code>CompletableFuture</code> berisi daftar hasil akan diperlukan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOf( Collection&lt;CompletableFuture&lt;T&gt;&gt; futures) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  Jeroan metode asli kemungkinan besar lebih kompleks daripada yang Anda harapkan: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CompletableFuture&lt;?&gt;[] cfs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture&lt;Void&gt; d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture&lt;Void&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lo &gt; hi) <span class="hljs-comment"><span class="hljs-comment">// empty d.result = NIL; else { CompletableFuture&lt;?&gt; a, b; int mid = (lo + hi) &gt;&gt;&gt; 1; if ((a = (lo == mid ? cfs[lo] : andTree(cfs, lo, mid))) == null || (b = (lo == hi ? a : (hi == mid+1) ? cfs[hi] : andTree(cfs, mid+1, hi))) == null) throw new NullPointerException(); if (!d.biRelay(a, b)) { BiRelay&lt;?,?&gt; c = new BiRelay&lt;&gt;(d, a, b); a.bipush(b, c); c.tryFire(SYNC); } } return d; }</span></span></code> </pre> <br><br>  Karena itu, alih-alih membuatnya dari awal, kami akan mencoba menggunakan kembali apa yang sudah ada dalam metode asli seolah-olah itu dimaksudkan untuk digunakan sebagai perangkat pensinyalan penyelesaian ... dan kemudian hanya mengubah hasil yang kosong ke daftar di masa mendatang: <br><br><pre> <code class="java hljs">CompletableFuture&lt;List&lt;CompletableFuture&lt;T&gt;&gt;&gt; i = futures.stream() .collect(collectingAndThen( toList(), l -&gt; CompletableFuture.allOf(l.toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .thenApply(__ -&gt; l)));</code> </pre> <br><br>  Sejauh ini bagus.  Kami berhasil mendapatkannya <br>  <code><code>CompletableFuture&lt;List&lt;CompletableFuture&lt;T&gt; <code>&gt;</code> <code>&gt;</code></code></code> <code><code>CompletableFuture&lt;Void&gt;</code></code> bukan <code><code>CompletableFuture&lt;Void&gt;</code></code> , yang sudah baik.  Tetapi kita tidak perlu daftar masa depan dengan hasil, kita perlu daftar hasil. <br><br>  Sekarang kita bisa memproses daftar dan menghapus masa depan yang tidak diinginkan dari itu.  Sangatlah normal untuk memanggil metode join CompletableFuture #, karena kita tahu bahwa mereka tidak akan pernah diblokir (pada titik ini, semua masa depan sudah selesai): <br><br><pre> <code class="java hljs">CompletableFuture&lt;List&lt;T&gt;&gt; result = intermediate .thenApply(list -&gt; list.stream() .map(CompletableFuture::join) .collect(toList()));</code> </pre> <br><br>  Sekarang mari kita gabungkan semua ini menjadi solusi final: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOf( Collection&lt;CompletableFuture&lt;T&gt;&gt; futures) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> futures.stream() .collect(collectingAndThen( toList(), l -&gt; CompletableFuture.allOf(l.toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .thenApply(__ -&gt; l.stream() .map(CompletableFuture::join) .collect(Collectors.toList())))); }</code> </pre> <br><br><h4>  Asynchronous dan Jatuh CompletableFuture # allOf </h4><br>  Jika ada pengecualian, CompletableFuture # allOf yang asli menunggu semua operasi yang tersisa untuk diselesaikan. <br><br>  Dan jika kita ingin melaporkan penyelesaian operasi ketika ada pengecualian di dalamnya, maka kita harus mengubah implementasinya. <br><br>  Untuk melakukan ini, buat instance baru <code>CompletableFuture</code> dan hentikan secara manual setelah salah satu operasi menimbulkan pengecualian: <br><br><pre> <code class="java hljs">CompletableFuture&lt;List&lt;T&gt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture&lt;&gt;(); futures.forEach(f -&gt; f .handle((__, ex) -&gt; ex == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || result.completeExceptionally(ex)));</code> </pre> <br><br>  ... tapi kemudian kita harus berurusan dengan skenario ketika semua masa depan akan selesai dengan sukses.  Ini dapat dengan mudah dilakukan dengan menggunakan metode allOf () yang ditingkatkan, dan kemudian cukup hentikan masa depan secara manual: <br><br><pre> <code class="java hljs">allOf(futures).thenAccept(result::complete);</code> </pre> <br><br>  Sekarang kita bisa menggabungkan semuanya untuk membentuk solusi akhir: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOfShortcircuiting(Collection&lt;CompletableFuture&lt;T&gt;&gt; futures) { CompletableFuture&lt;List&lt;T&gt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (CompletableFuture&lt;?&gt; f : futures) { f.handle((__, ex) -&gt; ex == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || result.completeExceptionally(ex)); } allOf(futures).thenAccept(result::complete); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br><h4>  CompletableFuture # anyOf </h4><br>  Mari kita mulai dengan tanda tangan metode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  Kami dapat segera mendeteksi masalah yang sama dengan metode yang dibahas di atas: <br><br><ol><li>  Metode ini menerima beberapa objek <code>CompletableFuture</code> berisi objek dari tipe yang berbeda. </li><li>  Metode mengembalikan <code>CompletableFuture</code> berisi objek bertipe <code>Object</code> . </li></ol><br><br>  Sejauh yang saya mengerti, metode <code>CompletableFuture#allOf</code> dirancang untuk digunakan sebagai perangkat pensinyalan.  Tetapi <code>CompletableFuture#anyOf</code> tidak mengikuti filosofi ini, mengembalikan <code><code>CompletableFuture&lt;Object&gt;</code></code> , yang bahkan lebih membingungkan. <br><br>  Lihatlah contoh berikut di mana saya mencoba memproses CompletableFuture yang berisi data dari berbagai jenis: <br><br><pre> <code class="java hljs">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.completedFuture(<span class="hljs-number"><span class="hljs-number">1</span></span>); CompletableFuture&lt;String&gt; f2 = CompletableFuture.completedFuture(<span class="hljs-string"><span class="hljs-string">"2"</span></span>); Integer result = CompletableFuture.anyOf(f1, f2) .thenApply(r -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Integer) r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.valueOf((String) r); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"unexpected object type!"</span></span>); }).join();</code> </pre> <br><br>  Cukup tidak nyaman, bukan? <br><br>  Untungnya, ini cukup mudah untuk beradaptasi dengan skenario yang lebih umum (menunggu salah satu dari banyak nilai di masa depan dengan jenis yang sama) dengan mengubah tanda tangan dan memperkenalkan casting tipe langsung. <br><br>  Dengan demikian, dengan peningkatan kami, kami dapat menggunakan kembali metode yang ada dan membawa hasilnya dengan aman: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;CompletableFuture&lt;T&gt;&gt; cfs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.anyOf(cfs.toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .thenApply(o -&gt; (T) o); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;T&gt;... cfs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.anyOf(cfs).thenApply(o -&gt; (T) o); }</code> </pre> <br><br><h3>  Kode sumber </h3><br>  Kode sumber dapat ditemukan di <a href="">Github</a> . <br><br>  Itu saja.  Sampai jumpa di <a href="https://otus.pw/lzgB/">lapangan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481804/">https://habr.com/ru/post/id481804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481792/index.html">Bagaimana PVS-Studio mengadakan paruh kedua dari konferensi 2019</a></li>
<li><a href="../id481794/index.html">Beckender - seorang psikoterapis: seorang debugger untuk jiwa</a></li>
<li><a href="../id481796/index.html">Cara membagi peran dalam proyek Laravel: ikhtisar paket RBAC</a></li>
<li><a href="../id481798/index.html">Menggabungkan tidak kompatibel: tim pengembangan produk dan dukungan semua digulung menjadi satu</a></li>
<li><a href="../id481800/index.html">VPS Anggaran dengan adapter video: perbandingan penyedia Rusia</a></li>
<li><a href="../id481806/index.html">Tes Unit Python: Mulai Cepat</a></li>
<li><a href="../id481808/index.html">Mengapa dukungan otomasi merugikan bisnis</a></li>
<li><a href="../id481812/index.html">Penelitian saya - yang bekerja di bidang TI - profesi, keterampilan, motivasi, pengembangan karir, teknologi (DIPERBARUI 12/26/2019)</a></li>
<li><a href="../id481814/index.html">FunCode Java / Kotlin menantang kontes backend</a></li>
<li><a href="../id481818/index.html">Memigrasi server yang sedang berjalan ke RAID</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>