<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 📧 🙇 Raccourcis JavaScript pour les débutants 🍮 📻 🌥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les fermetures sont l'un des concepts fondamentaux de JavaScript, provoquant des difficultés pour de nombreux débutants, que chaque programmeur JS dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raccourcis JavaScript pour les débutants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424967/">  Les fermetures sont l'un des concepts fondamentaux de JavaScript, provoquant des difficultés pour de nombreux débutants, que chaque programmeur JS devrait connaître et comprendre.  Ayant une bonne compréhension des fermetures, vous pouvez écrire un code meilleur, plus efficace et plus propre.  Et cela, à son tour, contribuera à votre croissance professionnelle. <br><br>  Le matériel, dont nous publions la traduction aujourd'hui, est consacré à l'histoire des mécanismes internes des fermetures et à leur fonctionnement dans les programmes JavaScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'une fermeture?</font> </h2><br>  Une fermeture est une fonction qui a accès à un périmètre formé par une fonction externe par rapport à elle, même après que cette fonction externe a terminé son travail.  Cela signifie qu'une fermeture peut stocker des variables déclarées dans une fonction externe et des arguments qui lui sont passés.  Avant de procéder, en fait, aux fermetures, nous comprendrons le concept d '«environnement lexical». <br><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'un environnement lexical?</font> </h2><br>  Le terme «environnement lexical» ou «environnement statique» en JavaScript fait référence à la possibilité d'accéder à des variables, des fonctions et des objets en fonction de leur emplacement physique dans le code source.  Prenons un exemple: <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br>  Ici, la fonction <code>inner()</code> a accès aux variables déclarées dans sa propre portée, dans la portée de la fonction <code>outer()</code> et dans la portée globale.  La fonction <code>outer()</code> a accès aux variables déclarées dans sa propre portée et dans la portée globale. <br><br>  La chaîne de portée du code ci-dessus ressemblera à ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br>  Notez que la fonction <code>inner()</code> est entourée par l'environnement lexical de la fonction <code>outer()</code> , qui à son tour est entourée d'une portée globale.  C'est pourquoi la fonction <code>inner()</code> peut accéder aux variables déclarées dans la fonction <code>outer()</code> et dans la portée globale. <br><br><h2>  <font color="#3AC1EF">Exemples pratiques de fermetures</font> </h2><br>  Considérez, avant de démonter les subtilités des circuits internes, quelques exemples pratiques. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Ici, nous appelons la fonction <code>person()</code> , qui renvoie la fonction interne <code>displayName()</code> , et stockons cette fonction dans la variable <code>peter</code> .  Lorsque, après cela, nous appelons la fonction <code>peter()</code> (la variable correspondante stocke en fait une référence à la fonction <code>displayName()</code> ), le nom <code>Peter</code> est affiché dans la console. <br><br>  En même temps, il n'y a pas de variable <code>displayName()</code> dans la fonction <code>displayName()</code> , nous pouvons donc conclure que cette fonction peut en quelque sorte accéder à la variable déclarée dans la fonction externe à elle, <code>person()</code> , même après cela comment cette fonction fonctionnait.  C'est peut-être parce que la fonction <code>displayName()</code> est en fait une fermeture. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Ici, comme dans l'exemple précédent, nous stockons le lien vers la fonction interne anonyme retournée par la fonction <code>getCounter()</code> dans le <code>count</code> variables.  Puisque la fonction <code>count()</code> est une fermeture, elle peut accéder à la variable <code>counter</code> de la fonction <code>getCount()</code> même après que la fonction <code>getCounter()</code> a terminé son travail. <br><br>  Notez que la valeur de la variable <code>counter</code> n'est pas réinitialisée à 0 à chaque appel de la fonction <code>count()</code> .  Il peut sembler qu'il devrait être réinitialisé à 0, comme ce serait le cas lors de l'appel d'une fonction régulière, mais cela ne se produit pas. <br><br>  Cela fonctionne exactement comme ça car chaque fois que la fonction <code>count()</code> est appelée, une nouvelle étendue est créée pour elle, mais il n'y a qu'une seule étendue pour la fonction <code>getCounter()</code> .  Étant donné que la variable <code>counter</code> est déclarée dans la portée de la fonction <code>getCounter()</code> , sa valeur entre les appels à la fonction <code>count()</code> est enregistrée sans réinitialiser à 0. <br><br><h2>  <font color="#3AC1EF">Comment fonctionnent les courts-circuits?</font> </h2><br>  Jusqu'à présent, nous avons parlé des fermetures et examiné des exemples pratiques.  Parlons maintenant des mécanismes internes JavaScript qui les font fonctionner. <br><br>  Afin de comprendre les fermetures, nous devons traiter avec deux concepts JavaScript cruciaux.  Il s'agit du contexte d'exécution et de l'environnement lexical. <br><br><h3>  <font color="#3AC1EF">▍ Contexte d'exécution</font> </h3><br>  Le contexte d'exécution est un environnement abstrait dans lequel le code JavaScript est calculé et exécuté.  Lorsque du code global est exécuté, cela se produit dans le contexte d'exécution global.  Le code de fonction est exécuté dans le contexte de l'exécution de la fonction. <br><br>  À un moment donné, le code peut être exécuté dans un seul contexte d'exécution (JavaScript est un langage de programmation à thread unique).  Ces processus sont gérés à l'aide de ce qu'on appelle la pile d'appels. <br><br>  La pile d'appels est une structure de données organisée selon le principe LIFO (Last In, First Out - Last In, First Out).  Les nouveaux éléments ne peuvent être placés que sur le dessus de la pile, et seuls les éléments peuvent en être supprimés. <br><br>  Le contexte d'exécution actuel sera toujours en haut de la pile, et lorsque la fonction actuelle se termine, son contexte d'exécution est extrait de la pile et le contrôle est transféré dans le contexte d'exécution, qui était situé sous le contexte de cette fonction dans la pile d'appels. <br><br>  Considérez l'exemple suivant pour mieux comprendre le contexte d'exécution et la pile d'appels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">Exemple de contexte d'exécution</font></i> <br><br>  Lorsque ce code est exécuté, le moteur JavaScript crée un contexte d'exécution global pour exécuter le code global, et lorsqu'il rencontre un appel à la fonction <code>first()</code> , crée un nouveau contexte d'exécution pour cette fonction et le place en haut de la pile. <br><br>  La pile d'appels de ce code ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">Pile d'appels</font></i> <br><br>  Lorsque l'exécution de la <code>first()</code> fonction <code>first()</code> est terminée, son contexte d'exécution est récupéré de la pile d'appels et le contrôle est transféré au contexte d'exécution en dessous, c'est-à-dire au contexte global.  Après cela, le code restant dans la portée globale sera exécuté. <br><br><h3>  <font color="#3AC1EF">▍Environnement Lexique</font> </h3><br>  Chaque fois que le moteur JS crée un contexte d'exécution pour exécuter une fonction ou un code global, il crée également un nouvel environnement lexical pour stocker les variables déclarées dans cette fonction lors de son exécution. <br><br>  L'environnement lexical est une structure de données qui stocke des informations sur la correspondance des identifiants et des variables.  Ici, «identificateur» est le nom d'une variable ou d'une fonction, et «variable» est une référence à un objet (cela inclut les fonctions) ou une valeur d'un type primitif. <br><br>  L'environnement lexical contient deux composants: <br><br><ul><li>  Un enregistrement d'environnement est l'endroit où les déclarations de variables et de fonctions sont stockées. </li><li>  Référence à l'environnement externe - un lien qui vous permet d'accéder à l'environnement lexical externe (parent).  Il s'agit de la composante la plus importante à traiter pour comprendre les fermetures. </li></ul><br>  Conceptuellement, l'environnement lexical ressemble à ceci: <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br>  Jetez un œil à l'extrait de code suivant: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br>  Lorsque le moteur JS crée un contexte d'exécution global pour exécuter du code global, il crée également un nouvel environnement lexical pour stocker les variables et les fonctions déclarées dans la portée globale.  En conséquence, l'environnement lexical de portée mondiale ressemblera à ceci: <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br>  Veuillez noter que la référence à l'environnement lexical externe ( <code>outer</code> ) est définie sur <code>null</code> , car la portée globale n'a pas d'environnement lexical externe. <br><br>  Lorsque le moteur crée un contexte d'exécution pour la <code>first()</code> fonction <code>first()</code> , il crée également un environnement lexical pour stocker les variables déclarées dans cette fonction lors de son exécution.  Par conséquent, l'environnement lexical de la fonction ressemblera à ceci: <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Le lien vers l'environnement lexical externe de la fonction est défini sur <code>&lt;globalLexicalEnvironment&gt;</code> , car dans le code source, le code de la fonction est dans la portée globale. <br><br>  Veuillez noter que lorsque la fonction termine son travail, son contexte d'exécution est récupéré de la pile d'appels, mais son environnement lexical peut être supprimé de la mémoire, ou il peut y rester.  Cela dépend si, dans d'autres environnements lexicaux, il existe des références à cet environnement lexical sous la forme de liens vers un environnement lexical externe. <br><br><h2>  <font color="#3AC1EF">Analyse détaillée d'exemples de travail avec fermetures</font> </h2><br>  Maintenant que nous nous sommes armés de la connaissance du contexte d'exécution et de l'environnement lexical, nous reviendrons sur les fermetures et analyserons plus en profondeur les mêmes fragments de code que nous avons déjà examinés. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 1</font> </h3><br>  Jetez un œil à cet extrait de code: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Lorsque la fonction <code>person()</code> est exécutée, le moteur JS crée un nouveau contexte d'exécution et un nouvel environnement lexical pour cette fonction.  En fin de travail, la fonction renvoie la fonction <code>displayName()</code> , une référence à cette fonction est écrite dans la variable <code>peter</code> . <br><br>  Son environnement lexical ressemblera à ceci: <br><br><pre> <code class="hljs powershell">personLexicalEnvironment = { environmentRecord: {   name : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reference</span></span></span><span class="hljs-function">&gt; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-function">: &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">globalLexicalEnvironment</span></span></span><span class="hljs-function">&gt; }</span></span></code> </pre> <br>  Lorsque la fonction <code>person()</code> ferme, son contexte d'exécution est extrait de la pile.  Mais son environnement lexical reste en mémoire, car il existe un lien vers lui dans l'environnement lexical de sa fonction interne <code>displayName()</code> .  Par conséquent, les variables déclarées dans cet environnement lexical restent disponibles. <br><br>  Lorsque la fonction <code>peter()</code> est appelée (la variable correspondante stocke une référence à la fonction <code>displayName()</code> ), le moteur JS crée un nouveau contexte d'exécution et un nouvel environnement lexical pour cette fonction.  Cet environnement lexical ressemblera à ceci: <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  Il n'y a pas de variables dans la fonction <code>displayName()</code> , donc son enregistrement d'environnement sera vide.  Lors de l'exécution de cette fonction, le moteur JS tentera de trouver la variable de <code>name</code> dans l'environnement lexical de la fonction. <br><br>  Étant donné que la recherche est introuvable dans l'environnement lexical de la fonction <code>displayName()</code> , la recherche se poursuivra dans l'environnement lexical externe, c'est-à-dire dans l'environnement lexical de la fonction <code>person()</code> , qui est toujours en mémoire.  Là, le moteur trouve la variable souhaitée et affiche sa valeur dans la console. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  L'environnement lexical de la fonction <code>getCounter()</code> ressemblera à ceci: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Cette fonction renvoie une fonction anonyme qui est affectée à la variable de <code>count</code> . <br><br>  Lorsque la fonction <code>count()</code> est exécutée, son environnement lexical ressemble à ceci: <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br>  Lors de l'exécution de cette fonction, le système recherchera la variable <code>counter</code> dans son environnement lexical.  Dans ce cas, à nouveau, l'enregistrement d'environnement de fonction est vide, de sorte que la recherche de la variable se poursuit dans l'environnement lexical externe de la fonction. <br><br>  Le moteur trouve la variable, l'affiche dans la console et incrémente la variable <code>counter</code> , qui est stockée dans l'environnement lexical de la fonction <code>getCounter()</code> . <br><br>  Par conséquent, l'environnement lexical de la fonction <code>getCounter()</code> après le premier appel à la fonction <code>count()</code> ressemblera à ceci: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Chaque fois que la fonction <code>count()</code> est appelée, le moteur JavaScript crée un nouvel environnement lexical pour cette fonction et incrémente la variable <code>counter</code> , ce qui entraîne des changements dans l'environnement lexical de la fonction <code>getCounter()</code> . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Dans cet article, nous avons parlé de ce que sont les fermetures et trié les mécanismes JavaScript sous-jacents qui les sous-tendent.  Les fermetures sont l'un des concepts JavaScript fondamentaux les plus importants, et chaque développeur JS doit les comprendre.  La compréhension des fermetures est l'une des étapes de l'écriture d'applications efficaces et de haute qualité. <br><br>  <b>Chers lecteurs!</b>  Si vous avez de l'expérience en développement JS, veuillez partager des exemples pratiques d'utilisation des fermetures avec des débutants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424967/">https://habr.com/ru/post/fr424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424955/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 332 (24-30 septembre 2018)</a></li>
<li><a href="../fr424957/index.html">Génération d'images à partir de texte à l'aide d'AttnGAN</a></li>
<li><a href="../fr424961/index.html">MTA-STS pour Postfix</a></li>
<li><a href="../fr424963/index.html">Financement Zuckerberg: créer ensemble des outils pour la science</a></li>
<li><a href="../fr424965/index.html">Développement d'applications React à l'aide de ReasonReact</a></li>
<li><a href="../fr424969/index.html">Guide Node.js, partie 9: Utilisation du système de fichiers</a></li>
<li><a href="../fr424971/index.html">Habrokast "Sunset Manually" # 1. Essayer de mettre en place un environnement pour développer un jouet pour Windows</a></li>
<li><a href="../fr424973/index.html">Détection de visages sur vidéo: Raspberry Pi et Neural Compute Stick</a></li>
<li><a href="../fr424975/index.html">Profondeurs SIEM: corrélations prêtes à l'emploi. Partie 2. Le schéma de données comme reflet du modèle «monde»</a></li>
<li><a href="../fr424977/index.html">Apprendre des erreurs: optimiser les applications sur l'App Store et Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>