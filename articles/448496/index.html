<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏼 🔹 🤸🏻 .NET Core en Linux, DevOps a caballo 📏 ♑️ 🚎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desarrollamos DevOps como pudimos. Éramos 8, y Vasya era la mejor de Windows. De repente, Vasya se fue, y tuve la tarea de presentar un nuevo proyecto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET Core en Linux, DevOps a caballo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448496/">  Desarrollamos DevOps como pudimos.  Éramos 8, y Vasya era la mejor de Windows.  De repente, Vasya se fue, y tuve la tarea de presentar un nuevo proyecto que proporciona el desarrollo de Windows.  Cuando vertí toda la pila de desarrollo de Windows sobre la mesa, me di cuenta de que la situación es una molestia ... <br><br>  Así comienza la historia de <b>Alexander Sinchinov</b> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOpsConf</a> .  Cuando el especialista líder en Windows dejó la empresa, Alexander se preguntó qué hacer ahora.  ¡Cambie a Linux, por supuesto!  Alexander contará cómo logró establecer un precedente y transferir parte del desarrollo de Windows a Linux usando el ejemplo de un proyecto completado para 100,000 usuarios finales. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e76/321/dcde7632138481f5c01f851d9af8e2e2.png"><br><br>  ¿Cómo entregar fácilmente y sin esfuerzo un proyecto a RPM usando TFS, Puppet, Linux .NET core?  ¿Cómo mantener el control de versiones de la base de datos del proyecto si el desarrollo primero escucha las palabras Postgres y Flyway, y la fecha límite pasado mañana?  ¿Cómo integrarse con Docker?  ¿Cómo motivar a los desarrolladores de .NET a abandonar Windows y los smoothies en favor de Puppet y Linux?  ¿Cómo resolver los conflictos ideológicos, si no hay fuerzas, ni deseos, ni recursos para servir a Windows en la producción?  Sobre esto, así como sobre Web Deploy, pruebas, CI, sobre las prácticas de uso de TFS en proyectos existentes y, por supuesto, sobre muletas rotas y soluciones de trabajo, en la decodificación del informe de Alexander. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZH9Ro9j9KQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Entonces, Vasya se fue, la tarea es para mí, los desarrolladores están esperando <s>con una horca</s> .  Cuando finalmente me di cuenta de que Vasya no podía ser devuelta, me puse manos a la obra.  Para empezar, calculé el porcentaje de Win VM en nuestro parque.  El puntaje no estaba a favor de Windows. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/3d8/061/fa73d80617e31117f8c2575cc747a17b.png"><br><br>  Dado que estamos desarrollando DevOps activamente, me di cuenta de que hay que cambiar algo en el enfoque de sacar una nueva aplicación.  La solución fue una: si es posible, transfiera todo a Linux.  Google me ayudó: en ese momento .Net ya estaba portado a Linux, ¡y me di cuenta de que esta solución! <br><br><h2>  ¿Por qué se incluye .NET core con Linux? </h2><br>  Hubo varias razones para esto.  Entre "pagar dinero" y "no pagar", la mayoría elegirá el segundo, como yo.  Una licencia para MSDB cuesta alrededor de $ 1,000; el mantenimiento de una flota de máquinas virtuales de Windows cuesta cientos de dólares.  Para una gran empresa, este es un gran gasto.  Por lo tanto, el <b>ahorro</b> es la <b>primera razón</b> .  No es el más importante, pero sí uno de los más importantes. <br><br>  Las máquinas virtuales de Windows ocupan más recursos que sus hermanos Linux: <b>son pesadas</b> .  Dada la escala de una gran empresa, elegimos Linux. <br><br>  <b>El sistema simplemente está integrado en el CI existente</b> .  Nos consideramos DevOps progresivos, utilizamos Bamboo, Jenkins y GitLab CI, por lo que la mayor parte de nuestro trabajo está en Linux. <br><br>  La última razón es la <b>escolta conveniente.</b>  Tuvimos que bajar el umbral de entrada para los "acompañantes", chicos que entienden la parte técnica, aseguran una operación ininterrumpida y servicios de servicio desde la segunda línea.  Ya estaban familiarizados con la pila de Linux, por lo que les resulta mucho más fácil comprender el nuevo producto, mantenerlo y mantenerlo, que gastar recursos adicionales para lidiar con la funcionalidad similar del software para la plataforma Windows. <br><br><h2>  Requisitos </h2><br>  En primer lugar, la <b>conveniencia de una nueva solución para desarrolladores</b> .  No todos estaban listos para el cambio, especialmente después de la palabra hablada Linux.  Los desarrolladores quieren su querido Visual Studio, TFS con pruebas de compilación y batidos.  Cómo se realiza la entrega en la producción: no les importa.  Por lo tanto, decidimos no cambiar el proceso habitual y dejar todo sin cambios para el desarrollo de Windows. <br><br>  El nuevo proyecto debe <b>integrarse en el CI existente</b> .  Los rieles ya estaban allí y todo el trabajo debía hacerse teniendo en cuenta los parámetros del sistema de gestión de la configuración, los estándares de entrega aceptados y los sistemas de monitoreo. <br><br>  <b>Simplicidad en soporte y operación</b> , como condición para un umbral mínimo de entrada para todos los nuevos participantes de diferentes departamentos y departamento de soporte. <br><br>  <b>Plazo - ayer</b> . <br><br><h2>  Gana el grupo de desarrollo </h2><br>  ¿Con qué trabajó entonces el equipo de Windows? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/527/4b9/5e9/5274b95e93a6d270259487b5c68ca600.png"><br><br>  Ahora puedo decir con confianza que <b>IdentityServer4</b> es una excelente alternativa gratuita a ADFS con capacidades similares, o que <b>Entity Framework Core</b> es el paraíso de los desarrolladores donde no puede molestarse en escribir scripts SQL, sino describir consultas en la base de datos en términos OOP.  Pero luego, cuando discutí el plan de acción, vi esta pila como una escritura cuneiforme sumeria que reconoce solo PostgreSQL y Git. <br><br>  En ese momento, utilizamos activamente <b>Puppet</b> como un sistema de gestión de configuración.  En la mayoría de nuestros proyectos, utilizamos <b>GitLab CI</b> , <b>Elastic</b> , servicios balanceados altamente cargados usando <b>HAProxy,</b> monitoreamos todo con <b>Zabbix</b> , un montón de <b>Grafana</b> y <b>Prometheus</b> , <b>Jaeger</b> , y todo esto giraba en el hardware de <b>HP</b> con <b>ESXi</b> en <b>VMware</b> .  Todos lo saben: un clásico del género. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffb/768/38f/ffb76838f0538bd215bc5a54d5e005ad.png"><br><br>  Miremos e intentemos comprender lo que sucedió antes de comenzar todas estas intervenciones. <br><br><h2>  Que fue </h2><br>  TFS es un sistema bastante poderoso que no solo entrega código del desarrollador a la máquina de producción final, sino que también tiene un conjunto para una integración muy flexible con varios servicios, para proporcionar CI a nivel multiplataforma. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b7/9a3/146/9b79a3146abb65be1c4dad29ad50e406.png"><br>  Anteriormente, se trataba de ventanas sólidas.  TFS utilizó varios agentes de Build, que reunieron muchos proyectos.  Cada agente tiene de 3 a 4 trabajadores, uno para paralelizar tareas y optimizar el proceso.  Además, de acuerdo con los planes de lanzamiento, TFS entregó el Build recién horneado al servidor de aplicaciones de Windows. <br><br><h2>  A lo que queríamos llegar </h2><br>  Para la entrega y el desarrollo, utilizamos TFS, y lanzamos la aplicación en el servidor de aplicaciones de Linux, y hay algún tipo de magia entre ellos.  Esta <b>caja mágica</b> es la sal del próximo trabajo.  Antes de desarmarlo en partes, daré un paso al costado y diré dos palabras sobre la aplicación. <br><br><h2>  Proyecto </h2><br>  La aplicación proporciona funcionalidad para manejar tarjetas prepagas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c2/3be/4cc/4c23be4cce98ad3b48de986826817c19.png"><br><br><h3>  Cliente </h3><br>  Había dos tipos de usuarios.  <b>El primero</b> obtuvo acceso iniciando sesión con el certificado SSL SHA-2.  El <b>segundo</b> tuvo acceso por usuario y contraseña. <br><br><h3>  HAProxy </h3><br>  Además, la solicitud del cliente cayó en HAProxy, que resolvió las siguientes tareas: <br><br><ul><li>  autorización primaria; <br></li><li>  Terminación SSL <br></li><li>  ajuste de solicitudes HTTP; <br></li><li>  Difundir solicitudes. <br></li></ul><br>  La verificación del certificado del cliente pasó por la cadena.  Somos <b>autoridad</b> y podemos pagarla, ya que nosotros mismos emitimos certificados para atender a los clientes. <br><br>  Presta atención al tercer punto, un poco más tarde volveremos a él. <br><br><h3>  Backend </h3><br>  Planearon hacer un backend en Linux.  El backend interactúa con la base de datos, carga la lista necesaria de privilegios y luego, dependiendo de los privilegios que tenga el usuario autorizado, proporciona acceso para firmar documentos financieros y enviarlos para su ejecución, o generar algún tipo de informe. <br><br><h2>  Ahorro con HAProxy </h2><br>  Además de los dos contextos por los que solía pasar cada cliente, también había un contexto de identidad.  <b>IdentityServer4</b> simplemente le permite iniciar sesión, es un análogo gratuito y potente para <b>ADFS</b> - <b>Servicios de federación de Active Directory</b> . <br><br>  La solicitud de identidad se procesó en varios pasos.  El primer paso: el <b>cliente</b> <b>cayó en el backend</b> , que intercambió datos con este servidor y verificó la presencia de un token para el cliente.  Si no lo encontraba, la solicitud regresaba al contexto del que provenía, pero con una redirección y con una redirección fue a identidad. <br><br>  El segundo paso: la solicitud fue <b>a la página de autenticación en IdentityServer,</b> donde estaba registrado el cliente, y el token muy esperado apareció en la base de datos de IdentityServer. <br><br>  El tercer paso: el <b>cliente redirigió de nuevo</b> al contexto del que vino. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ead/cc3/039/eadcc3039f4585956ccf9d25512a4370.png"><br><br>  IdentityServer4 tiene una peculiaridad: <b>devuelve la respuesta a la solicitud de devolución a través de HTTP</b> .  No importa cómo tuvimos problemas con la configuración del servidor, no importa cómo nos iluminamos con la documentación, cada vez que recibimos una solicitud inicial del cliente con una URL que vino a través de HTTPS, e IdentityServer devolvió el mismo contexto, pero con HTTP.  Estábamos en estado de shock!  Y todo esto se transfirió a través del contexto de identidad a HAProxy, y en los encabezados tuvimos que modificar el protocolo HTTP a HTTPS. <br><br>  ¿Cuál es la mejora y dónde ahorraron? <br><br><blockquote>  Ahorramos dinero mediante el uso de una solución gratuita para autorizar a un grupo de usuarios, recursos, ya que no tomamos IdentityServer4 como una nota separada en un segmento separado, sino que lo usamos junto con un back-end en el mismo servidor donde está girando el backend de la aplicación. </blockquote><br><h2>  Cómo debería funcionar </h2><br>  Entonces, como prometí, Magic Box.  Ya entendemos que estamos garantizados para avanzar hacia Linux.  Formulemos tareas específicas que requieran soluciones. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59b/f2c/bde/59bf2cbdeb581a1e53cea2dabfbd4aca.png"><br><br>  <b>Títeres se manifiesta.</b>  Para entregar y administrar la configuración del servicio y la aplicación, tenía que escribir recetas geniales.  Un rollo de lápiz muestra elocuentemente qué tan rápido y eficientemente se hizo esto. <br><br>  <b>Método de entrega</b>  El estándar es RPM.  Todos entienden que en Linux no hay forma de hacerlo sin él, pero el proyecto en sí mismo después del ensamblaje era un conjunto de archivos DLL ejecutables.  Hubo alrededor de 150 de ellos, el proyecto es bastante difícil.  La única solución armoniosa es empacar estos binarios en RPM e implementar la aplicación desde allí. <br><br>  <b>Versionado</b>  Teníamos que lanzarlo muy a menudo y teníamos que decidir cómo formar el nombre del paquete.  Esta es una cuestión de nivel de integración TFS.  Teníamos un agente de compilación en Linux.  Cuando TFS envía la tarea al controlador - trabajador - al agente Build, también le envía un grupo de variables que caen en el entorno del proceso del controlador.  Estas variables de entorno reciben el nombre Build, el nombre de la versión y otras variables.  Lea más sobre esto en la sección "Ensamblar un paquete RPM". <br><br>  <b>La configuración de TFS se</b> redujo a la configuración de Pipeline.  Anteriormente, recopilamos todos los proyectos de Windows en los agentes de Windows, y ahora hay un agente de Linux: un agente de compilación que debe incluirse en el grupo de ensamblaje, enriquecido con algunos artefactos, indicar qué tipo de proyectos se construirán en este agente de compilación, y de alguna manera modificar Pipeline. <br><br>  <b>IdentityServer.</b>  ADFS no es nuestro camino, nos ahogamos para Open Source. <br><br>  Veamos los componentes. <br><br><h2>  Caja mágica </h2><br>  Consta de cuatro partes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/737/6ef/bb5/7376efbb54d21a0dcc88f191b70dfe9f.png"><br><br>  <b>Agente de compilación de Linux.</b>  Linux, porque lo compilamos, es lógico.  Esta parte se llevó a cabo en tres pasos. <br><br><ul><li>  <b>Configurar trabajadores</b> y más de uno, ya que se asumió el trabajo distribuido en el proyecto. <br></li><li>  <b>Instale .NET Core 1.x.</b>  ¿Por qué 1.x cuando 2.0 ya está disponible en el repositorio estándar?  Porque cuando comenzamos el desarrollo, la versión estable era 1.09, y se decidió hacer el proyecto para ello. <br></li><li>  <b>Git 2.x.</b> <br></li></ul><br>  <b>Repositorio RPM.</b>  Los paquetes RPM debían almacenarse en algún lugar.  Se asumió que usaríamos el mismo repositorio RPM corporativo que está disponible para todos los hosts Linux.  Y así lo hicieron.  Se configura un <b>webhook</b> en el servidor de repositorio que descargó el paquete RPM requerido desde la ubicación especificada.  El agente de Build informó la versión del paquete al webhook. <br><br>  <b>Gitlab</b>  Atencion  GitLab es utilizado aquí no por desarrolladores, sino por el departamento de operaciones para controlar versiones de aplicaciones, versiones de paquetes, monitorear el estado de todas las máquinas Linux y almacena la receta, todos los manifiestos de Puppet. <br><br>  <b>Puppet</b> : resuelve todos los problemas controvertidos y ofrece exactamente la configuración que queremos de Gitlab. <br><br>  Comenzamos a bucear.  ¿Cómo se entrega DLL en RPM? <br><br><h3>  Entrega DDL a RPM </h3><br>  Digamos que tenemos una estrella de rock para el desarrollo .NET.  Utiliza Visual Studio y crea una rama de lanzamiento.  Después de eso, lo carga en Git, y Git aquí es una entidad TFS, es decir, es el repositorio de aplicaciones con el que trabaja el desarrollador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1fd/fcd/8db/1fdfcd8dbe8f5395907ce2e5ec450539.png"><br><br>  Después de lo cual TFS ve que ha llegado una nueva confirmación.  Cual aplicación?  En la configuración de TFS hay una etiqueta sobre los recursos que tiene un agente de compilación en particular.  En este caso, ve que estamos creando un proyecto .NET Core y seleccionando un agente de compilación de Linux del grupo. <br><br>  El agente de compilación recibe las fuentes, descarga las <b>dependencias</b> necesarias de .NET, el repositorio npm, etc.  y después de compilar la aplicación y el empaquetado posterior, envía el paquete RPM al repositorio RPM. <br><br>  Por otro lado, ocurre lo siguiente.  El ingeniero de mantenimiento participa directamente en la implementación del proyecto: cambia la versión de los paquetes en <b>Hiera</b> en el repositorio donde se almacena la receta de la aplicación, después de lo cual Puppet activa <b>Yum</b> , recoge el nuevo paquete del repositorio y la nueva versión de la aplicación está lista para su uso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/135/3dd/9ae/1353dd9ae0bf83bd4527ceaa8f4db1ee.png"><br><br>  En palabras, todo es simple, pero ¿qué sucede dentro del propio agente de compilación? <br><br><h3>  Empaquetado RPM DLL </h3><br>  Se recibieron las fuentes del proyecto y la tarea de compilación de TFS.  El agente de compilación <b>comienza a</b> compilar <b>el proyecto desde el origen</b> .  El proyecto ensamblado está disponible en forma de muchos <b>archivos DLL</b> que se empaquetan en un archivo zip para reducir la carga en el sistema de archivos. <br><br>  El archivo ZIP se arroja <b>al directorio de compilación del paquete RPM.</b>  A continuación, el script Bash inicializa las variables de entorno, encuentra la versión de compilación, la versión del proyecto, la ruta al directorio de compilación y lanza la compilación RPM.  Al final del ensamblaje, el paquete se publica en el <b>repositorio local</b> , que se encuentra en el agente de compilación. <br><br>  Además, <b>se envía</b> una <b>solicitud JSON</b> desde el agente de compilación al servidor en el repositorio RPM con el nombre de la versión y la compilación.  Webhook, sobre el que hablé antes, descarga este mismo paquete desde el repositorio local en el agente de compilación y hace que el nuevo ensamblaje esté disponible para la instalación. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44c/9a5/b5c/44c9a5b5c05b30293723eec126e0ff24.png"><br><br>  ¿Por qué tal esquema para entregar un paquete a un repositorio RPM?  ¿Por qué no puedo enviar inmediatamente el paquete ensamblado al repositorio?  El hecho es que esta es una condición para la seguridad.  Este escenario restringe la posibilidad de descargas no autorizadas de paquetes RPM por parte de personas externas a un servidor que sea accesible para todas las máquinas Linux. <br><br><h2>  Control de versiones de DB </h2><br>  En la consulta con el desarrollo, resultó que los chicos están más cerca de MS SQL, pero en la mayoría de los proyectos que no son de Windows ya usamos PostgreSQL con might y main.  Como ya decidimos abandonar todo lo pagado, comenzamos a usar PostgreSQL aquí. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9c/e1a/815/a9ce1a81549ee0de97167823755f9b25.png"><br><br>  En esta parte, quiero hablar sobre cómo implementamos el control de versiones de la base de datos y cómo elegir entre Flyway y Entity Framework Core.  Considere sus pros y sus contras. <br><br><h3>  Contras </h3><br>  Flyway va solo en un sentido, no <b>podemos retroceder</b> , este es un significativo menos.  La comparación con Entity Framework Core se puede realizar de acuerdo con otros parámetros, desde el punto de vista de la conveniencia del desarrollador.  Recuerda que pusimos esto a la vanguardia, y el criterio principal era no cambiar nada para el desarrollo de Windows. <br><br>  Para Flyway, <b>necesitábamos algún tipo de contenedor</b> para que los chicos no escribieran <b>consultas SQL</b> .  Están mucho más cerca de operar en términos de POO.  Escribimos instrucciones para trabajar con objetos de base de datos, formamos una consulta SQL y la ejecutamos.  La nueva versión de la base de datos está lista, enrollada: todo está bien, todo funciona. <br><br>  Entity Framework Core tiene un signo negativo: bajo cargas pesadas, no <b>genera consultas SQL óptimas</b> , y la reducción de la base de datos puede ser significativa.  Pero como no tenemos un servicio de alta carga, no calculamos la carga en cientos de RPS, tomamos estos riesgos y delegamos el problema en el futuro. <br><br><h3>  Pros </h3><br>  Entity Framework Core <b>funciona de forma inmediata y es fácil de desarrollar</b> , y Flyway se <b>integra a la perfección en los CI existentes</b> .  Pero lo hacemos convenientemente para desarrolladores :) <br><br><h3>  Procedimiento de enrollado </h3><br>  Puppet ve que hay un cambio en la versión de los paquetes, entre los cuales se encuentra el responsable de la migración.  Primero, instala un paquete que contiene scripts de migración y funcionalidad vinculada a la base de datos.  Después de eso, se reinicia la aplicación que funciona con la base de datos.  Lo siguiente es la instalación de los componentes restantes.  El orden en que se instalan los paquetes y se inician las aplicaciones se describe en el manifiesto de Puppet. <br><br>  Las aplicaciones usan datos confidenciales, como tokens, contraseñas para la base de datos, todo esto se incorpora a la configuración con el Puppet master, donde se almacenan en forma cifrada. <br><br><h2>  Problemas de TFS </h2><br>  Después de decidir y darnos cuenta de que todo realmente funciona para nosotros, decidí ver qué sucedía con los ensamblajes en TFS en su conjunto para el departamento de desarrollo de Win para otros proyectos: rápidamente o no, íbamos a / lanzamiento, y encontramos problemas significativos con la velocidad . <br><br>  Uno de los principales proyectos tomará entre 12 y 15 minutos: es mucho tiempo, no puedes vivir así.  Un análisis rápido mostró una reducción terrible en E / S, y esto está en los arreglos. <br><br>  Habiendo analizado componentes, identifiqué tres focos.  El primero es el <b>antivirus Kaspersky</b> , que escanea el código fuente en todos los agentes de Windows Build.  El segundo es el <b>indexador de</b> <b>Windows</b> <b>.</b>  No se desconectó, y en los agentes de Build en tiempo real todo se indexó durante el proceso de implementación. <br><br>  El tercero es la <b>instalación de Npm.</b>  Resultó que en la mayoría de las tuberías usamos este escenario particular.  ¿Por qué es malo?  El procedimiento de instalación de Npm comienza cuando el árbol de dependencias se forma en <b>package-lock.json</b> , donde se <b>arreglan</b> las versiones de los paquetes que se utilizarán para construir el proyecto.  La desventaja es que la instalación de Npm saca las últimas versiones de paquetes de Internet cada vez, y este es un tiempo considerable en el caso de un proyecto grande. <br><br><blockquote>  Los desarrolladores a veces experimentan en la máquina local para probar el funcionamiento de una parte individual o proyecto en su conjunto.  A veces resultó que a nivel local todo era genial, pero montado, desplegado, nada funcionaba.  Comenzamos a entender cuál es el problema: sí, diferentes versiones de paquetes de dependencia. </blockquote><br><h3>  Solución </h3><br><ul><li>  Fuentes de excepciones AV. <br></li><li>  Deshabilitar la indexación. <br></li><li>  Cambiar a <b>npm ci</b> . <br></li></ul><br>  La ventaja de npm ci es que <b>recopilamos el árbol de dependencias una vez</b> y tenemos la oportunidad de proporcionar al desarrollador una <b>lista actualizada de paquetes</b> con los que puede experimentar localmente tanto como sea necesario.  Esto <b>ahorra tiempo a los</b> desarrolladores que escriben código. <br><br><h3>  Configuracion </h3><br>  Ahora un poco sobre la configuración del repositorio.  Históricamente, hemos estado utilizando <b>Nexus</b> para administrar repositorios, incluido <b>REPO interno</b> .  Todos los componentes que utilizamos para fines internos, por ejemplo, la supervisión autoescrita, se entregan a este repositorio interno. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25d/4d9/204/25d4d920402193190f95e0783f31fc04.png"><br><br>  También usamos <b>NuGet</b> , ya que almacena mejor en caché que otros administradores de paquetes. <br><br><h3>  Resultado </h3><br>  Después de optimizar los agentes de compilación, el tiempo de compilación promedio se redujo de 12 minutos a 7. <br><br><blockquote>  Si contamos todas las máquinas que podríamos usar para Windows, pero transferidas a Linux en este proyecto, ahorramos alrededor de $ 10,000. Y esto es solo en licencias, y considerando el contenido, más. </blockquote><br><h2>  Planes </h2><br>  El próximo trimestre, el plan estableció el trabajo para optimizar la entrega del código. <br><br>  <b>Transición a la imagen de Docker precompilada</b> .  TFS es algo genial con muchos complementos que le permiten integrarse en la canalización, incluido el ensamblaje de acuerdo con el disparador, por ejemplo, una imagen de Docker.  Queremos hacer que este disparador esté en el mismo <b>paquete-lock.json</b> .  Si de alguna manera cambia la composición de los componentes que se utilizan para construir el proyecto, tendremos una nueva imagen de Docker.  Más tarde se utiliza para implementar el contenedor con la aplicación compilada.  Ahora bien, esto no es así, pero planeamos cambiar a una arquitectura de microservicios en Kubernetes, que se está desarrollando activamente en nuestra empresa y ha estado sirviendo soluciones de producción. <br><br><h2>  Resumen </h2><br>  Insto a todos a lanzar Windows, pero esto no se debe a que no sé cómo cocinarlo.  La razón es que la mayoría de las soluciones de Opensource son la <b>pila de Linux</b> .  <b>Ahorrará bien en recursos</b> .  En mi opinión, el futuro está en las soluciones Open Source Linux con una comunidad poderosa. <br><br>  <i>Perfil del orador Alexander Sinchinov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en GitHub</a> .</i> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOps Conf</a> es una conferencia sobre la integración de procesos de desarrollo, prueba y operación para profesionales de profesionales.  ¿Por eso el proyecto del que habló Alexander?  implementado y funcionando, y el día de la presentación se realizaron dos lanzamientos exitosos.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOps Conf en RIT ++</a> el 27 y 28 de mayo habrá incluso más casos de este tipo por parte de los profesionales.  Todavía puede saltar al último carro y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviar un informe,</a> o tomarse su tiempo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reservar un</a> boleto.  Nos vemos en Skolkovo! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448496/">https://habr.com/ru/post/448496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448484/index.html">Microbios de la raíz</a></li>
<li><a href="../448486/index.html">"En noviembre de 2018, caímos por error en spam en todos los frentes". Cómo guardé correos de una compañía con una base millonésima</a></li>
<li><a href="../448488/index.html">Miedo y asco DevSecOps</a></li>
<li><a href="../448490/index.html">Cómo comenzar la transformación de DevOps</a></li>
<li><a href="../448492/index.html">¿Qué es DevOps?</a></li>
<li><a href="../448498/index.html">"Rusia 404": ¿Cuánto Internet libre queda para vivir?</a></li>
<li><a href="../448500/index.html">Resolviendo un Crackme simple para Sega Mega Drive</a></li>
<li><a href="../448504/index.html">Recogieron para todos "Habrom" el libro de referencia "Por quién fue emitido ..." para pasaportes. Descargar a la salud</a></li>
<li><a href="../448506/index.html">The Matrix tiene 20 años: cómo Wachowski hizo cyberpunk, lo que determinó la agenda de toda una generación</a></li>
<li><a href="../448510/index.html">Acer en 2019: ¿y si eliminas todas las moscas de las computadoras portátiles para juegos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>