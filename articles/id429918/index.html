<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∑ ‚ñ™Ô∏è üßíüèº Intel Dunia Virtual. Bagian 2: SMP ü§¥üèΩ üë† üß¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya (tautan), saya berbicara tentang konsep dasar hypervisor berdasarkan teknologi virtualisasi perangkat keras Intel. Sekarang s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intel Dunia Virtual. Bagian 2: SMP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429918/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya (tautan), saya berbicara tentang konsep dasar hypervisor berdasarkan teknologi virtualisasi perangkat keras Intel.  Sekarang saya mengusulkan memperluas kemampuan hypervisor dengan menambahkan dukungan untuk arsitektur multiprosesor (SMP), dan juga mempertimbangkan contoh bagaimana hypervisor dapat membuat perubahan pada OS tamu. <br><br>  Semua tindakan lebih lanjut akan dilakukan pada PC dengan konfigurasi berikut: <br><br>  CPU: Intel Core i7 5820K <br>  Motherboard: Asus X99-PRO <br>  Ram: 16GB <br>  OS Tamu: Windows 7 x32 dengan PAE Dinonaktifkan <br><a name="habracut"></a><br>  Saya akan mulai dengan menjelaskan lokasi komponen hypervisor pada hard drive (semua nilai ditentukan dalam sektor). <br><br><img src="https://habrastorage.org/webt/in/_l/4b/in_l4birv9nzswyy15vouhjywla.jpeg" alt="gambar"><br>  <i>Proses memuat hypervisor berbeda dari versi sebelumnya hanya di hadapan modul <i>hypervisor.ap baru</i> , yang tujuannya adalah inisialisasi dasar prosesor AP.</i> <br><br>  Proses memuat modul ke dalam memori: <br><br><img src="https://habrastorage.org/webt/3a/in/ul/3ainulrasx1dmbgbpodesnsg-qy.jpeg"><br><br>  <b>Dukungan SMP</b> <br><br>  Saya menerapkan hypervisor pada prinsip multiprosesor simetris, yang berarti bahwa salinan VMX yang sama akan diluncurkan pada semua prosesor logis yang ada.  Selain itu, tabel IDT dan GDT, serta tabel untuk memori paging, akan umum untuk semua prosesor logis.  Saya melakukan ini karena hypervisor akan segera menginisialisasi memori untuk ruang alamat OS tamu dan tidak perlu secara dinamis menugaskan kembali alamat fisik setiap halaman.  Juga, dengan pendekatan ini, Anda tidak perlu memantau korespondensi cache TLB prosesor di sisi hypervisor. <br>  Proses inisialisasi untuk BSP dan AP akan berbeda.  Semua struktur utama yang terlibat dalam hypervisor akan dibuat selama inisialisasi BSP.  Selain itu, status Aktivitas untuk prosesor AP mode vmx non root akan diatur ke status HLT.  Dengan demikian, lingkungan OS tamu akan ditiru sesuai dengan apa yang akan terjadi tanpa menggunakan virtualisasi. <br><br>  Inisialisasi BSP: <br><br><ol><li>  Inisialisasi spinlock </li><li>  Menginisialisasi dan memuat tabel GDT dan IDT </li><li>  Inisialisasi Tabel Paging </li><li>  Menginisialisasi Struktur VMCS dan Membuat Tabel EPT Umum </li><li>  Aktivasi prosesor AP.  Untuk melakukan ini, urutan interupsi INIT - SIPI dikirim ke setiap AP.  Vektor untuk interupsi SIPI adalah 0x20, yang sesuai dengan transfer kontrol AP pada 0x20000 (modul hypervisor.ap) </li><li>  Memulai OS tamu di 0x7C00 (modul win7.mbr) </li></ol><br>  AP inisialisasi: <br><br><ol><li>  Setelah mengaktifkan AP, prosesor berada dalam mode nyata.  Modul hypervisor.ap menginisialisasi memori dan tabel paging untuk beralih ke mode lama </li><li>  Unduh IDT, GDT, serta katalog paging tables yang dibuat selama fase inisialisasi BSP </li><li>  Inisialisasi struktur VMCS, dan memuat tabel EPT dibuat pada tahap inisialisasi BSP </li><li>  Beralih ke mode non-root vmx dengan status HLT aktif </li></ol><br>  Kita dapat mengatakan bahwa implementasi dukungan SMP di hypervisor cukup sederhana, tetapi ada beberapa poin yang ingin saya perhatikan. <br><br>  1. Dukungan USB Legacy <br><br>  Model motherboard baru mungkin tidak memiliki konektor PS / 2, jadi Dukungan USB Legacy digunakan untuk memastikan kompatibilitas ke belakang.  Ini berarti Anda dapat bekerja dengan keyboard atau mouse usb menggunakan metode yang sama (port input / output) seperti halnya dengan standar PS / 2.  Implementasi Dukungan USB Legacy tidak hanya tergantung pada model motherboard, tetapi juga dapat mengisyaratkan dalam berbagai versi firmware.  Pada motherboard Asus X99-PRO saya, Dukungan USB Legacy diimplementasikan melalui interupsi SMI, di prosesor yang emulasi PS / 2 terjadi.  Saya menulis tentang hal ini dengan sangat rinci, karena dalam kasus saya (firmware versi 3801), Dukungan USB Legacy tidak kompatibel dengan mode lama dan ketika kembali dari SMM, prosesor masuk ke kondisi mati. <br><br>  Solusi termudah dalam situasi ini adalah mematikan Dukungan USB Legacy sebelum beralih ke mode lama.  Namun, di Windows, metode polling keyboard PS / 2 digunakan pada tahap memilih opsi boot, sehingga Dukungan USB Legacy harus diaktifkan kembali sebelum OS tamu mulai memuat. <br><br>  2. Peralihan Tugas Perangkat Keras <br><br>  Dalam sistem operasi modern, beralih antar tugas diimplementasikan, sebagai aturan, dengan metode perangkat lunak.  Namun, pada Windows7, penyeleksi yang menunjuk ke TSS ditugaskan untuk menginterupsi 2 - NMI dan 8 - Double Fault, yang berarti bahwa interupsi tersebut akan menyebabkan pengalihan konteks perangkat keras.  Intel VMX tidak mendukung Peralihan Tugas perangkat keras, dan upaya untuk mengeksekusinya menyebabkan VM Exit.  Untuk kasus-kasus seperti itu, saya menulis pengendali Task Switch saya (fungsi GuestTaskSwitch).  Gangguan Double Fault hanya terjadi jika terjadi konflik sistem yang serius yang disebabkan oleh penanganan gangguan lainnya secara tidak tepat.  Dalam proses debugging, saya tidak menemukan itu.  Tetapi NMI muncul pada prosesor AP pada saat me-reboot Windows.  Ini masih membuat saya ragu karena tidak jelas apakah NMI ini adalah hasil dari proses reboot biasa atau ini operasi hypervisor yang salah pada beberapa tahapan sebelumnya.  Jika Anda memiliki informasi tentang masalah ini, silakan berbicara dalam komentar atau tulis saya di pesan pribadi. <br><br>  <b>Perubahan pada OS tamu</b> <br><br>  Sejujurnya, saya tidak bisa memutuskan untuk waktu yang lama apa perubahan hypervisor seharusnya dalam karya OS tamu.  Faktanya adalah bahwa di satu sisi saya ingin menunjukkan sesuatu yang menarik, seperti pengenalan penangan kami dalam protokol jaringan dasar, tetapi di sisi lain, semuanya akan turun ke sejumlah besar kode, dan ada sedikit hubungannya dengan subjek hypervisor.  Selain itu, saya tidak ingin mengikat hypervisor ke set besi tertentu. <br><br>  Akibatnya, kompromi berikut ditemukan: dalam versi hypervisor ini, kontrol atas panggilan sistem dari mode pengguna diimplementasikan, dengan kata lain, akan dimungkinkan untuk mengontrol operasi aplikasi yang berjalan di OS tamu.  Jenis kontrol ini cukup sederhana untuk diterapkan dan selain itu memungkinkan Anda untuk mendapatkan hasil visual dari pekerjaan. <br><br>  Kontrol atas pengoperasian aplikasi akan dilakukan pada tingkat panggilan sistem.  Dan tujuan utamanya adalah untuk mengubah hasil dari fungsi <i>NtQuerySystemInformation</i> sehingga ketika Anda menelepon dengan argumen <i>SystemProcessInformation</i> ( <i>0x05</i> ), Anda dapat memotong informasi proses. <br><br>  Pada Windows 7, program aplikasi untuk memanggil fungsi sistem menggunakan perintah assembler sysenter, setelah itu kontrol ditransfer ke prosesor <i>KiFastCallEntry</i> ke kernel pada level r0.  Untuk kembali ke level aplikasi r3, gunakan perintah sysexit. <br>  Untuk mendapatkan akses ke hasil <i>eksekusi</i> fungsi <i>NtQuerySystemInformation,</i> perlu untuk menyimpan nomor fungsi yang dipanggil setiap kali perintah sysenter dijalankan.  Kemudian, ketika menjalankan <i>sysexit,</i> bandingkan nilai yang disimpan dengan jumlah fungsi yang dicegat dan, jika ada kecocokan, buat perubahan pada data yang dikembalikan oleh fungsi. <br>  Intel VMX tidak menyediakan cara langsung untuk memantau pelaksanaan <i>sysenter / sysexit</i> , namun, jika Anda menulis nilai 0 ke <i>Guest MSR IA32_SYSENTER_CS</i> , maka perintah <i>sysenter / sysexit</i> akan menaikkan pengecualian GP yang dapat digunakan untuk memanggil VM Exit handler.  Agar pengecualian GP untuk memanggil VM Exit, Anda perlu mengatur 13 bit di bidang <i>Exception Bitmap</i> dari VMCS. <br><br>  Struktur di bawah ini digunakan untuk meniru pasangan sysenter / sysexit. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> QWORD ServiceNumber; QWORD Guest_Sys_CS; QWORD Guest_Sys_EIP; QWORD Guest_Sys_ESP; } SysEnter_T;</code> </pre> <br>  Bidang <i>ServiceNumber</i> berisi jumlah fungsi yang dipanggil dan diperbarui dengan setiap panggilan ke sysenter. <br><br>  Bidang <i>Guest_Sys_CS, Guest_Sys_EIP, Guest_Sys_ESP</i> diperbarui ketika OS tamu mencoba menulis ke register MSR yang sesuai.  Untuk melakukan ini, tulis masker di <i>Alamat MSR-Bitmap</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS write mask ptrMSR_BMP[0x100 + (0x174 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x174 &amp; 0x3F)); // 175H 373 IA32_SYSENTER_ESP SYSENTER_ESP write mask ptrMSR_BMP[0x100 + (0x175 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x175 &amp; 0x3F)); // 176H 374 IA32_SYSENTER_EIP SYSENTER_EIP write mask ptrMSR_BMP[0x100 + (0x176 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x176 &amp; 0x3F));</span></span></code> </pre><br>  OS tamu seharusnya tidak melihat perubahan yang dibuat oleh hypervisor untuk pengoperasian panggilan fungsi sistem.  Dengan mengatur topeng baca untuk <i>MSR IA32_SYSENTER_CS,</i> Anda dapat mengembalikan OS tamu ke nilai register aslinya saat membaca. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS read mask ptrMSR_BMP[0x174 &gt;&gt; 6] |= (1UL &lt;&lt; (0x174 &amp; 0x3F));</span></span></code> </pre><br>  Berikut ini adalah skema emulasi perintah <i>sysenter / sysexit</i> . <br><br><img src="https://habrastorage.org/webt/bl/wx/vo/blwxvocgthxx_0skhnjmm4sbf4i.jpeg"><br><br>  Pada <i>tahap</i> emulasi <i>sysexit</i> , jumlah yang tersimpan dari fungsi yang dipanggil dibandingkan dengan nomor NtQuerySystemInformation (0x105).  Dalam kasus pertandingan, diverifikasi bahwa NtQuerySystemInformation disebut dengan argumen Informasi Proses Sistem dan jika demikian, fungsi <i>ChangeProcessNames (DWORD SPI_GVA, DWORD SPI_size)</i> membuat perubahan pada struktur yang berisi informasi tentang proses. <br>  <i>SPI_GVA</i> adalah alamat virtual tamu dari struktur <i>SYSTEM_PROCESS_INFORMATION</i> <br>  <i>SPI_size</i> adalah ukuran total struktur dalam byte. <br>  Struktur <i>SYSTEM_PROCESS_INFORMATION sendiri</i> terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span></span></span><span class="hljs-class"> {</span></span> ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[<span class="hljs-number"><span class="hljs-number">48</span></span>]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[<span class="hljs-number"><span class="hljs-number">6</span></span>]; } SYSTEM_PROCESS_INFORMATION;</code> </pre><br>  Tidak ada yang rumit dalam penguraiannya, yang terpenting adalah jangan lupa menerjemahkan alamat virtual tamu menjadi fisik, untuk ini digunakan fungsi <i>GuestLinAddrToPhysAddr ()</i> . <br><br>  Untuk lebih jelasnya, saya mengganti dua karakter pertama dalam nama-nama semua proses dengan tanda ' <b>:)</b> '. Hasil penggantian seperti itu terlihat di tangkapan layar. <br><br><img src="https://habrastorage.org/webt/rs/nq/rt/rsnqrtxvkrcoc0r_4xgjnuabk8o.png"><br><br>  <b>Ringkasan</b> <br><br>  Secara umum, tugas yang ditetapkan pada awal artikel selesai.  Hypervisor memastikan pengoperasian OS tamu yang stabil, dan juga mengontrol panggilan fungsi sistem dari level aplikasi.  Saya perhatikan bahwa kelemahan utama menggunakan emulasi perintah <i>sysenter / sysexit</i> adalah peningkatan yang signifikan dalam panggilan VM Exit, yang mempengaruhi kinerja dan ini terutama terlihat ketika OS tamu dalam mode prosesor tunggal.  Kerugian ini dapat dihilangkan jika Anda mengontrol panggilan hanya dalam konteks proses yang dipilih. <br><br>  Dan itu saja untuk saat ini.  Sumber untuk artikel dapat diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429918/">https://habr.com/ru/post/id429918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429908/index.html">Cara menggunakan coroutine dalam makanan dan tidur nyenyak di malam hari</a></li>
<li><a href="../id429910/index.html">AppsConf Naik</a></li>
<li><a href="../id429912/index.html">Pengembangan perpustakaan: dari API ke rilis publik</a></li>
<li><a href="../id429914/index.html">OpenSceneGraph: Grafik Adegan dan Pointer Cerdas</a></li>
<li><a href="../id429916/index.html">Cara membangun dan membangun</a></li>
<li><a href="../id429920/index.html">Tragicomedy in NaN bertindak: bagaimana kami membuat game di JS dan merilisnya di Steam</a></li>
<li><a href="../id429922/index.html">Bagaimana mengubah proyek sederhana menjadi konstruksi jangka panjang atau memotong semua yang tidak perlu</a></li>
<li><a href="../id429928/index.html">Semua yang perlu Anda ketahui tentang stres dan emosi yang kuat</a></li>
<li><a href="../id429930/index.html">Splunk Pemecahan masalah aplikasi yang mudah</a></li>
<li><a href="../id429934/index.html">Ada apa disana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>