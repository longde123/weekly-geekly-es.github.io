<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🚶🏾 👨🏿‍🍳 Pedal auf den Boden: Erstellen Sie einen weiteren Fußmanipulator für den PC 🐩 😸 👨🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einem Monat bin ich auf diesen Artikel gestoßen, in dem es um das Treten von Vim geht. Wenig später, nach meinem langen dreiminütigen Studium, ste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedal auf den Boden: Erstellen Sie einen weiteren Fußmanipulator für den PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  Vor einem Monat bin ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Artikel gestoßen, in dem es um das Treten von Vim geht.  Wenig später, nach meinem langen dreiminütigen Studium, stellte ich fest, dass dieses Thema nicht mehr neu und sehr beliebt ist.  Ich selbst benutze Vim nur im Notfall (wenn ich in der Konsole arbeiten muss, bevorzuge ich Nano), aber Sie können dasselbe für andere Anwendungen tun. <br><a name="habracut"></a><br>  Anfangs wollte ich einen kleinen Artikel machen, aber ich bekam ein ganzes Tutorial zum Erstellen dieses Geräts mit schrittweisem Schreiben von Code und einer Erklärung, was und wie.  Um den Artikel nicht aufzublasen, gibt es unter den Spoilern verschiedene Informationen, die interessant und der Aufmerksamkeit von Neulingen in Arduino würdig erschienen. Fortgeschrittene und besonders voreilige Benutzer dürfen keine Zeit damit verschwenden.  Der vollständige Quellcode wird ebenfalls am Ende des Artikels vorgestellt. <br><br><h2>  Warum brauche ich es? </h2><br>  Wenn Sie keinen Zweifel an der Notwendigkeit und Nützlichkeit dieses Geräts haben, können Sie diesen Punkt überspringen.  Im Übrigen möchte ich zunächst auf die Voraussetzungen für die Erstellung dieses Geräts eingehen. <br><br>  Programmierer und Designer haben stets versucht, eine bequeme und benutzerfreundliche Oberfläche zu erstellen, damit der Benutzer ohne unnötige Probleme mit Maus und Tastatur mit der Anwendung arbeiten kann. Warum benötigen wir also einen anderen Manipulator?  Schauen wir uns ein wenig die Geschichte an, oder besser gesagt, zu Beginn des 18. Jahrhunderts, als ein Musikinstrument wie das Klavier erfunden wurde.  Wie Sie wissen, bedeutet dieses Wort wörtlich „laut und leise“, aber nur wenige Menschen glauben, dass ein kluger italienischer Meister ein solches Instrument erhalten hat, indem er das damals existierende Cembalo tatsächlich „zerdrückt“ hat, wodurch es möglich war, die Lautstärke bis zu einem gewissen Grad ohne zu steuern Hände von den Schlüsseln nehmen. <br><br>  Es gibt viele Beispiele.  Das Auto hat Pedale, um das Lenkrad nicht zu werfen, wenn Sie Benzin nachfüllen müssen.  Das Schlagzeug hat auch Pedale zum Klopfen auf die Bassdrum und die Becken.  Und was können Pedale bei der Verwendung eines Computers geben?  Sie können beispielsweise eine Tastenkombination einstellen oder sogar eine Taste hinzufügen, die nicht vorhanden ist, z. B. das Ein- und Ausschalten des Sounds.  Die Pedale können helfen, wenn Ihre Hände beschäftigt sind: Ich spiele selbst Gitarre, und manchmal zur Begleitung wäre es für mich sehr praktisch, den Hintergrund zu rollen, ohne ständig die Tastatur zu erreichen.  Und schließlich können Controller in Spielen völlig unmenschliche Möglichkeiten bieten: Es wäre cool, Ihre gesamte Basis in einer Strategie mit einem Klick aufzubauen oder Feinde mit einer Geschwindigkeit von einem Dutzend Schlägen pro Sekunde in Schützen zu zerstören, oder? <br><br>  Generell hoffe ich, dass ich Sie überzeugt habe, was bedeutet, dass es Zeit ist, direkt mit der Entwicklung selbst zu beginnen. <br><br><h2>  Erforderliche Ressourcen </h2><br><ul><li>  <b>Eigentlich die Pedale.</b>  Einige Schwierigkeiten entstanden sofort aufgrund der Tatsache, dass ich mir keinen Namen für ein solches Pedal vorstellen konnte.  Ich wusste nur, dass solche Dinge in Nähmaschinen verwendet werden.  Im Allgemeinen gelang es mir auf Wunsch eines <b>elektrischen Pedals</b> immer noch, das zu finden, was ich bei Aliexpress brauchte, und ohne nachzudenken, bestellte ich 3 Stück. <br></li><li>  <b>Controller</b>  Das Pedalboard sollte die Tastatur und möglicherweise die Maus emulieren, um ohne unnötige Treiber eine Verbindung zu einem PC herstellen zu können.  Dafür ist das Arduino Pro Micro Board perfekt, das zwar keine Schlussfolgerungen zieht, aber so kompakt wie möglich ist.  Wir gehen zum selben Aliexpress und kaufen die chinesische Version dieses Wunders. <br></li><li>  <b>Drähte.</b>  Um 3 Pedale unter den Tisch zu stellen, benötigen Sie mindestens einen vieradrigen Draht mit einer Länge von mindestens einem Meter.  Hier sollten meiner Meinung nach keine Probleme auftreten. <br></li><li>  <b>RGB LED und Taste.</b>  Der erste wird benötigt, um die Modi anzuzeigen, und der zweite ist, um sie zu wechseln. <br></li><li>  Natürlich brauchen wir eine Arduino IDE, einen Lötkolben und gerade Arme. <br></li></ul><br><h2>  Gerätediagramm </h2><br>  Noch bevor die Pakete ankamen, begann ich mit der Erstellung eines Gerätediagramms.  Obwohl dies viel gesagt wird, musste ich nur die Pedale, die Diode und den Knopf anschließen.  Es stellte sich irgendwie so heraus: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  Für Pedale habe ich beschlossen, 4 Ports PB1-PB4 gleichzeitig zuzuweisen, dh zwei für den linken und zwei für den rechten Fuß, obwohl ich bisher nur 3 Pedale habe. Außerdem gehören sie alle zur selben Gruppe und befinden sich an einem Ort.  Unter der LED habe ich die Ausgänge PD0, PD1 und PD4 unter der Taste - PD7 genommen. <br>  In diesem Fall benötigen wir keine Pull-up-Widerstände, wenn Sie die im Controller eingebauten verwenden.  Wenn Sie dann jedoch eine Taste oder ein Pedal drücken, ist der Eingang niedrig, und wenn er losgelassen wird, ist er hoch, dh die Druckvorgänge werden invertiert, und Sie sollten dies nicht vergessen. <br><br><h2>  Code schreiben </h2><br>  Diese Phase war die schwierigste: Aufgrund einiger Fehler in den Zeigern habe ich den Bootloader mehrmals gelöscht und infolgedessen die Karte auf Softwareebene fast ausgefallen.  Im Folgenden werden alle Phasen der Erstellung der Firmware ausführlich beschrieben. Für diejenigen, die nur einen funktionierenden Code erhalten möchten, befindet sich dieser am Ende des Artikels. <br><br><h3>  Vorbereitung </h3><br>  Zuerst müssen wir verstehen, was das Pedal in Bezug auf das Programm ist.  Ich habe mich entschlossen, die Pedale in einem von zwei Modi einzustellen - Echtzeit und Trigger.  In diesem Fall hat jedes Pedal zwei Programme: Das erste wird ausgeführt, wenn das Pedal in Echtzeit oder mit ungeraden Drücken im Triggermodus gehalten wird, das zweite wird ausgeführt, wenn das Pedal in Echtzeit losgelassen wird oder wenn die Pedale im Triggermodus gleichmäßig gedrückt werden.  Das Pedal hat auch einen Port, einen Status und zwei Variablen - die aktuellen Positionen in den Programmen 1 und 2. Ich habe diese Struktur: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 —   , 1 —  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  Arduino hat ziemlich viel Speicher und ist auch 8-Bit, daher ist es am besten, wenn möglich zu versuchen, char anstelle von int zu verwenden. <br><br>  Wir benötigen auch die Standard-Tastaturbibliothek, um als Tastatur arbeiten zu können. <br><br><h3>  Klicken Sie auf Verarbeitung </h3><br>  Jetzt müssen wir einen Interpreter erstellen, der Daten aus dem Array liest und in Form von Tastenanschlägen an die Maschine sendet sowie mehrere Werte für verschiedene interne Befehle auswählt.  Wir öffnen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> mit den Schlüsselcodes und sehen, was und wie wir klicken können.  Ich habe nicht tief gegraben und alle möglichen Tastaturstandards studiert, da mir die Informationen hier für ein solches Projekt völlig ausreichend erschienen.  Die erste Hälfte ist für Standard-ASCII-Zeichen reserviert (obwohl einige von ihnen nicht druckbar sind oder nicht verwendet werden), die zweite Hälfte ist für verschiedene Modifizierertasten vorgesehen.  Es gibt sogar separate Codes für die linke und rechte Taste, was sehr erfreulich ist, aber ich habe keine speziellen Codes für die Zahlen aus dem Nampad gesehen, obwohl sie meines Wissens im System auf besondere Weise wahrgenommen werden als gewöhnliche Zahlen.  Vielleicht befinden sich ihre Codes irgendwo in den „Löchern“ zwischen den Bereichen, aber jetzt geht es nicht darum.  Der größte Schlüssel ist also der Aufwärtsschlüssel - 218, was bedeutet, dass der Bereich 219-255 als frei angesehen werden kann, oder zumindest gibt es keine wichtigen Schlüssel. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Ich denke, dass selbst eine Person mit nicht dem höchsten Kenntnisstand von C keine Fragen darüber haben wird, was hier passiert.  Zunächst wählt die Funktion das gewünschte Pedal aus und bestimmt je nach Modus und Zustand des Pedals, welches Programm ausgeführt werden soll.  Wenn beim Lesen jedes Elements des Arrays kein Steuerzeichen verwendet wird, wird die Funktion Keyboard.write () aufgerufen, die das Drücken und Loslassen einer Taste emuliert.  Die Steuerzeichen werden separat verarbeitet und werden benötigt, um die Tastenkombinationen zu klemmen und im Programm zu navigieren. <br><br><div class="spoiler">  <b class="spoiler_title">Einige Funktionen des Tastaturmodus</b> <div class="spoiler_text">  Keyboard.write () hat einige einfache, aber für Anfänger nicht offensichtliche Nuancen, basierend auf der Tatsache, dass wir Daten nicht in Rohform, sondern als Tastenanschläge senden.  Erstens kann der Computer seltsamerweise ohne zusätzliche Treiber nur Zeichen von der Tastatur akzeptieren, die sich auf der Tastatur befinden, was bedeutet, dass wir keine 0x03 (Interrupt-Signal) oder 0x1B (Beginn der ESCAPE-Sequenz) senden können.  Zweitens können wir die Großbuchstaben so anpassen, wie sie in der ASCII-Tabelle enthalten sind, aber die Maschine erhält die Tastenkombination Umschalt + &lt;Kleinbuchstaben&gt;.  Dies kann zu einem Problem werden, wenn CapsLock aktiviert ist und wir "unerwartet" kleine Buchstaben anstelle von großen Buchstaben erhalten und umgekehrt.  Drittens können wir die russische Sprache nicht so gut wie in jeder anderen Sprache verwenden.  Dies geschieht erneut aufgrund von nervigen Dingen wie <b>Schlüsselcodes</b> .  Obwohl Keyboard.write () dies als Argument akzeptiert, wird der Code, der dem Schlüssel entspricht, auf dem er sich im englischen Standardlayout befindet, weiterhin über USB gesendet. Wenn wir versuchen, das kyrillische Alphabet zu senden, wissen wir nicht, was.  Wenn wir unseren russischsprachigen Freunden über Arduino Hallo sagen möchten, müssen wir im Code „Ghbdtn“ schreiben und es dann senden, nachdem wir das russische Layout ausgewählt haben.  Eine solche „Begrüßung“ funktioniert im ukrainischen Layout, aber im Bulgarischen wird trotz der Tatsache, dass es auch ein kyrillisches Alphabet gibt, nichts daraus, da sich die Buchstaben dort an völlig anderen Stellen befinden.  (Ich habe einmal die Meinung gehört, dass es für viele amerikanische und englische Entwickler unverständlich ist, dass jemand möglicherweise sogar mehrere Layouts verwenden, diese aber auch wechseln muss.) <br></div></div><br>  Wir haben also einen Dolmetscher und ein grobes Verständnis dafür, wie unser Pedalboard mit einem Computer interagiert.  Jetzt müssen wir all dies auf den Zustand der vollständigen Firmware bringen und die Leistung auf einem Pedal überprüfen.  Wenn Sie eine Instanz des Pedals erstellen und zyklisch pedalAction () aufrufen, führen wir theoretisch das in der Struktur angegebene Programm aus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  Vergessen Sie übrigens niemals Null-Terminatoren in diesen „Programmen“, wenn ihre Länge kleiner als die Größe des Arrays ist und wenn sie nicht zyklisch sind, da Arduino nicht nur versucht, die nicht eingestellten Daten zu interpretieren, sondern sie auch mit hoher Geschwindigkeit an die Maschine sendet. und das ist das gleiche wie einem Affen eine Tastatur zu geben. <br><br><h3>  Ein Pedal ist gut und zwei sind besser </h3><br>  Jetzt ist es an der Zeit, sich mit der Verarbeitung von Signalen von mehreren Pedalen zu befassen und Schaltmodi hinzuzufügen.  Zu Beginn des Artikels wurden 4 Ports für Pedale zugewiesen, von denen jeder in sieben Modi arbeiten darf.  Warum 7?  Denn ohne PWM kann unsere LED nur 7 Farben liefern und die achte aus.  Diese Menge ist für den durchschnittlichen Benutzer völlig ausreichend, kann jedoch in extremen Fällen leicht erhöht werden.  Wir werden die Pedale also in einem zweidimensionalen Array von 7 x 4 speichern. Um den Speicher nicht zu verstopfen, können Werte, die mehreren Strukturen gemeinsam sind, wie z. B. die Portnummer, in separaten Arrays herausgenommen werden.  Als Ergebnis erhalten wir ungefähr Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Magie der Nummer 255</b> <div class="spoiler_text">  Sie haben wahrscheinlich bemerkt, dass in dem Artikel häufig die Nummer 255 erscheint, wo es logischer wäre, 0 zu setzen. Mit Blick auf die Zukunft werde ich sagen, dass dies für die bequeme Speicherung von Pedalen im EEPROM erforderlich ist, da ab Werk jede ihrer Zellen nicht 0 enthält, sondern Nur 255, was bedeutet, dass diese Zahl viel bequemer ist, um undefinierte Variablen als 0 anzuzeigen, damit Sie den Speicher nicht jedes Mal überschreiben. <br></div></div><br>  Es ist wichtig, dass wir nur die Art des Pedals und zwei Programme kennen, damit wir sie nur direkt in der Struktur belassen und den Rest von der Automatisierung erledigen lassen.  Die Prepare- und Loop-Methoden sehen nun folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  Der Controller betrachtet den Modus als nicht verwendet, wenn kein einziges Pedal darin deklariert ist (Modus = 255). Dies bedeutet, dass er beim Auftreffen sofort zum nächsten wechselt, der erste Modus jedoch immer vorhanden ist.  Beim Umschalten des Modus werden alle Werte in den Arrays auf Null gesetzt, da sie nicht für jeden Modus gespeichert werden müssen (richtig?). Dann umgeht die Schleife alle Pedale und ruft pedalAction für sie auf. <br><br>  Außerdem müssen Sie zu Beginn der pedalAction () -Methode die folgende Zeile hinzufügen, damit verstanden wird, mit welcher der Strukturen umgegangen werden soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  Die vorhandene Pedal1-Struktur kann als unnötig entfernt werden. <br><br>  All dies funktioniert auch ganz gut, aber ich bin auf ein Problem gestoßen: Einige Programme haben keine Zeit, Klicks mit der Geschwindigkeit zu empfangen, mit der Arduino sie sendet.  Die naheliegendste Lösung besteht darin, die Möglichkeit hinzuzufügen, bei Bedarf Verzögerungen zwischen Aktionen festzulegen.  Nur wenn wir uns hinsetzen, um Programme für Mikrocontroller zu schreiben, blieben alle Chips, wie Hardware-Multithreading, irgendwo auf High-Level-Computern. Wenn wir eine Verzögerung hinzufügen, stoppt das gesamte Programm, bis der Controller die richtige Anzahl von Zyklen zählt.  Da wir kein Multithreading haben, müssen wir es erstellen. <br><br><h3>  Schwer zu sagen, ja einfach zu machen </h3><br>  Ich habe kein Fahrrad erfunden, sondern die fertige ArduinoThread-Bibliothek genommen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> können Sie ein wenig darüber lesen, wie es funktioniert, und es herunterladen.  Sie können die Bibliothek von der Arduino IDE selbst herunterladen.  Kurz gesagt, Sie können regelmäßig eine Funktion mit einem bestimmten Intervall ausführen, ohne in eine Endlosschleife zu wechseln, wenn die Ausführung länger als das Intervall dauert.  Was du brauchst.  Erstellen Sie ein weiteres Array mit Threads für jedes Pedal: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Jetzt haben wir 6 identische virtuelle Threads, aber gleichzeitig sind sie verschiedene Objekte. <br><br>  Schreiben wir den Pedal-Bypass-Zyklus neu, um mit der neuen Funktionalität zu arbeiten: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Jetzt ergibt der Wert 252 im Programmarray, der "nichts tun" entspricht, eine Verzögerung von 10 Millisekunden (obwohl tatsächlich etwas mehr, da die Codeausführung auch Zeit benötigt).  Durch Hinzufügen einiger Zeilen zum Interpreter können Sie die Verzögerung in mehreren dieser "Quanten" einstellen und nur 2 Bytes des Arrays ausgeben: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  Im Gegensatz zu anderen Befehlen muss dieser Befehl genau am Anfang des Interpreters hinzugefügt werden, dh unmittelbar nach "while (1) {", da die Verzögerung verarbeitet werden muss, bevor der Interpreter das Programm liest.  Das Wartearray muss ebenfalls deklariert werden, wie dies bei Ports, Status usw. der Fall war.  und auch seine Zellen zurücksetzen, wenn der Modus umgeschaltet wird, so dass die Verzögerung nicht zu einem anderen Programm geht. <br><br>  Mit der Möglichkeit, die Verzögerung auf 2,55 Sekunden einzustellen, sollten nun keine Probleme bei der Definition von Schlüsseln durch Programme auftreten. <br><br><h3>  Unterwegs programmieren </h3><br>  Im Prinzip wäre es hier möglich, mit dem Code fertig zu werden und mit dem Zusammenbau des Geräts zu beginnen. In diesem Fall muss jemand, der plötzlich die Pedale neu programmieren möchte, die Arduino IDE öffnen, den Code bearbeiten und die Firmware erneut herunterladen.  Natürlich ist diese Option nicht die beste, daher habe ich beschlossen, die Möglichkeit hinzuzufügen, das Programm über die serielle Arduino-Schnittstelle zu ändern und die Programme selbst im EEPROM zu speichern.  Um mit nichtflüchtigem Speicher zu arbeiten, müssen Sie die Standardbibliothek EEPROM.h verbinden.  Der Programmiermoduscode lautet wie folgt: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  Was dieser Code bewirkt, wird durch die darin enthaltene Hilfe erklärt: Für die Modusnummer, die Pedalnummer und einen Befehl wird eine Leerzeichen-Nummer eingegeben, von denen es 3 gibt - Lesen, Schreiben und <s>Ausführen des</s> Programmlöschens.  Alle Daten auf den Pedalen werden nacheinander in einer Folge von 33 Bytes, dh dem Pedaltyp und zwei Programmen, gespeichert, und wir belegen 7 * 4 * 33 = 924 von 1024 Bytes EEPROM.  Ich habe die Option, die dynamische Größe der Pedale im Speicher zu verwenden, verworfen, da in diesem Fall beim Neuprogrammieren eines Pedals fast alle Zellen überschrieben werden müssen und es eine begrenzte Anzahl von Umschreibzyklen gibt. Wir empfehlen daher, dies so wenig wie möglich zu tun. <br><br><div class="spoiler">  <b class="spoiler_title">Funktionen der Arbeit mit EEPROM</b> <div class="spoiler_text">  Ich möchte auch auf die Linien des Formulars aufmerksam machen: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Dank dieser Bibliothek ist nichtflüchtiger Speicher aus Sicht des Programmierers ein gewöhnliches Char-Array. Als „Arduino“ müssen wir jedoch verstehen, dass das Schreiben in ein ROM eine sehr schwierige Operation ist, die vom Controller bis zu ~ 3 Sekunden dauert, und es ist ratsam, dies nicht zu unterbrechen Prozess.  Dieses Design lässt die Diode während solcher Vorgänge rot leuchten und gibt dann die „sichere“ grüne Farbe zurück. <br></div></div><br>  Im Programmaufzeichnungsmodus erfolgt die Eingabe direkt durch die Bytewerte im Dezimalzahlensystem mit einem Leerzeichen.  Es stellt sich als ziemlich schwerwiegend heraus, aber Sie müssen keinen komplexen Parser schreiben.  Darüber hinaus tritt eine Neuprogrammierung nicht so häufig auf, und in diesen Fällen ist es durchaus möglich, in die ASCII-Tabelle zu schauen. <br><br>  Nachdem die Strukturen erhalten geblieben sind, müssen wir jetzt irgendwie unsere Daten von dort herausziehen und sie in die "Pedal" -Ansicht konvertieren: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Auch hier passiert nichts Übernatürliches: Der Controller liest die Daten aus dem Speicher und füllt die vorhandenen Strukturen damit. <br><br>  Der Vorteil der Programmierung über UART besteht darin, dass wir wiederum keine speziellen Treiber benötigen, sodass Sie das Verhalten des Manipulators auch vom Telefon aus einstellen können. <br><br><h2>  Demonstration </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Vollständiger Quellcode </h2><br><div class="spoiler">  <b class="spoiler_title">Er ist hier</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 —   , 1 —  , 255 —    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Nachwort </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl ich anfangs ein Pedalboard für die Möglichkeit gemacht habe, die Aufnahme während des Gitarrenspiels zu scrollen, fand ich es persönlich praktisch, die Pedale bei normalen Aufgaben zu verwenden. Die Hauptsache ist, mich ein wenig an einen so ungewöhnlichen Manipulator zu gewöhnen. </font><font style="vertical-align: inherit;">Und hier liegt noch ein weiteres Problem: Bereits ohne Ihre Lieblingspedale wird das Arbeiten im Gegenteil schwieriger, da Sie sich daran erinnern müssen, was, wo und warum Sie drücken müssen. </font><font style="vertical-align: inherit;">Wenn Pedale noch getragen und mit dem Büro verbunden werden können, ist es am Institut schwieriger, mit ihnen in Klassenzimmern herumzulaufen. </font><font style="vertical-align: inherit;">Die Verwendung dieses Geräts für einen anderen Zweck als den ursprünglichen Zweck erfolgt auf eigene Gefahr und Gefahr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammengebautes Pedalboard:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462263/">https://habr.com/ru/post/de462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462245/index.html">Auto Git Bisect als Beispiel für den Linux-Kernel</a></li>
<li><a href="../de462251/index.html">Ist der Inkognito-Modus im Browser eine Fiktion?</a></li>
<li><a href="../de462253/index.html">Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA</a></li>
<li><a href="../de462257/index.html">Kafka auf Kubernetes - ist das gut?</a></li>
<li><a href="../de462259/index.html">Erstellen eines Controllers für ein Smart Home</a></li>
<li><a href="../de462265/index.html">Python und Würfel</a></li>
<li><a href="../de462267/index.html">Lernen Sie den PVS-Studio Static Analyzer für Java kennen</a></li>
<li><a href="../de462269/index.html">John Romero to Doom: 80er Jahre Game Dev</a></li>
<li><a href="../de462271/index.html">Sperrcode in iOS: Wie Apple von Verteidigung zu Verteidigung zur Bewachung einer einzelnen Grenze wechselte</a></li>
<li><a href="../de462273/index.html">Verwalten Sie Ihren Laptopständer mit digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>