<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèø üö∂üèæ üë®üèø‚Äçüç≥ Pedal auf den Boden: Erstellen Sie einen weiteren Fu√ümanipulator f√ºr den PC üê© üò∏ üë®üèª‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einem Monat bin ich auf diesen Artikel gesto√üen, in dem es um das Treten von Vim geht. Wenig sp√§ter, nach meinem langen dreimin√ºtigen Studium, ste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedal auf den Boden: Erstellen Sie einen weiteren Fu√ümanipulator f√ºr den PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  Vor einem Monat bin ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Artikel gesto√üen, in dem es um das Treten von Vim geht.  Wenig sp√§ter, nach meinem langen dreimin√ºtigen Studium, stellte ich fest, dass dieses Thema nicht mehr neu und sehr beliebt ist.  Ich selbst benutze Vim nur im Notfall (wenn ich in der Konsole arbeiten muss, bevorzuge ich Nano), aber Sie k√∂nnen dasselbe f√ºr andere Anwendungen tun. <br><a name="habracut"></a><br>  Anfangs wollte ich einen kleinen Artikel machen, aber ich bekam ein ganzes Tutorial zum Erstellen dieses Ger√§ts mit schrittweisem Schreiben von Code und einer Erkl√§rung, was und wie.  Um den Artikel nicht aufzublasen, gibt es unter den Spoilern verschiedene Informationen, die interessant und der Aufmerksamkeit von Neulingen in Arduino w√ºrdig erschienen. Fortgeschrittene und besonders voreilige Benutzer d√ºrfen keine Zeit damit verschwenden.  Der vollst√§ndige Quellcode wird ebenfalls am Ende des Artikels vorgestellt. <br><br><h2>  Warum brauche ich es? </h2><br>  Wenn Sie keinen Zweifel an der Notwendigkeit und N√ºtzlichkeit dieses Ger√§ts haben, k√∂nnen Sie diesen Punkt √ºberspringen.  Im √úbrigen m√∂chte ich zun√§chst auf die Voraussetzungen f√ºr die Erstellung dieses Ger√§ts eingehen. <br><br>  Programmierer und Designer haben stets versucht, eine bequeme und benutzerfreundliche Oberfl√§che zu erstellen, damit der Benutzer ohne unn√∂tige Probleme mit Maus und Tastatur mit der Anwendung arbeiten kann. Warum ben√∂tigen wir also einen anderen Manipulator?  Schauen wir uns ein wenig die Geschichte an, oder besser gesagt, zu Beginn des 18. Jahrhunderts, als ein Musikinstrument wie das Klavier erfunden wurde.  Wie Sie wissen, bedeutet dieses Wort w√∂rtlich ‚Äûlaut und leise‚Äú, aber nur wenige Menschen glauben, dass ein kluger italienischer Meister ein solches Instrument erhalten hat, indem er das damals existierende Cembalo tats√§chlich ‚Äûzerdr√ºckt‚Äú hat, wodurch es m√∂glich war, die Lautst√§rke bis zu einem gewissen Grad ohne zu steuern H√§nde von den Schl√ºsseln nehmen. <br><br>  Es gibt viele Beispiele.  Das Auto hat Pedale, um das Lenkrad nicht zu werfen, wenn Sie Benzin nachf√ºllen m√ºssen.  Das Schlagzeug hat auch Pedale zum Klopfen auf die Bassdrum und die Becken.  Und was k√∂nnen Pedale bei der Verwendung eines Computers geben?  Sie k√∂nnen beispielsweise eine Tastenkombination einstellen oder sogar eine Taste hinzuf√ºgen, die nicht vorhanden ist, z. B. das Ein- und Ausschalten des Sounds.  Die Pedale k√∂nnen helfen, wenn Ihre H√§nde besch√§ftigt sind: Ich spiele selbst Gitarre, und manchmal zur Begleitung w√§re es f√ºr mich sehr praktisch, den Hintergrund zu rollen, ohne st√§ndig die Tastatur zu erreichen.  Und schlie√ülich k√∂nnen Controller in Spielen v√∂llig unmenschliche M√∂glichkeiten bieten: Es w√§re cool, Ihre gesamte Basis in einer Strategie mit einem Klick aufzubauen oder Feinde mit einer Geschwindigkeit von einem Dutzend Schl√§gen pro Sekunde in Sch√ºtzen zu zerst√∂ren, oder? <br><br>  Generell hoffe ich, dass ich Sie √ºberzeugt habe, was bedeutet, dass es Zeit ist, direkt mit der Entwicklung selbst zu beginnen. <br><br><h2>  Erforderliche Ressourcen </h2><br><ul><li>  <b>Eigentlich die Pedale.</b>  Einige Schwierigkeiten entstanden sofort aufgrund der Tatsache, dass ich mir keinen Namen f√ºr ein solches Pedal vorstellen konnte.  Ich wusste nur, dass solche Dinge in N√§hmaschinen verwendet werden.  Im Allgemeinen gelang es mir auf Wunsch eines <b>elektrischen Pedals</b> immer noch, das zu finden, was ich bei Aliexpress brauchte, und ohne nachzudenken, bestellte ich 3 St√ºck. <br></li><li>  <b>Controller</b>  Das Pedalboard sollte die Tastatur und m√∂glicherweise die Maus emulieren, um ohne unn√∂tige Treiber eine Verbindung zu einem PC herstellen zu k√∂nnen.  Daf√ºr ist das Arduino Pro Micro Board perfekt, das zwar keine Schlussfolgerungen zieht, aber so kompakt wie m√∂glich ist.  Wir gehen zum selben Aliexpress und kaufen die chinesische Version dieses Wunders. <br></li><li>  <b>Dr√§hte.</b>  Um 3 Pedale unter den Tisch zu stellen, ben√∂tigen Sie mindestens einen vieradrigen Draht mit einer L√§nge von mindestens einem Meter.  Hier sollten meiner Meinung nach keine Probleme auftreten. <br></li><li>  <b>RGB LED und Taste.</b>  Der erste wird ben√∂tigt, um die Modi anzuzeigen, und der zweite ist, um sie zu wechseln. <br></li><li>  Nat√ºrlich brauchen wir eine Arduino IDE, einen L√∂tkolben und gerade Arme. <br></li></ul><br><h2>  Ger√§tediagramm </h2><br>  Noch bevor die Pakete ankamen, begann ich mit der Erstellung eines Ger√§tediagramms.  Obwohl dies viel gesagt wird, musste ich nur die Pedale, die Diode und den Knopf anschlie√üen.  Es stellte sich irgendwie so heraus: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  F√ºr Pedale habe ich beschlossen, 4 Ports PB1-PB4 gleichzeitig zuzuweisen, dh zwei f√ºr den linken und zwei f√ºr den rechten Fu√ü, obwohl ich bisher nur 3 Pedale habe. Au√üerdem geh√∂ren sie alle zur selben Gruppe und befinden sich an einem Ort.  Unter der LED habe ich die Ausg√§nge PD0, PD1 und PD4 unter der Taste - PD7 genommen. <br>  In diesem Fall ben√∂tigen wir keine Pull-up-Widerst√§nde, wenn Sie die im Controller eingebauten verwenden.  Wenn Sie dann jedoch eine Taste oder ein Pedal dr√ºcken, ist der Eingang niedrig, und wenn er losgelassen wird, ist er hoch, dh die Druckvorg√§nge werden invertiert, und Sie sollten dies nicht vergessen. <br><br><h2>  Code schreiben </h2><br>  Diese Phase war die schwierigste: Aufgrund einiger Fehler in den Zeigern habe ich den Bootloader mehrmals gel√∂scht und infolgedessen die Karte auf Softwareebene fast ausgefallen.  Im Folgenden werden alle Phasen der Erstellung der Firmware ausf√ºhrlich beschrieben. F√ºr diejenigen, die nur einen funktionierenden Code erhalten m√∂chten, befindet sich dieser am Ende des Artikels. <br><br><h3>  Vorbereitung </h3><br>  Zuerst m√ºssen wir verstehen, was das Pedal in Bezug auf das Programm ist.  Ich habe mich entschlossen, die Pedale in einem von zwei Modi einzustellen - Echtzeit und Trigger.  In diesem Fall hat jedes Pedal zwei Programme: Das erste wird ausgef√ºhrt, wenn das Pedal in Echtzeit oder mit ungeraden Dr√ºcken im Triggermodus gehalten wird, das zweite wird ausgef√ºhrt, wenn das Pedal in Echtzeit losgelassen wird oder wenn die Pedale im Triggermodus gleichm√§√üig gedr√ºckt werden.  Das Pedal hat auch einen Port, einen Status und zwei Variablen - die aktuellen Positionen in den Programmen 1 und 2. Ich habe diese Struktur: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 ‚Äî   , 1 ‚Äî  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  Arduino hat ziemlich viel Speicher und ist auch 8-Bit, daher ist es am besten, wenn m√∂glich zu versuchen, char anstelle von int zu verwenden. <br><br>  Wir ben√∂tigen auch die Standard-Tastaturbibliothek, um als Tastatur arbeiten zu k√∂nnen. <br><br><h3>  Klicken Sie auf Verarbeitung </h3><br>  Jetzt m√ºssen wir einen Interpreter erstellen, der Daten aus dem Array liest und in Form von Tastenanschl√§gen an die Maschine sendet sowie mehrere Werte f√ºr verschiedene interne Befehle ausw√§hlt.  Wir √∂ffnen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> mit den Schl√ºsselcodes und sehen, was und wie wir klicken k√∂nnen.  Ich habe nicht tief gegraben und alle m√∂glichen Tastaturstandards studiert, da mir die Informationen hier f√ºr ein solches Projekt v√∂llig ausreichend erschienen.  Die erste H√§lfte ist f√ºr Standard-ASCII-Zeichen reserviert (obwohl einige von ihnen nicht druckbar sind oder nicht verwendet werden), die zweite H√§lfte ist f√ºr verschiedene Modifizierertasten vorgesehen.  Es gibt sogar separate Codes f√ºr die linke und rechte Taste, was sehr erfreulich ist, aber ich habe keine speziellen Codes f√ºr die Zahlen aus dem Nampad gesehen, obwohl sie meines Wissens im System auf besondere Weise wahrgenommen werden als gew√∂hnliche Zahlen.  Vielleicht befinden sich ihre Codes irgendwo in den ‚ÄûL√∂chern‚Äú zwischen den Bereichen, aber jetzt geht es nicht darum.  Der gr√∂√üte Schl√ºssel ist also der Aufw√§rtsschl√ºssel - 218, was bedeutet, dass der Bereich 219-255 als frei angesehen werden kann, oder zumindest gibt es keine wichtigen Schl√ºssel. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Ich denke, dass selbst eine Person mit nicht dem h√∂chsten Kenntnisstand von C keine Fragen dar√ºber haben wird, was hier passiert.  Zun√§chst w√§hlt die Funktion das gew√ºnschte Pedal aus und bestimmt je nach Modus und Zustand des Pedals, welches Programm ausgef√ºhrt werden soll.  Wenn beim Lesen jedes Elements des Arrays kein Steuerzeichen verwendet wird, wird die Funktion Keyboard.write () aufgerufen, die das Dr√ºcken und Loslassen einer Taste emuliert.  Die Steuerzeichen werden separat verarbeitet und werden ben√∂tigt, um die Tastenkombinationen zu klemmen und im Programm zu navigieren. <br><br><div class="spoiler">  <b class="spoiler_title">Einige Funktionen des Tastaturmodus</b> <div class="spoiler_text">  Keyboard.write () hat einige einfache, aber f√ºr Anf√§nger nicht offensichtliche Nuancen, basierend auf der Tatsache, dass wir Daten nicht in Rohform, sondern als Tastenanschl√§ge senden.  Erstens kann der Computer seltsamerweise ohne zus√§tzliche Treiber nur Zeichen von der Tastatur akzeptieren, die sich auf der Tastatur befinden, was bedeutet, dass wir keine 0x03 (Interrupt-Signal) oder 0x1B (Beginn der ESCAPE-Sequenz) senden k√∂nnen.  Zweitens k√∂nnen wir die Gro√übuchstaben so anpassen, wie sie in der ASCII-Tabelle enthalten sind, aber die Maschine erh√§lt die Tastenkombination Umschalt + &lt;Kleinbuchstaben&gt;.  Dies kann zu einem Problem werden, wenn CapsLock aktiviert ist und wir "unerwartet" kleine Buchstaben anstelle von gro√üen Buchstaben erhalten und umgekehrt.  Drittens k√∂nnen wir die russische Sprache nicht so gut wie in jeder anderen Sprache verwenden.  Dies geschieht erneut aufgrund von nervigen Dingen wie <b>Schl√ºsselcodes</b> .  Obwohl Keyboard.write () dies als Argument akzeptiert, wird der Code, der dem Schl√ºssel entspricht, auf dem er sich im englischen Standardlayout befindet, weiterhin √ºber USB gesendet. Wenn wir versuchen, das kyrillische Alphabet zu senden, wissen wir nicht, was.  Wenn wir unseren russischsprachigen Freunden √ºber Arduino Hallo sagen m√∂chten, m√ºssen wir im Code ‚ÄûGhbdtn‚Äú schreiben und es dann senden, nachdem wir das russische Layout ausgew√§hlt haben.  Eine solche ‚ÄûBegr√º√üung‚Äú funktioniert im ukrainischen Layout, aber im Bulgarischen wird trotz der Tatsache, dass es auch ein kyrillisches Alphabet gibt, nichts daraus, da sich die Buchstaben dort an v√∂llig anderen Stellen befinden.  (Ich habe einmal die Meinung geh√∂rt, dass es f√ºr viele amerikanische und englische Entwickler unverst√§ndlich ist, dass jemand m√∂glicherweise sogar mehrere Layouts verwenden, diese aber auch wechseln muss.) <br></div></div><br>  Wir haben also einen Dolmetscher und ein grobes Verst√§ndnis daf√ºr, wie unser Pedalboard mit einem Computer interagiert.  Jetzt m√ºssen wir all dies auf den Zustand der vollst√§ndigen Firmware bringen und die Leistung auf einem Pedal √ºberpr√ºfen.  Wenn Sie eine Instanz des Pedals erstellen und zyklisch pedalAction () aufrufen, f√ºhren wir theoretisch das in der Struktur angegebene Programm aus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  Vergessen Sie √ºbrigens niemals Null-Terminatoren in diesen ‚ÄûProgrammen‚Äú, wenn ihre L√§nge kleiner als die Gr√∂√üe des Arrays ist und wenn sie nicht zyklisch sind, da Arduino nicht nur versucht, die nicht eingestellten Daten zu interpretieren, sondern sie auch mit hoher Geschwindigkeit an die Maschine sendet. und das ist das gleiche wie einem Affen eine Tastatur zu geben. <br><br><h3>  Ein Pedal ist gut und zwei sind besser </h3><br>  Jetzt ist es an der Zeit, sich mit der Verarbeitung von Signalen von mehreren Pedalen zu befassen und Schaltmodi hinzuzuf√ºgen.  Zu Beginn des Artikels wurden 4 Ports f√ºr Pedale zugewiesen, von denen jeder in sieben Modi arbeiten darf.  Warum 7?  Denn ohne PWM kann unsere LED nur 7 Farben liefern und die achte aus.  Diese Menge ist f√ºr den durchschnittlichen Benutzer v√∂llig ausreichend, kann jedoch in extremen F√§llen leicht erh√∂ht werden.  Wir werden die Pedale also in einem zweidimensionalen Array von 7 x 4 speichern. Um den Speicher nicht zu verstopfen, k√∂nnen Werte, die mehreren Strukturen gemeinsam sind, wie z. B. die Portnummer, in separaten Arrays herausgenommen werden.  Als Ergebnis erhalten wir ungef√§hr Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Magie der Nummer 255</b> <div class="spoiler_text">  Sie haben wahrscheinlich bemerkt, dass in dem Artikel h√§ufig die Nummer 255 erscheint, wo es logischer w√§re, 0 zu setzen. Mit Blick auf die Zukunft werde ich sagen, dass dies f√ºr die bequeme Speicherung von Pedalen im EEPROM erforderlich ist, da ab Werk jede ihrer Zellen nicht 0 enth√§lt, sondern Nur 255, was bedeutet, dass diese Zahl viel bequemer ist, um undefinierte Variablen als 0 anzuzeigen, damit Sie den Speicher nicht jedes Mal √ºberschreiben. <br></div></div><br>  Es ist wichtig, dass wir nur die Art des Pedals und zwei Programme kennen, damit wir sie nur direkt in der Struktur belassen und den Rest von der Automatisierung erledigen lassen.  Die Prepare- und Loop-Methoden sehen nun folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  Der Controller betrachtet den Modus als nicht verwendet, wenn kein einziges Pedal darin deklariert ist (Modus = 255). Dies bedeutet, dass er beim Auftreffen sofort zum n√§chsten wechselt, der erste Modus jedoch immer vorhanden ist.  Beim Umschalten des Modus werden alle Werte in den Arrays auf Null gesetzt, da sie nicht f√ºr jeden Modus gespeichert werden m√ºssen (richtig?). Dann umgeht die Schleife alle Pedale und ruft pedalAction f√ºr sie auf. <br><br>  Au√üerdem m√ºssen Sie zu Beginn der pedalAction () -Methode die folgende Zeile hinzuf√ºgen, damit verstanden wird, mit welcher der Strukturen umgegangen werden soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  Die vorhandene Pedal1-Struktur kann als unn√∂tig entfernt werden. <br><br>  All dies funktioniert auch ganz gut, aber ich bin auf ein Problem gesto√üen: Einige Programme haben keine Zeit, Klicks mit der Geschwindigkeit zu empfangen, mit der Arduino sie sendet.  Die naheliegendste L√∂sung besteht darin, die M√∂glichkeit hinzuzuf√ºgen, bei Bedarf Verz√∂gerungen zwischen Aktionen festzulegen.  Nur wenn wir uns hinsetzen, um Programme f√ºr Mikrocontroller zu schreiben, blieben alle Chips, wie Hardware-Multithreading, irgendwo auf High-Level-Computern. Wenn wir eine Verz√∂gerung hinzuf√ºgen, stoppt das gesamte Programm, bis der Controller die richtige Anzahl von Zyklen z√§hlt.  Da wir kein Multithreading haben, m√ºssen wir es erstellen. <br><br><h3>  Schwer zu sagen, ja einfach zu machen </h3><br>  Ich habe kein Fahrrad erfunden, sondern die fertige ArduinoThread-Bibliothek genommen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> k√∂nnen Sie ein wenig dar√ºber lesen, wie es funktioniert, und es herunterladen.  Sie k√∂nnen die Bibliothek von der Arduino IDE selbst herunterladen.  Kurz gesagt, Sie k√∂nnen regelm√§√üig eine Funktion mit einem bestimmten Intervall ausf√ºhren, ohne in eine Endlosschleife zu wechseln, wenn die Ausf√ºhrung l√§nger als das Intervall dauert.  Was du brauchst.  Erstellen Sie ein weiteres Array mit Threads f√ºr jedes Pedal: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Jetzt haben wir 6 identische virtuelle Threads, aber gleichzeitig sind sie verschiedene Objekte. <br><br>  Schreiben wir den Pedal-Bypass-Zyklus neu, um mit der neuen Funktionalit√§t zu arbeiten: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Jetzt ergibt der Wert 252 im Programmarray, der "nichts tun" entspricht, eine Verz√∂gerung von 10 Millisekunden (obwohl tats√§chlich etwas mehr, da die Codeausf√ºhrung auch Zeit ben√∂tigt).  Durch Hinzuf√ºgen einiger Zeilen zum Interpreter k√∂nnen Sie die Verz√∂gerung in mehreren dieser "Quanten" einstellen und nur 2 Bytes des Arrays ausgeben: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  Im Gegensatz zu anderen Befehlen muss dieser Befehl genau am Anfang des Interpreters hinzugef√ºgt werden, dh unmittelbar nach "while (1) {", da die Verz√∂gerung verarbeitet werden muss, bevor der Interpreter das Programm liest.  Das Wartearray muss ebenfalls deklariert werden, wie dies bei Ports, Status usw. der Fall war.  und auch seine Zellen zur√ºcksetzen, wenn der Modus umgeschaltet wird, so dass die Verz√∂gerung nicht zu einem anderen Programm geht. <br><br>  Mit der M√∂glichkeit, die Verz√∂gerung auf 2,55 Sekunden einzustellen, sollten nun keine Probleme bei der Definition von Schl√ºsseln durch Programme auftreten. <br><br><h3>  Unterwegs programmieren </h3><br>  Im Prinzip w√§re es hier m√∂glich, mit dem Code fertig zu werden und mit dem Zusammenbau des Ger√§ts zu beginnen. In diesem Fall muss jemand, der pl√∂tzlich die Pedale neu programmieren m√∂chte, die Arduino IDE √∂ffnen, den Code bearbeiten und die Firmware erneut herunterladen.  Nat√ºrlich ist diese Option nicht die beste, daher habe ich beschlossen, die M√∂glichkeit hinzuzuf√ºgen, das Programm √ºber die serielle Arduino-Schnittstelle zu √§ndern und die Programme selbst im EEPROM zu speichern.  Um mit nichtfl√ºchtigem Speicher zu arbeiten, m√ºssen Sie die Standardbibliothek EEPROM.h verbinden.  Der Programmiermoduscode lautet wie folgt: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  Was dieser Code bewirkt, wird durch die darin enthaltene Hilfe erkl√§rt: F√ºr die Modusnummer, die Pedalnummer und einen Befehl wird eine Leerzeichen-Nummer eingegeben, von denen es 3 gibt - Lesen, Schreiben und <s>Ausf√ºhren des</s> Programml√∂schens.  Alle Daten auf den Pedalen werden nacheinander in einer Folge von 33 Bytes, dh dem Pedaltyp und zwei Programmen, gespeichert, und wir belegen 7 * 4 * 33 = 924 von 1024 Bytes EEPROM.  Ich habe die Option, die dynamische Gr√∂√üe der Pedale im Speicher zu verwenden, verworfen, da in diesem Fall beim Neuprogrammieren eines Pedals fast alle Zellen √ºberschrieben werden m√ºssen und es eine begrenzte Anzahl von Umschreibzyklen gibt. Wir empfehlen daher, dies so wenig wie m√∂glich zu tun. <br><br><div class="spoiler">  <b class="spoiler_title">Funktionen der Arbeit mit EEPROM</b> <div class="spoiler_text">  Ich m√∂chte auch auf die Linien des Formulars aufmerksam machen: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Dank dieser Bibliothek ist nichtfl√ºchtiger Speicher aus Sicht des Programmierers ein gew√∂hnliches Char-Array. Als ‚ÄûArduino‚Äú m√ºssen wir jedoch verstehen, dass das Schreiben in ein ROM eine sehr schwierige Operation ist, die vom Controller bis zu ~ 3 Sekunden dauert, und es ist ratsam, dies nicht zu unterbrechen Prozess.  Dieses Design l√§sst die Diode w√§hrend solcher Vorg√§nge rot leuchten und gibt dann die ‚Äûsichere‚Äú gr√ºne Farbe zur√ºck. <br></div></div><br>  Im Programmaufzeichnungsmodus erfolgt die Eingabe direkt durch die Bytewerte im Dezimalzahlensystem mit einem Leerzeichen.  Es stellt sich als ziemlich schwerwiegend heraus, aber Sie m√ºssen keinen komplexen Parser schreiben.  Dar√ºber hinaus tritt eine Neuprogrammierung nicht so h√§ufig auf, und in diesen F√§llen ist es durchaus m√∂glich, in die ASCII-Tabelle zu schauen. <br><br>  Nachdem die Strukturen erhalten geblieben sind, m√ºssen wir jetzt irgendwie unsere Daten von dort herausziehen und sie in die "Pedal" -Ansicht konvertieren: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Auch hier passiert nichts √úbernat√ºrliches: Der Controller liest die Daten aus dem Speicher und f√ºllt die vorhandenen Strukturen damit. <br><br>  Der Vorteil der Programmierung √ºber UART besteht darin, dass wir wiederum keine speziellen Treiber ben√∂tigen, sodass Sie das Verhalten des Manipulators auch vom Telefon aus einstellen k√∂nnen. <br><br><h2>  Demonstration </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Vollst√§ndiger Quellcode </h2><br><div class="spoiler">  <b class="spoiler_title">Er ist hier</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 ‚Äî   , 1 ‚Äî  , 255 ‚Äî    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Nachwort </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl ich anfangs ein Pedalboard f√ºr die M√∂glichkeit gemacht habe, die Aufnahme w√§hrend des Gitarrenspiels zu scrollen, fand ich es pers√∂nlich praktisch, die Pedale bei normalen Aufgaben zu verwenden. Die Hauptsache ist, mich ein wenig an einen so ungew√∂hnlichen Manipulator zu gew√∂hnen. </font><font style="vertical-align: inherit;">Und hier liegt noch ein weiteres Problem: Bereits ohne Ihre Lieblingspedale wird das Arbeiten im Gegenteil schwieriger, da Sie sich daran erinnern m√ºssen, was, wo und warum Sie dr√ºcken m√ºssen. </font><font style="vertical-align: inherit;">Wenn Pedale noch getragen und mit dem B√ºro verbunden werden k√∂nnen, ist es am Institut schwieriger, mit ihnen in Klassenzimmern herumzulaufen. </font><font style="vertical-align: inherit;">Die Verwendung dieses Ger√§ts f√ºr einen anderen Zweck als den urspr√ºnglichen Zweck erfolgt auf eigene Gefahr und Gefahr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammengebautes Pedalboard:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462263/">https://habr.com/ru/post/de462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462245/index.html">Auto Git Bisect als Beispiel f√ºr den Linux-Kernel</a></li>
<li><a href="../de462251/index.html">Ist der Inkognito-Modus im Browser eine Fiktion?</a></li>
<li><a href="../de462253/index.html">Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA</a></li>
<li><a href="../de462257/index.html">Kafka auf Kubernetes - ist das gut?</a></li>
<li><a href="../de462259/index.html">Erstellen eines Controllers f√ºr ein Smart Home</a></li>
<li><a href="../de462265/index.html">Python und W√ºrfel</a></li>
<li><a href="../de462267/index.html">Lernen Sie den PVS-Studio Static Analyzer f√ºr Java kennen</a></li>
<li><a href="../de462269/index.html">John Romero to Doom: 80er Jahre Game Dev</a></li>
<li><a href="../de462271/index.html">Sperrcode in iOS: Wie Apple von Verteidigung zu Verteidigung zur Bewachung einer einzelnen Grenze wechselte</a></li>
<li><a href="../de462273/index.html">Verwalten Sie Ihren Laptopst√§nder mit digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>