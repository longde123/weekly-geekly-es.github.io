<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◀️ ♒️ 🔃 世界您好！ 深入浸入终端 🚊 🛠️ 🤾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一篇有关Sishny printf分析的文章启发了我写这篇文章。 但是，错过了片刻之后数据进入终端设备的方式。 在本文中，我想纠正此缺陷并分析终端中的数据路径。 我们还将弄清Terminal与Shell的区别，Pseudoterminal是什么，Terminal Emulator如何工作等等。 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>世界您好！ 深入浸入终端</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇有关Sishny printf分析的文章</a>启发了我写这篇文章。 但是，错过了片刻之后数据进入终端设备的方式。 在本文中，我想纠正此缺陷并分析终端中的数据路径。 我们还将弄清Terminal与Shell的区别，Pseudoterminal是什么，Terminal Emulator如何工作等等。 </p><a name="habracut"></a><br><h2 id="osnovy"> 基础知识 </h2><br><p> 首先让我们了解一下Terminal，Shell，Console是什么，Terminal Emulator与普通Terminal有何不同，以及为什么如此命名。 已经有很多关于此的信息，因此您在这里不会听到新的消息。 这里几乎所有信息都是从Internet上获取的，我将在文章结尾处提供链接。 谁已经知道所有这些内容意味着什么，可以安全地跳过此部分。 </p><br><hr><br><h3 id="terminal"> 航站楼 </h3><br><p>  <strong>终端</strong>是显示器和键盘（即物理设备）的组合。 在终端成为这种特定组合之前，它们是一种称为电传打字机（电传打字机，电传打字机或TTY）的设备，即打印机和键盘的组合。 通常，多个终端连接到同一台计算机。 因此，可以在同一台计算机上为多个用户工作，并且每个人都有自己的会话，彼此独立。 终端之所以这样命名是因为它位于终端电缆的末端。 </p><br><p> 这是<strong>电传打字机</strong> ： </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="电传打字" width="430" height="370"><br><br><p> 这是<strong>终端</strong> ： </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="航站楼" width="430" height="370"><br><br><hr><br><h3 id="console"> 主控台 </h3><br><p>  <strong>控制台（控制台）</strong> -直接连接到计算机的终端。 事实是，大多数终端都是隐式连接的，但至少有一个直接连接到计算机。 允许控制台使用严格定义的人员圈子，因为它允许您配置计算机。 </p><br><hr><br><h3 id="shell"> 壳牌 </h3><br><p> 如果前两个是物理设备，则此定义专门指软件。 </p><br><p>  <strong>Shell</strong>是命令行解释器。 主要目的是运行其他程序。 有大量不同的Shell。 最常见的是Bash（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a>所说，来自英语的Bourne Again SHell，是“ Born Again” Shell（即“复活” Shell）的双关语）。 其他示例：Dash（轻量级Shell，如果在/ bin / sh中运行二进制文件，则可用），Zsh。 </p><br><hr><br><p> 当然，终端和控制台都不得不在现代中找到自己的反映。 因此，我们将进一步考虑诸如<em>Terminal Emulator</em>和<em>Virtual Console之</em>类的东西。 </p><br><h3 id="terminal-emulator"> 终端模拟器 </h3><br><p>  <strong>终端仿真器</strong> -老式终端的仿真器。 无法与X Window系统直接交互的程序-Bash，Vim等需要终端仿真器。 </p><br><p> 让我们首先确定终端的职责： </p><br><ol><li> 将用户输入传输到计算机 </li><li> 将计算机输出传送到显示器 </li></ol><br><p> 因此，我们的终端仿真器执行的操作完全相同：它将用户输入传递给正在运行的程序，并在显示屏上显示该程序的输出。 无论如何，含义仍然存在-在用户和正在运行的程序之间，存在某种负责输入/输出的层。 终端仿真器的示例：gnome-terminal，xterm，konsole。 </p><br><p>  <strong>请不要混淆外壳程序和终端仿真器！</strong> <br> 终端仿真器是一个GUI应用程序，即X Window系统中的一个窗口。  Shell是命令行解释器，即只是命令执行程序，它没有图形化的Shell。 说得很对，您<strong>没有启动Bash</strong> ，而是<strong>运行Terminal Emulator，后者在内部启动了Bash</strong> 。 终端仿真器和Bash绝对是2个不同的程序。 第一个完全负责输入/输出，第二个-处理命令。 </p><br><p> 在本文的进一步内容中，对终端的所有引用将引用终端仿真器。 </p><br><hr><br><h3 id="virtual-console-virtual-terminal"> 虚拟控制台（虚拟终端） </h3><br><p> 按Ctrl + Alt + FN，其中N通常具有1到6的值。您刚才看到的称为虚拟控制台（虚拟控制台）或虚拟终端（虚拟终端）。 还记得我之前说的关于终端的内容吗？ 许多终端连接到一台计算机，每个终端是一个单独的会话，彼此独立。 虚拟控制台重复了这个想法：您的计算机内部可能有几个独立的会话（但是，计算机资源显然仍是共享的）。 </p><br><p> 您可以将这个实体命名为Virtual Console和Virtual Terminal，因为根据定义，控制台是直接连接到计算机的终端，但是从某种意义上说，所有虚拟终端都直接连接到计算机。 </p><br><hr><br><h3 id="tty-ustroystva">  TTY设备 </h3><br><p> 每个终端都分配有自己的<em>TTY设备</em> （终端设备），该设备提供控制台。 虽然您不太可能找到电传打字机，但是TTY的降低一直持续到今天。 </p><br><p>  TTY设备包含两个基本组件： </p><br><ol><li>  <strong>设备驱动</strong> 他负责将键盘输入传递给程序，并负责在屏幕上显示程序输出。 </li><li>  <strong>TTY线学科</strong> （俄语-线学科）。 线路规程是驱动程序访问接口，但是，它给TTY设备带来了很多逻辑。 可以说，线规代理会致电给驾驶员。 我们将在本文中找到该组件的职责范围是什么。 </li></ol><br><p> 构建TTY设备： </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="构建TTY设备"></p><br><p>  TTY设备有3种类型： </p><br><ol><li>  <em>控制台设备</em> -提供虚拟控制台操作。 该设备的输入和输出完全由内核控制。 </li><li>  <em>PTY设备</em> （伪终端）-在窗口界面中提供终端操作。 该设备的输入和输出由在用户空间中运行的终端仿真器控制。 </li><li>  <em>串行设备</em> -直接与硬件通信。 它通常不直接使用，而是作为终端设备体系结构组织中的最低级别存在。 </li></ol><br><p> 在本文中，我们将专门讨论第二种TTY设备-伪终端。 </p><br><hr><br><h2 id="tty-line-discipline">  TTY线学科 </h2><br><p> 我们开始研究TTY设备系列的规范。 </p><br><p> 线规的第一个重要特征是它负责处理I / O。 例如，这包括处理控制字符（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="控制字符">控制字符</a> ）和格式化输出。 例如，您输入了任何文本，但是突然您意识到自己在写东西时想错了并且想要删除它-这就是行规的作用。 </p><br><p> 我们将详细分析在终端中运行Bash时发生的确切情况。 默认情况下，TTY设备在<em>启用回显的</em>情况下以规范模式运行。 回声是您在屏幕上输入的字符的显示。 </p><br><p>例如，当我们输入字符<code>a</code> ，该字符将发送到TTY设备，但会被设备的TTY行的纪律所截获。 她将一个字符读入内部缓冲区，看到<code>echo</code>模式已打开，然后在屏幕上显示该字符。 此时，仍然无法读取终端设备所连接的程序。 让我们按键盘上的<code>backspace</code>键。 符号<code>^?</code> 再次受到线规的拦截，后者意识到用户要删除最后输入的字符，因此从其内部缓冲区中删除了该字符，并从屏幕上也删除了该字符。 现在，如果我们按Enter键，则TTY线路纪律最终会将以前写入内部规范缓冲区（包括LF）的所有内容发送到终端设备的读取缓冲区。 同时，在屏幕上显示字符CR和LF，以将光标移至新行-这是输出的格式。 </p><br><p> 这就是规范模式的工作方式-仅在按<code>Enter</code> ，将控制字符处理并格式化输出后，才将所有输入的字符传输到设备。 </p><br><h3 id="tty-line-editing">  TTY行编辑 </h3><br><p>  <strong>TTY线路编辑</strong>是负责处理线路规程中输入的组件。 应该说， <em>行编辑</em>是一个通用概念，它与输入处理有关。 例如，Bash和Vim有自己的行编辑。 </p><br><p> 我们可以使用<strong>stty</strong>程序控制当前TTY设备的线路的学科设置。 让我们尝试一下。 </p><br><p> 打开Bash或任何其他Shell，然后键入： </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p> 现在尝试输入内容，您将看不到输入内容（不用担心，您仍然可以将输入内容传递给程序）。 您刚刚禁用了回显-即在屏幕上显示输入的字符。 现在输入： </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p> 尝试输入内容。 您将看到结论是如何被打破的。 但是，为了获得更多效果，让我们进入Dash type <code>/bin/sh</code> 。 现在，尝试输入特殊字符（ <code>Ctrl</code> +键盘上的任何字符）或仅按<code>Enter</code> 。 您感到困惑-屏幕上这些奇怪的字符是什么？ 事实是，除了进入学科最简单的命令行管理程序之外，我们还禁用了Line Editing Bash，现在我们可以有力地观察到并主要包含了该行的<em>原始</em>学科模式。 此模式根本不处理输入，也不格式化输出。 为什么需要原始模式？ 例如，对于<em>Vim</em> ：它会打开整个终端窗口并处理输入本身，至少使行规的特殊符号不会与Vim本身的特殊符号相交。 </p><br><p> 为了获得更多理解，让我们看一下定制控制字符。  <code>stty &lt;control-character&gt; &lt;string&gt;</code>命令将帮助我们解决此问题。 <br> 输入Bash： </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p> 现在， <code>erase</code>控制字符将分配给字符<code>0</code> 。  <code>backspace</code>按钮通常很重要<code>^?</code>  ，但是现在这个特殊字符将按字面意义发送到PTS读取缓冲区-自己尝试。 现在，您可以使用键盘上的<code>0</code>按钮擦除字符，因为您自己要求tty行规矩将输入的字符识别为<code>erase</code>控制字符。 您可以使用命令<code>stty erase ^\?</code>返回设置<code>stty erase ^\?</code> 或者只是关闭终端，因为我们只影响了当前的tty设备。 </p><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="男人的风格">man stty中</a>找到更多信息。 </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal"> 终端仿真器和伪终端 </h2><br><p> 每次我们在X Window系统中打开一个新终端时，GNOME终端服务器都会产生一个新进程并在其中启动默认程序。 通常，这是某种Shell（例如Bash）。 </p><br><p> 与正在运行的程序的通信通过所谓的伪终端（pseudo-terminal，PTY）进行。 伪终端本身存在于内核中，但是它从用户空间（从终端仿真器）接收输入。 </p><br><p> 伪终端由以下两个<em>虚拟TTY设备组成</em> ： <br>  1） <strong>PTY主站（PTM）</strong> -伪终端的<strong>开头</strong>部分。  GNOME终端服务器使用它来将键盘输入传输到终端内运行的程序，以及读取程序输出和显示输出。  GNOME终端服务器又通过X协议与X Window系统通信。 <br>  2） <strong>PTY从站（PTS）</strong> -伪终端的从站部分。 由终端内运行的程序使用，以读取键盘输入并在屏幕上显示输出。 至少程序本身是这样认为的（我将进一步解释这意味着什么）。 </p><br><p> 记录在PTS设备中的任何数据都是PTM设备的输入，也就是说，它在PTM设备上变得可读。 反之亦然：PTM设备中记录的任何数据都是PTS设备的输入。 这是GNOME终端服务器与终端中运行的程序进行通信的方式。 每个PTM设备都与自己的PTS设备关联。 </p><br><p> 启动新终端的过程如下所示： <br>  1）GNOME终端服务器通过在特殊设备<strong>/ dev / ptmx</strong>上调用open（）函数来创建主设备和从设备。  open（）调用返回已创建的PTM设备<em>master_fd的</em>文件描述符。 <br>  2）GNOME终端服务器通过调用<code>fork()</code>创建一个新进程。 此过程将成为新的终端。 <br>  3）在PTS终端中，设备打开文件描述符0、1、2（分别为stdin，stdout和stderr）。 现在，标准终端I / O流到该设备。 <br>  4）通过调用<code>exec()</code>函数在终端中启动所需的程序。 通常会启动一些Shell（例如Bash）。 随后从Bash启动的任何程序都将具有与Bash本身相同的文件描述符，也就是说，程序流将定向到PTS设备。 </p><br><p> 您可以使用<code>ls -la /proc/self/fd</code>亲自查看标准终端输出流的方向： <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  PTS设备位于<strong>/ dev / pts / N</strong>路径上，而到PTM设备的路径根本使我们不感兴趣。 事实是GNOME终端服务器已经具有用于打开的PTM设备的文件描述符，并且不需要它的路径，但是，在子进程中，我们必须通过调用<code>open()</code>函数在标准输出流上打开PTS设备，这需要文件的路径。 </p><br><p> 还记得我说过使用PTS设备的程序只认为它直接与终端通信吗？ 事实是PTS也是<em>终端设备</em> （TTY设备），但是PTS设备与实际TTY设备之间的区别在于PTS设备不是从键盘接收输入，而是从主设备接收输入，并且输出不进入显示器，而是进入显示器。主设备。 这就是为什么伪终端如此命名的原因-伪终端仅模仿（还是??）终端。 终端仿真器和伪终端之间的区别在于，终端仿真器只是一个图形程序，允许您直接在窗口界面内运行终端，但是此功能是使用伪终端实现的。 </p><br><p>  <em>PTS设备是TTY设备</em>这一事实非常重要。 原因如下： </p><br><ol><li> 终端设备所连接的程序具有常规终端的所有功能。 例如：禁用回显，禁用/启用规范视图。 </li><li> 该程序在知道已连接终端设备的情况下（据说该程序具有控制终端），可以交互工作并要求用户输入。 例如，要求输入用户名和密码。 </li><li> 还有一个TTY线路纪律，因此我们能够在控制字符到达程序之前对其进行处理，以及格式化程序的输出。 </li></ol><br><p>  PTM设备也是TTY设备，但是由于它不用作控制终端，因此它没有任何作用。 此外，由于PTM设备的线路规则设置为原始模式，因此，在将数据从PTS传输到PTM设备时不执行处理。 但是，从用户空间进行的<code>read()</code>和<code>write()</code>调用仍然首先由这两种设备上的线路规程服务。 正如我们稍后将看到的那样，这一刻将发挥更大的作用。 </p><br><p>  GNOME终端服务器与终端中运行的程序之间的通信过程如下： </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="通信GNOME终端服务器和终端中运行的程序的过程"></p><br><p> 值得更详细地研究线路规则在伪终端的两个部分之间进行通信时所扮演的角色。 在此，线路规则负责处理<em>从PTM传递到PTS设备的数据</em> ，并负责将数据从伪终端的一部分传递到另一部分。 当我们进入PTS设备驱动程序时，我们会参与PTM设备的线路规程，反之亦然。 </p><br><hr><br><h2 id="virtualnye-ustroystva"> 虚拟设备 </h2><br><p> 您可能会想到，您可以沿着<em>/ dev / pts / N</em>路径打开文件，并从文件中写入或读取数据，就像从常规文本文件中读取数据一样？ 是的，由于Unix的基本原理（所有内容都是文件），因此类Unix系统上的所有设备都是文件。 但是，没有特殊的设备文件（英语-设备文件）是文本文件。 此类设备称为<strong>虚拟设备</strong> -即它们仅存在于内存中，而不存在于磁盘上。 </p><br><p> 不要尝试将这些文件作为常规文本文件打开。 但是，您可以通过<code>write()</code>和<code>read()</code>操作使用这些设备，其调用将由设备驱动程序提供。 让我们尝试去做。 </p><br><p> 打开两个终端窗口，然后在每个命令中输入<code>tty</code> 。 该命令将显示哪个TTY设备正在为当前活动的终端服务。 现在输入<code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> ，在第一个终端窗口中，其中N是第二个窗口设备的PTS索引，切换到第二个窗口，您将在第一个窗口中看到输入。 现在，您已将数据写入第二个窗口的PTS设备， <em>就好像是由该终端中运行的程序完成的一样</em> 。 </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala"> 伪终端设备 </h2><br><p> 我们越来越接近本文的最后一部分，但是在此之前，我们先来看看Linux的“幕后”-在内核级别考虑伪终端的设备。 会有很多代码，但是我将尝试尽可能详细地解释每个给定的代码块，减少不重要的细节并按顺序进行。 </p><br><p> 在开始之前，我们将介绍所谓的“组件篮”。 当我们沿着核心前进时，我们将向它添加越来越多的组件，并在它们之间找到联系。 希望这可以帮助您更好地了解伪终端设备。 让我们开始吧。 </p><br><p>  Linux启动时，它将加载必要的设备驱动程序。 我们的伪终端也有这样的驱动程序。 其注册从调用此函数开始： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p> 对于所有现代系统，将<code>unix98_pty_init()</code>函数： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p> 在这里，我们对三件事感兴趣： </p><br><ol><li> 为pty主驱动程序和pty从设备调用<code>tty_set_operatons</code> 。 </li><li>  <code>ptmx_open</code>函数，用于在打开特殊设备<em>/ dev / ptmx</em>时创建伪终端的两个部分。 重要说明：/ dev / ptmx不是PTM设备，而只是用于创建新的伪终端的接口。 </li><li> 注册PTM和PTS设备驱动程序。 </li></ol><br><p> 让我们按顺序进行： </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  <strong>tty_set_operations（）</strong>函数只是为当前驱动程序设置一个函数表： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  <strong>tty_operations</strong>结构是一个功能表，用于访问设备TTY驱动程序功能。 </p><br><p> 我将在结构<code>pty_unix98_ops</code>和<code>ptm_unix98_ops</code>最重要的东西，它们是伪终端相应部分的功能表： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p> 在这里，您可以观察到pty_write函数， <code>pty_write</code>函数已经在Sishny printf上的文章中很熟悉了-我们稍后再返回。 </p><br><p> 让我们将此结构添加到组件篮中： <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p> 如您所见，两个驱动程序的主要方法完全没有区别。 顺便说一下，请注意，没有用于read（）操作的功能-没有像<code>pty_read()</code> 。 事实是，阅读将完全由学科来服务。 因此，我们了解了生产线规程的第二个重要特征-从TTY设备读取数据。 </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p> 现在让我们继续到<strong>ptmx_open（）</strong> ： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p> 我们对<code>tty_init_dev()</code>函数感兴趣，其中第一个参数是PTM设备驱动程序，第二个参数是设备索引。 在这里，我们离开了PTY驱动程序的责任范围，并转到该文件，该文件仅对常规TTY设备负责，而对伪终端一无所知。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p> 首先，我们将<code>alloc_tty_struct()</code>函数： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p> 我们唯一感兴趣的是<code>tty_ldisc_init()</code>函数： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p> 哪个调用<code>tty_ldisc_get()</code> ： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p> 因此，我们检查了对<code>alloc_tty_struct()</code>函数的调用，该函数创建了<em>tty_struct</em>结构以及行规<em>-tty_ldisc</em>结构。 两种结构相互之间都有链接。 让我们仔细看看这些结构。 </p><br><ul><li>  <strong>tty_struct</strong>是用于访问TTY设备驱动程序和其他一些字段的结构。 看起来像这样： </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong>是该设备的TTY行的规则结构。 它仅包含两个字段，外观如下： </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p> 似乎没什么复杂的？ 让我们将到目前为止考虑的所有结构添加到我们的篮中，并按照与代码中连接它们相同的方式链接它们： <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt=" tty_struct" title="编译tty_struct"></p><br><p> 但是我们只为PTM设备创建了tty_struct。  PTS设备呢？ 为此，我们返回<code>tty_init_dev()</code>函数，并回想一下我们应该调用<code>tty_driver_install_tty()</code>函数： </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p> 注释告诉我们，此方法负责创建各种其他结构。  PTS设备将成为我们的附加结构。 我承认，这对我来说非常令人惊讶，因为它是该死的整个设备，而不仅仅是一些额外的结构！ 但是我们都知道所有设备都只是某种结构，所以继续前进。 好的，什么是<em>driver-&gt; ops-&gt;在这里安装</em> ？ 为此，请再次查看PTM驱动程序的功能表： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p> 并且我们了解到我们对<code>pty_unix98_install()</code>函数感兴趣： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p> 其中调用<code>pty_common_install()</code>函数： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  —  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p> .      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title=" PTY"></p><br><hr><br><h2 id="hello-world"> 世界您好！ </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> —       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> —   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer —       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   —        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ? 不管如何      ,     ,      —        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      —    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        —         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    —  <code>n_tty_read()</code> .      ,  ,          — <em>read_buf</em> —   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  —     ,   ! </p><br><h3 id="istochniki"> 资料来源 </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460257/">https://habr.com/ru/post/zh-CN460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460247/index.html">ELFs的食谱</a></li>
<li><a href="../zh-CN460249/index.html">用pwnable.kr 07解决任务-输入。 了解pwntools</a></li>
<li><a href="../zh-CN460251/index.html">人为的愚蠢：对我没有帮助的机器人</a></li>
<li><a href="../zh-CN460253/index.html">提高语音助手技能的10个理由</a></li>
<li><a href="../zh-CN460255/index.html">Node.js上的后门程序：为什么，为什么以及如何工作</a></li>
<li><a href="../zh-CN460259/index.html">什么是UI和UX设计？ 有什么共同点和不同点？</a></li>
<li><a href="../zh-CN460261/index.html">亚马逊：电子商务成功25年</a></li>
<li><a href="../zh-CN460263/index.html">进行真正的智能搜索：分步指南</a></li>
<li><a href="../zh-CN460265/index.html">创建一个Xcode项目模板</a></li>
<li><a href="../zh-CN460273/index.html">Apple Pay中最小的授权</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>