<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📤 🛌🏿 ⛹🏿 自己的导航堆栈。 比ROS更好？ 🤞🏾 👩🏻‍🎓 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是setUP团队的第二篇文章，介绍了我们在为Eurobot Open竞赛创建自动机器人并为此使用ROS方面的经验。 

 第一篇文章介绍了机器人的力学和总体架构。 

 机器人在平坦的地面上行驶，大多数障碍是事先知道的，但是，阴险的对手可以尝试窃取我们的资源（我们有时想吃掉几十个额外的积分），同时...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>自己的导航堆栈。 比ROS更好？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/">这是setUP团队的第二篇文章，介绍了我们在为Eurobot Open竞赛创建自动机器人并为此使用ROS方面的经验。 <br><br>  <a href="https://habr.com/ru/post/478836/">第一篇文章介绍了机器人的力学和总体架构。</a> <br><br> 机器人在平坦的地面上行驶，大多数障碍是事先知道的，但是，阴险的对手可以尝试窃取我们的资源（我们有时想吃掉几十个额外的积分），同时我们希望尽快驶向所需的地点而不碰障碍物。 从现场的外部摄像机，我们可以获得敌人的位置数据，并知道他现在的位置。 但是，仅仅知道他的位置还不够-您需要能够使用此信息。 <br><br> 今天，我们将尝试从A点驶向B点，而不必沿着在赛场上睡着了的猫尾巴走。 特别是，我们将说明如何构建路线并控制机器人的速度，并说明如何启动计算机上的所有内容。 <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3> 试图一点点流血 </h3><br> 解决此问题时，您可以获取专业人士编写的现成材料，这样就不会有下一个“自行车”的折磨和发明。 我们使用的是全轮式平台，因此尽管尝试使用ROS提供的现成的本地刨床，但由于多种原因，他们认为这是没有希望的。 在下面，您可以看到标准滑翔机的设计师需要多少东西： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>这是用于调节速度和整体轨迹的参数初始化的示例。</i> <br><br> 完整计算的重要参数： <br><br><ol><li> 参数world_model。 </li><li> 成本图参数：到包含障碍物及其“虚拟延伸”的地图的链接，其中考虑了潜在的碰撞。 </li></ol><br> 在标准堆栈的优点中，您可以突出显示文档的可用性以及在论坛上查找信息的能力。  <a href="https://github.com/ros-planning/navigation" rel="nofollow">您可以在官方网站上阅读更多文档</a> <br><br> 值得一提的是，ROS软件包是为两轮平台编写的，在Omni之下，它们通过增加到360度时的可用旋转角度进行了优化，这无疑是一个拐杖。 <br><br> 对项目进行分析后，我们意识到学习和补充存在困难，并且不需要很多繁重的芯片。 看起来，让它们成为现实，但是我们使用了Odroid xu4（该处理器仍在三星s5上使用），性能结果令人沮丧，而更强大的设备的空间（与之相比，树莓4和jetson nano处理器则紧张地抽烟了）和他在一起） 我不得不放弃标准堆栈，尝试自己创建全局计划程序，本地计划程序和轨迹管理器 <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3> 全球规划师，本地规划师，轨迹管理器以及所有这些 </h3><br> 需要全球和本地滑翔机才能获得前往目的地的路线。 为什么需要分隔？ 您为什么不能只乘<a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a>乘它呢？ 通常，全局规划人员在构造路线时可以在其工作中使用整个地图，因此算法应该尽可能快，甚至可以进行一些简化。 为了简化这些简化过程，他们还使用了本地计划程序，该程序根据全局计划程序的结果（或仅在机器人周围的有限区域内）尝试考虑所有细微差别。 <br><br> 构建路线后，我们知道机器人应该去哪里，但是如何得知他呢？ 为此，有一个轨迹调节器。 它计算机器人此时应以什么速度和朝哪个方向运动，以免偏离轨迹。 在许多方面，此软件包负责机器人运行的速度和美观程度。 <br><br> 除了这三个实体之外，还有第四个实体-地图服务器，它使您可以方便地处理世界状况。 它设置了我们描述地图的方式，使用地图时有什么可能性，并在许多方面决定了滑翔机的速度。 <br><br> 在继续介绍导航堆栈之前，最好概述一下为什么选择cost_map作为地图服务器的原因。 通常，我们为地图处理程序尝试了不同的选项： <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> ， <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> ， <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> ，但选择了后者。 <br><br> 原因： <br><br><ol><li> 方便地与地图互动。 </li><li> 我们需要各种形式（圆形，线性，矩形等）的迭代器。 </li><li> 您可以使用不同的参数存储多个地图图层。 </li><li> 良好的内存管理。 </li><li> 最重要的是速度。 网格地图可使用双精度类型，因此，它比使用int8起作用的那些地图服务器要慢几倍。 </li></ol><br> 尽管Occupancy网格也可以与int8一起使用，但是它不能拥有相同的可用性，因此我不得不放弃它。 <br><br> 从地图上，我们需要知道自由，危险和不可抗拒的区域在哪里。 对于场上的每个对象，我们都可以调整充气场-该值取决于与对象的距离，该值表示单元的渗透性。 通货膨胀是猫的尾巴，很容易注意到，但您会后悔很长一段时间。 我们为敌方机器人绘制地图，并添加仅本地计划人员考虑的危险区域。 全球规划师将忽略所有要点，如果它们不是障碍。 <br><br><h4> 全球规划师 </h4><br> 他们在导航中写的第一件事是全球规划师。 它基于theta *算法。 简而言之，这是一个修改后的<a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> ，其重点是找到可以直接到达的父节点，即 她没有任何障碍。 这使我们能够构建在本地计划程序中使用的方便且平滑的路径。 <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>A *和theta *的比较</i> <br><br> 对于全局规划师，我们有一个带有参数的文件（params / path_planner.yaml），该文件描述地图主题和所有机器人的位置的主题（对于现场的所有四个机器人，其中“ null”是带有有关当前机器人数据的主题）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br> 它还表明： <br><br><ol><li> 您可以选择的一种算法来构建路线， </li><li> 我们将在其自身上构建路线的图层的名称， </li><li> 一个关于我们位置的主题，在该位置发布已过滤的数据（在我们的情况下，它是来自照相机和里程表的位置数据的组合）。 </li></ol><br> 路径搜索算法本身-Theta Star-在单独的文件（src / global_planner.cpp）中突出显示，以方便添加新算法： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br> 删除RamerDouglasPeucker路径上多余点的算法也分配给单独的文件。 <br> 如果距连接两个相邻点的线的距离超出给定距离，它将从路径中删除点。 <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4> 当地规划师 </h4><br> 他在势场的梯度下降基础上为我们工作。 作为输入，来自全局计划程序的路径。 但是，这还不是他所能做到的。 在local_planner中，有用于选择路径构造模式的内部服务。 总共有两种操作模式：在地图上使用多次通过沿梯度平移点的模式以及平移模式，在平移模式下，我们立即在两个坐标中计算增量并将该点移动到安全区的边缘。 如果该点落入多个此类区域，则我们将移至其交点的位置，因为在那里最安全。 <br><br> 操作模式如下：如果上一次迭代的路径中没有障碍物，则我们每2 cm断开路径，然后沿梯度移动它，否则我们使用第二个局部规划器操作模式。 <br><br> 第二个选项非常轻巧，并且像全局计划器一样，不会过多地加载处理器。 我们对地图使用了该算法的多个版本以及各种操作。 例如，我们尝试编写一个图形，在该图形中，每隔10 cm会找到一个顶点，并且顶点之间的最大偏移量为4 cm，然后在获得的图形上使用Dijkstra算法查找最小的距离。 在这种情况下，端点使用最近的偏移点。 但是这种算法更适合全局规划人员，因此我们决定放弃此实现。 <br><br> 我们还尝试使用梯度下降法从头开始使用路径构建。 该方法是我们决定编写的第一个方法。 结果证明内存效率不高（它占用了超过400 mb的纯RAM，因为它每次都使用了成本映射）并且速度很慢。 由于优化不佳而关闭了频率控制，并且速度低于每秒30次，这不适合我们。 <br><br> 结果，我们决定根据整体刨床的路径在势场中使用梯度下降。 事实证明，这是一种轻量级且相对简单的算法，在路径质量，工作时间和100-150 mb区域内使用的RAM量方面完全适合我们，这比开发的第一次迭代少了几倍。 <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>本地平面铣刀偏移路径的示例</i> <br><br> 与global_planner不同，local_planner中的参数非常小，这是因为它很简单，因为所有最重要的任务都由global_planner承担： <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br> 在这种情况下，我们配置： <br><br><ul><li> 每个机器人的安全区域半径。 </li><li> 本地刨床的最大路径偏移量。 </li><li> 我们正在使用的地图图层的名称。 </li></ul><br> 在一个单独的类中，分配了所有最重要的功能。 在这种情况下，这是路径的递归分解，创建滑翔机以及虚拟构造函数和析构函数。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  LocalPlanning类是从该类继承而来的，该类是滑翔机整个核心所在的位置，即，将点移动到安全区的边缘，并具体决定如何处理该路径。 <br><br> 所有其他功能在单独的文件fichi.hpp中突出显示，并且梯度下降在potential_field.hpp中。 以下是此文件的快照，其中显示了在cost_map映射上创建潜在字段的功能： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4> 轨迹调节器 </h4><br> 最后但并非最不重要的是轨迹调节器。 他负责将本地计划程序路径转换为路径，并给出当前步骤的速度。 <br><br> 我们在Eurobot 2018决赛中使用的第一个版本是加速和制动pid控制器的混合体，其中矢量相对于到终点的距离归一化为沿途的下一个点。 <br><br> 简而言之，PID控制器是有助于修复系统的系统三个状态和有时会出现的随机错误的总和。 <br><br> 这些函数是根据经验选择的，并且取决于到路径终点的距离（它可以是二次方，三次方，逆方，但是我们定为二次方）。 这行得通，但唯一不适合我们的是机器人无法以每秒0.7米以上的速度及时制动。 因此，当时间到来时，我们决定重建整个算法。 <br><br> 通往新轨迹的第一个迭代是替换我们要去的向量。 现在它是下三个系数不同的向量的总和。 第二次迭代是编写最小混蛋。 简而言之，这是第5次多项式的构造，其中x和y坐标取决于到达每个点的时间。 <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>该图显示了坐标之一与时间的关系图，以及沿该坐标的速度</i> <br><br> 这种类型的轨迹调节器更适合我们，因为它需要较少的操作来选择不同的系数，因为所有系数都是多项式中的值，这些值是根据到达时间，当前速度和加速度，输出速度和加速度来计算的。 <br><br> 轨迹重写的结果是我们设法使机器人的平均速度提高了一倍。 <br><br> 与前两种情况一样，所有主要功能都在单独的文件中突出显示，以便于交互。 这次，PlannerTrajectory类负责基于MinimumJerk构造轨迹 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>照片显示了我们使用的所有已声明的变量。</i> <br><br> 其他所有内容都在另一个文件（包括/ trajectory_regulator.h）中突出显示：从主题接收点，确定是否要到达下一个点（如果有障碍，那么我们就不走），等等。 <br><br><h3> 迁移到ROS Melodic </h3><br> 直到去年，我们才使用ROS的LTE版本-ROS Kinetic。 他通常适合我们，但他的支持将在明年结束，并且我们需要的许多软件包开始专门针对ROS Melodic提供。 然后事实证明，我们使用的costmap_server不在Melodic之下。 <br><br> 处理卡中的数据时出现问题。 <br><br> 我们选择了Grid地图，因为堆栈是相似的，但是地图的开头在不同的位置，并且地图本身的值从0到1不等。这已成为整个导航堆栈中的大问题。 如果早些时候全局规划器每秒启动50次（存在频率限制，因此即使在一个线程的一半中也不会使用太多处理器），现在每两秒钟铺路并认为它不好：它完全加载了一个内核。 在2秒内，机器人可以越过整个地图。 这不适合我们，并且尝试并行化此过程的尝试均以失败告终，因为这样一来，其他项目就没有性能可言（考虑到并行化的成本）。 <br><br> 我们决定再次更改堆栈，放弃网格图，转而使用占用网格。 出现了一个新问题-无法同时存储多个版本的地图（例如，具有所有障碍的完整地图以及仅具有动态障碍的静态地图）。 我将不得不更改一半的代码，这并不是特别可靠。 因此，我们决定为该问题寻找替代解决方案。 <br><br><h4> 成本图服务器 </h4><br> 经过长时间的搜索，我们发现了分叉地图costmap_serverr： <a href="" rel="nofollow">https</a> : <a href="" rel="nofollow">//github.com/lelongg/cost_map.git-</a>对我们的分叉系统非常有用。 <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br> 现在，我们不再仅仅为栅格地图提供服务，而是为了交付，我们设法根据卡尔曼滤波器的预测来计算敌人的可能位置。 <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br> 地图服务器最重要的事情之一就是地图文件，该文件用于初始创建所有图层，随后仅对其进行更新。 这是一个二进制png图片，其中黑色是障碍物，白色是自由区。 <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br> 还有一个用于cost_map_server配置的设置文件。 它包含带有敌人要点，通货膨胀区和正方形大小的主题，还可以用于在地图上放置敌人的危险区。 <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br> 仅当有人订阅所有图层时，才会发布所有图层： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3> 在电脑上运行 </h3><br> 要启动整个堆栈，您必须： <br><br><ul><li> 放ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch-启动地图 </li><li>  roslaunch global_planner global_planner.launch-使用参数启动全局刨床 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam加载$（找到local_planner）/param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trajectory_regulator rosjectory_regulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner移动器 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 罗斯伦·维兹 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加通胀层 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在向主题/ gp /目标发送消息，我们将机器人发送至所需位置 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动所有项目的结果是，您将进行仿真以准备在计算机上启动我们的堆栈。</font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要的叉子</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初，我们需要导航，以帮助我们的机器人在全向轮上精美，快速，准确地行驶。</font><font style="vertical-align: inherit;">在比赛的准备过程中，没有一只猫受伤，而且机器人很帅。</font><font style="vertical-align: inherit;">因此，我们拥有一个类似于Eurobot的轻量级导航堆栈，我们对此感到非常满意。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于我们来说，此堆栈比标准堆栈要好，但是... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的电报：t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们所有创造力的存储库</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479636/">https://habr.com/ru/post/zh-CN479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479620/index.html">逆逻辑</a></li>
<li><a href="../zh-CN479622/index.html">Waves区块链上的匿名交易原型如何工作</a></li>
<li><a href="../zh-CN479624/index.html">Postgres专业宪兵Oleg Bartunov向Faride Roslovets介绍了PostgreSQL和俄罗斯的业务</a></li>
<li><a href="../zh-CN479626/index.html">共振器，物理学家不知道</a></li>
<li><a href="../zh-CN479630/index.html">争取关注</a></li>
<li><a href="../zh-CN479642/index.html">设计第二次世界大战的飞机时愚蠢的决定如何导致了Macintosh的诞生</a></li>
<li><a href="../zh-CN479644/index.html">关于程序化的简单词汇</a></li>
<li><a href="../zh-CN479646/index.html">中级后继续学习英语的不好建议或理由</a></li>
<li><a href="../zh-CN479650/index.html">前12个最有趣的IT动态动态图表</a></li>
<li><a href="../zh-CN479654/index.html">Django Vue生成器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>