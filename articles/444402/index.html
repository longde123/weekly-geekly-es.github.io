<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôç üìà ‚úåüèª C√≥digo de reacci√≥n dividido en 2019 üëâüèø üí´ üßõüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Es 2019! Todos piensan que conocen la divisi√≥n de c√≥digo. Entonces, ¬°revisemos dos veces! 



 ¬øQu√© significa la divisi√≥n de c√≥digo? 


 En resumen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥digo de reacci√≥n dividido en 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444402/"><p>  ¬°Es 2019!  Todos piensan que conocen la divisi√≥n de c√≥digo.  Entonces, ¬°revisemos dos veces! </p><br><p><img src="https://habrastorage.org/webt/da/lx/0b/dalx0bnbenxiqebdymmcrp8in68.png"></p><br><h2 id="what-does-code-splitting-stand-for">  ¬øQu√© significa la divisi√≥n de c√≥digo? </h2><br><p>  En resumen, la divisi√≥n de c√≥digo consiste en no cargar todo.  Entonces est√°s leyendo esta p√°gina, no tienes que cargar un sitio completo.  Cuando selecciona una sola fila de una base de datos, no tiene que tomar todo. <br>  Obvio?  La divisi√≥n del c√≥digo tambi√©n es bastante obvia, no solo sobre sus datos, sino sobre su c√≥digo. </p><a name="habracut"></a><br><h2 id="whowhat-is-making-code-splitting">  ¬øQui√©n (¬øQu√©?) ¬øEst√° dividiendo el c√≥digo? </h2><br><p> <code>React.lazy</code> ?  No, solo lo usa.  La divisi√≥n de c√≥digo se realiza en un nivel de paquete: paquete web, parcela o simplemente su sistema de archivos en el caso de m√≥dulos esm "nativos".  La divisi√≥n de c√≥digo es solo archivos, archivos que puede cargar en alg√∫n lugar "m√°s tarde".  Entonces, a las preguntas " <strong>¬øQu√© es la divisi√≥n de c√≥digo de alimentaci√≥n?</strong> ", La respuesta es: un "paquete". </p><br><h2 id="whowhat-is-using-code-splitting">  ¬øQui√©n (Qu√©) est√° usando la divisi√≥n de c√≥digo? </h2><br><p>  <code>React.lazy</code> est√° usando.  Simplemente usando la divisi√≥n de c√≥digo de su paquete.  Simplemente llamando a import cuando se proces√≥.  Y eso es todo. </p><br><h2 id="whats-about-react-loadable">  ¬øQu√© hay de React-loadable? </h2><br><p>  <code>React.lazy</code> reemplaz√≥.  Y proporcion√≥ m√°s funciones, como <code>Suspense</code> para controlar el estado de carga.  Entonces, use <code>React.Lazy</code> en <code>React.Lazy</code> lugar. </p><br><blockquote>  S√≠, eso es todo.  Gracias por leer y que tengas un buen d√≠a. </blockquote><br><h2 id="why-article-is-not-finished">  ¬øPor qu√© el art√≠culo no est√° terminado? </h2><br><p>  Bueno  Hay algunas zonas grises sobre <code>React.lazy</code> y la divisi√≥n de c√≥digo que olvid√© mencionar. </p><br><h3 id="grey-zone-1--testing">  Zona gris 1 - prueba </h3><br><p>  No es f√°cil probar <code>React.lazy</code> debido a su <em>asincron√≠a</em> .  Estar√≠a simplemente "vac√≠o", siempre y cuando todav√≠a no est√© cargado (incluso si lo est√°): <code>Promises</code> e devoluciones de <code>import</code> , y acepta perezosamente, <strong>promesas</strong> , que siempre se ejecutaron en el <strong>siguiente tic</strong> . </p><br><p>  ¬øSoluci√≥n propuesta?  No lo creer√≠a, pero la soluci√≥n propuesta es utilizar <em>thenables</em> sincr√≥nicos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte la solicitud de extracci√≥n</a> .  Entonces, ¬°hagamos que nuestras <code>imports</code> SINCR√ìNICAS!  <em>(para solucionar un problema vago para las pruebas o cualquier otro caso del lado del servidor)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LazyText = lazy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ then(cb) { cb({<span class="hljs-attr"><span class="hljs-attr">default</span></span>: Text}); <span class="hljs-comment"><span class="hljs-comment">// this is "sync" thenable }, })); const root = ReactTestRenderer.create( &lt;Suspense fallback={&lt;Text text="Loading..." /&gt;}&gt; &lt;LazyText text="Hi" /&gt; // this lazy is not very lazy &lt;/Suspense&gt;, );</span></span></code> </pre> <br><p>  No es dif√≠cil convertir la funci√≥n de importaci√≥n en una funci√≥n sincronizable memorizable. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> syncImport = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importFn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> preloaded = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = importFn().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> preloaded = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ^ "auto" import and "cache" promise return () =&gt; preloaded ? { then: () =&gt; preloaded } : promise; // ^ return sync thenable then possible } const lazyImport = isNode ? syncImport : a =&gt; a; // ^ sync for node, async for browser const LazyComponent = React.lazy(lazyImport(() =&gt; import('./file'));</span></span></code> </pre> <br><h3 id="grey-zone-2--ssr">  Zona gris 2 - SSR </h3><br><blockquote>  Si NO necesita SSR, ¬°contin√∫e leyendo el art√≠culo! </blockquote><p>  <code>React.lazy</code> es <code>React.lazy</code> SSR.  Pero requiere <code>Suspense</code> para funcionar, y Suspenso <strong>NO</strong> es <strong>amigable con el servidor</strong> . </p><br><p>  Hay 2 soluciones: </p><br><ul><li>  Reemplace Suspenso con Fragmento, por ejemplo, a trav√©s de la burla.  Luego, use la versi√≥n alterada de <code>import</code> with synchronous para hacer que la perezosa tambi√©n se comporte sincr√≥nicamente. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realLazy = React.lazy; React.lazy = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importer</span></span></span><span class="hljs-function"> =&gt;</span></span> realLazy(syncImport(importer)); React.Suspense = React.Fragment; <span class="hljs-comment"><span class="hljs-comment">// :P // ^ React SSR just got fixed :D</span></span></code> </pre> </li></ul><br><p>  Esta es una buena opci√≥n, pero no ser√≠a del todo amigable para el cliente.  Por qu√©  Definamos la segunda soluci√≥n posible: </p><br><ul><li>  Use una <strong>biblioteca especializada</strong> para rastrear los scripts, fragmentos y estilos usados, y c√°rguelos en el lado del cliente (¬°especialmente los estilos!) Antes de reaccionar la hidrataci√≥n.  O bien, representar√≠a agujeros vac√≠os en lugar de sus componentes divididos en c√≥digo.  Una vez m√°s, no carg√≥ el c√≥digo que acaba de dividir, por lo que no puede procesar nada de lo que va a hacer. </li></ul><br><h3 id="behold-code-splitting-libraries">  He aqu√≠ las bibliotecas de divisi√≥n de c√≥digo </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Componente universal</a> : la biblioteca m√°s antigua y a√∫n mantenible.  "Invent√≥" la divisi√≥n de c√≥digo en t√©rminos de Webpack ense√±ado a la divisi√≥n de c√≥digo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cargable por reacci√≥n</a> : muy popular, pero una biblioteca sin mantenimiento.  Hizo que el c√≥digo escupiera algo popular.  Los problemas est√°n cerrados, por lo que no hay comunidad alrededor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Componentes cargables</a> : una biblioteca completa de funciones, es un placer usarla, con la comunidad m√°s activa. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Componente importado</a> : una biblioteca √∫nica, no vinculada a Webpack, es decir, capaz de manejar parcela o esm. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Componente React-async</a> : biblioteca ya muerta (pero popular), que tuvo un impacto significativo en todo lo relacionado con la divisi√≥n de c√≥digo, el recorrido personalizado del √°rbol React y la SSR. </li><li>  <em>Otra biblioteca, hab√≠a muchas bibliotecas, muchas de las cuales no sobrevivieron a la evoluci√≥n de Webpack o React 16, no las he enumerado aqu√≠, pero si conoces a un buen candidato, solo env√≠ame un mensaje.</em> </li></ul><br><h3 id="which-library-to-pick">  ¬øQu√© biblioteca elegir? </h3><br><p>  Es f√°cil, <strong>no reacciona cargable</strong> , es pesado, sin mantenimiento y obsoleto, incluso si todav√≠a es mega popular.  (y gracias por popularizar la divisi√≥n de c√≥digo, una vez m√°s) </p><br><p>  <em>Componentes cargables</em> : puede ser una muy buena opci√≥n.  Est√° muy bien escrito, se mantiene activamente y admite todo de forma inmediata.  Admite "importaciones din√°micas completas", lo que le permite importar archivos dependiendo de los accesorios proporcionados, pero por lo tanto no se pueden tipificar.  Admite suspenso, por lo que podr√≠a reemplazar React.lazy. </p><br><p>  <em>Componente universal</em> , en realidad "inventores" de importaciones din√°micas completas, lo implementaron en Webpack.  Y muchas otras cosas a bajo nivel, lo hicieron.  Yo dir√≠a que esta biblioteca es un poco dura y un poco menos f√°cil de usar.  La documentaci√≥n de los componentes cargables es inmejorable.  Vale la pena si no usa esta biblioteca, luego lea la documentaci√≥n: hay tantos detalles que debe saber ... </p><br><p>  <em>Componente importado por reacci√≥n</em> : es un poco extra√±o.  Es independiente del paquete, por lo que nunca se romper√≠a (no hay nada que romper), funcionar√≠a con Webpack 5 y 55, pero eso tiene un costo.  Mientras que las bibliotecas anteriores durante SSR agregar√≠an todas las secuencias de comandos utilizadas al cuerpo de la p√°gina, y podr√° cargar todas las secuencias de comandos en paralelo: los nombres de archivos no conocidos importados y llamar√°n a las "importaciones" originales (por eso paquete independiente) para cargar fragmentos usados, pero solo puede realizar llamadas desde el paquete principal, por lo que todos los scripts adicionales se cargar√°n solo despu√©s de que se descargue y ejecute el principal.  No admite importaciones din√°micas completas, como React.lazy y, como resultado, puede escribirse.  Tambi√©n es compatible con suspenso.  Utiliza <em>thenables</em> sincr√≥nicos en SSR.  Tambi√©n tiene un enfoque absolutamente diferente para CSS y un soporte perfecto para la representaci√≥n de secuencias. </p><br><p>  No hay diferencia en calidad o popularidad entre las bibliotecas que figuran en la lista, y todos somos buenos amigos, as√≠ que elige de todo coraz√≥n. </p><br><h2 id="grey-zone-3--hybrid-render">  Zona gris 3 - render h√≠brido </h2><br><p>  SSR es algo bueno, pero, ya sabes, dif√≠cil.  Los proyectos peque√±os pueden querer tener un SSR, hay muchas razones para tenerlo, pero es posible que no quieran configurarlo y mantenerlo. </p><br><blockquote>  SSR podr√≠a ser realmente, REALMENTE dif√≠cil.  Prueba razzle o ve con Next.js si quieres una victoria r√°pida. </blockquote><p>  Por lo tanto, la soluci√≥n m√°s f√°cil para SSR, especialmente para un SPA simple, ser√≠a la representaci√≥n previa.  Como abrir su SPA en un navegador y presionar el bot√≥n "Guardar".  Como: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React-snap</a> : utiliza el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">titiritero</a> (tambi√©n conocido como Chrome sin cabeza) para representar su p√°gina en un "navegador" y guarda un resultado como una p√°gina HTML est√°tica. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rendertron</a> : que hace lo mismo, pero de una manera diferente (en la <em>nube</em> ). </li></ul><br><p>  La representaci√≥n previa es "SSR" sin "Servidor".  Es SSR usando un Cliente.  Magia!  Y trabajando fuera de la caja ... ... ... pero no para escupir c√≥digo. <br>  Entonces, acabas de renderizar tu p√°gina en un navegador, guardaste HTML y pediste cargar las mismas cosas.  Pero no se us√≥ el c√≥digo espec√≠fico del lado del servidor (para recopilar todos los fragmentos usados), ¬°porque <strong>NO HAY SERVIDOR</strong> ! </p><br><p><img src="https://habrastorage.org/webt/tr/sz/9i/trsz9i4ct8jc7cnwxtm-ljnepuq.png"></p><br><p>  En la parte anterior, he se√±alado las bibliotecas que est√°n vinculadas a webpack en t√©rminos de recopilaci√≥n de informaci√≥n sobre fragmentos usados: no pod√≠an manejar el renderizado h√≠brido en absoluto. </p><br><blockquote>  La versi√≥n 2 de componentes cargables (incompatible con la versi√≥n 5 actual) fue parcialmente compatible con react-snap.  El apoyo se ha ido. </blockquote><p>  El componente importado por reacci√≥n podr√≠a manejar este caso, siempre y cuando no est√© unido al paquete / lado, por lo que no hay diferencia para SSR o h√≠brido, sino solo para reacci√≥n instant√°nea, siempre que sea compatible con la "hidrataci√≥n del estado", mientras que el rendertron no. </p><br><blockquote>  Esta capacidad de reaccionar-componente importado se encontr√≥ durante la redacci√≥n de este art√≠culo, no se conoc√≠a antes - ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a>  Es muy facil. </blockquote><p>  Y aqu√≠ debe usar otra soluci√≥n, que es perpendicular a todas las dem√°s bibliotecas. </p><br><h3 id="react-prerendered-component">  Componente de reacci√≥n previa </h3><br><p>  Esta biblioteca fue creada para una hidrataci√≥n parcial y podr√≠a rehidratar parcialmente su aplicaci√≥n, manteniendo el resto a√∫n deshidratado.  Y funciona para renderizadores SSR e h√≠bridos sin ninguna diferencia. <br>  La idea es simple: </p><br><ul><li>  durante SSR: renderice el componente, envuelto con un &lt;div /&gt; </li><li>  en el cliente: busque ese div y use innerHTML hasta que Component est√© listo para reemplazar HTML muerto. </li><li>  no tiene que cargar, y espere un trozo con un componente dividido antes de <code>hydrate</code> para <em>NO generar un agujero blanco en su lugar</em> , solo use HTML pre-renderizado, que es absolutamente igual al que representar√≠a <em>un componente real</em> , y que ya existe: viene con una respuesta de servidor (o hidrid). </li></ul><br><blockquote>  Es por eso que tenemos que esperar a que se carguen todos los fragmentos antes de hidratarse, para que <strong>coincida</strong> con el HTML renderizado por el servidor.  Es por eso que podr√≠amos usar piezas de HTML renderizado por el servidor hasta que el cliente no est√© listo: es igual al que solo vamos a producir. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PrerenderedComponent} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-prerendered-component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importer = memoizeOne(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Component'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ^ it's very important to keep the "one" promise const Component = React.lazy(importer); // or use any other library with ".prefetch" support // all libraries has it (more or less) const App = () =&gt; ( &lt;PrerenderedComponent live={importer()}&gt; {/* ^ shall return the same promise */ } &lt;Component /&gt; {/* ^ would be rendered when a component goes "live" */ } &lt;/PrerenderedComponent&gt; );</span></span></code> </pre> <br><p>  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro art√≠culo sobre esta tecnolog√≠a</a> , puede leer.  Pero lo principal aqu√≠ es que resuelve "Flash de contenido descargado" en otro, no es una forma com√∫n de <em>bibliotecas de divisi√≥n de c√≥digo</em> .  Est√© abierto a nuevas soluciones. </p><br><h3 id="tldr">  TLDR? </h3><br><ul><li>  no use react-loadable, no agregar√≠a ning√∫n valor valioso </li><li>  React.lazy es bueno, pero demasiado simple todav√≠a. </li><li>  SSR es algo dif√≠cil, y debes saberlo </li><li>  El renderizado h√≠brido dirigido por titiriteros es una cosa.  A veces algo a√∫n m√°s dif√≠cil. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444402/">https://habr.com/ru/post/444402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444392/index.html">Radiaci√≥n: riesgos, seguridad, protecci√≥n.</a></li>
<li><a href="../444394/index.html">Linux Foundation lanza un nuevo proyecto DevOps con Jenkins y Spinnaker</a></li>
<li><a href="../444396/index.html">Stand de Epson en ISE 2019: la exposici√≥n ha pasado, las impresiones permanecen</a></li>
<li><a href="../444398/index.html">¬øPor qu√© las tiendas no alimentarias necesitan una organizaci√≥n de autoservicio?</a></li>
<li><a href="../444400/index.html">C√≥mo reescrib√≠ un motor de b√∫squeda de vuelos de PHP a NodeJS</a></li>
<li><a href="../444404/index.html">¬øPor qu√© tenemos miedo a los robots?</a></li>
<li><a href="../444406/index.html">Italia digital. Que y como funciona</a></li>
<li><a href="../444408/index.html">Apple lanz√≥ ayer nuevos iPads y tiene preguntas.</a></li>
<li><a href="../444410/index.html">Mapas de red. Una breve descripci√≥n del software para construir mapas de red</a></li>
<li><a href="../444414/index.html">Snapdragon 8cx: plataforma de PC de 7 nm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>